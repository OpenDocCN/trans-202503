<html><head></head><body>
		<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_99"/><strong><span class="big">5</span></strong><br/><strong>TOOLS FOR ANALYZING COMPILER OUTPUT</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">In order to write great code, you must be able to recognize the difference between programming language sequences that do their job more or less adequately and those that are great. In the context of our discussion, great code sequences use fewer instructions, fewer machine cycles, or less memory than mediocre code sequences. If you’re working in assembly language, the CPU manufacturers’ data sheets and a bit of experimentation are all it takes to determine which code sequences are great and which are not. When working with HLLs, however, you need some way of mapping the high-level language statements in a program to the corresponding machine code, so that you can determine the quality of those HLL statements. In this chapter, we’ll discuss how to:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">View and analyze a compiler’s machine language output so you can use that information to write better HLL code</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Tell certain compilers to produce a human-readable assembly language output file</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_100"/>&#13;
			<p class="noindent">Analyze binary object output files using tools such as <code>dumpbin</code> and <code>objdump</code></p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">Use a disassembler to examine the machine code output a compiler produces</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Use a debugger to analyze compiler output</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Compare two different assembly language listings for the same HLL source file to determine which version is better</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Analyzing compiler output is one of the principal skills you’ll need in order to distinguish great machine code from merely sufficient machine code. To analyze compiler output, you’ll need to learn a couple of things. First, you’ll need to learn enough assembly language programming so that you can effectively read compiler output.<sup><a id="ch5fn_1"/><a href="footnotes.xhtml#ch5fn1">1</a></sup> Second, you’ll need to learn how to tell a compiler (or some other tool) to produce human-readable assembly language output. Finally, you’ll have to learn how to correlate the assembly instructions with the HLL code. <a href="ch03.xhtml#ch03">Chapters 3</a> and <a href="ch04.xhtml#ch04">4</a> gave you the foundation you need to read some basic assembly code. This chapter discusses how to translate compiler output into a human-readable form. And the rest of this book deals with analyzing that assembly code so you can generate better machine code by wisely choosing your HLL statements.</p>&#13;
		<p class="indent">Let’s begin with some background on compiler output and things to keep in mind for optimization.</p>&#13;
		<h3 class="h3" id="ch00lev1sec41"><strong>5.1 Background</strong></h3>&#13;
		<p class="noindent">As <a href="ch04.xhtml#ch04">Chapter 4</a> discussed, most compilers available today emit object code output that a linker program reads and processes in order to produce an executable program. Because the object code file generally consists of binary data that is not human-readable, many compilers also provide an option to produce an assembly language version of the output code. By activating this option, you can analyze the compiler’s output and, if necessary, refine your HLL source code accordingly. Indeed, with a specific compiler and a thorough knowledge of its optimizations, you can write HLL source code that compiles to machine code that’s almost as good as the best handwritten assembly language code. Although you can’t expect such optimizations to work with every compiler, this trick enables you to write good code with one compiler that will still be able to run (though possibly less efficiently) on other processors. This is an excellent solution for code that needs to run as efficiently as possible on a certain class of machines but still needs to run on other CPUs.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>Keep in mind that examining compiler output may lead you to implement nonportable optimizations. That is, when you examine your compiler’s output you might decide to modify your HLL source code to produce better output; however, those optimizations might not carry over to a different compiler.</em></p>&#13;
		</div>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_101"/>The ability to emit assembly language output is compiler specific. Some compilers do so by default. GCC, for example, always emits an assembly language file (though it typically deletes that file after the compilation). Most compilers, however, must be explicitly told to produce an assembly language listing. Some compilers produce an assembly listing that can be run through an assembler to produce object code. Some compilers may only produce assembly annotation in a listing file, and that “assembly code” is not syntax-compatible with any existing assembler. For your purposes, it doesn’t matter if a real-world assembler is capable of processing the compiler’s assembly output; you’re only going to read that output to determine how to tweak the HLL code to produce better object code.</p>&#13;
		<p class="indent">For those compilers that can produce assembly language output, the readability of the assembly code varies considerably. Some compilers insert the original HLL source code into the assembly output as comments, which makes it easy to correlate the assembly instructions with the HLL code. Other compilers (such as GCC) emit pure assembly language code; so, unless you’re well versed in the particular CPU’s assembly language, analyzing the output can be difficult.</p>&#13;
		<p class="indent">Another problem that may affect the readability of the compiler output is the optimization level you choose. If you disable all optimizations, it is often easier to determine which assembly instructions correspond to the HLL statements. Unfortunately, with the optimizations turned off, most compilers generate low-quality code. If the purpose of viewing assembly output from a compiler is to choose better HLL sequences, then you must specify the same optimization level that you will use for the production version of your application. You should never tweak your high-level code to produce better assembly code at one optimization level and then change the optimization level for your production code. If you do, you may wind up doing extra work that the optimizer would normally do for you. Worse, those manual optimizations could actually prevent the compiler from doing a decent job when you increase its optimization level.</p>&#13;
		<p class="indent">When you specify a higher level of optimization for a compiler, the compiler will often move code around in the assembly output file, eliminate code entirely, and do other code transformations that obfuscate the correspondence between the high-level code and the assembly output. Still, with a bit of practice, you can determine which machine instructions correspond to a given statement in the HLL code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec42"><strong>5.2 Telling a Compiler to Produce Assembly Output</strong></h3>&#13;
		<p class="noindent">How you tell a compiler to emit an assembly language output file is specific to the compiler. For that information, you’ll need to consult the documentation for your particular compiler. This section will look at two commonly used C/C++ compilers: GCC and Microsoft’s Visual C++.</p>&#13;
		<h4 class="h4" id="ch00lev2sec58"><span epub:type="pagebreak" id="page_102"/><strong>5.2.1 Assembly Output from GNU Compilers</strong></h4>&#13;
		<p class="noindent">To emit assembly output with the GCC compiler, you specify the <code>-S</code> option on the command line when invoking the compiler. Here is a sample command line for GCC:</p>&#13;
		<pre class="programs">gcc -O2 -S t1.c     # -O2 option is for optimization</pre>&#13;
		<p class="indent">When supplied to GCC, the <code>-S</code> option doesn’t actually tell the compiler to produce an assembly output file. GCC <em>always</em> produces an assembly output file. The <code>-S</code> simply tells GCC to stop all processing after it has produced an assembly file. GCC will produce an assembly output file whose root name is the same as the original C file (<em>t1</em> in these examples) with a <em>.s</em> suffix (during normal compilation, GCC deletes the <em>.s</em> file after assembling it).</p>&#13;
		<h4 class="h4" id="ch00lev2sec59"><strong>5.2.2 Assembly Output from Visual C++</strong></h4>&#13;
		<p class="noindent">The Visual C++ compiler (VC++) uses the -<code>FA</code> command-line option to specify MASM-compatible assembly language output. The following is a typical command line to VC++ to tell it to produce an assembly listing:</p>&#13;
		<pre class="programs">cl -O2 -FA t1.c</pre>&#13;
		<h4 class="h4" id="ch00lev2sec60"><strong>5.2.3 Example Assembly Language Output</strong></h4>&#13;
		<p class="noindent">As an example of producing assembly language output from a compiler, consider the following C program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv )<br/>{<br/>    int i;<br/>    int j;<br/><br/>    i = argc;<br/>    j = **argv;<br/><br/><br/>    if( i == 2 )<br/>    {<br/>        ++j;<br/>    }<br/>    else<br/>    {<br/>        --j;<br/>    }<br/><br/>    printf( "i=%d, j=%d\n", i, j );<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_103"/>The following subsections provide the compiler output for Visual C++ and GCC from this code sequence in order to highlight the differences between their respective assembly language listings.</p>&#13;
		<h5 class="h5" id="ch00lev3sec30"><strong>5.2.3.1 Visual C++ Assembly Language Output</strong></h5>&#13;
		<p class="noindent">Compiling this file with VC++ using the command line</p>&#13;
		<pre class="programs">cl -Fa -O1 t1.c</pre>&#13;
		<p class="noindent">produces the following (MASM) assembly language output.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>The exact meaning of each assembly language statement appearing in this output isn’t important—yet! What’s important is seeing the difference between the syntax in this listing and the listings for Visual C++ and Gas that appear in the following sections.</em></p>&#13;
		</div>&#13;
		<pre class="programs">&#13;
			; Listing generated by Microsoft (R) Optimizing<br/>; Compiler Version 19.00.24234.1<br/>; This listing is manually annotated for readability.<br/><br/>include listing.inc<br/><br/>INCLUDELIB LIBCMT<br/>INCLUDELIB OLDNAMES<br/><br/>PUBLIC  __local_stdio_printf_options<br/>PUBLIC  _vfprintf_l<br/>PUBLIC  printf<br/>PUBLIC  main<br/>PUBLIC  ??_C@_0M@MJLDLLNK@i?$DN?$CFd?0?5j?$DN?$CFd?6?$AA@ ; `string'<br/>EXTRN   __acrt_iob_func:PROC<br/>EXTRN   __stdio_common_vfprintf:PROC<br/>_DATA   SEGMENT<br/>COMM    ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD                                                    ; `__local_stdio_printf_options'::`2'::_OptionsStorage<br/>_DATA   ENDS<br/>;       COMDAT pdata<br/>pdata   SEGMENT<br/>    .<br/>    .<br/>    .<br/>;       COMDAT main<br/>_TEXT   SEGMENT<br/>argc$ = 48<br/>argv$ = 56<br/>main    PROC                                            ; COMDAT<br/><br/>$LN6:<br/>        sub     rsp, 40                                 ; 00000028H<br/><br/>; if( i == 2 )<br/>;{<br/>;    ++j;<br/><span epub:type="pagebreak" id="page_104"/>;}<br/>;else<br/>;{<br/>;    --j<br/>;}<br/><br/>        mov     rax, QWORD PTR [rdx]   ; rax (i) = *argc<br/>        cmp     ecx, 2<br/>        movsx   edx, BYTE PTR [rax]    ; rdx(j) = **argv<br/><br/>        lea     eax, DWORD PTR [rdx-1] ; rax = ++j<br/>        lea     r8d, DWORD PTR [rdx+1] ; r8d = --j;<br/><br/>        mov     edx, ecx               ; edx = argc (argc was passed in rcx)<br/>        cmovne  r8d, eax               ; eax = --j if i != 2<br/><br/>; printf( "i=%d, j+5d\n", i, j ); (i in edx, j in eax)<br/><br/>        lea     rcx, OFFSET FLAT:??_C@_0M@MJLDLLNK@i?$DN?$CFd?0?5j?$DN?$CFd?6?$AA@<br/>        call    printf<br/><br/>; return 0;<br/><br/>        xor     eax, eax<br/><br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS<br/>; Function compile flags: /Ogtpy<br/>; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h<br/>;       COMDAT printf<br/>_TEXT   SEGMENT<br/>    .<br/>    .<br/>    .<br/>    END</pre>&#13;
		<h5 class="h5" id="ch00lev3sec31"><strong>5.2.3.2 GCC Assembly Language Output (PowerPC)</strong></h5>&#13;
		<p class="noindent">Like Visual C++, GCC doesn’t insert the C source code into the assembly output file. In GCC’s case, it’s somewhat understandable: producing assembly output is something it always does (rather than something it does because of a user request). By not inserting the C source code into the output file, GCC can cut down compilation times by a small amount (because the compiler won’t have to write the C source code data and the assembler won’t have to read this data). Here’s the output of GCC for a PowerPC processor when using the command line <code>gcc -O1 -S t1.c</code>:</p>&#13;
		<pre class="programs">&#13;
			gcc -O1 -S t1.c<br/><br/>.data<br/>.cstring<br/><span epub:type="pagebreak" id="page_105"/>        .align 2<br/>LC0:<br/>        .ascii "i=%d, j=%d\12\0"<br/>.text<br/>        .align 2<br/>        .globl _main<br/>_main:<br/>LFB1:<br/>        mflr r0<br/>        stw r31,-4(r1)<br/>LCFI0:<br/>        stw r0,8(r1)<br/>LCFI1:<br/>        stwu r1,-80(r1)<br/>LCFI2:<br/>        bcl 20,31,L1$pb<br/>L1$pb:<br/>        mflr r31<br/>        mr r11,r3<br/>        lwz r9,0(r4)<br/>        lbz r0,0(r9)<br/>        extsb r5,r0<br/>        cmpwi cr0,r3,2<br/>        bne+ cr0,L2<br/>        addi r5,r5,1<br/>        b L3<br/>L2:<br/>        addi r5,r5,-1<br/>L3:<br/>        addis r3,r31,ha16(LC0-L1$pb)<br/>        la r3,lo16(LC0-L1$pb)(r3)<br/>        mr r4,r11<br/>        bl L_printf$stub<br/>        li r3,0<br/>        lwz r0,88(r1)<br/>        addi r1,r1,80<br/>        mtlr r0<br/>        lwz r31,-4(r1)<br/>        blr<br/>LFE1:<br/>.data<br/>.picsymbol_stub<br/>L_printf$stub:<br/>        .indirect_symbol _printf<br/>        mflr r0<br/>        bcl 20,31,L0$_printf<br/>L0$_printf:<br/>        mflr r11<br/>        addis r11,r11,ha16(L_printf$lazy_ptr-L0$_printf)<br/>        mtlr r0<br/>        lwz r12,lo16(L_printf$lazy_ptr-L0$_printf)(r11)<br/>        mtctr r12<br/>        addi r11,r11,lo16(L_printf$lazy_ptr-L0$_printf)<br/>        bctr<br/>.data<br/><span epub:type="pagebreak" id="page_106"/>.lazy_symbol_pointer<br/>L_printf$lazy_ptr:<br/>        .indirect_symbol _printf<br/>        .long dyld_stub_binding_helper<br/>.data<br/>.constructor<br/>.data<br/>.destructor<br/>        .align 1</pre>&#13;
		<p class="indent">As you can see, the output of GCC is quite sparse. Of course, as this is PowerPC assembly language, it’s not really practical to compare this assembly output to the 80x86 output from the Visual C++ compiler.</p>&#13;
		<h5 class="h5" id="ch00lev3sec32"><strong>5.2.3.3 GCC Assembly Language Output (80x86)</strong></h5>&#13;
		<p class="noindent">The following code provides the GCC compilation to x86-64 assembly code for the <em>t1.c</em> source file:</p>&#13;
		<pre class="programs">&#13;
			      .section    __TEXT,__text,regular,pure_instructions<br/>    .macosx_version_min 10, 13<br/>    .globl  _main                   ## -- Begin function main<br/>    .p2align    4, 0x90<br/>_main:                              ## @main<br/>    .cfi_startproc<br/>## BB#0:<br/>    pushq   %rbp<br/>Lcfi0:<br/>    .cfi_def_cfa_offset 16<br/>Lcfi1:<br/>    .cfi_offset %rbp, -16<br/>    movq    %rsp, %rbp<br/>Lcfi2:<br/>    .cfi_def_cfa_register %rbp<br/>    movl    %edi, %ecx<br/>    movq    (%rsi), %rax<br/>    movsbl  (%rax), %eax<br/>    cmpl    $2, %ecx<br/>    movl    $1, %esi<br/>    movl    $-1, %edx<br/>    cmovel  %esi, %edx<br/>    addl    %eax, %edx<br/>    leaq    L_.str(%rip), %rdi<br/>    xorl    %eax, %eax<br/>    movl    %ecx, %esi<br/>    callq   _printf<br/>    xorl    %eax, %eax<br/>    popq    %rbp<br/>    retq<br/>    .cfi_endproc<br/>                                        ## -- End function<br/>    .section    __TEXT,__cstring,cstring_literals<br/>L_.str:                                 ## @.str<br/><span epub:type="pagebreak" id="page_107"/>    .asciz  "i=%d, j=%d\n"<br/><br/>.subsections_via_symbols</pre>&#13;
		<p class="indent">This example should help demonstrate that the massive amount of code that GCC emitted for the PowerPC is more a function of the machine’s architecture than of the compiler. If you compare this to the code that other compilers emit, you’ll discover that it is roughly equivalent.</p>&#13;
		<h5 class="h5" id="ch00lev3sec33"><strong>5.2.3.4 GCC Assembly Language Output (ARMv7)</strong></h5>&#13;
		<p class="noindent">The following code provides the GCC compilation to ARMv6 assembly code for the <em>t1.c</em> source file as compiled on a Raspberry Pi (running 32-bit Raspian):</p>&#13;
		<pre class="programs">&#13;
			..arch armv6<br/>    .eabi_attribute 27, 3<br/>    .eabi_attribute 28, 1<br/>    .fpu vfp<br/>    .eabi_attribute 20, 1<br/>    .eabi_attribute 21, 1<br/>    .eabi_attribute 23, 3<br/>    .eabi_attribute 24, 1<br/>    .eabi_attribute 25, 1<br/>    .eabi_attribute 26, 2<br/>    .eabi_attribute 30, 2<br/>    .eabi_attribute 34, 1<br/>    .eabi_attribute 18, 4<br/>    .file   "t1.c"<br/>    .section    .text.startup,"ax",%progbits<br/>    .align  2<br/>    .global main<br/>    .type   main, %function<br/>main:<br/>    @ args = 0, pretend = 0, frame = 0<br/>    @ frame_needed = 0, uses_anonymous_args = 0<br/>    stmfd   sp!, {r3, lr}<br/>    cmp r0, #2<br/>    ldr r3, [r1]<br/>    mov r1, r0<br/>    ldr r0, .L5<br/>    ldrb    r2, [r3]    @ zero_extendqisi2<br/>    addeq   r2, r2, #1<br/>    subne   r2, r2, #1<br/>    bl  printf<br/>    mov r0, #0<br/>    ldmfd   sp!, {r3, pc}<br/>.L6:<br/>    .align  2<br/>.L5:<br/>    .word   .LC0<br/>    .size   main, .-main<br/>    .section    .rodata.str1.4,"aMS",%progbits,1<br/>    .align  2<br/><span epub:type="pagebreak" id="page_108"/>.LC0:<br/>    .ascii  "i=%d, j=%d\012\000"<br/>    .ident  "GCC: (Raspbian 4.9.2-10) 4.9.2"<br/>    .section    .note.GNU-stack,"",%progbits</pre>&#13;
		<p class="indent">Note that the <code>@</code> denotes a comment in this source code; Gas ignores everything from the <code>@</code> to the end of the line.</p>&#13;
		<h5 class="h5" id="ch00lev3sec34"><strong>5.2.3.5 Swift Assembly Language Output (x86-64)</strong></h5>&#13;
		<p class="noindent">Given a Swift source file <em>main.swift</em>, you can request an assembly language output file from the macOS Swift compiler using the following command:</p>&#13;
		<pre class="programs">swiftc -O -emit-assembly main.swift -o result.asm</pre>&#13;
		<p class="indent">This will produce the <em>result.asm</em> output assembly language file. Consider the following Swift source code:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/><br/>var i:Int = 0;<br/>var j:Int = 1;<br/><br/><br/>    if( i == 2 )<br/>    {<br/>        i = i + 1<br/>    }<br/>    else<br/>    {<br/>        i = i - 1<br/>    }<br/><br/>    print( "i=\(i), j=\(j)" )</pre>&#13;
		<p class="indent">Compiling this with the previous command line produces a rather long assembly language output file; here is the main procedure from that code:</p>&#13;
		<pre class="programs">&#13;
			_main:<br/>.cfi_startproc<br/>    pushq   %rbp<br/>    .cfi_def_cfa_offset 16<br/>    .cfi_offset %rbp, -16<br/>    movq    %rsp, %rbp<br/>    .cfi_def_cfa_register %rbp<br/>    pushq   %r15<br/>    pushq   %r14<br/>    pushq   %r13<br/>    pushq   %r12<br/>    pushq   %rbx<br/>    pushq   %rax<br/>    .cfi_offset %rbx, -56<br/>    .cfi_offset %r12, -48<br/><span epub:type="pagebreak" id="page_109"/>    .cfi_offset %r13, -40<br/>    .cfi_offset %r14, -32<br/>    .cfi_offset %r15, -24<br/>    movq    $1, _$S6result1jSivp(%rip)<br/>    movq    $-1, _$S6result1iSivp(%rip)<br/>    movq    _$Ss23_ContiguousArrayStorageCyypGML(%rip), %rdi<br/>    testq   %rdi, %rdi<br/>    jne LBB0_3<br/>    movq    _$SypN@GOTPCREL(%rip), %rsi<br/>    addq    $8, %rsi<br/>    xorl    %edi, %edi<br/>    callq   _$Ss23_ContiguousArrayStorageCMa<br/>    movq    %rax, %rdi<br/>    testq   %rdx, %rdx<br/>    jne LBB0_3<br/>    movq    %rdi, _$Ss23_ContiguousArrayStorageCyypGML(%rip)<br/>LBB0_3:<br/>    movabsq $8589934584, %r12<br/>    movl    48(%rdi), %esi<br/>    movzwl  52(%rdi), %edx<br/>    addq    $7, %rsi<br/>    andq    %r12, %rsi<br/>    addq    $32, %rsi<br/>    orq $7, %rdx<br/>    callq   _swift_allocObject<br/>    movq    %rax, %r14<br/>    movq    _$Ss27_ContiguousArrayStorageBaseC16countAndCapacitys01_B4BodyVvpWvd@GOTPCREL(%rip), %rbx<br/>    movq    (%rbx), %r15<br/>    movaps  LCPI0_0(%rip), %xmm0<br/>    movups  %xmm0, (%r14,%r15)<br/>    movq    _$SSSN@GOTPCREL(%rip), %rax<br/>    movq    %rax, 56(%r14)<br/>    movq    _$Ss23_ContiguousArrayStorageCySSGML(%rip), %rdi<br/>    testq   %rdi, %rdi<br/>    jne LBB0_6<br/>    movq    _$SSSN@GOTPCREL(%rip), %rsi<br/>    xorl    %edi, %edi<br/>    callq   _$Ss23_ContiguousArrayStorageCMa<br/>    movq    %rax, %rdi<br/>    testq   %rdx, %rdx<br/>    jne LBB0_6<br/>    movq    %rdi, _$Ss23_ContiguousArrayStorageCySSGML(%rip)<br/>    movq    (%rbx), %r15<br/>LBB0_6:<br/>    movl    48(%rdi), %esi<br/>    movzwl  52(%rdi), %edx<br/>    addq    $7, %rsi<br/>    andq    %r12, %rsi<br/>    addq    $80, %rsi<br/>    orq $7, %rdx<br/>    callq   _swift_allocObject<br/>    movq    %rax, %rbx<br/>    movaps  LCPI0_1(%rip), %xmm0<br/>    movups  %xmm0, (%rbx,%r15)<br/>    movabsq $-2161727821137838080, %r15<br/><span epub:type="pagebreak" id="page_110"/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRetain<br/>    movl    $15721, %esi<br/>    movq    %r15, %rdi<br/>    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n<br/>    movq    %rax, %r12<br/>    movq    %rdx, %r13<br/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRelease<br/>    movq    %r12, 32(%rbx)<br/>    movq    %r13, 40(%rbx)<br/>    movq    _$S6result1iSivp(%rip), %rdi<br/>    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5<br/>    movq    %rax, 48(%rbx)<br/>    movq    %rdx, 56(%rbx)<br/>    movabsq $-2017612633061982208, %r15<br/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRetain<br/>    movl    $1030365228, %esi<br/>    movq    %r15, %rdi<br/>    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n<br/>    movq    %rax, %r12<br/>    movq    %rdx, %r13<br/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRelease<br/>    movq    %r12, 64(%rbx)<br/>    movq    %r13, 72(%rbx)<br/>    movq    _$S6result1jSivp(%rip), %rdi<br/>    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5<br/>    movq    %rax, 80(%rbx)<br/>    movq    %rdx, 88(%rbx)<br/>    movabsq $-2305843009213693952, %r15<br/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRetain<br/>    xorl    %esi, %esi<br/>    movq    %r15, %rdi<br/>    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n<br/>    movq    %rax, %r12<br/>    movq    %rdx, %r13<br/>    movq    %r15, %rdi<br/>    callq   _swift_bridgeObjectRelease<br/>    movq    %r12, 96(%rbx)<br/>    movq    %r13, 104(%rbx)<br/>    movq    %rbx, %rdi<br/>    callq   _$SSS19stringInterpolationS2Sd_tcfCTf4nd_n<br/>    movq    %rax, 32(%r14)<br/>    movq    %rdx, 40(%r14)<br/>    callq   _$Ss5print_9separator10terminatoryypd_S2StFfA0_<br/>    movq    %rax, %r12<br/>    movq    %rdx, %r15<br/>    callq   _$Ss5print_9separator10terminatoryypd_S2StFfA1_<br/>    movq    %rax, %rbx<br/>    movq    %rdx, %rax<br/>    movq    %r14, %rdi<br/><span epub:type="pagebreak" id="page_111"/>    movq    %r12, %rsi<br/>    movq    %r15, %rdx<br/>    movq    %rbx, %rcx<br/>    movq    %rax, %r8<br/>    callq   _$Ss5print_9separator10terminatoryypd_S2StF<br/>    movq    %r14, %rdi<br/>    callq   _swift_release<br/>    movq    %r12, %rdi<br/>    callq   _swift_bridgeObjectRelease<br/>    movq    %rbx, %rdi<br/>    callq   _swift_bridgeObjectRelease<br/>    xorl    %eax, %eax<br/>    addq    $8, %rsp<br/>    popq    %rbx<br/>    popq    %r12<br/>    popq    %r13<br/>    popq    %r14<br/>    popq    %r15<br/>    popq    %rbp<br/>    retq<br/>    .cfi_endproc</pre>&#13;
		<p class="indent">As you can see, Swift doesn’t generate very optimal code compared to C++. In fact, hundreds of additional lines of code have been omitted from this listing to save space.</p>&#13;
		<h4 class="h4" id="ch00lev2sec61"><strong>5.2.4 Assembly Output Analysis</strong></h4>&#13;
		<p class="noindent">Unless you’re well versed in assembly language programming, analyzing assembly output can be tricky. If you’re not an assembly language programmer, about the best you can do is count instructions and assume that if a compiler option (or reorganization of your HLL source code) produces fewer instructions, the result is better. In reality, this assumption isn’t always correct. Some machine instructions (particularly on CISC processors such as the 80x86) require substantially more time to execute than others. A sequence of three or more instructions on a processor such as the 80x86 could execute faster than a single instruction that does the same operation. Fortunately, a compiler is not likely to produce both of these sequences based on a reorganization of your high-level source code. Therefore, you don’t usually have to worry about such issues when examining the assembly output.</p>&#13;
		<p class="indent">Note that some compilers will produce two different sequences if you change the optimization level. This is because certain optimization settings tell the compiler to favor shorter programs, while other optimization settings tell the compiler to favor faster execution. The optimization setting that favors smaller executable files will probably pick the single instruction over the three instructions that do the same work (assuming those three instructions compile into more code); the optimization setting that favors speed will probably pick the faster instruction sequence.</p>&#13;
		<p class="indent">This section uses various C/C++ compilers in its examples, but you should remember that compilers for other languages also provide the <span epub:type="pagebreak" id="page_112"/>ability to emit assembly code. You’ll have to check your compiler’s documentation to see if this is possible and what options you can use to produce the assembly output. Some compilers (Visual C++, for example) provide an integrated development environment (IDE) that you may use in place of a command-line tool. Even though most compilers that work through an IDE also work from the command line, you can usually specify assembly output from within an IDE as well as from the command line. Once again, see your compiler vendor’s documentation for details.</p>&#13;
		<h3 class="h3" id="ch00lev1sec43"><strong>5.3 Using Object Code Utilities to Analyze Compiler Output</strong></h3>&#13;
		<p class="noindent">Although many compilers provide an option to emit assembly language rather than object code, a large number of compilers do not; they can only emit binary machine code to an object code file. Analyzing this kind of compiler output will be a bit more work, and it’s going to require some specialized tools. If your compiler emits object code files (such as PE/COFF or ELF files) to be fed into a linker, you can probably find an “object code dump” utility that will prove quite useful for analyzing the compiler’s output. For example, Microsoft provides the <em>dumpbin.exe</em> program, and the FSF/GNU <em>dumpobj</em> program has similar capabilities for ELF files under Linux and other operating systems. In the following subsections, we’ll take a look at using these two tools when analyzing compiler output.</p>&#13;
		<p class="indent">One nice feature of working with object files is that they usually contain symbolic information. That is, in addition to binary machine code, the object file contains strings specifying identifier names that appear in the source file (such information does not normally appear in an executable file). Object code utilities can usually display these symbolic names within the machine instructions that reference the memory locations associated with these symbols. Though these object code utilities can’t automatically correlate the HLL source code with the machine code, having the symbolic information available can help you when you’re studying their output, because it’s much easier to read names like <code>JumpTable</code> than memory addresses like <code>$401_1000</code>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec62"><strong>5.3.1 The Microsoft dumpbin.exe Utility</strong></h4>&#13;
		<p class="noindent">Microsoft’s <code>dumpbin</code> command-line tool allows you to examine the contents of a Microsoft PE/COFF file.<sup><a id="ch5fn_2"/><a href="footnotes.xhtml#ch5fn2">2</a></sup> You run the program as follows:</p>&#13;
		<pre class="programs">&#13;
			dumpbin <span class="codeitalic1">options filename</span></pre>&#13;
		<p class="indent">The <span class="codeitalic">filename</span> parameter is the name of the <em>.obj</em> file that you wish to examine, and the <span class="codeitalic">options</span> parameter is a set of optional command-line arguments that specify the type of information you want to display. These options each begin with a forward slash (<code>/</code>). We’ll take a look at each of the <span epub:type="pagebreak" id="page_113"/>possible options in a moment. First, here is a listing of the possible objects (obtained via the <code>/?</code> command-line option):</p>&#13;
		<pre class="programs">&#13;
			Microsoft (R) COFF/PE Dumper Version 14.00.24234.1<br/>Copyright (C) Microsoft Corporation.  All rights reserved.<br/><br/>usage: dumpbin <span class="codeitalic1">options files</span><br/><br/>   options:<br/><br/>      /ALL<br/>      /ARCHIVEMEMBERS<br/>      /CLRHEADER<br/>      /DEPENDENTS<br/>      /DIRECTIVES<br/>      /DISASM[:{BYTES|NOBYTES}]<br/>      /ERRORREPORT:{NONE|PROMPT|QUEUE|SEND}<br/>      /EXPORTS<br/>      /FPO<br/>      /HEADERS<br/>      /IMPORTS[:filename]<br/>      /LINENUMBERS<br/>      /LINKERMEMBER[:{1|2}]<br/>      /LOADCONFIG<br/>      /NOLOGO<br/>      /OUT:filename<br/>      /PDATA<br/>      /PDBPATH[:VERBOSE]<br/>      /RANGE:vaMin[,vaMax]<br/>      /RAWDATA[:{NONE|1|2|4|8}[,#]]<br/>      /RELOCATIONS<br/>      /SECTION:name<br/>      /SUMMARY<br/>      /SYMBOLS<br/>      /TLS<br/>      /UNWINDINFO</pre>&#13;
		<p class="indent">Though the primary use of <code>dumpbin</code> is to look at the object code a compiler produces, it also displays a considerable amount of interesting information about a PE/COFF file. For more information on the meaning of many of the <code>dumpbin</code> command-line options, review “Object File Formats” on <a href="ch04.xhtml#page_71">page 71</a> or “Executable File Formats” on <a href="ch04.xhtml#page_80">page 80</a>.</p>&#13;
		<p class="indent">The following subsections describe several of the possible <code>dumpbin</code> command-line options and provide example output for a simple “Hello World” program written in C:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>int main( int argc, char **argv)<br/>{<br/>    printf( "Hello World\n" );<br/>}</pre>&#13;
		<h5 class="h5" id="ch00lev3sec35"><span epub:type="pagebreak" id="page_114"/><strong>5.3.1.1 /all</strong></h5>&#13;
		<p class="noindent">The <code>/all</code> command-line option instructs <code>dumpbin</code> to display all the information it can except for a disassembly of the code found in the object file. The problem with this approach is that an <em>.exe</em> file contains all the routines from the language’s standard library (such as the C Standard Library) that the linker has merged into the application. When analyzing compiler output in order to improve your application’s code, wading through all this extra information about code outside your program can be tedious. Fortunately, there’s an easy way to pare down the unnecessary information—run <code>dumpbin</code> on your object (<em>.obj</em>) files rather than your executable (<em>.exe</em>) files. Here is the (shortened) output that <code>dumpbin</code> produces for the “Hello World” example:</p>&#13;
		<pre class="programs">&#13;
			G:\&gt;dumpbin /all hw.obj<br/>Microsoft (R) COFF/PE Dumper Version 14.00.24234.1<br/>Copyright (C) Microsoft Corporation.  All rights reserved.<br/><br/><br/>Dump of file hw.obj<br/><br/>File Type: COFF OBJECT<br/><br/>FILE HEADER VALUES<br/>            8664 machine (x64)<br/>               D number of sections<br/>        5B2C175F time date stamp Thu Jun 21 14:23:43 2018<br/>             466 file pointer to symbol table<br/>              2D number of symbols<br/>               0 size of optional header<br/>               0 characteristics<br/><br/>SECTION HEADER #1<br/>.drectve name<br/>       0 physical address<br/>       0 virtual address<br/>      2F size of raw data<br/>     21C file pointer to raw data (0000021C to 0000024A)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>  100A00 flags<br/>         Info<br/>         Remove<br/>         1 byte align<br/><br/><span class="codeitalic1">Hundreds of lines deleted...</span><br/><br/>  Summary<br/><br/>           D .data<br/>          70 .debug$S<br/>          2F .drectve<br/><span epub:type="pagebreak" id="page_115"/>          24 .pdata<br/>          C2 .text$mn<br/>          18 .xdata</pre>&#13;
		<p class="indent">This example deletes the bulk of the output from this command (to spare you having to read a dozen or so extra pages). Try executing the <code>/all</code> command yourself to see the quantity of output you get. In general, though, use this option with care.</p>&#13;
		<h5 class="h5" id="ch00lev3sec36"><strong>5.3.1.2 /disasm</strong></h5>&#13;
		<p class="noindent">The <code>/disasm</code> command-line option is the one of greatest interest to us. It produces a disassembled listing of the object file. As with the <code>/all</code> option, you shouldn’t try to disassemble an <em>.exe</em> file using <code>dumpbin</code>. The disassembled listing you’ll get will be quite long, and the vast majority of the code will probably be the listings of all the library routines your application calls. For example, the simple “Hello World” application generates over 5,000 lines of disassembled code. All but a small handful of those statements correspond to library routines. Wading through that amount of code will prove overwhelming to most people.</p>&#13;
		<p class="indent">However, if you disassemble the <em>hw.obj</em> file rather than the executable file, here’s the output you typically get:</p>&#13;
		<pre class="programs">&#13;
			Microsoft (R) COFF/PE Dumper Version 14.00.24234.1<br/>Copyright (C) Microsoft Corporation.  All rights reserved.<br/><br/><br/>Dump of file hw.obj<br/><br/>File Type: COFF OBJECT<br/><br/>main:<br/>  0000000000000000: 48 89 54 24 10     mov         qword ptr [rsp+10h],rdx<br/>  0000000000000005: 89 4C 24 08        mov         dword ptr [rsp+8],ecx<br/>  0000000000000009: 48 83 EC 28        sub         rsp,28h<br/>  000000000000000D: 48 8D 0D 00 00 00  lea         rcx,[$SG4247]<br/>                    00<br/>  0000000000000014: E8 00 00 00 00     call        printf<br/>  0000000000000019: 33 C0              xor         eax,eax<br/>  000000000000001B: 48 83 C4 28        add         rsp,28h<br/>  000000000000001F: C3                 ret<br/><br/>// Uninterested code emitted by dumpbin.exe left out...<br/><br/>  Summary<br/><br/>           D .data<br/>          70 .debug$S<br/>          2F .drectve<br/>          24 .pdata<br/>          C2 .text$mn<br/>          28 .xdata</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_116"/>If you look closely at this disassembled code, you’ll find the major problem with disassembling object files rather than executable files—most addresses in the code are relocatable addresses, which appear as <code>$00000000</code> in the object code listing. As a result, you’ll probably have a hard time figuring out what the various assembly statements are doing. For example, in the <em>hw.obj</em>’s disassembled listing you see the following two statements:</p>&#13;
		<pre class="programs">&#13;
			000000000000000D:  48 8D 0D 00 00 00  lea         rcx,[$SG4247]<br/>                   00<br/>0000000000000014:  E8 00 00 00 00     call        printf</pre>&#13;
		<p class="indent">The <code>lea</code> instruction opcode is the 3-byte sequence <code>48 8D 0D</code> (which includes an REX opcode prefix byte). The address of the <code>"Hello World"</code> string is not <code>00 00 00 00</code> (the 4 bytes following the opcode); instead, it is a relocatable address that the linker/system fills in later. If you run <code>dumpbin</code> on <em>hw.obj</em> with the <code>/all</code> command-line option, you’ll notice that this file has two relocation entries:</p>&#13;
		<pre class="programs">&#13;
			RELOCATIONS #4<br/>                                                Symbol    Symbol<br/> Offset    Type              Applied To         Index     Name<br/> --------  ----------------  -----------------  --------  ------<br/> 00000010  REL32                      00000000         8  $SG4247<br/> 00000015  REL32                      00000000        15  printf</pre>&#13;
		<p class="indent">The Offset column tells you the byte offset into the file where the relocations are to be applied. In the preceding disassembly, note that the <code>lea</code> instruction starts at offset <code>$d</code>, so the actual displacement is at offset <code>$10</code>. Similarly, the <code>call</code> instruction begins at offset <code>$14</code>, so the address of the actual routine that needs to be patched is 1 byte later, at offset <code>$15</code>. From the relocation information that <code>dumpbin</code> outputs, you can discern the symbols associated with these relocations. (<code>$SG4247</code> is an internal symbol that the C compiler generates for the <code>"Hello World"</code> string. And <code>printf</code> is, obviously, the name associated with the C <code>printf()</code> function.)</p>&#13;
		<p class="indent">Cross-referencing every call and memory reference against the relocation list may seem like a pain, but at least you get symbolic names when you do this.</p>&#13;
		<p class="indent">Consider the first few lines of the disassembled code when you apply the <code>/disasm</code> option to the <em>hw.exe</em> file:</p>&#13;
		<pre class="programs">&#13;
			0000000140001009: 48 83 EC 28        sub         rsp,28h<br/>000000014000100D: 48 8D 0D EC DF 01  lea         rcx,[000000014001F000h]<br/>                  00<br/>0000000140001014: E8 67 00 00 00     call        0000000140001080<br/>0000000140001019: 33 C0              xor         eax,eax<br/>000000014000101B: 48 83 C4 28        add         rsp,28h<br/>000000014000101F: C3                 ret<br/>                              .<br/>                              .<br/>                              .</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_117"/>Notice that the linker has filled in the addresses (relative to the load address for the file) of the offset <code>$SG4247</code> and <code>print</code> labels. This may seem somewhat convenient; however, note that these labels (especially the <code>printf</code> label) are no longer present in the file. When you are reading the disassembled output, the absence of these labels can make it very difficult to figure out which machine instructions correspond to HLL statements. This is yet another reason why you should use object files rather than executable files when running <code>dumpbin</code>.</p>&#13;
		<p class="indent">If you think it’s going to be a major pain to read the disassembled output of the <code>dumpbin</code> utility, don’t worry: for optimization purposes, you’re often more interested in the code differences between two versions of an HLL program than in figuring out what each machine instruction does. Therefore, you can easily determine which machine instructions are affected by a change in your code by running <code>dumpbin</code> on two versions of your object files (one before the change to the HLL code and one created afterward). For example, consider the following modification to the “Hello World” program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>int main( int argc, char **argv)<br/>{<br/>        char *hwstr = "Hello World\n";<br/><br/>        printf( hwstr );<br/>}</pre>&#13;
		<p class="indent">Here’s the disassembly output that <code>dumpbin</code> produces:</p>&#13;
		<pre class="programs">&#13;
			Microsoft (R) COFF Binary File Dumper Version 6.00.8168<br/>  0000000140001000: 48 89 54 24 10     mov         qword ptr [rsp+10h],rdx<br/>  0000000140001005: 89 4C 24 08        mov         dword ptr [rsp+8],ecx<br/>  0000000140001009: 48 83 EC 28        sub         rsp,28h<br/>  000000014000100D: 48 8D 0D EC DF 01  lea         rcx,[000000014001F000h]<br/>                    00<br/>  0000000140001014: E8 67 00 00 00     call        0000000140001080<br/>  0000000140001019: 33 C0              xor         eax,eax<br/>  000000014000101B: 48 83 C4 28        add         rsp,28h<br/>  000000014000101F: C3                 ret</pre>&#13;
		<p class="indent">By comparing this output with the previous assembly output (either manually or by running one of the programs based on the Unix <code>diff</code> utility), you can see the effect of the change to your HLL source code on the emitted machine code.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>The section “Comparing Output from Two Compilations” on <a href="ch05.xhtml#page_137">page 137</a> discusses the merits of both comparison methods (manual and <code>diff</code>-based).</em></p>&#13;
		</div>&#13;
		<h5 class="h5" id="ch00lev3sec37"><span epub:type="pagebreak" id="page_118"/><strong>5.3.1.3 /headers</strong></h5>&#13;
		<p class="noindent">The <code>/headers</code> option instructs <code>dumpbin</code> to display the COFF header files and section header files. The <code>/all</code> option also prints this information, but <code>/header</code> displays <em>only</em> the header information without all the other output. Here’s the sample output for the “Hello World” executable file:</p>&#13;
		<pre class="programs">&#13;
			G:\WGC&gt;dumpbin /headers hw.exe<br/>Microsoft (R) COFF/PE Dumper Version 14.00.24234.1<br/>Copyright (C) Microsoft Corporation.  All rights reserved.<br/><br/><br/>Dump of file hw.exe<br/><br/>PE signature found<br/><br/>File Type: EXECUTABLE IMAGE<br/><br/>FILE HEADER VALUES<br/>            8664 machine (x64)<br/>               6 number of sections<br/>        5B2C1A9F time date stamp Thu Jun 21 14:37:35 2018<br/>               0 file pointer to symbol table<br/>               0 number of symbols<br/>              F0 size of optional header<br/>              22 characteristics<br/>                   Executable<br/>                   Application can handle large (&gt;2GB) addresses<br/><br/>OPTIONAL HEADER VALUES<br/>             20B magic # (PE32+)<br/>           14.00 linker version<br/>           13400 size of code<br/>            D600 size of initialized data<br/>               0 size of uninitialized data<br/>            1348 entry point (0000000140001348)<br/>            1000 base of code<br/>       140000000 image base (0000000140000000 to 0000000140024FFF)<br/>            1000 section alignment<br/>             200 file alignment<br/>            6.00 operating system version<br/>            0.00 image version<br/>            6.00 subsystem version<br/>               0 Win32 version<br/>           25000 size of image<br/>             400 size of headers<br/>               0 checksum<br/>               3 subsystem (Windows CUI)<br/>            8160 DLL characteristics<br/>                   High Entropy Virtual Addresses<br/>                   Dynamic base<br/>                   NX compatible<br/>                   Terminal Server Aware<br/>          100000 size of stack reserve<br/><span epub:type="pagebreak" id="page_119"/>            1000 size of stack commit<br/>          100000 size of heap reserve<br/>            1000 size of heap commit<br/>               0 loader flags<br/>              10 number of directories<br/>               0 [       0] RVA [size] of Export Directory<br/>           1E324 [      28] RVA [size] of Import Directory<br/>               0 [       0] RVA [size] of Resource Directory<br/>           21000 [    126C] RVA [size] of Exception Directory<br/>               0 [       0] RVA [size] of Certificates Directory<br/>           24000 [     620] RVA [size] of Base Relocation Directory<br/>           1CDA0 [      1C] RVA [size] of Debug Directory<br/>               0 [       0] RVA [size] of Architecture Directory<br/>               0 [       0] RVA [size] of Global Pointer Directory<br/>               0 [       0] RVA [size] of Thread Storage Directory<br/>           1CDC0 [      94] RVA [size] of Load Configuration Directory<br/>               0 [       0] RVA [size] of Bound Import Directory<br/>           15000 [     230] RVA [size] of Import Address Table Directory<br/>               0 [       0] RVA [size] of Delay Import Directory<br/>               0 [       0] RVA [size] of COM Descriptor Directory<br/>               0 [       0] RVA [size] of Reserved Directory<br/><br/><br/>SECTION HEADER #1<br/>   .text name<br/>   1329A virtual size<br/>    1000 virtual address (0000000140001000 to 0000000140014299)<br/>   13400 size of raw data<br/>     400 file pointer to raw data (00000400 to 000137FF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>60000020 flags<br/>         Code<br/>         Execute Read<br/><br/>SECTION HEADER #2<br/>  .rdata name<br/>    9A9A virtual size<br/>   15000 virtual address (0000000140015000 to 000000014001EA99)<br/>    9C00 size of raw data<br/>   13800 file pointer to raw data (00013800 to 0001D3FF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>40000040 flags<br/>         Initialized Data<br/>         Read Only<br/><br/>  Debug Directories<br/><span epub:type="pagebreak" id="page_120"/>        Time Type        Size      RVA  Pointer<br/>    -------- ------- -------- -------- --------<br/>    5B2C1A9F coffgrp      2CC 0001CFC4    1B7C4<br/><br/>SECTION HEADER #3<br/>   .data name<br/>    1BA8 virtual size<br/>   1F000 virtual address (000000014001F000 to 0000000140020BA7)<br/>     A00 size of raw data<br/>   1D400 file pointer to raw data (0001D400 to 0001DDFF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>C0000040 flags<br/>         Initialized Data<br/>         Read Write<br/><br/>SECTION HEADER #4<br/>  .pdata name<br/>    126C virtual size<br/>   21000 virtual address (0000000140021000 to 000000014002226B)<br/>    1400 size of raw data<br/>   1DE00 file pointer to raw data (0001DE00 to 0001F1FF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>40000040 flags<br/>         Initialized Data<br/>         Read Only<br/><br/>SECTION HEADER #5<br/>  .gfids name<br/>      D4 virtual size<br/>   23000 virtual address (0000000140023000 to 00000001400230D3)<br/>     200 size of raw data<br/>   1F200 file pointer to raw data (0001F200 to 0001F3FF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/>       0 number of line numbers<br/>40000040 flags<br/>         Initialized Data<br/>         Read Only<br/><br/>SECTION HEADER #6<br/>  .reloc name<br/>     620 virtual size<br/>   24000 virtual address (0000000140024000 to 000000014002461F)<br/>     800 size of raw data<br/>   1F400 file pointer to raw data (0001F400 to 0001FBFF)<br/>       0 file pointer to relocation table<br/>       0 file pointer to line numbers<br/>       0 number of relocations<br/><span epub:type="pagebreak" id="page_121"/>       0 number of line numbers<br/>42000040 flags<br/>         Initialized Data<br/>         Discardable<br/>         Read Only<br/><br/>  Summary<br/><br/>        2000 .data<br/>        1000 .gfids<br/>        2000 .pdata<br/>        A000 .rdata<br/>        1000 .reloc<br/>       14000 .text</pre>&#13;
		<p class="indent">Review the discussion of object file formats in <a href="ch04.xhtml#ch04">Chapter 4</a> (see “Object File Formats” on <a href="ch04.xhtml#page_71">page 71</a>) to make sense of the information that <code>dumpbin</code> outputs when you specify the <code>/headers</code> option.</p>&#13;
		<h5 class="h5" id="ch00lev3sec38"><strong>5.3.1.4 /imports</strong></h5>&#13;
		<p class="noindent">The <code>/imports</code> option lists all of the dynamic-link symbols that the operating system must supply when the program loads into memory. This information isn’t particularly useful for analyzing code emitted for HLL statements, so this chapter won’t mention this option further.</p>&#13;
		<h5 class="h5" id="ch00lev3sec39"><strong>5.3.1.5 /relocations</strong></h5>&#13;
		<p class="noindent">The <code>/relocations</code> option displays all the relocation objects in the file. This command is quite useful because it provides a list of all the symbols for the program and the offsets of their use in the disassembly listing. Of course, the <code>/all</code> option also presents this information, but <code>/relocations</code> provides just this information without anything else.</p>&#13;
		<h5 class="h5" id="ch00lev3sec40"><strong>5.3.1.6 Other dumpbin.exe Command-Line Options</strong></h5>&#13;
		<p class="noindent">The <code>dumpbin</code> utility supports many more command-line options beyond those this chapter describes. As noted earlier, you can get a list of all possible options by specifying <code>/?</code> on the command line when running <code>dumpbin</code>. You can also read more online at <em><a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/">https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/</a></em>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec63"><strong>5.3.2 The FSF/GNU objdump Utility</strong></h4>&#13;
		<p class="noindent">If you’re running the GNU toolset on your operating system (for example, under Linux, Mac, or BSD), then you can use the FSF/GNU <code>objdump</code> utility to examine the object files produced by GCC and other GNU-compliant tools. Here are the command-line options it supports:</p>&#13;
		<pre class="programs">&#13;
			Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt;<br/>Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt;<br/>Display information from object &lt;file(s)&gt;.<br/><span epub:type="pagebreak" id="page_122"/>At least one of the following switches must be given:<br/>  -a, --archive-headers    Display archive header information<br/>  -f, --file-headers       Display the contents of the overall file header<br/>  -p, --private-headers    Display object format specific file header contents<br/>  -P, --private=OPT,OPT... Display object format specific contents<br/>  -h, --[section-]headers  Display the contents of the section headers<br/>  -x, --all-headers        Display the contents of all headers<br/>  -d, --disassemble        Display assembler contents of executable sections<br/>  -D, --disassemble-all    Display assembler contents of all sections<br/>  -S, --source             Intermix source code with disassembly<br/>  -s, --full-contents      Display the full contents of all sections requested<br/>  -g, --debugging          Display debug information in object file<br/>  -e, --debugging-tags     Display debug information using ctags style<br/>  -G, --stabs              Display (in raw form) any STABS info in the file<br/>  -W[lLiaprmfFsoRt] or<br/>  --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,<br/>          =frames-interp,=str,=loc,=Ranges,=pubtypes,<br/>          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,<br/>          =addr,=cu_index]<br/>                           Display DWARF info in the file<br/>  -t, --syms               Display the contents of the symbol table(s)<br/>  -T, --dynamic-syms       Display the contents of the dynamic symbol table<br/>  -r, --reloc              Display the relocation entries in the file<br/>  -R, --dynamic-reloc      Display the dynamic relocation entries in the file<br/>  @&lt;file&gt;                  Read options from &lt;file&gt;<br/>  -v, --version            Display this program's version number<br/>  -i, --info               List object formats and architectures supported<br/>  -H, --help               Display this information<br/><br/> The following switches are optional:<br/>  -b, --target=BFDNAME           Specify the target object format as BFDNAME<br/>  -m, --architecture=MACHINE     Specify the target architecture as MACHINE<br/>  -j, --section=NAME             Only display information for section NAME<br/>  -M, --disassembler-options=OPT Pass text OPT on to the disassembler<br/>  -EB --endian=big               Assume big endian format when disassembling<br/>  -EL --endian=little            Assume little endian format when disassembling<br/>      --file-start-context       Include context from start of file (with -S)<br/>  -I, --include=DIR              Add DIR to search list for source files<br/>  -l, --line-numbers             Include line numbers and filenames in output<br/>  -F, --file-offsets             Include file offsets when displaying information<br/>  -C, --demangle[=STYLE]         Decode mangled/processed symbol names<br/>                                 The STYLE, if specified, can be `auto', `gnu',<br/>                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'<br/>                                  or `gnat'<br/>  -w, --wide                     Format output for more than 80 columns<br/>  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling<br/>      --start-address=ADDR       Only process data whose address is &gt;= ADDR<br/>      --stop-address=ADDR        Only process data whose address is &lt;= ADDR<br/>      --prefix-addresses         Print complete address alongside disassembly<br/>      --[no-]show-raw-insn       Display hex alongside symbolic disassembly<br/>      --insn-width=WIDTH         Display WIDTH bytes on a single line for -d<br/>      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses<br/>      --special-syms             Include special symbols in symbol dumps<br/><span epub:type="pagebreak" id="page_123"/>      --prefix=PREFIX            Add PREFIX to absolute paths for -S<br/>      --prefix-strip=LEVEL       Strip initial directory names for -S<br/>      --dwarf-depth=N            Do not display DIEs at depth N or greater<br/>      --dwarf-start=N            Display DIEs starting with N, at the same depth<br/>                                 or deeper<br/>      --dwarf-check              Make additional dwarf internal consistency checks.<br/><br/>objdump: supported targets: elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 a.out-i386-linux pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 plugin srec symbolsrec verilog tekhex binary ihex<br/>objdump: supported architectures: i386 i386:x86-64 i386:x64-32 i8086 i386:intel i386:x86-64:intel i386:x64-32:intel i386:nacl i386:x86-64:nacl i386:x64-32:nacl iamcu iamcu:intel l1om l1om:intel k1om k1om:intel plugin<br/>The following i386/x86-64 specific disassembler options are supported for use<br/>with the -M switch (multiple options should be separated by commas):<br/>  x86-64          Disassemble in 64bit mode<br/>  i386            Disassemble in 32bit mode<br/>  i8086           Disassemble in 16bit mode<br/>  att             Display instruction in AT&amp;T syntax<br/>  intel           Display instruction in Intel syntax<br/>  att-mnemonic    Display instruction in AT&amp;T mnemonic<br/>  intel-mnemonic  Display instruction in Intel mnemonic<br/>  addr64          Assume 64bit address size<br/>  addr32          Assume 32bit address size<br/>  addr16          Assume 16bit address size<br/>  data32          Assume 32bit data size<br/>  data16          Assume 16bit data size<br/>  suffix          Always display instruction suffix in AT&amp;T syntax<br/>  amd64           Display instruction in AMD64 ISA<br/>  intel64         Display instruction in Intel64 ISA<br/>Report bugs to &lt;http://www.sourceware.org/bugzilla/&gt;.</pre>&#13;
		<p class="indent">Given the following <em>m.hla</em> source code fragment:</p>&#13;
		<pre class="programs">&#13;
			begin t;<br/><br/>        // test mem.alloc and mem.free:<br/><br/>        for( mov( 0, ebx ); ebx &lt; 16; inc( ebx )) do<br/><br/>                // Allocate lots of storage:<br/><br/>                for( mov( 0, ecx ); ecx &lt; 65536; inc( ecx )) do<br/><br/>                        rand.range( 1, 256 );<br/>                        malloc( eax );<br/>                        mov( eax, ptrs[ ecx*4 ] );<br/><br/>                endfor;<br/>                   .<br/>                   .<br/>                   .</pre>&#13;
		<p class="noindent"><span epub:type="pagebreak" id="page_124"/>Here is some sample output produced on the 80x86, created with the Linux command line <code>objdump -S m</code>:</p>&#13;
		<pre class="programs">&#13;
			        objdump -S m<br/><br/><br/> 0804807e &lt;_HLAMain&gt;:<br/> 804807e:   89 e0                   mov    %esp,%eax<br/><br/>        .<br/>        . // Some deleted code here,<br/>        . // that HLA automatically generated.<br/>        .<br/><br/> 80480ae:   bb 00 00 00 00          mov    $0x0,%ebx<br/> 80480b3:   eb 2a                   jmp    80480df &lt;StartFor__hla_2124&gt;<br/><br/>080480b5 &lt;for__hla_2124&gt;:<br/> 80480b5:   b9 00 00 00 00          mov    $0x0,%ecx<br/> 80480ba:   eb 1a                   jmp    80480d6 &lt;StartFor__hla_2125&gt;<br/><br/>080480bc &lt;for__hla_2125&gt;:<br/> 80480bc:   6a 01                   push   $0x1<br/> 80480be:   68 00 01 00 00          push   $0x100<br/> 80480c3:   e8 64 13 00 00          call   804942c &lt;RAND_RANGE&gt;<br/> 80480c8:   50                      push   %eax<br/> 80480c9:   e8 6f 00 00 00          call   804813d &lt;MEM_ALLOC1&gt;<br/> 80480ce:   89 04 8d 68 c9 04 08    mov    %eax,0x804c968(,%ecx,4)<br/><br/>080480d5 &lt;continue__hla_2125&gt;:<br/> 80480d5:   41                      inc    %ecx<br/><br/>080480d6 &lt;StartFor__hla_2125&gt;:<br/> 80480d6:   81 f9 00 00 01 00       cmp    $0x10000,%ecx<br/> 80480dc:   72 de                   jb     80480bc &lt;for__hla_2125&gt;<br/><br/>080480de &lt;continue__hla_2124&gt;:<br/> 80480de:   43                      inc    %ebx<br/><br/>080480df &lt;StartFor__hla_2124&gt;:<br/> 80480df:   83 fb 10                cmp    $0x10,%ebx<br/> 80480e2:   72 d1                   jb     80480b5 &lt;for__hla_2124&gt;<br/><br/>080480e4 &lt;QuitMain__hla_&gt;:<br/> 80480e4:   b8 01 00 00 00          mov    $0x1,%eax<br/> 80480e9:   31 db                   xor    %ebx,%ebx<br/> 80480eb:   cd 80                   int    $0x80<br/> 8048274:   bb 00 00 00 00          mov    $0x0,%ebx<br/> 8048279:   e9 d5 00 00 00          jmp    8048353 &lt;L1021_StartFor__hla_&gt;<br/><span epub:type="pagebreak" id="page_125"/><br/>0804827e &lt;L1021_for__hla_&gt;:<br/> 804827e:   b9 00 00 00 00          mov    $0x0,%ecx<br/> 8048283:   eb 1a                   jmp    804829f &lt;L1022_StartFor__hla_&gt;<br/><br/>08048285 &lt;L1022_for__hla_&gt;:<br/> 8048285:   6a 01                   push   $0x1<br/> 8048287:   68 00 01 00 00          push   $0x100<br/> 804828c:   e8 db 15 00 00          call   804986c &lt;RAND_RANGE&gt;<br/> 8048291:   50                      push   %eax<br/> 8048292:   e8 63 0f 00 00          call   80491fa &lt;MEM_ALLOC&gt;<br/> 8048297:   89 04 8d 60 ae 04 08    mov    %eax,0x804ae60(,%ecx,4)<br/><br/>0804829e &lt;L1022_continue__hla_&gt;:<br/> 804829e:   41                      inc    %ecx<br/><br/>0804829f &lt;L1022_StartFor__hla_&gt;:<br/> 804829f:   81 f9 00 00 01 00       cmp    $0x10000,%ecx<br/> 80482a5:   72 de                   jb     8048285 &lt;L1022_for__hla_&gt;<br/><br/>080482a7 &lt;L1022_exitloop__hla_&gt;:<br/> 80482a7:   b9 00 00 00 00          mov    $0x0,%ecx<br/> 80482ac:   eb 0d                   jmp    80482bb &lt;L1023_StartFor__hla_&gt;</pre>&#13;
		<p class="indent">These listings are only a fragment of the total code (which is why certain labels are absent). Nevertheless, you can see how the <code>objdump</code> utility can be useful for analyzing compiler output by allowing you to disassemble the object code for a certain code fragment.</p>&#13;
		<p class="indent">Like <code>dumpbin</code>, <code>objdump</code> can display additional information beyond the machine code disassembly that may prove useful when you’re analyzing compiler output. For most purposes, however, the GCC <code>-S</code> (assembly output) option is the most useful. Here’s an example of a disassembly of some C code using the <code>objdump</code> utility. First, the original C code:</p>&#13;
		<pre class="programs">&#13;
			// Original C code:<br/><br/>#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv )<br/>{<br/>    int i,j,k;<br/><br/>    j = **argv;<br/>    k = argc;<br/>    i = j &amp;&amp; k;<br/>    printf( "%d\n", i );<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_126"/>Here’s the Gas output (x86-64) from GCC for the C code:</p>&#13;
		<pre class="programs">&#13;
			    .file   "t.c"<br/>    .section    .rodata<br/>.LC0:<br/>    .string "%d\n"<br/>    .text<br/>    .globl  main<br/>    .type   main, @function<br/>main:<br/>.LFB0:<br/>    .cfi_startproc<br/>    pushq   %rbp<br/>    .cfi_def_cfa_offset 16<br/>    .cfi_offset 6, -16<br/>    movq    %rsp, %rbp<br/>    .cfi_def_cfa_register 6<br/>    subq    $32, %rsp<br/>    movl    %edi, -20(%rbp)<br/>    movq    %rsi, -32(%rbp)<br/>    movq    -32(%rbp), %rax<br/>    movq    (%rax), %rax<br/>    movzbl  (%rax), %eax<br/>    movsbl  %al, %eax<br/>    movl    %eax, -12(%rbp)<br/>    movl    -20(%rbp), %eax<br/>    movl    %eax, -8(%rbp)<br/>    cmpl    $0, -12(%rbp)<br/>    je  .L2<br/>    cmpl    $0, -8(%rbp)<br/>    je  .L2<br/>    movl    $1, %eax<br/>    jmp .L3<br/>.L2:<br/>    movl    $0, %eax<br/>.L3:<br/>    movl    %eax, -4(%rbp)<br/>    movl    -4(%rbp), %eax<br/>    movl    %eax, %esi<br/>    movl    $.LC0, %edi<br/>    movl    $0, %eax<br/>    call    printf<br/>    movl    $0, %eax<br/>    leave<br/>    .cfi_def_cfa 7, 8<br/>    ret<br/>    .cfi_endproc<br/>.LFE0:<br/>    .size   main, .-main<br/>    .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"<br/>    .section    .note.GNU-stack,"",@progbits</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_127"/>Now here’s the <code>objdump</code> disassembly of the main function:</p>&#13;
		<pre class="programs">&#13;
			.file   "t.c"<br/><br/>0000000000400526 &lt;main&gt;:<br/>  400526:   55                      push   %rbp<br/>  400527:   48 89 e5                mov    %rsp,%rbp<br/>  40052a:   48 83 ec 20             sub    $0x20,%rsp<br/>  40052e:   89 7d ec                mov    %edi,-0x14(%rbp)<br/>  400531:   48 89 75 e0             mov    %rsi,-0x20(%rbp)<br/>  400535:   48 8b 45 e0             mov    -0x20(%rbp),%rax<br/>  400539:   48 8b 00                mov    (%rax),%rax<br/>  40053c:   0f b6 00                movzbl (%rax),%eax<br/>  40053f:   0f be c0                movsbl %al,%eax<br/>  400542:   89 45 f4                mov    %eax,-0xc(%rbp)<br/>  400545:   8b 45 ec                mov    -0x14(%rbp),%eax<br/>  400548:   89 45 f8                mov    %eax,-0x8(%rbp)<br/>  40054b:   83 7d f4 00             cmpl   $0x0,-0xc(%rbp)<br/>  40054f:   74 0d                   je     40055e &lt;main+0x38&gt;<br/>  400551:   83 7d f8 00             cmpl   $0x0,-0x8(%rbp)<br/>  400555:   74 07                   je     40055e &lt;main+0x38&gt;<br/>  400557:   b8 01 00 00 00          mov    $0x1,%eax<br/>  40055c:   eb 05                   jmp    400563 &lt;main+0x3d&gt;<br/>  40055e:   b8 00 00 00 00          mov    $0x0,%eax<br/>  400563:   89 45 fc                mov    %eax,-0x4(%rbp)<br/>  400566:   8b 45 fc                mov    -0x4(%rbp),%eax<br/>  400569:   89 c6                   mov    %eax,%esi<br/>  40056b:   bf 14 06 40 00          mov    $0x400614,%edi<br/>  400570:   b8 00 00 00 00          mov    $0x0,%eax<br/>  400575:   e8 86 fe ff ff          callq  400400 &lt;printf@plt&gt;<br/>  40057a:   b8 00 00 00 00          mov    $0x0,%eax<br/>  40057f:   c9                      leaveq<br/>  400580:   c3                      retq</pre>&#13;
		<p class="indent">As you can see, the assembly code output is somewhat easier to read than <code>objdump</code>’s output.</p>&#13;
		<h3 class="h3" id="ch00lev1sec44"><strong>5.4 Using a Disassembler to Analyze Compiler Output</strong></h3>&#13;
		<p class="noindent">Although using an object code “dump” tool is one way to analyze compiler output, another possible solution is to run a <em>disassembler</em> on the executable file. A disassembler is a utility that translates binary machine code into human-readable assembly language statements (“human-readable” is debatable, but that’s the idea, anyway). As such, it’s another tool you can use to analyze compiler output.</p>&#13;
		<p class="indent">There is a subtle, but important, difference between an object code dump utility (which contains a simple disassembler) and a sophisticated disassembler program. Object code dump utilities are automatic, but they <span epub:type="pagebreak" id="page_128"/>can get easily confused if the object code contains tricky constructs (such as buried data in the instruction stream). An <em>automatic disassembler</em> is very convenient to use, requiring little expertise on the user’s part, but rarely disassembles the machine code correctly. A full-blown <em>interactive disassembler</em>, on the other hand, requires more training to use properly, but is capable of disassembling tricky machine code sequences with a little help from its user. Therefore, decent disassemblers will work in situations where a simplistic object code dump utility will fail. Fortunately, most compilers do not always emit the kind of tricky code that confuses object code dump utilities, so you can sometimes get by without having to learn how to use a full-blown disassembler program. Nevertheless, having a disassembler handy can be useful in situations where a simplistic approach doesn’t work.</p>&#13;
		<p class="indent">Several “free” disassemblers are available. The one we’ll cover in this chapter is IDA7. IDA is the freeware version of IDA Pro, a very capable and powerful commercial disassembler system (<em><a href="https://www.hex-rays.com/products/ida/">https://www.hex-rays.com/products/ida/</a></em>).</p>&#13;
		<p class="indent">When you first run IDA, it opens the window shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a>.</p>&#13;
		<div class="image" id="ch5fig1">&#13;
			<img alt="Image" src="../images/05fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 5-1: IDA opening window</em></p>&#13;
		<p class="indent">Click the <strong>New</strong> button and type in the name of the <em>.exe</em> or <em>.obj</em> file you wish to disassemble. Once you enter an executable filename, IDA brings up the Format dialog shown in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>. In this dialog, you can select the binary file type (for example, PE/COFF, PE64 executable file, or pure binary) and the options to use when disassembling the file. IDA does a good job of choosing reasonable default values for these options, so most of the time you’ll just accept the defaults unless you’re working with some weird binary files.</p>&#13;
		<div class="image" id="ch5fig2">&#13;
			<span epub:type="pagebreak" id="page_129"/>&#13;
			<img alt="Image" src="../images/05fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 5-2: IDA executable file format dialog</em></p>&#13;
		<p class="indent">Generally, IDA will figure out the appropriate file type information for a standard disassembly, then do an “automatic” disassembly of the object code file. To produce an assembly language output file, click <strong>OK</strong>. Here are the first few lines of the disassembly of the <em>t1.c</em> file given in “Example Assembly Language Output” on <a href="ch05.xhtml#page_102">page 102</a>:</p>&#13;
		<pre class="programs">&#13;
			; int __cdecl main(int argc, const char **argv, const char **envp)<br/>main    proc    near<br/>        sub     rsp, 28h<br/>        mov     rax, [rdx]<br/>        cmp     ecx, 2<br/>        movsx   edx, byte ptr [rax]<br/>        lea     eax, [rdx-1]<br/>        lea     r8d, [rdx+1]<br/>        mov     edx, ecx<br/>        cmovnz  r8d, eax<br/>        lea     rcx, aIDJD      ; "i=%d, j=%d\n"<br/>        call    sub_140001040<br/>        xor     eax, eax<br/>        add     rsp, 28h<br/>        retn<br/>main endp</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_130"/>IDA is an <em>interactive</em> disassembler. This means that it provides lots of complex features that you can use to guide the disassembly to produce a more reasonable assembly language output file. However, its “automatic” mode of operation is generally all you’ll need in order to examine compiler output files to assess their quality. For more details on IDA (freeware) or IDA Pro, see its documentation (<em><a href="https://www.hex-rays.com/products/ida/support/">https://www.hex-rays.com/products/ida/support/</a></em>).</p>&#13;
		<h3 class="h3" id="ch00lev1sec45"><strong>5.5 Using the Java Bytecode Disassembler to Analyze Java Output</strong></h3>&#13;
		<p class="noindent">Most Java compilers (particularly those from Oracle, Inc.) do not generate machine code directly. Instead, they generate Java bytecode (JBC), which computer systems then execute using a JBC interpreter. To improve performance, some Java interpreters run a just-in-time (JIT) compiler that translates JBC into native machine code during interpretation to improve performance (though the result is rarely as good as the machine code an optimizing compiler generates). Unfortunately, because the Java interpreter does this translation at runtime, it is difficult to analyze the machine code output from the Java compiler. It is, however, possible to analyze the JBC it produces. This can give you a better picture of what the compiler is doing with your Java code than simply guessing. Consider the following (relatively trivial) Java program:</p>&#13;
		<pre class="programs">&#13;
			public class Welcome<br/>{<br/>    public static void main( String[] args )<br/>    {<br/>        switch(5)<br/>        {<br/>            case 0:<br/>                System.out.println("0");<br/>                break;<br/>            case 1:<br/>                System.out.println("1");<br/>                break;<br/>            case 2:<br/>            case 5:<br/>                System.out.println("5");<br/>                break;<br/>            default:<br/>                System.out.println("default" );<br/>        }<br/>        System.out.println( "Hello World" );<br/>    }<br/>}</pre>&#13;
		<p class="indent">Typically, you can compile this program (<em>Welcome.java</em>) using a command line of the form:</p>&#13;
		<pre class="programs">javac Welcome.java</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_131"/>This command produces the <em>Welcome.class</em> JBC file. You can use the following command to disassemble this file (to the standard output):</p>&#13;
		<pre class="programs">javap -c Welcome</pre>&#13;
		<p class="indent">Note that you do not include the <em>.class</em> file extension on the command line; the <code>javap</code> command automatically supplies it.</p>&#13;
		<p class="indent">The <code>javap</code> command produces a bytecode disassembly listing similar to the following:</p>&#13;
		<pre class="programs">&#13;
			Compiled from "Welcome.java"<br/>public class Welcome extends java.lang.Object{<br/>public Welcome();<br/>  Code:<br/>   0:   aload_0<br/>   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V<br/>   4:   return<br/><br/>public static void main(java.lang.String[]);<br/>  Code:<br/>   0:   iconst_5<br/>   1:   tableswitch{ //0 to 5<br/>        0: 40;<br/>        1: 51;<br/>        2: 62;<br/>        3: 73;<br/>        4: 73;<br/>        5: 62;<br/>        default: 73 }<br/>   40:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;<br/>   43:  ldc #3;             //String 0<br/>   45:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br/>   48:  goto    81<br/>   51:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;<br/>   54:  ldc #5;             //String 1<br/>   56:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br/>   59:  goto    81<br/>   62:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;<br/>   65:  ldc #6;             //String 5<br/>   67:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br/>   70:  goto    81<br/>   73:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;<br/>   76:  ldc #7;             //String default<br/>   78:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br/>   81:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;<br/>   84:  ldc #8;             //String Hello World<br/>   86:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br/>   89:  return<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_132"/>You can find documentation for the JBC mnemonics and the <code>javap</code> Java class file disassembler on <a href="http://Oracle.com">Oracle.com</a> (search the site for “javap” and “Java bytecode disassembler”). Also, the online chapters (specifically, Appendix D) accompanying this book discuss the Java VM bytecode assembly language.</p>&#13;
		<h3 class="h3" id="ch00lev1sec46"><strong>5.6 Using the IL Disassembler to Analyze Microsoft C# and Visual Basic Output</strong></h3>&#13;
		<p class="noindent">Microsoft’s .NET language compilers do not directly emit native machine code. Instead, they emit a special IL (intermediate language) code. This is quite similar, in principle, to Java bytecode or UCSD p-machine code. The .NET runtime system will compile IL executable files and run them using a JIT compiler.</p>&#13;
		<p class="indent">The Microsoft C# compiler is a good example of a .NET language that works in this fashion. Compiling a simple C# program will produce a Microsoft <em>.exe</em> file that you can examine with <code>dumpbin</code>. Unfortunately, you can’t use <code>dumpbin</code> to look at the object code (IL or otherwise). Fortunately, Microsoft supplies a utility, <em>ildasm.exe</em>, that you can use to disassemble the IL byte/assembly code.</p>&#13;
		<p class="indent">Consider the following small C# example program (<em>Class1.cs</em>, a slight tweak of the ubiquitous “Hello World!” program):</p>&#13;
		<pre class="programs">&#13;
			using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Text;<br/>using System.Threading.Tasks;<br/><br/>namespace Hello_World<br/>{<br/>    class program<br/>    {<br/>        static void Main( string[] args)<br/>        {<br/>            int i = 5;<br/>            int j = 6;<br/>            int k = i + j;<br/>            Console.WriteLine("Hello World! k={0}", k);<br/>        }<br/>    }<br/>}</pre>&#13;
		<p class="indent">Typing <code>ildasm class1.exe</code> from a command prompt brings up the window shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>&#13;
		<div class="image" id="ch5fig3">&#13;
			<span epub:type="pagebreak" id="page_133"/>&#13;
			<img alt="Image" src="../images/05fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 5-3: IL disassembler window</em></p>&#13;
		<p class="indent">To view the code disassembly, double-click the S icon (next to the Main entry). This opens a window containing the following text (comments added for clarity):</p>&#13;
		<pre class="programs">&#13;
			.method private hidebysig static void  Main(string[] args) cil managed<br/>{<br/>  .entrypoint<br/>  // Code size       25 (0x19)<br/>  .maxstack  2<br/>  .locals init (int32 V_0,<br/>           int32 V_1,<br/>           int32 V_2)<br/>; push constant 5 on stack<br/><br/>  IL_0000:  ldc.i4.5<br/><br/>; pop stack and store into i<br/><br/>  IL_0001:  stloc.0<br/><br/><span epub:type="pagebreak" id="page_134"/>; push constant 6 on stack<br/><br/>  IL_0002:  ldc.i4.6<br/><br/>; pop stack and store in j<br/><br/>  IL_0003:  stloc.1<br/><br/>; Push i and j onto stack:<br/><br/>  IL_0004:  ldloc.0<br/>  IL_0005:  ldloc.1<br/><br/>; Add two items on stack, leave result on stack<br/><br/>  IL_0006:  add<br/><br/>; Store sum into k<br/><br/>  IL_0007:  stloc.2<br/><br/>; Load string onto stack (pointer to string)<br/><br/>  IL_0008:  ldstr      "Hello World! k={0}"<br/><br/>; Push k's value onto stack:<br/><br/>  IL_000d:  ldloc.2<br/>  IL_000e:  box        [mscorlib]System.Int32<br/><br/>; call writeline routine:<br/><br/>  IL_0013:  call       void [mscorlib]System.Console::WriteLine(string,<br/>                                                                object)<br/>  IL_0018:  ret<br/>} // end of method program::Main</pre>&#13;
		<p class="indent">You can use the IL disassembler program for any .NET language (such as Visual Basic and F#). See Appendix E online for details on Microsoft’s IL assembly language.</p>&#13;
		<h3 class="h3" id="ch00lev1sec47"><strong>5.7 Using a Debugger to Analyze Compiler Output</strong></h3>&#13;
		<p class="noindent">Another option you can use to analyze compiler output is a debugger program, which usually incorporates a disassembler that you can use to view machine instructions. Depending on the debugger you use, viewing your compiler output this way can be either a headache or a breeze. Typically, if you use a stand-alone debugger, you’ll find that it takes considerably more effort to analyze your compiler output than if you use a debugger built into a compiler’s IDE. This section looks at both approaches.</p>&#13;
		<h4 class="h4" id="ch00lev2sec64"><span epub:type="pagebreak" id="page_135"/><strong>5.7.1 Using an IDE’s Debugger</strong></h4>&#13;
		<p class="noindent">The Microsoft Visual C++ environment provides excellent tools for analyzing the code produced by a compilation (of course, the compiler also produces assembly output, but we’ll ignore that fact here). To view the output using the Visual Studio debugger, first compile your C/C++ program to an executable file and then select <strong>Debug</strong> ▸ <strong>Step Into</strong> from the Visual Studio Debug menu. When the program pauses execution, select <strong>Debug</strong> ▸ <strong>Windows</strong> ▸ <strong>Disassembly</strong> from the debug menu. For the <em>t1.c</em> program (see “Example Assembly Language Output” on <a href="ch05.xhtml#page_102">page 102</a>), you should see a disassembly like the following (assuming you’re producing 32-bit code):</p>&#13;
		<pre class="programs">&#13;
			--- c:\users\rhyde\test\t\t\t.cpp ----------------------------------------------<br/>#include "stdafx.h"<br/>#include &lt;stdio.h&gt;<br/>int main(int argc, char **argv)<br/>{<br/>00F61000  push        ebp<br/>00F61001  mov         ebp,esp<br/>00F61003  sub         esp,8<br/>    int i;<br/>    int j;<br/><br/>    i = argc;<br/>00F61006  mov         eax,dword ptr [argc]<br/>00F61009  mov         dword ptr [i],eax<br/>    j = **argv;<br/>00F6100C  mov         ecx,dword ptr [argv]<br/>00F6100F  mov         edx,dword ptr [ecx]<br/>00F61011  movsx       eax,byte ptr [edx]<br/>00F61014  mov         dword ptr [j],eax<br/><br/><br/>    if (i == 2)<br/>00F61017  cmp         dword ptr [i],2<br/>00F6101B  jne         main+28h (0F61028h)<br/>    {<br/>        ++j;<br/>00F6101D  mov         ecx,dword ptr [j]<br/>00F61020  add         ecx,1<br/>00F61023  mov         dword ptr [j],ecx<br/>    }<br/>    else<br/>00F61026  jmp         main+31h (0F61031h)<br/>    {<br/>        --j;<br/>00F61028  mov         edx,dword ptr [j]<br/>00F6102B  sub         edx,1<br/>00F6102E  mov         dword ptr [j],edx<br/>    }<br/><br/>    printf("i=%d, j=%d\n", i, j);<br/>00F61031  mov         eax,dword ptr [j]<br/>00F61034  push        eax<br/><span epub:type="pagebreak" id="page_136"/>00F61035  mov         ecx,dword ptr [i]<br/>00F61038  push        ecx<br/>00F61039  push        0F620F8h<br/>00F6103E  call        printf (0F61090h)<br/>00F61043  add         esp,0Ch<br/>    return 0;<br/>00F61046  xor         eax,eax<br/>}<br/>00F61048  mov         esp,ebp<br/>00F6104A  pop         ebp<br/>00F6104B  ret</pre>&#13;
		<p class="indent">Of course, because Microsoft’s Visual C++ package is already capable of outputting an assembly language file during compilation, using the Visual Studio integrated debugger in this manner isn’t necessary.<sup><a id="ch5fn_3"/><a href="footnotes.xhtml#ch5fn3">3</a></sup> However, some compilers do not provide assembly output, and debugger output may be the easiest way to view the machine code the compiler produces. For example, Embarcadero’s Delphi compiler does not provide an option to produce assembly language output. Given the massive amount of class library code that Delphi links into an application, attempting to view the code for a small section of your program by using a disassembler would be like trying to find a needle in a haystack. A better solution is to use the debugger built into the Delphi environment.</p>&#13;
		<h4 class="h4" id="ch00lev2sec65"><strong>5.7.2 Using a Stand-Alone Debugger</strong></h4>&#13;
		<p class="noindent">If your compiler doesn’t provide its own debugger as part of an IDE, another alternative is to use a separate debugger such as OllyDbg, DDD, or GDB to disassemble your compiler’s output. Simply load the executable file into the debugger for normal debugging operations.</p>&#13;
		<p class="indent">Most debuggers that are not associated with a particular programming language are machine-level debuggers that disassemble the binary machine code into machine instructions for viewing during the debugging operation. One problem with using machine-level debuggers is that locating a particular section of code to disassemble can be difficult. Remember, when you load the entire executable file into a debugger, you load in all the statically linked library routines and other runtime support code that doesn’t normally appear in the application’s source file. Searching through all this extraneous code to find out how the compiler translates a particular sequence of statements to machine code can be time-consuming. Some serious code sleuthing may be necessary. Fortunately, most linkers collect all the library routines together and place them either at the beginning or end of the executable file. Therefore, that’s generally also where you’ll find the code associated with your application.</p>&#13;
		<p class="indent">Debuggers come in one of three different flavors: pure machine-level debuggers, symbolic <span epub:type="pagebreak" id="page_137"/>debuggers, and source-level debuggers. Symbolic debuggers and source-level debuggers require executable files to contain special debugging information and, therefore, the compiler must specifically include this extra information.</p>&#13;
		<p class="indent">Pure machine-level debuggers have no access to the original source code or symbols in the application. A pure machine-level debugger simply disassembles the application’s machine code and displays the listing using literal numeric constants and machine addresses. Reading through such code is difficult, but if you understand how compilers generate code for the HLL statements (as this book will teach you), then locating the machine code is easier. Nevertheless, without any symbolic information to provide a “root point” in the code, analysis can be difficult.</p>&#13;
		<p class="indent">Symbolic debuggers use special symbol table information found in the executable file (or a separate debugging file, in some instances) to associate labels with functions and, possibly, variable names in your source file. This feature makes locating sections of code within the disassembly listing much easier. When symbolic labels identify calls to functions, it’s much easier to see the correspondence between the disassembled code and your original HLL source code. One thing to keep in mind, however, is that symbolic information is available only if the application was compiled with debugging mode enabled. Check your compiler’s documentation to determine how to activate this feature for use with your debugger.</p>&#13;
		<p class="indent">Source-level debuggers actually display the original source code associated with the file the debugger is processing. In order to see the machine code the compiler produced, you often have to activate a special machine-level view of the program. As with symbolic debuggers, your compiler must produce special executable files (or auxiliary files) containing debug information that a source-level debugger can use. Clearly, source-level debuggers are much easier to work with because they show the correspondence between the original HLL source code and the disassembled machine code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec48"><strong>5.8 Comparing Output from Two Compilations</strong></h3>&#13;
		<p class="noindent">If you are an expert assembly language programmer and you’re well versed in compiler design, it should be pretty easy for you to determine what changes you’ll need to make to your HLL source code to improve the quality of the output machine code. However, most programmers (especially those who do not have considerable experience studying compiler output) can’t just read a compiler’s assembly language output. They have to compare the two sets of outputs (before and after a change) to determine which code is better. After all, not every change you make to your HLL source files will result in better code. Some changes will leave the machine code unaffected (in which case, you should use the more readable and maintainable version of the HLL source code). In other cases, you could actually make the output machine code worse. Therefore, unless you know exactly what a compiler is going to do when you make changes to your HLL source file, you should do a before-and-after comparison of the compiler’s output machine code before accepting any modifications you make.</p>&#13;
		<h4 class="h4" id="ch00lev2sec66"><span epub:type="pagebreak" id="page_138"/><strong>5.8.1 Before-and-After Comparisons with diff</strong></h4>&#13;
		<p class="noindent">Of course, the first reaction from any experienced software developer is, “Well, if we have to compare files, we’ll just use <code>diff</code>!” As it turns out, a typical <code>diff</code> (compute file differences) program will be useful for certain purposes, but it won’t be universally applicable when you’re comparing two different output files from a compiler. The problem with a program like <code>diff</code> is that it works great when there are only a few differences between two files, but it’s not so useful when the files are wildly different. For example, consider the following C program (<em>t.c</em>) and two different outputs produced by the Microsoft VC++ compiler:</p>&#13;
		<pre class="programs">&#13;
			extern void f( void );<br/>int main( int argc, char **argv )<br/>{<br/>    int boolResult;<br/><br/>    switch( argc )<br/>    {<br/>        case 1:<br/>            f();<br/>            break;<br/><br/>        case 10:<br/>            f();<br/>            break;<br/><br/>        case 100:<br/>            f();<br/>            break;<br/><br/>        case 1000:<br/>            f();<br/>            break;<br/><br/>        case 10000:<br/>            f();<br/>            break;<br/><br/>        case 100000:<br/>            f();<br/>            break;<br/><br/>        case 1000000:<br/>            f();<br/>            break;<br/><br/>        case 10000000:<br/>            f();<br/>            break;<br/><br/>        case 100000000:<br/>            f();<br/>            break;<br/><span epub:type="pagebreak" id="page_139"/><br/>        case 1000000000:<br/>            f();<br/>            break;<br/><br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the assembly language output MSVC++ produces when using the command line <code>cl /Fa t.c</code> (that is, when compiling without optimization):</p>&#13;
		<pre class="programs">&#13;
			  ; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1<br/><br/>include listing.inc<br/><br/>INCLUDELIB LIBCMT<br/>INCLUDELIB OLDNAMES<br/><br/>PUBLIC  main<br/>EXTRN   f:PROC<br/>pdata   SEGMENT<br/>$pdata$main DD  imagerel $LN16<br/>        DD      imagerel $LN16+201<br/>        DD      imagerel $unwind$main<br/>pdata   ENDS<br/>xdata   SEGMENT<br/>$unwind$main DD 010d01H<br/>        DD      0620dH<br/>xdata   ENDS<br/>; Function compile flags: /Odtp<br/>_TEXT   SEGMENT<br/>tv64 = 32<br/>argc$ = 64<br/>argv$ = 72<br/>main    PROC<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 4<br/>$LN16:<br/>        mov     QWORD PTR [rsp+16], rdx<br/>        mov     DWORD PTR [rsp+8], ecx<br/>        sub     rsp, 56                                 ; 00000038H<br/>; Line 7<br/>        mov     eax, DWORD PTR argc$[rsp]<br/>        mov     DWORD PTR tv64[rsp], eax<br/>        cmp     DWORD PTR tv64[rsp], 100000             ; 000186a0H<br/>        jg      SHORT $LN15@main<br/>        cmp     DWORD PTR tv64[rsp], 100000             ; 000186a0H<br/>        je      SHORT $LN9@main<br/>        cmp     DWORD PTR tv64[rsp], 1<br/>        je      SHORT $LN4@main<br/>        cmp     DWORD PTR tv64[rsp], 10<br/>        je      SHORT $LN5@main<br/>        cmp     DWORD PTR tv64[rsp], 100                ; 00000064H<br/>        je      SHORT $LN6@main<br/><span epub:type="pagebreak" id="page_140"/>        cmp     DWORD PTR tv64[rsp], 1000               ; 000003e8H<br/>        je      SHORT $LN7@main<br/>        cmp     DWORD PTR tv64[rsp], 10000              ; 00002710H<br/>        je      SHORT $LN8@main<br/>        jmp     SHORT $LN2@main<br/>$LN15@main:<br/>        cmp     DWORD PTR tv64[rsp], 1000000            ; 000f4240H<br/>        je      SHORT $LN10@main<br/>        cmp     DWORD PTR tv64[rsp], 10000000           ; 00989680H<br/>        je      SHORT $LN11@main<br/>        cmp     DWORD PTR tv64[rsp], 100000000          ; 05f5e100H<br/>        je      SHORT $LN12@main<br/>        cmp     DWORD PTR tv64[rsp], 1000000000         ; 3b9aca00H<br/>        je      SHORT $LN13@main<br/>        jmp     SHORT $LN2@main<br/>$LN4@main:<br/>; Line 10<br/>        call    f<br/>; Line 11<br/>        jmp     SHORT $LN2@main<br/>$LN5@main:<br/>; Line 14<br/>        call    f<br/>; Line 15<br/>        jmp     SHORT $LN2@main<br/>$LN6@main:<br/>; Line 18<br/>        call    f<br/>; Line 19<br/>        jmp     SHORT $LN2@main<br/>$LN7@main:<br/>; Line 22<br/>        call    f<br/>; Line 23<br/>        jmp     SHORT $LN2@main<br/>$LN8@main:<br/>; Line 26<br/>        call    f<br/>; Line 27<br/>        jmp     SHORT $LN2@main<br/>$LN9@main:<br/>; Line 30<br/>        call    f<br/>; Line 31<br/>        jmp     SHORT $LN2@main<br/>$LN10@main:<br/>; Line 34<br/>        call    f<br/>; Line 35<br/>        jmp     SHORT $LN2@main<br/>$LN11@main:<br/>; Line 38<br/>        call    f<br/>; Line 39<br/>        jmp     SHORT $LN2@main<br/><br/><span epub:type="pagebreak" id="page_141"/>$LN12@main:<br/>; Line 42<br/>        call    f<br/>; Line 43<br/>        jmp     SHORT $LN2@main<br/>$LN13@main:<br/>; Line 46<br/>        call    f<br/>$LN2@main:<br/>; Line 50<br/>        xor     eax, eax<br/>; Line 51<br/>        add     rsp, 56                                 ; 00000038H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS<br/>END</pre>&#13;
		<p class="indent">Here’s the assembly listing we get when we compile the C program with the command line <code>cl /Ox /Fa t.c</code> (<code>/Ox</code> enables maximum optimization for speed in Visual C++):</p>&#13;
		<pre class="programs">&#13;
			    ; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1<br/><br/>include listing.inc<br/><br/>INCLUDELIB LIBCMT<br/>INCLUDELIB OLDNAMES<br/><br/>PUBLIC  main<br/>EXTRN   f:PROC<br/>pdata   SEGMENT<br/>$pdata$main DD  imagerel $LN18<br/>        DD      imagerel $LN18+89<br/>        DD      imagerel $unwind$main<br/>pdata   ENDS<br/>xdata   SEGMENT<br/>$unwind$main DD 010401H<br/>        DD      04204H<br/>xdata   ENDS<br/>; Function compile flags: /Ogtpy<br/>_TEXT   SEGMENT<br/>argc$ = 48<br/>argv$ = 56<br/>main    PROC<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 4<br/>$LN18:<br/>        sub     rsp, 40                                 ; 00000028H<br/>; Line 7<br/>        cmp     ecx, 100000                             ; 000186a0H<br/>        jg      SHORT $LN15@main<br/>        je      SHORT $LN10@main<br/>        sub     ecx, 1<br/><span epub:type="pagebreak" id="page_142"/>        je      SHORT $LN10@main<br/>        sub     ecx, 9<br/>        je      SHORT $LN10@main<br/>        sub     ecx, 90                                 ; 0000005aH<br/>        je      SHORT $LN10@main<br/>        sub     ecx, 900                                ; 00000384H<br/>        je      SHORT $LN10@main<br/>        cmp     ecx, 9000                               ; 00002328H<br/>; Line 27<br/>        jmp     SHORT $LN16@main<br/>$LN15@main:<br/>; Line 7<br/>        cmp     ecx, 1000000                            ; 000f4240H<br/>        je      SHORT $LN10@main<br/>        cmp     ecx, 10000000                           ; 00989680H<br/>        je      SHORT $LN10@main<br/>        cmp     ecx, 100000000                          ; 05f5e100H<br/>        je      SHORT $LN10@main<br/>        cmp     ecx, 1000000000                         ; 3b9aca00H<br/>$LN16@main:<br/>        jne     SHORT $LN2@main<br/>$LN10@main:<br/>; Line 34<br/>        call    f<br/>$LN2@main:<br/>; Line 50<br/>        xor     eax, eax<br/>; Line 51<br/>        add     rsp, 40                                 ; 00000028H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS<br/>        END</pre>&#13;
		<p class="indent">It doesn’t take a very sharp eye to notice that the two assembly language output files are radically different. Running these two files through <code>diff</code> simply produces a lot of noise; the output from <code>diff</code> is more difficult to interpret than manually comparing the two assembly language output files.</p>&#13;
		<p class="indent">A differencing program like <code>diff</code> (or better yet, the differencing facility built into many advanced programming editors) works best for comparing two different outputs for a given HLL source file to which you’ve made a small change. In the current example, had we changed the statement <code>case 1000:</code> to <code>case 1001:</code>, then a <code>diff</code> of the resulting assembly file against the original produces the following output:</p>&#13;
		<pre class="programs">&#13;
			50c50<br/>&lt; cmp eax, 1000<br/><br/>---<br/>&gt; cmp eax, 1001</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_143"/>As long as you’re comfortable reading <code>diff</code> output, this isn’t too bad. However, a better solution is to use some commercially available file comparison programs. Two excellent options are Beyond Compare (<em><a href="https://www.scootersoftware.com/">https://www.scootersoftware.com/</a></em>) and Araxis Merge (<em><a href="https://www.araxis.com/merge/">https://www.araxis.com/merge/</a></em>).</p>&#13;
		<p class="indent">Of course, another way to compare compiler output is manually. Set two listings side by side (either on paper or on your monitor) and start analyzing them. In the current C example, if we compare the two different outputs from the C compiler (without optimization and with the <code>/Ox</code> optimization option), we’ll discover that both versions use a binary search algorithm to compare the <code>switch</code> value against a list of widely varying constants. The main difference between the optimized and unoptimized versions has to do with code duplication.</p>&#13;
		<p class="indent">In order to properly compare two assembly listings that a compiler produces, you’ll need to learn how to interpret the machine language output from your compilers and connect certain assembly language sequences with the statements in your HLL code. That’s the purpose of many of the chapters to come.</p>&#13;
		<h3 class="h3" id="ch00lev1sec49"><strong>5.9 For More Information</strong></h3>&#13;
		<p class="noindent">Your compiler’s manual is the first place to look when you’re trying to figure out how to view the machine code the compiler produces. Many compilers produce assembly language output as an option, and that’s the best way to view code output. If your compiler does not provide this option, a debugging tool built into the compiler’s IDE (if available) is another good choice. See the documentation for your IDE or compiler for details.</p>&#13;
		<p class="indent">Tools like <code>objdump</code> and <code>dumpbin</code> are also useful for examining compiler output. Check the Microsoft, FSF/GNU, or Apple LLVM documentation for details on using these programs. If you decide to use an external debugger, such as OllyDbg or GDB, check out the software’s user documentation, or visit the author’s support web page (for example, <em><a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a></em> for the OllyDbg debugger).<span epub:type="pagebreak" id="page_144"/></p>&#13;
	</body></html>