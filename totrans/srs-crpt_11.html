<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_181"/><span class="big">10</span><br/>RSA</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">The Rivest–Shamir–Adleman (RSA) cryptosystem revolutionized cryptography when it emerged in 1977 as the first public-key encryption scheme; whereas classical, symmetric-key encryption schemes use the same secret key to encrypt and decrypt messages, public-key encryption (also called <em>asymmetric</em> encryption) uses two keys: one is your public key, which can be used by anyone who wants to encrypt messages for you, and the other is your private key, which is required in order to decrypt messages encrypted using the public key. This magic is the reason why RSA came as a real breakthrough, and 40 years later, it’s still the paragon of public-key encryption and a workhorse of internet security. (One year prior to RSA, Diffie and Hellman had introduced the concept of public-key cryptography, but their scheme was unable to perform public-key encryption.)</p>
<p class="indent">RSA is above all an arithmetic trick. It works by creating a mathematical object called a <em>trapdoor permutation</em>, a function that transforms a number <em>x</em> <span epub:type="pagebreak" id="page_182"/>to a number <em>y</em> in the same range, such that computing <em>y</em> from <em>x</em> is easy using the public key, but computing <em>x</em> from <em>y</em> is practically impossible unless you know the private key—the <em>trapdoor</em>. (Think of <em>x</em> as a plaintext and <em>y</em> as a ciphertext.)</p>
<p class="indent">In addition to encryption, RSA is also used to build digital signatures, wherein the owner of the private key is the only one able to sign a message, and the public key enables anyone to verify the signature’s validity.</p>
<p class="indent">In this chapter, I explain how the RSA trapdoor permutation works, discuss RSA’s security relative to the factoring problem (discussed in <a href="ch09.xhtml#ch9">Chapter 9</a>), and then explain why the RSA trapdoor permutation alone isn’t enough to build <em>secure</em> encryption and signatures. I also discuss ways to implement RSA and demonstrate how to attack it.</p>
<p class="indent">We begin with an explanation of the basic mathematical notions behind RSA.</p>
<h3 class="h3" id="lev1sec66">The Math Behind RSA</h3>
<p class="noindent">When encrypting a message, RSA sees the message as a big number, and encryption consists essentially of multiplications of big numbers. Therefore, in order to understand how RSA works, we need to know what kind of big numbers it manipulates and how multiplication works on those numbers.</p>
<p class="indent">RSA sees the plaintext that it’s encrypting as a positive integer between 1 and <em>n</em> – 1, where <em>n</em> is a large number called the <em>modulus</em>. More precisely, RSA works on the numbers less than <em>n</em> that are co-prime with <em>n</em> and therefore that have no common prime factor with <em>n</em>. Such numbers, when multiplied together, yield another number that satisfies these criteria. We say that these numbers form a group, denoted <strong>Z</strong><sub><em>N</em></sub><sup>*</sup>, and call the multiplicative group of integers modulo <em>n</em>. (See the mathematical definition of a group in <a href="ch09.xhtml#lev2sec121">“What Is a Group?”</a> on page 174.)</p>
<p class="indent">For example, consider the group <strong>Z</strong><sub>4</sub><sup>*</sup> of integers modulo 4. Recall from <a href="ch09.xhtml#ch9">Chapter 9</a> that a group must include an identity element (that is, 1) and that each number <em>x</em> in the group must have an inverse, a number <em>y</em> such that <em>x</em> × <em>y</em> = 1. How do we determine that set that makes up <strong>Z</strong><sub>4</sub><sup>*</sup>? Based on our definitions, we know that 0 is not in the group <strong>Z</strong><sub>4</sub><sup>*</sup> because multiplying any number by 0 can never give 1, so 0 has no inverse. By the same token, the number 1 belongs to <strong>Z</strong><sub>4</sub><sup>*</sup> because 1 × 1 = 1, so 1 is its own inverse. However, the number 2 does not belong in this group because we can’t obtain 1 by multiplying 2 with another element of <strong>Z</strong><sub>4</sub><sup>*</sup> (the reason is that 2 isn’t co-prime with 4, because 4 and 2 share the factor of 2.) The number 3 belongs in the group <strong>Z</strong><sub>4</sub><sup>*</sup> because it is its own inverse within <strong>Z</strong><sub>4</sub><sup>*</sup>. Thus, we have <strong>Z</strong><sub>4</sub><sup>*</sup> = {1, 3}.</p>
<p class="indent">Now consider <strong>Z</strong><sub>5</sub><sup>*</sup>, the multiplicative group of integers modulo 5. What numbers does this set contain? The number 5 is prime, and 1, 2, 3, and 4 are all co-prime with 5, so the set of <strong>Z</strong><sub>5</sub><sup>*</sup> is {1, 2, 3, 4}. Let’s verify this: 2 × 3 mod 5 = 1, therefore, 2 is 3’s inverse, and 3 is 2’s inverse; note that 4 is its own inverse because 4 × 4 mod 5 = 1; finally, 1 is again its own inverse in the group.</p>
<p class="indent"><span epub:type="pagebreak" id="page_183"/>In order to find the number of elements in a group <strong>Z</strong><sub><em>n</em></sub><sup>*</sup> when <em>n</em> isn’t prime, we use <em>Euler’s totient function,</em> which is written as φ(<em>n</em>), with φ representing the Greek letter phi. This function gives the number of elements co-prime with <em>n</em>, which is the number of elements in <strong>Z</strong><sub><em>n</em></sub><sup>*</sup>. As a rule, if <em>n</em> is a product of prime numbers <em>n</em> = <em>p</em><sub>1</sub> × <em>p</em><sub>2</sub> × … × <em>p</em><sub><em>m</em></sub>, the number of elements in the group <strong>Z</strong><sub><em>n</em></sub><sup>*</sup> is the following:</p>
<p class="center">φ(<em>n</em>) = (<em>p</em><sub>1</sub> − 1) × (<em>p</em><sub>2</sub> − 1) × … × (<em>p<sub>m</sub></em> − 1)</p>
<p class="indent">RSA only deals with numbers <em>n</em> that are the product of two large primes, usually noted as <em>n</em> = <em>pq</em>. The associated group <strong>Z</strong><sub><em>N</em></sub><sup>*</sup> will then contain φ(<em>n</em>) = (<em>p</em> – 1)(<em>q</em> – 1) elements. By expanding this expression, we get the equivalent definition φ(<em>n</em>) = <em>n</em> – <em>p</em> – <em>q</em> + 1, or φ(<em>n</em>) = (<em>n</em> + 1) – (<em>p</em> + <em>q</em>), which expresses more intuitively the value of φ(<em>n</em>) relative to <em>n</em>. In other words, all but (<em>p</em> + <em>q</em>) numbers between 1 and <em>n</em> – 1 belong to <strong>Z</strong><sub><em>N</em></sub><sup>*</sup> and are “valid numbers” in RSA operations.</p>
<h3 class="h3" id="lev1sec67">The RSA Trapdoor Permutation</h3>
<p class="noindent">The RSA trapdoor permutation is the core algorithm behind RSA-based encryption and signatures. Given a modulus <em>n</em> and number <em>e</em>, called the <em>public exponent</em>, the RSA trapdoor permutation transforms a number <em>x</em> from the set <strong>Z</strong><sub><em>n</em></sub><sup>*</sup> into a number <em>y</em> = <em>x</em><sup><em>e</em></sup> mod <em>n</em>. In other words, it calculates the value that’s equal to <em>x</em> multiplied by itself <em>e</em> times modulo <em>n</em> and then returns the result. When we use the RSA trapdoor permutation to encrypt, the modulus <em>n</em> and the exponent <em>e</em> make up the RSA public key.</p>
<p class="indentb">In order to get <em>x</em> back from <em>y</em>, we use another number, denoted <em>d</em>, to compute the following:</p>
<p class="center"><em>y<sup>d</sup></em> mod <em>n</em> = (<em>x<sup>e</sup></em>)<sup><em>d</em></sup> mod <em>n</em> = <em>x<sup>ed</sup></em> mod <em>n</em> = <em>x</em></p>
<p class="indentt">Because <em>d</em> is the trapdoor that allows us to decrypt, it is part of the private key in an RSA key pair, and, unlike the public key, it should always be kept secret. The number <em>d</em> is also called the <em>secret exponent</em>.</p>
<p class="indent">Obviously, <em>d</em> isn’t just any number; it’s the number such that <em>e</em> multiplied by <em>d</em> is equivalent to 1, and therefore such that <em>x</em><sup><em>ed</em></sup> mod <em>n</em> = <em>x</em> for any <em>x</em>. More precisely, we must have <em>ed</em> = 1 mod φ(<em>n</em>) in order to get <em>x</em><sup><em>ed</em></sup> = <em>x</em><sup>1</sup> = <em>x</em> and to decrypt the message correctly. Note that we compute modulo φ(<em>n</em>) and not modulo <em>n</em> here because exponents behave like the indexes of elements of <strong>Z</strong><sub><em>n</em></sub><sup>*</sup> rather than as the elements themselves. Because <strong>Z</strong><sub><em>n</em></sub><sup>*</sup> has φ(<em>n</em>) elements, the index must be less than φ(<em>n</em>).</p>
<p class="indent">The number φ(<em>n</em>) is crucial to RSA’s security. In fact, finding φ(<em>n</em>) for an RSA modulus <em>n</em> is equivalent to breaking RSA, because the secret exponent <em>d</em> can easily be derived from φ(<em>n</em>) and <em>e</em>, by computing <em>e</em>’s inverse. Hence <em>p</em> and <em>q</em> should also be secret, since knowing <em>p</em> or <em>q</em> gives φ(<em>n</em>) by computing (<em>p</em> – 1)(<em>q</em> – 1) = φ(<em>n</em>).</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_184"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep">φ(n) <em>is also called the</em> order <em>of the group</em> <strong>Z</strong><sub>n</sub><sup>*</sup>; <em>the order is an important characteristic of a group, which is also essential to other public-key systems such as Diffie–Hellman and elliptic curve cryptography.</em></p>
</div>
<h3 class="h3" id="lev1sec68">RSA Key Generation and Security</h3>
<p class="noindent"><em>Key generation</em> is the process by which an RSA key pair is created, namely a public key (modulus <em>n</em> and public exponent <em>e</em>) and its private key (secret exponent <em>d</em>). The numbers <em>p</em> and <em>q</em> (such that <em>n</em> = <em>pq</em>) and the order φ(<em>n</em>) should also be secret, so they’re often seen as part of the private key.</p>
<p class="indent">In order to generate an RSA key pair, we first pick two random prime numbers, <em>p</em> and <em>q</em>, and then compute φ(<em>n</em>) from these, and we compute <em>d</em> as the inverse of <em>e</em>. To show how this works, <a href="ch10.xhtml#ch10list1">Listing 10-1</a> uses SageMath (<em><a href="http://www.sagemath.org/">http://www.sagemath.org/</a></em>), an open-source Python-like environment that includes many mathematical packages.</p>
<p class="programs"><span class="ent">❶</span> sage: <span class="codestrong">p = random_prime(2^32); p</span><br/>   1103222539<br/><span class="ent">❷</span> sage: <span class="codestrong">q = random_prime(2^32); q</span><br/>   17870599<br/><span class="ent">❸</span> sage: <span class="codestrong">n = p*q; n</span><br/>   19715247602230861‬<br/><span class="ent">❹</span> sage: <span class="codestrong">phi = (p-1)*(q-1); phi</span><br/>   36567230045260644<br/><span class="ent">❺</span> sage: <span class="codestrong">e = random_prime(phi); e</span><br/>   13771927877214701<br/><span class="ent">❻</span> sage: <span class="codestrong">d = xgcd(e, phi)[1]; d</span><br/>   15417970063428857<br/><span class="ent">❼</span> sage: <span class="codestrong">mod(d*e, phi)</span><br/>   1</p>
<p class="figcap"><a id="ch10list1"/><em>Listing 10-1: Generating RSA parameters using SageMath</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In order to avoid multiple pages of output, I’ve used a 64-bit modulus</em> n <em>in <a href="ch10.xhtml#ch10list1">Listing 10-1</a>, but in practice an RSA modulus should be at least 2048 bits.</em></p>
</div>
<p class="indent">We use the <span class="literal">random_prime()</span> function to pick random primes <span class="literal">p</span> <span class="ent">❶</span> and <span class="literal">q</span> <span class="ent">❷</span>, which are lower than a given argument. Next, we multiply <span class="literal">p</span> and <span class="literal">q</span> to get the modulus <span class="literal">n</span> <span class="ent">❸</span> and φ(<em>n</em>), which is the variable <span class="literal">phi</span> <span class="ent">❹</span>. We then generate a random public exponent, <span class="literal">e</span> <span class="ent">❺</span>, by picking a random prime less than <span class="literal">phi</span> in order to ensure that <span class="literal">e</span> will have an inverse modulo <span class="literal">phi</span>. We then generate the associated private exponent <em>d</em> by using the <span class="literal">xgcd()</span> function from Sage <span class="ent">❻</span>. This function computes the numbers <em>s</em> and <em>t</em> given two numbers, <em>a</em> and <em>b</em>, with the extended Euclidean algorithm such that <em>as</em> + <em>bt</em> = <strong>GCD</strong>(<em>a</em>, <em>b</em>). Finally, we check that <em>ed</em> mod φ(<em>n</em>) = 1 <span class="ent">❼</span>, to ensure that <em>d</em> will work correctly to invert the RSA permutation.</p>
<p class="indent">Now we can apply the trapdoor permutation, as shown in <a href="ch10.xhtml#ch10list2">Listing 10-2</a>.<span epub:type="pagebreak" id="page_185"/></p>
<p class="programs"><span class="ent">❶</span> sage: <span class="codestrong">x = 1234567</span><br/><span class="ent">❷</span> sage: <span class="codestrong">y = power_mod(x, e, n); y</span><br/>  19048323055755904<br/><span class="ent">❸</span> sage: <span class="codestrong">power_mod(y, d, n)</span><br/>  1234567</p>
<p class="figcap"><a id="ch10list2"/><em>Listing 10-2: Computing the RSA trapdoor permutation back and forth</em></p>
<p class="indent">We assign the integer 1234567 to <em>x</em> <span class="ent">❶</span> and then use the function <span class="literal">power_mod(x, e, n)</span>, the exponentiation modulo <em>n</em>, or <em>x</em><sup><em>e</em></sup> mod <em>n</em> in equation form, to calculate <em>y</em> <span class="ent">❷</span>. Having computed <em>y</em> = <em>x</em><sup><em>e</em></sup> mod <em>n</em>, we compute <em>y</em><sup><em>d</em></sup> mod <em>n</em> <span class="ent">❸</span> with the trapdoor <em>d</em> to return the original <em>x</em>.</p>
<p class="indent">But how hard is it to find <em>x</em> without the trapdoor <em>d</em>? An attacker who can factor big numbers can break RSA by recovering <em>p</em> and <em>q</em> and then φ(<em>n</em>) in order to compute <em>d</em> from <em>e</em>. But that’s not the only risk. Another risk to RSA lies in an attacker’s ability to compute <em>x</em> from <em>x</em><sup><em>e</em></sup> mod <em>n</em>, or <em>e</em> th roots modulo <em>n</em>, without necessarily factoring <em>n</em>. Both risks seem closely connected, though we don’t know for sure whether they are equivalent.</p>
<p class="indent">Assuming that factoring is indeed hard and that finding <em>e</em> th roots is about as hard, RSA’s security level depends on three factors: the size of <em>n</em>, the choice of <em>p</em> and <em>q</em>, and how the trapdoor permutation is used. If <em>n</em> is too small, it could be factored in a realistic amount of time, revealing the private key. To be safe, <em>n</em> should at least be 2048 bits long (a security level of about 90 bits, requiring a computational effort of about 2<sup>90</sup> operations), but preferably 4096 bits long (a security level of approximately 128 bits). The values <em>p</em> and <em>q</em> should be unrelated random prime numbers of similar size. If they are too small, or too close together, it becomes easier to determine their value from <em>n</em>. Finally, the RSA trapdoor permutation should not be used directly for encryption or signing, as I’ll discuss shortly.</p>
<h3 class="h3" id="lev1sec69">Encrypting with RSA</h3>
<p class="noindent">Typically, RSA is used in combination with a symmetric encryption scheme, where RSA is used to encrypt a symmetric key that is then used to encrypt a message with a cipher such as the Advanced Encryption Standard (AES). But encrypting a message or symmetric key with RSA is more complicated than simply converting the target to a number <em>x</em> and computing <em>x</em><sup><em>e</em></sup> mod <em>n</em>.</p>
<p class="indent">In the following subsections, I explain why a naive application of the RSA trapdoor permutation is insecure, and how strong RSA-based encryption works.</p>
<h4 class="h4" id="lev2sec125"><em>Breaking Textbook RSA Encryption’s Malleability</em></h4>
<p class="noindent"><em>Textbook RSA encryption</em> is the phrase used to describe the simplistic RSA encryption scheme wherein the plaintext contains only the message you want to encrypt. For example, to encrypt the string <em>RSA</em>, we would first convert it to a number by concatenating the ASCII encodings of each of the three letters as a byte: <em>R</em> (byte 52), <em>S</em> (byte 53), and <em>A</em> (byte 41). The <span epub:type="pagebreak" id="page_186"/>resulting byte string <span class="literal">525341</span> is equal to 5395265 when converted to decimal, which we might then encrypt by computing 5395265<sup><em>e</em></sup> mod <em>n</em>. Without knowing the secret key, there would be no way to decrypt the message.</p>
<p class="indentb">However, textbook RSA encryption is deterministic: if you encrypt the same plaintext twice, you’ll get the same ciphertext twice. That’s one problem, but there’s a bigger problem—given two textbook RSA ciphertexts <em>y</em><sub>1</sub> = <em>x</em><sub>1</sub><sup><em>e</em></sup> mod <em>n</em> and <em>y</em><sub>2</sub> = <em>x</em><sub>2</sub><sup><em>e</em></sup> mod <em>n</em>, you can derive the ciphertext of <em>x</em><sub>1</sub> × <em>x</em><sub>2</sub> by multiplying these two ciphertexts together, like this:</p>
<p class="center"><em>y</em><sub>1</sub> × <em>y</em><sub>2</sub> mod <em>n</em> = <em>x</em><sub>1</sub><sup><em>e</em></sup> × <em>x</em><sub>2</sub><sup><em>e</em></sup> mod <em>n</em> = (<em>x</em><sub>1</sub> × <em>x</em><sub>2</sub>)<sup><em>e</em></sup> mod <em>n</em></p>
<p class="indentt">The result is (<em>x</em><sub>1</sub> × <em>x</em><sub>2</sub>)<sup><em>e</em></sup> mod <em>n</em>, the ciphertext of the message <em>x</em><sub>1</sub> × <em>x</em><sub>2</sub> mod <em>n</em>. Thus an attacker could create a new valid ciphertext from two RSA ciphertexts, allowing them to compromise the security of your encryption by letting them deduce information about the original message. We say that this weakness makes textbook RSA encryption <em>malleable</em>. (Of course, if you know <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>, you can compute (<em>x</em><sub>1</sub> × <em>x</em><sub>2</sub>)<sup><em>e</em></sup> mod <em>n</em>, too, but if you only know <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub>, you should not be able to multiply ciphertexts and get a ciphertext of the multiplied plaintexts.)</p>
<h4 class="h4" id="lev2sec126"><em>Strong RSA Encryption: OAEP</em></h4>
<p class="noindent">In order to make RSA ciphertexts nonmalleable, the ciphertext should consist of the message data and some additional data called <em>padding</em>, as shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>. The standard way to encrypt with RSA in this fashion is to use Optimal Asymmetric Encryption Padding (OAEP), commonly referred to as RSA-OAEP. This scheme involves creating a bit string as large as the modulus by padding the message with extra data and randomness before applying the RSA function.</p>
<div class="image"><img src="../images/f10-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch10fig1"/><em>Figure 10-1: Encrypting a symmetric key,</em> K, <em>with RSA using</em> (n, e) <em>as a public key</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>OAEP is referred to as RSAES-OAEP in official documents such as the PKCS#1 standard by the RSA company and NIST’s Special Publication 800-56B. OAEP improves on the earlier method now called PKCS#1 v1.5, which is one of the first in a series of Public-Key Cryptography Standards (PKCS) created by RSA. It is markedly less secure than OAEP, yet is still used in many systems.</em></p>
</div>
<h5 class="h5"><span epub:type="pagebreak" id="page_187"/>OAEP’s Security</h5>
<p class="noindent">OAEP uses a pseudorandom number generator (PRNG) to ensure the indistinguishability and nonmalleability of ciphertexts by making the encryption probabilistic. It has been proven secure as long as the RSA function and the PRNG are secure and, to a lesser extent, as long as the hash functions aren’t too weak. You should use OAEP whenever you need to encrypt with RSA.</p>
<h5 class="h5">How OAEP Encryption Works</h5>
<p class="noindent">In order to encrypt with RSA in OAEP mode, you need a message (typically a symmetric key, <em>K</em>), a PRNG, and two hash functions. To create the ciphertext, you use a given modulus <em>n</em> long of <em>m</em> bytes (that is, 8<em>m</em> bits, and therefore an <em>n</em> lower than 2<sup>8</sup><sup><em>m</em></sup>). To encrypt <em>K</em>, the <em>encoded message</em> is formed as <em>M</em> = <em>H</em> || 00 … 00 || 01 || <em>K</em>, where <em>H</em> is an <em>h</em>-byte constant defined by the OAEP scheme, followed by as many 00 bytes as needed and a 01 byte. This encoded message, <em>M</em>, is then processed as described next and as depicted in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>.</p>
<div class="image"><img src="../images/f10-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch10fig2"/><em>Figure 10-2: Encrypting a symmetric key</em>, K, <em>with RSA-OAEP, where</em> H <em>is a fixed parameter and</em> R <em>is random bits</em></p>
<p class="indentt">Next, you generate an <em>h</em>-byte random string <em>R</em> and set <em>M</em> = <em>M</em> ⊕ <strong>Hash1</strong>(<em>R</em>), where <strong>Hash1</strong>(<em>R</em>) is as long as <em>M</em>. You then set <em>R</em> = <em>R</em> ⊕ <strong>Hash2</strong>(<em>M</em>), where <strong>Hash2</strong>(<em>M</em>) is as long as <em>R</em>. Now you use these new values of <em>M</em> and <em>R</em> to form an <em>m</em>-byte string <em>P</em> = 00 || <em>M</em> || <em>R</em>, which is as long as the modulus <em>n</em> and which can be converted to an integer number less than <em>n</em>. The result of this conversion is the number <em>x</em>, which is then used to compute the RSA function <em>x</em><sup><em>e</em></sup> mod <em>n</em> to get the ciphertext.</p>
<p class="indent">To decrypt a ciphertext <em>y</em>, you would first compute <em>x</em> = <em>y</em><sup><em>d</em></sup> mod <em>n</em> and, from this, recover the final values of <em>M</em> and <em>R</em>. Next, you would retrieve <em>M</em>’s initial value by computing <em>M</em> ⊕ <strong>Hash1</strong>(<em>R</em> ⊕ <strong>Hash2</strong>(<em>M</em>)). Finally, you would verify that <em>M</em> is of the form <em>H</em> || 00 … 00 || 01 || <em>K</em>, with an <em>h</em>-byte <em>H</em> and 00 bytes followed by a 01 byte.</p>
<p class="indent"><span epub:type="pagebreak" id="page_188"/>In practice, the parameters <em>m</em> and <em>h</em> (the length of the modulus and the length of <strong>Hash2</strong>’s output, respectively) are typically <em>m</em> = 256 bytes (for 2048-bit RSA) and <em>h</em> = 32 (using SHA-256 as <strong>Hash2</strong>). This leaves <em>m</em> – <em>h</em> – 1 = 223 bytes for <em>M</em>, of which up to <em>m</em> – 2<em>h</em> – 2 = 190 bytes are available for <em>K</em> (the “– 2” is due to the separator 01 byte in <em>M</em>). The <strong>Hash1</strong> hash value is then composed of <em>m</em> – <em>h</em> – 1 = 223 bytes, which is longer than the hash value of any common hash function.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In order to build a hash with such an unusual output length, the RSA standard documents specify the use of the</em> mask generating function <em>technique to create hash functions that return arbitrarily large hash values from any hash function.</em></p>
</div>
<h3 class="h3" id="lev1sec70">Signing with RSA</h3>
<p class="noindent">Digital signatures can prove that the holder of the private key tied to a particular digital signature signed some message and that the signature is authentic. Because no one other than the private key holder knows the private exponent <em>d</em>, no one can compute a signature <em>y</em> = <em>x</em><sup><em>d</em></sup> mod <em>n</em> from some value <em>x</em>, but everyone can verify <em>y</em><sup><em>e</em></sup> mod <em>n</em> = <em>x</em> given the public exponent <em>e</em>. That verified signature can be used in a court of law to demonstrate that the private-key holder did sign some particular message—a property of undeniability called <em>nonrepudiation</em>.</p>
<p class="indent">It’s tempting to see RSA signatures as the converse of encryption, but they are not. Signing with RSA is not the same as encrypting with the private key. Encryption provides confidentiality whereas a digital signature is used to prevent forgeries. The most salient example of this difference is that it’s okay for a signature scheme to leak information on the message signed, because the message is not secret. For example, a scheme that reveals parts of the messages could be a secure signature scheme but not a secure encryption scheme.</p>
<p class="indent">Due to the processing overhead required, public-key encryption can only process short messages, which are usually secret keys rather than actual messages. A signature scheme, however, can process messages of arbitrary sizes by using their hash values <strong>Hash</strong>(<em>M</em>) as a proxy, and it can be deterministic yet secure. Like RSA-OAEP, RSA-based signature schemes can use a padding scheme, but they can also use the maximal message space allowed by the RSA modulus.</p>
<h4 class="h4" id="lev2sec127"><em>Breaking Textbook RSA Signatures</em></h4>
<p class="noindent">What we call a <em>textbook RSA signature</em> is the method that signs a message, <em>x</em>, by directly computing <em>y</em> = <em>x</em><sup><em>d</em></sup> mod <em>n</em>, where <em>x</em> can be any number between 0 and <em>n</em> – 1. Like textbook encryption, textbook RSA signing is simple to specify and implement but also insecure in the face of several attacks. One such attack involves a trivial forgery: upon noticing that 0<sup><em>d</em></sup> mod <em>n</em> = 0, 1<sup><em>d</em></sup> mod <em>n</em> = 1, and (<em>n</em> – 1)<sup><em>d</em></sup> mod <em>n</em> = <em>n</em> – 1, regardless of the value of the private key <em>d</em>, an attacker can forge signatures of 0, 1, or <em>n</em> – 1 without knowing <em>d</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_189"/>More worrying is the <em>blinding</em> <em>attack</em>. For example, say you want to get a third party’s signature on some incriminating message, <em>M</em>, that you know they would never knowingly sign. To launch this attack, you could first find some value, <em>R</em>, such that <em>R</em><sup><em>e</em></sup><em>M</em> mod <em>n</em> is a message that your victim would knowingly sign. Next, you would convince them to sign that message and to show you their signature, which is equal to <em>S</em> = (<em>R</em><sup><em>e</em></sup><em>M</em>)<sup><em>d</em></sup> mod <em>n</em>, or the message raised to the power <em>d</em>. Now, given that signature, you can derive the signature of <em>M</em>, namely <em>M</em><sup><em>d</em></sup>, with the aid of some straightforward computations.</p>
<p class="indent">Here’s how this works: because <em>S</em> can be written as (<em>R</em><sup><em>e</em></sup><em>M</em>)<sup><em>d</em></sup> = <em>R</em><sup><em>ed</em></sup><em>M</em><sup><em>d</em></sup>, and because <em>R</em><sup><em>ed</em></sup> = <em>R</em> is equal to <em>R</em><sup><em>ed</em></sup> = <em>R</em> (by definition), we have S = (<em>R</em><sup><em>e</em></sup><em>M</em>)<sup><em>d</em></sup> = <em>RM</em><sup><em>d</em></sup>. To obtain <em>M</em><sup><em>d</em></sup>, we simply divide <em>S</em> by <em>R</em>, as follows, to obtain the signature:</p>
<p class="center"><em>S</em>/<em>R</em> = <em>RM<sup>d</sup></em>/<em>R</em> = <em>M<sup>d</sup></em></p>
<p class="indentt">As you can see, this is a practical and powerful attack.</p>
<h4 class="h4" id="lev2sec128"><em>The PSS Signature Standard</em></h4>
<p class="noindent">The RSA <em>Probabilistic Signature Scheme (PSS)</em> is to RSA signatures what OAEP is to RSA encryption. It was designed to make message signing more secure, thanks to the addition of padding data.</p>
<p class="indent">As shown in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>, PSS combines a message narrower than the modulus with some random and fixed bits before RSAing the results of this padding process.</p>
<div class="image"><img src="../images/f10-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch10fig3"/><em>Figure 10-3: Signing a message</em>, M, <em>with RSA and with the PSS standard, where</em> (n, d) <em>is the private key</em></p>
<p class="indentt">Like all public-key signature schemes, PSS works on a message’s hash rather than on the message itself. Signing <strong>Hash</strong>(<em>M</em>) is secure as long as the hash function is collision resistant. One particular benefit of PSS is that you can use it to sign messages of any length, because after hashing a message, you’ll obtain a hash value of the same length regardless of the message’s original length. The hash’s length is typically 256 bits, with the hash function SHA-256.</p>
<p class="indent">Why not sign by just running OAEP on <strong>Hash</strong>(<em>M</em>)? Unfortunately, you can’t. Although similar to PSS, OAEP has only been proven secure for encryption, not for signature.</p>
<p class="indent">Like OAEP, PSS also requires a PRNG and two hash functions. One, <strong>Hash1</strong>, is a typical hash with <em>h</em>-byte hash values such as SHA-256. The other, <strong>Hash2</strong>, is a wide-output hash like OAEP’s <strong>Hash2</strong>.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_190"/>The PSS signing procedure for message <em>M</em> works as follows (where <em>h</em> is <strong>Hash1</strong>’s output length):</p>
<ol>
<li class="noindent"><p class="list">Pick an <em>r</em>-byte random string <em>R</em> using the PRNG.</p></li>
<li class="noindent"><p class="list">Form an encoded message <em>M</em><em>′</em> = 0000000000000000 || <strong>Hash1</strong>(<em>M</em>) || <em>R</em>, long of <em>h</em> + <em>r</em> + 8 bytes (with eight zero bytes at the beginning).</p></li>
<li class="noindent"><p class="list">Compute the <em>h</em>-byte string <em>H</em> = <strong>Hash1</strong>(<em>M</em><em>′</em>).</p></li>
<li class="noindent"><p class="list">Set <em>L</em> = 00 … 00 || 01 || <em>R</em>, or a sequence of 00 bytes followed by a 01 byte and then <em>R</em>, with a number of 00 bytes such that <em>L</em> is long of <em>m</em> – <em>h</em> – 1 bytes (the byte width <em>m</em> of the modulus minus the hash length <em>h</em> minus 1).</p></li>
<li class="noindent"><p class="list">Set <em>L</em> = <em>L</em> ⊕ <strong>Hash2</strong>(<em>H</em>), thus replacing the previous value of <em>L</em> with a new value.</p></li>
<li class="noindent"><p class="list">Convert the <em>m</em>-byte string <em>P</em> = <em>L</em> || <em>H</em> || BC to a number, <em>x</em>, lower than <em>n</em>. Here, the byte BC is a fixed value appended after <em>H</em>.</p></li>
<li class="noindent"><p class="list">Given the value of <em>x</em> just obtained, compute the RSA function <em>x</em><sup><em>d</em></sup> mod <em>n</em> to obtain the signature.</p></li>
</ol>
<p class="indentt">To verify a signature given a message, <em>M</em>, you compute <strong>Hash1</strong>(<em>M</em>) and use the public exponent <em>e</em> to retrieve <em>L</em> and <em>H</em> and then <em>M′</em> from the signature, checking the padding’s correctness at each step.</p>
<p class="indent">In practice, the random string <em>R</em> (called a <em>sal</em><em>t</em> in the RSA-PSS standard) is usually as long as the hash value. For example, if you use <em>n</em> = 2048 bits and SHA-256 as the hash, the value <em>L</em> is long of <em>m</em> – <em>h</em> – 1 = 256 – 32 – 1 = 223 bytes, and the random string <em>R</em> would typically be 32 bytes.</p>
<p class="indent">Like OAEP, PSS is provably secure, standardized, and widely deployed. Also like OAEP, it looks needlessly complex and is prone to implementation errors and mishandled corner cases. But unlike RSA encryption, there’s a way to get around this extra complexity with a signature scheme that doesn’t even need a PRNG, thus reducing the risk of insecure RSA signatures caused by an insecure PRNG, as discussed next.</p>
<h4 class="h4" id="lev2sec129"><em>Full Domain Hash Signatures</em></h4>
<p class="noindent"><em>Full Domain Hash (FDH)</em> is the simplest signature scheme you can imagine. To implement it, you simply convert the byte string <strong>Hash</strong>(<em>M</em>) to a number, <em>x</em>, and create the signature <em>y</em> = <em>x</em><sup><em>d</em></sup> mod <em>n</em>, as shown in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>
<div class="image"><img src="../images/f10-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch10fig4"/><em>Figure 10-4: Signing a message with RSA using the Full Domain Hash technique</em></p>
<p class="indentt"><span epub:type="pagebreak" id="page_191"/>Signature verification is straightforward, too. Given a signature that is a number <em>y</em>, you compute <em>x</em> = <em>y</em><sup><em>e</em></sup> mod <em>n</em> and compare the result with <strong>Hash</strong>(<em>M</em>). It’s boringly simple, deterministic, yet secure. So why bother with the complexity of PSS?</p>
<p class="indent">The main reason is that PSS was released <em>after</em> FDH, in 1996, and it has a security proof that inspires more confidence than FDH. Specifically, its proof offers slightly higher security guarantees than the proof of FDH, and its use of randomness helped strengthen that proof.</p>
<p class="indent">These stronger theoretical guarantees are the main reason cryptographers prefer PSS over FDH, but most applications using PSS today could switch to FDH with no meaningful security loss. In some contexts, however, a viable reason to use PSS instead of FDH is that PSS’s randomness protects it from some attacks on its implementation, such as the fault attacks we’ll discuss in <a href="ch10.xhtml#lev1sec72">“How Things Can Go Wrong”</a> on page 196.</p>
<h3 class="h3" id="lev1sec71">RSA Implementations</h3>
<p class="noindent">I sincerely hope you’ll never have to implement RSA from scratch. If you’re asked to, run as fast as you can and question the sanity of the person who asked you to do so. It took decades for cryptographers and engineers to develop RSA implementations that are fast, sufficiently secure, and hopefully free of debilitating bugs, so you really don’t want to reinvent RSA. Even with all the documentation available, it would take months to complete this daunting task.</p>
<p class="indent">Typically, when implementing RSA, you’ll use a library or API that provides the necessary functions to carry out RSA operations. For example, the Go language has the following function in its <span class="literal">crypto</span> package (from <em><a href="https://www.golang.org/src/crypto/rsa/rsa.go">https://www.golang.org/src/crypto/rsa/rsa.go</a></em>):</p>
<p class="programs">func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte,<br/>label []byte) (out []byte, err error)</p>
<p class="indent">The function <span class="literal">EncryptOAEP()</span> takes a hash value, a PRNG, a public key, a message, and a label (an optional parameter of OAEP), and returns a signature and an error code. When you call <span class="literal">EncryptOAEP()</span>, it calls <span class="literal">encrypt()</span> to compute the RSA function given the padded data, as shown in <a href="ch10.xhtml#ch10list3">Listing 10-3</a>.</p>
<p class="programs">func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {<br/>    e := big.NewInt(int64(pub.E))<br/>    c.Exp(m, e, pub.N)<br/>    return c<br/>  }</p>
<p class="figcap"><a id="ch10list3"/><em>Listing 10-3: Implementing the core RSA encryption function from the Go language cryptography library</em></p>
<p class="indentt">The main operation shown in <a href="ch10.xhtml#ch10list3">Listing 10-3</a> is <span class="literal">c.Exp(m, e, pub.N)</span>, which raises a message, <span class="literal">m</span>, to the power <span class="literal">e</span> modulo <span class="literal">pub.N</span>, and assigns the result to the variable <span class="literal">c</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_192"/>If you choose to implement RSA instead of using a readily available library function, be sure to rely on an existing <em>big-number</em> library, which is a set of functions and types that allow you to define and compute arithmetic operations on large numbers thousands of bits long. For example, you might use the GNU Multiple Precision (GMP) arithmetic library in C, or Go’s <span class="literal">big</span> package. (Believe me, you don’t want to implement big-number arithmetic yourself.)</p>
<p class="indent">Even if you just use a library function when implementing RSA, be sure that you understand how the internals work in order to measure the risks.</p>
<h4 class="h4" id="lev2sec130"><em>Fast Exponentiation Algorithm: Square-and-Multiply</em></h4>
<p class="noindent">The operation of raising <em>x</em> to the power <em>e</em>, when computing <em>x</em><sup><em>e</em></sup> mod <em>n</em>, is called <em>exponentiation</em>. When we’re working with big numbers, as with RSA, this operation can be extremely slow if naively implemented. But how do we do this efficiently?</p>
<p class="indent">The naive way to compute <em>x</em><sup><em>e</em></sup> mod <em>n</em> takes <em>e</em> – 1 multiplications, as shown in the pseudocode algorithm in <a href="ch10.xhtml#ch10list4">Listing 10-4</a>.</p>
<p class="programs">expModNaive(x, e, n) {<br/>    y = x<br/>    for i = 1 to e – 1 {<br/>        y = y * x  mod n<br/>    }<br/>    return y<br/>}</p>
<p class="figcap"><a id="ch10list4"/><em>Listing 10-4: A naive exponentiation algorithm in pseudocode</em></p>
<p class="indentt">This algorithm is simple but highly inefficient. One way to get the same result exponentially faster is to square rather than multiply exponents until the correct value is reached. This family of methods is called <em>square-and-</em><em>multiply</em>, or <em>exponentiation by squaring</em> or <em>binary exponentiation</em>.</p>
<p class="indent">For example, say that we want to compute 3<sup>65537</sup> mod 36567232109354321. (The number 65537 is the public exponent used in most RSA implementations.) We could multiply the number 3 by itself 65536 times, or we could approach this problem with the understanding that 65537 can be written as 2<sup>16</sup> + 1 and use a series of squaring operations. Essentially, we do the following:</p>
<p class="indentb">Initialize a variable, <em>y</em> = 3, and then compute the following squaring (<em>y</em><sup>2</sup>) operations:</p>
<ol>
<li class="noindent"><p class="list">Set <em>y</em> = <em>y</em><sup>2</sup> mod <em>n</em> (now <em>y</em> = 3<sup>2</sup> mod <em>n</em>).</p></li>
<li class="noindent"><p class="list">Set <em>y</em> = <em>y</em><sup>2</sup> mod <em>n</em> (now <em>y</em> = (3<sup>2</sup>)<sup>2</sup> mod <em>n</em> = 3<sup>4</sup> mod <em>n</em>).</p></li>
<li class="noindent"><p class="list">Set <em>y</em> = <em>y</em><sup>2</sup> mod <em>n</em> (now <em>y</em> = (3<sup>4</sup>)<sup>2</sup> = 3<sup>8</sup> mod <em>n</em>).</p></li>
<li class="noindent"><p class="list">Set <em>y</em> = <em>y</em><sup>2</sup> mod <em>n</em> (now <em>y</em> = (3<sup>8</sup>)<sup>2</sup> = 3<sup>16</sup> mod <em>n</em>).</p></li>
<li class="noindent"><p class="list">Set <em>y</em> = <em>y</em><sup>2</sup> mod <em>n</em> (now <em>y</em> = (3<sup>16</sup>)<sup>2</sup>= 3<sup>32</sup> mod <em>n</em>).</p></li>
</ol>
<p class="indentt">And so on until <em>y</em> = 3<sup>65536</sup>, by performing 16 squarings.</p>
<p class="indent"><span epub:type="pagebreak" id="page_193"/>To get the final result, we return 3 × <em>y</em> mod <em>n</em> = 3<sup>65537</sup> mod <em>n</em> = 26652909283612267. In other words, we compute the result with only 17 multiplications rather than 65536 with the naive method.</p>
<p class="indent">More generally, a square-and-multiply method works by scanning the exponent’s bits one by one, from left to right, computing the square for each exponent’s bit to double the exponent’s value, and multiplying by the original number for each bit with a value of 1 encountered. In the preceding example, the exponent 65537 is 10000000000000001 in binary, and we squared <em>y</em> for each new bit and multiplied by the original number 3 only for the very first and last bits.</p>
<p class="indent"><a href="ch10.xhtml#ch10list5">Listing 10-5</a> shows how this would work as a general algorithm in pseudocode to compute <em>x</em><sup><em>e</em></sup> mod <em>n</em> when the exponent <em>e</em> consists of bits <em>e</em><sub><em>m</em></sub> <sub>–</sub> <sub>1</sub><em>e</em><sub><em>m</em></sub> <sub>–</sub> <sub>2</sub> … <em>e</em><sub>1</sub><em>e</em><sub>0</sub>, where <em>e</em><sub>0</sub> is the least significant bit.</p>
<p class="programs">expMod(x, e, n) {<br/>    y = x<br/>    for i = m – 1 to 0 {<br/>        y = y * y  mod n<br/>        if e<sub>i</sub> == 1 then<br/>            y = y * x  mod n<br/>    }<br/>    return y<br/>}</p>
<p class="figcap"><a id="ch10list5"/><em>Listing 10-5: A fast exponentiation algorithm in pseudocode</em></p>
<p class="indentt">The <span class="literal">expMod()</span> algorithm shown in <a href="ch10.xhtml#ch10list5">Listing 10-5</a> runs in time <em>O</em>(<em>m</em>), whereas the naive algorithm runs in time <em>O</em>(2<sup><em>m</em></sup>), where <em>m</em> is the bit length of the exponent. Here, <em>O</em>() is the asymptotic complexity notation introduced in <a href="ch09.xhtml#ch9">Chapter 9</a>.</p>
<p class="indent">Real systems often implement variants of this simplest square-and-multiply method. One such variant is the <em>sliding window</em> method, which considers blocks of bits rather than individual bits to perform a given multiplication operation. For example, see the function <span class="literal">expNN()</span> of the Go language, whose source code is available at <em><a href="https://golang.org/src/math/big/nat.go">https://golang.org/src/math/big/nat.go</a></em>.</p>
<p class="indent">How secure are these square-and-multiply exponentiation algorithms? Unfortunately, the tricks to speed the process up often result in increased vulnerability against some attacks. Let’s see what can go wrong.</p>
<p class="indent">The weakness in these algorithms is due to the fact that the exponentiation operations are heavily dependent on the exponent’s value. The <span class="literal">if</span> operation shown in <a href="ch10.xhtml#ch10list5">Listing 10-5</a> takes a different branch based on whether an exponent’s bit is 0 or 1. If a bit is 1, an iteration of the <span class="literal">for</span> loop will be slower than it will be for 0, and attackers who monitor the execution time of the RSA operation can exploit this time difference to recover a private exponent. This is called a timing attack. Attacks on hardware can distinguish 1 bit from 0 bits by monitoring the device’s power consumption and observing which iterations perform an extra multiplication to reveal which bits of the private exponent are 1.</p>
<p class="indent">Only a minority of cryptographic libraries implement effective defenses against timing attacks, let alone against such power-analysis attacks.</p>
<h4 class="h4" id="lev2sec131"><span epub:type="pagebreak" id="page_194"/><em>Small Exponents for Faster Public-Key Operations</em></h4>
<p class="noindent">Because an RSA computation is essentially the computation of an exponentiation, its performance depends on the value of the exponents used. Smaller exponents require fewer multiplications and therefore can make the exponentiation computation much faster.</p>
<p class="indent">The public exponent <em>e</em> can in principle be any value between 3 and φ(<em>n</em>) – 1, as long as <em>e</em> and φ(<em>n</em>) are co-prime. But in practice you’ll only find small values of <em>e</em>, and most of the time <em>e</em> = 65537 due to concerns with encryption and signature verification speed. For example, the Microsoft Windows CryptoAPI only supports public exponents that fit in a 32-bit integer. The larger the <em>e</em>, the slower it is to compute <em>x</em><sup><em>e</em></sup> mod <em>n.</em></p>
<p class="indent">Unlike the size of the public exponent, the private exponent <em>d</em> will be about as large as <em>n</em>, making decryption much slower than encryption, and signing much slower than verification. Indeed, because <em>d</em> is secret, it must be unpredictable and therefore can’t be restricted to a small value. For example, if <em>e</em> is fixed to 65537, the corresponding <em>d</em> will usually be of the same order of magnitude as the modulus <em>n</em>, which would be close to 2<sup>2048</sup> if <em>n</em> is 2048 bits long.</p>
<p class="indent">As discussed in <a href="ch10.xhtml#lev2sec130">“Fast Exponentiation Algorithm: Square-and-Multiply”</a> on page 192, raising a number to the power 65537 will only take 17 multiplications, whereas raising a number to the power of some 2048-bit number will take on the order of 3000 multiplications.</p>
<p class="indent">One way to determine the actual speed of RSA is to use the OpenSSL toolkit. For example, <a href="ch10.xhtml#ch10list6">Listing 10-6</a> shows the results of 512-, 1024-, 2048-, and 4096-bit RSA operations on my MacBook, which is equipped with an Intel Core i5-5257U clocked at 2.7 GHz.</p>
<p class="programs">$ <span class="codestrong">openssl speed rsa512 rsa1024 rsa2048 rsa4096</span><br/>Doing 512 bit private rsa's for 10s: 161476 512 bit private RSA's in 9.59s<br/>Doing 512 bit public rsa's for 10s: 1875805 512 bit public RSA's in 9.68s<br/>Doing 1024 bit private rsa's for 10s: 51500 1024 bit private RSA's in 8.97s<br/>Doing 1024 bit public rsa's for 10s: 715835 1024 bit public RSA's in 8.45s<br/>Doing 2048 bit private rsa's for 10s: 13111 2048 bit private RSA's in 9.65s<br/>Doing 2048 bit public rsa's for 10s: 288772 2048 bit public RSA's in 9.68s<br/>Doing 4096 bit private rsa's for 10s: 1273 4096 bit private RSA's in 9.71s<br/>Doing 4096 bit public rsa's for 10s: 63987 4096 bit public RSA's in 8.50s<br/>OpenSSL 1.0.2g  1 Mar 2016<br/>--<span class="codeitalic">snip</span>--<br/>                  sign    verify    sign/s verify/s<br/>rsa  512 bits 0.000059s 0.000005s  16838.0 193781.5<br/>rsa 1024 bits 0.000174s 0.000012s   5741.4  84714.2<br/>rsa 2048 bits 0.000736s 0.000034s   1358.7  29831.8<br/>rsa 4096 bits 0.007628s 0.000133s    131.1   7527.9</p>
<p class="figcap"><a id="ch10list6"/><em>Listing 10-6: Benchmarks of RSA operations using the OpenSSL toolkit</em></p>
<p class="indentt">How much slower is verification compared to signature generation? To get an idea, we can compute the ratio of the verification time over signature time. The benchmarks in <a href="ch10.xhtml#ch10list6">Listing 10-6</a> show that I’ve got <span epub:type="pagebreak" id="page_195"/>verification-over-signature speed ratios of approximately 11.51, 14.75, 21.96, and 57.42 for 512-, 1024-, 2048-, and 4096-bit moduli sizes, respectively. The gap grows with the modulus size because the number of multiplications for <em>e</em> operations will remain constant with respect to the modulus size (for example, 17 when <em>e</em> = 65537), while private-key operations will always need more multiplications for a greater modulus because <em>d</em> will grow accordingly.</p>
<p class="indentb">But if small exponents are so nice, why use 65537 and not something like 3? It would actually be fine (and faster) to use 3 as an exponent when implementing RSA with a secure scheme such as OAEP, PSS, or FDH. Cryptographers avoid doing so, however, because when <em>e</em> = 3, less secure schemes make certain types of mathematical attacks possible. The number 65537 is large enough to avoid such <em>low-exponent attacks</em>, and it has just one instance in which a bit is 1, thanks to its low Hamming weight, which decreases the computational time. 65537 is also special for mathematicians: it’s the fourth Fermat number, or a number of the form</p>
<p class="center">2<sup>(2<sup><em>n</em></sup>)</sup> + 1</p>
<p class="noindentt">because it’s equal to 2<sup>16</sup> + 1, where 16 = 2<sup>4</sup>, but that’s just a curiosity mostly irrelevant for cryptographic engineers.</p>
<h4 class="h4" id="lev2sec132"><em>The Chinese Remainder Theorem</em></h4>
<p class="noindent">The most common trick to speed up decryption and signature verification (that is, the computation of <em>y</em><sup><em>d</em></sup> mod <em>n</em>) is the <em>Chinese remainder theorem (CRT)</em>. It makes RSA about four times faster.</p>
<p class="indent">The Chinese remainder theorem allows for faster decryption by computing two exponentiations, modulo <em>p</em> and modulo <em>q</em>, rather than simply modulo <em>n</em>. Because <em>p</em> and <em>q</em> are much smaller than <em>n</em>, it’s faster to perform two “small” exponentiations than a single “big” one.</p>
<p class="indent">The Chinese remainder theorem isn’t specific to RSA. It’s a general arithmetic result that, in its simplest form, states that if <em>n</em> = <em>n</em><sub>1</sub><em>n</em><sub>2</sub><em>n</em><sub>3</sub> … , where the <em>n</em><sub><em>i</em></sub>s are pairwise co-prime (that is, <strong>GCD</strong>(<em>n</em><sub><em>i</em></sub>, <em>n</em><sub><em>j</em></sub>) = 1 for any distinct <em>i</em> and <em>j</em>), then the value <em>x</em> mod <em>n</em> can be computed from the values <em>x</em> mod <em>n</em><sub>1</sub>, <em>x</em> mod <em>n</em><sub>2</sub>, <em>x</em> mod <em>n</em><sub>3</sub>, … . For example, say we have <em>n</em> = 1155, which we write as the product of prime factors 3 × 5 × 7 × 11. We want to determine the number <em>x</em> that satisfies <em>x</em> mod 3 = 2, <em>x</em> mod 5 = 1, <em>x</em> mod 7 = 6, and <em>x</em> mod 11 = 8. (I’ve chosen 2, 1, 6, and 8 arbitrarily.)</p>
<p class="indentb">To find <em>x</em> using the Chinese remainder theorem, we can compute the sum <em>P</em>(<em>n</em><sub>1</sub>) + <em>P</em>(<em>n</em><sub>2</sub>) + … , where <em>P</em>(<em>n</em><sub><em>i</em></sub>) is defined as follows:</p>
<p class="center"><em>P</em>(<em>n<sub>i</sub></em>) = (<em>x</em> mod <em>n<sub>i</sub></em>) × <em>n</em> / <em>n<sub>i</sub></em> × (1 / (<em>n</em> / <em>n<sub>i</sub></em>) mod <em>n<sub>i</sub></em>) mod <em>n</em></p>
<p class="indentt">Note that the second term, <em>n</em>/<em>n</em><sub><em>i</em></sub>, is equal to the product of all other factors than this <em>n</em><sub><em>i</em></sub>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_196"/>To apply this formula to our example and recover our <em>x</em> mod 1155, we take the arbitrary values 2, 1, 6, and 8; we compute <em>P</em>(3), <em>P</em>(5), <em>P</em>(7), and <em>P</em>(8); and then we add them together to get the following expression:</p>
<div class="image1"><img src="../images/f0196-01.jpg" alt="image"/></div>
<p class="indent">Here, I’ve just applied the preceding definition of <em>P</em>(<em>n</em><sub><em>i</em></sub>). (The math behind the way each number was found is straightforward, but I won’t detail it here.) This expression can then be reduced to [770 + 231 + 1980 + 1680] mod <em>n</em> = 41, and indeed 41 is the number I had picked for this example, so we’ve got the correct result.</p>
<p class="indentb">Applying the CRT to RSA is simpler than the previous example, because there are only two factors for each <em>n</em> (namely <em>p</em> and <em>q</em>). Given a ciphertext <em>y</em> to decrypt, instead of computing <em>y</em><sup><em>d</em></sup> mod <em>n</em>, you use the CRT to compute <em>x</em><sub><em>p</em></sub> = <em>y</em><sup><em>s</em></sup> mod <em>p</em>, where <em>s</em> = <em>d</em> mod (<em>p</em> – 1) and <em>x</em><sub>q</sub> = <em>y</em><sup><em>t</em></sup> mod <em>q</em>, where <em>t</em> = <em>d</em> mod (<em>q</em> – 1). You now combine these two expressions and compute <em>x</em> to be the following:</p>
<p class="center"><em>x</em> = <em>x<sub>p</sub></em> × <em>q</em> × (1/<em>q</em> mod <em>p</em>) + <em>x<sub>q</sub></em> × <em>p</em> × (1/<em>p</em> mod <em>q</em>) mod <em>n</em></p>
<p class="indentt">And that’s it. This is faster than square-and-multiply because the multiplication-heavy operations are carried out on modulo <em>p</em> and <em>q</em>, numbers that are twice as small as <em>n</em>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In the final operation, the two numbers</em> q × (1/q <em>mod</em> p) <em>and</em> p × (1/p <em>mod</em> q) <em>can be computed in advance, which means only two multiplications and an addition of modulo</em> n <em>need to be computed to find</em> x.</p>
</div>
<p class="indentt">Unfortunately, there’s a security caveat attached to these techniques, as I’ll discuss next.</p>
<h3 class="h3" id="lev1sec72">How Things Can Go Wrong</h3>
<p class="noindent">Even more beautiful than the RSA scheme itself is the range of attacks that work either because the implementation leaks (or can be made to leak) information on its internals or because RSA is used insecurely. I discuss two classic examples of these types of attacks in the sections that follow.</p>
<h4 class="h4" id="lev2sec133"><em>The Bellcore Attack on RSA-CRT</em></h4>
<p class="noindent">The Bellcore attack on RSA is one of the most important attacks in the history of RSA. When first discovered in 1996, it stood out because it exploited RSA’s vulnerability to <em>fault injections</em>—attacks that force a part of the algorithm to misbehave and thus yield incorrect results. For example, hardware circuits or embedded systems can be temporarily perturbed by suddenly altering their voltage supply or by beaming a laser pulse to a carefully <span epub:type="pagebreak" id="page_197"/>chosen part of a chip. Attackers can then exploit the resulting faults in an algorithm’s internal operation by observing the impact on the final result. For example, comparing the correct result with a faulty one can provide information on the algorithm’s internal values, including secret values.</p>
<p class="indent">The Bellcore attack is such a fault attack. It works on RSA signature schemes that use the Chinese remainder theorem and that are deterministic—meaning that it works on FDH, but not on PSS, which is probabilistic.</p>
<p class="indentb">To understand how the Bellcore attack works, recall from the previous section that with CRT, the result that is equal to <em>x</em><sup><em>d</em></sup> mod <em>n</em> is obtained by computing the following, where <em>x</em><sub><em>p</em></sub> = <em>y</em><sup><em>s</em></sup> mod <em>p</em> and <em>x</em><sub><em>q</em></sub> = <em>y</em><sup><em>t</em></sup> mod <em>q</em>:</p>
<p class="center"><em>x</em> = <em>x<sub>p</sub></em> × <em>q</em> × (1/<em>q</em> mod <em>p</em>) + <em>x<sub>q</sub></em> × <em>p</em> × (1/<em>p</em> mod <em>q</em>) mod <em>n</em></p>
<p class="indent1">Now assume that an attacker induces a fault in the computation of <em>x</em><sub><em>q</em></sub> so that you end up with some incorrect value, which differs from the actual <em>x</em><sub><em>q</em></sub>. Let’s call this incorrect value <em>x</em><sub><em>q</em></sub>′ and call the final result obtained <em>x</em>′. The attacker can then subtract the incorrect signature <em>x</em>′ from the correct signature <em>x</em> to factor <em>n</em>, which results in the following:</p>
<p class="center"><em>x</em> − <em>x</em>′ = (<em>x<sub>q</sub></em> − <em>x</em><sub><em>q</em></sub>′) × <em>p</em> × (1/<em>p</em> mod <em>q</em>) mod <em>n</em></p>
<p class="indentt">The value <em>x</em> – <em>x</em>′ is therefore a multiple of <em>p</em>, so <em>p</em> is a divisor of <em>x</em> – <em>x</em>′. Because <em>p</em> is also a divisor of <em>n</em>, the greatest common divisor of <em>n</em> and <em>x</em> – <em>x</em>′ yields <em>p</em>, <strong>GCD</strong>(<em>x</em> – <em>x</em>′, <em>n</em>) = <em>p</em>. We can then compute <em>q</em> = <em>n</em>/<em>p</em> and <em>d</em>, resulting in a total break of RSA signatures.</p>
<p class="indent">A variant of this attack works when you don’t know the correct signature but only know the message is signed. There’s also a similar fault attack on the modulus value, rather than on the CRT values computation, but I won’t go into detail on that here.</p>
<h4 class="h4" id="lev2sec134"><em>Sharing Private Exponents or Moduli</em></h4>
<p class="noindent">Now I’ll show you why your public key shouldn’t have the same modulus <em>n</em> as that of someone else.</p>
<p class="indent">Different private keys belonging to different systems or persons should obviously have different private exponents, <em>d</em>, even if the keys use different moduli, or you could try your own value of <em>d</em> to decrypt messages encrypted for other entities, until you hit one that shares the same <em>d</em>. By the same token, different key pairs should have different <em>n</em> values, even if they have different <em>d</em>s, because <em>p</em> and <em>q</em> are usually part of the private key. Hence, if we share the same <em>n</em> and thus the same <em>p</em> and <em>q</em>, I can compute your private key from your public key <em>e</em> using <em>p</em> and <em>q</em>.</p>
<p class="indent">What if my private key is simply the pair (<em>n</em>, <em>d</em><sub>1</sub>), and your private key is (<em>n</em>, <em>d</em><sub>2</sub>) and your public key is (<em>n</em>, <em>e</em><sub>2</sub>)? Say that I know <em>n</em> but not <em>p</em> and <em>q</em>, so I can’t directly compute your private exponent <em>d</em><sub>2</sub> from your public exponent <em>e</em><sub>2</sub>. How would you compute <em>p</em> and <em>q</em> from a private exponent <em>d</em> only? The solution is a bit technical, but elegant.</p>
<p class="indent"><span epub:type="pagebreak" id="page_198"/>Remember that <em>d</em> and <em>e</em> satisfy <em>ed</em> = <em>k</em>φ(<em>n</em>) + 1, where φ(<em>n</em>) is secret and could give us <em>p</em> and <em>q</em> directly. We don’t know <em>k</em> or φ(<em>n</em>), but we can compute <em>k</em>φ(<em>n</em>) = <em>ed</em> – 1.</p>
<p class="indent">What can we do with this value <em>k</em>φ(<em>n</em>)? A first observation is that, according to <em>Euler’s theorem</em>, we know that for any number <em>a</em> co-prime with <em>n</em>, <em>a</em><sup>φ(<em>n</em>)</sup> = 1 mod <em>n</em>. Therefore, modulo <em>n</em> we have the following:</p>
<p class="center"><em>a</em><sup><em>kφ</em>(<em>n</em>)</sup> = (<em>a</em><sup>φ(<em>n</em>)</sup>)<sup><em>k</em></sup> = 1<sup><em>k</em></sup> = 1</p>
<p class="indentt">A second observation is that, because <em>k</em>φ(<em>n</em>) is an even number, we can write it as 2<sup><em>s</em></sup><em>t</em> for some numbers <em>s</em> and <em>t</em>. That is, we’ll be able to write <em>a</em><sup><em>k</em>φ(<em>n</em>)</sup> = 1 mod <em>n</em> under the form <em>x</em><sup>2</sup> = 1 mod <em>n</em> for some <em>x</em> easily computed from <em>k</em>φ(<em>n</em>). Such an <em>x</em> is called a <em>root of unity</em>.</p>
<p class="indent">The key observation is that <em>x</em><sup>2</sup> = 1 mod <em>n</em> is equivalent to saying that the value <em>x</em><sup>2</sup> – 1 = (<em>x</em> – 1)(<em>x</em> + 1) divides <em>n</em>. In other words, <em>x</em> – 1 or <em>x</em> + 1 must have a common factor with <em>n</em>, which can give us the factorization of <em>n</em>.</p>
<p class="indent"><a href="ch10.xhtml#ch10list7">Listing 10-7</a> shows a Python implementation of this method where, in order to find the factors <em>p</em> and <em>q</em> from <em>n</em> and <em>d</em>, we use small, 64-bit numbers for the sake of simplicity.</p>
<p class="programs">  from math import gcd<br/><br/>  n = 36567232109354321<br/>  e = 13771927877214701<br/>  d = 15417970063428857<br/><br/><span class="ent">❶</span> kphi = d*e - 1<br/>   t = kphi<br/><br/><span class="ent">❷</span> while t % 2 == 0:<br/>      t = divmod(t, 2)[0]<br/><br/><span class="ent">❸</span> a = 2<br/>  while a &lt; 100:<br/>   <span class="ent">❹</span> k = t<br/>      while k &lt; kphi:<br/>          x = pow(a, k, n)<br/>       <span class="ent">❺</span> if x ! = 1 and x ! = (n - 1) and pow(x, 2, n) == 1:<br/>           <span class="ent">❻</span> p = gcd(x - 1, n)<br/>              break<br/>          k = k*2<br/>      a = a + 2<br/><br/>  q = n//p<br/><span class="ent">❼</span> assert (p*q) == n<br/>  print('p = ', p)<br/>  print('q = ', q)</p>
<p class="figcap"><a id="ch10list7"/><em>Listing 10-7: A python program that computes the prime factors</em> p <em>and</em> q <em>from the private exponent</em> d</p>
<p class="indentt"><span epub:type="pagebreak" id="page_199"/>This program determines <em>k</em>φ(<em>n</em>) from <em>e</em> and <em>d</em> <span class="ent">❶</span> by finding the number <em>t</em> such that <em>k</em>φ(<em>n</em>) = 2<sup><em>s</em></sup><em>t</em>, for some <em>s</em> <span class="ent">❷</span>. Then it looks for <em>a</em> and <em>k</em> such that (<em>a</em><sup><em>k</em></sup>)<sup>2</sup> = 1 mod <em>n</em> <span class="ent">❸</span>, using <em>t</em> as a starting point for <em>k</em> <span class="ent">❹</span>. When this condition is satisfied <span class="ent">❺</span>, we’ve found a solution. It then determines the factor <em>p</em> <span class="ent">❻</span> and verifies <span class="ent">❼</span> that the value of <em>pq</em> equals the value of <em>n.</em> It then prints the resulting values of <em>p</em> and <em>q</em>:</p>
<p class="programs">p = 2046223079<br/>q = 17870599</p>
<p class="indentt">The program correctly returns the two factors.</p>
<h3 class="h3" id="lev1sec73">Further Reading</h3>
<p class="noindent">RSA deserves a book by itself. I had to omit many important and interesting topics, such as Bleichenbacher’s padding oracle attack on OAEP’s predecessor (the standard PKCS#1 v1.5), an attack similar in spirit to the padding oracle attack on block ciphers seen in <a href="ch04.xhtml#ch4">Chapter 4</a>. There’s also Wiener’s attack on RSA with low private exponents, and attacks using Coppersmith’s method on RSA with small exponents that potentially also have insecure padding.</p>
<p class="indent">To see research results related to side-channel attacks and defenses, view the CHES workshop proceedings that have run since 1999 at <em><a href="http://www.chesworkshop.org/">http://www.chesworkshop.org/</a></em>. One of the most useful references while writing this chapter was Boneh’s “Twenty Years of Attacks on the RSA Cryptosystem,” a survey that reviews and explains the most important attacks on RSA. For reference specifically on timing attacks, the paper “Remote Timing Attacks Are Practical” by Brumley and Boneh, is a must-read, both for its analytical and experimental contributions. To learn more about fault attacks, read the full version of the Bellcore attack paper “On the Importance of Eliminating Errors in Cryptographic Computations” by Boneh, DeMillo, and Lipton.</p>
<p class="indent">The best way to learn how RSA implementations work, though sometimes painful and frustrating, is to review the source code of widely used implementations. For example, see RSA and its underlying big-number arithmetic implementations in OpenSSL, in NSS (the library used by the Mozilla Firefox browser), in Crypto++, or in other popular software, and examine their implementations of arithmetic operations as well as their defenses against timing and fault attacks.<span epub:type="pagebreak" id="page_200"/></p>
</body></html>