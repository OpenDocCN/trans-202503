<html><head></head><body>
<h2 class="h2" id="ch6"><span epub:type="pagebreak" id="page_69"/><span class="big">6</span><br/>WRITING FUNCTIONS</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">So far, the code you’ve written has been fairly one-dimensional: your scripts had a single task. And while there’s nothing wrong with a script that can only access files in a folder, you’ll want code that can do more than one thing as you write more-robust PowerShell tools. There’s nothing</span> stopping you from packing more and more into a script. You could write a thousand lines of code that do hundreds of tasks, all in a single, uninterrupted block of code. But that script would be a mess to read and a mess to work with. You could break each task into its own script, but that would be a mess to use. You want one tool that can do many things, not a hundred that can each do a single thing.</p>&#13;
<p class="indent">To do this, you’ll break each task into its own <em>function</em>, a labeled piece of code that performs a single task. A function is defined once. You write the code to solve a certain problem once, store it in a function, and anytime you run into that problem, you just use—or <em>call</em>—the function that solves it. Functions dramatically increase the usability and readability of your code, <span epub:type="pagebreak" id="page_70"/>making it much easier to work with. In this chapter, you’ll learn to write functions, add and manage your functions’ parameters, and set up functions to accept pipeline input. But first, let’s look at a bit of terminology.</p>&#13;
<h3 class="h3" id="ch6lev1">Functions vs. Cmdlets</h3>&#13;
<p class="noindent">If the idea of a function sounds familiar, it is probably because it sounds a bit like the cmdlets you’ve been using throughout this book, such as <span class="literal">Start-Service</span> and <span class="literal">Write-Host</span>. These are also named pieces of code that solve a single problem. The difference between a function and a cmdlet is <em>how</em> each of these constructs is made. A cmdlet isn’t written with PowerShell. It’s written in another language, typically something like C#, and then it’s compiled and made available inside PowerShell. Functions, on the other hand, are written in PowerShell’s simple scripting language.</p>&#13;
<p class="indent">You can see which commands are cmdlets and which are functions by using the <span class="literal">Get-Command</span> cmdlet and its <span class="literal">CommandType</span> parameter, as in <a href="ch06.xhtml#ch6list1">Listing 6-1</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Command –CommandType Function</span></pre>&#13;
<p class="caption" id="ch6list1"><em>Listing 6-1: Displaying the available functions</em></p>&#13;
<p class="indent">This command will display all the functions currently loaded into your PowerShell session, or inside modules that are available to PowerShell (<a href="ch07.xhtml#ch7">Chapter 7</a> covers modules). To see other functions, you have to copy and paste them into the console, add them to an available module, or <em>dot source</em> them (which we’ll also cover later).</p>&#13;
<p class="indent">With that out of the way, let’s start writing functions.</p>&#13;
<h3 class="h3" id="ch6lev2">Defining a Function</h3>&#13;
<p class="noindent">Before you can use a function, you need to define it. To define a function, you use the <span class="literal">function</span> keyword, followed by a descriptive, user-defined name, followed by a set of curly brackets. Inside the curly brackets is a scriptblock that you want PowerShell to execute. <a href="ch06.xhtml#ch6list2">Listing 6-2</a> defines a basic function in the console and executes it.</p>&#13;
<pre>PS&gt; <span class="codestrong1">function Install-Software { Write-Host 'I installed some software, Yippee!' }</span>&#13;
PS&gt; <span class="codestrong1">Install-Software</span>&#13;
I installed some software, Yippee!</pre>&#13;
<p class="caption" id="ch6list2"><em>Listing 6-2: Writing a message to the console with a simple function</em></p>&#13;
<p class="indent">The function you’ve defined, <span class="literal">Install-Software</span>, uses <span class="literal">Write-Host</span> to display a message in the console. Once it’s defined, you can use this function’s name to execute the code inside its scriptblock.</p>&#13;
<p class="indent">A function’s name is important. You can name your functions whatever you want, but the name should always describe what the function does. Function-naming convention in PowerShell follows the Verb-Noun syntax, <span epub:type="pagebreak" id="page_71"/>and it’s considered best practice to always use this syntax unless absolutely necessary. You can use the <span class="literal">Get-Verb</span> command to see a list of recommended verbs. The noun is typically the singular name of whatever entity you’re working with—in this case, software.</p>&#13;
<p class="indent">If you want to change the behavior of a function, you can redefine it, as in <a href="ch06.xhtml#ch6list3">Listing 6-3</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">function Install-Software { Write-Host 'You installed some software, Yay!' }</span>&#13;
PS&gt; <span class="codestrong1">Install-Software</span>&#13;
You installed some software, Yay!</pre>&#13;
<p class="caption" id="ch6list3"><em>Listing 6-3: Redefining the <span class="codeitalic">Install-Software</span> function to change its behavior</em></p>&#13;
<p class="indent">Now that you’ve redefined <span class="literal">Install-Software</span>, it will display a slightly different message.</p>&#13;
<p class="indent">Functions can be defined in a script or typed directly into the console. In <a href="ch06.xhtml#ch6list2">Listing 6-2</a>, you had a small function, so defining it in the console wasn’t a problem. Most of the time, you’ll have bigger functions, and it’ll be easier to define those functions in a script or a module, and then call that script or module in order to load the function into memory. As you might imagine from <a href="ch06.xhtml#ch6list3">Listing 6-3</a>, retyping a hundred-line function every time you want to tweak its functionality could get a little frustrating.</p>&#13;
<p class="indent">For the rest of this chapter, you’ll expand our <span class="literal">Install-Software</span> function to accept parameters and accept pipeline input. I suggest you open your favorite editor and store the function in a <em>.ps1</em> file as you’re working through the chapter.</p>&#13;
<h3 class="h3" id="ch6lev3">Adding Parameters to Functions</h3>&#13;
<p class="noindent">PowerShell functions can have any number of parameters. When you create your own functions, you’ll have the option to include parameters and decide how those parameters work. The parameters can be mandatory or optional, and they can either accept anything or be forced to accept one of a limited list of possible arguments.</p>&#13;
<p class="indent">For example, the fictional software you’re installing via the <span class="literal">Install-Software</span> function might have many versions, but currently, the <span class="literal">Install-Software</span> function offers a user no way to specify which version they want to install. If you were the only one using the function, you could redefine the function each time you wanted a specific version—but that would be a waste of time and would be prone to potential errors, not to mention that you want others to be able to use your code.</p>&#13;
<p class="indent">Introducing parameters into your function allows it to have variability. Just as variables allowed you to write scripts that could handle many versions of the same situation, parameters allow you to write a single function that does one thing many ways. In this case, you want it to install multiple versions of the same piece of software, and do so on many computers.</p>&#13;
<p class="indent">Let’s first add a parameter to the function that enables you or a user to specify the version to install.</p>&#13;
<h4 class="h4" id="ch6lev3sec1"><span epub:type="pagebreak" id="page_72"/>Creating a Simple Parameter</h4>&#13;
<p class="noindent">Creating a parameter on a function requires a <span class="literal">param</span> block, which will hold all the parameters for the function. You can define a <span class="literal">param</span> block with the <span class="literal">param</span> keyword followed by parentheses, as in <a href="ch06.xhtml#ch6list4">Listing 6-4</a>.</p>&#13;
<pre>function Install-Software {&#13;
    [CmdletBinding()]&#13;
    param()&#13;
&#13;
    Write-Host 'I installed software version 2. Yippee!' &#13;
}</pre>&#13;
<p class="caption" id="ch6list4"><em>Listing 6-4: Defining a <span class="codeitalic">param</span> block</em></p>&#13;
<p class="indent">At this point, your function’s actual functionality hasn’t changed. You’ve just installed the plumbing, preparing the function for a parameter. You’ll use a <span class="literal">Write-Host</span> command to simulate the software installation so you can focus on writing the function.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In the demos this for book, you’ll build only</em> advanced <em>functions. There are also</em> basic <em>functions, but nowadays, they’re typically used in only small, niche situations. The differences are too nuanced to go into detail, but if you see a <span class="codeitalic">[CmdletBinding()]</span> reference under the function name, or a parameter defined as <span class="codeitalic">[Parameter()]</span>, you know you’re working with an advanced function.</em></p>&#13;
</div>&#13;
<p class="indent">Once you’ve added the <span class="literal">param</span> block, you can create the parameter by putting it within the <span class="literal">param</span> block’s parentheses, as in <a href="ch06.xhtml#ch6list5">Listing 6-5</a>.</p>&#13;
<pre>function Install-Software {&#13;
     [CmdletBinding()]&#13;
     param(	&#13;
    <span class="ent">❶</span> [Parameter()]&#13;
    <span class="ent">❷</span> [string] $Version&#13;
    )&#13;
&#13;
 <span class="ent">❸</span> Write-Host "I installed software version $Version. Yippee!" &#13;
}</pre>&#13;
<p class="caption" id="ch6list5"><em>Listing 6-5: Creating a parameter</em></p>&#13;
<p class="indent">Inside the <span class="literal">param</span> block, you first define the <span class="literal">Parameter</span> block <span class="ent">❶</span>. An empty <span class="literal">Parameter</span> block like the one here does nothing but is required (I’ll explain how to use it in the next section).</p>&#13;
<p class="indent">Let’s focus instead on the <span class="literal">[string]</span> type <span class="ent">❷</span> in front of the parameter name. By putting the parameter’s type between square brackets before the parameter variable name, you can cast the parameter so PowerShell will always try to convert any value that’s passed to this parameter into a string—if it isn’t one already. Here, anything passed in as <span class="literal">$Version</span> will <span epub:type="pagebreak" id="page_73"/>always be treated as a string. Casting your parameter to a type isn’t mandatory, but I highly encourage it, because explicitly defining the type will significantly reduce errors down the road.</p>&#13;
<p class="indent">You also add <span class="literal">$Version</span> into your print statement <span class="ent">❸</span>, which means that when you run the <span class="literal">Install-Software</span> command with the <span class="literal">Version</span> parameter and pass it a version number, you should get a statement saying so, as in <a href="ch06.xhtml#ch6list6">Listing 6-6</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Install-Software -Version 2</span>&#13;
I installed software version 2. Yippee!</pre>&#13;
<p class="caption" id="ch6list6"><em>Listing 6-6: Passing a parameter to your function</em></p>&#13;
<p class="indent">You’ve now defined a working parameter to your function. Let’s see what you can do with that parameter.</p>&#13;
<h4 class="h4" id="ch6lev3sec2">The Mandatory Parameter Attribute</h4>&#13;
<p class="noindent">You can use the <span class="literal">Parameter</span> block to control various <em>parameter attributes</em>, which will allow you to change the behavior of the parameter. For example, if you want to make sure anyone calling the function has to pass in a given parameter, you could define that parameter as <span class="literal">Mandatory</span>.</p>&#13;
<p class="indent">By default, parameters are optional. Let’s force the user to pass in a version by using the <span class="literal">Mandatory</span> keyword inside the <span class="literal">Parameter</span> block, as in <a href="ch06.xhtml#ch6list7">Listing 6-7</a>.</p>&#13;
<pre>function Install-Software {&#13;
    [CmdletBinding()]&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Version&#13;
    )&#13;
&#13;
    Write-Host "I installed software version $Version. Yippee!"&#13;
}&#13;
Install-Software</pre>&#13;
<p class="caption" id="ch6list7"><em>Listing 6-7: Using a mandatory parameter</em></p>&#13;
<p class="indent">If you run this, you should get the following prompt:</p>&#13;
<pre>cmdlet Install-Software at command pipeline position 1&#13;
Supply values for the following parameters:&#13;
Version:</pre>&#13;
<p class="indent">Once you’ve set the <span class="literal">Mandatory</span> attribute, executing the function without the parameter will halt execution until the user inputs a value. The function will wait until the user specifies a value for the <span class="literal">Version</span> parameter, and once they enter it, PowerShell will execute the function and move on. To avoid this prompt, simply pass the value as a parameter when you call the function with the <span class="codeitalic">-ParameterName</span> syntax—for example, <span class="literal">Install-Software -Version 2</span>.</p>&#13;
<h4 class="h4" id="ch6lev3sec3"><span epub:type="pagebreak" id="page_74"/>Default Parameter Values</h4>&#13;
<p class="noindent">You can also assign a parameter a default value when the parameter is defined. This is useful when you expect a certain value for a parameter most of the time. For example, if you want to install version 2 of this software 90 percent of the time, and you’d rather not have to set the value every time you run this function, you could assign a default value of <span class="literal">2</span> to the <span class="literal">$Version</span> parameter, as in <a href="ch06.xhtml#ch6list8">Listing 6-8</a>.</p>&#13;
<pre>function Install-Software {&#13;
    [CmdletBinding()]&#13;
    param(&#13;
        [Parameter()]&#13;
        [string]$Version = 2&#13;
    )&#13;
&#13;
    Write-Host "I installed software version $Version. Yippee!"&#13;
}&#13;
Install-Software</pre>&#13;
<p class="caption" id="ch6list8"><em>Listing 6-8: Using a default parameter value</em></p>&#13;
<p class="indent">Having a default parameter doesn’t prevent you from passing one in. Your passed-in value will override the default value.</p>&#13;
<h4 class="h4" id="ch6lev3sec4">Adding Parameter Validation Attributes</h4>&#13;
<p class="noindent">In addition to making parameters mandatory and giving them default values, you can restrict them to certain values by using <em>parameter validation attributes</em>. When possible, limiting the information that users (or even you!) can pass to your functions or scripts will eliminate unnecessary code inside your function. For example, say you pass the value 3 to your <span class="literal">Install-Software</span> function, knowing that version 3 is an existing version. Your function assumes that every user knows which versions exist, so it doesn’t account for what happens when you try to specify version 4. In that case, the function will fail to find the version’s folder because it doesn’t exist.</p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6list9">Listing 6-9</a>, you use the <span class="literal">$Version</span> string in a file path. If someone passes a value that doesn’t complete an existing folder name (for example, SoftwareV3 or SoftwareV4), the code will fail.</p>&#13;
<pre>function Install-Software {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Version&#13;
    )&#13;
    Get-ChildItem -Path \\SRV1\Installers\SoftwareV$Version&#13;
}&#13;
&#13;
Install-Software -Version 3</pre>&#13;
<p class="caption" id="ch6list9"><em>Listing 6-9: Assuming parameter values</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>This gives the following error:</p>&#13;
<pre>Get-ChildItem : Cannot find path '\\SRV1\Installers\SoftwareV3' because it does not exist.&#13;
At line:7 char:5&#13;
+     Get-ChildItem -Path \\SRV1\Installers\SoftwareV3&#13;
+     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : ObjectNotFound: (\\SRV1\Installers\SoftwareV3:String)&#13;
                              [Get-ChildItem], ItemNotFoundException&#13;
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand</pre>&#13;
<p class="indent">You could write error-handling code to account for this problem, or you could nip the problem in the bud by requiring the user pass only an existing version of the software. To limit the user’s input, you’ll add parameter validation.</p>&#13;
<p class="indent">Various kinds of parameter validation exist, but with respect to your <span class="literal">Install-Software</span> function, the <span class="literal">ValidateSet</span> attribute works best. The <span class="literal">ValidateSet</span> attribute enables you to specify a list of values allowed for the parameter. If you’re accounting for only the string 1 or 2, you’d ensure that the user can specify only these values; otherwise, the function will fail immediately and notify the user why.</p>&#13;
<p class="indent">Let’s add parameter validation attributes inside the <span class="literal">param</span> block, right under the original <span class="literal">Parameter</span> block, as in <a href="ch06.xhtml#ch6list10">Listing 6-10</a>.</p>&#13;
<pre>function Install-Software {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [ValidateSet('1','2')]&#13;
        [string]$Version&#13;
    )&#13;
    Get-ChildItem -Path \\SRV1\Installers\SoftwareV$Version&#13;
}&#13;
&#13;
Install-Software -Version 3</pre>&#13;
<p class="caption" id="ch6list10"><em>Listing 6-10: Using the <span class="codeitalic">ValidateSet</span> parameter validation attribute</em></p>&#13;
<p class="indent">You add the set of items 1 and 2 inside the <span class="literal">ValidateSet</span> attribute’s trailing parentheses, which tells PowerShell that the only values valid for <span class="literal">Version</span> are 1 or 2. If a user tries to pass something besides what’s in the set, they will receive an error message (see <a href="ch06.xhtml#ch6list11">Listing 6-11</a>) notifying them that they have only a specific number of options available.</p>&#13;
<pre>Install-Software : Cannot validate argument on parameter 'Version'. The argument "3" does not&#13;
belong to the set "1,2" specified by the ValidateSet attribute.&#13;
Supply an argument that is in the set and then try the command again.&#13;
At line:1 char:25&#13;
+ Install-Software -Version 3&#13;
+                         ~~~~&#13;
+ CategoryInfo          : InvalidData: (:) [Install-Software],ParameterBindingValidationException&#13;
    + FullyQualifiedErrorId : ParameterArgumentValidationError,Install-Software</pre>&#13;
<p class="caption" id="ch6list11"><em>Listing 6-11: Passing a parameter value that’s not in the <span class="codeitalic">ValidateSet</span> block</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <span class="literal">ValidateSet</span> attribute is a common validation attribute, but others are available. For a complete breakdown of all the ways parameter values can be restricted, check out the <span class="literal">Functions_Advanced_Parameters</span> help topic by running <span class="literal">Get-Help about_Functions_Advanced_Parameters</span>.</p>&#13;
<h3 class="h3" id="ch6lev4">Accepting Pipeline Input</h3>&#13;
<p class="noindent">So far, you’ve created a function with a parameter that can be passed only by using the typical <span class="codeitalic">-ParameterName &lt;Value&gt;</span> syntax. But in <a href="ch03.xhtml#ch3">Chapter 3</a>, you learned that PowerShell has a pipeline that allows you to seamlessly pass objects from one command to another. Recall that some functions didn’t have pipeline capability—when working with your own functions, that’s something you control. Let’s add pipeline capabilities to our <span class="literal">Install-Software</span> function.</p>&#13;
<h4 class="h4" id="ch6lev4sec5">Adding Another Parameter</h4>&#13;
<p class="noindent">First, you’ll add another parameter to your code that specifies the computer on which you want to install the software. You’ll also add that parameter to your <span class="literal">Write-Host</span> command to simulate the installation. <a href="ch06.xhtml#ch6list12">Listing 6-12</a> adds the new parameter:</p>&#13;
<pre>function Install-Software {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [ValidateSet('1','2')],&#13;
        [string]$Version&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$ComputerName&#13;
    )&#13;
    Write-Host "I installed software version $Version on $ComputerName. Yippee!"&#13;
&#13;
}&#13;
&#13;
Install-Software -Version 2 -ComputerName "SRV1"</pre>&#13;
<p class="caption" id="ch6list12"><em>Listing 6-12: Adding the <span class="codeitalic">ComputerName</span> parameter</em></p>&#13;
<p class="indent">Just as with <span class="literal">$Version</span>, you’ve added the <span class="literal">ComputerName</span> parameter to the <span class="literal">param</span> block.</p>&#13;
<p class="indent">Once you’ve added the <span class="literal">ComputerName</span> parameter to the function, you could iterate over a list of computer names and pass the values for the computer name and the version to the <span class="literal">Install-Software</span> function, like so:</p>&#13;
<pre>$computers = @("SRV1", "SRV2", "SRV3")&#13;
foreach ($pc in $computers) {&#13;
    Install-Software -Version 2 -ComputerName $pc&#13;
}</pre>&#13;
<p class="indent">But as you’ve seen a few times already, you should forgo <span class="literal">foreach</span> loops like this and use the pipeline instead.</p>&#13;
<h4 class="h4" id="ch6lev4sec6"><span epub:type="pagebreak" id="page_77"/>Making the Function Pipeline Compatible</h4>&#13;
<p class="noindent">Unfortunately, if you try to use the pipeline straightaway, you’ll get errors. Before you add pipeline support to the function, you should decide which type of pipeline input you want the function to accept. As you learned in <a href="ch03.xhtml#ch3">Chapter 3</a>, a PowerShell function uses two kinds of pipeline input: <span class="literal">ByValue</span> (entire object) and <span class="literal">ByPropertyName</span> (a single object property). Here, because our <span class="literal">$computers</span> list contains only strings, you’ll pass those strings via <span class="literal">ByValue</span>.</p>&#13;
<p class="indent">To add pipeline support, you add a parameter attribute to the parameter you want by using one of two keywords: <span class="literal">ValueFromPipeline</span> or <span class="literal">ValueFromPipelineByPropertyName</span>, as in <a href="ch06.xhtml#ch6list13">Listing 6-13</a>.</p>&#13;
<pre>function Install-Software {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Version&#13;
        [ValidateSet('1','2')],&#13;
        [Parameter(Mandatory, ValueFromPipeline)]&#13;
        [string]$ComputerName&#13;
    )&#13;
    Write-Host "I installed software version $Version on $ComputerName. Yippee!"&#13;
}&#13;
&#13;
$computers = @("SRV1", "SRV2", "SRV3")&#13;
$computers | Install-Software -Version 2</pre>&#13;
<p class="caption" id="ch6list13"><em>Listing 6-13: Adding pipeline support</em></p>&#13;
<p class="indent">Run the script again, and you should get something like this:</p>&#13;
<pre>I installed software version 2 on SRV3. Yippee!</pre>&#13;
<p class="indent">Notice that <span class="literal">Install-Software</span> executes for only the last string in the array. You’ll see how to fix this in the next section.</p>&#13;
<h4 class="h4" id="ch6lev4sec7">Adding a process Block</h4>&#13;
<p class="noindent">To tell PowerShell to execute this function for every object coming in, you must include a <span class="literal">process</span> block. Inside the <span class="literal">process</span> block, you put the code you want to execute each time the function receives pipeline input. Add a <span class="literal">process</span> block to your script, as shown in <a href="ch06.xhtml#ch6list14">Listing 6-14</a>.</p>&#13;
<pre>function Install-Software {&#13;
    param(&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Version&#13;
        [ValidateSet('1','2')],&#13;
        [Parameter(Mandatory, ValueFromPipeline)]&#13;
        [string]$ComputerName&#13;
    )&#13;
<span epub:type="pagebreak" id="page_78"/>    process {&#13;
        Write-Host "I installed software version $Version on $ComputerName. Yippee!"&#13;
    }&#13;
}&#13;
&#13;
$computers = @("SRV1", "SRV2", "SRV3")&#13;
$computers | Install-Software -Version 2</pre>&#13;
<p class="caption" id="ch6list14"><em>Listing 6-14: Adding a <span class="codeitalic">process</span> block</em></p>&#13;
<p class="indent">Notice that the <span class="literal">process</span> keyword is followed by a set of curly brackets, which contain the code your function executes.</p>&#13;
<p class="indent">With the <span class="literal">process</span> block, you should see output for all three servers in <span class="literal">$computers</span>:</p>&#13;
<pre>I installed software version 2 on SRV1. Yippee!&#13;
I installed software version 2 on SRV2. Yippee!&#13;
I installed software version 2 on SRV3. Yippee!</pre>&#13;
<p class="indent">The <span class="literal">process</span> block should contain the main code you want to execute. You can also use <span class="literal">begin</span> and <span class="literal">end</span> blocks for code that will execute at the beginning and end of the function call. For more information about building advanced functions including the <span class="literal">begin</span>, <span class="literal">process</span>, and <span class="literal">end</span> blocks, check out the <span class="literal">about</span><span class="literal">_Functions_Advanced</span> help topic by running <span class="literal">Get-Help about_Functions_Advanced</span>.</p>&#13;
<h3 class="h3" id="ch6lev5">Summary</h3>&#13;
<p class="noindent">Functions allow you to compartmentalize code into discrete building blocks. They not only help you break your work into smaller, more manageable chunks, but also force you to write readable and testable code. When you use descriptive names for your functions, your code becomes self-documenting, and anyone reading it can intuitively understand what it’s doing.</p>&#13;
<p class="indent">In this chapter, you learned the basics of functions: how to define them, how to specify parameters and their attributes, and how to accept pipeline input. In the next chapter, you’ll see how to bundle many functions together by using modules.</p>&#13;
</body></html>