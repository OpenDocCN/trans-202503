["```\npackage ch11\n\nimport (\n    \"crypto/tls\"\n    \"net\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"strings\"\n    \"testing\"\n    \"time\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc TestClientTLS(t *testing.T) {\n    ts := 1httptest.NewTLSServer(\n        http.HandlerFunc(\n            func(w http.ResponseWriter, r *http.Request) {\n                if 2r.TLS == nil {\n                    u := \"https://\" + r.Host + r.RequestURI\n                    http.Redirect(w, r, u, http.StatusMovedPermanently)\n                    return\n                }\n\n                w.WriteHeader(http.StatusOK)\n            },\n        ),\n    )\n    defer ts.Close()\n\n    resp, err := 3ts.Client().Get(ts.URL)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n if resp.StatusCode != http.StatusOK {\n        t.Errorf(\"expected status %d; actual status %d\",\n            http.StatusOK, resp.StatusCode)\n    }\n```", "```\n`--snip--`\n\n    tp := &http.Transport{\n        TLSClientConfig: &tls.Config{\n            CurvePreferences: []tls.CurveID{1tls.CurveP256},\n            MinVersion:       tls.VersionTLS12,\n        },\n    }\n\n    err = 2http2.ConfigureTransport(tp)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    client2 := &http.Client{Transport: tp}\n\n    _, err = client2.Get(ts.URL)\n    if err == nil || !strings.Contains(err.Error(),\n        \"certificate signed by unknown authority\") {\n        t.Fatalf(\"expected unknown authority error; actual: %q\", err)\n    }\n\n 3 tp.TLSClientConfig.InsecureSkipVerify = true\n\n    resp, err = client2.Get(ts.URL)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n if resp.StatusCode != http.StatusOK {\n        t.Errorf(\"expected status %d; actual status %d\",\n            http.StatusOK, resp.StatusCode)\n    }\n}\n```", "```\n`--snip--`\n\nfunc TestClientTLSGoogle(t *testing.T) {\n    conn, err := 1tls.DialWithDialer(\n        &net.Dialer{Timeout: 30 * time.Second},\n        \"tcp\",\n        \"www.google.com:443\",\n        &tls.Config{\n            CurvePreferences: []tls.CurveID{tls.CurveP256},\n            MinVersion:       tls.VersionTLS12,\n        },\n    )\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    state := 2conn.ConnectionState()\n    t.Logf(\"TLS 1.%d\", state.Version-tls.VersionTLS10)\n    t.Log(tls.CipherSuiteName(state.CipherSuite))\n    t.Log(state.VerifiedChains[0][0].Issuer.Organization[0])\n\n    _ = conn.Close()\n}\n```", "```\n$ **go test -race -run TestClientTLSGoogle -v ./...**\n=== RUN   TestClientTLSGoogle\n    TestClientTLSGoogle: tls_client_test.go:89: TLS 1.3\n    TestClientTLSGoogle: tls_client_test.go:90: TLS_AES_128_GCM_SHA256\n    TestClientTLSGoogle: tls_client_test.go:91: Google Trust Services\n--- PASS: TestClientTLSGoogle (0.31s)\nPASS\n```", "```\n$ **go run $GOROOT/src/crypto/tls/generate_cert.go -host localhost -ecdsa-curve P256**\n```", "```\npackage ch11\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net\"\n    \"time\"\n)\n\nfunc NewTLSServer(ctx context.Context, address string,\n    maxIdle time.Duration, tlsConfig *tls.Config) *Server {\n    return &Server{\n        ctx:       ctx,\n        ready:     make(chan struct{}),\n        addr:      address,\n        maxIdle:   maxIdle,\n        tlsConfig: tlsConfig,\n    }\n}\n\ntype Server struct {\n    ctx   context.Context\n    ready chan struct{}\n\n    addr      string\n    maxIdle   time.Duration\n    tlsConfig *tls.Config\n}\n\nfunc (s *Server) 1Ready() {\n    if s.ready != nil {\n        <-s.ready\n    }\n}\n```", "```\n`--snip--`\n\nfunc (s *Server) ListenAndServeTLS(certFn, keyFn string) error {\n    if s.addr == \"\" {\n        s.addr = \"localhost:443\"\n    }\n\n    l, err := net.Listen(\"tcp\", s.addr)\n    if err != nil {\n        return fmt.Errorf(\"binding to tcp %s: %w\", s.addr, err)\n    }\n\n    if s.ctx != nil {\n        go func() {\n            <-s.ctx.Done()\n            _ = l.Close()\n        }()\n    }\n\n    return s.ServeTLS(l, certFn, keyFn)\n}\n```", "```\n`--snip--`\n\nfunc (s Server) ServeTLS(l net.Listener, certFn, keyFn string) error {\n    if s.tlsConfig == nil {\n        s.tlsConfig = &tls.Config{\n CurvePreferences:         []tls.CurveID{tls.CurveP256},\n            MinVersion:               tls.VersionTLS12,\n         1 PreferServerCipherSuites: true,\n        }\n    }\n\n    if len(s.tlsConfig.Certificates) == 0 &&\n        s.tlsConfig.GetCertificate == nil {\n        cert, err := 2tls.LoadX509KeyPair(certFn, keyFn)\n        if err != nil {\n            return fmt.Errorf(\"loading key pair: %v\", err)\n        }\n\n        s.tlsConfig.Certificates = []tls.Certificate{cert}\n    }\n\n    tlsListener := 3tls.NewListener(l, s.tlsConfig)\n    if s.ready != nil {\n        close(s.ready)\n    }\n```", "```\n`--snip--`\n\n    for {\n        conn, err := 1tlsListener.Accept()\n        if err != nil {\n            return fmt.Errorf(\"accept: %v\", err)\n        }\n\n        go func() {\n            defer func() { _ = 2conn.Close() }()\n\n            for {\n                if s.maxIdle > 0 {\n err := 3conn.SetDeadline(time.Now().Add(s.maxIdle))\n                    if err != nil {\n                        return\n                    }\n                }\n\n                buf := make([]byte, 1024)\n                n, err := 4conn.Read(buf)\n                if err != nil {\n                    return\n                }\n\n                _, err = conn.Write(buf[:n])\n                if err != nil {\n                    return\n                }\n            }\n        }()\n    }\n}\n```", "```\npackage ch11\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"crypto/tls\"\n    \"crypto/x509\"\n    \"io\"\n    \"io/ioutil\"\n    \"strings\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestEchoServerTLS(t *testing.T) {\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    serverAddress := \"localhost:34443\"\n    maxIdle := time.Second\n    server := NewTLSServer(ctx, serverAddress, maxIdle, nil)\n    done := make(chan struct{})\n\n    go func() {\n        err := 1server.ListenAndServeTLS(\"cert.pem\", \"key.pem\")\n        if err != nil && !strings.Contains(err.Error(),\n            \"use of closed network connection\") {\n            t.Error(err)\n            return\n        }\n        done <- struct{}{}\n    }()\n2     server.Ready()\n```", "```\n`--snip--`\n\n    cert, err := ioutil.ReadFile(\"cert.pem\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    certPool := 1x509.NewCertPool()\n    if ok := certPool.AppendCertsFromPEM(cert); !ok {\n        t.Fatal(\"failed to append certificate to pool\")\n    }\n\n    tlsConfig := &tls.Config{\n        CurvePreferences: []tls.CurveID{tls.CurveP256},\n        MinVersion:       tls.VersionTLS12,\n     2 RootCAs:          certPool,\n    }\n```", "```\n`--snip--`\n\n    conn, err := 1tls.Dial(\"tcp\", serverAddress, tlsConfig)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    hello := []byte(\"hello\")\n    _, err = conn.Write(hello)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    b := make([]byte, 1024)\n    n, err := conn.Read(b)\n    if err != nil {\n t.Fatal(err)\n    }\n\n    if actual := b[:n]; !bytes.Equal(hello, actual) {\n        t.Fatalf(\"expected %q; actual %q\", hello, actual)\n    }\n\n 2 time.Sleep(2 * maxIdle)\n    _, err = conn.Read(b)\n    if err != 3io.EOF {\n        t.Fatal(err)\n    }\n\n    err = conn.Close()\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    cancel()\n    <-done\n}\n```", "```\npackage main\n\nimport (\n    \"crypto/ecdsa\"\n    \"crypto/elliptic\"\n    \"crypto/rand\"\n    \"crypto/x509\"\n    \"crypto/x509/pkix\"\n    \"encoding/pem\"\n    \"flag\"\n    \"log\"\n    \"math/big\"\n    \"net\"\n    \"os\"\n    \"strings\"\n    \"time\"\n)\n\nvar (\n    host = flag.String(\"host\", \"localhost\",\n        \"Certificate's comma-separated host names and IPs\")\n    certFn = flag.String(\"cert\", \"cert.pem\", \"certificate file name\")\n    keyFn  = flag.String(\"key\", \"key.pem\", \"private key file name\")\n)\n\nfunc main() {\n    flag.Parse()\n\n    serial, err := 1rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), \n        128))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    notBefore := time.Now()\n    template := x509.Certificate{\n        SerialNumber: serial,\n Subject: pkix.Name{\n            Organization: []string{\"Adam Woodbeck\"},\n        },\n        NotBefore: notBefore,\n        NotAfter:  notBefore.Add(10 * 356 * 24 * time.Hour),\n        KeyUsage: x509.KeyUsageKeyEncipherment |\n            x509.KeyUsageDigitalSignature |\n            x509.KeyUsageCertSign,\n        ExtKeyUsage: []x509.ExtKeyUsage{\n            x509.ExtKeyUsageServerAuth,\n          2x509.ExtKeyUsageClientAuth,\n        },\n        BasicConstraintsValid: true,\n        IsCA:                  true,\n    }\n```", "```\n`--snip--`\n\n    for _, h := range 1strings.Split(*host, \",\") {\n        if ip := net.ParseIP(h); ip != nil {\n         2 template.IPAddresses = append(template.IPAddresses, ip)\n        } else {\n         3 template.DNSNames = append(template.DNSNames, h)\n        }\n    }\n\n    priv, err := 4ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n der, err := 5x509.CreateCertificate(rand.Reader, &template,\n        &template, &priv.PublicKey, priv)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    cert, err := os.Create(*certFn)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    err = 6pem.Encode(cert, &pem.Block{Type: \"CERTIFICATE\", Bytes: der})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := cert.Close(); err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"wrote\", *certFn)\n```", "```\n`--snip--`\n\n    key, err := os.OpenFile(*keyFn, os.O_WRONLY|os.O_CREATE|os.O_TRUNC,\n      10600)\n    if err != nil {\n        log.Fatal(err)\n }\n\n    privKey, err := 2x509.MarshalPKCS8PrivateKey(priv)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    err = 3pem.Encode(key, &pem.Block{Type: \"EC PRIVATE KEY\",\n    Bytes: privKey})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := key.Close(); err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"wrote\", *keyFn)\n}\n```", "```\n$ **go run cert/generate.go -cert serverCert.pem -key serverKey.pem -host localhost**\n2006/01/02 15:04:05 wrote serverCert.pem\n2006/01/02 15:04:05 wrote serverKey.pem\n$ **go run cert/generate.go -cert clientCert.pem -key clientKey.pem -host localhost**\n2006/01/02 15:04:05 wrote clientCert.pem\n2006/01/02 15:04:05 wrote clientKey.pem\n```", "```\npackage ch11\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"crypto/tls\"\n    \"crypto/x509\"\n    \"errors\"\n    \"io/ioutil\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc caCertPool(caCertFn string) (*x509.CertPool, error) {\n    caCert, err := 1ioutil.ReadFile(caCertFn)\n    if err != nil {\n        return nil, err\n    }\n\n    certPool := x509.NewCertPool()\n    if ok := 2certPool.AppendCertsFromPEM(caCert); !ok {\n        return nil, errors.New(\"failed to add certificate to pool\")\n    }\n\n    return certPool, nil\n}\n```", "```\n`--snip--`\n\nfunc TestMutualTLSAuthentication(t *testing.T) {\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    serverPool, err := caCertPool(1\"clientCert.pem\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    cert, err := 2tls.LoadX509KeyPair(\"serverCert.pem\", \"serverKey.pem\")\n    if err != nil {\n        t.Fatalf(\"loading key pair: %v\", err)\n    }\n```", "```\n`--snip--`\n\n    serverConfig := &tls.Config{\n        Certificates: []tls.Certificate{cert},\n     1 GetConfigForClient: func(hello *tls.ClientHelloInfo) (*tls.Config,\n            error) {\n            return &tls.Config{\n                Certificates:             []tls.Certificate{2cert},\n             3 ClientAuth:               tls.RequireAndVerifyClientCert,\n             4 ClientCAs:                serverPool,\n                CurvePreferences:         []tls.CurveID{tls.CurveP256},\n                MinVersion:             5tls.VersionTLS13,\n                PreferServerCipherSuites: true,\n```", "```\n`--snip--`\n\n             1 VerifyPeerCertificate: func(rawCerts [][]byte,\n                    verifiedChains [][]*x509.Certificate) error {\n\n                    opts := x509.VerifyOptions{\n                        KeyUsages: []x509.ExtKeyUsage{\n                          2x509.ExtKeyUsageClientAuth,\n                        },\n                        Roots: 3serverPool,\n                    }\n\n                    ip := strings.Split(hello.Conn.RemoteAddr().String(),\n                        \":\")[0]\n                    hostnames, err := 4net.LookupAddr(ip)\n                    if err != nil {\n                        t.Errorf(\"PTR lookup: %v\", err)\n                    }\n                    hostnames = append(hostnames, ip)\n\n                    for _, chain := range verifiedChains {\n                        opts.Intermediates = x509.NewCertPool()\n                        for _, cert := range 5chain[1:] {\n                            opts.Intermediates.AddCert(cert)\n                        }\n\n                        for _, hostname := range hostnames {\n                            opts.DNSName = 6hostname\n                            _, err = chain[0].Verify(opts)\n                            if err == nil {\n                                return nil\n                            }\n                        }\n                    }\n\n                    return errors.New(\"client authentication failed\")\n                },\n            }, nil\n        },\n    }\n```", "```\n`--snip--`\n\n    serverAddress := \"localhost:44443\"\n    server := NewTLSServer(ctx, serverAddress, 0, 1serverConfig)\n    done := make(chan struct{})\n\n    go func() {\n        err := server.ListenAndServeTLS(\"serverCert.pem\", \"serverKey.pem\")\n        if err != nil &&!strings.Contains(err.Error(),\n            \"use of closed network connection\") {\n            t.Error(err)\n            return\n        }\n done <- struct{}{}\n    }()\n 2 server.Ready()\n```", "```\n`--snip--`\n\n    clientPool, err := caCertPool(1\"serverCert.pem\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    clientCert, err := tls.LoadX509KeyPair(\"clientCert.pem\", \"clientKey.pem\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    conn, err := tls.Dial(\"tcp\", serverAddress, &tls.Config{\n     2 Certificates:     []tls.Certificate{clientCert},\n        CurvePreferences: []tls.CurveID{tls.CurveP256},\n        MinVersion:       tls.VersionTLS13,\n     3 RootCAs:          clientPool,\n    })\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    hello := []byte(\"hello\")\n    _, err = conn.Write(hello)\n if err != nil {\n        t.Fatal(err)\n    }\n\n    b := make([]byte, 1024)\n    n, err := 1conn.Read(b)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    if actual := b[:n]; !bytes.Equal(hello, actual) {\n        t.Fatalf(\"expected %q; actual %q\", hello, actual)\n    }\n\n    err = conn.Close()\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    cancel()\n    <-done\n}\n```"]