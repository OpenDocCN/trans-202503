- en: '**18**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BLEND MODES, FILTER EFFECTS, AND MASKING**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The majority of today’s browsers—desktop and mobile—support the *Scalable Vector
    Graphics (SVG)* format. SVG differs from image formats such as GIF, JPEG, and
    PNG (known as bitmap images), as SVG is made up of a markup language
  prefs: []
  type: TYPE_NORMAL
- en: (similar to HTML) that describes points, or vectors, rather than the grids of
    pixels that make up bitmap images. One advantage that SVG has over bitmap images
    is that, as a vector format, it scales well to fit screens of any resolution.
    In addition to this, the SVG format offers a built-in array of rich graphical
    effects previously available only in image-editing software such as Photoshop,
    GIMP, and Sketch.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, however, using those graphical effects in browsers wasn’t practical;
    live image effects are computationally intensive, and using them on the Web would
    have negatively affected performance. Today, however, browsers have become much
    faster and more capable, with almost all rendering graphics directly on the device’s
    GPU. This advance allows for the hardware-accelerated display of transformations
    and animations and unlocks the potential to use the rich graphical effects of
    SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'As browsers implemented SVG graphics effects, it became somewhat of a no-brainer
    to also give other web technologies access to them. So, in this chapter, you’ll
    learn about three features that make SVG’s graphical potential available to CSS:
    *blend modes*, *filter effects*, and *masking*. These nondestructive effects only
    alter the way images are displayed on the page; they don’t modify the source images.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Many SVG effects involve variations of color, which are very difficult to
    portray in black and white. I strongly encourage you to see examples of the effects
    yourself at* [http://thebookofcss3.com/](http://thebookofcss3.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blend Modes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve used professional-grade image-editing software like Photoshop or GIMP,
    you may already be familiar with blend modes. Blend modes are a way to mix an
    image into a solid color or another image so the two appear merged or blended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various blend modes are available, each of which blends images in different
    ways, according to various algorithms. The available modes in CSS are defined
    in the Compositing and Blending Module (*[http://www.w3.org/TR/compositing-1/](http://www.w3.org/TR/compositing-1/)*).
    I can’t cover all of the modes in detail due to a lack of space, so I’ll concentrate
    on three:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen** In this mode, whites remain white, whereas black lets the background
    color show through. As a result of applying this mode, images tend to become lighter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiply** This mode tends to produce darker images. Blacks remain black,
    whereas whites let the background color pass through.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlay** The Overlay mode strikes a balance between the Screen and Multiply
    modes. Highlights and shadows are preserved, increasing contrast.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining blend modes are generally variations on these three. You can read
    a full explanation of each in the spec or see a good visual introduction on *[http://dev.opera.com/articles/getting-to-know-css-blend-modes/](http://dev.opera.com/articles/getting-to-know-css-blend-modes/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***background-blend-mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `background-blend-mode` property is used to blend the background layers
    of an element; for example, you might use it to blend the background color with
    the background image. This property works solely in the context of the element:
    Only the background layers are blended; the element itself doesn’t blend with
    any part of the page below it. The property requires as a value the keyword of
    the blend mode you want to use, such as `screen`, `multiply`, or `overlay`. For
    example, here’s how to apply the Multiply blend mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The default value of `background-blend-mode` is `normal`, which leaves the background
    layer unblended.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending an Image and a Color**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The simplest way to show how background blend modes work is to blend a background
    image with a background color. The following listing has an element with a background
    image and color applied and is set to use the Screen blend mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 18-1](ch18.html#ch18fig1) shows the result of this and other blend
    modes. Image (A) at top left has no blend mode applied and is provided as a reference.
    The other images each have a different blend mode keyword applied, namely `screen`
    (B), `multiply` (C), and `overlay` (D). (Note that in this case the Overlay mode
    just puts a solid color over the image, which is far from ideal; Overlay blend
    modes are much more useful when blending two images.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: Comparing different blend modes applied to a source image*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending Two Images**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In addition to blending a background image layer with a color layer, you can
    also blend a background image layer with other background image layers. To do
    so, apply multiple background images (as discussed in [Chapter 8](ch08.html#ch08))
    and then set the blend mode as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 18-2](ch18.html#ch18fig2) shows examples of blending two images. Each
    image has different blend mode keywords applied. From left to right, these are
    `screen`, `multiply`, and `overlay`. (If you’re looking at the example files using
    a desktop browser, hover your mouse over the elements to show the two different
    background images that I’ve used.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Blending multiple background image layers*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’ve set a transparent background color on the element. If I hadn’t,
    the `multiply` keyword would have made the lower background image layer blend
    with the background color and then blend with the other image layer, creating
    a different effect than what I intended.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Blend Modes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since you can add multiple background images to an element, it follows that
    you can apply a blend mode to each layer. To do so, you need only list the required
    blend modes in a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the element has three background layers: two images
    and a color. I’ve applied two blend mode keywords: Multiply mode will be used
    to blend the background color with *foo.png*; the result will be blended with
    *bar.png* using the Screen blend mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As with the other multiple background properties, having fewer values on the*
    `*background-blend-mode*` *property than there are background layers will make
    the value list loop.*'
  prefs: []
  type: TYPE_NORMAL
- en: Varying the blend modes can produce dramatically different results. For example,
    [Figure 18-3](ch18.html#ch18fig3) shows a number of combinations applied to different
    elements with identical background layers. The element on the left uses the Screen
    mode on the top image layer and Multiply mode on the lower; the element in the
    middle uses Multiply mode on the upper image layer and Overlay on the lower; and
    on the right, Overlay mode is applied on the upper and Screen on the lower. As
    you can see, the results are quite different.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Applying multiple blend modes in different combinations*'
  prefs: []
  type: TYPE_NORMAL
- en: '***mix-blend-mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although blending background layers is undoubtedly useful, the real power lies
    in blending one element with another. In CSS3, you do this with the `mix-blend-mode`
    property. When applied to an element, this property blends the content of the
    element with the content and background of any elements that are directly behind
    it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this differs from `background-blend-mode`, let’s see a quick
    example. In the following listing, I apply a background image to element `*E*`
    and the Multiply blend mode to element `*F*`, nested inside `*E*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 18-4](ch18.html#ch18fig4) shows the result, along with other blend
    modes for comparison. The element at top left (A) has no blend mode applied and
    is used as a reference; the remaining three each have blend mode keywords applied:
    `screen` (B), `multiply` (C), and `overlay` (D).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Different blend modes applied to the text element, mixed with
    the background of its parent*'
  prefs: []
  type: TYPE_NORMAL
- en: '***isolation***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When using `mix-blend-mode`, be aware that it will blend with *every* visual
    element drawn behind it on the screen, which can cause unintended consequences.
    For example, say you have the following markup structure, in which an `img` element
    is nested inside a `div`, inside the `body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you set a background image on the `body` and the `mix-blend-mode` property
    on the `img`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `img` will blend with the body because the `div` is transparent,
    as shown in the example on the left of [Figure 18-5](ch18.html#ch18fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Isolating an element to set a new stacking context*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the result isn’t exactly what you want, you can make an element create a
    new stacking context,^([1](footnote.html#footnote2)) similar to the way setting
    `position: relative` on an element resets the coordinates for absolute positioning.
    When blending, this process is called *isolating* the element, and you use the
    `isolation` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value is `auto`, but to create the new stacking context, you must
    use the alternate value, `isolate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see the difference in the example on the right of [Figure 18-5](ch18.html#ch18fig5).
    The `div` is isolated and a new stacking context created, so the `img` is blended
    only with the transparent parent. As a result, you don’t see the background image
    of the `body` as in the example on the left.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter Effects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like blend modes, filters are a common part of professional image-editing software.
    Filters are used to change an element’s appearance before it reaches the page,
    and unlike blend modes, they don’t rely on the interaction of two components.
    CSS filters are defined in the CSS Filter Effects Module (*[http://www.w3.org/TR/filter-effects-1/](http://www.w3.org/TR/filter-effects-1/)*)
    and are applied using the `filter` property, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `*function*` value is at least one of a range of nine filter effect functions.
    Each accepts a single argument, except when a series of arguments is required
    (in a space-separated list). I discuss each one here.
  prefs: []
  type: TYPE_NORMAL
- en: '***blur()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Applies a blur effect to an element. The argument for the `blur()` function
    is a unit of length that controls the radius of the blur. The effect is called
    *Gaussian blur*—a kind of image smoothing that reduces noise in the image. The
    higher the radius value, the greater the blur effect. For example, to create a
    blur of radius 10px, you use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see the blur effect in action in [Figure 18-6](ch18.html#ch18fig6).
    The unfiltered image is on the left; the `blur()` filter has been applied to the
    image on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-6: Applying a Gaussian blur filter*'
  prefs: []
  type: TYPE_NORMAL
- en: '***brightness() and contrast()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `brightness()` function changes the brightness of an element, whereas the
    `contrast()` function increases or decreases the contrast between the dark and
    light of an element. Both functions take a percentage as an argument. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, an argument of `100%` leaves the element unchanged. An argument
    of `0%` for `brightness()` makes the element fully black, and `0%` for `contrast()`
    makes the element fully gray. You can use values in excess of `100%` to increase
    the brightness and contrast as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also use a number for this function, with* `*1*` *being equivalent
    to* `*100%*`, `*1.5*` *to* `*150%*`*, and so on. The same applies to all other
    functions that accept percentage values.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-7](ch18.html#ch18fig7) shows examples of both functions. The first
    image has no filter applied and is shown as a reference. The middle image has
    the `brightness()` function applied, and the image on the right has `contrast()`—each
    function has an argument of `50%`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-7: Adjusting brightness and contrast with CSS filter effects*'
  prefs: []
  type: TYPE_NORMAL
- en: '***grayscale(), sepia(), and saturate()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next three functions all deal with color. The `grayscale()` function gives
    you a way to replace colors with shades of gray so you can convert images to black
    and white. The `sepia()` toning function is similar to `grayscale()`, except it
    uses a gold tint to produce a vintage photo effect. Finally, the `saturate()`
    function controls the color intensity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the functions accepts a percentage value as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A value of `100%` for the `grayscale()` function makes an image completely black
    and white. Passing `100%` to the `sepia()` function makes an image fully sepia
    toned. In the case of both functions, a value of `0%` leaves the image unchanged,
    whereas values greater than `100%` are treated as `100%`.
  prefs: []
  type: TYPE_NORMAL
- en: The `saturate()` function also accepts a percentage as an argument, but it works
    differently from `grayscale()` and `sepia()`. A value of `0%` makes an image appear
    fully unsaturated—or grayscale—whereas values greater than `100%` oversaturate
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To see these functions in action, view example file 18-a on this book’s companion
    website* ([http://thebookofcss3.com/](http://thebookofcss3.com/)).'
  prefs: []
  type: TYPE_NORMAL
- en: '***hue-rotate()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The prosaically named `hue-rotate()` function is used to rotate the hue of
    an element. Recall from “[Hue, Saturation, Lightness](ch10.html#ch10leve1sec119)”
    on [page 116](ch10.html#page_116) that color hue is calculated from an angle around
    the axis of the color wheel. Therefore, the required argument to the `hue-rotate()`
    function is a degree, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Applying `hue-rotate()` actually shifts the hue of all colors in an element
    around the color wheel by the same amount. To see this function in action, view
    example file 18-b on this book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '***opacity()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `opacity()` function works the same as the `opacity` property introduced
    in [Chapter 10](ch10.html#ch10). The function accepts a percentage value as an
    argument, with `0%` equal to fully transparent and `100%` equal to fully opaque:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Values greater than `100%` are treated as `100%`.
  prefs: []
  type: TYPE_NORMAL
- en: If the result of the `opacity()` function is identical to that of the `opacity`
    property, why bother using it at all? Because you can combine it with the other
    filter effect functions, as you’ll see shortly in “[Multiple Filter Effect Functions](ch18.html#ch18leve1sec250)”
    on [page 234](ch18.html#page_234).
  prefs: []
  type: TYPE_NORMAL
- en: '***drop-shadow()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At first, the `drop-shadow()` function may seem to be the same as the `box-shadow`
    property, introduced in [Chapter 9](ch09.html#ch09). Indeed, it even takes the
    same values as arguments: an x-offset, y-offset, blur radius, and shadow color.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The biggest difference between the two is that the `drop-shadow()` function
    is aware of any alpha value (opacity) in the target element. You can see the difference
    clearly in [Figure 18-8](ch18.html#ch18fig8). The target image has a transparent
    background, so in the image at left (which has the `drop-shadow()` function applied),
    the drop box follows the outline of the image. The image on the right, however,
    has the `box-shadow` property applied. Because the `box-shadow` property doesn’t
    care about alpha transparency, the shadow follows only the outline of the box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-8: Comparing the* `*drop-shadow()*` *filter (left) with the* `*box-shadow*`
    *property (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiple Filter Effect Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can apply multiple filter effect functions to an element by simply listing
    them in a space-separated list. For example, you could add both blur and a drop
    shadow to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The order in which you list the functions is important, as that’s the order
    in which they’ll be applied. For example, in this next listing two filter effects
    are applied, but I’ve changed the order: in the first, the `gray-scale()` function
    is applied before `sepia()`, and in the second, I’ve reversed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the `sepia()` function will be applied and then `grayscale()`,
    so all the colors of the `sepia()` filter effect will be converted to grayscale.
    In the second, the `grayscale()` function will be applied and then `sepia()`,
    so the colors of the `sepia()` filter effect will show. Example file 18-c on this
    book’s website shows how this appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like CSS Transforms (introduced in [Chapter 12](ch12.html#ch12)), when you
    list multiple functions in the `filter` property, any functions not in the list
    will have their values returned to the default. For example, in the following
    listing, the element loses its `sepia()` filter effect on hover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '***Filters in SVG***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that CSS filter effects are simply shorthand for SVG filter presets.
    The Filter Effects Module shows the markup equivalents for all of the CSS functions.
    For example, the SVG markup for the `blur()` filter looks like the following (the
    `*blur-radius*` value is a unitless number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create your own filters in SVG and apply them in CSS by using an ID
    reference. The first step is to add an ID value to your filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then refer to it in your CSS using the `url()` notation, containing the ID
    reference, as a value for the `filter` property. If your SVG is in line with the
    markup in your document, you need only the ID reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If your SVG is in an external asset file (say, *filters.svg*), state the path
    to that file followed by the ID reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Unlike CSS filter effects, this technique only works for a single filter. To
    apply multiple filters to an element, you have to combine them in the SVG markup
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '**Masking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Masking is a technique in which certain parts of an element are hidden from
    view. There are two approaches `to masking:` clipping, where the area that’s hidden
    is set by a polygonal shape that’s overlaid on an element, and image masking,
    where an image’s alpha channel is used to set the hidden area.
  prefs: []
  type: TYPE_NORMAL
- en: '***Clipping***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Clipping is the simplest form of masking. When clipping, a shape is laid over
    an image and any parts of the element that are behind the shape will be shown,
    while any parts outside the boundaries of the shape will be hidden. The boundary
    of the shape is called the *clip path* and is created with the `clip-path` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*shape*` can be one of four basic types, each of which is represented
    by a function: `circle()`, `ellipse()`, `inset()` (for rectangles), and `polygon()`.
    Each function takes a number of arguments, which define the clip path. For example,
    to create a circle, you supply three arguments to the `circle()` function, using
    a syntax like that for radial gradients (see [Chapter 11](ch11.html#ch11)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*r*` represents the radius of the circle, and `*cx*` and `*cy*` are the
    coordinates of its center. So to clip an element to a 100px circle positioned
    at the center of the target, you use these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ellipse()` function is very similar, requiring only an extra argument
    to set the radii of the ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `*rx*` is used to represent the *x*-axis of the radius, and `*ry*` the
    *y*-axis. To create an ellipse with a radius of 50px and 100px, again at the center
    of the target, you use these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To see how these appear in practice, take a look at [Figure 18-9](ch18.html#ch18fig9).
    The example on the left uses the `circle()` function with the values used earlier,
    and on the right, `ellipse()`, also with the values used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-9: Function values for the* `*clip-path*` *property:* `*circle()*`
    *(left) and* `*ellipse()*` *(right)*'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the `inset()` function is used to create a rectangle that
    is inset from the border of the element to which it is applied. It can accept
    up to 12 (!) arguments. The first four arguments set the distance that each side
    of the rectangle is offset—just like the `border-image-slice` property (see [Chapter
    9](ch09.html#ch09)). So a single value will set the offset distance equally on
    all sides; if two values are supplied, the first will set the top and bottom and
    the second the left and right; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to use all four values, the syntax would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Each `*o**` represents an offset value (the top, right, bottom and left, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest format, a single value would create four equal offsets, as
    in this case, where each offset value is 2em:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also round the corners of the clip path, which is where the remaining
    arguments come in. Following the `round` keyword, you can use syntax identical
    to that of the `border-radius` property (see [Chapter 9](ch09.html#ch09)) to define
    a radius for each corner—with up to eight values for fine control. To prevent
    my having to repeat the explanation of the `border-radius` short-hand here, this
    example shows how you’d set a radius of 20px on each corner of the inset rectangle
    defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See the result in [Figure 18-10](ch18.html#ch18fig10). The example on the left
    shows a rectangle with right-angled corners, and on the right, a rectangle with
    rounded corners.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-10: The* `*inset()*` *function without (left) and with (right) border
    radius values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `polygon()` function to create more complex clip paths. This
    function takes an unlimited number of arguments, in pairs, in a comma-separated
    list. Each pair creates a coordinate value, and the full set of coordinates is
    used to draw the required clip shape. As a very simple example, this syntax defines
    the three points of a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The triangle’s points are at the left top, left bottom, and right top of the
    target element. You can see how this is clipped in [Figure 18-11](ch18.html#ch18fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-11: A triangular clip path made with the* `*polygon()*` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clipping an element only changes its visual appearance—the dimensions and
    box model of the element that’s clipped will be unmodified. For a suggestion of
    how this may change in the future, see “[Shapes](ch19.html#ch19leve1sec263)” on
    [page 246](ch19.html#page_246).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of clip-path in Safari**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `clip-path` property was implemented in Safari 7, with a vendor prefix,
    but using a now-outdated version of the syntax (the updated syntax was implemented
    in Safari 8). The `polygon()` function works in the same way, but the others are
    slightly different; for example, the `circle()` function looks slightly different,
    requiring three comma-separated arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `ellipse()` function accepts four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inset()` function is known as `inset-rectangle()`, and it requires a minimum
    of four comma-separated values to represent the offset distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can round the corners, but the values must be the same for each corner—you
    can’t set an individual value per corner. You can, however, set *x*-axis and *y*-axis
    values to make irregular radii:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The biggest difference from the standard is in the `rectangle()` function;
    this was originally defined in the spec but has since been pushed back to a future
    version. The `rectangle()` function also lets you create rectangular clipping
    shapes but using coordinates rather than offset values. It accepts up to six arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four arguments are required: `*x*` and `*y*` set the *x*- and *y*-
    coordinates of the top-left corner of the shape, relative to the top-left corner
    of the target element; and `*w*` and `*h*` set the width and height, respectively,
    of the shape. The optional `*rx*` and `*ry*` arguments can be used to set the
    border-radius of all corners of the clip path. (You can use one value to make
    an equal radius, but you can’t set each corner individually.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-12](ch18.html#ch18fig12) shows how these six values set the clipping
    area of an image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-12: Six values for the* `*rectangle()*` *shape function that set
    the clipping area*'
  prefs: []
  type: TYPE_NORMAL
- en: If we combine these options as shown in the following listing, we would create
    a clip path 10px from the top left of the element it’s set on, with a width of
    50 percent, a height of 100px, and corners with a radius of 20px on both axes.
    [Figure 18-13](ch18.html#ch18fig13) shows what this would look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f18-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-13: A rectangle made with the* `*rectangle()*` *function of* `*-webkit-clip-path*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Animating Clip Paths**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because clip paths are defined using coordinates, animating them to create
    impressive effects is easy. For example, you can take the triangle polygon defined
    in the previous section and transition it on hover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this animation, two points of the triangle stay in the same position, while
    the third switches to the corner diagonally opposite. This is animated with a
    transition, causing the effect you see in example file 18-d.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clip Paths in SVG**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can also create clip paths in SVG and apply them to an element using CSS.
    To do so, you first define your clip path markup and then assign it a unique ID.
    For example, the following listing creates a circular clip path using the `clipPath`
    element at the center of the element, with a radius half the width and height.
    It has an ID of `clipping`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, I apply this clip path to my element using the `clip-path` property,
    with a value equal to the `url()` notation containing the ID of the clip path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this method has drawbacks. For one, as of this writing, it only
    works in Firefox. Also, you can’t animate these shapes without using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '***Image Masking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to clipping an element with geometric shapes, you can also mask
    one image with another, using the alpha value of the mask to determine how much
    of the target will be visible. (This process is similar to the way blend modes
    work, except that it uses alpha rather than black and white.) The mask is applied
    using the `mask` property, which takes these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*image*` value is the `url()` notation with a path to the image to be
    used as a mask. The properties `*position*` and `*size*` work the same as the
    `background-position` and `background-size` properties (see [Chapter 8](ch08.html#ch08)).
    For example, the following code will set an image called *mask.png* at the center
    of an element, with the mask filling the width of the parent while maintaining
    its original aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 18-14](ch18.html#ch18fig14) shows the three steps in masking. The target
    image is on the left; the image to be used as a mask is in the middle; and the
    mask applied to the target is on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-14: The three steps of image masking*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is a simple mask. The syntax is much more flexible than this, although
    a bit too complicated to explore in detail in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mask` property is shorthand for a whole range of subproperties, including
    `mask-image`, `mask-position`, and `mask-size`. You can use many more properties
    in addition to these, and the full `mask` shorthand looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a brief walk through the unfamiliar properties. The `mask-mode` property
    determines whether the mask should work on the default alpha channel or through
    *luminance* (lightness); `mask-repeat` tiles the mask image just as `background-repeat`;
    `mask-origin` and `mask-clip` also work like their background equivalents (`background-origin`
    and `background-clip` in [Chapter 8](ch08.html#ch08)); and `mask-composite` controls
    how multiple `mask-image` values should interact if they overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '***Border Masking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.html#ch09), I introduced the `border-image` property, which
    is used to apply images to the borders of an element. You can use the same basic
    method of slicing an image that we discussed in that context to apply a mask to
    the border of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties involved in border masking are `mask-border-source`, `mask-border-slice`,
    `mask-border-repeat`, `mask-border-width,` and `mask-border-output`. Each can
    be included in the `mask-border` shorthand, and each is identical in function
    to their `border-image-*` counterpart. For example, to set an image *mask.png,*
    with slices of 40px each, which repeats along each side of an element, you use
    this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as of this writing no browser supports this in accordance with
    the spec (though Chrome and Safari support a similar but outdated property called
    `-webkit-mask-box-image`), so I won’t spend any more time discussing border masking.
  prefs: []
  type: TYPE_NORMAL
- en: '***Masking in SVG***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use SVG to mask images, much as you might clip them. To do so, you
    define the mask in markup and then apply it using a CSS property (`mask`). For
    example, the following listing creates a mask of a black box with a white ellipse
    in the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to apply the mask to the target element, using the `mask`
    property with a `url()` notation containing the ID of the `mask` element (`masking`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For a more in-depth look at masking in SVG and CSS, see Dirk Schulze’s “CSS*
    *Masking”* ([http://www.html5rocks.com/en/tutorials/masking/adobe/](http://www.html5rocks.com/en/tutorials/masking/adobe/)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Filter Effects and Masking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Should you want to combine filter effects with masking on the same element,
    it’s important to know that they will be applied in a specific order: filter effects
    are applied first, followed by clipping, then masking, and finally opacity. To
    see the consequence of this order, consider the following listing that applies
    a drop shadow filter and circular clipping path to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the effects are applied to the image in this order: first, the
    drop shadow is applied; then the image with the drop shadow applied is clipped
    into a circle. To avoid the clipping of the drop shadow, you can apply the filter
    effect to a parent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This works because of the way browsers parse the DOM for rendering. The clipping
    of the child element will occur before the filter effect that is inherited from
    the parent. ([Figure 18-15](ch18.html#ch18fig15) compares the two methods.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f18-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-15: Comparing rendering order of graphical CSS effects*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blend modes, filter effects, and masking provide access to web browser features
    that were previously found only in professional photo-imaging software. Each is
    useful on its own, but combine them and designers and developers get a whole new
    way to approach visual design on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to use graphical effects like these comes thanks to the widespread
    implementation of SVG. The markup that describes an SVG image is already closely
    tied with HTML (it can be dropped into HTML and will be parsed as part of the
    document), and in the future you should see SVG and CSS become much more closely
    tied—we’ve seen that with the graphical effects in this chapter, and modules currently
    in development also describe a shared implementation of the animation properties
    described in [Chapter 14](ch14.html#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: '**Blend Modes, Filter Effects, and Masking: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| `background-blend-mode` | Yes | Yes | Safari 8 | No |'
  prefs: []
  type: TYPE_TB
- en: '| `mix-blend-mode` | No^([*](ch18.html#footnote41a)) | Yes | Safari 8 | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isolation` | No[*](ch18.html#footnote41a) | No | Safari 8 | No |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | Yes^([†](ch18.html#footnote42a)) | No^([‡](ch18.html#footnote43a))
    | Yes^([†](ch18.html#footnote42a)) | No |'
  prefs: []
  type: TYPE_TB
- en: '| `clip-path` | Yes[*](ch18.html#footnote41a) | No | Safari 8^([§](ch18.html#footnote44a))
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `mask` | Yes^([†](ch18.html#footnote42a)) | No | Yes^([†](ch18.html#footnote42a))
    | No |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch18.html#footnote_41a) Implemented but off by default'
  prefs: []
  type: TYPE_NORMAL
- en: '[†](ch18.html#footnote_42a) With vendor prefix'
  prefs: []
  type: TYPE_NORMAL
- en: '[‡](ch18.html#footnote_43a) Can use filters defined in SVG'
  prefs: []
  type: TYPE_NORMAL
- en: '[§](ch18.html#footnote_44a) With vendor prefix; implemented with outdated syntax
    in Safari 7'
  prefs: []
  type: TYPE_NORMAL
