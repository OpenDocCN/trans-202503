- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Testing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, we’ll look at the various ways in which you can extend Rust’s
    testing capabilities and what other kinds of testing you may want to add into
    your testing mix. Rust comes with a number of built-in testing facilities that
    are well covered in *The Rust Programming Language*, represented primarily by
    the `#[test]` attribute and the *tests/* directory. These will serve you well
    across a wide range of applications and scales and are often all you need when
    you are getting started with a project. However, as the codebase develops and
    your testing needs grow more elaborate, you may need to go beyond just tagging
    `#[test]` onto individual functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨扩展Rust测试功能的各种方式，以及可能想要加入的其他类型的测试。Rust自带了一些内建的测试工具，这些工具在*《Rust编程语言》*中有详细介绍，主要通过`#[test]`属性和*tests/*目录进行表示。这些工具能够很好地支持各种应用和规模，通常在你刚开始一个项目时，已经足够用了。然而，随着代码库的发展，测试需求变得更加复杂，你可能需要超越简单地在单个函数上标记`#[test]`。
- en: This chapter is divided into two main sections. The first part covers Rust testing
    mechanisms, like the standard testing harness and conditional testing code. The
    second looks at other ways to evaluate the correctness of your Rust code, such
    as benchmarking, linting, and fuzzing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个主要部分。第一部分涵盖了Rust的测试机制，比如标准的测试框架和条件性测试代码。第二部分则讨论了其他评估Rust代码正确性的方法，如基准测试、代码检查和模糊测试。
- en: Rust Testing Mechanisms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust测试机制
- en: 'To understand the various testing mechanisms Rust provides, you must first
    understand how Rust builds and runs tests. When you run `cargo test --lib`, the
    only special thing Cargo does is pass the `--test` flag to `rustc`. This flag
    tells `rustc` to produce a test binary that runs all the unit tests, rather than
    just compiling the crate’s library or binary. Behind the scenes, `--test` has
    two primary effects. First, it enables `cfg(test)` so that you can conditionally
    include testing code (more on that in a bit). Second, it makes the compiler generate
    a *test harness*: a carefully generated `main` function that invokes each `#[test]`
    function in your program when it’s run.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Rust提供的各种测试机制，首先必须了解Rust是如何构建和运行测试的。当你运行`cargo test --lib`时，Cargo唯一做的特殊事情就是将`--test`标志传递给`rustc`。这个标志告诉`rustc`生成一个测试二进制文件，运行所有单元测试，而不仅仅是编译包的库或二进制文件。在幕后，`--test`有两个主要效果。首先，它启用了`cfg(test)`，这样你可以有条件地包含测试代码（稍后会详细介绍）。其次，它使编译器生成一个*测试框架*：一个精心生成的`main`函数，运行程序中的每个`#[test]`函数。
- en: The Test Harness
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试框架
- en: The compiler generates the test harness `main` function through a mix of procedural
    macros, which we’ll discuss in greater depth in Chapter 7, and a light sprinkling
    of magic. Essentially, the harness transforms every function annotated by `#[test]`
    into a test *descriptor*—this is the procedural macro part. It then exposes the
    path of each of the descriptors to the generated `main` function—this is the magic
    part. The descriptor includes information like the test’s name, any additional
    options it has set (like `#[should_panic]`), and so on. At its core, the test
    harness iterates over the tests in the crate, runs them, captures their results,
    and prints the results. So, it also includes logic to parse command line arguments
    (for things like `--test-threads=1`), capture test output, run the listed tests
    in parallel, and collect test results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过程序化宏（在第7章中我们将深入讨论）和一些魔法的小技巧，生成测试框架的`main`函数。基本上，框架将每个被`#[test]`注解的函数转换成一个测试*描述符*——这是程序化宏的部分。然后，它将每个描述符的路径暴露给生成的`main`函数——这就是魔法的部分。描述符包含信息，例如测试的名称、设置的任何附加选项（如`#[should_panic]`）等。核心的测试框架会遍历包中的所有测试，运行它们，捕获结果并打印输出。所以，它还包括解析命令行参数的逻辑（例如`--test-threads=1`），捕获测试输出，平行运行列出的测试，并收集测试结果。
- en: As of this writing, Rust developers are working on making the magic part of
    test harness generation a publicly available API so that developers can build
    their own test harnesses. This work is still at the experimental stage, but the
    proposal aligns fairly closely with the model as it exists today. Part of the
    magic that needs to be figured out is how to ensure that `#[test]` functions are
    available to the generated `main` function even if they are inside private submodules.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在写本文时，Rust 开发者正在致力于使测试工具生成的魔法部分成为公开可用的 API，以便开发者能够构建自己的测试工具。这项工作仍处于实验阶段，但该提案与现有模型非常接近。需要解决的部分魔法是如何确保即使
    `#[test]` 函数位于私有子模块中，也能让它们在生成的 `main` 函数中可用。
- en: Integration tests (the tests in *tests/*) follow the same process as unit tests,
    with the one exception that they are each compiled as their own separate crate,
    meaning they can access only the main crate’s public interface and are run against
    the main crate compiled without `#[cfg(test)]`. A test harness is generated for
    each file in *tests/*. Test harnesses are not generated for files in subdirectories
    under *tests/* to allow you to have shared submodules for your tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试（位于 *tests/* 目录中的测试）与单元测试遵循相同的流程，唯一的例外是它们每个都作为独立的 crate 编译，这意味着它们只能访问主 crate
    的公共接口，并且是在没有 `#[cfg(test)]` 的情况下针对主 crate 编译运行的。每个 *tests/* 中的文件都会生成一个测试工具。对于
    *tests/* 下子目录中的文件，不会生成测试工具，这样你可以为测试共享子模块。
- en: Rust does not require that you use the default test harness. You can instead
    opt out of it and implement your own `main` method that represents the test runner
    by setting `harness = false` for a given integration test in *Cargo.toml*, as
    shown in [Listing 6-1](#listing6-1). The `main` method that you define will then
    be invoked to run the test.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不要求你使用默认的测试工具。你可以选择退出它，并实现你自己的 `main` 方法，作为测试运行器，通过在 *Cargo.toml* 中为特定的集成测试设置
    `harness = false`，如[清单 6-1](#listing6-1)所示。你定义的 `main` 方法将会被调用来运行测试。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Opting out of the standard test harness'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-1：退出标准测试工具
- en: Without the test harness, none of the magic around `#[test]` happens. Instead,
    you’re expected to write your own `main` function to run the testing code you
    want to execute. Essentially, you’re writing a normal Rust binary that just happens
    to be run by `cargo test`. That binary is responsible for handling all the things
    that the default harness normally does (if you want to support them), such as
    command line flags. The `harness` property is set separately for each integration
    test, so you can have one test file that uses the standard harness and one that
    does not.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试工具时，`#[test]` 的相关魔法不会发生。相反，你需要编写你自己的 `main` 函数来运行你希望执行的测试代码。实际上，你正在编写一个普通的
    Rust 二进制文件，只不过它是由 `cargo test` 运行的。这个二进制文件负责处理默认测试工具通常处理的所有事务（如果你希望支持它们的话），比如命令行标志。`harness`
    属性是针对每个集成测试单独设置的，因此你可以拥有一个使用标准测试工具的测试文件，也可以拥有一个不使用它的文件。
- en: Integration tests without a harness are primarily useful for benchmarks, as
    we’ll see later, but they also come in handy when you want to run tests that don’t
    fit the standard “one function, one test” model. For example, you’ll frequently
    see harnessless tests used with fuzzers, model checkers, and tests that require
    a custom global setup (like under WebAssembly or when working with custom targets).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试工具的集成测试主要用于基准测试，正如我们稍后将看到的，但它们在你想运行那些不符合标准“一个函数，一个测试”模型的测试时也很有用。例如，你会经常看到没有测试工具的测试与模糊测试器、模型检查器一起使用，或者需要自定义全局设置的测试（如在
    WebAssembly 中，或与自定义目标一起使用时）。
- en: '#[cfg(test)]'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '#[cfg(test)]'
- en: 'When Rust builds code for testing, it sets the compiler configuration flag
    `test`, which you can then use with conditional compilation to have code that
    is compiled out unless it is specifically being tested. On the surface, this may
    seem odd: don’t you want to test exactly the same code that’s going into production?
    You do, but having code exclusively available when testing allows you to write
    better, more thorough tests, in a few ways.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rust 为测试构建代码时，它会设置编译器配置标志 `test`，你可以利用条件编译来确保代码只有在进行测试时才会被编译。表面上看，这似乎有些奇怪：你不想测试进入生产环境的完全相同的代码吗？当然是的，但只在测试时提供代码，可以让你以几种方式编写更好、更彻底的测试。
- en: Test-Only APIs
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅限测试的 API
- en: First, having test-only code allows you to expose additional methods, fields,
    and types to your (unit) tests so the tests can check not only that the public
    API behaves correctly but also that the internal state is correct. For example,
    consider the `HashMap` type from `hashbrown`, the crate that implements the standard
    library `HashMap`. The `HashMap` type is really just a wrapper around a `RawTable`
    type, which is what implements most of the hash table logic. Suppose that after
    doing a `HashMap::insert` on an empty map, you want to check that a single bucket
    in the map is nonempty, as shown in [Listing 6-2](#listing6-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，只有测试代码可以让你向（单元）测试暴露额外的方法、字段和类型，这样测试不仅可以检查公共 API 是否正常工作，还可以检查内部状态是否正确。例如，考虑`hashbrown`中的`HashMap`类型，它是实现标准库`HashMap`的
    crate。`HashMap`类型实际上只是一个围绕`RawTable`类型的包装器，后者实现了大部分哈希表的逻辑。假设在对一个空的哈希表执行`HashMap::insert`后，你想检查哈希表中的一个桶是否非空，如[Listing
    6-2](#listing6-2)所示。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: A test that accesses inaccessible internal state and thus does
    not compile'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-2：一个访问不可访问内部状态的测试，因此无法编译
- en: This code will not compile as written, because while the test code can access
    the private `table` field of `HashMap`, it cannot access the also private `buckets`
    field of `RawTable`, as `RawTable` lives in a different module. We could fix this
    by making the `buckets` field visibility `pub(crate)`, but we really don’t want
    `HashMap` to be able to touch `buckets` in general, as it could accidentally corrupt
    the internal state of the `RawTable`. Even making `buckets` available as read-only
    could be problematic, as new code in `HashMap` may then start depending on the
    internal state of `RawTable`, making future modifications more difficult.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按原样无法编译，因为尽管测试代码可以访问`HashMap`的私有`table`字段，但它不能访问`RawTable`的私有`buckets`字段，因为`RawTable`位于不同的模块中。我们可以通过将`buckets`字段的可见性设置为`pub(crate)`来解决此问题，但我们并不希望`HashMap`能触及`buckets`，因为这可能会意外地破坏`RawTable`的内部状态。即使将`buckets`设置为只读也可能会带来问题，因为`HashMap`中的新代码可能会开始依赖`RawTable`的内部状态，从而使未来的修改更加困难。
- en: The solution is to use `#[cfg(test)]`. We can add a method to `RawTable` that
    allows access to `buckets` only while testing, as shown in [Listing 6-3](#listing6-3),
    and thereby avoid adding footguns for the rest of the code. The code from [Listing
    6-2](#listing6-2) can then be updated to call `buckets()` instead of accessing
    the private `buckets` field.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用`#[cfg(test)]`。我们可以向`RawTable`添加一个方法，允许在测试时访问`buckets`，如[Listing 6-3](#listing6-3)所示，从而避免为其他代码增加不必要的风险。然后，可以更新[Listing
    6-2](#listing6-2)中的代码，调用`buckets()`而不是直接访问私有的`buckets`字段。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Using `#[cfg(test)]` to make internal state accessible in the
    testing context'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-3：使用`#[cfg(test)]`使内部状态在测试上下文中可访问
- en: Bookkeeping for Test Assertions
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试断言的记账
- en: The second benefit of having code that exists only during testing is that you
    can augment the program to perform additional runtime bookkeeping that can then
    be inspected by tests. For example, imagine you’re writing your own version of
    the `BufWriter` type from the standard library. When testing it, you want to make
    sure that `BufWriter` does not issue system calls unnecessarily. The most obvious
    way to do so is to have the `BufWriter` keep track of how many times it has invoked
    `write` on the underlying `Write`. However, in production this information isn’t
    important, and keeping track of it introduces (marginal) performance and memory
    overhead. With `#[cfg(test)]`, you can have the bookkeeping happen only when testing,
    as shown in [Listing 6-4](#listing6-4).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在测试期间存在的代码的第二个好处是，你可以增强程序以执行额外的运行时记账操作，然后由测试进行检查。例如，假设你正在编写自己版本的标准库中的`BufWriter`类型。在测试时，你希望确保`BufWriter`不会不必要地发出系统调用。最直接的方式是让`BufWriter`跟踪它在底层`Write`上调用`write`的次数。然而，在生产环境中，这些信息并不重要，而跟踪这些信息会带来（边际）性能和内存开销。通过`#[cfg(test)]`，你可以确保记账操作仅在测试时发生，如[Listing
    6-4](#listing6-4)所示。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Using `#[cfg(test)]` to limit bookkeeping to the testing context'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-4：使用`#[cfg(test)]`将记账限制在测试上下文中
- en: Keep in mind that `test` is set only for the crate that is being compiled as
    a test. For unit tests, this is the crate being tested, as you would expect. For
    integration tests, however, it is the integration test binary being compiled as
    a test—the crate you are testing is just compiled as a library and so will not
    have `test` set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`test` 仅在作为测试编译的 crate 中设置。对于单元测试，这是正在测试的 crate，正如你所期望的那样。然而，对于集成测试，它是作为测试编译的集成测试二进制文件——你正在测试的
    crate 只是作为库编译，因此不会设置 `test`。
- en: Doctests
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Doctests
- en: Rust code snippets in documentation comments are automatically run as test cases.
    These are commonly referred to as *doctests*. Because doctests appear in the public
    documentation of your crate, and users are likely to mimic what they contain,
    they are run as integration tests. This means that the doctests don’t have access
    to private fields and methods, and `test` is not set on the main crate’s code.
    Each doctest is compiled as its own dedicated crate and is run in isolation, just
    as if the user had copy-pasted the doctest into their own program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释中的 Rust 代码片段会自动作为测试用例运行。这些通常被称为 *doctests*。由于 doctests 出现在你的 crate 的公共文档中，用户很可能会模仿它们，因此它们作为集成测试运行。这意味着
    doctests 无法访问私有字段和方法，并且 `test` 在主 crate 的代码中没有设置。每个 doctest 都作为一个独立的 crate 编译，并且在隔离环境中运行，就像用户将
    doctest 复制粘贴到自己的程序中一样。
- en: Behind the scenes, the compiler performs some preprocessing on doctests to make
    them more concise. Most importantly, it automatically adds an `fn main` around
    your code. This allows doctests to focus only on the important bits that the user
    is likely to care about, like the parts that actually use types and methods from
    your library, without including unnecessary boilerplate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，编译器对 doctest 进行一些预处理，使其更加简洁。最重要的是，它会自动为你的代码添加一个 `fn main`。这让 doctest 只关注用户可能关心的重要部分，比如实际使用你库中的类型和方法的部分，而不会包含不必要的样板代码。
- en: You can opt out of this auto-wrapping by defining your own `fn main` in the
    doctest. You may want to do this, for example, if you want to write an asynchronous
    `main` function using something like `#[tokio::main] async fn main`, or if you
    want to add additional modules to the doctest.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 doctest 中定义自己的 `fn main` 来选择退出这种自动包装。例如，如果你想使用类似 `#[tokio::main] async
    fn main` 的异步 `main` 函数，或者你想在 doctest 中添加其他模块，可能需要这么做。
- en: 'To use the `?` operator in your doctest, you don’t normally have to use a custom
    `main` function as `rustdoc` includes some heuristics to set the return type to
    `Result<(), impl Debug>` if your code looks like it makes use of `?` (for example,
    if it ends with `Ok(())`). If type inference gives you a hard time about the error
    type for the function, you can disambiguate it by changing the last line of the
    doctest to be explicitly typed, like this: `Ok::<(), T>(())`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 doctest 中使用 `?` 运算符时，通常不需要使用自定义的 `main` 函数，因为 `rustdoc` 会自动进行一些启发式处理，如果你的代码看起来像是使用了
    `?`（例如，代码以 `Ok(())` 结尾），它会将返回类型设置为 `Result<(), impl Debug>`。如果类型推断在函数的错误类型上让你感到困惑，你可以通过显式指定最后一行的类型来消除歧义，例如：`Ok::<(),
    T>(())`。
- en: Doctests have a number of additional features that come in handy as you write
    documentation for more complex interfaces. The first is the ability to hide individual
    lines. If you prefix a line of a doctest with a `#`, that line is included when
    the doctest is compiled and run, but it is not included in the code snippet generated
    in the documentation. This lets you easily hide details that are not important
    to the current example, such as implementing traits for dummy types or generating
    values. It is also useful if you wish to present a sequence of examples without
    showing the same leading code each time. [Listing 6-5](#listing6-5) gives an example
    of what a doctest with hidden lines might look like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest 具有许多额外的功能，这些功能在为更复杂的接口编写文档时非常实用。第一个功能是隐藏单独的行。如果你在 doctest 的一行前加上 `#`，该行会在
    doctest 编译并运行时被包含，但不会出现在文档生成的代码片段中。这样你可以轻松隐藏当前示例中不重要的细节，例如为虚拟类型实现特征或生成值。如果你希望展示一系列示例，而不每次都显示相同的前导代码，这也非常有用。[列表
    6-5](#listing6-5) 给出了一个包含隐藏行的 doctest 示例。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '/// # let unfrobnified_number = 0;'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # let unfrobnified_number = 0;'
- en: '/// # let already_frobnified = 1;'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # let already_frobnified = 1;'
- en: /// assert!(frobnify(unfrobnified_number).is_ok());
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert!(frobnify(unfrobnified_number).is_ok());
- en: /// assert!(frobnify(already_frobnified).is_err());
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert!(frobnify(already_frobnified).is_err());
- en: /// [PRE5]
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE5]
- en: '/// # use mylib::frobnify;'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # use mylib::frobnify;'
- en: /// frobnify("0".parse()?)?;
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: /// frobnify("0".parse()?)?;
- en: '/// # Ok::<(), anyhow::Error>(())'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # Ok::<(), anyhow::Error>(())'
- en: /// [PRE6]
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE6]
- en: '/// # /*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # /*'
- en: /// let i = ...;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: /// let i = ...;
- en: '/// # */'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # */'
- en: '/// # let i = 42;'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # let i = 42;'
- en: /// frobnify(i)?;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: /// frobnify(i)?;
- en: /// [PRE7]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE7]
- en: 'Listing 6-5: Hiding lines in a doctest with `#`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-5：使用 `#` 在文档测试中隐藏行
- en: Much like `#[test]` functions, doctests also support attributes that modify
    how the doctest is run. These attributes go immediately after the triple-backtick
    used to denote a code block, and multiple attributes can be separated by commas.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `#[test]` 函数类似，文档测试也支持修改文档测试运行方式的属性。这些属性紧跟在用于表示代码块的三重反引号后面，多个属性可以用逗号分隔。
- en: Like with test functions, you can specify the `should_panic` attribute to indicate
    that the code in a particular doctest should panic when run, or `ignore` to check
    the code segment only if `cargo test` is run with the `--ignored` flag. You can
    also use the `no_run` attribute to indicate that a given doctest should compile
    but should not be run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试函数类似，您可以指定 `should_panic` 属性来指示特定的文档测试中的代码在运行时应当触发 panic，或者使用 `ignore` 仅在
    `cargo test` 以 `--ignored` 标志运行时检查代码段。您还可以使用 `no_run` 属性来指示某个文档测试应编译但不应运行。
- en: The attribute `compile_fail` tells `rustdoc` that the code in the documentation
    example should not compile. This indicates to the user that a particular use is
    not possible and serves as a useful test to remind you to update the documentation
    should the relevant aspect of your library change. You can also use this attribute
    to check that certain static properties hold for your types. [Listing 6-6](#listing6-6)
    shows an example of how you can use `compile_fail` to check that a given type
    does not implement `Send`, which may be necessary to uphold safety guarantees
    in unsafe code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `compile_fail` 告诉 `rustdoc` 文档示例中的代码不应该编译。这向用户指示某个特定用法不可行，并作为一个有用的测试提醒您在库的相关部分发生变化时更新文档。您还可以使用此属性来检查某些静态属性是否对您的类型有效。[列表
    6-6](#listing6-6)展示了如何使用 `compile_fail` 来检查某个类型是否没有实现 `Send`，这可能对在不安全代码中维护安全保证至关重要。
- en: '[PRE8]compile_fail'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]compile_fail'
- en: struct MyNonSendType(std::rc::Rc<()>);
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: struct MyNonSendType(std::rc::Rc<()>);
- en: 'fn is_send<T: Send>() {}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn is_send<T: Send>() {}'
- en: is_send::<MyNonSendType>();
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: is_send::<MyNonSendType>();
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-6: Testing that code fails to compile with `compile_fail`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-6：测试代码是否无法编译，使用 `compile_fail`
- en: '`compile_fail` is a fairly crude tool in that it gives no indication of *why*
    the code does not compile. For example, if code doesn’t compile because of a missing
    semicolon, a `compile_fail` test will appear to have been successful. For that
    reason, you’ll usually want to add the attribute only after you have made sure
    that the test indeed fails to compile with the expected error. If you need more
    fine-grained tests for compilation errors, such as when developing macros, take
    a look at the `trybuild` crate.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile_fail` 是一个相对粗略的工具，因为它没有指示 *为什么* 代码不编译。例如，如果代码因为缺少分号而无法编译，`compile_fail`
    测试可能看起来已成功。出于这个原因，您通常需要在确保测试确实因为预期错误无法编译后再添加该属性。如果您需要更细粒度的编译错误测试，例如在开发宏时，建议查看
    `trybuild` crate。'
- en: Additional Testing Tools
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他测试工具
- en: There’s a lot more to testing than just running test functions and seeing that
    they produce the expected result. A thorough survey of testing techniques, methodologies,
    and tools is outside the scope of this book, but there are some key Rust-specific
    pieces that you should know about as you expand your testing repertoire.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不仅仅是运行测试函数并查看它们是否产生预期的结果。全面的测试技术、方法论和工具的调研超出了本书的范围，但有一些关键的 Rust 特定内容是您在扩展测试工具时应该了解的。
- en: Linting
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析
- en: You may not consider a linter’s checks to be tests, but in Rust they often can
    be. The Rust linter *clippy* categorizes a number of its lints as *correctness*
    lints. These lints catch code patterns that compile but are almost certainly bugs.
    Some examples are `a = b; b = a`, which fails to swap `a` and `b`; `std::mem::forget(t)`,
    where `t` is a reference; and `for x in y.next()`, which will iterate only over
    the first element in `y`. If you are not running clippy as part of your CI pipeline
    already, you probably should be.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会将静态分析工具（linter）的检查视为测试，但在 Rust 中，它们通常可以视为测试。Rust 的 linter *clippy* 将其多个
    lint 分类为 *正确性* lint。这些 lint 能捕捉那些能够编译但几乎肯定是 bug 的代码模式。一些示例包括 `a = b; b = a`，这无法交换
    `a` 和 `b`；`std::mem::forget(t)`，其中 `t` 是一个引用；以及 `for x in y.next()`，这只会遍历 `y`
    中的第一个元素。如果您尚未在 CI 流水线中运行 clippy，您可能应该开始使用它。
- en: Clippy comes with a number of other lints that, while usually helpful, may be
    more opinionated than you’d prefer. For example, the `type_complexity` lint, which
    is on by default, issues a warning if you use a particularly involved type in
    your program, like `Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>`. While that warning
    encourages you to write code that is easier to read, you may find it too pedantic
    to be broadly useful. If some part of your code erroneously triggers a particular
    lint, or you just want to allow a specific instance of it, you can opt out of
    the lint just for that piece of code with `#[allow(clippy::name_of_lint)]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Clippy 附带了许多其他的 lint（静态分析检查），虽然这些通常很有帮助，但有时可能比你希望的更具主观性。例如，默认开启的 `type_complexity`
    lint 会发出警告，提示你使用了一个特别复杂的类型，例如 `Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>`。虽然这个警告鼓励你编写更易读的代码，但你可能会觉得它过于吹毛求疵，难以广泛应用。如果你代码中的某一部分错误地触发了特定的
    lint，或者你只是希望允许某一特定实例，你可以使用 `#[allow(clippy::name_of_lint)]` 让该部分代码不受该 lint 的影响。
- en: The Rust compiler also comes with its own set of lints in the form of warnings,
    though these are usually more directed toward writing idiomatic code than checking
    for correctness. Instead, correctness lints in the compiler are simply treated
    as errors (take a look at `rustc -W help` for a list).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器也带有一套自己的 lint，形式是警告，尽管这些警告通常更多是针对编写符合惯用法的代码，而不是检查代码的正确性。相反，编译器中的正确性
    lint 会被视为错误（可以通过 `rustc -W help` 查看相关列表）。
- en: Test Generation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试生成
- en: 'Writing a good test suite is a lot of work. And even when you do that work,
    the tests you write test only the particular set of behaviors you were considering
    at the time you wrote them. Luckily, you can take advantage of a number of test
    generation techniques to develop better and more thorough tests. These generate
    input for you to use to check your application’s correctness. Many such tools
    exist, each with their own strengths and weaknesses, so here I’ll cover only the
    main strategies used by these tools: fuzzing and property testing.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个好的测试套件是非常耗费精力的。而且，即使你完成了这项工作，你编写的测试仅仅测试了你在编写它们时考虑的特定行为集。幸运的是，你可以利用一些测试生成技术来开发更好、更全面的测试。这些技术会为你生成输入，用来检查你应用程序的正确性。许多此类工具已经存在，每个工具都有自己的优缺点，因此在这里我只会讲解这些工具的主要策略：模糊测试和属性测试。
- en: Fuzzing
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模糊测试
- en: 'Entire books have been written about fuzzing, but at a high level the idea
    is simple: generate random inputs to your program and see if it crashes. If the
    program crashes, that’s a bug. For example, if you’re writing a URL parsing library,
    you can fuzz-test your program by systematically generating random strings and
    throwing them at the parsing function until it panics. Done naively, this would
    take a while to yield results: if the fuzzer starts with `a`, then `b`, then `c`,
    and so on, it will take it a long time to generate a tricky URL like `http://[:]`.
    In practice, modern fuzzers use code coverage metrics to explore different paths
    in your code, which lets them reach higher degrees of coverage faster than if
    the inputs were truly chosen at random.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模糊测试（fuzzing），已经有许多书籍专门讨论了这个话题，但从高层次上看，原理很简单：为你的程序生成随机输入，看看它是否崩溃。如果程序崩溃了，那就是一个
    bug。例如，如果你正在编写一个 URL 解析库，你可以通过系统地生成随机字符串并将其传递给解析函数进行模糊测试，直到它发生 panic。若操作不够精细，这个过程可能需要一些时间才能得到结果：如果模糊测试器从
    `a` 开始，然后是 `b`，接着是 `c`，依此类推，它需要很长时间才能生成像 `http://[:]` 这样棘手的 URL。在实际应用中，现代的模糊测试工具使用代码覆盖率度量来探索代码中的不同路径，这使得它们能够比真正随机选择输入时更快地达到更高的覆盖度。
- en: 'Fuzzers are great at finding strange corner cases that your code doesn’t handle
    correctly. They require little setup on your part: you just point the fuzzer at
    a function that takes a “fuzzable” input, and off it goes. For example, [Listing
    6-7](#listing6-7) shows an example of how you might fuzz-test a URL parser.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试工具在发现你的代码无法正确处理的奇怪边界情况方面非常出色。它们对你几乎没有设置要求：你只需要将模糊测试工具指向一个接受“可模糊输入”的函数，它就会自动开始工作。例如，[Listing
    6-7](#listing6-7) 显示了一个如何进行 URL 解析器模糊测试的例子。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-7: Fuzzing a URL parser with `libfuzzer`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-7: 使用 `libfuzzer` 进行 URL 解析器模糊测试'
- en: The fuzzer will generate semi-random inputs to the closure, and any that form
    valid UTF-8 strings will be passed to the parser. Notice that the code here doesn’t
    check whether the parsing succeeds or fails—instead, it’s looking for cases where
    the parser panics or otherwise crashes due to internal invariants that are violated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试工具将会为闭包生成半随机输入，任何能够形成有效 UTF-8 字符串的输入都会被传递给解析器。注意，代码这里并没有检查解析是否成功或失败——而是关注于查找解析器因为违反了内部不变条件而
    panic 或崩溃的情况。
- en: The fuzzer keeps running until you terminate it, so most fuzzing tools come
    with a built-in mechanism to stop after a certain number of test cases have been
    explored. If your input isn’t a trivially fuzzable type—something like a hash
    table—you can usually use a crate like `arbitrary` to turn the byte string that
    the fuzzer generates into a more complex Rust type. It feels like magic, but under
    the hood it’s actually implemented in a very straightforward fashion. The crate
    defines an `Arbitrary` trait with a single method, `arbitrary`, that constructs
    the implementing type from a source of random bytes. Primitive types like `u32`
    or `bool` read the necessary number of bytes from that input to construct a valid
    instance of themselves, whereas more complex types like `HashMap` or `BTreeSet`
    produce one number from the input to dictate their length and then call `Arbitrary`
    that number of times on their inner types. There’s even an attribute, `#[derive(Arbitrary)]`,
    that implements `Arbitrary` by just calling `arbitrary` on each contained type!
    To explore fuzzing further, I recommend starting with `cargo-fuzz`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试工具会一直运行，直到你终止它，所以大多数模糊测试工具都内建有机制，在探索了某些测试用例后停止。如果你的输入不是一个可以简单模糊测试的类型——比如哈希表——你通常可以使用像`arbitrary`这样的库，将模糊测试生成的字节字符串转化为更复杂的Rust类型。它看起来像魔法，但在幕后，它其实是通过非常直接的方式实现的。这个库定义了一个`Arbitrary`特性，其中有一个方法`arbitrary`，用于从随机字节源构建实现该特性的类型。像`u32`或`bool`这样的原始类型会从输入中读取必要的字节数来构建其有效实例，而像`HashMap`或`BTreeSet`这样的复杂类型会从输入中生成一个数字来决定它们的长度，然后对它们的内部类型调用`Arbitrary`该次数。甚至有一个属性`#[derive(Arbitrary)]`，它通过对每个包含类型调用`arbitrary`来实现`Arbitrary`！如果你想更深入地了解模糊测试，我推荐从`cargo-fuzz`开始。
- en: Property-Based Testing
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: Sometimes you want to check not only that your program doesn’t crash but also
    that it does what it’s expected to do. It’s great that your `add` function didn’t
    panic, but if it tells you that the result of `add(1, 4)` is `68`, it’s probably
    still wrong. This is where *property-based testing* comes into play; you describe
    a number of properties your code should uphold, and then the property testing
    framework generates inputs and checks that those properties indeed hold.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不仅仅想检查程序是否崩溃，还希望它能够按预期执行。这意味着你的`add`函数没有崩溃是好事，但如果它告诉你`add(1, 4)`的结果是`68`，那可能还是错误的。这就是*基于属性的测试*发挥作用的地方；你描述一些代码应该遵循的属性，然后属性测试框架生成输入并检查这些属性是否确实成立。
- en: A common way to use property-based testing is to first write a simple but naive
    version of the code you want to test that you are confident is correct. Then,
    for a given input, you give that input to both the code you want to test and the
    simplified but naive version. If the result or output of the two implementations
    is the same, your code is good—that is the correctness property you’re looking
    for—but if it’s not, you’ve likely found a bug. You can also use property-based
    testing to check for properties not directly related to correctness, such as whether
    operations take strictly less time for one implementation than another. The common
    principle is that you want any difference in outcome between the real and test
    versions to be informative and actionable so that every failure allows you to
    make improvements. The naive implementation might be one from the standard library
    that you’re trying to replace or augment (like `std::collections::VecDeque`),
    or it might be a simpler version of an algorithm that you’re trying optimize (like
    naive versus optimized matrix multiplication).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于属性的测试的常见方法是，首先编写一个简单但天真的版本的代码，这是你确信正确的版本。然后，对于给定的输入，你将该输入同时提供给你想测试的代码和简化但天真的版本。如果两个实现的结果或输出相同，那么你的代码就是好的——这就是你正在寻找的正确性属性——但如果不相同，你可能已经发现了一个bug。你还可以使用基于属性的测试来检查与正确性无关的属性，比如某个实现的操作是否比另一个实现的操作耗时更少。普遍的原则是，你希望实际版本和测试版本之间的任何结果差异都是有信息量的并且可操作的，这样每次失败都能让你改进。天真的实现可能是你想替换或增强的标准库中的某个实现（比如`std::collections::VecDeque`），或者它可能是你正在尝试优化的算法的简化版本（比如天真的矩阵乘法与优化后的矩阵乘法）。
- en: If this approach of generating inputs until some condition is met sounds a lot
    like fuzzing, that’s because it is—smarter people than I have argued that fuzzing
    is “just” property-based testing where the property you’re testing for is “it
    doesn’t crash.”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种生成输入直到满足某些条件的方式听起来很像模糊测试，那是因为它确实如此——比我更聪明的人曾经说过，模糊测试“只是”基于属性的测试，而你测试的属性就是“它不会崩溃”。
- en: One downside of property-based testing is that it relies more heavily on the
    provided descriptions of the inputs. Whereas fuzzing will keep trying all possible
    inputs, property testing tends to be guided by developer annotations like “a number
    between 0 and 64” or “a string that contains three commas.” This allows property
    testing to more quickly reach cases that fuzzers may take a long time to encounter
    randomly, but it does require manual work and may miss important but niche buggy
    inputs. As fuzzers and property testers grow closer, however, fuzzers are starting
    to gain this kind of constraint-based searching capability as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试的一个缺点是它更加依赖于输入的描述。与模糊测试不断尝试所有可能的输入不同，属性测试往往依赖开发者注释的指导，如“0 到 64 之间的数字”或“包含三个逗号的字符串”。这使得属性测试能够更快地覆盖到模糊测试可能需要很长时间才能随机遇到的情况，但它确实需要手动工作，并且可能错过一些重要但冷门的
    bug 输入。然而，随着模糊测试和属性测试的不断融合，模糊测试也开始具备这种基于约束的搜索能力。
- en: If you’re curious about property-based test generation, I recommend starting
    with the `proptest` crate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对基于属性的测试生成感兴趣，我推荐从 `proptest` crate 开始。
- en: Test Augmentation
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试增强
- en: 'Let’s say you have a magnificent test suite all set up, and your code passes
    all the tests. It’s glorious. But then, one day, one of the normally reliable
    tests inexplicably fails or crashes with a segmentation fault. There are two common
    reasons for these kinds of nondeterministic test failures: race conditions, where
    your test might fail only if two operations occur on different threads in a particular
    order, and undefined behavior in unsafe code, such as if some unsafe code reads
    a particular value out of uninitialized memory.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经设置好了一个非常棒的测试套件，并且你的代码通过了所有的测试。这是如此辉煌。但有一天，通常可靠的测试却莫名其妙地失败了，或者因为分段错误崩溃。有两种常见的原因会导致这种非确定性的测试失败：竞态条件，测试可能仅在两个操作以特定顺序在不同线程上发生时才会失败，以及不安全代码中的未定义行为，例如某些不安全代码从未初始化的内存中读取特定值。
- en: Catching these kinds of bugs with normal tests can be difficult—often you don’t
    have sufficient low-level control over thread scheduling, memory layout and content,
    or other random-ish system factors to write a reliable test. You could run each
    test many times in a loop, but even that may not catch the error if the bad case
    is sufficiently rare or unlikely. Luckily, there are tools that can help augment
    your tests to make catching these kinds of bugs much easier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规测试捕捉这些类型的 bug 可能很困难——通常你无法充分控制线程调度、内存布局和内容，或者其他随机系统因素来编写可靠的测试。你可以在循环中多次运行每个测试，但即便如此，如果错误的发生足够罕见或不太可能，它可能仍然不会被捕捉到。幸运的是，有一些工具可以帮助增强你的测试，使捕捉这些类型的
    bug 变得更容易。
- en: The first of these is the amazing tool *Miri*, an interpreter for Rust’s *mid-level
    intermediate representation (MIR)*. MIRis an internal, simplified representation
    of Rust that helps the compiler find optimizations and check properties without
    having to consider all of the syntax sugar of Rust itself. Running your tests
    through Miri is as simple as running `cargo miri test`. Miri *interprets* your
    code rather than compiling and running it like a normal binary, which makes the
    tests run a decent amount slower. But in return, Miri can keep track of the entire
    program state as each line of your code executes. This allows Miri to detect and
    report if your program ever exhibits certain types of undefined behavior, such
    as uninitialized memory reads, uses of values after they’ve been dropped, or out-of-bounds
    pointer accesses. Rather than having these operations yield strange program behaviors
    that may only sometimes result in observable test failures (like crashes), Miri
    detects them when they happen and tells you immediately.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个是令人惊叹的工具 *Miri*，它是 Rust 的 *中级中间表示（MIR）* 的解释器。MIR 是 Rust 的一种内部简化表示，帮助编译器在无需考虑
    Rust 本身的语法糖的情况下，找到优化并检查属性。通过 Miri 运行测试就像运行 `cargo miri test` 一样简单。Miri *解释* 你的代码，而不是像正常的二进制文件那样编译和运行，这使得测试运行的速度会慢一些。但作为回报，Miri
    可以在执行代码的每一行时跟踪整个程序的状态。这使得 Miri 能够检测并报告你的程序是否表现出某些类型的未定义行为，比如未初始化的内存读取、在变量被销毁后使用值，或者越界指针访问。与其让这些操作导致奇怪的程序行为，这些行为可能只在某些情况下才会导致可观察的测试失败（如崩溃），Miri
    能够在它们发生时检测到，并立即告诉你。
- en: For example, consider the very unsound code in [Listing 6-8](#listing6-8), which
    creates two exclusive references to a value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下 [列表 6-8](#listing6-8) 中非常不安全的代码，它创建了两个指向同一值的独占引用。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-8: Wildly unsafe code that Miri detects is incorrect'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-8：Miri 检测到的极其不安全的代码是错误的
- en: 'At the time of writing, if you run this code through Miri, you get an error
    that points out exactly what’s wrong:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，如果你通过 Miri 运行这段代码，你会遇到一个错误，错误信息会准确指出问题所在：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another tool worth looking at is *Loom*, a clever library that tries to ensure
    your tests are run with every relevant interleaving of concurrent operations.
    At a high level, Loom keeps track of all cross-thread synchronization points and
    runs your tests over and over, adjusting the order in which threads proceed from
    those synchronization points each time. So, if thread A and thread B both take
    the same `Mutex`, Loom will ensure that the test runs once with A taking it first
    and once with B taking it first. Loom also keeps track of atomic accesses, memory
    orderings, and accesses to `UnsafeCell` (which we’ll discuss in Chapter 9) and
    checks that threads do not access them inappropriately. If a test fails, Loom
    can give you an exact rundown of which threads executed in what order so you can
    determine how the crash happened.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的工具是 *Loom*，这是一个巧妙的库，旨在确保你的测试以每种相关的并发操作交替顺序运行。从高层次来看，Loom 跟踪所有线程间同步点，并反复运行你的测试，每次都调整线程从这些同步点开始执行的顺序。因此，如果线程
    A 和线程 B 都需要获取相同的 `Mutex`，Loom 会确保测试分别以 A 先获取和 B 先获取的顺序运行。Loom 还跟踪原子操作、内存顺序和对 `UnsafeCell`（我们将在第
    9 章讨论）访问，并检查线程是否不当访问这些内容。如果测试失败，Loom 会提供一个详细的报告，告诉你哪些线程按照什么顺序执行，这样你就可以确定崩溃发生的原因。
- en: Performance Testing
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: Writing performance tests is difficult because it is often hard to accurately
    model a workload that reflects real-world usage of your crate. But having such
    tests is important; if your code suddenly runs 100 times slower, that really should
    be considered a bug, yet without a performance test you may not spot the regression.
    If your code runs 100 times *faster*, that might also indicate that something
    is off. Both of these are good reasons to have automated performance tests as
    part of your CI—if performance changes drastically in either direction, you should
    know about it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编写性能测试很困难，因为通常很难准确模拟一个能够反映你 crate 的实际使用情况的工作负载。但拥有这样的测试是很重要的；如果你的代码突然变得慢了 100
    倍，这应该被视为一个 bug，然而没有性能测试的话，你可能不会发现这种回归。如果你的代码运行得快了 100 倍，这也可能意味着出了问题。这两种情况都是将自动化性能测试纳入
    CI 的充分理由——如果性能发生了大幅变化，无论是变快还是变慢，你都应该知道。
- en: Unlike with functional testing, performance tests do not have a common, well-defined
    output. A functional test will either succeed or fail, whereas a performance test
    may give you a throughput number, a latency profile, a number of processed samples,
    or any other metric that might be relevant to the application in question. Also,
    a performance test may require running a function in a loop a few hundred thousand
    times, or it might take hours running across a distributed network of multicore
    boxes. For that reason, it is difficult to speak about how to write performance
    tests in a general sense. Instead, in this section, we’ll look at some of the
    issues you may encounter when writing performance tests in Rust and how to mitigate
    them. Three particularly common pitfalls that are often overlooked are performance
    variance, compiler optimizations, and I/O overhead. Let’s explore each of these
    in turn.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能测试不同，性能测试没有一个共同的、明确定义的输出。功能测试要么通过，要么失败，而性能测试可能会给出吞吐量、延迟曲线、处理的样本数，或其他与应用程序相关的指标。此外，性能测试可能需要在循环中执行一个函数数十万次，或者可能需要几个小时才能在一个分布式的多核机器网络上运行。由于这个原因，很难在一般意义上讨论如何编写性能测试。因此，在本节中，我们将讨论编写
    Rust 性能测试时可能遇到的一些问题，并探讨如何减轻这些问题。三个常被忽视的常见陷阱是性能波动、编译器优化和 I/O 开销。让我们依次探讨这些问题。
- en: Performance Variance
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能波动
- en: Performance can vary for a huge variety of reasons, and many factors affect
    how fast a particular sequence of machine instructions run. Some are obvious,
    like the CPU and memory clock speed, or how loaded the machine otherwise is, but
    many are much more subtle. For example, your kernel version may change paging
    performance, the length of your username might change the layout of memory, and
    the temperature in the room might cause the CPU to clock down. Ultimately, it
    is highly unlikely that if you run a benchmark twice, you’ll get the same result.
    In fact, you may observe significant variance, even if you are using the same
    hardware. Or, viewed from another perspective, your code may have gotten slower
    or faster, but the effect may be invisible due to differences in the benchmarking
    environment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 性能可能由于各种原因而有所不同，许多因素会影响特定机器指令序列的运行速度。有些因素很明显，比如 CPU 和内存的时钟速度，或者机器的负载情况，但很多因素则更为微妙。例如，你的内核版本可能会改变分页性能，用户名的长度可能会改变内存布局，而房间的温度可能会导致
    CPU 降频。最终，如果你运行基准测试两次，几乎不可能得到相同的结果。事实上，即使使用相同的硬件，你也可能观察到显著的波动。或者，从另一个角度来看，你的代码可能变得更慢或更快，但由于基准测试环境的差异，这种变化可能是不可见的。
- en: There are no perfect ways to eliminate all variance in your performance results,
    unless you happen to be able to run benchmarks repeatedly on a highly diverse
    fleet of machines. Even so, it’s important to try to handle this measurement variance
    as best we can to extract a signal from the noisy measurements benchmarks give
    us. In practice, our best friend in combating variance is to run each benchmark
    many times and then look at the *distribution* of measurements rather than just
    a single one. Rust has tools that can help with this. For example, rather than
    ask “How long did this function take to run on average?” crates like `hdrhistogram`
    enable us to look at statistics like “What range of runtime covers 95% of the
    samples we observed?” To be even more rigorous, we can use techniques like null
    hypothesis testing from statistics to build some confidence that a measured difference
    indeed corresponds to a true change and is not just noise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你恰好能够在一个高度多样化的机器集群上重复运行基准测试，否则没有完美的方法可以消除性能结果中的所有波动。即便如此，尽力处理这些测量的波动以从基准测试给出的噪音数据中提取信号仍然很重要。在实践中，我们应对波动的好帮手是多次运行每个基准测试，然后查看测量结果的*分布*，而不仅仅是单一的结果。Rust
    提供了一些有助于此的工具。例如，像 `hdrhistogram` 这样的 crate 使我们能够查看诸如“95% 的样本运行时间范围是什么？”这样的统计数据，而不仅仅是询问“这个函数的平均运行时间是多少？”为了更加严谨，我们还可以使用像统计学中的零假设检验等技术，来建立一定的信心，确保一个测得的差异确实代表了一个真实的变化，而不仅仅是噪音。
- en: A lecture on statistical hypothesis testing is beyond the scope of this book,
    but luckily much of this work has already been done by others. The `criterion`
    crate, for instance, does all of this and more for you. All you have to do is
    give it a function that it can call to run one iteration of your benchmark, and
    it will run it the appropriate number of times to be fairly sure that the result
    is reliable. It then produces a benchmark report, which includes a summary of
    the results, analysis of outliers, and even graphical representations of trends
    over time. Of course, it can’t eliminate the effects of just testing on a particular
    configuration of hardware, but it at least categorizes the noise that is measurable
    across executions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 统计假设检验的讲解超出了本书的范围，但幸运的是，这项工作中的大部分已经由其他人完成。例如，`criterion` crate 就可以为你完成所有这些工作，并且更多。你所需要做的就是提供一个函数，供它调用以运行基准测试的一次迭代，然后它会运行适当次数，以确保结果可靠。它随后会生成基准测试报告，其中包括结果摘要、异常值分析，甚至是随时间变化的趋势图表。当然，它不能消除仅在特定硬件配置上测试的影响，但至少它会对在多次执行中可以测量到的噪音进行分类。
- en: Compiler Optimizations
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译器优化
- en: Compilers these days are really clever. They eliminate dead code, compute complex
    expressions at compile time, unroll loops, and perform other dark magic to squeeze
    every drop of performance out of our code. Normally this is great, but when we’re
    trying to measure how fast a particular piece of code is, the compiler’s smartness
    can give us invalid results. For example, take the code to benchmark `Vec::push`
    in [Listing 6-9](#listing6-9).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的编译器非常聪明。它们会消除死代码，在编译时计算复杂表达式，展开循环，并执行其他黑魔法，以挤出代码的每一滴性能。通常这很棒，但当我们试图衡量某段代码的执行速度时，编译器的聪明才智可能会给我们带来无效的结果。例如，考虑在[清单
    6-9](#listing6-9)中基准测试 `Vec::push` 的代码。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-9: A suspiciously fast performance benchmark'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-9：一个可疑的快速性能基准
- en: 'If you were to look at the assembly output of this code compiled in release
    mode using something like the excellent *godbolt.org* or `cargo-asm`, you’d immediately
    notice that something was wrong: the calls to `Vec::with_capacity` and `Vec::push`,
    and indeed the whole `for` loop, are nowhere to be seen. They have been optimized
    out completely. The compiler realized that nothing in the code actually required
    the vector operations to be performed and eliminated them as dead code. Of course,
    the compiler is completely within its rights to do so, but for benchmarking purposes,
    this is not particularly helpful.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看使用类似于优秀的*godbolt.org*或`cargo-asm`在发布模式下编译的代码的汇编输出，你会立即注意到有些问题：`Vec::with_capacity`和`Vec::push`的调用，甚至整个`for`循环，都完全消失了。它们已经被完全优化掉了。编译器意识到代码中实际上没有任何地方需要执行向量操作，因此将它们作为死代码剔除了。当然，编译器完全有权这样做，但对于基准测试来说，这并没有什么帮助。
- en: To avoid these kinds of optimizations for benchmarking, the standard library
    provides `std::hint::black_box`. This function has been the topic of much debate
    and confusion and is still pending stabilization at the time of writing, but is
    so useful it’s worth discussing here nonetheless. At its core, it’s simply an
    identity function (one that takes `x` and returns `x`) that tells the compiler
    to assume that the argument to the function is used in arbitrary (legal) ways.
    It does not prevent the compiler from applying optimizations to the input argument,
    nor does it prevent the compiler from optimizing how the return value is used.
    Instead, it encourages the compiler to actually compute the argument to the function
    (under the assumption that it will be used) and to store that result somewhere
    accessible to the CPU such that `black_box` could be called with the computed
    value. The compiler is free to, say, compute the input argument at compile time,
    but it should still inject the result into the program.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种基准测试优化，标准库提供了`std::hint::black_box`。这个函数曾引发过很多争论和困惑，并且在撰写本文时仍待稳定化，但它非常有用，值得在这里讨论。它的核心实际上是一个恒等函数（即接受`x`并返回`x`），它告诉编译器假设该函数的参数以任意（合法的）方式被使用。它并不会阻止编译器对输入参数应用优化，也不会阻止编译器优化返回值的使用方式。相反，它鼓励编译器实际计算函数的参数（假设该参数会被使用），并将结果存储在某个CPU可以访问的地方，以便`black_box`可以用计算出的值调用。编译器可以自由地在编译时计算输入参数，但它仍应将结果注入程序中。
- en: This function is all we need for many, though admittedly not all, of our benchmarking
    needs. For example, we can annotate [Listing 6-9](#listing6-9) so that the vector
    accesses are no longer optimized out, as shown in [Listing 6-10](#listing6-10).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就是我们在很多基准测试需求中所需要的，尽管并非所有的需求都能用它来解决。例如，我们可以对[列表6-9](#listing6-9)进行标注，以便不再让向量访问被优化掉，如[列表6-10](#listing6-10)所示。
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-10: A corrected version of [Listing 6-9](#listing6-9)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-10：[列表6-9](#listing6-9)的修正版本
- en: We’ve told the compiler to assume that `vs` is used in arbitrary ways on each
    iteration of the loop, both before and after the calls to `push`. This forces
    the compiler to perform each `push` in order, without merging or otherwise optimizing
    consecutive calls, since it has to assume that “arbitrary stuff that cannot be
    optimized out” (that’s the `black_box` part) may happen to `vs` between each call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉编译器假设`vs`在每次循环迭代中以任意方式被使用，无论是在调用`push`之前还是之后。这迫使编译器按顺序执行每个`push`，而不合并或以其他方式优化连续的调用，因为它必须假设在每次调用之间，`vs`可能会发生“无法优化掉的任意操作”（这就是`black_box`部分的作用）。
- en: Note that we used `vs.as_ptr()` and not, say, `&vs`. That’s because of the caveat
    that the compiler should assume `black_box` can perform any *legal* operation
    on its argument. It is not legal to mutate the `Vec` through a shared reference,
    so if we used `black_box(&vs)`, the compiler might notice that `vs` will not change
    between iterations of the loop and implement optimizations based on that observation!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`vs.as_ptr()`而不是`&vs`。这是因为编译器应该假设`black_box`可以对其参数执行任何*合法*的操作。通过共享引用修改`Vec`是不合法的，因此如果我们使用`black_box(&vs)`，编译器可能会注意到`vs`在循环的每次迭代之间不会发生变化，从而根据这一观察实施优化！
- en: I/O Overhead Measurement
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: I/O开销测量
- en: 'When writing benchmarks, it’s easy to accidentally measure the wrong thing.
    For example, we often want to get information in real time about how far along
    the benchmark is. To do that, we might write code like that in [Listing 6-11](#listing6-11),
    intended to measure how fast `my_function` runs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 编写基准测试时，容易不小心测量到错误的东西。例如，我们通常希望实时了解基准测试进行到什么阶段。为了做到这一点，我们可能会编写像[列表 6-11](#listing6-11)那样的代码，旨在衡量`my_function`的运行速度：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-11: What are we really benchmarking here?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-11：我们到底在基准测试什么？
- en: 'This may look like it achieves the goal, but in reality, it does not actually
    measure how fast `my_function` is. Instead, this loop is most likely to tell us
    how long it takes to print a million numbers. The `println!` in the body of the
    loop does a lot of work behind the scenes: it turns a binary integer into decimal
    digits for printing, locks standard output, writes out a sequence of UTF-8 code
    points using at least one system call, and then releases the standard output lock.
    Not only that, but the system call might block if your terminal is slow to print
    out the input it receives. That’s a lot of cycles! And the time it takes to call
    `my_function` might pale in comparison.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎达到了目标，但实际上它并没有真正衡量`my_function`的执行速度。相反，这个循环更有可能告诉我们打印一百万个数字需要多长时间。循环体中的`println!`在幕后做了大量的工作：它将二进制整数转换为十进制数字以便打印，锁定标准输出，使用至少一个系统调用写出一系列UTF-8码点，然后释放标准输出锁。不仅如此，如果你的终端打印输入的速度很慢，系统调用可能会被阻塞。这消耗了很多计算周期！而调用`my_function`所需的时间可能与之相比微不足道。
- en: A similar thing happens when your benchmark uses random numbers. If you run
    `my_function(rand::random())` in a loop, you may well be mostly measuring the
    time it takes to generate a million random numbers. The story is the same for
    getting the current time, reading a configuration file, or starting a new thread—these
    things all take a long time, relatively speaking, and may end up overshadowing
    the time you actually wanted to measure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的基准测试使用随机数时，会发生类似的情况。如果你在循环中运行`my_function(rand::random())`，你很可能主要在测量生成一百万个随机数的时间。获取当前时间、读取配置文件或启动新线程的情况也是如此——这些事情相对来说都花费很长时间，可能最终会掩盖你实际上想要测量的时间。
- en: Luckily, this particular issue is often easy to work around once you are aware
    of it. Make sure that the body of your benchmarking loop contains almost nothing
    but the particular code you want to measure. All other code should run either
    before the benchmark begins or outside of the measured part of the benchmark.
    If you’re using `criterion`, take a look at the different timing loops it provides—they’re
    all there to cater to benchmarking cases that require different measurement strategies!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一旦你意识到这个问题，通常很容易找到解决方法。确保基准测试循环体内几乎只有你想要测量的代码。所有其他代码应在基准测试开始之前或基准测试的测量部分之外运行。如果你使用`criterion`，可以查看它提供的不同计时循环——它们都旨在适应需要不同测量策略的基准测试案例！
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the built-in testing capabilities that Rust offers
    in great detail. We also looked at a number of testing facilities and techniques
    that are useful when testing Rust code. This is the last chapter that focuses
    on higher-level aspects of intermediate Rust use in this book. Starting with the
    next chapter on declarative and procedural macros, we will be focusing much more
    on Rust code. See you on the next page!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了Rust所提供的内置测试功能。我们还介绍了许多在测试Rust代码时有用的测试工具和技巧。本章是本书中专注于中级Rust使用的最后一章。从下一章关于声明式和过程宏开始，我们将更多关注Rust代码。下页见！
