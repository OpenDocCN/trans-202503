- en: Chapter 5. Pushing the Envelope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll find techniques that you usually won’t need but can,
    from time to time, be very useful. For example, sometimes it’s useful to extend
    GNU `make`’s language by creating new functions in C or even Guile. This chapter
    shows how to do that and more.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GNU `make` has no built-in arithmetic capability. But it is possible to create
    functions for addition, subtraction, multiplication, and division of integers.
    You can also create functions for integer comparisons, such as greater than or
    not equal. These functions are implemented entirely using GNU `make`’s built-in
    list and string manipulation functions: `$(subst)`, `$(filter)`, `$(filter-out)`,
    `$(words)`, `$(wordlist)`, `$(call)`, `$(foreach)`, and `$(if)`. After we define
    our arithmetic functions, we’ll implement a simple calculator in GNU `make`.'
  prefs: []
  type: TYPE_NORMAL
- en: To create an arithmetic library, we first need a representation of numbers.
    A simple way to represent a number is with a list containing that number of items.
    For example, for the arithmetic library, a number is a list of letter `x`s. So
    the number 5 is represented by `x x x x x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this representation, we can use the `$(words)` function to convert from
    the internal form (all `x`s) to a human-readable form. For example, the following
    will output 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a user-defined function `decode` to translate from the `x` representation
    to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `decode` in a makefile, we need to use the GNU `make` function `$(call)`,
    which can call a user-defined function with a set of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The arguments will be stored in temporary variables called `$1`, `$2`, `$3`,
    and so on. In `decode`, which takes one argument—the number to decode—we just
    use `$1`.
  prefs: []
  type: TYPE_NORMAL
- en: Addition and Subtraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a representation, we can define functions for addition, increment
    (by 1), and decrement (by 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plus` function makes a list of its two arguments; concatenation is enough
    to implement addition with the `x` representation. The `increment` function adds
    a single `x` to its argument. `decrement` strips the first `x` off its argument
    by asking for the entire string of `x`s starting from index 2\. For example, the
    following code will output 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice the nested calls to `plus` inside a call to `decode` so that we output
    the number 11 instead of a list of 11 `x`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create another simple function, `double`, which doubles its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing subtraction is more challenging that addition. But before we do
    that, let’s implement `max` and `min` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `max` function uses two GNU `make` built-in functions: `$(join)` and `$(subst)`.
    `$(join LIST1,LIST2)` takes two lists as arguments and joins the two lists together
    by concatenating the first element of `LIST1` with the first element of `LIST2`
    and so on through the list. If one list is longer than the other, the remaining
    items are just appended.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$(subst FROM,TO,LIST)` runs through a list and substitutes elements that match
    a `FROM` pattern with the `TO` value. To see how `max` works, consider the sequence
    of events in computing `$(call max,$(five),$(six))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, `$(join)` joins the list with five `x`s with the list with six `x`s,
    resulting in a list with six elements, the first five of which are `xx.` Then,
    `$(subst)` turns the first five `xx`s into `x`s. The final result is six `x`s,
    which is the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement `min`, we use a similar trick, but we keep only the `xx`s and
    throw away the `x`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `xx`s represent where the two lists could be joined. The shorter of the
    two lists will have only `xx`s. The `$(filter PATTERN,LIST)` function runs through
    the list and removes elements that do not match the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar pattern works for subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For a moment, ignore the `$(warning)` and `$(if)` parts of the definition,
    and focus on `$(filter-out)`. `$(filter-out)` is the opposite of `$(filter)`:
    it removes elements from a list that match the pattern. For example, we can see
    that the `$(filter-out)` here implements subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this would also work if five and six were reversed, so we first
    need to check that the first argument is greater than or equal to the second.
    In the `subtract` definition, the special function `gte` (*greater than or equal*)
    returns a non-empty string if its first argument is greater than its second. We
    use `gte` to decide whether to do the subtraction or output a warning message
    using `$(warning)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gte` function is implemented using two other functions for *greater than*
    (`gt`) and *equal* (`eq`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`gte` will return a non-empty string if either `gt` or `eq` returns a non-empty
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `eq` function is a bit of a mind-bender. It works out the number of elements
    in its two arguments, treats one argument as a pattern and the other as a list,
    and uses `$(filter)` to decide whether they are the same. Here’s an example where
    they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `eq` function converts both `$(five)`s to a list of five `x`s. These are
    then both converted to the number 5 using `$(words)`. The two 5s are fed to `$(filter)`.
    Because the two arguments of `$(filter)` are the same, the result is 5 and because
    5 is not an empty string, it is interpreted as meaning *true*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what happens when they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This proceeds as for `$(call eq,$(five),$(five))` but with `$(six)` in place
    of one of the `$(five)`s. Since `$(filter 5,6)` is an empty string, the result
    is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the `$(filter)` function acts as a kind of string equality operator; the
    two strings in our case are the lengths of the two number strings. The `gt` function
    is implemented in a similar way: it returns a non-empty string if the length of
    the first number string is not equal to the maximum of the two number strings.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `gt` function works in a manner similar to `eq` (described previously) but
    uses `$(filter-out)` instead of `$(filter)`. It converts both `x`-representation
    numbers to digits but compares—using `$(filter-out)`—the first of them against
    the max of the two. When the first number is greater than the second, two different
    numbers are fed to `$(filter-out)`. Because they are different, `$(filter-out)`
    returns a non-empty string indicating true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example in which the first number is less than the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, because the `max` of the two numbers is the same as the second number
    (because it’s the largest), `$(filter-out)` is fed the same number and returns
    an empty string indicating false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can define *not-equal* (`ne`), *less-than* (`lt`), and *less-than-or-equal*
    (`lte`) operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`lte` is defined in terms of `lt` and `eq`. Because a non-empty string means
    *true*, `lte` just concatenates the values returned by `lt` and `eq`; if either
    returned true, then `lte` returns true.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication and Division
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll have a pretty powerful arithmetic package after we define just three
    more functions: `multiply`, `divide`, and `encode`. `encode` is a way to create
    a number string of `x`s from an integer; we’ll leave that for last and then implement
    our calculator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplication uses the `$(foreach VAR,LIST,DO)` function. It sets that variable
    named `VAR` to each element of `LIST` and does whatever `DO` says. So multiplication
    is easy to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`multiply` just strings together its second argument for however many `x`s
    there are in the first argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`divide` is the most complex function of the lot because it requires recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If its first argument is less than its second, division returns `0` because
    the `ELSE` part of the `$(if)` is empty (see the `,)` at the end). If division
    is possible, `divide` works by repeated subtraction of the second argument from
    the first, using the `subtract` function. Each time it subtracts, it adds an `x`
    and calls `divide` again. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, `gte` returns a non-empty string, so recursion happens. Next, `gte` returns
    an empty string, so no more recursion occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid recursion in the special case of division by 2; we define the
    `halve` function to be the opposite of `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By now you’ve seen all the functions used in `halve`. Work through an example,
    say `$(call halve,$(five))`, to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only tricky thing to do is turn a number a user enters into a string of
    `x`s. The `encode` function does this by deleting a substring of `x`s from a predefined
    list of `x`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we are limited to entering numbers up to 65536\. We can fix that by changing
    the number of `x`s in `input_int`. Once we have the number in the encoding, only
    available memory limits the size of integers we can work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Our Arithmetic Library: A Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To really show off this library, here’s an implementation of a Reverse Polish
    Notation calculator written entirely in GNU `make` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The operators and numbers are passed into GNU `make` in the `calc` variable,
    separated by commas. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, this is not what GNU `make` was designed for, but it does show the
    power of GNU `make` functions. Here’s the complete commented makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get a closer look at these techniques in [Chapter 6](ch06.html "Chapter 6. The
    GNU Make Standard Library") when you learn about the GNU Make Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Making an XML Bill of Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With standard GNU `make` output, it’s difficult to answer the question of what
    got built and why. This section presents a simple technique to get GNU `make`
    to create an XML file containing a *bill of materials (BOM)*. The BOM contains
    the names of all the files built by the makefile and is nested to show the prerequisites
    of each file.
  prefs: []
  type: TYPE_NORMAL
- en: An Example Makefile and BOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 5-1](ch05.html#simple_makefile_to_illustrate_the_bom "Example 5-1. A
    simple makefile to illustrate the BOM") shows an example makefile. We’ll look
    at its BOM and then work backward to see how the BOM JSON file was generated.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1. A simple makefile to illustrate the BOM
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `all` from `foo` and `bar.` In turn, `foo` is made from `baz`. Running
    this code in GNU `make` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the output, it’s impossible to identify the tree-ordering of the build
    or which files depend on which. In this case, the makefile is small and relatively
    easy to trace by hand; in a real makefile, hand tracing is almost impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to produce output like that shown in [Example 5-2](ch05.html#xml_document_showing_the_structure_of_th
    "Example 5-2. An XML document showing the structure of the example makefile")
    that shows what was built and why:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2. An XML document showing the structure of the example makefile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, each rule run by the makefile has a `<rule>` tag added with a `target`
    attribute giving the name of the target that the rule built. If the rule had any
    prerequisites, within the `<rule>`/`</rule>` pair a list of prerequisite rules
    would be enclosed in `<prereq>`/`</prereq>`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the structure of the makefile reflected in the nesting of the tags.
    Loading the XML document into an XML editor (or simply into a web browser) allows
    you to expand and contract the tree at will to explore the structure of the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the output shown in [Example 5-2](ch05.html#xml_document_showing_the_structure_of_th
    "Example 5-2. An XML document showing the structure of the example makefile"),
    the example makefile is modified to include a special `bom` makefile using the
    standard `include bom` method. With that included, we can generate the XML output
    by running GNU `make` using a command line, such as `make bom-all`.
  prefs: []
  type: TYPE_NORMAL
- en: '`bom-all` instructs GNU `make` to build the BOM starting with the `all` target.
    It’s as if you typed `make all`, but now an XML document will be created.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the XML document has the same name as the makefile but with `.xml`
    appended. If the example makefile was in `example.mk`, the XML document created
    would be called `example.mk.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms "Example 5-3. The
    bom makefile that creates XML BOMs") shows the contents of the `bom` makefile
    to include:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3. The `bom` makefile that creates XML BOMs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First we determine the correct name for the XML file by extracting the name
    of the makefile that included `bom` into `PARENT_MAKEFILE` ➊, appending `.xml`,
    and storing the resulting name in `bom-file` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we use a trick that’s appeared in this book a number of times: the `SHELL`
    hack. GNU `make` will expand the value of `$(SHELL)` for every rule that’s run
    in the makefile. And at the time that `$(SHELL)` is expanded, the per-rule automatic
    variables (such as `$@`) have already been set. So by modifying `SHELL`, we can
    perform some task for every rule in the makefile as it runs.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➌, we store the original value of `SHELL` in `bom-old-shell` using an immediate
    assignment (`:=`), and we then redefine `SHELL` to be the expansion of `$(bom-run)`
    and the original shell at ➍. Because `$(bom-run)` actually expands to an empty
    string, the effect is that `bom-run` is expanded for each rule in the makefile,
    but the actual shell used is unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: '`bom-run` is defined at ➐. It uses `$(eval)` to store the relationship between
    the current target being built (the `$(if)` ensures that `$@` is defined) and
    its prerequisites. For example, when `foo` is being built, a call will be made
    to `bom-run` with `$@` set to `foo` and `$^` (the list of all prerequisites) set
    to `baz`. `bom-run` will set the value of `bom-prereq-foo` to `baz`. Later, the
    values of these `bom-prereq-X` variables are used to print out the XML tree.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, we define the pattern rule that handles the `bom-%` target. Because the
    prerequisite of `bom-%` is `%`, this pattern rule has the effect of building the
    target matching the `%` and then building `bom-%`. In our example, running `make
    bom-all` matches against this pattern rule to build `all` and then run the commands
    associated with `bom-%` with `$*` set to `all`.
  prefs: []
  type: TYPE_NORMAL
- en: '`bom-%`’s commands first delete the `bom-file` and then recursively dump out
    the XML starting from `$*`. In this example, where the user did `make bom-all`,
    the `bom-%` commands call `bom-dump` with the argument `all`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define `bom-dump` at ➏. It’s fairly routine: it uses a helper function `bom-write`
    to echo fragments of XML to the `bom-file` and calls itself for each of the targets
    in the prerequisites of each target it is dumping. Prerequisites are extracted
    from the `bom-prereq-X` variables created by `bom-run`.'
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "Example 5-3. The bom makefile that creates XML BOMs") comes with a few gotchas.
    One gotcha is that the technique can end up producing enormous amounts of output.
    This is because it will print the entire tree below any target. If a target appears
    multiple times in the tree, a large tree can be repeated many times in the output.
    Even for small projects, this can make the dump time for the XML very lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a workaround, we can change the definition of `bom-dump` to just dump the
    prerequisite information once for each target. This is much faster than the approach
    in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms "Example 5-3. The
    bom makefile that creates XML BOMs") and could be processed by a script like the
    following to help understand the structure of the `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the example makefile in [Example 5-1](ch05.html#simple_makefile_to_illustrate_the_bom
    "Example 5-1. A simple makefile to illustrate the BOM"), the XML document now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Another gotcha is that if the makefile includes rules with no commands, those
    rules will cause a break in the tree outputted by the technique in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "Example 5-3. The bom makefile that creates XML BOMs"). For example, if the example
    makefile were this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'the resulting XML would not mention `baz` at all because the rule for `foo`
    doesn’t have any commands. So `SHELL` is not expanded, and the hack doesn’t work.
    Here’s the XML in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As a workaround, we can modify `foo: baz` to include a useless command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now the correct results will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced User-Defined Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. The Basics Revisited"), we looked at creating
    user-defined functions in GNU `make`. Now we’ll look inside the GNU `make` source
    code to see how we can enhance GNU `make` with our own built-in functions by writing
    some C code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the GNU `make` source code from the Free Software Foundation.
    For this section, I’m working with GNU `make` 3.81\. Things haven’t changed much
    with GNU `make` 3.82 or 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download `make-3.81.tar.gz`, and `gunzip` and `untar`, and then build GNU `make`
    using the standard `configure` and `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With that done, we are left with a working GNU `make` in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started Modifying GNU make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s handy to be able to tell which GNU `make` you’re running, so as a first
    modification let’s change the message printed out when we ask for the version
    information. Here’s the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I’m working on a Mac (that final string will change depending
    on the machine you are working with) with GNU `make` version 3.81.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change that message so it prints `(with jgc''s modifications)` after
    the version number. To do that, we need to open the file `main.c` in a text editor
    and find the function `print_version` (at line 2,922), which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `printf` in `print_version` is where the version number is printed.
    We can modify it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, and then rerun `make`. Now enter **`make -v`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We now know which version we’re working with.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Built-In Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make`’s built-in functions are defined in the file `function.c`. To begin
    understanding how this file works, take a look at the table of functions that
    GNU `make` knows about. It’s called `function_table_init[]` and is on line 2,046\.
    Because it’s quite large, I’ve removed some lines from the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line defines a single function and consists of five pieces of information:
    the name of the function, the minimum number of arguments that the function must
    have, the maximum number of arguments (specifying a maximum of zero with a non-zero
    minimum means that the function can have an unlimited number of arguments), whether
    the arguments should be expanded, and the name of the C function that actually
    performs the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s the definition of the `findstring` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`findstring` has a minimum of two arguments and a maximum of two, and the arguments
    should be expanded before calling the C function `func_findstring`. `func_findstring`
    (in `function.c` at line 819) does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The C functions that implement GNU `make` built-in functions have three arguments:
    `o` (a pointer to a buffer into which output of the function should be written),
    `argv` (the arguments of the function as a null-terminated array of strings),
    and `funcname` (a string containing the name of the function; most functions don’t
    need this, but it can be helpful if one C routine handles more than one GNU `make`
    function).'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that `func_findstring` just uses the standard C library `strstr`
    function to find the presence of its second argument (in `argv[1]`) in its first
    (in `argv[0]`).
  prefs: []
  type: TYPE_NORMAL
- en: '`func_findstring` uses a handy GNU `make` C function called `variable_buffer_
    output` (defined in `expand.c` at line 57). `variable_buffer_output` copies a
    string into the output buffer `o` of a GNU `make` function. The first argument
    should be the output buffer, the second the string to copy, and the last the amount
    of the string to copy.'
  prefs: []
  type: TYPE_NORMAL
- en: '`func_findstring` either copies all of its first argument (if the `strstr`
    was successful) or leaves `o` untouched (and hence, empty, because it is initialized
    to an empty string before `func_findstring` is called).'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have enough information to start making our own GNU `make` function.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse a String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s no easy way to reverse a string in GNU `make`, but it’s easy to write
    a C function that does and insert it into GNU `make`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll add the definition of `reverse` to the list of functions that GNU
    `make` knows about. `reverse` will have a single argument that must be expanded
    and will call a C function named `func_reverse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the entry to add to the `function_table_init[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define `func_reverse`, which reverses the string in `argv[0]` by
    swapping characters and then updates the output buffer `o`, as shown in [Example 5-4](ch05.html#defining_a_gnu_make_function_using_c
    "Example 5-4. Defining a GNU make function using C"):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4. Defining a GNU make function using C
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This function works by walking from the start and end of the string at the same
    time and swapping pairs of characters until `left` and `right` meet in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, we can write a little makefile that tries three possibilities:
    an empty string, a string with even length, and a string with odd length, all
    calling the new built-in function `reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that it works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Writing in C gives you access to the full range of C library functions; therefore,
    the GNU `make` built-in functions you can create are limited only by your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: GNU make 4.0 Loadable Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding the `reverse` function to GNU `make` was fairly complex because we had
    to modify GNU `make`’s source code. But using GNU `make` 4.0 or later, you can
    add C functions to GNU `make` without changing the source code. GNU `make` 4.0
    added a `load` directive you can use to load a shared object containing GNU `make`
    functions written in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can turn the `reverse` function from [Example 5-4](ch05.html#defining_a_gnu_make_function_using_c
    "Example 5-4. Defining a GNU make function using C") into a loadable GNU `make`
    object by saving it in a file called `reverse.c` with some small modifications.
    Here’s the complete `reverse.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `reverse` function is added to GNU `make` by the call to `gmk_add_function`
    at ➌. The function `reverse` is then available to use just like any other GNU
    `make` built-in function. The actual reversing of a string is handled by `func_reverse`,
    which calls a GNU `make` API function `gmk_alloc` to allocate space for the new
    string at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ is a special, unused variable called `plugin_is_GPL_compatible`, which
    is required in any loadable module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the new `reverse` function, you need to compile the `reverse.c` file
    into a `.so` file and load it into GNU `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `load` directive loads the `.so`, and the rule at ➍ builds the `.so` from
    the `.c` file. If the `.so` file is missing when GNU `make` encounters the `load`
    directive, GNU `make` builds it (using the rule) and then restarts, parsing the
    makefile from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once loaded, you can use `reverse` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it is not necessary to use `$(call)`. The `reverse` function is
    just like any other built-in GNU `make` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using Guile in GNU make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU `make` 4.0 introduced a big change with the `$(guile)` function. This function’s
    argument is sent to the built-in Guile language and is executed by it. (GNU Guile
    is an implementation of Scheme, which itself is Lisp.) `$(guile)`’s return value
    is the return value from the Guile code that was executed after converting to
    a type that GNU `make` recognizes. Strictly speaking, GNU `make` doesn’t have
    data types (everything is a string), although it sometimes treats strings as other
    types (for example, a string with spaces in it is treated as a list by many functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to reverse a list using `$(guile)` and the Guile function `reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this makefile will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s worth diving into ➊ to see what happens, because there are a couple of
    subtle points. The argument to `$(guile)` is first expanded by GNU `make`, so
    ➊ becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So the Guile code to be executed is `(reverse ''(liesl friedrich louisa kurt
    brigitta marta gretl))`. The GNU `make` variable `$(NAMES)` has been expanded
    into the list of names and is turned into a Guile list by wrapping it in `''(...)`.
    Because Guile has data types, you must use the correct syntax: in this case, you
    need to surround a list with parentheses and quote it with a single quote to tell
    Guile that this is a literal list (not a function invocation).'
  prefs: []
  type: TYPE_NORMAL
- en: The Guile `reverse` function reverses this list and returns the reversed list.
    GNU `make` then converts the Guile list into a GNU `make` list (a string with
    spaces in it). Finally, `$(info)` displays the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Guile is a rich language, it’s possible to create more complex functions.
    Here, for example, is a GNU `make` function called `file-exists` that uses the
    Guile `access?` function to determine whether a file exists. It returns a Boolean
    value after converting the Guile `#t`/`#f` (true/false) value returned by `access?`
    to a GNU `make` Boolean (a non-empty string for true or an empty string for false):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice the double quotes around the parameter `$1`. Guile needs to know that
    the filename is actually a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build a more complex example by using the Guile `http-get` function
    to download data from the Web inside a makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, `http-get` gets the current UTC time from a web service that returns the
    time as a string in the body of the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: The `utc-time` variable contains the current UTC time. It works by retrieving
    the time from *[http://www.timeapi.org/utc/now/](http://www.timeapi.org/utc/now/)*
    using the Guile code stored in the `get-url` variable. The Guile code in `get-url`
    uses the `http-get` function to retrieve the header and body of a web page, and
    returns just the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how you can use the GNU `make define` directive to create large blocks
    of Guile code. If the Guile code becomes unwieldy, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$(guile (load "myfunctions.scm"))`'
  prefs: []
  type: TYPE_NORMAL
- en: This is how you can store the Guile code in a file and load it.
  prefs: []
  type: TYPE_NORMAL
- en: Self-Documenting Makefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upon encountering a new makefile, many ask “What does this makefile do?” or
    “What are the important targets I need to know about?” For any sizable makefile,
    answering those questions can be difficult. In this section, I present a simple
    GNU `make` trick that you can use to make a makefile self-documenting and print
    out help automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I show you how it works, here’s a small example. This makefile has three
    targets that the creator thinks you need to know about: `all`, `clean`, and `package`.
    They’ve documented the makefile by including some extra information with each
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of the targets needing documentation, the makefile maintainer has
    added a call to a user-defined function `print-help` with two arguments: the name
    of the target and a brief description of that target. The call to `print-help`
    doesn’t interfere with the definition of the prerequisites of the rule because
    it always returns (or is expanded to) an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing `make` with this makefile outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'and typing `make help` reveals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`make` automatically prints the names of the interesting targets and includes
    an explanation of what they do, as well as the line number of the makefile where
    you can find more information about the commands for that target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting work is done by the included makefile `help-system.mak`. `help-system.mak`
    first defines the user-defined function `print-help`. `print-help` is the function
    called for each target that needs documenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`print-help` uses GNU `make`’s `$(warning)` function to output the appropriate
    message based on the two parameters passed to it. The first parameter (stored
    in `$1`) is the name of the target, and the second (in `$2`) is the help text;
    they are separated by `--`. `$(warning)` writes a message to the console and returns
    an empty string; hence, you can safely use `print-help` in the prerequisite list
    of a rule.'
  prefs: []
  type: TYPE_NORMAL
- en: '`print-help` decides whether it needs to print any message by examining the
    `need-help` variable, which will be the string `help` if the user specified `help`
    on the `make` command line, or empty if they did not. In either case, the expanded
    value of `print-help` is an empty string. `need-help` determines whether the user
    entered `help` on the command line by examining the built-in variable `MAKECMDGOALS`,
    which is a space-separated list of all the goals specified on the `make` command
    line. `need-help` filters out any goal that doesn’t match the text `help` and,
    hence, is the string `help` if `help` was in `MAKECMDGOALS` or empty otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The definition of `need-help` and `print-help` are all we need to have `make`
    print out help on each target when run with `help` on the command line. The rest
    of `help-system.mak` prints the message `Type 'make help' to get help` when the
    user simply types `make.`
  prefs: []
  type: TYPE_NORMAL
- en: 'It defines a default goal for the makefile called `help`, which will be run
    if no other goal is specified on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This rule will output nothing if the user has asked for `help` (determined by
    the `need-help` variable), but if not, it will output the message containing the
    name of the `make` program (stored in `$(MAKE)`) followed by the appropriate parameter
    to load the makefile. This last part is subtle.
  prefs: []
  type: TYPE_NORMAL
- en: If the makefile that included `help-system.mak` was simply called `Makefile`
    (or `makefile` or `GNUmakefile`), then GNU `make` would look for it automatically,
    and it’s enough to type `make help` to get help. If it was not, the actual makefile
    name needs to be specified with the `-f` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule uses a variable called `dash-f` to output the correct command line.
    `dash-f` contains nothing if one of the default makefile names was used, or it
    contains `-f` followed by the correct makefile name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`dash-f` looks at the value of a variable called `parent-makefile`, which contains
    the name of the makefile that included `help-system.mak`. If it’s not a standard
    name, `dash-f` returns the name of the parent makefile with the `-f` option.'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent-makefile` is determined by looking at the `MAKEFILE_LIST`. `MAKEFILE_LIST`
    is a list of all the makefiles read so far in order. `help-system.mak` first determines
    its own name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it gets the list of all the other makefiles included by removing `this-makefile`
    (that is, `help-system.mak`) from the `MAKEFILE_LIST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The final element of `other-makefiles` will be the parent of `help-system.mak`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `last-element` function to get the last element of a spaceseparated
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`last-element` returns the last word in a list by getting the word count using
    `$(words)` and returning the word referenced by it. Because GNU `make`’s lists
    are counted from position 1, `$(words LIST)` is the index of the last element.'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting Makefiles with print-help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documenting makefiles with `print-help` is easy. Just add the relevant `$(call
    print-help,target,description)` to the prerequisite list for each target you want
    to document. If you add the call right next to the commands that are used for
    the target, the help system not only prints help but also automatically points
    the user to the place in the makefile to look for more information.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also easy to keep the documentation up to date because the description
    of a target is actually part of the definition of the target, not in a separate
    help list.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete help-system.mak
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, here’s the full `help_system.mak` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Just `include help-system.mak` to start using this system in makefiles that
    could use documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard Library"), we’ll
    look at a helpful resource, the GMSL project. Creating GNU `make` built-in functions
    is easy, but it does cause a maintenance problem: the next time GNU `make` is
    updated, we’ll need to port our changes to the new version. If we can do what
    we need with GNU `make` built-ins without modifying the source, then makefiles
    will be more portable. The GMSL provides lots of additional functionality without
    modifying the GNU `make` source.'
  prefs: []
  type: TYPE_NORMAL
