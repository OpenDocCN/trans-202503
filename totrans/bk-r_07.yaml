- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SPECIAL VALUES, CLASSES, AND COERCION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ve now learned about numeric values, logicals, character strings, and factors,
    as well as their unique properties and applications. Now you’ll look at some special
    values in R that aren’t as well-defined. You’ll see how they might come about
    and how to handle and test for them. Then you’ll look at different data types
    in R and some general object class concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.1 Some Special Values**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many situations in R call for special values. For example, when a data set has
    missing observations or when a practically infinite number is calculated, the
    software has some unique terms that it reserves for these situations. These special
    values can be used to mark abnormal or missing values in vectors, arrays, or other
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.1.1 Infinity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 2.1](ch02.xhtml#ch02lev1sec09), I mentioned that R imposes limits
    on how extreme a number can be before the software cannot reliably represent it.
    When a number is too large for R to represent, the value is deemed to be *infinite*.
    Of course, the mathematical concept of infinity (∞) does not correspond to a specific
    number—R simply has to define an extreme cutoff point. The precise cutoff value
    varies from system to system and is governed in part by the amount of memory R
    has access to. This value is represented by the special object `Inf`, which is
    case sensitive. Because it represents a numeric value, `Inf` can be associated
    only with numeric vectors. Let’s create some objects to test it out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’ve defined an object `foo` that is a single instance of an infinite
    value. You’ve also defined a numeric vector, `bar`, with two infinite elements,
    and then raised 90,000 to a power of 100 in `baz` to produce a result R deems
    infinite.
  prefs: []
  type: TYPE_NORMAL
- en: R can also represent negative infinity, with `-Inf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates a vector with two negative-infinite values and one positive-infinite
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Though infinity does not represent any specific value, to a certain extent you
    can still perform mathematical operations on infinite values in R. For example,
    multiplying `Inf` by any negative value will result in `-Inf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you add to or multiply infinity, you also get infinity as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Zero and infinity go hand in hand when it comes to division. Any (finite) numeric
    value divided by infinity, positive or negative, will result in zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Though it isn’t mathematically defined, note that in R, any nonzero value divided
    by zero will result in infinity (positive or negative depending on the sign of
    the numerator).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, you’ll simply want to detect infinite values in a data structure. The
    functions `is.infinite` and `is.finite` take in a collection of values, typically
    a vector, and return for each element a logical value answering the question posed.
    Here’s an example using `qux` from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that these functions do not distinguish between positive or negative infinity,
    and the result of `is.finite` will always be the opposite (the negation) of the
    result of `is.infinite`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, relational operators function as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line confirms that `-Inf` is indeed treated as less than `Inf`,
    and the second line shows that `Inf` is not greater than `Inf`. The third and
    fourth lines, again using `qux`, test for equality, which is a useful way to distinguish
    between positive and negative infinity if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.1.2 NaN***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some situations, it’s impossible to express the result of a calculation using
    a number, `Inf`, or `-Inf`. These difficult-to-quantify special values are labeled
    `NaN` in R, which stands for *Not a Number*.
  prefs: []
  type: TYPE_NORMAL
- en: As with infinite values, `NaN` values are associated only with numeric observations.
    It’s possible to define or include a `NaN` value directly, but this is rarely
    the way they’re encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Typically, `NaN` is the unintended result of attempting a calculation that’s
    impossible to perform with the specified values.
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 6.1.1](ch06.xhtml#ch06lev2sec55), you saw that adding or subtracting
    from `Inf` or `-Inf` will simply result again in `Inf` or `-Inf`. However, if
    you attempt to cancel representations of infinity in any way, the result will
    be `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line won’t result in zero because positive and negative infinity
    can’t be interpreted in that numeric sense, so you get `NaN` as a result. The
    same thing happens if you attempt to divide `Inf` by itself. In addition, although
    you saw earlier that a nonzero value divided by zero will result in positive or
    negative infinity, `NaN` results when *zero* is divided by zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that any mathematical operation involving `NaN` will simply result in `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, adding 1 to “not a number” is still `NaN`. In the second
    line, you obtain `NaN` from the `(4-4)/0`, which is clearly `0/0`, so the result
    is also `NaN`. In the third line, `NaN` results from `-Inf/Inf`, so the result
    of the remaining calculation is again `NaN`. This begins to give you an idea of
    how `NaN` or infinite values might unintentionally crop up. If you have a function
    where various values are passed to a fixed calculation and you don’t take care
    to prevent, for example, `0/0` from occurring, then the code will return `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like with `Inf`, a special function (`is.nan`) is used to detect the presence
    of `NaN` values. Unlike infinite values, however, relational operators cannot
    be used with `NaN`. Here’s an example using `bar`, which was defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using the `is.nan` function on `bar` flags the two `NaN` positions as `TRUE`.
    In the second example, you use the negation operator `!` to flag the positions
    where the elements are NOT `NaN`. Using the element-wise OR, `|` (see [Section
    4.1.3](ch04.xhtml#ch04lev2sec39)), you then identify elements that are either
    `NaN` OR infinite. Finally, the last line uses `which` to convert these logical
    values into numeric index positions so that you can remove them with negative
    indexes in square brackets (see [Section 4.1.5](ch04.xhtml#ch04lev2sec41) for
    a refresher on using `which`).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details on the functionality and behavior of `NaN` and `Inf`
    in the R help file by entering `?Inf` at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the following vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Output all elements of `foo` that, when raised to a power of 75, are NOT infinite.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the elements of `foo`, excluding those that result in negative infinity
    when raised to a power of 75.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store the following 3 × 4 matrix as the object `bar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0108-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the coordinate-specific indexes of the entries of `bar` that are `NaN`
    when you raise `bar` to a power of 65 and divide by infinity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the values in `bar` that are NOT `NaN` when `bar` is raised to a power
    of 67 and infinity is added to the result. Confirm this is identical to identifying
    those values in `bar` that, when raised to a power of 67, are not equal to negative
    infinity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify those values in `bar` that are either negative infinity OR finite when
    you raise `bar` to a power of 67.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '***6.1.3 NA***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In statistical analyses, data sets often contain missing values. For example,
    someone filling out a questionnaire may not respond to a particular item, or a
    researcher may record some observations from an experiment incorrectly. Identifying
    and handling missing values is important so that you can still use the rest of
    the data. R provides a standard special term to represent missing values, `NA`,
    which reads as *Not Available*.
  prefs: []
  type: TYPE_NORMAL
- en: '`NA` entries are not the same as `NaN` entries. Whereas `NaN` is used only
    with respect to numeric operations, missing values can occur for any type of observation.
    As such, `NA`s can exist in both numeric and non-numeric settings. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The object `foo` is a character vector with entries 3 and 6 missing; `bar` is
    a factor vector of length 11 with elements 2, 3, 7, and 10 missing; and `baz`
    is a numeric matrix with row 1, columns 2 and 3, and row 3, column 3, elements
    missing. In the factor vector, note that the `NA`s are printed as `<NA>`. This
    is to differentiate between bona fide levels of the factor and the missing observations,
    to prevent `NA` from being mistakenly interpreted as one of the levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the other special values so far, you can identify `NA` elements using
    the function `is.na`. This is often useful for removing or replacing `NA` values.
    Consider the following numeric vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This vector has a total of 14 entries, including `NA`, `NaN`, and `Inf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `is.na` flags the corresponding `NA` entries in `qux` as `TRUE`.
    But this is not all—note that it also flags elements 7 and 14, which are `NaN`,
    not `NA`. Strictly speaking, `NA` and `NaN` are different entities, but numericly
    they are practically the same since there is almost nothing you can do with either
    value. Using `is.na` labels both as `TRUE`, allowing the user to remove or recode
    both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to identify `NA` and `NaN` entries separately, you can use `is.nan`
    in conjunction with logical operators. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This identifies the index positions whose elements are specifically `NaN`.
    If you want to identify `NA` entries only, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This identifies the element indexes for only the `NA` entries (by checking for
    entries where `is.na` is `TRUE` AND where `is.nan` is NOT `TRUE`).
  prefs: []
  type: TYPE_NORMAL
- en: After locating the offending elements, you could use negative indexes in square
    brackets to remove them, though R offers a more direct option. The function `na.omit`
    will take a structure and delete all `NA`s from it; `na.omit` will also apply
    to `NaN`s if the elements are numeric.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the structure passed to `na.omit` is given as the argument `object`
    and that some additional output is displayed in printing the returned object.
    These extra details are provided to inform the user that there were elements in
    the original vector that were removed (in this case, the element positions provided
    in the attribute `na.action`). Attributes will be discussed more in [Section 6.2.1](ch06.xhtml#ch06lev2sec59).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `NaN`, arithmetic calculations with `NA` result in `NA`. Using relational
    operators with either `NaN` or `NA` will also result in `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can find more details on the usage and finer technicalities of `NA` values
    by entering `?NA`.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.1.4 NULL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, you’ll look at the *null* value, written as `NULL`. This value is often
    used to explicitly define an “empty” entity, which is quite different from a “missing”
    entity specified with `NA`. An instance of `NA` clearly denotes an existing position
    that can be accessed and/or overwritten if necessary—not so for `NULL`. You can
    see an indication of this if you compare the assignment of `NA` with the assignment
    of a `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that `bar`, the `NA` object, is printed with an index position `[1]`. This
    suggests you have a vector with a single element. In contrast, you explicitly
    instructed `foo` to be empty with `NULL`. Printing this object doesn’t provide
    a position index because there is no position to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interpretation of `NULL` also applies to vectors that have other well-defined
    items. Consider the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates a vector of length 4, with the third position coded
    as `NA`. The second line creates a similar vector but using `NULL` instead of
    `NA`. The result is a vector with a length of only 3\. That’s because `NULL` cannot
    take up a position in the vector. As such, it makes no sense to assign `NULL`
    to multiple positions in a vector (or any other structure). Again, here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first line can be interpreted as “three possible slots with unrecorded observations.”
    The second line simply provides “emptiness three times,” which is interpreted
    as one single, unsubsettable, empty object.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might wonder why there is even a need for `NULL`. If something
    is empty and doesn’t exist, why define it in the first place? The answer lies
    in the need to be able to explicitly state or check whether a certain object has
    been defined. This occurs often when calling functions in R. For example, when
    a function contains optional arguments, internally the function has to check which
    of those arguments have been supplied and which are missing or empty. The `NULL`
    value is a useful and flexible tool that the author of a function can use to facilitate
    such checks. You’ll see examples of this later on in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: The `is.null` function is used to check whether something is explicitly `NULL`.
    Suppose you have a function with an optional argument named `opt.arg` and that,
    if supplied, `opt.arg` should be a character vector of length 3\. Let’s say a
    user calls this function with the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you check whether the argument was supplied using `NA`, you might call
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The position-specific nature of `NA` means that this check is element-wise and
    returns an answer for each value in `opt.arg`. This is problematic because you
    want only a single answer—is `opt.arg` empty or is it supplied? This is when `NULL`
    comes to the party.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Quite clearly `opt.arg` is not empty, and the function can proceed as necessary.
    If the argument is empty, using `NULL` over `NA` for the check is again better
    for these purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As noted earlier, filling a vector with `NULL` isn’t usual practice; it’s done
    here just for illustration. But usage of `NULL` is far from specific to this particular
    example. It’s commonly used throughout both ready-to-use and user-contributed
    functionality in R.
  prefs: []
  type: TYPE_NORMAL
- en: The empty `NULL` has an interesting effect if it’s included in arithmetic or
    relational comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rather than `NULL` as you might expect, the result is an “empty” vector of a
    type determined by the nature of the operation attempted. `NULL` typically dominates
    any arithmetic, even if it includes other special values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`NULL` also occurs naturally when examining lists and data frames. For example,
    define a new list `foo`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This list obviously doesn’t include a member called `member3`. Look at what
    happens when you try to access a member in `foo` by that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The result of `NULL` signals that a member called `member3` in `foo` doesn’t
    exist, or in R terms, is empty. Therefore, it can be filled with whatever you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The same principle applies when querying a data frame for a nonexistent column
    or variable using the dollar operator (as in [Section 5.2.2](ch05.xhtml#ch05lev2sec53)).
  prefs: []
  type: TYPE_NORMAL
- en: For more technical details on how `NULL` and `is.null` are handled by R, see
    the help file accessed by `?NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decide yourself which of the following statements are true and which are false
    and then use R to confirm:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The length of `foo` is 8.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling `which(x=is.na(x=foo))` will not result in `4` and `8`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking `is.null(x=foo)` will provide you with the locations of the two `NULL`
    values that are present.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing `is.na(x=foo[8])+4/NULL` will not result in `NA`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create and store a list containing a single member: the vector `c(7,7,NA,3,NA,1,1,5,NA)`.
    Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the member `"alpha"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that the list doesn’t have a member with the name `"beta"` using the
    appropriate logical valued function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new member called `beta`, which is the vector obtained by identifying
    the index positions of `alpha` that are `NA`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**6.2 Understanding Types, Classes, and Coercion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you’ve studied many of the fundamental features in the R language for
    representing, storing, and handling data. In this section, you’ll examine how
    to formally distinguish between different kinds of values and structures and look
    at some simple examples of conversion from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.1 Attributes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each R object you create has additional information about the nature of the
    object itself. This additional information is referred to as the object’s *attributes*.
    You’ve see a few attributes already. In [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    you identified the dimensions attribute of a matrix using `dim`. In [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    you used `levels` to get the levels attribute of a factor. It was also noted that
    `names` can get the member names of a list in [Section 5.1.2](ch05.xhtml#ch05lev2sec50),
    and in [Section 6.1.3](ch06.xhtml#ch06lev2sec57), that an attribute annotates
    the result of applying `na.omit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, you can think of attributes as either *explicit* or *implicit*.
    Explicit attributes are immediately visible to the user, while R determines implicit
    attributes internally. You can print explicit attributes for a given object with
    the `attributes` function, which takes any object and returns a named list. Consider,
    for example, the following 3 × 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, calling `attributes` returns a list with one member: `dim`. Of course,
    you can retrieve the contents of `dim` with `attributes(foo)$dim`, but if you
    know the name of an attribute, you can also use `attr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the object in as `x` and the name of the attribute as `which`.
    Recall that names are specified as character strings in R. To make things even
    more convenient, the most common attributes have their own functions (usually
    named after the attribute) to access the corresponding value. For the dimensions
    of a matrix, you’ve already seen the function `dim`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These attribute-specific functions are useful because they also allow access
    to implicit attributes, which, while still controllable by the user, are set automatically
    by the software as a matter of necessity. The `names` and `levels` functions mentioned
    earlier are also both attribute-specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit attributes are often optional; if they aren’t specified, they are
    `NULL`. For example, when building a matrix with the `matrix` function, you can
    use the optional argument `dimnames` to annotate the rows and columns with names.
    You pass `dimnames` a list made up of two members, both character vectors of the
    appropriate lengths—the first giving row names and the second giving column names.
    Let’s define the matrix `bar` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because the dimension names are attributes, the `dimnames` appear when you call
    `attributes(bar)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that `dimnames` is itself a list, nested inside the larger attributes list.
    Again, to extract the values of this attribute, you can use list member referencing,
    you can use `attr` as shown earlier, or you can use the attribute-specific function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Some attributes can be modified after an object has been created (as you saw
    already in [Section 5.1.2](ch05.xhtml#ch05lev2sec50), where you renamed members
    of a list). Here, to make `foo` match `bar` exactly, you can give `foo` some `dimnames`
    by assigning them to the attribute-specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used matrices in the discussion here, but optional attributes for other
    objects in R are treated the same way. Attributes are not restricted to built-in
    R objects, either. Objects you build yourself can be defined with their own attributes
    and attribute-specific functions. Just remember that the role of an attribute
    is typically to provide descriptive data about an object, or you could end up
    overcomplicating your object structures unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.2 Object Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An object’s *class* is one of the most useful attributes for describing an entity
    in R. Every object you create is identified, either implicitly or explicitly,
    with at least one class. R is an *object-oriented* programming language, meaning
    entities are stored as objects and have methods that act upon them. In such a
    language, class identification is formally referred to as *inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This section will focus on the most common classing structure used in R, called*
    S3\. *There is another structure,* S4*, which is essentially a more formal set
    of rules for the identification and treatment of different objects. For most practical
    intents and certainly for beginners, understanding and using S3 will be sufficient.
    You can find further details in R’s online documentation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The class of an object is explicit in situations where you have user-defined
    object structures or an object such as a factor vector or data frame where other
    attributes play an important part in the handling of the object itself—for example,
    level labels of a factor vector, or variable names in a data frame, are modifiable
    attributes that play a primary role in accessing the observations of each object.
    Elementary R objects such as vectors, matrices, and arrays, on the other hand,
    are implicitly classed, which means the class is not identified with the `attributes`
    function. Whether implicit or explicit, the class of a given object can always
    be retrieved using the attribute-specific function `class`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stand-Alone Vectors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s create some simple vectors to use as examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass any object to the `class` function, and it returns a character
    vector as output. Here are examples using the vectors just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output from using `class` on the character vector, the logical vector, and
    the factor vector simply match the kind of data that has been stored. The output
    from the number vectors is a little more intricate, however. So far, I’ve referred
    to any object with an arithmetically valid set of numbers as “numeric.” If all
    the numbers stored in a vector are whole, then R identifies the vector as `"integer"`.
    Numbers with decimal places (called *floating-point* numbers), on the other hand,
    are identified as `"numeric"`. This distinction is necessary because some tasks
    strictly require integers, not floating-point numbers. Colloquially, I’ll continue
    to refer to both types as “numeric” and in fact, the `is.numeric` function will
    return `TRUE` for both integer and floatingpoint structures, as you’ll see in
    [Section 6.2.3](ch06.xhtml#ch06lev2sec61).
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Data Structures**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned earlier, R’s classes are essentially designed to facilitate object-oriented
    programming. As such, `class` usually reports on the nature of the data *structure*,
    rather than the type of data that’s stored—it returns the data type only when
    used on stand-alone vectors. Let’s try it on some matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note from [Section 4.3.1](ch04.xhtml#ch04lev2sec46) that factors are used only
    in vector form, so `fac.vec` is not included here. Now check these matrices with
    `class`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You see that regardless of the data type, `class` reports the structure of the
    object itself—all matrices. The same is true for other object structures, like
    arrays, lists, and data frames.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Classes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Certain objects will have multiple classes. A variant on a standard form of
    an object, such as an ordered factor vector, will inherit the usual factor class
    and also contain the additional `ordered` class. Both are returned if you use
    the `class` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, `fac.vec` was identified as `"factor"` only, but the class of `ordfac.vec`
    has two components. It’s still identified as `"factor"`, but it also includes
    `"ordered"`, which identifies the variant of the `"factor"` class also present
    in the object. Here, you can think of `"ordered"` as a *subclass* of `"factor"`.
    In other words, it is a special case that inherits from, and therefore behaves
    like, a `"factor"`. For further technical details on R subclasses, I recommend
    [Chapter 9](ch09.xhtml#ch09) of *The Art of R Programming* by Matloff ([2011](ref.xhtml#ref44)).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I have focused on the* `class` *function here because it’s directly relevant
    to the object-oriented programming style exercised in this text, especially in
    [Part II](part02.xhtml#part02). There are other functions that show some of the
    complexities of R’s classing rules. For example, the function* `typeof` *reports
    the type of data contained within an object, not just for vectors but also for
    matrices and arrays. Note, however, that the terminology in the output of* `typeof`
    *doesn’t always match the output of* `class`*. See the help file* `?typeof` *for
    details on the values it returns.*'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, an object’s class is first and foremost a descriptor of the data
    structure, though for simple vectors, the `class` function reports the type of
    data stored. If the vector entries are exclusively whole numbers, then R classes
    the vector as `"integer"`, whereas `"numeric"` is used to label a vector with
    floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.3 Is-Dot Object-Checking Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Identifying the class of an object is essential for functions that operate on
    stored objects, especially those that behave differently depending on the class
    of the object. To check whether the object is a specific class or data type, you
    can use the *is-dot* functions on the object and it will return a `TRUE` or `FALSE`
    logical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is-dot functions exist for almost any sensible check you can think of. For
    example, consider once more the `num.vec1` vector from [Section 6.2.2](ch06.xhtml#ch06lev2sec60)
    and the following six checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The first, second, and sixth is-dot functions check the kind of data stored
    in the object, while the others check the structure of the object itself. The
    results are to be expected: `num.vec1` *is* an “integer” (and *is* “numeric”),
    and it *is* a “vector.” It’s not a matrix or a data frame, nor is it logical.'
  prefs: []
  type: TYPE_NORMAL
- en: Briefly, it’s worth noting that these checks use more general categories than
    the formal classes identified with `class`. Recall that `num.vec1` was identified
    solely as `"integer"` in [Section 6.2.2](ch06.xhtml#ch06lev2sec60), but using
    `is.numeric` here still returns `TRUE`. In this example, the `num.vec1` with integer
    data is generalized to be `"numeric"`. Similarly, for a data frame, an object
    of class `"data.frame"` will return `TRUE` for `is.data.frame` *and* `is.list`
    because a data frame is intuitively generalized to a list.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a difference between the object is-dot functions detailed here and functions
    such as `is.na` discussed in [Section 6.1](ch06.xhtml#ch06lev1sec21). The functions
    to check for the special values like `NA` should be thought of as a check for
    equality; they exist because it is not legal syntax to write something like `foo==NA`.
    Those functions from [Section 6.1](ch06.xhtml#ch06lev1sec21) thus operate in R’s
    element-wise fashion, whereas the object is-dot functions inspect the object *itself*,
    returning only a single logical value.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.4 As-Dot Coercion Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve seen different ways to modify an object after it’s been created—by accessing
    and overwriting elements, for example. But what about the structure of the object
    itself and the type of data contained within?
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting from one object or data type to another is referred to as *coercion*.
    Like other features of R you’ve met so far, coercion is performed either implicitly
    or explicitly. Implicit coercion occurs automatically when elements need to be
    converted to another type in order for an operation to complete. In fact, you’ve
    come across this behavior already, in [Section 4.1.4](ch04.xhtml#ch04lev2sec40),
    for example, when you used numeric values for logical values. Remember that logical
    values can be thought of as integers—one for `TRUE` and zero for `FALSE`. Implicit
    coercion of logical values to their numeric counterparts occurs in lines of code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this operation, R recognizes that you’re attempting an arithmetic calculation
    with `+`, so it expects numeric quantities. Since the logical vector is not in
    this form, the software internally coerces it to ones and zeros before completing
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another frequent example of implicit coercion is when `paste` and `cat` are
    used to glue together character strings, as explored in [Section 4.2.2](ch04.xhtml#ch04lev2sec43).
    Non-character entries are automatically coerced to strings before the concatenation
    takes place. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, the integer `34` and the logical `T` are implicitly coerced to characters
    since R knows the output of `paste` must be a string.
  prefs: []
  type: TYPE_NORMAL
- en: In other situations, coercion won’t happen automatically and must be carried
    out by the user. This explicit coercion can be achieved with the *as-dot* functions.
    Like is-dot functions, as-dot functions exist for most typical R data types and
    object classes. The previous two examples can be coerced explicitly, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Coercions are possible in most cases that “make sense.” For example, it’s easy
    to see why R is able to read something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following conversion makes no sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since there is no logical way to translate “g’day mate” into numbers, the entry
    is returned as `NA` (in this case, R has also issued a warning message). This
    means that in certain cases, multiple coercions are needed to attain the final
    result. Suppose, for example, you have the character vector `c("1","0","1","0","0")`
    and you want to coerce it to a logical-valued vector. Direct character to logical
    coercion is not possible, because even if all the character strings contained
    numbers, there is no guarantee in general that they would all be ones and zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you know that character string numbers can be converted to a numeric
    data type, and you know that ones and zeros are easily coerced to logicals. So,
    you can perform the coercion in those two steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Not all data-type coercion is entirely straightforward. Factors, for example,
    are trickier because R treats the levels as integers. In other words, regardless
    of how the levels of a given factor are actually labeled, the software will refer
    to them internally as level 1, level 2, and so on. This is clear if you try to
    coerce a factor to a numeric data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see that R has assigned the numeric representation of the factor in
    the stored order of the factor labels (alphabetic by default). Level 1 refers
    to `female`, and level 2 refers to `male`. This example is simple enough, though
    it’s important to be aware of the behavior since coercion from factors with numeric
    levels can cause confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The numeric representation of the factor `qux` is `c(1,1,2,3)`. This highlights
    again that the levels of `qux` are simply treated as level 1 (even though it has
    a label of `2`), level 2 (which has a label of `3`), and level 3 (which has a
    label of `5`).
  prefs: []
  type: TYPE_NORMAL
- en: Coercion between object classes and structures can also be useful. For example,
    you might need to store the contents of a matrix as a single vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that `as.vector` has coerced the matrix by “stacking” the columns into
    a single vector. The same column-wise deconstruction occurs for higher-dimensional
    arrays, in order of layer or block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `as.matrix` stores the array as a 12 × 1 matrix, and `as.vector`
    stores it as a single vector. Similar commonsense rules for data types apply to
    coercion when working with object structures. For example, coercing the following
    list `baz` to a data frame produces an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The error occurs because the variables do not have matching lengths. But there
    is no problem with coercing the list `qux`, shown here, which has equal-length
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This stores the variables as a data set in a column-wise fashion, in the order
    that your list supplies them as members.
  prefs: []
  type: TYPE_NORMAL
- en: This discussion on object classes, data types, and coercion is not exhaustive,
    but it serves as a useful introduction to how R deals with issues surrounding
    the formal identification, description, and handling of the objects you create—issues
    that are present for most high-level languages. Once you’re more familiar with
    R, the help files (such as the one accessed by entering `?as` at the prompt) provide
    further details about object handling in the software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 6.3**'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the class of the following objects. For each object, also state whether
    the class is explicitly or implicitly defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`foo <- array(data=1:36,dim=c(3,3,4))`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bar <- as.vector(foo)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`baz <- as.character(bar)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`qux <- as.factor(baz)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`quux <- bar+c(-0.1,0.1)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For each object defined in (a), find the sum of the result of calling `is.numeric`
    and `is.integer` on it separately. For example, `is.numeric(foo)+is.integer(foo)`
    would compute the sum for (i). Turn the collection of five results into a factor
    with levels `0`, `1`, and `2`, identified by the results themselves. Compare this
    factor vector with the result of coercing it to a numeric vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'into the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the following matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0126-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coerce the matrix to a data frame.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As a data frame, coerce the second column to be logical-valued.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As a data frame, coerce the third column to be factor-valued.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Inf`, `-Inf` | Value for ±infinity | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 104](ch06.xhtml#page_104) |'
  prefs: []
  type: TYPE_TB
- en: '| `is.infinite` | Element-wise check for `Inf` | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 105](ch06.xhtml#page_105) |'
  prefs: []
  type: TYPE_TB
- en: '| `is.finite` | Element-wise check for finiteness | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 105](ch06.xhtml#page_105) |'
  prefs: []
  type: TYPE_TB
- en: '| `NaN` | Value for invalid numerics | [Section 6.1.2](ch06.xhtml#ch06lev2sec56),
    [p. 106](ch06.xhtml#page_106) |'
  prefs: []
  type: TYPE_TB
- en: '| `is.nan` | Element-wise check for `NaN` | [Section 6.1.2](ch06.xhtml#ch06lev2sec56),
    [p. 107](ch06.xhtml#page_107) |'
  prefs: []
  type: TYPE_TB
- en: '| `NA` | Value for missing observation | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 108](ch06.xhtml#page_108) |'
  prefs: []
  type: TYPE_TB
- en: '| `is.na` | Element-wise check for `NA` OR `NaN` | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 109](ch06.xhtml#page_109) |'
  prefs: []
  type: TYPE_TB
- en: '| `na.omit` | Delete all `NA`s and `NaN`s | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 110](ch06.xhtml#page_110) |'
  prefs: []
  type: TYPE_TB
- en: '| `NULL` | Value for “empty” | [Section 6.1.4](ch06.xhtml#ch06lev2sec58), [p.
    110](ch06.xhtml#page_110) |'
  prefs: []
  type: TYPE_TB
- en: '| `is.null` | Check for `NULL` | [Section 6.1.4](ch06.xhtml#ch06lev2sec58),
    [p. 111](ch06.xhtml#page_111) |'
  prefs: []
  type: TYPE_TB
- en: '| `attributes` | List explicit attributes | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 114](ch06.xhtml#page_114) |'
  prefs: []
  type: TYPE_TB
- en: '| `attr` | Obtain specific attribute | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 115](ch06.xhtml#page_115) |'
  prefs: []
  type: TYPE_TB
- en: '| `dimnames` | Get array dimension names | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 116](ch06.xhtml#page_116) |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Get object class (S3) | [Section 6.2.2](ch06.xhtml#ch06lev2sec60),
    [p. 117](ch06.xhtml#page_117) |'
  prefs: []
  type: TYPE_TB
- en: '| `is._` | Object-checking functions | [Section 6.2.3](ch06.xhtml#ch06lev2sec61),
    [p. 120](ch06.xhtml#page_120) |'
  prefs: []
  type: TYPE_TB
- en: '| `as._` | Object-coercion functions | [Section 6.2.4](ch06.xhtml#ch06lev2sec62),
    [p. 121](ch06.xhtml#page_121) |'
  prefs: []
  type: TYPE_TB
