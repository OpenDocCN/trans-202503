- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: KEEPING YOUR PROGRAMS SAFE WITH OPTIONALS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可选值保护你的程序安全
- en: '![](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: 'In this chapter, we’ll cover a very cool feature in Swift: optionals. *Optionals*
    are variables that can either have a value or no value at all. Swift is different
    from many programming languages because normal constants and variables *must*
    have a value. This makes Swift a *safe* language because it prevents your code
    from failing when a variable is expected to have a value but one hasn’t yet been
    set.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Swift 中一个非常酷的特性：可选值。*可选值* 是可以有值或没有值的变量。与许多编程语言不同，Swift 中的常量和变量*必须*有值。这使得
    Swift 成为一种*安全*的语言，因为它可以防止代码在期望一个变量有值但实际上尚未设置时出错。
- en: However, there will be times when you need to create a variable but don’t have
    a value for it yet. In these cases, you can use an optional.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要创建一个变量，但还没有给它赋值。在这种情况下，你可以使用可选值。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选值？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将可选值想象成一个盒子，这个盒子要么包含某些东西，要么是空的。例如，一个可选的 `String` 就是一个要么包含 `String` 值，要么为空的盒子。当可选值为空时，它的特殊值是
    `nil`。在 Swift 中，`nil` 表示没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift 期望它持有一个值。如果你不确定该变量或常量应该持有什么值，可以使用可选值来避免程序中的问题。让我们来看一下怎么做！
- en: '**CREATING OPTIONALS**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选值**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选值，你需要声明一个变量或常量，并在数据类型后添加一个 `?`。`?` 告诉 Swift 你希望将该变量或常量定义为可选值。和普通变量或常量一样，可选值可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `futureTeacher` 的可选值作为例子。假设你所在学校的所有老师还没有分配到明年的班级，所以你不知道新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `futureTeacher` 的可选变量，它将存储一个 `String` 类型的值，方法是数据类型后添加一个 `?`。与之前使用的非可选变量不同，可选值不需要初始值。那部分——你猜对了——是*可选的*！在
    ➊ 处，我们没有给 `futureTeacher` 分配初始值，所以它的默认值是特殊值 `nil`，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 `futureTeacher` 声明为一个可选的 `String` 类型，它可以持有 `nil` 或一个 `String` 值。你可以像设置普通变量一样改变可选值的值，如
    ➋ 所示。如果你改变主意，想将可选值再次设置为 `nil`，你也可以这么做 ➌。请注意，你不能将普通变量设置为 `nil`！这是可选值的一个特殊特点。在 [图
    5-1](text00015.html#ch05fig1) 中，你可以看到将 `futureTeacher` 设置为 `nil` 是允许的，但将 `grade`
    设置为 `nil` 却不行。
- en: '![](Image00104.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `grade` 设置为 `nil` 的原因是，`grade` 并没有被声明为可选值，它只是一个普通的 `Int` 数据类型。只有可选值才能持有声明类型的值或
    `nil`。可选值就是这样特别。
- en: '![](Image00105.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选值设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的playground中，以查看if-let语句的实际效果：
- en: '![](Image00110.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: if-let语句检查optional类型的futureTeacher是否包含一个值。如果包含，该值将被赋给常量knownTeacher ➊，然后执行紧随其后的代码块。在这种情况下，optional类型的futureTeacher没有包含任何值，因此紧随if-let语句后的代码块不会被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选值为nil时执行某些操作，可以写一个else块，就像我们在➋处所做的那样。在这个例子中，我们告诉计算机查看futureTeacher，如果它包含一个值，计算机应该将这个值称为knownTeacher。如果futureTeacher中没有值，我们的程序将输出“我不知道明年谁将是我的老师。”
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到if-let语句中的这段代码与之前你写的那段代码很相似——它检查了futureTeacher是否为nil，在强制解包并将其值赋给knownTeacher之前？例如，像这样：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更简洁且更好的写法：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将futureTeacher更改为某个教师的名字，并重新运行这个if-let语句。你应该能看到“明年*teacher*将是我的老师。”这个句子被你输入的名字填充。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这种类型的语句叫做if-let语句，但你也可以使用if-var，并将可选值临时赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将futureTeacher中的值赋给常量knownTeacher。常量knownTeacher只存在于if-let语句的大括号内。如果你想在程序后面访问futureTeacher的值，你必须再写一个if-let语句。这就是我们所说的，使用可选值会让你多做一些工作，因为每次想使用它时都得解包一次。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包方式，当你不确定可选值是否包含值时可以使用它。如果可选值是nil，你不会收到错误，而是可以使用else语句控制发生的事情。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“怎么可能不知道某个东西是否有值呢？”在我们的例子中，很明显futureTeacher没有值，因为我们把它设置为nil。但实际上，有很多时候你无法知道一个可选值是否有值。例如，假设我们要求用户输入futureTeacher的名字。用户可能输入了名字，也可能没有。用户是不可预测的。也许他们分心了，忘记输入名字。直到*运行时*——也就是程序实际运行时，才有办法知道用户做了什么。如果我们的程序需要用户为futureTeacher设置值，那么它必须准备好处理这两种可能性（用户输入了名字或忘记了），因为在运行时这两种情况都有可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选类型**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你到目前为止看到的，可选值需要在程序访问它们所持有的数据之前进行解包。通常，每次需要使用可选值时，你都会解包它。但是也有一些罕见的情况，你可能会遇到必须是可选值并且始终有一个值的变量。在这些情况下，与其每次使用时都解包该可选值，不如将其声明为*隐式解包可选值*。这告诉计算机该变量是一个可选值，但始终会有一个值。因此，隐式解包可选值不需要每次使用时都解包；它会自动为你解包。与常规可选值通过在数据类型后加一个
    ? 创建不同，隐式解包可选值则通过在数据类型后加一个 ! 来创建。
- en: '![](Image00111.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道什么时候会使用这些隐式解包的可选值。一个常见的用法是在你编写带有故事板的应用时。当你想要将代码中的变量与故事板中的对象连接时，你会将它们声明为隐式解包可选值。在[第
    10 章](text00021.html#ch10)中，你会在创建生日追踪器应用时看到这些变量。这些变量需要是可选值（因为故事板要求如此），但它们始终会有一个值（由于它们与故事板连接，故事板会在你使用它们之前始终给它们一个值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况外，你不应频繁使用隐式解包可选值。它们不像常规可选值那样安全，使用不当可能导致程序崩溃。最好尽可能使用常规的可选值。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的运算符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在解包可选值时，有一种非常有用的特殊运算符：*nil 合并运算符*。听起来很厉害吧？不过实际上它非常简单易用，而且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符写作一对问号，位于可选值和默认值之间，例如 optionalThing ?? defaultThing。当可选值有一个值时，会像往常一样使用该值；但是当可选值为
    nil 时，nil 合并运算符将使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个使用此运算符的例子：
- en: '![](Image00112.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们创建了一个名为 specialLunch 的可选字符串变量。接下来，我们设置一个名为 myLunch 的变量，如果 specialLunch
    包含一个字符串值，就将其赋值给 myLunch；如果没有，则将默认值 defaultLunch 赋给 myLunch ➋。在 ➌，当我们打印 myLunch
    的值时，可以看到它的默认值是 "pizza"，因为 specialLunch 为 nil。当我们将 specialLunch 设置为 "牧羊人派" ➍，然后再次使用
    nil 合并运算符时，specialLunch 的值被解包并赋给 myLunch ➎。正如你所看到的，nil 合并运算符是一个快速的方式，可以在可选值存在时获取其值，或者在它为
    nil 时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了可选项这一特性，这是使Swift成为安全语言的一个重要功能。可选项强迫我们知道哪些变量可能没有值，这样我们就能在程序中避免潜在的问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](text00016.html#ch06)中，你将学习到两种集合数据类型：数组和字典。它们都非常有用，可以存储和管理一组项目。数组中的项目按顺序存储，可以通过索引号访问。字典中的项目是无序的键/值对，可以通过键来访问。
- en: KEEPING YOUR PROGRAMS SAFE WITH OPTIONALS
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可选项保证你的程序安全
- en: '![](Image00001.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: 'In this chapter, we’ll cover a very cool feature in Swift: optionals. *Optionals*
    are variables that can either have a value or no value at all. Swift is different
    from many programming languages because normal constants and variables *must*
    have a value. This makes Swift a *safe* language because it prevents your code
    from failing when a variable is expected to have a value but one hasn’t yet been
    set.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论Swift中的一个非常酷的特性：可选项。*可选项*是可以有值或没有值的变量。Swift与许多编程语言不同，因为普通的常量和变量*必须*有一个值。这使得Swift成为一个*安全*的语言，因为它避免了当一个变量预期有值但还没有设置时，代码会失败的问题。
- en: However, there will be times when you need to create a variable but don’t have
    a value for it yet. In these cases, you can use an optional.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你需要创建一个变量，但还没有为它设置值。在这种情况下，你可以使用可选项。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选项？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将可选项看作是一个盒子，它要么包含某个值，要么是空的。例如，一个可选的String就只是一个盒子，它要么包含一个String值，要么是空的。当一个可选项为空时，它的特殊值是nil。在Swift中，nil仅仅表示没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift期望它持有一个值。如果你不确定希望该变量或常量持有什么值，你可以使用可选项来避免程序中的问题。让我们看看是怎么回事！
- en: '**CREATING OPTIONALS**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选项**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选项，你需要声明一个变量或常量，并在数据类型后加上一个?。这个?告诉Swift你希望将该变量或常量定义为可选项。像普通变量或常量一样，可选项可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个名为futureTeacher的可选项为例。假设你学校的所有老师还没有被分配到明年的班级，因此你还不知道你的新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个可选变量futureTeacher，它将存储一个String类型，通过在数据类型后添加?来实现。与我们之前使用的非可选变量不同，可选变量不需要初始化值。正如你猜到的那样——*是可选的*！在➊处，我们没有为futureTeacher分配初始值，因此它的默认值是特殊值nil，表示它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 futureTeacher 声明为一个 optional String，它可以保存 null（nil）或 String。你可以像设置常规变量那样改变一个
    optional 的值，如 ➋ 所示。如果你改变主意并希望再次将 optional 设置为 nil，你可以在 ➌ 处这么做。请注意，你不能将常规变量设置为
    nil！这是 optionals 的一个特殊特性。在 [图 5-1](text00015.html#ch05fig1) 中，你可以看到将 futureTeacher
    设置为 nil 是允许的，但将 grade 设置为 nil 是不允许的。
- en: '![](Image00104.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 grade 设置为 nil 的原因是 grade 并没有被声明为 optional，它只是一个常规的 Int 数据类型。只有 optionals
    可以存储声明类型的值或 nil。Optionals 就是这样特殊。
- en: '![](Image00105.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非 optional 设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包 Optionals**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Optionals 使你的代码更安全，因为它们迫使你为没有值的情况进行预先规划。但这也意味着它们需要更多的工作来使用。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用常规的 String 一样使用 optional String 。首先，你需要检查你的 optional 中是否真的存储了一个 String。如果有，那么你就可以像使用其他
    String 一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的 optional 是否有可以使用的值，你需要*解包*它。解包 optional 就像把它从盒子里拿出来一样。你不会在不拆开盒子的情况下玩生日礼物，对吧？同样，你也不能在不解包
    optional 的情况下在代码中使用它。有几种不同的解包方式，让我们看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解包 optional 的一种方式是通过 *强制解包*。当你知道一个 optional 有值，并且希望计算机直接访问该值时，可以使用强制解包。你可以在
    optional 名称后加上一个 ! 来实现这一点。将这段代码输入到你的 Playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 futureTeacher 设置为 "Mr.Gale"。如果我们尝试将 optional String 变量 futureTeacher
    插入到 print 语句中 ➊，打印的值是 Optional("Mr.Gale")。这不是我们想要的！我们只希望看到字符串 "Mr.Gale"。要获得这个，你需要解包该
    optional。在 ➋ 处，我们通过 futureTeacher! 强制解包 futureTeacher。现在打印的行 "Next year I know
    my teacher will be Mr.Gale.\n" 看起来如预期。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制解包时，必须确保该 optional 有值。如果它是 nil，你会得到一个错误。为了亲自验证这一点，将 futureTeacher 设置为
    nil，而不是 "Mr.Gale"，如 [图 5-2](text00015.html#ch05fig2) 所示。如果你强制解包一个 optional 且它的值是
    nil，你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：强制解包没有值的 optional 会导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应谨慎使用，只有在你能回答“我是否知道这个可选值在此代码点上始终有值？”这个问题时，才应使用。你可以先检查可选值是否为 nil，再尝试解包，这是强制解包的一种安全方式：
- en: '![](Image00109.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们检查 futureTeacher 是否有值，然后再强制解包。如果 futureTeacher 不等于 nil，我们将强制解包并将其值存储在常量
    knownTeacher ➋ 中。如果 futureTeacher 是 nil，我们会通过 ➌ 处的 else 语句输出 "I do not know who
    will be my teacher next year."。
- en: '**Optional Binding**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值的另一种方法是使用 *可选绑定*。可选绑定通过临时将可选值绑定到常量或变量，然后提供一个代码块，只有当可选值确实有值时，这个代码块才会执行。我们通过
    if-let 语句来实现这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码添加到你的 playground 中，看看 if-let 语句如何工作：
- en: '![](Image00110.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: if-let 语句检查可选值 futureTeacher 是否包含值。如果它包含值，那个值将被赋给常量 knownTeacher ➊，然后执行大括号内的代码块。在这种情况下，可选值
    futureTeacher 没有值，因此 if-let 语句后的代码块不会被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选值为 nil 时执行某些操作，你可以写一个 else 块，像我们在 ➋ 处那样。在这个例子中，我们告诉计算机检查 futureTeacher，如果它包含值，计算机应该将该值称为
    knownTeacher。如果 futureTeacher 没有值，我们的程序将输出 "I do not know who will be my teacher
    next year."
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到 if-let 语句中的代码块与你之前写的检查 futureTeacher 是否为 nil 并强制解包赋值给 knownTeacher 的代码块之间的相似性？例如，这样：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好且更简洁的写法：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 futureTeacher 改为某个教师的名字，然后再次运行这个 if-let 语句。你应该能看到 "Next year *teacher* will
    be my teacher." 这句话被你输入的名字所替代。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然这种语句被称为 if-let 语句，但你也可以使用 if-var，临时将可选值赋给变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将 futureTeacher 的值赋给常量 knownTeacher。常量 knownTeacher 仅存在于 if-let
    语句的大括号内。如果你想在程序的其他部分访问 futureTeacher 的值，你需要写另一个 if-let 语句。这就是我们所说的，使用可选值需要更多的工作，因为每次你想使用它时都需要解包。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包方式，当你不确定可选值是否包含值时使用。如果可选值为nil，你不会遇到错误，反而可以通过else语句控制发生什么。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：“怎么可能不知道某个值是否有值？”在我们的示例中，很明显`futureTeacher`没有值，因为我们将它设置为nil。但有很多时候你无法知道一个可选值是否有值。例如，假设我们要求用户为`futureTeacher`输入一个名字。用户可能输入了名字，也可能没有。用户的行为是不可预测的。也许他们被分心了，忘记输入名字。直到*运行时*——也就是程序实际运行时——你才有办法知道用户在做什么。如果我们的程序需要用户为`futureTeacher`设置值，那么它必须准备好处理这两种可能性（无论用户是否输入了名字），因为在运行时这两种情况都有可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包的可选值**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你到目前为止看到的，使用可选值时需要解包才能访问它们所包含的数据。通常每次使用可选值时，你都会解包它。但是也有一些少见的情况，你需要一个变量，它必须是可选的，并且总会有一个值。在这些情况下，你可以声明它为*隐式解包的可选值*，而不是每次使用它时都解包。这告诉计算机，这个变量是可选的，但总会有一个值。因此，隐式解包的可选值*不*需要每次使用时解包；它会自动为你解包。与普通的可选值不同，隐式解包的可选值在数据类型后加上!。
- en: '![](Image00111.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，什么时候会使用隐式解包的可选值。一个常见的用法是在你编写带有故事板的应用时。当你想要将代码中的变量与故事板中的对象连接时，你需要将它们设置为隐式解包的可选值。在你创建生日追踪器应用的[第10章](text00021.html#ch10)中，你会看到这些变量的用法。这些变量需要是可选的（因为故事板要求这样），但它们总会有一个值（因为它们连接到故事板，故事板会在你使用它们之前给它们赋值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况，通常不应该频繁使用隐式解包的可选值。它们不像普通的可选值那样安全，如果使用不当，可能导致程序崩溃。最好尽可能使用普通的可选值。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的操作符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的操作符，在你解包可选值时非常有用：*空合并操作符*。听起来很厉害，对吧？其实它很容易使用，且能节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符写作一对问号，位于可选值和默认值之间，像这样：optionalThing ?? defaultThing。当可选值有值时，将按常规使用该值；但是当可选值为nil时，空合并运算符将使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个运算符试个例子：
- en: '![](Image00112.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们创建了一个名为specialLunch的可选String变量。接下来，我们将变量myLunch的值设置为specialLunch的值（如果它包含String）或者defaultLunch的值（如果没有）➋。在➌，当我们打印myLunch的值时，可以看到它是默认值"pizza"，因为specialLunch是nil。当我们将specialLunch设置为"牧羊人馅饼"➍，然后再次使用空合并运算符时，specialLunch的值会被解包并放入myLunch中➎。正如你所看到的，空合并运算符是一种快速的方法，可以在可选值有值时获取该值，或者在其为nil时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了可选值，这是使Swift成为安全语言的一个重要特性。可选值强制我们了解哪些变量可能没有值，从而防止程序中潜在的问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00016.html#ch06)，你将学习两种集合数据类型：数组和字典。它们都非常适合用于存储和管理物品集合。数组中的项目按顺序存储，可以通过索引访问；字典中的项目则按无序的键/值对存储，可以通过键来访问。
- en: '![](Image00001.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: 'In this chapter, we’ll cover a very cool feature in Swift: optionals. *Optionals*
    are variables that can either have a value or no value at all. Swift is different
    from many programming languages because normal constants and variables *must*
    have a value. This makes Swift a *safe* language because it prevents your code
    from failing when a variable is expected to have a value but one hasn’t yet been
    set.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Swift中的一个非常酷的特性：可选值。*可选值*是可以有值也可以没有值的变量。与许多编程语言不同，Swift中的常量和变量*必须*有值。这使得Swift成为一种*安全*的语言，因为它可以防止你的代码在期望一个变量有值但该值尚未设置时失败。
- en: However, there will be times when you need to create a variable but don’t have
    a value for it yet. In these cases, you can use an optional.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你需要创建一个变量，但还没有它的值。在这种情况下，你可以使用可选值。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选值？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把可选值想象成一个盒子，它要么包含某物，要么为空。例如，一个可选String就是一个要么包含String，要么为空的盒子。当一个可选值为空时，它的特殊值为nil。在Swift中，nil意味着没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift期望它持有一个值。如果你不确定想要让这个变量或常量持有什么值，你可以使用可选值来避免程序中的问题。让我们看看如何操作！
- en: '**CREATING OPTIONALS**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选值**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选值，你需要声明一个变量或常量，并在数据类型后面加上一个?。这个?让Swift知道你想将该变量或常量定义为可选值。像变量或常量一样，可选值可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `futureTeacher` 的可选值作为示例。假设并非所有的老师都已经分配到下学年的班级，所以你不知道你的新老师会是谁。
- en: '![](Image00103.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个可选变量 `futureTeacher`，它将存储一个字符串，通过在数据类型后添加 `?` 来实现。与我们之前使用的非可选变量不同，可选变量不需要初始值。没错，这部分是*可选*的！在
    ➊ 处，我们没有给 `futureTeacher` 赋初值，所以它的默认值是特殊值 nil，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了 `futureTeacher` 是一个可选的字符串，它可以存储一个值，也可以是没有值（nil）。你可以像设置普通变量的值一样设置可选值的值，如
    ➋ 所示。如果你改变主意并想将可选值重新设为 nil，你也可以这么做 ➌ 。注意，你不能将普通变量设为 nil！这是可选值的一个特殊特性。在 [图 5-1](text00015.html#ch05fig1)
    中，你可以看到将 `futureTeacher` 设置为 nil 是允许的，但将 `grade` 设置为 nil 是不允许的。
- en: '![](Image00104.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `grade` 改为 nil 的原因是因为 `grade` 没有声明为可选值，它只是一个普通的 `Int` 数据类型。只有可选值可以存储声明类型的值或者
    nil。可选值就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选值设为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值使你的代码更安全，因为它们强制你考虑没有值的情况。但这也意味着它们需要更多的工作来使用。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用普通字符串那样使用可选字符串。首先，你需要检查你的可选值是否真的存储了一个字符串。如果有，那么你就可以像使用任何其他字符串一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选值是否有一个可以使用的值，你需要*解包*它。解包一个可选值就像是把它从盒子里拿出来。你不会在不拆开生日礼物的情况下就玩它，对吧？同样，在代码中，你也不能在不解包的情况下使用一个可选值。有几种不同的方式可以解包可选值。让我们看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值的一种方式是通过*强制解包*。当你确定一个可选值有值时，使用强制解包来让计算机直接访问该值。你只需要在可选值的名称后面加上 `!`。在你的 playground
    中输入这段代码：
- en: '![](Image00107.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将futureTeacher设置为"Mr.Gale"。如果我们尝试将可选String变量futureTeacher放入打印语句中➊，其值会被打印为Optional("Mr.Gale")。这不是理想的！我们只希望打印字符串"Mr.Gale"。为了实现这一点，你需要解包这个可选值。在➋处，我们使用futureTeacher!强制解包futureTeacher。现在打印的行"Next
    year I know my teacher will be Mr.Gale.\n"符合预期。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制解包时，必须确保该可选值有值。如果它是nil，程序会报错。为了验证这一点，将futureTeacher设置为nil，而不是"Mr.Gale"，如[图5-2](text00015.html#ch05fig2)所示。如果你强制解包一个可选值且它的值为nil，程序会崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：强制解包一个没有值的可选值会导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应该谨慎使用，并且仅在你能够回答“我是否知道这个可选值在代码中的这一点总是有值？”时才使用。你可以通过先检查它是否为nil来确保可选值有值，然后再尝试解包它。这是一种安全的强制解包方式：
- en: '![](Image00109.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们检查确保futureTeacher有值，然后才进行强制解包。如果futureTeacher不等于nil，我们强制解包它并将其值存储在常量knownTeacher中➋。如果futureTeacher是nil，我们使用else语句在➌处打印“我不知道谁会是我明年的老师”。
- en: '**Optional Binding**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解包可选值的方法是使用*可选绑定*。可选绑定的工作方式是暂时将可选值绑定到常量或变量，然后提供一个代码块，仅当可选值确实有值时才会执行该代码块。我们使用if-let语句来做到这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到你的playground中，看看if-let语句是如何工作的：
- en: '![](Image00110.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: if-let语句检查可选值futureTeacher是否包含值。如果包含值，则该值会被赋给常量knownTeacher ➊，随后会执行花括号中的代码块。在这个例子中，可选值futureTeacher不包含值，因此if-let语句后的代码块没有被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选值为nil时执行某些操作，你可以写一个else语句块，正如我们在➋处所做的那样。在这个例子中，我们告诉计算机查看futureTeacher，如果它包含值，计算机应将该值称为knownTeacher。如果futureTeacher没有值，我们的程序将输出“我不知道谁会是我明年的老师。”
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到if-let语句中的代码块和你在强制解包之前检查futureTeacher是否为nil并将其值设置为knownTeacher时所写的代码块之间的相似性了吗？例如，下面这个：
- en: '[PRE4]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种更好且更简洁的写法：
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将futureTeacher改成一个教师的名字，然后重新运行这个if-let语句。你应该会看到句子“明年*教师*将是我的老师。”并填入你输入的名字。
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然这种语句被称为if-let语句，但你也可以使用if-var，并将可选值临时赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将未来教师（futureTeacher）的值赋给常量已知教师（knownTeacher）。常量knownTeacher仅在if-let语句的大括号内存在。如果你想在程序的后续部分访问futureTeacher的值，你需要再写一个if-let语句。这就是我们所说的，使用可选类型（optionals）需要你付出更多的努力，因为每次使用它时，你都需要解包这个可选值。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包可选值的方式，特别是在你不确定它们是否包含有效值的情况下。如果可选值为nil，程序不会报错，你可以使用else语句来控制发生的情况。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：“怎么可能不知道某个东西是否有值？”在我们的例子中，很明显futureTeacher没有值，因为我们将其设置为nil。但是有很多时候你并不知道一个可选值是否有值。例如，假设我们让用户输入一个futureTeacher的名字。用户可能输入了名字，也可能没有。用户的行为是不可预测的，也许他们分心了，忘记输入名字。在程序实际运行之前，你无法看到用户做了什么，也就是在*运行时*，程序正在运行时。如果我们的程序需要用户设置futureTeacher的值，那么它必须准备好处理这两种情况（用户输入了名字或忘记输入）。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选值**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你迄今为止所看到的，在程序访问可选值中的数据之前，通常需要解包可选值。通常，你每次需要使用它时都会解包。但是有一些罕见的情况，你可能会有一个必须是可选值且始终会有值的变量。在这些情况下，你可以将其声明为*隐式解包可选值*，而不必每次使用时都解包它。隐式解包可选值会告诉计算机该变量是可选的，但总是有一个值。因此，隐式解包可选值*不*需要每次使用时解包，它会自动为你解包。与常规可选值（使用数据类型后跟?）不同，隐式解包可选值是在数据类型后面加上!来创建的。
- en: '![](Image00111.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，什么时候才会使用这些隐式解包的可选值呢？一个常见的用法是在你编写一个带有故事板的应用程序时。当你想将代码中的变量与故事板中的对象连接时，你会将它们定义为隐式解包的可选值。在[第10章](text00021.html#ch10)中，当你创建生日追踪器应用程序时，你会看到这些变量。这些变量需要是可选的（因为故事板要求这样），但它们总会有值（因为它们连接到故事板，故事板会在使用前给它们赋值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况外，你通常不应该经常使用隐式解包可选值。它们不如常规可选值安全，如果使用不当可能会导致程序崩溃。最好尽可能使用常规可选值。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的运算符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的运算符，在解包可选值时非常有用：*nil 合并运算符*。听起来很酷，是不是？不过它其实很容易使用，而且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符的写法是在可选值和默认值之间使用一对问号，如optionalThing ?? defaultThing。当可选值有值时，会像往常一样使用该值；但当可选值为nil时，nil合并运算符会使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个运算符做个示例：
- en: '![](Image00112.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们创建了一个名为specialLunch的可选String变量。接下来，我们将一个名为myLunch的变量设置为specialLunch的值（如果它包含一个String）或者defaultLunch的值（如果它没有）
    ➋。在➌，当我们打印myLunch的值时，可以看到它是默认值"pizza"，因为specialLunch是nil。当我们将specialLunch设置为"牧羊人派"
    ➍，然后再次使用nil合并运算符时，specialLunch的值会被解包并放入myLunch中 ➎。如你所见，nil合并运算符是一种快速方法，可以在可选值有值时取出它的值，或者在它为nil时使用其他默认值。
- en: '![](Image00113.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了可选值，这是Swift语言中的一个很棒的特性。可选值迫使我们知道哪些变量可能没有值，这样我们就能在程序中避免潜在的问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00016.html#ch06)中，你将学习到两种集合数据类型：数组和字典。它们都非常有用，用来存储和管理项的集合。数组中的项按顺序存储，可以通过索引号访问；而字典中的项是无序的键值对，可以通过键来访问。
- en: 'In this chapter, we’ll cover a very cool feature in Swift: optionals. *Optionals*
    are variables that can either have a value or no value at all. Swift is different
    from many programming languages because normal constants and variables *must*
    have a value. This makes Swift a *safe* language because it prevents your code
    from failing when a variable is expected to have a value but one hasn’t yet been
    set.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Swift 中一个非常酷的特性：可选值。*可选值* 是可以有值或没有值的变量。Swift 与许多编程语言不同，因为普通的常量和变量
    *必须* 有一个值。这使得 Swift 成为一种 *安全* 的语言，因为它可以防止你的代码在期望变量有值时却没有值的情况。
- en: However, there will be times when you need to create a variable but don’t have
    a value for it yet. In these cases, you can use an optional.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你需要创建一个变量，但还没有为它提供值。在这种情况下，你可以使用可选值。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选值？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把可选值想象成一个盒子，这个盒子要么包含某物，要么是空的。例如，一个可选的 String 就是一个盒子，要么包含一个 String，要么是空的。当可选值为空时，它具有特殊的值
    nil。在 Swift 中，nil 只是表示没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift 期望它持有一个值。如果你不确定这个变量或常量应该持有什么值，你可以使用可选值来避免程序出现问题。让我们看看如何做到这一点！
- en: '**CREATING OPTIONALS**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选值**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选值，你只需声明一个变量或常量，并在数据类型后添加一个 ?。问号让 Swift 知道你希望将该变量或常量声明为可选值。像变量或常量一样，可选值可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 futureTeacher 为例，创建一个可选值。想象一下，学校里的所有老师还没有被分配到下一学年的班级，所以你不知道新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个可选变量 futureTeacher，它将存储一个 String 类型的值，通过在数据类型后添加一个 ?。与我们之前使用的非可选变量不同，可选值不需要初始化值。正如你猜到的那样——*这是可选的*！在
    ➊ 处，我们没有给 futureTeacher 赋初始值，因此它的默认值是特殊值 nil，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明 futureTeacher 为一个可选的 String 类型，它可以存储“没有值（nil）”或一个 String 类型的值。你可以像为普通变量设置值一样，更改可选值的值，如
    ➋ 所示。如果你改变主意，想将可选值再次设置为 nil，你可以这样做 ➌。请注意，你不能将普通变量设置为 nil！这是可选值的一个特殊特性。在 [图 5-1](text00015.html#ch05fig1)
    中，你可以看到将 futureTeacher 设置为 nil 是允许的，但将 grade 设置为 nil 是不允许的。
- en: '![](Image00104.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法将 grade 设置为 nil 的原因是因为 grade 没有被声明为可选值，它只是一个普通的 Int 数据类型。只有可选值才能存储声明类型的值或
    nil。可选值就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选值设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解开可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可选项使你的代码更安全，因为它们强制你为没有值的情况做出计划。但这也意味着它们使用起来需要更多的工作。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用常规的 String 一样使用可选的 String。首先，你需要检查是否真的有一个 String 存储在可选项中。如果有，那么你可以像使用任何其他
    String 一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选项是否有可以使用的值，你需要*解包*它。解包可选项就像是将它从盒子里拿出来。你不会不拿出生日礼物就玩它，对吧？同样，你不能在代码中使用一个可选项而不先解包它。有几种不同的方法可以解包可选项。让我们看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选项的一种方法是通过*强制解包*。当你知道可选项有一个值，并且希望计算机直接访问该值时，使用强制解包。你可以通过在可选项名称后输入一个 ! 来做到这一点。将以下代码输入到你的
    Playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 futureTeacher 设置为 "Mr.Gale"。如果我们尝试将可选的 String 变量 futureTeacher 放入
    print 语句 ➊ 中，输出的值是 Optional("Mr.Gale")。这不是理想的！我们只想要字符串 "Mr.Gale"。为了获得这个值，你需要解包该可选项。在
    ➋ 处，我们使用 futureTeacher! 强制解包 futureTeacher。现在输出的 "Next year I know my teacher
    will be Mr.Gale.\n" 看起来符合预期。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制解包时，必须确保可选项有一个值。如果它是 nil，你会得到一个错误。为了亲自验证这一点，可以将 futureTeacher 设置为 nil，而不是
    "Mr.Gale"，如 [图 5-2](text00015.html#ch05fig2) 所示。如果你强制解包一个可选项，而它的值是 nil，你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：强制解包一个没有值的可选项将导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应该谨慎使用，只有在你能回答“我知道这个可选项在此代码点上总是有值吗？”时，才应使用强制解包。你可以通过首先检查该可选项是否为 nil，来确保它有一个值。在尝试解包之前检查
    nil 是一种安全的强制解包方法：
- en: '![](Image00109.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们检查确保 futureTeacher 有值之后再强制解包它。如果 futureTeacher 不等于 nil，我们就强制解包它，并将其值存储在常量
    knownTeacher 中 ➋。如果 futureTeacher 是 nil，我们会通过 else 语句在 ➌ 处打印 "I do not know who
    will be my teacher next year."。
- en: '**Optional Binding**'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选项的另一种方法是使用*可选绑定*。可选绑定的工作原理是暂时将可选项绑定到一个常量或变量上，然后提供一个代码块，只有当可选项确实有值时，代码块才会执行。我们使用
    if-let 语句来做到这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码添加到你的 Playground 中，看看 if-let 语句如何运作：
- en: '![](Image00110.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: if-let 语句检查 optional futureTeacher 是否包含值。如果包含，值将被赋给常量 knownTeacher ➊，并且接下来的花括号内的代码块将会执行。在这个例子中，optional
    futureTeacher 没有值，因此 if-let 语句后的代码块没有被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望当可选项为 nil 时执行某些操作，那么你可以写一个 else 代码块，就像我们在 ➋ 处做的那样。在这个例子中，我们告诉计算机查看 futureTeacher，如果它包含一个值，那么计算机应该将该值称为
    knownTeacher。如果 futureTeacher 中没有值，我们的程序将输出“我不知道明年谁会是我的老师。”
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 if-let 语句中的代码块和你写的检查 futureTeacher 是否为 nil 之后强制解包并将其值赋给 knownTeacher 的代码块有相似之处吗？例如，这段代码：
- en: '[PRE6]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好且更简洁的写法：
- en: '[PRE7]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 futureTeacher 改为一个老师的名字，然后再次运行这个 if-let 语句。你应该看到句子“明年 *teacher* 将是我的老师。”被你输入的名字替换。
- en: '**NOTE**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然这种语句叫做 if-let 语句，但你也可以使用 if-var，并将可选值临时赋给变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将 futureTeacher 的值赋给了常量 knownTeacher。常量 knownTeacher 仅在 if-let
    语句的花括号内存在。如果你想在程序的其他部分访问 futureTeacher 的值，你需要再次使用 if-let 语句。这就是我们所说的，使用可选项需要更多的工作，因为每次使用它时你都必须解包它。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包方法，当你不确定它们是否包含值时。如果可选项为 nil，你不会遇到错误，而是可以使用 else 语句控制发生的事情。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：“怎么会不知道某个值是否存在？”在我们的例子中，很明显 futureTeacher 没有值，因为我们把它设置为 nil。但是很多时候你并不知道一个可选项是否有值。例如，假设我们让用户输入一个名字给
    futureTeacher。用户可能输入了名字，也可能没有。用户的行为是不可预测的，也许他们分心了，忘记输入名字。直到*运行时*——也就是程序实际运行时——我们才知道用户做了什么。如果我们的程序需要用户设置
    futureTeacher 的值，那么它必须准备好处理这两种可能性（用户输入了名字或忘记了输入），因为在运行时，两者都可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选项**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可选值在程序访问其包含的数据之前需要被解包。通常，每当你需要使用它时，都会解包一个可选值。但也有一些罕见的情况，你可能需要一个必须是可选值并且总是有值的变量。在这些情况下，与你每次使用它时都解包可选值相比，你可以将它声明为*隐式解包可选值*。这告诉计算机该变量是一个可选值，但总会有一个值。因此，隐式解包的可选值每次使用时*不需要*解包；它会自动为你解包。与常规的可选值在数据类型后加上
    `?` 来创建不同，你通过在数据类型后加上 `!` 来创建隐式解包的可选值。
- en: '![](Image00111.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，什么时候需要使用这些隐式解包的可选值呢？一个常见的用途是在编写一个包含故事板的应用程序时。当你希望将代码中的变量与故事板中的对象连接时，你会将这些变量声明为隐式解包的可选值。在你创建生日追踪器应用时，你会在[第
    10 章](text00021.html#ch10)看到这些内容。这些变量需要是可选值（因为故事板要求这样做），但它们总是有值的（因为它们与故事板连接，故事板会在你使用它们之前总是给它们一个值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况外，你不应该经常使用隐式解包的可选值。它们不像常规的可选值那样安全，如果使用不当，可能会导致程序崩溃。最好尽量使用常规的可选值。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的运算符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特别的运算符，当你解包可选值时非常有用：*nil 合并运算符*。听起来很厉害，对吧？其实它非常容易使用，而且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符是通过在可选值和默认值之间写上一对问号来表示的，例如 `optionalThing ?? defaultThing`。当可选值有值时，会像往常一样使用该值，但如果可选值为
    nil，nil 合并运算符则会使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个运算符来尝试一个例子：
- en: '![](Image00112.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 `specialLunch` 的可选字符串变量。接着，我们将一个名为 `myLunch` 的变量设置为：如果 `specialLunch`
    包含字符串，则取 `specialLunch` 的值，否则取 `defaultLunch` 作为默认值 ➋。在 ➌ 处，当我们打印 `myLunch` 的值时，可以看到它是默认值“披萨”，因为
    `specialLunch` 为 nil。当我们将 `specialLunch` 设置为“牧羊人派” ➍，并再次使用 nil 合并运算符时，`specialLunch`
    的值会被解包并赋值给 `myLunch` ➎。正如你所看到的，nil 合并运算符是一种快速方法，可以在可选值有值时获取它的值，如果没有值，则使用其他默认值。
- en: '![](Image00113.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可选项，这是Swift的一大特性，使得Swift成为一种安全的语言。可选项迫使我们知道哪些变量可能没有值，从而帮助我们避免程序中的潜在问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00016.html#ch06)中，你将学习两种集合数据类型：数组和字典。这两者在存储和管理项目集合时都非常有用。数组中的项目存储在有序的列表中，可以通过索引访问。而字典中的项目存储在无序的键/值对中，可以通过键来访问。
- en: However, there will be times when you need to create a variable but don’t have
    a value for it yet. In these cases, you can use an optional.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要创建一个变量，但还没有为其赋值。在这种情况下，你可以使用可选项。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选项？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把可选项看作一个盒子，它要么包含某物，要么是空的。例如，一个可选的String就像一个盒子，它要么包含一个String，要么是空的。当一个可选项是空的时，它的特殊值是nil。在Swift中，nil表示没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift期望它持有一个值。如果你不确定这个变量或常量应该持有什么值，你可以使用可选项来避免程序中的问题。让我们看看如何做到这一点！
- en: '**CREATING OPTIONALS**'
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选项**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选项，你需要声明一个变量或常量，并在数据类型后添加一个?。这个?让Swift知道你想将变量或常量设为可选项。像普通的变量或常量一样，可选项可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以futureTeacher为例来创建一个可选项。假设你学校的所有老师并未全部分配到下一年的课程，因此你还不知道你的新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过在数据类型后添加?来创建一个可选变量futureTeacher，它将存储一个String。与我们之前使用的非可选变量不同，可选项不要求有初始值。没错，这部分是——*可选的*！在
    ➊ ，我们没有为futureTeacher赋初始值，所以它的默认值是特殊值nil，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将futureTeacher声明为可选的String类型，它可以存储nil（表示什么都没有）或者一个String。你可以像设置常规变量一样改变可选项的值，如
    ➋ 所示。如果你改变主意，想把可选项的值设置回nil，你也可以这么做 ➌ 。请注意，你不能将常规变量设置为nil！这是可选项的一个特殊特性。在[图 5-1](text00015.html#ch05fig1)中，你可以看到将futureTeacher设置为nil是允许的，但将grade设置为nil则不允许。
- en: '![](Image00104.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将grade改为nil的原因是，grade并没有声明为可选项，它只是一个普通的Int数据类型。只有可选项可以持有声明的类型的值或nil。可选项就是如此特别。
- en: '![](Image00105.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1: 你不能将一个非可选值设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值使你的代码更安全，因为它们强制你考虑没有值的情况。但这也意味着它们的使用需要更多的工作。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用常规字符串一样使用一个可选字符串。首先，你需要检查是否真的有一个字符串存储在可选值中。如果有，你就可以像使用其他字符串一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选值是否有可以使用的值，你需要对其进行*解包*。解包一个可选值就像把它从盒子里拿出来一样。你不会在没有拿出盒子的情况下玩生日礼物，对吧？那么，你也不能在代码中使用一个可选值而不先解包它。有几种不同的方式可以解包可选值。让我们看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值的一种方式是通过*强制解包*。当你知道一个可选值有值，并且你希望计算机直接访问这个值时，可以使用强制解包。你通过在可选值名称后加一个 `!`
    来实现这一点。将此代码输入到你的 Playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `futureTeacher` 设置为 "Mr.Gale"。如果我们尝试将可选的字符串变量 `futureTeacher` 放入打印语句中
    ➊，则会打印为 Optional("Mr.Gale")。这不是理想的！我们只想要字符串 "Mr.Gale"。为了实现这一点，你需要解包可选值。在 ➋ 处，我们通过使用
    `futureTeacher!` 强制解包 `futureTeacher`。现在，打印出的 "Next year I know my teacher will
    be Mr.Gale.\n" 看起来就像预期的那样。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用强制解包时，你必须确保可选值有值。如果它是 nil，你会遇到错误。为了亲自验证这一点，将 `futureTeacher` 设置为 nil，而不是 "Mr.Gale"，如
    [图 5-2](text00015.html#ch05fig2) 所示。如果你强制解包一个可选值并且它是 nil，那么你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2: 强制解包一个没有值的可选值会导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应该谨慎使用，仅在你能回答“我是否知道这个可选值在代码的这个位置一定会有值？”时使用。你可以通过先检查它是否等于 nil 来确保一个可选值有值，这是一种安全的强制解包方式：
- en: '![](Image00109.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在强制解包之前，先检查 `futureTeacher` 是否有值。如果 `futureTeacher` 不等于 nil，我们就强制解包它并将其值存储在常量
    `knownTeacher` 中 ➋。如果 `futureTeacher` 是 nil，我们会使用 else 语句在 ➌ 处打印 "I do not know
    who will be my teacher next year."。
- en: '**Optional Binding**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值的另一种方式是使用*可选绑定*。可选绑定通过将可选值临时绑定到常量或变量上，然后提供一个代码块，该代码块仅在可选值确实包含值时运行。我们通过`if-let`语句来实现这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到你的playground中，以查看`if-let`语句的实际操作：
- en: '![](Image00110.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-let`语句检查可选值`futureTeacher`是否包含一个值。如果它有值，那个值将被赋给常量`knownTeacher` ➊，然后紧随其后的代码块将会执行。在这种情况下，可选值`futureTeacher`没有值，因此`if-let`语句后的代码块不会执行。'
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选值为`nil`时执行某些操作，你可以像我们在➋处做的那样写一个`else`块。在这个例子中，我们告诉计算机查看`futureTeacher`，如果它包含一个值，计算机应该将该值称为`knownTeacher`。如果`futureTeacher`没有值，我们的程序将输出“我不知道明年谁会是我的老师。”
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到`if-let`语句中的代码块与你编写的代码块之间的相似性？那段代码是检查`futureTeacher`是否为`nil`，然后强制解包并将其值赋给`knownTeacher`。例如，像这样：
- en: '[PRE8]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好且更简洁的写法：
- en: '[PRE9]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`futureTeacher`改为某位教师的名字，再次运行此`if-let`语句。你应该会看到句子“Next year *teacher* will
    be my teacher.”被你输入的名字填充。
- en: '**NOTE**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这种语句被称为`if-let`语句，你也可以使用`if-var`并将可选值临时赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是将`futureTeacher`中的值临时赋给常量`knownTeacher`。常量`knownTeacher`只在`if-let`语句的代码块内部存在。如果你想在程序的后续部分访问`futureTeacher`的值，你必须再写一个`if-let`语句。这就是我们所说的使用可选值时需要更多工作的原因，因为每次你想使用它时，都必须解包可选值。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包可选值的方式，当你不确定可选值是否包含一个值时使用。如果可选值为`nil`，你不会遇到错误，而是可以使用`else`语句控制发生的事情。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“怎么可能不知道某个值是否有值？”在我们的例子中，很显然futureTeacher没有值，因为我们将其设置为nil。但有很多时候，你无法知道一个可选类型是否有值。例如，假设我们让用户输入futureTeacher的名字。用户可能输入了名字，也可能没有。用户是不可预测的，或许他们因为分心而忘记输入名字。直到*运行时*——也就是程序实际运行时——你才知道用户的操作。如果我们的程序需要用户为futureTeacher设置值，那么它必须准备好处理两种可能性（用户输入了名字或忘记输入），因为在运行时，这两种情况都可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选类型**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在访问存储的数据之前，可选类型需要解包。通常每次使用可选类型时，你都会解包它。但是也有一些特殊情况，你会遇到一个必须是可选类型并且始终有值的变量。在这些情况下，与你每次使用时解包可选类型不同，你可以将其声明为*隐式解包可选类型*。这告诉计算机，变量是可选类型，但始终有值。因此，隐式解包可选类型*不需要*每次使用时解包；它会自动为你解包。你创建隐式解包可选类型时，数据类型后面跟一个!，而不是像常规可选类型那样在数据类型后面跟一个?。
- en: '![](Image00111.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，什么时候会使用这些隐式解包可选类型。一种常见的用法是在使用故事板（storyboard）编写应用程序时。当你想将代码中的变量与故事板中的对象连接时，你将这些变量声明为隐式解包可选类型。在你创建生日追踪器应用程序时，你会在[第10章](text00021.html#ch10)中看到这些变量。这些变量需要是可选类型（因为故事板要求这样），但它们始终会有一个值（因为它们与故事板连接，故事板会在你使用它们之前始终赋予它们一个值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况，你不应频繁使用隐式解包可选类型。它们不如常规可选类型安全，如果使用不当，可能会导致程序崩溃。最好尽可能使用常规可选类型。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的操作符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在解包可选类型时，有一种非常有用的操作符：*空合并操作符*。听起来很厉害吧？其实它非常简单，并且能够节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符写作可选项和默认值之间的一对问号，如 `optionalThing ?? defaultThing`。当可选项有值时，会像平常一样使用该值；但当可选项为
    nil 时，nil 合并运算符将使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个运算符的一个示例：
- en: '![](Image00112.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 `specialLunch` 的可选字符串变量。接下来，我们设置一个名为 `myLunch` 的变量，如果 `specialLunch`
    包含一个字符串，则将其值赋给 `myLunch`，否则如果没有，则使用 `defaultLunch` ➋。在 ➌ 处，当我们打印 `myLunch` 的值时，可以看到它是默认值
    "pizza"，因为 `specialLunch` 是 nil。当我们将 `specialLunch` 设置为 "牧羊人派" ➍，然后再次使用 nil 合并运算符时，`specialLunch`
    的值会被展开并赋值给 `myLunch` ➎。正如你所看到的，nil 合并运算符是一种快速的方式，可以在可选项有值时获取该值，或者在它为 nil 时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了可选项，这是一个使 Swift 成为安全语言的伟大特性。可选项迫使我们知道哪些变量可能没有值，这样我们就能避免程序中的潜在问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](text00016.html#ch06) 中，你将学习两种集合数据类型：数组和字典。它们对于存储和管理项目集合非常有用。数组中的项目按顺序存储，可以通过索引访问。字典中的项目以无序的键值对形式存储，可以通过键来访问。
- en: '**WHAT IS AN OPTIONAL?**'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是可选项？**'
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把可选项看作一个盒子，它要么包含某个东西，要么是空的。例如，一个可选的字符串就是一个要么包含一个字符串，要么为空的盒子。当一个可选项为空时，它具有特殊的值
    nil。在 Swift 中，nil 仅表示没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift 期望它持有一个值。如果你不确定该变量或常量应该持有什么值，你可以使用可选项来避免程序中的问题。让我们来看一下如何操作！
- en: '**CREATING OPTIONALS**'
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选项**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选项，你声明一个变量或常量，并在数据类型后加一个 `?`。这个 `?` 告诉 Swift 你希望将该变量或常量设置为可选项。像变量或常量一样，可选项可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `futureTeacher` 的可选项作为示例。假设你学校的所有教师还没有分配到下一年的课程，所以你不知道你的新教师会是谁。
- en: '![](Image00103.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个可选变量futureTeacher，它将存储一个String类型，通过在数据类型后加上?。与我们到目前为止使用的非可选变量不同，可选项不需要初始值。那部分是——你猜对了——*可选*的！在➊处，我们没有为futureTeacher赋初始值，所以它的默认值是特殊的值nil，意味着它目前没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明futureTeacher为一个可选的String，它可以存储空值(nil)或一个String。你可以像设置常规变量一样更改可选项的值，如➋所示。如果你改变主意并希望再次将可选项设置为nil，你也可以做到这一点➌。请注意，你不能将常规变量设置为nil！这是可选项的一个特殊特点。在[图
    5-1](text00015.html#ch05fig1)中，你可以看到将futureTeacher设置为nil是允许的，但将grade设置为nil则不行。
- en: '![](Image00104.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将grade更改为nil的原因是，grade并没有被声明为可选项，它只是一个常规的Int数据类型。只有可选项可以存储声明类型的值或nil。可选项就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选项设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选项**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可选项使你的代码更安全，因为它们迫使你为没有值的情况做出规划。但这也意味着它们在使用时需要更多的工作。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用常规String那样使用可选的String。首先，你需要检查你的可选项中是否确实存储了一个String。如果存储了，那么你可以像使用其他String一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选项是否有一个你可以使用的值，你需要*解包*它。解包一个可选项就像是把它从盒子里拿出来一样。你不会在没有把生日礼物从盒子里拿出来的情况下玩它，对吧？嗯，你也不能在没有先解包它的情况下使用一个可选项。在解包可选项时有几种不同的方法，让我们看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 解包一个可选项的一种方式是通过*强制解包*。当你知道一个可选项有值并且希望计算机直接访问这个值时，可以使用强制解包。你可以通过在可选项名称后加上!来实现。请在你的
    Playground 中输入以下代码：
- en: '![](Image00107.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将futureTeacher设置为"Mr.Gale"。如果我们尝试将可选的String变量futureTeacher放入打印语句中➊，打印出来的值是Optional("Mr.Gale")。这并不理想！我们只想要字符串"Mr.Gale"。为了得到它，你需要解包这个可选项。在➋处，我们使用futureTeacher!强制解包futureTeacher。现在打印出来的行"Next
    year I know my teacher will be Mr.Gale.\n"看起来如预期般正常。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制展开时，必须确保可选项有值。如果它是 nil ，你会遇到错误。你可以亲自验证这一点，将 futureTeacher 设置为 nil 而不是
    "Mr.Gale" ，如 [图 5-2](text00015.html#ch05fig2) 所示。如果你强制展开一个可选项并且它的值是 nil ，你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：强制展开一个没有值的可选项将导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 强制展开应该谨慎使用，只有在你能回答“我知道这个可选项在这段代码中始终有值吗？”时，才能使用它。你可以通过首先检查它是否等于 nil 来确保一个可选项有值，这是一种安全的强制展开方式：
- en: '![](Image00109.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们检查 futureTeacher 是否有值，确保在强制展开它之前不会出错。如果 futureTeacher 不等于 nil ，我们会强制展开它并将其值存储在常量
    knownTeacher 中 ➋ 。如果 futureTeacher 是 nil ，我们会使用 ➌ 的 else 语句打印出 "I do not know
    who will be my teacher next year."。
- en: '**Optional Binding**'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种展开可选项的方法是使用 *可选绑定* 。可选绑定通过临时将可选项绑定到一个常量或变量，然后提供一个仅在可选项确实有值时才会执行的代码块来工作。我们使用
    if-let 语句来实现这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码添加到你的 playground 中，查看 if-let 语句的实际效果：
- en: '![](Image00110.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: if-let 语句检查可选项 futureTeacher 是否包含一个值。如果它包含值，该值将被赋给常量 knownTeacher ➊ ，接下来的代码块将被执行。在这种情况下，futureTeacher
    不包含值，因此 if-let 语句后的代码块没有被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选项的值为 nil 时发生某些操作，你可以编写一个 else 块，像我们在 ➋ 中做的那样。在这个例子中，我们告诉计算机查看 futureTeacher
    ，如果它包含一个值，计算机应该将该值称为 knownTeacher。如果 futureTeacher 中没有值，我们的程序将输出 "I do not know
    who will be my teacher next year."。
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到 if-let 语句中的代码块和你之前编写的检查 futureTeacher 是否为 nil 并在强制展开后将其值赋给 knownTeacher
    的代码块之间的相似之处？例如，这段代码：
- en: '[PRE10]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好、更简洁的写法：
- en: '[PRE11]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 futureTeacher 更改为老师的名字，然后再次运行这个 if-let 语句。你应该能看到句子 "Next year *teacher*
    will be my teacher." 被你输入的名字填充。
- en: '**NOTE**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这种语句被称为 if-let 语句，你也可以使用 if-var，将可选项的值临时赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将futureTeacher中的值赋给常量knownTeacher。常量knownTeacher仅在if-let语句的花括号内存在。如果你想在程序的后续部分访问futureTeacher的值，你必须再次使用if-let语句。这就是我们所说的，使用可选值需要多一些操作，因为每次想使用它时都需要解包。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的解包可选值的方法，当你不确定它们是否包含值时。如果可选值为nil，程序不会报错，相反，你可以通过else语句来控制接下来的操作。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“怎么可能不知道某个值是否有值？”在我们的示例中，很明显futureTeacher没有值，因为我们将其设置为nil。但是有很多时候，你并不知道一个可选值是否有值。例如，假设我们要求用户输入futureTeacher的名字。用户可能输入了名字，也可能没有。用户的行为是不可预测的。也许他们分心了，忘记输入名字。在程序*运行时*之前，我们无法看到用户的操作——也就是说，只有当程序实际运行时，才知道用户是否输入了名字。如果我们的程序需要用户为futureTeacher设置值，那么它必须能够处理这两种情况（用户输入了名字或忘记输入），因为在运行时，这两种情况都有可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选值**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，可选值在程序访问其持有的数据之前必须解包。通常你会在每次需要使用时解包可选值。但是，也有一些特殊情况，某些变量必须是可选值并且总是会有一个值。在这些情况下，你可以将其声明为*隐式解包可选值*，而不需要每次使用时都解包。这样做告诉计算机，变量是一个可选值，但总会有一个值。因此，隐式解包可选值不需要每次使用时都解包；它会自动解包。与常规的可选值通过在数据类型后加?来创建不同，隐式解包可选值是通过在数据类型后加!来创建的。
- en: '![](Image00111.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道何时使用这些隐式解包可选值。一个常见的使用场景是你在编写带有故事板的应用程序时。当你想将代码中的变量与故事板中的对象连接时，你会将它们声明为隐式解包可选值。在[第10章](text00021.html#ch10)中，你将创建生日追踪器应用时看到这些。由于故事板要求这些变量必须是可选值，但它们总会有一个值（因为它们与故事板连接，故事板会在你使用它们之前总是给它们一个值），所以它们必须是可选值。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个特殊情况外，你不应该经常使用隐式解包的可选项。它们不如常规的可选项安全，如果使用不当，可能会导致程序崩溃。最好尽可能使用常规的可选项。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊类型的运算符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种非常有用的运算符，在解包可选项时特别有用：*nil 合并运算符*。听起来是不是很厉害？其实它很容易使用，而且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符写作一对问号，位于可选项和默认值之间，像这样：optionalThing ?? defaultThing。当可选项有值时，会按常规使用该值，但当可选项为
    nil 时，nil 合并运算符会使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个使用这个运算符的例子：
- en: '![](Image00112.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 specialLunch 的可选字符串变量。接下来，我们将名为 myLunch 的变量设置为 specialLunch
    的值（如果它包含字符串），或者如果它没有值，则设置为 defaultLunch ➋。在 ➌ 处，当我们打印 myLunch 的值时，可以看到它是默认值 "pizza"，因为
    specialLunch 为 nil。当我们将 specialLunch 设置为 "shepherd's pie" ➍ 然后再次使用 nil 合并运算符时，specialLunch
    的值被解包并放入 myLunch ➎。正如你所看到的，nil 合并运算符是一个快速的方法，既可以在可选项有值时获取其值，也可以在它为 nil 时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可选项，这是一个使 Swift 成为安全语言的伟大特性。可选项强制我们了解哪些变量可能没有值，从而可以在程序中防止任何潜在问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00016.html#ch06)中，你将学习两种集合数据类型：数组和字典。它们对于存储和管理项目集合非常有用。数组中的项目存储在有序列表中，可以通过索引号访问；字典中的项目存储在无序的键/值对中，可以通过键访问。
- en: You can think of an optional as a box that either contains something or is empty.
    For example, an optional String is just a box that either contains a String or
    is empty. When an optional is empty, it has the special value nil . In Swift,
    nil just means that there’s no value.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把可选项想象成一个盒子，盒子里面要么有东西，要么是空的。例如，一个可选的字符串就是一个盒子，要么包含一个字符串，要么是空的。当一个可选项为空时，它具有特殊值
    nil。在 Swift 中，nil 只是意味着没有值。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift 期望它保存一个值。如果你不确定该变量或常量应该保存什么值，可以使用可选项来避免程序中的问题。让我们来看一下如何操作！
- en: '**CREATING OPTIONALS**'
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选项**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选项，你声明一个变量或常量，并在数据类型后加上一个 ?。这个 ? 告诉 Swift 你希望将变量或常量设为可选项。像变量或常量一样，可选项可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `futureTeacher` 为例创建一个可选值。假设你学校的所有老师还没有被分配到下一年的班级，所以你不知道谁将成为你的新老师。
- en: '![](Image00103.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个可选变量 `futureTeacher`，它将存储一个字符串类型的值，通过在数据类型后面添加一个 ? 来表示。与我们之前使用的非可选变量不同，可选变量不要求初始化值。没错——这部分是*可选的*！在➊，我们没有给
    `futureTeacher` 赋初始值，所以它的默认值是特殊值 nil，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `futureTeacher` 声明为可选的字符串类型，它可以存储 nil 或一个字符串。你可以像设置普通变量的值一样设置可选值的值，如➋所示。如果你改变主意并想将可选值设为
    nil，你也可以这样做 ➌。请注意，你不能将普通变量设置为 nil！这是可选值的一个特殊特性。在[图 5-1](text00015.html#ch05fig1)中，你可以看到设置
    `futureTeacher` 为 nil 是允许的，但将 `grade` 设置为 nil 是不允许的。
- en: '![](Image00104.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `grade` 改为 nil 的原因是，`grade` 不是被声明为可选类型，它只是一个普通的 Int 数据类型。只有可选类型可以存储声明类型的值或
    nil。可选值就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选值设为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值让你的代码更加安全，因为它们强制你考虑没有值的情况。但这也意味着使用它们需要多一点工作。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用普通的字符串那样使用可选字符串。首先，你需要检查可选值中是否真的存储了一个字符串。如果有，那么你可以像使用其他字符串一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选值是否有可用的值，你需要*解包*它。解包可选值就像是将它从盒子里拿出来。你不会在没有打开盒子的情况下玩生日礼物，对吧？同样，你也不能在没有解包的情况下使用代码中的可选值。解包可选值有几种不同的方法。我们来看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 解包一个可选值的一个方法是通过*强制解包*。当你知道一个可选值有值，并且你想让计算机直接访问这个值时，可以使用强制解包。你通过在可选值的名字后面加一个
    ! 来实现。将这段代码输入到你的 playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将futureTeacher设置为"Mr.Gale"。如果我们试图将可选的字符串变量futureTeacher放入打印语句中 ➊，则打印出的值是Optional("Mr.Gale")。这并不理想！我们只想要字符串"Mr.Gale"。为了得到这个值，你需要解包可选项。在
    ➋ 处，我们使用futureTeacher!强制解包了futureTeacher。现在打印出的行"Next year I know my teacher will
    be Mr.Gale.\n"看起来符合预期。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制解包时，必须确保该可选项有值。如果它是nil，你将得到一个错误。要亲自验证这一点，请将futureTeacher设置为nil而不是"Mr.Gale"，如[图5-2](text00015.html#ch05fig2)所示。如果你强制解包一个可选项并且它的值是nil，那么你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：强制解包一个没有值的可选项将导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应谨慎使用，并且仅在你能回答"我是否知道这个可选项在代码的这一点上肯定会有值？"时才使用。你可以通过首先检查它是否等于nil来确保可选项有值，然后再尝试解包它。这是一种安全的强制解包方式：
- en: '![](Image00109.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们检查确保futureTeacher有值后再进行强制解包。如果futureTeacher不等于nil，我们强制解包并将其值存储在常量knownTeacher
    ➋中。如果futureTeacher是nil，我们通过在 ➌ 处使用else语句打印"我不知道明年我的老师是谁。"。
- en: '**Optional Binding**'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解包可选项的方式是使用*可选绑定*。可选绑定通过将可选项暂时绑定到一个常量或变量，然后提供一个只有在可选项有值时才会执行的代码块来工作。我们使用if-let语句来实现这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码添加到你的playground中，观察if-let语句的实际效果：
- en: '![](Image00110.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: if-let语句检查可选的futureTeacher是否包含一个值。如果包含，值将赋给常量knownTeacher ➊，然后紧随其后的花括号中的代码块将被执行。在这个例子中，可选的futureTeacher没有包含值，因此if-let语句后的代码块没有被执行。
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望当可选值为nil时执行某些操作，可以写一个else块，就像我们在 ➋ 处做的那样。在这个例子中，我们告诉计算机检查futureTeacher，如果它包含一个值，计算机应该将该值称为knownTeacher。如果futureTeacher没有值，我们的程序将输出"我不知道明年我的老师是谁。"
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到if-let语句中的代码块和你之前检查futureTeacher是否为nil的代码块有相似之处吗？例如，这段代码：
- en: '[PRE12]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好且更简洁的写法：
- en: '[PRE13]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 futureTeacher 更改为一个教师的名字，并再次运行这个 if-let 语句。你应该看到句子“明年 *teacher* 将是我的老师。”填充了你输入的名字。
- en: '**NOTE**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这种语句称为 if-let 语句，你也可以使用 if-var，并临时将可选值赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是暂时将 futureTeacher 的值赋给常量 knownTeacher 。常量 knownTeacher 只存在于 if-let
    语句的括号内。如果你希望在程序的其他地方访问 futureTeacher 的值，你必须再写一个 if-let 语句。这就是我们所说的，使用可选值需要你做更多工作的原因，因为每次想要使用可选值时，你都必须解包它。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是解包可选值的一种安全方式，适用于你不确定其是否包含值的情况。如果可选值为 nil ，你不会遇到错误，反而可以通过 else 语句来控制发生的情况。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：“怎么可能不知道某个东西是否有值？”在我们的示例中，很明显 futureTeacher 没有值，因为我们将其设置为 nil 。但是有很多情况下，你并不清楚一个可选值是否有值。例如，假设我们要求用户为
    futureTeacher 输入一个名字。用户可能会输入名字，也可能不会。用户的行为是不可预测的，也许他们分心了，忘记输入名字。你无法知道用户的具体操作，直到
    *运行时* ——也就是说，程序实际运行时。如果我们的程序需要用户为 futureTeacher 设置值，那么它必须能够处理两种可能性（用户输入了名字或者忘记了输入），因为在运行时，任一情况都有可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选值**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你到目前为止看到的那样，可选值需要被解包才能让程序访问其持有的数据。通常，你每次需要使用可选值时都会解包它。但也有一些特殊情况，你会遇到一个必须是可选值且始终有值的变量。在这种情况下，与其每次使用时都解包它，你可以将其声明为
    *隐式解包可选值* 。这告诉计算机，变量是一个可选值，但始终会有值。因此，隐式解包可选值在每次使用时 *不需要* 解包；它会自动为你解包。你可以通过在数据类型后添加
    ! 来创建隐式解包可选值，而不是像普通可选值那样在数据类型后添加 ?。
- en: '![](Image00111.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，什么时候会使用这些隐式解包的可选类型呢？一个常见的用法是当你编写一个带有故事板的应用时。当你想将代码中的变量连接到故事板中的对象时，你会将它们声明为隐式解包的可选类型。在
    [第10章](text00021.html#ch10) 中，你将在创建生日追踪应用时看到这些变量的使用。因为这些变量需要是可选的（因为故事板要求），但它们总是会有一个值（因为它们与故事板连接，故事板会在你使用它们之前为它们赋值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况，你不应该经常使用隐式解包的可选类型。它们不像常规可选类型那样安全，如果使用不当，可能会导致程序崩溃。最好尽量使用常规可选类型。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特殊的运算符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的运算符在解包可选类型时非常有用：*空合并运算符*。听起来很厉害，是不是？不过它其实很容易使用，并且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符写作一对问号，位于一个可选值和默认值之间，例如 optionalThing ?? defaultThing。当可选值有值时，按常规使用该值，但当可选值为
    nil 时，空合并运算符会使用默认值。
- en: 'Let’s try an example with this operator:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个运算符尝试一个例子：
- en: '![](Image00112.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们创建了一个名为 specialLunch 的可选字符串变量。接下来，我们将名为 myLunch 的变量设置为 specialLunch 的值（如果它包含一个字符串），否则为
    defaultLunch ➋。在 ➌，当我们打印 myLunch 的值时，我们可以看到它是默认值 "pizza"，因为 specialLunch 为 nil。当我们将
    specialLunch 设置为 "牧羊人派" ➍，然后再次使用空合并运算符时，specialLunch 的值被解包并赋给 myLunch ➎。正如你所看到的，空合并运算符是一个快速的方法，可以在可选值有值时获取它，或者在可选值为
    nil 时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了可选类型，这是一个使 Swift 成为安全语言的伟大特性。可选类型强制我们知道哪些变量可能没有值，从而帮助我们防止程序中潜在的问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第6章](text00016.html#ch06) 中，你将学习两种集合数据类型：数组和字典。它们都非常有用，用于存储和管理一组项。数组中的项按顺序存储，可以通过索引访问。字典中的项以无序的键/值对存储，可以通过键访问。
- en: When you declare a variable or constant, Swift expects it to hold a value. If
    you’re not sure what value you want that variable or constant to hold, you can
    use an optional to avoid problems in your programs. Let’s see how!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量或常量时，Swift 期望它持有一个值。如果你不确定想让这个变量或常量持有什么值，可以使用可选类型来避免程序中的问题。让我们来看看如何做！
- en: '**CREATING OPTIONALS**'
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选类型**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选值，你声明一个变量或常量，并在数据类型后加一个 `?`。`?` 告诉 Swift 你希望将该变量或常量设为可选值。像变量或常量一样，可选值可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `futureTeacher` 为例创建一个可选值。假设你所在学校的所有老师并没有完全分配到明年的课程中，因此你不知道你的新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个可选变量 `futureTeacher`，它将存储一个 `String`，通过在数据类型后面加一个 `?` 来实现。与我们之前使用的非可选变量不同，可选变量不需要初始值。那部分是——你猜对了——*可选的*！在➊处，我们没有为
    `futureTeacher` 指定初始值，所以它的默认值是特殊值 `nil`，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `futureTeacher` 声明为一个可选的 `String`，它可以存储 `nil` 或一个 `String`。你可以像为普通变量设置值一样更改可选值，如➋所示。如果你改变主意并希望将可选值再次设置为
    `nil`，可以在➌处这样做。请注意，你不能将普通变量设置为 `nil`！这是可选值的一个特殊特性。在 [图 5-1](text00015.html#ch05fig1)
    中，你可以看到将 `futureTeacher` 设置为 `nil` 是允许的，但将 `grade` 设置为 `nil` 则不允许。
- en: '![](Image00104.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `grade` 改为 `nil` 的原因是，因为 `grade` 不是声明为可选的，它只是一个普通的 `Int` 数据类型。只有可选值可以同时存储声明的数据类型的值或
    `nil`。可选值就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将非可选值设置为 `nil`。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解包可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值使得你的代码更安全，因为它迫使你为没有值的情况做好规划。但这也意味着它们需要更多的工作来使用。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用普通的 `String` 那样使用一个可选的 `String`。首先，你需要检查可选值中是否真的存储了一个 `String`。如果有，那么你可以像使用任何其他
    `String` 一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选值是否有你可以使用的值，你需要 *解包* 它。解包可选值就像把它从盒子里拿出来。你不会在不拿出盒子的情况下玩生日礼物，对吧？同样，你也不能在代码中使用一个没有解包的可选值。解包可选值有几种不同的方法。让我们来看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制解包**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值的一种方式是通过 *强制解包*。当你知道一个可选值有一个值，并希望计算机直接访问该值时，使用强制解包。你通过在可选值名称后加一个 `!` 来实现。将以下代码输入到你的
    playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`futureTeacher`设置为 "Mr.Gale"。如果我们尝试将可选项字符串变量`futureTeacher`插入到`print`语句中
    ➊，则打印出的值是`Optional("Mr.Gale")`。这并不是我们想要的！我们只想要字符串 "Mr.Gale"。为了达到这个目的，你需要解包可选项。在
    ➋ 处，我们使用`futureTeacher!`强制解包了`futureTeacher`。现在，打印的行 "Next year I know my teacher
    will be Mr.Gale.\n" 看起来如我们所预期的。
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用强制解包时，必须确保该可选项确实有值。如果它是`nil`，你将遇到错误。为了亲自验证这一点，将`futureTeacher`设置为`nil`，而不是
    "Mr.Gale"，如[图 5-2](text00015.html#ch05fig2)所示。如果你强制解包一个可选项并且它的值是`nil`，你的程序将崩溃。
- en: '![](Image00108.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2: 强制解包一个没有值的可选项会导致错误。*'
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包应谨慎使用，并且只有在你可以回答“我知道这个可选项在代码的这一点上总是有值吗？”时才使用。你可以通过首先检查它是否等于`nil`来确保可选项有值，然后再尝试解包它。这是一种安全的强制解包方法：
- en: '![](Image00109.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们检查确保`futureTeacher`具有值之后，才会进行强制解包。如果`futureTeacher`不等于`nil`，我们将强制解包并将其值存储到常量`knownTeacher`
    ➋ 中。如果`futureTeacher`是`nil`，我们将在 ➌ 处使用`else`语句打印出 "I do not know who will be my
    teacher next year."。
- en: '**Optional Binding**'
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可选绑定**'
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选项的另一种方式是使用*可选绑定*。可选绑定的工作原理是将可选项临时绑定到常量或变量，然后提供一个仅在可选项确实包含值时才会执行的代码块。我们通过使用`if-let`语句来实现这一点。
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码添加到你的Playground中，查看`if-let`语句的执行过程：
- en: '![](Image00110.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-let`语句检查可选项`futureTeacher`是否包含值。如果包含，该值将被赋值给常量`knownTeacher` ➊，并且接下来的大括号内的代码块将会被执行。在这个例子中，可选项`futureTeacher`没有包含值，因此`if-let`语句后的代码块不会执行。'
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在可选项为`nil`时执行某些操作，可以编写一个`else`块，正如我们在 ➋ 处所做的那样。在这个例子中，我们告诉计算机查看`futureTeacher`，如果它包含值，计算机应该将该值称为`knownTeacher`。如果`futureTeacher`中没有值，我们的程序将输出
    "I do not know who will be my teacher next year."。
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到`if-let`语句中的代码块与在强制解包前检查`futureTeacher`是否为`nil`并将其值设置为`knownTeacher`时你写的代码块之间的相似性？例如，这段代码：
- en: '[PRE14]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更好且更简洁的写法：
- en: '[PRE15]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，什么时候会使用这些隐式解包的可选类型。一个常见的用法是当你编写一个带有故事板的应用时。当你想要将代码中的变量与故事板中的对象连接时，你需要将它们设为隐式解包的可选类型。你将在[第十章](text00021.html#ch10)中创建生日追踪器应用时看到这些变量的使用。这些变量需要是可选类型（因为故事板要求这样），但它们总会有值（由于它们已与故事板连接，故事板会在你使用它们之前给它们赋值）。
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特殊情况外，你应该尽量避免频繁使用隐式解包的可选类型。它们不像普通的可选类型那样安全，错误使用时可能会导致程序崩溃。最好尽可能使用普通的可选类型。
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一种特别的操作符：??**'
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特别有用的操作符，在你解包可选类型时非常实用：*空合并操作符*。听起来很厉害吧？不过实际上它非常容易使用，而且可以节省时间。
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并操作符由一对问号组成，位于可选类型和默认值之间，类似于 optionalThing ?? defaultThing。当可选类型有值时，通常会使用该值；而当可选类型为
    nil 时，空合并操作符会使用默认值代替。
- en: 'Let’s try an example with this operator:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个操作符来做个例子：
- en: '![](Image00112.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00112.jpg)'
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个可选的 String 类型变量 specialLunch。接下来，我们将一个变量 myLunch 设置为 specialLunch
    的值（如果它包含 String 类型的值）或者是 defaultLunch（如果它没有值） ➋。在 ➌ 处，当我们打印 myLunch 的值时，可以看到它是默认值
    "pizza"，因为 specialLunch 为 nil。当我们将 specialLunch 设置为 "shepherd's pie" ➍，然后再次使用空合并操作符时，specialLunch
    的值被解包并赋值给 myLunch ➎。正如你所看到的，空合并操作符是一种快速的方式，可以在可选值存在时获取其值，或者在其为 nil 时使用其他值。
- en: '![](Image00113.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00113.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你学习了可选类型，这是一个使 Swift 成为安全语言的伟大特性。可选类型迫使我们了解哪些变量可能没有值，从而帮助我们防止程序中潜在的问题。
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](text00016.html#ch06)中，你将学习两种集合数据类型：数组和字典。它们都非常有用，用于存储和管理项目集合。数组中的项目按顺序存储，可以通过索引号访问；字典中的项目按无序的键/值对存储，可以通过键来访问。
- en: '**CREATING OPTIONALS**'
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建可选类型**'
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可选值，你声明一个变量或常量，并在数据类型后面加上 ?。这个 ? 告诉 Swift 你想将这个变量或常量设置为可选值。就像普通的变量或常量一样，可选值可以包含任何数据类型。
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 futureTeacher 的可选值作为例子。假设你学校的所有老师还没有被分配到明年的班级，所以你不知道你的新老师是谁。
- en: '![](Image00103.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过在数据类型后面添加 ? 来创建一个可选的变量 futureTeacher，它将存储一个 String 类型。与我们之前使用的非可选变量不同，可选变量不要求有初始值。那部分——你猜对了——是*可选的*！在➊处，我们没有为
    futureTeacher 赋初始值，因此它的默认值是特殊值 nil，这意味着它还没有值。
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 futureTeacher 声明为一个可选的 String 类型，它可以保存一个值，也可以是空值（nil）。你可以像设置普通变量的值一样设置可选变量的值，如➋所示。如果你改变主意，想把可选值设置为
    nil，你也可以这样做，如➌所示。请注意，你不能将普通变量设置为 nil！这是可选值的一个特殊特性。在[图 5-1](text00015.html#ch05fig1)中，你可以看到将
    futureTeacher 设置为 nil 是允许的，但将 grade 设置为 nil 是不允许的。
- en: '![](Image00104.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 grade 设置为 nil 的原因是，因为 grade 并没有声明为可选类型，它只是一个普通的 Int 数据类型。只有可选值才能同时保存声明的类型值或
    nil。可选值就是这么特别。
- en: '![](Image00105.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：你不能将一个非可选值设置为 nil。*'
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**展开可选值**'
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值使你的代码更安全，因为它迫使你考虑一个可能没有值的情况。但这也意味着它们在使用时需要更多的工作。
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能像使用普通的 String 一样使用一个可选的 String。首先，你需要检查可选值中是否真的有一个 String。如果有，那么你就可以像使用其他
    String 一样使用它。
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的可选值是否有可以使用的值，你需要*展开*它。展开一个可选值就像是把它从盒子里拿出来。你不会在没有拆开生日礼物的情况下就去玩它，对吧？同样地，在代码中，你也不能在没有先展开可选值的情况下使用它。展开可选值有几种不同的方法。我们来看看它们是如何工作的！
- en: '![](Image00106.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: '**Forced Unwrapping**'
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制展开**'
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 展开可选值的一种方式是通过*强制展开*。当你知道一个可选值有值，并且想让计算机直接访问该值时，可以使用强制展开。你可以在可选值的名称后加上一个 ! 来实现这一点。将以下代码输入到你的
    Playground 中：
- en: '![](Image00107.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 futureTeacher 改为某个教师的名字，并再次运行这个 if-let 语句。你应该会看到句子 "Next year *teacher*
    will be my teacher." 被你输入的名字替换。
- en: '**NOTE**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然这种语句被称为 if-let 语句，但你也可以使用 if-var，并将可选值暂时赋给一个变量，而不是常量。*'
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只是将 futureTeacher 的值暂时赋给了常量 knownTeacher。常量 knownTeacher 仅在 if-let
    语句的花括号内存在。如果你想在程序的后续部分访问 futureTeacher 的值，你将不得不再创建一个 if-let 语句。这就是我们所说的，使用可选值需要你付出更多的工作，因为每次你想使用它时，都需要解包这个可选值。
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是一种安全的方式，用来解包那些你不确定是否包含值的可选值。如果可选值为 nil，你不会得到错误，反而可以通过 else 语句控制程序的执行。
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“你怎么可能不知道某个值是否有值呢？”在我们的例子中，很明显 futureTeacher 没有值，因为我们将它设置为了 nil。但有很多时候，你并不知道一个可选值是否有值。例如，假设我们要求用户输入
    futureTeacher 的名字。用户可能输入了名字，也可能没有。用户是不可预测的。也许他们分心了，忘记输入名字。直到 *运行时*，即程序实际运行时，你才知道用户做了什么。如果我们的程序需要用户设置
    futureTeacher 的值，那么它必须准备好处理这两种情况（用户输入了名字或忘记输入），因为在运行时，这两种情况都可能发生。
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式解包可选值**'
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你到目前为止所看到的，可选值需要在程序访问它们所包含的数据之前解包。通常，每次你需要使用可选值时，都要解包它。但也有一些少见的情况，你可能会有一个必须是可选值的变量，并且它总是会有值。在这些情况下，你可以将它声明为
    *隐式解包可选值*，而不是每次使用时解包它。这告诉计算机，这个变量是一个可选值，但总是有值。因此，隐式解包可选值每次使用时 *不需要* 被解包；它会自动为你解包。与常规可选值在数据类型后加
    ? 不同，你可以通过在数据类型后加 ! 来创建隐式解包可选值。
- en: '![](Image00111.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: To create an optional, you declare a variable or a constant and add a ? after
    the data type. The ? lets Swift know that you want to make the variable or constant
    an optional. Like a variable or a constant, an optional can contain any data type.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00103.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an optional called futureTeacher as an example. Imagine that not
    all of the teachers at your school have been assigned to the next year’s classes
    yet, so you don’t know who your new teacher will be.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00103.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00103.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-654
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create an optional variable, futureTeacher , that will store
    a String , by adding a ? after the data type. Unlike non-optional variables that
    we’ve used up until this point, an optional doesn’t require an initial value.
    That part is—you guessed it—*optional* ! At ➊ , we didn’t assign an initial value
    to futureTeacher , so its default value is the special value nil , which means
    it doesn’t yet have a value.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-748
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared futureTeacher as an optional String , it can hold either
    nothing (nil ) or a String . You change the value of an optional in the same way
    that you set the value for a regular variable, as shown at ➋ . If you change your
    mind and want to set the optional to nil again, you can do so ➌ . Note that you
    can’t set a regular variable to nil ! This is a special characteristic of optionals.
    In [Figure 5-1](text00015.html#ch05fig1) , you can see that setting futureTeacher
    to nil is allowed, but setting grade to nil is not.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00104.jpg)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-809
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-816
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-819
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-827
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-849
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: The reason you can’t change grade to nil is because grade was not declared as
    an optional and is just a regular Int data type. Only optionals can hold either
    a value of the declared type or nil . Optionals are special like that.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-862
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-898
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00105.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-913
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-919
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-946
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-948
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-1: You can’t set a non-optional to nil .*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-953
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-957
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-960
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-963
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-968
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-986
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-989
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '**UNWRAPPING OPTIONALS**'
  id: totrans-999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-1004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1012
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: Optionals make your code safer because they force you to plan for a situation
    in which they have no value. But this also means they require a little more work
    to use.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-1049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1057
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1062
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1086
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can’t use an optional String the same way you would use a regular
    String . First, you need to check if there really is a String stored in your optional.
    If there is, then you can use it like any other String .
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-1093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1095
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1098
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1106
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1128
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: To check if your optional has a value that you can use, you need to *unwrap*
    it. Unwrapping an optional is like taking it out of a box. You wouldn’t play with
    a birthday present without taking it out of the box, right? Well, you can’t use
    an optional in your code without unwrapping it first, either. There are a few
    different ways to unwrap optionals. Let’s see how they work!
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-1136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1138
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1149
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1164
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1171
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1173
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
- en: '**Forced Unwrapping**'
  id: totrans-1178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1180
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1186
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1191
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1206
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1213
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '**Forced Unwrapping**'
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1221
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1224
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1232
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1247
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to unwrap an optional is through *forced unwrapping* . Use forced unwrapping
    when you know that an optional has a value and you want the computer to access
    that value directly. You do this by entering an ! after the optional name. Enter
    this code into your playground:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1264
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1267
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1272
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1294
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1296
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1303
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1306
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1326
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1335
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we set futureTeacher to "Mr.Gale" . If we try sticking the
    optional String variable futureTeacher into a print statement ➊ , the value is
    printed as Optional("Mr.Gale") . That’s not ideal! We just want the string "Mr.Gale"
    . To get that, you need to unwrap the optional. At ➋ , we force-unwrap futureTeacher
    using futureTeacher! . Now the printed line "Next year I know my teacher will
    be Mr.Gale.\n" looks as expected.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1344
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1349
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1371
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1373
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: When you use forced unwrapping, you must be sure that the optional has a value.
    If it’s nil , you’ll get an error. To see this for yourself, set futureTeacher
    to nil instead of "Mr.Gale" , as shown in [Figure 5-2](text00015.html#ch05fig2)
    . If you force-unwrap an optional and it has a nil value, your program will crash.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1378
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1381
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1401
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1410
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  id: totrans-1414
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1417
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1422
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1437
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1444
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1446
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-2: Force-unwrapping an optional with no value will cause an error.*'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1452
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1457
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1472
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1479
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1481
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: 'Forced unwrapping should be used with caution and only when you can answer
    yes to the question, “Do I know this optional will always have a value at this
    point in the code?” You can make sure that an optional has a value by first checking
    whether it’s equal to nil before trying to unwrap it. This is a safe way to force-unwrap
    an optional:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1486
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1491
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1506
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1515
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  id: totrans-1519
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1524
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1539
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1546
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1548
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we check to make sure that futureTeacher has a value before we force-unwrap
    it. If futureTeacher is not equal to nil , we force-unwrap it and store its value
    in the constant knownTeacher ➋ . If futureTeacher is nil , we print "I do not
    know who will be my teacher next year." using an else statement at ➌ .
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1556
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1571
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1574
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1578
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1580
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Binding**'
  id: totrans-1584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1587
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1602
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1611
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: Another way to unwrap an optional is to use *optional binding* . Optional binding
    works by temporarily binding the optional to a constant or variable and then providing
    a block of code that will run only when the optional does have a value. We do
    this using an if-let statement.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1617
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1632
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1639
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1641
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code into your playground to see an if-let statement in action:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1646
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1661
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1668
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1670
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  id: totrans-1674
  prefs: []
  type: TYPE_IMG
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1689
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1696
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1698
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: The if-let statement checks whether the optional futureTeacher contains a value.
    If it does, the value will be assigned to the constant knownTeacher ➊ , and the
    block of code in the braces that follows will be executed. In this case, the optional
    futureTeacher doesn’t contain a value, so the block of code following the if-let
    statement isn’t executed.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1716
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1723
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1725
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: If you want something to happen when your optional has a nil value, then you
    can write an else block, like we did at ➋ . In this example, we’re telling the
    computer to look at futureTeacher and if it contains a value, the computer should
    call that value knownTeacher . If there’s no value in futureTeacher , our program
    will output "I do not know who will be my teacher next year."
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1742
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1749
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1751
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the similarity between the block of code in the if-let statement
    and the block of code that you wrote checking whether futureTeacher is nil before
    force-unwrapping it and setting its value to knownTeacher ? So, for example, this:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1767
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1774
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1776
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'is a better and more concise way of writing this:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1791
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1798
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1800
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: 'is a better and more concise way of writing this:'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-1805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1814
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1821
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1823
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1836
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1843
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1845
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: Try changing futureTeacher to a teacher’s name and run this if-let statement
    again. You should see the sentence "Next year *teacher* will be my teacher." filled
    with the name you typed.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1857
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1864
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1866
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: '*Although this type of statement is called an if-let statement, you can also
    use if-var and temporarily assign the optional value to a variable instead of
    a constant.*'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1877
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1884
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1886
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1887
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we’re just temporarily assigning the value in futureTeacher
    to the constant knownTeacher . The constant knownTeacher only exists inside of
    the if-let statement’s braces. If you want to access the value of futureTeacher
    later in the program, you’ll have to make another if-let statement. That’s what
    we mean when we say that using optionals requires a little more work on your part,
    because you’ll have to unwrap the optional each time you want to use it.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1895
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1902
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1904
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding is a safe way to unwrap optionals when you’re not sure if they
    contain a value. If the optional is nil , you won’t get an error, and instead
    you can control what happens using an else statement.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1912
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1919
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1921
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, “How could you not know whether something has a
    value?” In our example, it’s quite obvious that futureTeacher doesn’t have a value
    because we set it to nil . But there are many times when you won’t know whether
    an optional has a value. For example, suppose we asked the user to input a name
    for futureTeacher . The user may have typed a name or not. Users can be unpredictable.
    Maybe they were distracted and forgot to enter a name. There’s no way to see what
    the user is doing until *runtime* —that is, when the program is actually running.
    If our program needs the user to set the value for futureTeacher , then it has
    to be ready to handle both possibilities (if the user typed a name or forgot)
    because at runtime either could be true.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1928
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1935
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1937
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1938
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicitly Unwrapped Optionals**'
  id: totrans-1941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1943
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1946
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1950
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1952
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen so far, optionals need to be unwrapped before your program
    can access the data they hold. Usually you will unwrap an optional every time
    you need to use it. But there are some rare cases where you will have a variable
    that has to be an optional and will always have a value. In these cases, rather
    than unwrap the optional every time you use it, you can declare it as an *implicitly
    unwrapped optional* . This tells the computer that the variable is an optional
    but will always have a value. An implicitly unwrapped optional, therefore, does
    *not* need to be unwrapped every time you use it; it’s automatically unwrapped
    for you. Instead of creating the optional with a ? after the data type like a
    regular optional, you create an implicitly unwrapped optional by typing an ! after
    the data type.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1957
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1964
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1966
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  id: totrans-1970
  prefs: []
  type: TYPE_IMG
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1977
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1979
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering when you would ever use these implicitly unwrapped optionals.
    A common use is when you write an app with a storyboard. When you want to connect
    variables in your code to objects in the storyboard, you make them implicitly
    unwrapped optionals. You’ll see these come up in [Chapter 10](text00021.html#ch10)
    while you’re creating the Birthday Tracker app. These variables need to be optional
    (because the storyboard requires it), but they will always have a value (since
    they are connected to the storyboard, the storyboard will always give them a value
    before you use them).
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-1989
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-1991
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-1992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
- en: Other than in this special case, you shouldn’t be using implicitly unwrapped
    optionals very often. They aren’t as safe as regular optionals and can cause your
    program to crash if used incorrectly. It’s best to stick with regular optionals
    as much as possible.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-1996
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2000
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2002
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2003
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
- en: '**A SPECIAL KIND OF OPERATOR: ??**'
  id: totrans-2006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2010
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2012
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a special kind of operator that’s very useful when you’re unwrapping
    optionals: the *nil coalescing operator* . It’s impressive sounding, isn’t it?
    It’s actually quite easy to use, though, and can be a timesaver.'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2019
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2021
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is written as a pair of question marks between an
    optional and a default value, like optionalThing ?? defaultThing . When the optional
    has a value, the value will be used as usual, but when the optional is nil, the
    nil coalescing operator will use the default value instead.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2027
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2029
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example with this operator:'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2034
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2036
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00112.jpg)'
  id: totrans-2040
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2042
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we create an optional String variable called specialLunch . Next, we
    set a variable called myLunch to either be the value of specialLunch if it contains
    a String or defaultLunch if it doesn’t ➋ . At ➌ , when we print the value of myLunch
    , we can see that it’s the default value of "pizza" because specialLunch is nil
    . When we set specialLunch to "shepherd's pie" ➍ and then use the nil coalescing
    operator again, the specialLunch value is unwrapped and put into myLunch ➎ . As
    you can see, the nil coalescing operator is a quick way to either get an optional’s
    value if it has one, or use some other value if the it is nil .
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2047
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00113.jpg)'
  id: totrans-2051
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about optionals, a great feature that makes Swift
    a safe language. Optionals force us to know which variables might not have a value
    so we can prevent any potential problems in our programs.
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](text00016.html#ch06) , you’ll learn about two collection data
    types: the array and the dictionary. Both are extremely useful for storing and
    managing collections of items. Items in an array are stored in an ordered list
    and can be accessed by an index number. Items in a dictionary are stored in unordered
    key/value pairs and can be accessed by the keys.'
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
