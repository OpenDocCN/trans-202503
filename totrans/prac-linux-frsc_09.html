<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_255"/><strong><span class="big">9</span><br/>FORENSIC ANALYSIS OF TIME AND LOCATION</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">This chapter explains digital forensic concepts related to Linux time, regional settings, and location. Forensic timelines are explored, including how to build a forensic timeline from a Linux system. It also describes international configuration such as locale, keyboards, and languages. The final section covers geolocation technologies and reconstructing a Linux system’s geographic location history.</p>&#13;
<h3 class="h3" id="ch00lev1_43"><strong>Linux Time Configuration Analysis</strong></h3>&#13;
<p class="noindent">A large part of digital forensics is reconstructing past events. This <em>digital archaeology</em> depends on understanding concepts of time as applied to Linux environments.</p>&#13;
<h4 class="h4" id="ch00lev2_121"><strong><em>Time Formats</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_256"/>The standard representation of time in Linux is taken from Unix. The original Unix developers needed a compact way to represent the current time and date. They chose January 1, 1970, 00:00:00 UTC as the beginning of time (coinciding with the naming of Unix which took place in early 1970), and the number of seconds elapsed from that point represented a particular time and date. This date is also called the <em>Unix epoch</em>, and this format allowed for time and date to be stored as a 32-bit number.</p>&#13;
<p class="indent">We refer to a specified point in time as a <em>timestamp</em>. The following example shows the time in seconds using the Linux <code>date</code> command:</p>&#13;
<pre>$ <span class="codestrong1">date +%s</span>&#13;
1608832258</pre>&#13;
<p class="noindent">This timestamp is given in text format, but it could also be stored in binary format in big- or little-endian form. This same string in hexadecimal is a four-byte string: 0x5fe4d502.</p>&#13;
<p class="indent">One problem with 32-bit epoch-based time is the maximum number of seconds until the clock restarts to zero. This rollover will happen on January 18, 2038, creating a similar situation to Y2K (the rollover to January 1, 2000). Linux kernel developers are aware of this and have already implemented support for 64-bit timestamps.</p>&#13;
<p class="indent">Another problem with the original Unix time representation was its accuracy, which was limited to a precision of one second. This limit was enough for the slower speeds of early computers, but modern systems need higher resolution. Common terms representing the fractions of a second are:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Millisecond</strong> One thousandth of a second (0.0001)</p>&#13;
<p class="noindentin"><strong>Microsecond</strong> One millionth of a second (0.000001)</p>&#13;
<p class="noindentin"><strong>Nanosecond</strong> One billionth of a second (0.000000001)</p>&#13;
</div>&#13;
<p class="indent">The following example shows the number of seconds since the epoch with nanosecond resolution:</p>&#13;
<pre>$ <span class="codestrong1">date +%s.%N</span>&#13;
1608832478.606373616</pre>&#13;
<p class="noindent">To retain backward compatibility, some filesystems have added an additional byte to the timestamp. The individual bits in this byte are split between solving the 2038 issue and providing increased resolution.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As you get better at performing forensic analysis work, train yourself to notice numeric strings that are likely to be timestamps. For example, if you see a 10-digit number beginning with 16 (16</em>XXXXXXXX<em>), it could be a timestamp (September 2020 to November 2023).</em></p>&#13;
</div>&#13;
<p class="indent">The format used to display time in human-readable form is customizable. The format could be long, short, numeric, or a combination of the <span epub:type="pagebreak" id="page_257"/>three. Regional variations also may cause confusion. For example, 1/2/2020 could be February 1 or January 2, depending on the region. Even the delimiters are different depending on region or style (“.” or “/” or “-”).</p>&#13;
<p class="indent">In 1988, ISO created a global standard format for writing numeric dates that defined the year, followed by month, followed by day: 2020-01-02. I recommend using this format if your forensic tool supports it (and it probably does). The XKCD comic in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a> may help you remember.</p>&#13;
<div class="image"><img id="ch09fig01" src="Images/ch09fig01.jpg" alt="Image" width="452" height="527"/></div>&#13;
<p class="figcap"><em>Figure 9-1: XKCD Time Format (</em> <span class="normal"><a href="https://xkcd.com/1179/">https://xkcd.com/1179/</a></span><em>)</em></p>&#13;
<p class="indent">Two standards are useful for understanding time formats: ISO 8601 (<em><a href="https://www.iso.org/iso-8601-date-and-time-format.html">https://www.iso.org/iso-8601-date-and-time-format.html</a></em>) and RFC 3339 (<em><a href="https://datatracker.ietf.org/doc/html/rfc3339/">https://datatracker.ietf.org/doc/html/rfc3339/</a></em>). When performing digital forensics, especially logfile analysis, make sure that you understand the time format used.</p>&#13;
<h4 class="h4" id="ch00lev2_122"><strong><em>Time Zones</em></strong></h4>&#13;
<p class="noindent">The planet is divided into 24 major time zones, one hour apart.<sup><a id="ch09foot01" href="footnotes.xhtml#ch09foot_01">1</a></sup> The time zone indicates a geographical region and the time offset from Coordinated Universal Time (UTC). A time zone can be applied to a system or a user, and these zones are not necessarily the same if a user is logging in remotely.</p>&#13;
<p class="indent">When a system is first installed, the system owner specifies a time zone. This setting is a symbolic link (symlink) of <em>/etc/localtime</em>, which points to a <span epub:type="pagebreak" id="page_258"/><em>tzdata</em> file located in <em>/usr/share/zoneinfo/</em>. Determining the system’s configured time zone is simply a matter of identifying where this file is linked. In the following example, a system is configured for the region Europe and the city of Zurich:</p>&#13;
<pre>$ <span class="codestrong1">ls -l /etc/localtime</span>&#13;
lrwxrwxrwx 1 root root 33 Jun 1 08:50 /etc/localtime -&gt; /usr/share/zoneinfo/Europe/Zurich</pre>&#13;
<p class="noindent">This configuration provides an indicator of the machine’s physical location (or at least the region). A discrepancy between a system time zone and a user’s time zone at login is interesting, as it indicates the potential location of the system owner (using a remotely installed/managed system).</p>&#13;
<p class="indent">The configured time zone is usually static for systems with a fixed location like desktop PCs and servers. Laptops that change time zone regularly indicate a traveling user. A changed time zone (manually or automatically) can be observed in the journal:</p>&#13;
<pre>Dec 23 03:44:54 pc1 systemd-timedated[3126]: Changed time zone to 'America/Winnipeg' (CDT).&#13;
...&#13;
Dec 23 10:49:31 pc1 systemd-timedated[3371]: Changed time zone to 'Europe/Zurich' (CEST).</pre>&#13;
<p class="noindent">These logs show examples of changing the time zone using the GNOME Date &amp; Time GUI. The <code>systemd-timedated</code> daemon is asked to change the time zone and update the symlink for <em>/etc/localtime</em>. If set to change automatically, the system will query GeoClue for the location. GeoClue is the Linux geolocation service (described later in this chapter).</p>&#13;
<p class="indent">Individual users may also specify a login time zone that is different from the system’s time zone—for example, on servers where multiple users from around the world are logging in remotely via secure shell (SSH). To identify an individual user’s time zone, look for the assignment of the <code>TZ</code> environment variable. The <code>TZ</code> variable may be found in the shell startup files (<em>.bash_login</em>, <em>.profile</em>, and others) or set as a variable passed by the SSH program. To determine whether SSH is passing the <code>TZ</code> variable, check whether the SSH server config (<em>sshd_config</em>) is explicitly allowing <code>TZ</code> with the <code>AcceptEnv</code> parameter, or if the client config (<em>ssh_config</em> or <em>./ssh/config</em>) is explicitly passing <code>TZ</code> with the <code>SendEnv</code> parameter.</p>&#13;
<p class="indent">The TZ variable is a POSIX standard and implemented in Linux by the GNU C Library. The TZ variable has three formats, which are described here with examples:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Time zone and offset</strong> CET+1</p>&#13;
<p class="noindentin"><strong>Time zone and offset with daylight savings</strong> EST+5EDT</p>&#13;
<p class="noindentin"><strong>A time zone filename</strong> Europe/London</p>&#13;
</div>&#13;
<p class="indent">You can find a more detailed description of the TZ variable at <em><a href="https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html">https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html</a></em>.</p>&#13;
<p class="indent">On Fedora and SUSE systems, some packages and scripts may read the <em>/etc/sysconfig/clock</em> file (if it exists). This file describes the hardware clock (if it’s UTC, the time zone, and so on).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>When using forensic tools for analyzing timestamps, the tool may require specifying a time zone. With The Sleuth Kit, for example, commands using time zone information can use the <code>-z</code> flag to specify the time zone.</p>&#13;
<h4 class="h4" id="ch00lev2_123"><strong><em>Daylight Saving and Leap Time</em></strong></h4>&#13;
<p class="noindent">Daylight saving time is the practice of moving clocks forward an hour in spring and backward an hour in fall (“spring forward, fall back") to provide earlier daylight during winter and later daylight during summer. This practice is decided by regional governments and is not a global standard. Some regions (Russia in 2014 and Europe in 2021) have abolished, or are in the process of abolishing, the daylight saving time change.</p>&#13;
<p class="indent">It is important to be aware of daylight saving time when forensically analyzing systems in affected regions. The added or removed hour affects the reconstruction of forensic timelines and interpretation of past events. Forensic tools generally support daylight saving adjustments if a geographic region is specified. UTC does not change for daylight saving time.</p>&#13;
<p class="indent">The <em>tzdata</em> file described in the previous section contains daylight saving information. To extract a list of time intervals (historic and future) for a particular time zone, use the <code>zdump</code> tool on a Linux machine, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">zdump -v Europe/Paris |less</span> &#13;
...&#13;
Europe/Paris Sun Mar 31 00:59:59 2019 UT = Sun Mar 31 01:59:59 2019 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 31 01:00:00 2019 UT = Sun Mar 31 03:00:00 2019 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 27 00:59:59 2019 UT = Sun Oct 27 02:59:59 2019 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 27 01:00:00 2019 UT = Sun Oct 27 02:00:00 2019 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 29 00:59:59 2020 UT = Sun Mar 29 01:59:59 2020 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 29 01:00:00 2020 UT = Sun Mar 29 03:00:00 2020 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 25 00:59:59 2020 UT = Sun Oct 25 02:59:59 2020 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 25 01:00:00 2020 UT = Sun Oct 25 02:00:00 2020 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 28 00:59:59 2021 UT = Sun Mar 28 01:59:59 2021 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 28 01:00:00 2021 UT = Sun Mar 28 03:00:00 2021 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 31 00:59:59 2021 UT = Sun Oct 31 02:59:59 2021 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 31 01:00:00 2021 UT = Sun Oct 31 02:00:00 2021 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 27 00:59:59 2022 UT = Sun Mar 27 01:59:59 2022 CET isdst=0 gmtoff=3600&#13;
Europe/Paris Sun Mar 27 01:00:00 2022 UT = Sun Mar 27 03:00:00 2022 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 30 00:59:59 2022 UT = Sun Oct 30 02:59:59 2022 CEST isdst=1 gmtoff=7200&#13;
Europe/Paris Sun Oct 30 01:00:00 2022 UT = Sun Oct 30 02:00:00 2022 CET isdst=0 gmtoff=3600&#13;
...</pre>&#13;
<p class="noindent">Here, the transition time, time zone abbreviation (CET or CEST), current daylight saving flag (<code>isdst=</code>), and offset from UTC in seconds (<code>gmtoff=</code>) are shown.</p>&#13;
<p class="indent">It is interesting to note those regions that abandoned daylight saving, as the final entry in the <em>tzdata</em> file is the date and time of last change in the region.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>For more information about <em>tzdata</em> files, see the tzfile(5) man page. The authoritative source for time zone data is the Internet Assigned Numbers Authority (IANA), and tz database files can be found on the IANA website (<em><a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a></em>).</p>&#13;
<p class="indent">Leap years and leap seconds are also a factor in Linux timekeeping, and a challenge in forensics. A leap year is the addition of a single day, February 29, every four years (there is an exception to the leap year rule once per century). Leap seconds are more difficult to predict and are caused by the Earth’s rotation slowing down. The International Earth Rotation Service (IERS) decides when to add a leap second and publishes that decision half a year in advance (usually planned for the end or middle of the year). A list of leap seconds since the Unix epoch (28 of them as of this writing) are available on the IERS website (<em><a href="https://hpiers.obspm.fr/iers/bul/bulc/ntp/leap-seconds.list">https://hpiers.obspm.fr/iers/bul/bulc/ntp/leap-seconds.list</a></em>). Linux systems using external time synchronization will automatically add leap seconds. Leap years are predictable, and Linux systems are designed to add February 29 every four years.</p>&#13;
<p class="indent">It is important to be aware of leap years and leap seconds when forensically analyzing systems. The additional day and second could affect the reconstruction of past events and creation of forensic timelines.</p>&#13;
<h4 class="h4" id="ch00lev2_124"><strong><em>Time Synchronization</em></strong></h4>&#13;
<p class="noindent">From a digital forensics perspective, knowing the configured time synchronization is important for several reasons. It helps determine when a system was in sync or out of sync over time, providing more accurate analysis of system timelines. It helps investigations when the clock was deliberately changed or manipulated for malicious reasons.</p>&#13;
<p class="indent">To maintain the correct time during normal system operation, an external time source is used. Examples of external time sources include:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Network Time Protocol (NTP)</strong> Network-based time sync protocol (RFC 5905)</p>&#13;
<p class="noindentin"><strong>DCF77</strong> German longwave radio time signal broadcast from near Frankfurt (used across Europe)</p>&#13;
<p class="noindentin"><strong>Global Positioning System (GPS)</strong> Time received from a network of satellites</p>&#13;
</div>&#13;
<p class="noindent">Most Linux systems check and set the date on startup, using NTP after the network is functional.</p>&#13;
<p class="indent">The most common NTP software packages used on Linux systems are:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>ntp</strong> The original NTP reference implementation (<em><a href="https://ntp.org/">https://ntp.org/</a></em>)</p>&#13;
<p class="noindentin"><strong>openntpd</strong> Designed by the OpenBSD community for simplicity and security</p>&#13;
<p class="noindentin"><strong>chrony</strong> Designed to perform well under a variety of conditions</p>&#13;
<p class="noindentin"><strong>systemd-timesyncd</strong> Time synchronization built into systemd</p>&#13;
</div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_261"/>To determine which ntp mechanism is used, check the installed packages for ntp, openntpd, or chrony (systemd-timesync is installed as part of systemd). Then check which service unit file is enabled by examining the symlinks in <em>/etc/systemd/system/*.wants/</em>) directories. Common unit files are <em>ntp.service</em>, <em>ntpd.service</em>, <em>chrony.service</em>, and <em>openntpd.service</em>.</p>&#13;
<p class="indent">Systemd’s timesyncd will create symbolic links such as <em>/etc/systemd/system/ dbus-org.freedesktop.timesync1.service</em> and <em>/etc/systemd/system/sysinit.target.wants/ systemd-timesyncd.service</em>. On a live system the <code>timedatectl</code> command queries and manages these files.</p>&#13;
<p class="indent">The contents of the unit files provide information about the configuration. Often the time daemons will have a separate configuration file in <em>/etc/</em> (<em>ntp.conf</em> or <em>ntpd.conf</em>, for example) that defines the behavior of the daemon and specifies the time servers used. The systemd-timesyncd configuration is defined in <em>/etc/systemd/timesyncd.conf</em> .</p>&#13;
<p class="indent">Logs related to the time daemon provide information about startup, shutdown, time sync changes, and errors. These can be found in the systemd journal, in syslog logs, and in stand-alone logfiles in <em>/var/log/*</em>.</p>&#13;
<p class="indent">The following examples show log entries from openntpd, chrony, and systemd-timesyncd, with the time being changed:</p>&#13;
<pre>Aug 01 08:13:14 pc1 ntpd[114535]: adjusting local clock by -57.442957s&#13;
...&#13;
Aug 01 08:27:27 pc1 chronyd[114841]: System clock wrong by -140.497787 seconds,&#13;
adjustment started&#13;
...&#13;
Aug 01 08:41:00 pc1 chronyd[114841]: Backward time jump detected!&#13;
...&#13;
Aug 01 09:58:39 pc1 systemd-timesyncd[121741]: Initial synchronization to&#13;
time server 162.23.41.10:123 (ntp.metas.ch).</pre>&#13;
<p class="noindent">A list of servers is typically configured for the system to synchronize time. In some cases, a system may have a locally attached time source (DCF77, GPS, and so on) that may appear as a server with a 127.<em>x</em>.<em>x</em>.<em>x</em> IP address in the configuration file. You can find additional information about the time daemon and the configuration files in the software package man pages or at the developer website.</p>&#13;
<p class="indent">If a GPS device is attached, look for the gpsd (<em><a href="https://gpsd.io/">https://gpsd.io/</a></em>) software package and associated configuration (<em>/etc/gpsd/*</em> or <em>/etc/default/gpsd</em>).</p>&#13;
<p class="indent">Clock synchronization is typical but not required, and in some cases, no NTP configuration will be found. For example:</p>&#13;
<ul>&#13;
<li class="noindent">Virtual machines that trust the clock of the host (with a paravirtualized hardware clock, for example)</li>&#13;
<li class="noindent">Machines where the user sets the clock manually</li>&#13;
<li class="noindent">Machines where the <code>ntpdate</code> command is run at startup (or periodically) to set the clock</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_262"/>In such cases, the synchronization of the virtual machine’s host or the time of the hardware clock on the mainboard becomes important.</p>&#13;
<p class="indent">Most PC mainboards have a small battery to keep the clock running while the system is powered off. The Linux kernel’s real-time clock (RTC) driver makes the clock accessible through the <em>/dev/rtc</em> device (often a symlink to <em>/dev/rtc0</em>). Time synchronization software will keep the hardware clock updated accordingly.</p>&#13;
<p class="indent">The hardware clock of a system may be set to either the local time or to UTC (UTC is recommended). See the hwclock(8) man page for more information.</p>&#13;
<h5 class="h5"><strong>Raspberry Pi Clock</strong></h5>&#13;
<p class="noindent">The Raspberry Pi does not have a clock battery, and it powers on with an epoch time of zero (January 1, 1970 00:00:00). Any logs generated before the Raspberry Pi’s time is synchronized will have incorrect timestamps. Knowing when the system’s time synchronization established the correct time is important when analyzing anything with timestamps.</p>&#13;
<p class="indent">The Raspberry Pi and other embedded systems may save a timestamp at shutdown so that they can set a more reasonable time at early boot (until the time is synchronized). This is achieved using the <em>fake-hwclock</em> software package. The time is stored in a file, as shown in this example:</p>&#13;
<pre># <span class="codestrong1">cat /etc/fake-hwclock.data</span>&#13;
2020-03-24 07:17:01</pre>&#13;
<p class="noindent">The time stored in the <em>fake-hwclock.data</em> file may be in UTC and match the corresponding filesystem timestamps (last changed and modified). A periodic cron job may update the time written to the file in case of an unexpected crash or power loss. See the fake-hwclock(8) man page for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_125"><strong><em>Timestamps and Forensic Timelines</em></strong></h4>&#13;
<p class="noindent">A timestamp refers to a specific point in time, usually associated with some action or activity for which there is some digital evidence. Using timestamps in a forensic context helps to reconstruct a sequence of past events. However, there are challenges with using and trusting timestamps extracted from digital data sources. Some of the risks that affect the accuracy of timestamps are:</p>&#13;
<ul>&#13;
<li class="noindent">Clock drift or skew on machines without time synchronization</li>&#13;
<li class="noindent">Delays and latency for non-real-time operating systems</li>&#13;
<li class="noindent">Timestamps discovered without a known time zone</li>&#13;
<li class="noindent">Anti-forensics or the malicious changing of timestamps (using <code>timestomp</code>, for example)</li>&#13;
</ul>&#13;
<p class="noindent">Global investigations involving many devices across multiple time zones become more complex when the timestamps are impacted by these risks.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>Most forensic tools are aware of these issues and include functionality to adjust time accordingly. For example, The Sleuth Kit has flags that help:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">-s</span> <span class="codestrongitalic">seconds</span>    Adjust +/- seconds</p>&#13;
<p class="noindentin"><span class="codestrong">-z</span> <span class="codestrongitalic">zone</span>    Specify a time zone (for example, CET)</p>&#13;
</div>&#13;
<p class="indent">Never completely trust timestamps. Errors, failures, or anti-forensic activity are always possible, so try to corroborate with timestamps on different devices or other evidence sources.</p>&#13;
<p class="indent">A forensic timeline is the reconstruction of events based on timestamps found related to investigations. The first digital forensics timelines were created from the timestamps of the filesystem metadata (last accessed, modified, changed, and so on). Today, investigators assemble timestamp data from multiple sources into a single <em>super-timeline</em>, which can include any relevant timestamps, such as the following:</p>&#13;
<ul>&#13;
<li class="noindent">Filesystem timestamps (MACB)</li>&#13;
<li class="noindent">Logs (syslog, systemd journal, and application logs)</li>&#13;
<li class="noindent">Browser history, cookies, cache, and bookmarks</li>&#13;
<li class="noindent">Configuration data containing timestamps</li>&#13;
<li class="noindent">Recycle/trash data</li>&#13;
<li class="noindent">Email and attachments (mbox, maildir)</li>&#13;
<li class="noindent">Office document metadata (PDFs, LibreOffice, and so on)</li>&#13;
<li class="noindent">EXIF data (metadata from photos or videos)</li>&#13;
<li class="noindent">Volatility output files (memory forensics)</li>&#13;
<li class="noindent">Captured network traffic (PCAP files)</li>&#13;
<li class="noindent">CCTV cameras and building access systems (badge readers)</li>&#13;
<li class="noindent">Phone, chat, and other communication records</li>&#13;
<li class="noindent">Backup archives (tar <em>.snar</em> files and backup indexes)</li>&#13;
<li class="noindent">Other timestamp sources (mobile phones, IoT devices, or cloud)</li>&#13;
</ul>&#13;
<p class="noindent">A popular super-timelining framework is log2timeline/plaso, which uses free and open source tools to assemble timestamps from a variety of sources. You can visit the project website (<em><a href="https://github.com/log2timeline/plaso/">https://github.com/log2timeline/plaso/</a></em>) for more information.</p>&#13;
<p class="indent">The forensic timeline of every Linux image contains several significant time points:</p>&#13;
<ul>&#13;
<li class="noindent">Unix epoch</li>&#13;
<li class="noindent">Files that existed before installation (distro-provided files)</li>&#13;
<li class="noindent">Time of original system installation</li>&#13;
<li class="noindent">Last timestamp observed during normal operation</li>&#13;
<li class="noindent">Time of forensic acquisition</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_264"/>There should never be any timestamps after the forensic acquisition. If there are, they could indicate the drive image was tampered with or modified. Dates appearing after an acquisition could also have been deliberately created (faked) through anti-forensic activity.</p>&#13;
<p class="indent">Building and interpreting timelines presents some challenges. With large technical datasets, the number of timestamps available can be difficult to process (especially manually). Many timestamps will describe trivial or non-relevant events. Sometimes a collection of many timestamps describes a single overall event.</p>&#13;
<p class="indent">Another challenge is determining whether some event was caused by the user or the machine. It is also important to note, especially for filesystem forensics, that the farther back we look on the timeline, the less information we’ll likely find. Over time, sectors are overwritten, filesystem timestamps are updated, and other information is lost during normal system operation.</p>&#13;
<h3 class="h3" id="ch00lev1_44"><strong>Internationalization</strong></h3>&#13;
<p class="noindent">The internationalization of a Linux system includes the configuration of locale, languages, keyboards, and other region-specific information. Global investigations involving the identification of people (also known as attribution) benefit greatly from understanding the local regional artifacts found on a Linux system.</p>&#13;
<p class="indent">Linux internationalization refers to the support for multiple languages and cultural settings. The word <em>internationalization</em> is sometimes abbreviated as <em>i18n</em> because there are 18 characters between the <em>i</em> and <em>n</em>.</p>&#13;
<p class="indent">On Fedora-based and SUSE systems, some packages and scripts may read the i18n, keyboard, console, and language files (if they exist) in the <em>/etc/sysconfig/</em> directory. Debian-based systems have similar keyboard, hwclock, console-setup, and locale files in the <em>/etc/default/</em> directory.</p>&#13;
<p class="indent">Those files can be examined during a forensic investigation, but they have been partly superseded by the systemd equivalents described here.</p>&#13;
<h4 class="h4" id="ch00lev2_126"><strong><em>Locale and Language Settings</em></strong></h4>&#13;
<p class="noindent">Much of the internationalization of Linux is configured by defining the locale settings. The locale is part of glibc and can be used by any locale-aware software to control language, formatting, and other regional settings. These settings are defined in the <em>/etc/locale.conf</em> file, which may not exist (if the system uses other default settings), might contain a single line (language, for example), or may have a detailed locale configuration:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/locale.conf</span>&#13;
LANG="en_CA.UTF-8"</pre>&#13;
<p class="noindent">Here, the language is defined as Canadian English (Unicode). The locale definition file describes things like date format, currency, and other local <span epub:type="pagebreak" id="page_265"/>information. The definitions for available locales are found in <em>/usr/share/ i18n/locales</em> and stored in readable text files.</p>&#13;
<p class="indent">On some systems, the locale-gen program generates all the locales specified in <em>/etc/locale.gen</em> and installs them in <em>/usr/lib/locale/locale-archive</em>, where they can be used by any user on the system. The <code>localedef</code> tool can list the locales in the file:</p>&#13;
<pre>$ <span class="codestrong1">localedef --list-archive -i /usr/lib/locale/locale-archive</span>&#13;
de_CH.utf8&#13;
en_CA.utf8&#13;
en_GB.utf8&#13;
en_US.utf8&#13;
fr_CH.utf8</pre>&#13;
<p class="noindent">The output should correspond to the configuration in the <em>/etc/locale.gen</em> file. The file can be copied to a separate examination machine for offline analysis (using the <code>-i</code> flag).</p>&#13;
<p class="indent">From a user’s perspective, a locale is a collection of variables that define their local or regional preferences. On a running system, the <code>locale</code> command lists the variables:</p>&#13;
<pre>$ <span class="codestrong1">locale</span>&#13;
LANG=en_US.UTF-8&#13;
LC_CTYPE="en_US.UTF-8"&#13;
LC_NUMERIC="en_US.UTF-8"&#13;
LC_TIME="en_US.UTF-8"&#13;
LC_COLLATE="en_US.UTF-8"&#13;
LC_MONETARY="en_US.UTF-8"&#13;
LC_MESSAGES="en_US.UTF-8"&#13;
LC_PAPER="en_US.UTF-8"&#13;
LC_NAME="en_US.UTF-8"&#13;
LC_ADDRESS="en_US.UTF-8"&#13;
LC_TELEPHONE="en_US.UTF-8"&#13;
LC_MEASUREMENT="en_US.UTF-8"&#13;
LC_IDENTIFICATION="en_US.UTF-8"&#13;
LC_ALL=</pre>&#13;
<p class="noindent">These variables determine the language, numeric formats (commas instead of periods, for example), time (24-hour versus AM/PM), currency, paper size, name and address styles, measurement, and more. Some of these variables are defined by POSIX and others have been added by the Linux community. In a postmortem forensic examination we can reconstruct these preferences from configuration files.</p>&#13;
<p class="indent">See the locale(5) man page for more information about each of these variables (there are three locale man pages with different section numbers: locale(1), locale(5), and locale(7), so be sure to consult the right one).</p>&#13;
<p class="indent">A user can also create a mixed locale composed from variables taken from multiple installed locales (for example, North American English language together with European time settings).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_266"/>If no variables are defined by the user (in the shell startup scripts), the system-wide default locale defined in <em>/etc/locale.conf</em> is used. Systemd uses the <code>localectl</code> tool to manage localization and reads <em>locale.conf</em> during system boot. Any localization explicitly defined by system administrators and users is interesting and may help an investigation. For example, a mixture of settings may indicate a person speaking a certain language, but residing in a different country.</p>&#13;
<p class="indent">Most international software projects include support for multiple languages for interactive messages, error messages, help pages, documentation, and other information communicated to the user. When separate language files are provided with a software package, those files are stored in <em>/usr/share/locale/</em> and dynamically chosen depending on the configured language. The <code>LANG=</code> variable specifies the language to be used, which can be a system-wide default or configured for each user.</p>&#13;
<p class="indent">Graphical environments may have additional or separate language information and configuration settings (for example, the <code>KDE_LANG</code> variable for KDE or settings in the dconf database for GNOME). The XDG <em>*.desktop</em> files typically have language translation strings defined in the file. Some applications require separate installation of language packs (for example, dictionaries, office programs, and man pages).</p>&#13;
<h4 class="h4" id="ch00lev2_127"><strong><em>Physical Keyboard Layout</em></strong></h4>&#13;
<p class="noindent">A physical system’s attached keyboard is interesting because it tells us something about the person who uses it. The keyboard country and language suggest the user’s cultural origin (however, many non-English-speaking Linux computer programmers and enthusiasts choose a US English keyboard). The keyboard design may also provide information about how the owner is using the machine. There are gamer keyboards, programmer/sysadmin keyboards, ergonomic keyboards, touchscreen keyboards, collectable keyboards, and other exotic keyboard designs. These physical keyboard characteristics may be useful contextual information in a forensic examination.</p>&#13;
<p class="indent">The first step in analyzing the keyboard is to identify the physically attached device. A USB keyboard’s manufacturer and product information can be found in the kernel logs:</p>&#13;
<pre>Aug 01 23:30:02 pc1 kernel: usb 1-6.3: New USB device found, idVendor=0853,&#13;
idProduct=0134, bcdDevice= 0.01&#13;
Aug 01 23:30:02 pc1 kernel: usb 1-6.3: New USB device strings: Mfr=1,&#13;
Product=2, SerialNumber=0&#13;
Aug 01 23:30:02 pc1 kernel: usb 1-6.3: Product: Mini Keyboard&#13;
Aug 01 23:30:02 pc1 kernel: usb 1-6.3: Manufacturer: LEOPOLD</pre>&#13;
<p class="noindent">Here, the <code>idVendor</code> is <code>0853</code>, which is Topre (see <em><a href="http://www.linux-usb.org/usb-ids.html">http://www.linux-usb.org/usb-ids.html</a></em>), the <code>Manufacturer</code> is <code>LEOPOLD</code>, and the product (<code>0134</code>) is described as a <code>Mini Keyboard</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>Virtual machines don’t have physical keyboards (unless a physical USB keyboard is passed through directly to the virtual machine), and a virtual keyboard may appear as a PS/2 device:</p>&#13;
<pre>[    0.931940] i8042: PNP: PS/2 Controller [PNP0303:KBD,PNP0f13:MOU]&#13;
at 0x60,0x64 irq&#13;
[    0.934092] serio: i8042 KBD port at 0x60,0x64 irq 1&#13;
[    0.934597] input: AT Translated Set 2 keyboard as&#13;
/devices/platform/i8042/serio0/input/input0</pre>&#13;
<p class="noindent">The electronic/digital hardware interface to a keyboard is generic and language independent. A Linux system must be manually configured to map the language-specific layout and symbols seen on the physical key caps. This configuration can be done separately for the console and graphical environments.</p>&#13;
<p class="indent">Low-level scancodes generated by the physical keyboard are translated by the kernel into keycodes. These keycodes are mapped in userspace (either on the console or graphical environment) to keysyms, which are the characters (glyphs) in a human language. The available character sets are stored in <em>/usr/share/i18n/charmaps/</em> as compressed text files. A system-wide character set can be defined as the default, and a user may choose their own at login.</p>&#13;
<p class="indent">Linux systems replaced the early Unix serial ports with virtual consoles where the keyboard, mouse, and video are attached. These consoles are the text interface that is available when no graphical environment is started and typically seen at boot time or on server systems. The console keyboard (and font) can be configured in <em>/etc/vconsole.conf</em> with the <code>KEYMAP=</code> option.</p>&#13;
<p class="indent">If a graphical environment is used, the keyboard configuration describes the model, language, and other options. KDE stores this information in the <em>.config/kxkbrc</em> file of a user’s home directory. For example:</p>&#13;
<pre>[Layout]&#13;
DisplayNames=,&#13;
LayoutList=us,ch&#13;
LayoutLoopCount=-1&#13;
Model=hhk&#13;
Options=caps:ctrl_modifier&#13;
...</pre>&#13;
<p class="noindent">Here, a Happy Hacking Keyboard (<code>hhk</code>) is used, the available language layouts are <code>us</code> and <code>ch</code> (Switzerland), and other options are specified (CAPS LOCK is remapped as a CTRL key).</p>&#13;
<p class="indent">GNOME stores keyboard information in the dconf database under the <em>org.gnome.libgnomekbgd</em> key. See <a href="ch10.xhtml">Chapter 10</a> on how to analyze the dconf database.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>If systemd or the <code>localectl</code> command was used (manually or in a script) to set the configuration, the keyboard configuration will be stored in the <em>/etc/X11/xorg.conf.d/00-keyboard.conf</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/X11/xorg.conf.d/00-keyboard.conf</span>&#13;
# Written by systemd-localed(8), read by systemd-localed and Xorg. It's&#13;
# probably wise not to edit this file manually. Use localectl(1) to&#13;
# instruct systemd-localed to update it.&#13;
Section "InputClass"&#13;
        Identifier "system-keyboard"&#13;
        MatchIsKeyboard "on"&#13;
        Option "XkbLayout" "ch"&#13;
        Option "XkbModel" "hhk"&#13;
        Option "XkbVariant" "ctrl:nocaps,altwin:swap_lalt_lwin"&#13;
EndSection</pre>&#13;
<p class="noindent">Here, another Happy Hacking Keyboard (<code>hhk</code>) is configured with a Swiss (<code>ch</code>) layout.</p>&#13;
<p class="indent">Other window managers and graphical environments may also use dconf or have their own configuration files. Debian-based systems may store this information as variables in the <em>/etc/default/keyboard</em> file, like this:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/default/keyboard</span>&#13;
# KEYBOARD CONFIGURATION FILE&#13;
&#13;
# Consult the keyboard(5) manual page.&#13;
&#13;
XKBMODEL="pc105"&#13;
XKBLAYOUT="us"&#13;
XKBVARIANT=""&#13;
XKBOPTIONS="ctrl:nocaps"</pre>&#13;
<p class="noindent">XKB refers to the <em>X Keyboard Extension</em> from the X11 specification. See the xkeyboard-config(7) man page for a list of keyboard models, layouts, and options. Some Wayland compositors will also use these <code>XKB*</code> variables to configure the keyboard (Sway WM, for example).</p>&#13;
<h3 class="h3" id="ch00lev1_45"><strong>Linux and Geographic Location</strong></h3>&#13;
<p class="noindent">Answering the geographic “where?” question in a forensic investigation requires the reconstruction of the physical locations of a Linux device over time. If a device was stolen or missing and then subsequently recovered, where was it located during that time period? If a device was seized or quarantined for investigation, what is the history of device locations related to the incident? We can attempt to answer these questions using geolocation analysis.</p>&#13;
<p class="indent">Hand-held mobile devices are well known for their location-aware features, mostly due to the GPS implemented in hardware. Linux systems are usually installed on generic PCs that don’t have a built-in GPS. However, <span epub:type="pagebreak" id="page_269"/>forensic artifacts indicating geographic location can still be found. In some cases, geolocation data may also be derived or inferred from other sources (external to the forensic image under examination).</p>&#13;
<p class="indent">The reference to location may have several different contexts, including:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Global context</strong> Latitude and longitude (GPS coordinates)</p>&#13;
<p class="noindentin"><strong>Regional context</strong> Cultural or political region (locale, keyboard)</p>&#13;
<p class="noindentin"><strong>Organizational context</strong> Campus, building, office, or desk (IT inventory)</p>&#13;
</div>&#13;
<p class="indent">These location references may be determined or inferred from a forensic analysis of a system or surrounding infrastructure where the system has been connected.</p>&#13;
<h4 class="h4" id="ch00lev2_128"><strong><em>Geographic Location History</em></strong></h4>&#13;
<p class="noindent">Location history is the record of an object changing its point in space over a period of time. To reconstruct location history, we need physical location data together with timestamps. Knowing when a physical location changed helps us build a location timeline. Many of the ideas described here are not limited to Linux systems and may apply generally to other operating systems.</p>&#13;
<p class="indent">The keyboard, language, and other locale settings provide a broad indicator of region location. For example, knowing that the default paper size is US Letter or A4 indicates whether a system is from the North American region or not. If a system has a Swiss keyboard and German language, it indicates a German-speaking region of Switzerland. If the paper size or keyboard changed at a certain (known) time, it may indicate a change of region.</p>&#13;
<p class="indent">Time and time zone changes are potential indicators of travel. If a system suddenly changed its time zone settings (as previously shown in the logs), that indicates a change in location. The number of time zones changed may also be interesting, as it may suggest a mode of travel (flight versus automobile).</p>&#13;
<p class="indent">An analysis of timestamps before and after time zone switching could also be interesting. Was there a significant gap in timestamp activity before the time zone changed? Or do the timestamps show the person was working throughout the period when the time zone change took place?</p>&#13;
<p class="indent">To some extent, the IP address can provide an approximate geographic location. This method of determining location is sometimes called <em>IP geolocation</em> or <em>geo-IP</em> lookup. IP ranges are allocated to regional internet registries (RIRs) that delegate the use of ranges to an assigned region. The five RIRs (and their dates of inception) are:</p>&#13;
<ul>&#13;
<li class="noindent">RIPE NCC, RIPE Network Coordination Centre (1992)</li>&#13;
<li class="noindent">APNIC, Asia-Pacific Network Information Centre (1993)</li>&#13;
<li class="noindent">ARIN, American Registry for Internet Numbers (1997)</li>&#13;
<li class="noindent">LACNIC, Latin American and Caribbean Internet Address Registry (1999)</li>&#13;
<li class="noindent">AfriNIC, African Network Information Centre (2004)</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_270"/>National internet registries (NIRs) and local internet registries (LIRs) may further assign IP ranges to geographic regions. Companies like MaxMind (<em><a href="https://www.maxmind.com/">https://www.maxmind.com/</a></em>) may compile data from internet registries, information from internet service providers (ISPs), and other analytical sources to produce IP lookup databases that are sold as products and services.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>IP geolocation for devices that use tunneling, relaying, anonymization, mobile networks, international non-public networks, or private IP ranges (RFC 1918) may not provide accurate results.</em></p>&#13;
</div>&#13;
<p class="indent">Whenever a forensic examination reveals an IP address linked to a timestamp, it is a point on the location history timeline. IP addresses from within an organization’s internal network may offer more accurate location information (network configuration documentation, IT inventory databases, and so on).</p>&#13;
<p class="indent">At the link layer, the surrounding MAC addresses found in logs may be a location indicator. The MAC addresses of local routers or other fixed-location devices on a network segment may help determine location. For example, corporate IT environments may have an inventory of infrastructure MAC addresses that are assigned to physical buildings or offices. Wi-Fi infrastructure (BSSIDs) logged or cached on a local machine may also be a geographic location indicator.</p>&#13;
<p class="indent">In some cases, the machine’s MAC address or other unique identifiers may be logged at a wireless infrastructure provider (for example, WWAN mobile devices connecting to cell towers or WLAN wireless interfaces connecting to public Wi-Fi hotspots).</p>&#13;
<p class="indent">Connections to stationary Bluetooth devices may indicate a physical location (for example, evidence that a laptop used Bluetooth to connect with a desktop PC, home stereo, keyboard, or printer at a known location). Bluetooth connections to other mobile devices that have geolocation information may help reconstruct location history (for example, a laptop connected to a mobile phone or automobile that has stored GPS location information).</p>&#13;
<p class="indent">Application data may provide information about past locations of a roaming Linux system. For example, many providers will deposit cookies containing geolocation information whenever someone visits their website. In addition, any connections made to remote services may retain location information in the server logs (assuming the logs can be reliably linked to the machine under examination). In some cases, this information can be formally requested (by subpoena or other lawful request).</p>&#13;
<p class="indent">Geolocation information is often found in the metadata of files (photos, for example). However, this is not necessarily an indication of the PC’s location, but rather the device that originally took the photo.</p>&#13;
<p class="indent">If a Linux system is equipped with a GPS device, it is likely using the gpsd software package. Any programs or applications using gpsd may have logs or cached location data.</p>&#13;
<p class="indent">Desktop PCs are usually located in a fixed physical location. If seized, the exact location is known (obviously). In a forensic report, other information may be important to document, like a building address, room number, <span epub:type="pagebreak" id="page_271"/>or specific desk in an open plan office. In an enterprise environment, the physical location of a machine may have changed over time, and the location history can be reconstructed from changes to the IT inventory (if it exists and tracks changes to system location).</p>&#13;
<p class="indent">To some extent, we can also step into the physical world to determine the location of a particular electronic device. For example, some people collect stickers and put them on the lids of their laptops. People do this for various reasons: to easily identify their laptop, deter theft, or promote favorite products, projects, conferences, or other things. Laptop lid stickers create a unique visual identifier that can be matched with CCTV camera footage or geolocation tags of photos containing the laptop. They may also match specific conferences and events where the stickers were distributed.</p>&#13;
<h4 class="h4" id="ch00lev2_129"><strong><em>GeoClue Geolocation Service</em></strong></h4>&#13;
<p class="noindent">The GeoClue software project was started to provide location information for location-aware applications using D-Bus. As documented on its website (<em><a href="https://gitlab.freedesktop.org/geoclue/geoclue/">https://gitlab.freedesktop.org/geoclue/geoclue/</a></em>), it derives location information from:</p>&#13;
<ul>&#13;
<li class="noindent">Wi-Fi-based geolocation using Mozilla Location Service (accuracy in yards/meters)</li>&#13;
<li class="noindent">GPS(A) receivers (accuracy in inches/centimeters)</li>&#13;
<li class="noindent">GPS of other devices on the local network, such as smartphones (accuracy in inches/centimeters)</li>&#13;
<li class="noindent">3G modems (accuracy in miles/kilometers, unless the modem has GPS)</li>&#13;
<li class="noindent">GeoIP (city-level accuracy)</li>&#13;
</ul>&#13;
<p class="noindent">GeoClue was initially written for use by GNOME applications, but it is a D-Bus service and can be used by any application that is authorized in the GeoClue configuration file.</p>&#13;
<p class="indent">GeoClue’s configuration file defines which location sources to use and which local applications are permitted to request location information:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/geoclue/geoclue.conf</span>&#13;
# Configuration file for Geoclue&#13;
...&#13;
# Modem GPS source configuration options&#13;
[modem-gps]&#13;
&#13;
# Enable Modem-GPS source&#13;
enable=true&#13;
&#13;
# WiFi source configuration options&#13;
[wifi]&#13;
&#13;
<span epub:type="pagebreak" id="page_272"/># Enable WiFi source&#13;
enable=true&#13;
...&#13;
[org.gnome.Shell]&#13;
allowed=true&#13;
system=true&#13;
users=&#13;
...&#13;
[firefox]&#13;
allowed=true&#13;
system=false&#13;
users=</pre>&#13;
<p class="noindent">The daemon itself does not log location information; however, applications that use it may log or store this information.</p>&#13;
<p class="indent">The preference for using location services is stored in the user’s dconf database (<em>org.gnome.system.location.enabled</em>). This preference is independent of whether the <code>geoclue</code> service is running. If a user disables location services in their GUI settings, the <code>geoclue</code> service will not be disabled system-wide. Determining whether GeoClue was enabled requires checking for the existence of the systemd <em>geoclue.service</em> file.</p>&#13;
<h3 class="h3" id="ch00lev1_46"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter described how to analyze time-related elements of a Linux system. It explored the Linux internationalization features and how they can be useful in a forensic investigation. It also considered geolocation in the context of a Linux forensic analysis. This chapter has touched on user activity and behavior, a topic that the next chapter covers in greater depth.</p>&#13;
</div></body></html>