<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch19" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch19">
<span class="CN"><span aria-label=" Page 321. " epub:type="pagebreak" id="pg_321" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE ESP32 MICROCONTROLLER PLATFORM AND IOT</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">The phrase <i>Internet of things (IoT)</i> describes a wide variety of devices that communicate or are controlled over the internet. In the past, building IoT Arduino projects that communicate using Wi-Fi was complex and expensive, as Wi-Fi shields for Arduino were cumbersome and had limited features when combined with the Arduino’s microcontroller. However, this is no longer the case, thanks to the Espressif ESP32 microcontroller platform, which has built-in Wi-Fi and Arduino compatibility.</p>
<p class="TX">We’ll use ESP32-based boards in the final six chapters of this book. For the best learning experience, you may want to read these chapters in order; however, you can still skip around between them if you prefer.</p>
<p class="TX">In this chapter, I’ll introduce you to the ESP32-based Arduino-compatible development board. You’ll learn to install new board profiles in the Arduino <span aria-label=" Page 322. " epub:type="pagebreak" id="pg_322" role="doc-pagebreak"/>IDE, test ESP32 Wi-Fi connectivity, and use PWM with the ESP32 board. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Create a simple web page with buttons</li>
<li class="BL">Build a remote control for four outputs with state display</li>
<li class="BL">Build a remote-control-adjustable PWM output</li>
</ul>
<p class="TX">You’ll use the skills you develop in this chapter to work with other internet-connected devices in the later chapters of this book.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-139"/><samp class="SANS_Futura_Std_Bold_B_11">The ESP32</samp></h2>
<p class="TNI">The ESP32 is a microcontroller with built-in Wi-Fi and Bluetooth, as well as a higher operating speed than a typical Arduino or compatible board. It’s not a simple one-chip configuration; instead, it requires an external flash memory IC and an antenna for the wireless operations. The IC and antenna are usually grouped closely together, as shown in <a href="chapter19.xhtml#fig19-1">Figure 19-1</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE ESP32 MICROCONTROLLER UNIT PCB" class="img5" id="fig19-1" src="../images/fig19-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: Example ESP32 chipset in a module with the top can removed</samp></p></figcaption>
</figure>
<p class="TX">To avoid signal interference, the required circuitry is supplied in a module, which has a metal can on top. This module is then fitted to boards with the circuitry used to interface with other devices or is added to boards to become Arduino-compatible, as shown in <a href="chapter19.xhtml#fig19-2">Figure 19-2</a>.<span aria-label=" Page 323. " epub:type="pagebreak" id="pg_323" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF THE ESP32-BASED ARDUINO-COMPATIBLE BOARD" class="img6" id="fig19-2" src="../images/fig19-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: An ESP32 development board</samp></p></figcaption>
</figure>
<p class="TX">Boards like PMD Way part 51045204, shown in <a href="chapter19.xhtml#fig19-2">Figure 19-2</a>, are known as <i>ESP32 development boards</i> (or <i>dev boards</i>). You’ll use this board for projects from this chapter through <span class="Xref"><a href="chapter24.xhtml">Chapter 24</a></span>. Make sure to order the required USB cable if it isn’t included with the board you purchase.</p>
<p class="TX">There are four major differences between the Arduino Uno and the ESP32 dev board. The first is the large external flash memory IC; the ESP32 offers much more space for Arduino code than offered by an 8-bit Arduino. The second difference is the faster CPU speed of up to 240 MHz.</p>
<p class="TX">The third difference is that the ESP32 is a 3.3 V device, so all connections to external devices via input or output pins must either operate at 3.3 V or be 3.3 V tolerant. If the connection isn’t at this voltage by default, you’ll need to use a level converter such as PMD Way part 441079, shown in <a href="chapter19.xhtml#fig19-3">Figure 19-3</a>. Connect the converter between the wires from the 5 V device to the HV pads and the matching lower voltage wires on the LV pads to the ESP32, and connect GND of both sides to the ESP32 and the 5 V device.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE FOUR-CHANNEL LEVEL CONVERTER PCB" class="img4" id="fig19-3" src="../images/fig19-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A four-channel level converter board</samp></p></figcaption>
</figure>
<p class="TX">When shopping for a level converter, get a four-channel unit like the unit in <a href="chapter19.xhtml#fig19-3">Figure 19-3</a>. That way, you can use both SPI and I<sup>2</sup>C data buses without running out of converter pins.</p>
<p class="TX">The final difference between the Arduino Uno and the ESP32 is that, while the ESP32 shares the same physical form factor as an Uno, the pinouts are different, as shown in <a href="chapter19.xhtml#tab19-1">Table 19-1</a>. This also means that some Arduino shields may not work with the ESP32 <span aria-label=" Page 324. " epub:type="pagebreak" id="pg_324" role="doc-pagebreak"/>board, so investigate the required connections of a shield before purchasing to use with your ESP32.</p>
<figure class="table">
<p class="TableTitle" id="tab19-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">ESP32 and Arduino Pinout Comparison</samp></p>
<table class="table2">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino label</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Uno R3</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino label</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Uno R3</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">C clock</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SCL</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SCL</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D3</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO25</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp class="SANS_Futura_Std_Book_11">C data</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SDA</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SDA</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D2</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO26</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog reference</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">AREF</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">RESET</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D1</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">TX only</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D0</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">RX only</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D13</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO18</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO39</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D12</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO19</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A4</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO36</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D11</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO23</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A3</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO34</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D10</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A2</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO35</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D9</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO13</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A1</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO4</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D8</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO12</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog input</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A0</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO2</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D7</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO14</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Board voltage</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IOREF</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO0</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D6</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO27</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Reset MCU</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">RESET</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">RESET</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO16</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3.3 V output</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3.3V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3.3V</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital I/O</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D4</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">IO17</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5 V output</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
</tr>
<tr>
<td class="table TB"/>
<td class="table TB"/>
<td class="table TB"/>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
</tr>
<tr>
<td class="table TB"/>
<td class="table TB"/>
<td class="table TB"/>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
</tr>
<tr>
<td class="table TBL"/>
<td class="table TBL"/>
<td class="table TBL"/>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Raw voltage in</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Vin</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Vin</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">ESP32 pins labeled IO<i>xx</i> are (3.3 V) digital input and output pins. When addressing these pins in your Arduino sketches, don’t include the IO, just use the number. I’ll demonstrate that shortly.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Port manipulation doesn’t work with the ESP32 board. Pins may also have other functions beyond those shown in the table, but for the purposes of the projects in this chapter, you’ll use only the functions shown in the table.</i></p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-140"/><samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE for the ESP32</samp></h2>
<p class="TNI">The Arduino IDE doesn’t come with the ESP32 boards preinstalled, so you’ll need to install the required files. With your ESP32 on hand, open the Arduino IDE and select <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Preferences</b>. When the Preferences dialog appears, click the small button next to the Additional Boards Manager URLs field, and the Additional Boards Manager URLs dialog should appear, as shown in <a href="chapter19.xhtml#fig19-4">Figure 19-4</a>.<span aria-label=" Page 325. " epub:type="pagebreak" id="pg_325" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF ADDING THE BOARD PROFILES IN ARDUINO IDE" class="img7" id="fig19-4" src="../images/fig19-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: The Arduino IDE Additional Boards Manager URLs dialog</samp></p></figcaption>
</figure>
<p class="TX">Enter the following URL into the dialog:</p>

<pre><code><b>https://dl.espressif.com/dl/package_esp32_index.json</b>
</code></pre>

<p class="TX">If you already have other URLs in the dialog, place a comma at the end of the last URL and paste the new one after the comma.</p>
<p class="TX">Click <b>OK</b> to close the Preferences dialog. Now close and reopen the IDE. If your computer is not connected to the internet, connect it now. Select <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Boards Manager</b>. When the Boards Manager opens, enter <b>ESP32</b> in the search dialog. The ESP32 package should appear. Always use the latest version available.</p>
<p class="TX">Click <b>Install</b> and wait a few moments for the process to complete, as shown in the progress bar at the bottom of the Boards Manager dialog.</p>
<p class="TX">Since the ESP32 uses the CH340 USB-to-serial interface, which differs from that used on an Arduino Uno or compatible board, you’ll need to install drivers for the interface for your computer. To do this, follow the guide provided by SparkFun at <a href="https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all"><i>https://<wbr/>learn<wbr/>.sparkfun<wbr/>.com<wbr/>/tutorials<wbr/>/how<wbr/>-to<wbr/>-install<wbr/>-ch340<wbr/>-drivers<wbr/>/all</i></a>. Once you’ve installed the driver, connect your ESP32 dev board to the PC via a USB cable.</p>
<p class="TX">If you don’t already have the latest version of Python on your PC, you’ll also need to download and install it, since the Arduino IDE requires it as part of the toolchain to upload code to an ESP32 board. If necessary, visit <a href="https://www.python.org/downloads"><i>https://<wbr/>www<wbr/>.python<wbr/>.org<wbr/>/downloads</i></a> and follow the links for your operating system and install.</p>
<p class="TX">After installing Python, macOS users may need to open the terminal and run the following command before re-opening the Arduino IDE:</p>

<pre><code><b>Open -a Arduino</b>
</code></pre>

<p class="TX">Now open the Arduino IDE, select <b>Tools</b>, and change all the settings from Board onward to match those shown in <a href="chapter19.xhtml#fig19-5">Figure 19-5</a>.<span aria-label=" Page 326. " epub:type="pagebreak" id="pg_326" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF THE ESP32 SETTINGS MENU IN IDE" class="img5" id="fig19-5" src="../images/fig19-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Board settings in Arduino IDE for the ESP32</samp></p></figcaption>
</figure>
<p class="TX">The only parameter that may vary on your computer is the USB port; select the appropriate port shown in that option.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-141"/><samp class="SANS_Futura_Std_Bold_B_11">Testing the ESP32</samp></h2>
<p class="TNI">Before moving on to the first project of the chapter, test the dev board to check you can upload a sketch, operate GPIO pins, and operate your Wi-Fi.</p>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h2-28"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The GPIO Pins</samp></h3>
<p class="TNI">First, try controlling some GPIO pins by building the classic test circuit that blinks some LEDs. You will need the following:</p>
<ul class="ul">
<li class="BL">An ESP32 dev board and matching USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">Four LEDs</li>
<li class="BL">One 560 Ω, 0.25 W, 1 percent resistor</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter19.xhtml#fig19-6">Figure 19-6</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR TESTING LISTING 19-1" class="img5" id="fig19-6" src="../images/fig19-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A basic four-LED circuit for testing purposes.</samp></p></figcaption>
</figure>
<p class="TX">Now enter and upload <a href="#LiT-19-1">Listing 19-1</a> to your ESP32 dev board. A moment after uploading the sketch, each LED should turn on and off in turn.</p>
<span id="LiT-19-1"/>

<pre><code><span aria-label=" Page 327. " epub:type="pagebreak" id="pg_327" role="doc-pagebreak"/>void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> pinMode(16, OUTPUT);
    pinMode(17, OUTPUT);
    pinMode(18, OUTPUT);
    pinMode(19, OUTPUT);
}

void blinkLEDs()
{
    int i;
    int d = 250;
    for (i = 16; i &lt; 20; i++)
    {
      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> digitalWrite(i, HIGH);
        delay(d);
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> digitalWrite(i, LOW);
    }
}

void loop()
{
    blinkLEDs();
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: Testing outputs from the ESP32 dev board</samp></p>
<p class="TX">Although the hardware descriptions for the GPIO pins are IO<i>xx</i>, as shown in <a href="chapter19.xhtml#tab19-1">Table 19-1</a>, the sketch references the pins by just their numerical part identifiers when setting up the GPIO pin status <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and addressing them to turn on and off <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">If your sketch didn’t upload, check the settings for the board type and parameters as described in the previous section. Once you’ve finished this test, keep the circuit assembled, as you’ll use it for the following projects.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h2-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Wi-Fi Connectivity</samp></h3>
<p class="TNI">You’ll now test the ESP32’s Wi-Fi connectivity, using the WiFiScan sketch included with the ESP32 board profile that scans for the existence of Wi-Fi networks in your immediate vicinity.</p>
<p class="TX">You won’t need any extra hardware beyond the board, the USB cable, and a Wi-Fi network. Upload the sketch from the IDE’s examples via <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Examples</b> <img alt="" class="inline" src="../images/arr.png"/> <b>WiFi</b> <img alt="" class="inline" src="../images/arr.png"/> <b>WiFiScan</b>, then open the Serial Monitor in the Arduino IDE. After a few moments, the board should search for the existence of Wi-Fi access points and list them, along with their signal strength, as shown in <a href="chapter19.xhtml#fig19-7">Figure 19-7</a>.<span aria-label=" Page 328. " epub:type="pagebreak" id="pg_328" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF THE OUTPUT PRODUCED WHEN SCANNING FOR NEW WI-FI NETWORKS" class="img5" id="fig19-7" src="../images/fig19-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: Example results of scanning for Wi-Fi access points</samp></p></figcaption>
</figure>
<p class="TX">The Serial Monitor simply shows the access point names, not whether the connection is open. If you’d like more information on the meaning of the signal strength, visit <a href="https://en.wikipedia.org/wiki/Received_signal_strength_indication"><i>https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Received<wbr/>_signal<wbr/>_strength<wbr/>_indication</i></a>.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h1-142"/><samp class="SANS_Futura_Std_Bold_B_11">Port Forwarding</samp></h2>
<p class="TNI">To control your project from a device that isn’t connected to your local network, such as a tablet or phone using a cellular connection that doesn’t have a static IP address, you’ll need to use a technique called <i>port forwarding</i> in your network router or modem. Port forwarding gives you a static IP address from an external provider that then diverts data directly to your device.</p>
<p class="TX">Port forwarding services are provided by organizations such as No-IP (<a href="https://www.noip.com"><i>https://<wbr/>www<wbr/>.noip<wbr/>.com</i></a>) and Dyn (<a href="https://account.dyn.com"><i>https://<wbr/>account<wbr/>.dyn<wbr/>.com</i></a>). Setup is often unique to the make and model of your router, so do an internet search for <i>router port forwarding</i> for your model of router. Alternatively, you could ask your ISP, if it provided the router, or visit a tutorial site such as <a href="http://www.wikihow.com/Port-Forward"><i>http://<wbr/>www<wbr/>.wikihow<wbr/>.com<wbr/>/Port<wbr/>-Forward</i></a> for more information.</p>
<p class="TX">Once you’ve set up port forwarding or otherwise confirmed your static IP address, you’re ready to start building a framework for remote-control applications. However, if you can’t organize port forwarding, you can still control your projects from your local-area Wi-Fi network.</p>
<p class="HeadProject"><span id="h1-143"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #55: Remote-Controlling a Single GPIO Pin</samp></p>
<p class="TNI">In this project, you’ll remotely control a GPIO pin on your ESP32 dev board via any device with a web browser. This includes building a simple web page hosted by the ESP32 using HTML and CSS. You can then use this page to control anything you normally would control with an Arduino 3.3 V (or 5 V with a level converter) digital output, such as a relay, MOSFET, LED, or so on.</p>
<p class="TX"><span aria-label=" Page 329. " epub:type="pagebreak" id="pg_329" role="doc-pagebreak"/>For the hardware, use the circuit for testing the GPIO pins described in the previous section. Enter and upload the Project #55 sketch to your ESP32 dev board. Don’t forget to update your Wi-Fi network credentials in the sketch before uploading. A moment after that, open the Serial Monitor in the Arduino IDE to watch the ESP32’s progress as it connects to the Wi-Fi network. The sketch should then display your project’s IP address, as shown in <a href="chapter19.xhtml#fig19-8">Figure 19-8</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE OUTPUT FROM THE ESP32 ONCE CONNECTED TO A WI-FI NETWORK" class="img5" id="fig19-8" src="../images/fig19-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The Serial Monitor showing that the ESP32 has connected to the Wi-Fi network</samp></p></figcaption>
</figure>
<p class="TX">Next, using the web browser on a web-enabled device, visit the IP address shown in the Serial Monitor. You should see the simple web page hosted by the ESP32 dev board, as shown in <a href="chapter19.xhtml#fig19-9">Figure 19-9</a>.</p>
<figure class="IMG"><img alt="&lt;&lt;AN IMAGE OF THE WEB PAGE INTERFACE FOR PROJECT #55" class="img5" id="fig19-9" src="../images/fig19-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: A remote-control web page</samp></p></figcaption>
</figure>
<p class="TX">When you click the On or Off buttons, the LED connected to GPIO 16 should turn on and off. For this project, the ESP32 dev board has two jobs: to act as a web server that hosts the simple web page for the user interface (including the On/Off buttons) and to respond to HTML requests from the web browser (to turn the GPIO pin on and off).</p>
<p class="TX">Let’s take a closer look at how this works:</p>
<span id="pro-55"/>

<pre><code>// Project #55 - Digital output control via web page

#include &lt;WiFi.h&gt; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
WiFiServer server(80); // Set web server port to 80

<span aria-label=" Page 330. " epub:type="pagebreak" id="pg_330" role="doc-pagebreak"/>// Store your Wi-Fi network credentials:
char* ssid = "<var>name</var>"; // Insert name of Wi-Fi access point
char* password = "<var>password</var>"; // Insert password

String request; // Stores HTTP request from client (web browser)
int outputPin = 16; // Using GPIO pin 16 on the ESP32 board

unsigned long currentTime = millis(); <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void setup()
{
    Serial.begin(115200);
    // Set up digital pin to control
    pinMode(outputPin, OUTPUT);
    digitalWrite(outputPin, LOW);

    // Connect to Wi-Fi network:
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    // Show indicator while waiting for connection:
    {
        delay(500);
        Serial.print("~");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server
    server.begin();
}

void loop()
{
    // Listen for incoming clients from web browser: <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
    WiFiClient client = server.available();
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; currentTime - previousTime &lt;= timeoutTime)
        {// Stay connected for timeoutTime
            currentTime = millis();
            if (client.available())
            {
                // Display data from client on Serial Monitor:
                char c = client.read(); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                Serial.write(c);
                request += c;
<span aria-label=" Page 331. " epub:type="pagebreak" id="pg_331" role="doc-pagebreak"/>                if (c == '\n') // Client request has finished
                {
                    if (currentLine.length() == 0)
                    {
                        // Send HTTP response to client:
                        client.println("HTTP/1.1 200"OK");
                        client.println("Content-type:text/h"ml");
                        client.println("Connection: cl"se");
                        client.println();
                        // Now do things based on the client request:
                        if (request.indexOf("GET /16/on") &gt;= 0) <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
                        {
                            // If request was IP address/16/on:
                            Serial.println("output on");
                            digitalWrite(outputPin, HIGH);
                        } else if (request.indexOf("GET /16/off") &gt;= 0) <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
                        // If request was IP address/16/off:
                        {
                            Serial.println("output off");
                            digitalWrite(outputPin, LOW);
                        }
                        // Build web page for display on browser:
                        client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;");
                        client.print("&lt;head&gt;&lt;meta name=\"viewport\");
                        client.println(" content=\"width=device-width, initial-scale=1\"&gt;");
                        client.println("&lt;link rel=\"icon\" href=\"data:,\ "&gt;");
                        // Build buttons using CSS:
                        client.print("&lt;style&gt;html {font-family: Helvetica; display:");
                        client.print("inline-block; margin: 0px auto; text-align: center;}");
                        client.println();
                        client.print (".button {background-color: #ff0000; border: ");
                        client.println("none; color: white; padding: 8px 20px;");
                        client.print ("text-decoration: none; font-size: 20px; margin: ");
                        client.println("2px; cursor: pointer; border-radius: 12px;}");
                        client.println("&lt;/style&gt;&lt;/head&gt;");
                        // Now HTML for layout:
                        client.println("&lt;body&gt;&lt;h3&gt;Remote ESP32 Output Control&lt;/h3&gt;");
                        // Display "On" button with matching HTML "/16/on":
                        client.print ("&lt;p&gt;&lt;a href=\"/16/on\"&gt;&lt;button ");
                        client.println("class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;");
                        // Display "Off" button with matching HTML "/16/off":
                        client.print ("&lt;a href=\"/16/off\"&gt;&lt;button class");
                        client.println("=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                        client.println("&lt;/body&gt;&lt;/html&gt;");
                        // End the response to client request:
                        client.println();
                        break;
                    } else
                    {// If you got a newline, then clear currentLine
                        currentLine = " ";
                    }
                } else if (c != '\r')
                {
                    currentLine += c;
<span aria-label=" Page 332. " epub:type="pagebreak" id="pg_332" role="doc-pagebreak"/>                }
            }
        }
        request = " "; <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
        // Close connection to client:
        client.stop();
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">First, the sketch includes the Arduino Wi-Fi library <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and creates an instance of a server with a port of 80. Following this, it stores the SSID (Wi-Fi access point name) and password in the respective fields. It declares a string variable to contain the text of the HTTP request from the client (the web browser displaying the project’s web page) and then sets the GPIO pin it will control.</p>
<p class="TX">The sketch then declares variables to take care of the connection time allowed for each client to the server (the ESP32 dev board) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, it configures the Serial Monitor and then sets GPIO16 as an output and to LOW. The ESP32 attempts to connect to the Wi-Fi network using the credentials entered earlier, with the code looping and displaying a tilde (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) every half second until the network connection is successful. Once the ESP32 has made a Wi-Fi connection, the sketch displays the IP address in the Serial Monitor and the project begins to operate as a web server, thanks to <samp class="SANS_TheSansMonoCd_W5Regular_11">server.begin()</samp>.</p>
<p class="TX">The ESP32 now runs the code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> until a reset or removal of power. Each loop begins by checking to see if a client (a person using a web browser) is trying to connect to the project <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If so, the code takes note of the point in time at which the connection starts using the <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> function to allow each individual client to connect to the ESP32 for only up to two seconds (as set with <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp>). This is because other users may want access as well—you don’t want one person hogging access to the project. The code also empties the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">currentLine</samp>, awaiting text from the client.</p>
<p class="TX">If the client has been connected for less than 2,000 milliseconds and has made a request, the ESP32 receives it. The code feeds the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentTime</samp> variable with the latest value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>. The string request receives the client request <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, one character at a time. This request is displayed on the Serial Monitor so that, if you’re curious, you can see the information the client sends out (browser type, device operating system, and so on). Once the client has finished sending the request, as denoted by a newline character (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), the ESP32 sends a response in HTML back to the client browser. To do so, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions, which send the text out via the Wi-Fi connection in the same way you may use <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp> in other projects.</p>
<p class="TX">The ESP32 can finally act on the client request and take an action. Client requests are received in the form <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>, so the string request is searched in turn for an on command <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and acted upon by sending this to the Serial Monitor and then turning GPIO16 on; if an off command is received, the opposite occurs <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. This is the point where you can modify the actions to suit your own purposes. This project simply calls a <span aria-label=" Page 333. " epub:type="pagebreak" id="pg_333" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> function, and you can replace this with your own function to have the ESP32 take an action of your own choosing.</p>
<p class="TX">The final section of the code enables ESP32 to host the simple web page that is the user interface shown in <a href="chapter19.xhtml#fig19-10">Figure 19-10</a>. Using many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions, the code creates HTML that creates the framework for a web page, defines using CSS the buttons to be displayed, positions the buttons, and sends HTML to define the end of the web page. Once the client request is complete, the sketch flushes the request from the variable <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> and closes the connection, ready for the next user.</p>
<p class="TX">Let’s take a closer look at the HTML contained in the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions:</p>

<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;
&lt;head&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;
&lt;link rel=\"icon\" href=\"data:,\"&gt;
&lt;style&gt;html {font-family: Helvetica; display: inline-block;
 margin: 0px auto; text-align: center;}
.button {background-color: #ff0000; border: none; color: white; padding: 8px 20px;
text-decoration: none; font-size: 20px; margin: 2px; cursor: pointer; border-radius: 12px;} <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
&lt;/style&gt;&lt;/head&gt;
&lt;body&gt;&lt;h3&gt;Remote ESP32 Output Control&lt;/h3&gt; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
&lt;p&gt;&lt;a href=\"/16/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt; <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
&lt;a href=\"/16/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt; <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
&lt;/body&gt;&lt;/html&gt;</code></pre>

<p class="TX">This code uses CSS to select the color, size, font size, and rounded edges of the web interface’s buttons <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, with the heading displayed in a larger type <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It then adds the two buttons to the web page. Each button has a hyperlink to its respective operation attached: the first link is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and the second is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. When the user clicks either of the buttons, the client request will consist of the IP address of the ESP32, followed by <i>/16/on</i>—for example, <i>http://<wbr/>192<wbr/>.168<wbr/>.20<wbr/>.28<wbr/>/16<wbr/>/on</i>.</p>
<p class="TX">If you hover your mouse over the button on the web page, the link should appear at the bottom of the screen. For example, <a href="chapter19.xhtml#fig19-10">Figure 19-10</a> shows what happens when the mouse hovers over the On button. (The URL in the browser tab at the top is for the last page I visited, the result of clicking the Off button.)</p>
<figure class="IMG"><img alt="AN IMAGE OF THE HYPERLINK DISPLAYED IN THE WEB BROWSER" class="img7" id="fig19-10" src="../images/fig19-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: Example hyperlink displayed in the browser</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 334. " epub:type="pagebreak" id="pg_334" role="doc-pagebreak"/>When installing a project on a more permanent basis, the end user can also bookmark the full URL for each function. For example, if the IP address returned by the project is 192.168.20.28, the bookmark to turn on would be <i>http://<wbr/>192<wbr/>.168<wbr/>.20<wbr/>.28<wbr/>/16<wbr/>/on</i>.</p>
<aside aria-labelledby="box2" class="box">
<h3 class="BoxTitle" id="box2"><samp class="SANS_Dogma_OT_Bold_B_11">HTML AND CSS RESOURCES</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you’re not familiar with HTML or CSS and would like to learn more, you can visit the following sites for more information:</samp></p>
<ul class="ul">
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">HTML basics:</samp> <a href="https://www.w3schools.com/html/default.asp"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.w3schools.com/html/default.asp</samp></a></li>
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Creating and using buttons:</samp> <a href="https://www.w3schools.com/css/css3_buttons.asp"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.w3schools.com/css/css3_buttons.asp</samp></a></li>
<li class="BoxListBullet"><samp class="SANS_Futura_Std_Book_11">Determining color codes in hexadecimal:</samp> <a href="https://www.color-hex.com"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.color-hex.com</samp></a></li>
</ul>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You can also use</samp> <a href="https://htmledit.squarefree.com"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://htmledit.squarefree.com</samp></a> <samp class="SANS_Futura_Std_Book_11">as a tool to preview your own HTML without having to publish it or upload to the ESP32.</samp></p>
</aside>
<p class="TX">Be warned that anyone who has the URL address for this type of project can operate the controls. For increased security, you might create a secure website or portal that password-protects access to the control buttons.</p>
<p class="HeadProject"><span id="h1-144"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #56: Remote-Controlling Four GPIO Pins</samp></p>
<p class="TNI">This project builds on the previous project by allowing you to remotely control four GPIO pins, displaying their status on the web page hosted by the ESP32. Users can then quickly review the status of the devices under control, which is ideal for truly remote-controlled projects.</p>
<p class="TX">You’ll use the same demonstration circuit described in <span class="Xref">“The GPIO Pins” on page 326</span> (this is why it includes four LEDs). Once you’ve set up that circuit, enter and upload the Project #56 sketch to your ESP32 dev board. A moment after that, open the Serial Monitor in the Arduino IDE to watch as the ESP32 connects to the Wi-Fi network.</p>
<p class="TX">Once the ESP32 connects, the IP address of the project should appear in the Serial Monitor. Enter that IP address into a web browser and the interface for this project should appear, as shown in <a href="chapter19.xhtml#fig19-11">Figure 19-11</a>.<span aria-label=" Page 335. " epub:type="pagebreak" id="pg_335" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56&gt;, SHOWING ALL FOUR OUTPUTS ARE OFF" class="img5" id="fig19-11" src="../images/fig19-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: The user interface for Project #56</samp></p></figcaption>
</figure>
<p class="TX">You should be able to control all four LEDs by clicking their respective buttons. After each button click, the web page should also indicate the state of the linked LED. For example, <a href="chapter19.xhtml#fig19-12">Figure 19-12</a> shows that outputs 2 and 4 are on.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56, SHOWING OUTPUTS 1 AND 3 ARE OFF AND 2 AND 4 ARE ON" class="img5" id="fig19-12" src="../images/fig19-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-12: Outputs 2 and 4 are on, while 1 and 3 are off.</samp></p></figcaption>
</figure>
<p class="TX">You can imagine how much more useful this is to have four sets of buttons, enabling control of more relays, outputs, devices controlled by MOSFETs, and so on.</p>
<p class="TX"><span aria-label=" Page 336. " epub:type="pagebreak" id="pg_336" role="doc-pagebreak"/>Let’s take a closer look to see how this works:</p>
<span id="pro-56"/>

<pre><code>// Project #56 - Digital output controls via web page with status update

#include &lt;WiFi.h&gt;
WiFiServer server(80); // Set web server port to 80

// Store your Wi-Fi network credentials:
char* ssid = "<var>name</var>"; // Insert name of Wi-Fi access point
char* password = "<var>password</var>"; // Insert password

String request; // Stores HTTP request from client (web browser)
String outputPin1State = "Off"; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
String outputPin2State = "Off";
String outputPin3State = "Off";
String outputPin4State = "Off";

int outputPin1 = 16; // Using GPIO pins 16~19 on the ESP32 board <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
int outputPin2 = 17;
int outputPin3 = 18;
int outputPin4 = 19;

unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void setup()
{
    Serial.begin(115200);
    // Set up digital pins to control:
    pinMode(outputPin1, OUTPUT); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
    pinMode(outputPin2, OUTPUT);
    pinMode(outputPin3, OUTPUT);
    pinMode(outputPin4, OUTPUT);
    digitalWrite(outputPin1, LOW);
    digitalWrite(outputPin2, LOW);
    digitalWrite(outputPin3, LOW);
    digitalWrite(outputPin4, LOW);
    // Connect to Wi-Fi network:
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    // Show indicator while waiting for connection:
    {
        delay(500);
        Serial.print("~");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server:
    server.begin();
}

void loop()
<span aria-label=" Page 337. " epub:type="pagebreak" id="pg_337" role="doc-pagebreak"/>{
    // Listen for incoming clients from web browser:
    WiFiClient client = server.available();
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; currentTime—previousTime &lt;= timeoutTime)
        {// Stay connected for timeoutTime
            currentTime = millis();
            if (client.available())
            {
                char c = client.read(); // Display data from client on Serial Monitor
                Serial.write(c);
                request += c;
                if (c == '\n')
                {
                    // Client request has finished
                    if (currentLine.length() == 0)
                    {
                        // Send HTTP response back to client
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:text/html");
                        client.println("Connection: close");
                        client.println();
                        // Now do things based on the client request:
                        if (request.indexOf("GET /16/on") &gt;= 0) <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                        {
                            // If request was IP address/16/on:
                            Serial.println("output 1 on");
                            outputPin1State = "On"; <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
                            digitalWrite(outputPin1, HIGH);
                        } else if (request.indexOf("GET /16/off") &gt;= 0)
                        {
                            // If request was IP address/16/off:
                            Serial.println("output 1 off");
                            outputPin1State = "Off";
                            digitalWrite(outputPin1, LOW);
                        } else if (request.indexOf("GET /17/on") &gt;= 0)
                        {
                        // If request was IP address/17/on:
                            Serial.println("output 2 on");
                            outputPin2State = "On";
                            digitalWrite(outputPin2, HIGH);
                        } else if (request.indexOf("GET /17/off") &gt;= 0)
                        // If request was IP address/17/off:
                            {
                            Serial.println("output 2 off");
                            outputPin2State = "Off";
                            digitalWrite(outputPin2, LOW);
                                }
                    else if (request.indexOf("GET /18/on") &gt;= 0)
<span aria-label=" Page 338. " epub:type="pagebreak" id="pg_338" role="doc-pagebreak"/>                    {
                        // If request was IP address/18/on:
                        Serial.println("output 3 on");
                        outputPin3State = "On";
                        digitalWrite(outputPin3, HIGH);
                    } else if (request.indexOf("GET /18/off") &gt;= 0)
                    // If request was IP address/18/off:
                    {
                        Serial.println("output 3 off");
                        outputPin3State = "Off";
                        digitalWrite(outputPin3, LOW);
                    }
                    else if (request.indexOf("GET /19/on") &gt;= 0)
                    {
                        // If request was IP address/19/on:
                        Serial.println("output 4 on");
                        outputPin4State = "On";
                        digitalWrite(outputPin4, HIGH);
                    } else if (request.indexOf("GET /19/off") &gt;= 0)
                    // If request was IP address/19/off:
                    {
                        outputPin4State = "Off";
                        Serial.println("output 4 off");
                        digitalWrite(outputPin4, LOW);
                    }

                    // Build web page for display on browser:
                    client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;");
                    client.print("&lt;head&gt;&lt;meta name=\"viewport\" content=\"width=");
                    client.println("device-width, initial-scale=1\"&gt;");
                    client.println("&lt;link rel=\"icon\" href=\"data:,\"&gt;");
                    // Build buttons using CSS:
                    client.print("&lt;style&gt;html {font-family: Helvetica; display: inline-block;");
                    client.print("margin: 0px auto; text-align: center;} ");
                    client.print(".button {background-color: #ff0000; border: none; color: ");
                    client.print("white; padding: 8px 20px; ");
                    client.print("text-decoration: none; font-size: 20px; margin: 2px; ");
                    client.println("cursor: pointer; border-radius: 12px;} ");

                    client.println("&lt;/style&gt;&lt;/head&gt;");
                    // Now HTML for layout:
                    client.println("&lt;body&gt;&lt;h3&gt;Remote ESP32 Output Controls&lt;/h3&gt;");
                    client.println("&lt;p&gt;&lt;b&gt;Output 1 is ");
                    client.println(outputPin1State); <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
                    client.print(" - &lt;/b&gt;&lt;a href=\"/16/on\"&gt;&lt;button);
                    client.println("class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;");
                    client.print("&lt;a href=\"/16/off\"&gt;&lt;button");
                    client.println("class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                    client.println("&lt;p&gt;&lt;b&gt;Output 2 is ");
                    client.println(outputPin2State);
                    client.print(" - &lt;/b&gt;&lt;a href=\"/17/on\"&gt;&lt;button ");
                    client.println("class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;");
                    client.print("&lt;a href=\"/17/off\"&gt;&lt;button");
                    client.println("class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
<span aria-label=" Page 339. " epub:type="pagebreak" id="pg_339" role="doc-pagebreak"/>                    client.println("&lt;p&gt;&lt;b&gt;Output 3 is ");
                    client.println(outputPin3State);
                    client.print(" - &lt;/b&gt;&lt;a href=\"/18/on\"&gt;&lt;button ");
                    client.println("class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;");
                    client.print ("&lt;a href=\"/18/off\"&gt;&lt;button ");
                    client.println("class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                    client.println("&lt;p&gt;&lt;b&gt;Output 4 is ");
                    client.println(outputPin4State);
                    client.print(" - &lt;/b&gt;&lt;a href=\"/19/on\"&gt;&lt;button");
                    client.println("class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;");
                    client.print ("&lt;a href=\"/19/off\"&gt;&lt;button");
                    client.println(" class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                    client.println("&lt;/body&gt;&lt;/html&gt;");
                    // End the response to client request:
                    client.println();
                    break;
                } else
                {// If you got a newline, then clear currentLine
                    currentLine = " ";
                }
              } else if (c != '\r')
                {
                    currentLine += c;
                }
            }
        }
        request = " ";
        // Close connection to client:
        client.stop();
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">The framework for this project is the same as that of the previous project, except that it controls four GPIOs and eight buttons while keeping track of the GPIO status. The sketch uses four string variables to store the status of the four GPIO pins in text form, On or Off, declaring them with a default value of Off <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. To save confusion, the sketch also declares variables to give each GPIO pin a name instead of a number in the code <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It then sets the pins as outputs and to LOW <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">As there are now eight buttons and eight matching actions (on and off for each of the four GPIOs), there are eight client requests to look out for <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. After each action has taken place, the status of the matching GPIO is updated in its matching state variable <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. This occurs for all eight client request types.</p>
<p class="TX">Once again, the code uses many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions to create the HTML for the user interface. Functions like the one at <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> in the project code generate the HTML required to display the status of each GPIO pin. The sketch also attaches a hyperlink to each button (using <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;a href=</samp>) such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp> to turn GPIO 16 on, and so on.</p>
<p class="TX"><span aria-label=" Page 340. " epub:type="pagebreak" id="pg_340" role="doc-pagebreak"/>Here’s the full HTML code contained in the sketch:</p>

<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;
&lt;head&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;
&lt;link rel=\"icon\" href=\"data:,\"&gt;
&lt;style&gt;html {font-family: Helvetica; display: inline-block;
margin: 0px auto; text-align: center;}
".button {background-color: #ff0000; border: none; color: white; padding: 8px 20px;"
"text-decoration: none; font-size: 20px; margin: 2px; cursor: pointer; border-radius: 12px;}"
&lt;/style&gt;&lt;/head&gt;
&lt;body&gt;&lt;h3&gt;Remote ESP32 Output Controls&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Output 1 is "
// Insert outputPin1State:
" - &lt;/b&gt;&lt;a href=\"/16/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;
&lt;a href=\"/16/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Output 2 is "
// Insert outputPin2State:
" - &lt;/b&gt;&lt;a href=\"/17/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;
&lt;a href=\"/17/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Output 3 is "
// Insert outputPin3State:
" - &lt;/b&gt;&lt;a href=\"/18/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;"
"&lt;a href=\"/18/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Output 4 is ");
// Insert outputPin4State:
" - &lt;/b&gt;&lt;a href=\"/19/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;
&lt;a href=\"/19/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</code></pre>

<p class="TX">I encourage you to experiment with the buttons—changing their size, shape, the URLs attached to them, and so on—to help you master the process of building an interface.</p>
<p class="TX">Keep this project’s circuit assembled. You’ll use it in the next section to learn about using pulse-width modulation on the ESP32 dev board.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h2 class="H1" id="sec8"><span id="h1-145"/><samp class="SANS_Futura_Std_Bold_B_11">Pulse-Width Modulation</samp></h2>
<p class="TNI">Just like with the usual Arduino and compatible boards, the ESP32 dev board offers pulse-width modulation (PWM) with all the GPIO pins on the ESP32 dev board. PWM allows you to control the perceived brightness of an LED, instead of simply switching it on and off. The LED’s brightness is determined by the duty cycle, or the length of time the GPIO pin is on (so the LED is lit) versus the length of time it is off (the LED is unlit).</p>
<p class="TX">Duty cycle is expressed as the percentage of time the pin is on in each <i>cycle</i>, the fixed period of time in which the pin can be on or off. The greater the duty cycle, the greater the perceived brightness of the LED connected to the pin. Furthermore, the higher the frequency of the PWM signal—that is, the faster the signal is turned on and off—the smoother the visual effect. If you’re controlling a motor, a higher PWM frequency makes the rotational speed a closer approximation of the actual speed required.</p>
<p class="TX"><span aria-label=" Page 341. " epub:type="pagebreak" id="pg_341" role="doc-pagebreak"/><a href="chapter19.xhtml#fig19-13">Figure 19-13</a> shows four possible PWM duty cycles. The filled-in gray areas represent the amount of time that the LED is on; as you can see, this increases with the duty cycle.</p>
<figure class="IMG"><img alt="A DIAGRAM EXPLAINING THE PWM DUTY CYCLE WIDTHS" class="img8" id="fig19-13" src="../images/fig19-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-13: Various PWM duty cycles</samp></p></figcaption>
</figure>
<p class="TX">The ESP32 module has 16 PWM channels (numbered 0 to 15). You can direct each channel to a GPIO pin. To do so, you must add two lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> for each pin you want to use. The first line is</p>

<pre><code>ledcSetup(<var>channel</var>, <var>frequency</var>, <var>resolution</var>);
</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp> is the PWM channel to use (0 through 15), <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp> is the PWM frequency, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp> is the detail for the duty cycle. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>, I suggest 5,000 for 5 kHz. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>, use 8 for 8-bit resolution, giving you a value of between 0 and 255 for the duty cycle (the same way you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">analogWrite()</samp> when using an Arduino or compatible board).</p>
<p class="TX">The second line required is</p>

<pre><code>ledcAttachPin(<var>GPIO</var>, <var>channel</var>);
</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is the number of the GPIO pin to use, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp> is the PWM channel to use, as defined in the previous line of code.</p>
<p class="TX">Finally, to activate PWM on the GPIO, use</p>

<pre><code>ledcWrite(<var>channel</var>, <var>dutyCycle</var>);
</code></pre>

<p class="BodyContinued"><span aria-label=" Page 342. " epub:type="pagebreak" id="pg_342" role="doc-pagebreak"/>where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp> is the PWM channel to control, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dutyCycle</samp> is, of course, the duty cycle.</p>
<p class="TX">To stop using PWM on a particular GPIO pin and instead use it as a digital input or output, use</p>

<pre><code>ledcDetachPin(<var>GPIO</var>);
</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is the number of the GPIO pin (not the PWM channel).</p>
<p class="TX">You can test PWM and experiment with these parameters with the following sketch, which uses the same four-LED circuit you’ve used throughout this chapter. A moment after you enter and upload <a href="#LiT-19-2">Listing 19-2</a>, all four LEDs should use PWM to exhibit a “breathing” effect by using increasing and then decreasing values for the duty cycle.</p>
<span id="LiT-19-2"/>

<pre><code>void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> ledcSetup(0, 5000, 8); // LED channel, frequency, resolution (8-bit)
    ledcSetup(1, 5000, 8);
    ledcSetup(2, 5000, 8);
    ledcSetup(3, 5000, 8);

  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> ledcAttachPin(16, 0); // GPIO, LED channel
    ledcAttachPin(17, 1);
    ledcAttachPin(18, 2);
    ledcAttachPin(19, 3);
}

void loop()
{
    int dutyCycle;
    for (dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++)
    {
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> ledcWrite(0, dutyCycle);
        ledcWrite(1, dutyCycle);
        ledcWrite(2, dutyCycle);
        ledcWrite(3, dutyCycle);
        delay(10);
    }
    for (dutyCycle = 255; dutyCycle &gt; −0; dutyCycle--)
    {
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> ledcWrite(0, dutyCycle);
        ledcWrite(1, dutyCycle);
        ledcWrite(2, dutyCycle);
        ledcWrite(3, dutyCycle);
        delay(10);
    }
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: Testing PWM outputs</samp></p>
<p class="TX">This sketch demonstrates the three relevant lines for using PWM, setting up the required PWM channels <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and then attaching those channels <span aria-label=" Page 343. " epub:type="pagebreak" id="pg_343" role="doc-pagebreak"/>to GPIO pins <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This allows the duty cycles to be set for each of the pins at an increasing <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and decreasing <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> level.</p>
<p class="TX">You’ll put this technique to use in the next project.</p>
<p class="HeadProject"><span id="h1-146"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #57: Building a Hosted Web Page for a User Interface</samp></p>
<p class="TNI">This project synthesizes everything you’ve learned in this chapter: using an ESP32 dev board to control a GPIO via Wi-Fi, using PWM for various output levels, and building a hosted web page for a user interface. You can use this as a framework to build projects that require PWM control, such as LED lighting effects, controlling DC motors via MOSFETs, or experimenting with sound effects from a distance.</p>
<p class="TX">This project uses the same circuit as in previous projects, with only one LED connected to GPIO16 being controlled. Once the circuit is ready and the ESP32 dev board has been connected to the PC, upload the Project #57 sketch. A moment after that, determine the project’s IP address as usual with the Serial Monitor and then enter that address into your web browser. The browser should display the project interface, as shown in <a href="chapter19.xhtml#fig19-14">Figure 19-14</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #57" class="img7" id="fig19-14" src="../images/fig19-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-14: The user interface for Project #57</samp></p></figcaption>
</figure>
<p class="TX">You should be able to turn the LED on and off with the appropriate buttons as usual. This time, though, you can also decrease or increase the duty cycle one step at a time with the DC<span class="symbol">−</span> and DC+ buttons. You can click the second row of four additional buttons to give the duty cycle a preset value, and the line of text beneath them shows the current duty cycle value. For example, <a href="chapter19.xhtml#fig19-14">Figure 19-14</a> shows the LED as off (as the duty cycle is 0), while in <a href="chapter19.xhtml#fig19-15">Figure 19-15</a>, the LED is on with a duty cycle of 72/255.<span aria-label=" Page 344. " epub:type="pagebreak" id="pg_344" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF THE WEB CONTROL INTERFACE WITH THE DUTY CYCLE SET TO 72/255" class="img7" id="fig19-15" src="../images/fig19-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-15: The user interface with the duty cycle set to 72/255</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-57"/>

<pre><code>// Project #57 - ESP32 Remote Control PWM Output

#include &lt;WiFi.h&gt;
WiFiServer server(80); // Set webserver port to 80

// Store your Wi-Fi network credentials:
char* ssid = "<var>name</var>"; // Insert name of Wi-Fi access point
char* password = "<var>password</var>"; // Insert password

int outputPin1 = 16;
int dutyCycle = 0; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
String request; // Stores HTTP request from client (web browser)

unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000; // Allowed client connection time

void pinOff()
{
    ledcDetachPin(16); // Disconnect from PWM
    digitalWrite(16, LOW); // Pin off
}

void pinOn()
{
    ledcDetachPin(16); // Disconnect from PWM
    digitalWrite(16, HIGH); // Usual turn pin on
}

void pinPWM(int dc)
{
<span aria-label=" Page 345. " epub:type="pagebreak" id="pg_345" role="doc-pagebreak"/>    // Set up digital pin for PWM:
    ledcSetup(0, 5000, 8); // LED channel, frequency, resolution (8-bit)
    ledcAttachPin(16, 0);  // Attach PWM — GPIO, LED channel
    ledcWrite(0, dc);      // Set duty cycle
}

void setup()
{
    Serial.begin(115200);
    pinMode(16, OUTPUT);
    pinOff(); <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>

    // Connect to Wi-Fi network:
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED)
    // Show indicator while waiting for connection:
    {
        delay(500);
        Serial.print("~");
    }
    Serial.println(); // Display local IP address on Serial Monitor
    Serial.print("Connected, IP address: ");
    Serial.println(WiFi.localIP());
    // Start web server:
    server.begin();
}

void loop()
{
    // Listen for incoming clients from web browser:
    WiFiClient client = server.available();
    if (client) // If a request received
    {
        currentTime = millis();
        previousTime = currentTime;
        Serial.println("New client connected");
        String currentLine = " ";
        while (client.connected() &amp;&amp; currentTime—previousTime &lt;= timeoutTime)
        {// Stay connected for timeoutTime
            currentTime = millis();
            if (client.available())
            {
                char c = client.read(); // Display data from client on Serial Monitor
                Serial.write(c);
                request += c;
                if (c == '\n') // Client request has finished
                {
                    if (currentLine.length() == 0)
                    {
                        // Send HTTP response back to client:
                        client.println("HTTP/1.1 200 OK");
<span aria-label=" Page 346. " epub:type="pagebreak" id="pg_346" role="doc-pagebreak"/>                        client.println("Content-type:text/html");
                        client.println("Connection: close");
                        client.println();

                        // Now do things based on the client request:
                        if (request.indexOf("GET /off") &gt;= 0)
                        {
                            // If request was IP address/off:
                            pinOff(); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
                            dutyCycle = 0;
                        } else if (request.indexOf("GET /dcdown") &gt;= 0)
                        // If request was reduced duty cycle:
                        {
                            if (dutyCycle &gt;= 2) <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                            {
                                pinPWM(dutyCycle − 1);
                                dutyCycle−−;
                            } else if (dutyCycle &lt;= 1)
                            {
                                pinOff();
                                dutyCycle = 0;
                            }

                        } else if (request.indexOf("GET /dcup") &gt;= 0) <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
                        {
                            // If request was increased duty cycle:
                            if (dutyCycle &gt; 253)
                            {
                                pinOn();
                                dutyCycle = 255;
                            }
                            else if (dutyCycle &lt;= 253)
                            {
                                pinPWM(dutyCycle + 1);
                                dutyCycle++;
                            }

                        } else if (request.indexOf("GET /on") &gt;= 0) <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
                        // If request was IP address/on:
                        {
                            pinOn();
                            dutyCycle = 255;
                        }
                        else if (request.indexOf("GET /35") &gt;= 0) <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
                        {
                            // If request was IP address/35:
                            pinPWM(35);
                            dutyCycle = 35;
                        } else if (request.indexOf("GET /50") &gt;= 0)
                        // If request was IP address/50:
                        {
                            pinPWM(50);
<span aria-label=" Page 347. " epub:type="pagebreak" id="pg_347" role="doc-pagebreak"/>                            dutyCycle = 50;
                        }
                        else if (request.indexOf("GET /65") &gt;= 0)
                        {
                            // If request was IP address/65:
                            pinPWM(65);
                            dutyCycle = 65;
                        } else if (request.indexOf("GET /75") &gt;= 0)
                        // If request was IP address/75:
                        {
                            pinPWM(75);
                            dutyCycle = 75;
                        }

                        // Build web page for display on browser:
                        client.println("&lt;!DOCTYPE html&gt;&lt;html&gt;");
                        client.print("&lt;head&gt;&lt;meta name=\"viewport\" content=\"width=device-width");
                        client.println(", initial-scale=1\"&gt;");
                        client.println("&lt;link rel=\"icon\" href=\"data:,\"&gt;");
                        // Build buttons using CSS:
                        client.print("&lt;style&gt;html {font-family: Helvetica; display: inline-block; ");
                        client.println("margin: 0px auto; text-align: center;}");
                        client.print(".button {background-color: #ff0000; border: none; color: ");
                        client.println("white; padding: 8px 20px;");
                        client.print("text-decoration: none; font-size: 20px; margin: 2px; cursor: ");
                        client.println("pointer; border-radius: 12px;}");
                        client.println("&lt;/style&gt;&lt;/head&gt;");
                        // Now HTML for layout:
                        client.println("&lt;body&gt;&lt;h3&gt;Remote ESP32 PWM Control&lt;/h3&gt;");
                        client.println("&lt;p&gt;&lt;a href=\"/off\"&gt;&lt;button class=\"button\"&gt;Off&lt;/button&gt;&lt;/a&gt;");
                        client.print("&lt;a href=\"/dcdown\"&gt;&lt;button class=\"button\"&gt; ");
                        client.println("DC -&lt;/button&gt;&lt;/a&gt;");
                        client.println(" &lt;a href=\"/dcup\"&gt;&lt;button class=\"button\"&gt;DC +&lt;/button&gt;&lt;/a&gt;");
                        client.println(" &lt;a href=\"/on\"&gt;&lt;button class=\"button\"&gt;On&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                        client.println("&lt;p&gt;&lt;a href=\"/35\"&gt;&lt;button class=\"button\"&gt;35&lt;/button&gt;&lt;/a&gt;");
                        client.println(" &lt;a href=\"/50\"&gt;&lt;button class=\"button\"&gt;50&lt;/button&gt;&lt;/a&gt;");
                        client.println(" &lt;a href=\"/60\"&gt;&lt;button class=\"button\"&gt;65&lt;/button&gt;&lt;/a&gt;");
                        client.println(" &lt;a href=\"/75\"&gt;&lt;button class=\"button\"&gt;75&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;");
                        client.println(" Duty cycle is set to ");
                        client.println(dutyCycle);
                        client.println("/255&lt;/p&gt;");
<span aria-label=" Page 348. " epub:type="pagebreak" id="pg_348" role="doc-pagebreak"/>                        client.println("&lt;/body&gt;&lt;/html&gt;");
                        // End the response to client request
                        client.println();
                        break;
                    } else {// If you got a newline, then clear currentLine
                    currentLine = " ";
                    }
                } else if (c != '\r')
                {
                    currentLine += c;
                }
            }
        }
        request = " ";
        // Close connection to client:
        client.stop();
        Serial.println("Disconnected.");
    }
}</code></pre>

<p class="TX">The operation of this project is similar to that of the previous projects, but with more buttons and a different type of status display.</p>
<p class="TX">When the user changes the duty cycle of the PWM output, that value is stored in an integer variable <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp> function is called when the user clicks the Off button. Since you can’t set PWM to 0 duty cycle to turn off the GPIO output, this function detaches the PWM channel from the GPIO pin and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> to turn off the GPIO pin. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp> function does the opposite; since you can’t set the PWM to full-on, this function detaches the PWM channel and then turns the GPIO pin on using <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>.</p>
<p class="TX">The sketch uses the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PWM(int dc)</samp> function to activate PWM, attach a PWM channel to the GPIO pin, and set the required duty cycle, passed in via the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">dc</samp>. When you first start the project or reset it, the sketch turns the GPIO pin off <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, the sketch reviews client requests. If the user presses the Off button to turn off the GPIO pin off, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp> variable to 0 for display purposes on the interface. If the user presses the DC button <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, the duty cycle decreases by 1. If this would cause the duty cycle to fall below 1, the GPIO is switched off instead using <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>. Likewise, if the user presses the DC+ button <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the duty cycle increases by 1. If this would push the cycle beyond 254, the sketch instead turns on GPIO using <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>. Pressing the On button <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp> function and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp> variable to 255 for display purposes on the interface.</p>
<p class="TX">The four final buttons <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> set the duty cycle to preset levels. They’re just examples to give you an idea of what is possible. Each request simply sets the PWM value via <samp class="SANS_TheSansMonoCd_W5Regular_11">pinPWM()</samp> and then updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp> variable accordingly.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h1-147"/><span aria-label=" Page 349. " epub:type="pagebreak" id="pg_349" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter demonstrated how to remotely control your ESP32 dev board over the internet via web pages designed to your specifications. Rather than controlling operations, you can also simply display data generated via the ESP32 on a web page for remote viewing, such as data from a sensor.</p>
<p class="TX">You’ll continue to use your ESP32 in the following chapters. In the next, you’ll learn to control it by interacting with social media.</p>
</section>
</section>
</body>
</html>