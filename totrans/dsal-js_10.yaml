- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 8 SHUFFLING AND SAMPLING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider this chapter to be a complement of the two previous chapters, but instead
    of sorting values into some kind of order, you want to shuffle them into a random,
    disordered sequence (as for a card game). And rather than select a value at a
    given position, you want to choose a set of values randomly (as for statistical
    sampling algorithms). [Chapters 6](chapter6.xhtml) and [7](chapter7.xhtml) revolved
    around order and consistency, but this chapter works with disorder and randomness
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '### Choosing Numbers Randomly'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider a basic function that you’ll need to use throughout this chapter:
    generating a random number in a given interval. JavaScript already provides Math.random(),
    which produces a pseudorandom number *r* such that 0 ≤ *r* < 1\. (For more information,
    see *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random.).*)
    The distribution of the numbers this function produces is *uniform*, which means
    that each value is equally possible, and no value is more likely than another.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Why is it pseudorandom? The random numbers are actually produced by an algorithm
    in such a way that the properties of the generated sequence are approximately
    that of a sequence of truly random numbers. However, the fact that the numbers
    are generated by a procedure automatically means that they aren’t truly random;
    they just look like they are. For the sake of simplicity, though, in this chapter
    we’ll consider the produced numbers to be random.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this function, you can scale its results to produce numbers in any given
    range. The following functions will come in handy for the rest of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function is useful when you want to decide between two alternatives
    randomly, as if simulating a coin toss. If a random number is less than 0.5 (0
    to 0.4999 ...), you return false (heads), and you return true (tails) otherwise
    (0.5 to 0.9999 ...). Given a range of values from *a* to *b* (not necessarily
    integers, but *a* < *b*), the second function produces a random floating-point
    number *r* such that *a* < *r* < *b*. This is easily verified by noting that (b
    - a)*Math.random() is greater than or equal to zero but strictly less than (b
    - a). The last function is meant to be called with integer arguments, and it produces
    a random integer *r* such that *a* < *r* < *b*. You can also write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some people have difficulty with randomInt(...). For instance, to simulate
    rolling a die, they might write randomInt(1,6), but that won’t work: randomInt(1,7)
    does the job. (See question 8.2 for another take on this.) You could obviously
    rewrite randomInt(...) to do it another way, but you’re following JavaScript’s
    lead as in the array.slice(start,end) method, whose parameters work exactly as
    these do, taking elements from start up to (but not including) end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these basic tools, let’s turn to the problems of shuffling and sampling,
    both of which will be based on random numbers in one way or another.  ### Shuffling'
  prefs: []
  type: TYPE_NORMAL
- en: The first problem we’ll consider is *shuffling* an array of values in order
    to produce a random sequence of values—or to use a mathematical term, a permutation.
    This is equivalent to shuffling a deck of cards before playing a game to start
    anew with a different sequence of cards every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important requisite is that every possible permutation should be equally
    likely, which presents a thorny problem: How can you make sure that the shuffling
    code ran correctly? For instance, when sorting an array, you can check that the
    sorted array is actually in order and that its elements are the same before and
    after sorting. Similarly, for selection algorithms, you can check that it worked
    by sorting the array separately and then checking whether the selected value is
    correct. Shuffling is harder to check.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you should prove (somehow) that the logic is correct so that all results
    are equally probable. However, what if you implement the algorithm badly, with
    some bug? (Don’t ask me how I know.) An empirical suggestion is to run the algorithm
    many times with a known input sequence and test statistically whether the observed
    outcomes suggest a uniform distribution; we’ll leave the mathematical aspects
    of this solution to the textbooks and instead try an easier way (see question
    8.1).
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling by Sorting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start with a sorting-based algorithm. It doesn’t have the best performance,
    but it’s the simplest implementation. In order to shuffle a set of values, you
    associate a random number with each value, sort the set on that random value,
    and the result will be a totally random shuffle (see [Figure 8-1](chapter8.xhtml#fig8-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Sorting an array by a randomly assigned key produces a totally
    random shuffle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement this solution with any of the algorithms discussed in [Chapter
    6](chapter6.xhtml). Let’s go the simplest possible direction and use JavaScript’s
    own .sort(...) method. The shuffle code ends up being a single line, even though
    more lines are used here to show it clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code directly matches the steps in [Figure 8-1](chapter8.xhtml#fig8-1).
    Given the array of values, create a new array where objects have the original
    value in val and a random value in key ❶. Then sort it by this random key ❷ and
    produce a new array with only the values ❸.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is probably the shortest one in the book, and it produces a shuffled
    list of values easily. However, it’s easy to make a mistake when implementing
    random sorting (see question 8.3 for an example).
  prefs: []
  type: TYPE_NORMAL
- en: The performance of this code is *O*(*n* log *n*), but you can do better. First,
    however, we’ll consider something you could have designed based on an interesting
    mix of concepts from [Chapters 5](chapter5.xhtml) and [6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling by Coin Tossing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s explore other ways to shuffle a set of values. Imagine a divide-and-conquer
    procedure where you split a set in two (using a simulated coin toss to decide
    what goes where), recursively shuffle each part, and join them back together.
    Empty sets or sets with only one element would need no shuffling. You can shuffle
    a set with exactly two elements by randomly deciding (again, tossing a coin) which
    elements will be first and last. For sets with more than two elements, apply the
    recursive procedure illustrated in [Figure 8-2](chapter8.xhtml#fig8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Randomly splitting an array, shuffling each part, and joining the
    results produces a shuffle that’s reminiscent of merge sort.'
  prefs: []
  type: TYPE_NORMAL
- en: The first split at the top separates the array into two parts with five and
    three elements. The subsequent steps follow moving downward. The five-element
    array splits into arrays with one and four elements. The single element doesn’t
    need any further shuffling, and the array with elements splits into two parts.
    Of those two parts, one is left as is (12, 60), and the other is swapped. The
    joined pairs create a random shuffle of the original four-element array, which
    then joins with the single element (22) to produce a random shuffle of the initial
    five-element array. A similar process occurs on the right side of the array, and
    the final result is at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for shuffling functions will be an array arr and the portion
    of it (from, to) you are shuffling ❶. If the length of the array is less than
    2 ❷, nothing needs to be done. If the array has exactly two elements ❸, flip a
    coin to decide whether to leave it be or swap the two elements. If the array has
    more than two elements ❹, apply a logic reminiscent of partitioning in quicksort:
    flip coins to decide where each value goes. If the coin flip is true, the value
    goes into the ind1 to to section, and if the coin flip is false, the value goes
    in the from to ind0 section. After moving every element to its place (at which
    time ind0 and ind1 will point to positions next to each other), use recursion
    to shuffle the elements that received a false bit ❺ and those that got a true
    bit ❻. Finally, return the shuffled-in-place array ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm can be proven to have an average *O*(*n* log *n*) performance
    with a worst case of *O*(*n*²). [Figure 8-2](chapter8.xhtml#fig8-2) should remind
    you of merge sort and quicksort, algorithms with similar workings, so you haven’t
    really done better than with sorting.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Shuffling in Linear Time'
  prefs: []
  type: TYPE_NORMAL
- en: How fast can we shuffle? The best possible result with shuffling is *O*(*n*),
    where you access each element in the array once. All the methods in the previous
    section had worse performance (although for small values of *n* they may be quite
    suitable), so now you’re going to consider linear time shuffling algorithms. And
    to better match what we did in [Chapter 6](chapter6.xhtml), we’ll shuffle just
    a portion of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Floyd’s Shuffle
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Robert Floyd’s linear time shuffling algorithm has some interesting ideas.
    The process has two steps: first, it generates a random permutation of numbers
    0 to *n* – 1, and then it uses that generated permutation to shuffle the original
    array. (You’ll also see this technique in Floyd’s sampling algorithm, later in
    this chapter.) Start by generating the permutation, which is similar to an insertion
    sort (see [Figure 8-3](chapter8.xhtml#fig8-3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Floyd’s algorithm produces a shuffle by randomly inserting new
    values into the previously shuffled ones.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works the same way as arranging playing cards by hand. You pick
    the first card, and that’s it. Then you pick the second card and place it to the
    left or to the right of the previous one. Then pick the third card and place it
    to the left, in the middle, or to the right of the previous two cards. Each new
    card goes somewhere among the previous cards, in a random place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For a simple implementation ❶, you can use an array for the generated shuffle.
    First loop n times starting at 0 ❷, and each time you generate a random position
    ❸ where you insert the new number among the previous ones ❹ by using the very
    handy .splice(...) method.
  prefs: []
  type: TYPE_NORMAL
- en: But how do you get from this permutation to a shuffle of the original array?
    [Figure 8-4](chapter8.xhtml#fig8-4) shows how to use the previous result to finish
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: A random permutation of numbers is used to shuffle an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element of the original array gets moved to a different place, according
    to the corresponding value that floydShuffleN(...) produces. Implementing the
    moves requires an extra array. Having generated a shuffled list of numbers from
    0 to *n* – 1, here’s the code to finish shuffling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First generate a sample of numbers the same size as the portion of the array
    that you want to shuffle ❶, and then take the values in the input array ❷ and
    replace them according to the method ❸ shown in [Figure 8-3](chapter8.xhtml#fig8-3).
  prefs: []
  type: TYPE_NORMAL
- en: How the code performs depends on what data structure you choose for the sample.
    Using an array as shown here means that insertion .splice(...) is *O*(*n*), so
    the whole algorithm becomes *O*(*n*²). You’ll see appropriate data structures
    in future chapters, but Floyd suggests using a hash table of size 2*n*, with entries
    forming a linked list, for an expected average O(*n*) performance, or a balanced
    ordered tree with linked nodes, for O(*n* log *n*) assured performance.
  prefs: []
  type: TYPE_NORMAL
- en: Robson’s Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here’s a different take on how to generate a permutation. With an array of *n*
    elements, there are *n*! possible shuffling outcomes. The idea in Robson’s algorithm
    is to randomly select a number between 0 and *n*! – 1 inclusive and use that number
    to generate a permutation, so each different number produces a different shuffle.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This method is related to a mathematical concept called the Lehmer code, which
    is a way to encode each possible permutation of n numbers, but we won’t go into
    that here.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to shuffle an array with four elements to produce a random permutation
    out of the 24 (= 4!) possible ones, you’d start with a random number between 0
    and 23 inclusive. Then divide that number by 4\. The quotient will be a number
    between 0 and 5, and the remainder will be between 0 and 3\. (An important detail
    is that all possible combinations of quotient and remainder are equally probable.
    Can you verify that?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the remainder to choose one of the four elements in the array, set it aside,
    and keep working with the other three. Consider the quotient: it’s a random value
    between 0 and 5.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, divide by 3\. The new quotient will be 0 or 1, and the remainder
    will be 0, 1, or 2, which you can use to choose one of the three remaining numbers.
    Consider the quotient, which is either 0 or 1\. If you divide the quotient you
    had by 2, you’ll get a quotient of 0 (no more work to be done). You can use the
    remainder (0 or 1) to choose one of the two remaining numbers, and you’ll have
    your desired shuffle. (After you’ve chosen 3 out of 4, the complete shuffle is
    implied.) [Figure 8-5](chapter8.xhtml#fig8-5) shows the algorithm if you had drawn
    14 as the random number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Robson’s shuffling algorithm is also based on transforming the
    original array depending on a randomly chosen permutation.'
  prefs: []
  type: TYPE_NORMAL
- en: Start with values ABCD in the four positions of the array, from 0 to 3\. In
    the first step, divide 14 by 4, getting a quotient of 3 and a remainder of 2\.
    Then swap the element in position 2 of the array with the last, getting ABDC.
    The second step divides 3 (the previous quotient) by 3, producing quotient 1 and
    remainder 0\. Then swap the element in position 0 with the next-to-last element,
    resulting in DBAC. Then, divide 1 (the latest quotient) by 2, which gives quotient
    0 and remainder 1\. You don’t need to swap, because you’d swap the element at
    position 1 with itself, and you’d still have DBAC. After having shuffled three
    of the elements of the array, the fourth is also in place, and you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of elements to shuffle is n ❶. You generate a random number ❷ between
    0 and *n*! – 1 using the factorial function developed in [Chapter 5](chapter5.xhtml).
    You then loop through the array from right to left ❸: calculate q ❹, use it to
    swap elements ❺, and find r to loop again ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is obviously *O*(*n*), as it follows from its single loop. However,
    as is, the algorithm has a problem. You wouldn’t be able to use it for large arrays,
    because calculating a factorial may exceed the available precision of JavaScript
    (see question 8.5). Fortunately, there’s a way out.
  prefs: []
  type: TYPE_NORMAL
- en: The Fisher-Yates Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The problem with Robson’s algorithm is the need to calculate *n*! to get a random
    number with which to proceed. But if you consider it carefully, you don’t really
    need the factorial. The key to that algorithm was the series of remainders, and
    you can generate those by using a random function. The first remainder was in
    the range 0 to *n* – 1, and it was used to choose the initial value of the permutation;
    the second remainder was in the range 0 to *n* – 2, and it was used to choose
    the second value of the permutation, and so on. It follows that you just need
    to generate random values at proper times in Robson’s algorithm, and that’s the
    Fisher-Yates algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, you can write this alternative to Robson’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As in Robson’s shuffle, loop from right to left ❶, and at each pass calculate
    a random number ❷ that you use to decide what elements to swap ❸. Basically, any
    element in positions from to i could be chosen for the swap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fisher-Yates algorithm is frequently written to shuffle from left to right,
    which is basically the same idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is the same ❶ except that the generated permutation starts from left
    to right, and any element in positions i to to ❷ may be chosen for swapping ❸.
    This algorithm is quite efficient, and it’s often used for shuffling. Be careful,
    though, because it’s easy to mess up; see question 8.4.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sampling is a technique frequently used in statistics. Basically, out of a
    set of values (an array), you want to pick a random, smaller set, which is called
    a *sample*. There are two kinds of sampling procedures: sampling with repetition,
    in which elements may be chosen more than once, and sampling without repetition,
    in which no element may be chosen two times or more. In mathematical terms, the
    latter procedure is called selecting a *combination* of elements. (In the first
    case, sampling with repetition, the number of chosen elements can be anything.
    In the second case, the number is limited by the number of elements in the original
    set.) Don’t worry about the order in which the elements are selected.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first consider sampling with repetition, for which we just need a couple
    of short, optimally efficient algorithms, and then we’ll dedicate most of the
    rest of the chapter to sampling without repetition, which requires more complex
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling with Repetition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sampling with repetition is a simple algorithm, and you’ll start by selecting
    just a single value. Choosing a larger sample will simply be a matter of choosing
    a value over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Only One Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Choosing a single value is the simplest kind of sampling, and all you need
    is a random number in the appropriate range. You can use the randomInt(...) function,
    and for an element of an array, the following works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To select an element between the from and to positions (both included), you
    produce a random number in that range and return the corresponding element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you always want to choose values from the whole array (as you’ll
    do in the rest of the chapter), simpler code does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to setting from = 0 and to = arr.length - 1, so this new
    function works in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Several Values with Repetition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As mentioned, to make multiple selections from a set (maybe to simulate a series
    of roulette wheel turns, or create a strategy for a game of rock/paper/scissors,
    or implement the lazy select median-finding algorithm from [Chapter 7](chapter7.xhtml)),
    doing several single selections is enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is simple: first loop k times ❶, randomly choosing elements one by
    one ❷. Again, as with choosing a single value, to make selections from an entire
    array, the code is simpler, and you can reuse the singlePickAll code from the
    previous section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For a related coding challenge, see question 8.7\. Next, take a look at sampling
    without repetition, which has the restrictions of not allowing you to choose any
    element more than once and doing so in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling Without Repetition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This process is equivalent to what’s used in Powerball-style lottery drawings:
    numbers are removed from (but not returned to) an urn, guaranteeing that all selected
    numbers are different.'
  prefs: []
  type: TYPE_NORMAL
- en: For the algorithms in this section, assume you have an array with *n* elements,
    from which you want to pick a combination of *k* elements. It must be *k* < *n*—if
    *k* were equal to *n*, no algorithm would be needed, and *k* cannot be greater
    than *n* if no repetitions are allowed. Algorithms will be faster the fewer elements
    that you want, so for a cheap optimization, you can assume that *k >*= *n*/2;
    indeed, if *k* ≥ *n*/2, instead of selecting *k* elements, you could select *n*
    – *k* ones and discard them.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling by Sorting or Shuffling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first idea is inspired by the “Shuffling by Sorting” section on page 139,
    plus the selection algorithm explored in [Chapter 7](chapter7.xhtml). You can
    assign random keys to all elements, sort them, and then get the elements with
    the lowest *k* keys. You’ve already considered all the necessary code to implement
    this method, so leave actual development to question 8.8.
  prefs: []
  type: TYPE_NORMAL
- en: A second idea you could try is based on the fact that you already know how to
    generate a random permutation of a set. Given this, an obvious way to generate
    a sample could easily be to shuffle the set and then take its first *k* elements.
    That works, but you can get the desired sample with more efficient logic without
    having to shuffle (similar to what you found with selection algorithms, when you
    saw better ways of selecting that didn’t require a previous sort). You won’t see
    the code for this procedure either, as it’s derived from what you’ve already done.
    Let’s move on to new algorithms instead.
  prefs: []
  type: TYPE_NORMAL
- en: Floyd’s Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often you just need a sample of *k* integers between 0 (included) and *n* (excluded).
    Robert Floyd’s floydSampleKofN(...) algorithm produces an array with a combination
    of *k* such numbers, which is interesting in itself and will help you write a
    more general sampling algorithm. If you need a sample from the original array,
    you can use the selected numbers produced by floydSampleKofN() for that task,
    as in [Figure 8-6](chapter8.xhtml#fig8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: A random selection of numbers from 0 to n – 1 produces a random
    sample.'
  prefs: []
  type: TYPE_NORMAL
- en: You can choose values from the original input array using the sample’s values
    as indices, as shown in [Figure 8-6](chapter8.xhtml#fig8-6). The input array is
    at the top, the sample produced by Floyd’s code is [5, 2, 3], and the final result
    is shaded in gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code that uses the (yet unseen) floydSampleKofN() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You generate a random combination of k values out of n ❶ and use those numbers
    as indices to get values from the original input array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to generating the combination and finally see floydSampleKofN().
    The recursive version is the following, and recursion helps you understand how
    and why the algorithm works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You want a combination of k distinct values between 0 and n - 1 inclusive ❶.
    If k is 0 ❷, you return an empty sample. Otherwise, you use recursion first to
    choose a combination of k - 1 values up to n - 2 ❸. Then decide what value to
    add to that sample ❹. At the end ❺, you return the created sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now examine how to add a new value to the sample, working with getting a sample
    of three values out of eight, as in [Figure 8-6](chapter8.xhtml#fig8-6). Suppose
    you already have a sample of two values out of the set 0 to 6: should you add
    a 7 value to produce the sample of three values? A possibility (1/8) is that the
    random number j is exactly 7\. It can’t be in the previous sample, so it will
    be added.'
  prefs: []
  type: TYPE_NORMAL
- en: The other way to add 7 is if j was one of the two numbers already in the sample
    (2/8). Thus, the probability that 7 will end up included in the sample of 3 out
    of 8 is 1/8 + 2/8, which is exactly 3/8 as you needed. You can apply this argument
    systematically and find that each of the *n* values has a probability of *k/n*
    of being in the final sample, so the algorithm really produces a correct sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since recursion always happens at the beginning of each pass, you can turn
    the code into an iterative equivalent version (see question 8.9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, create an array to return the chosen sample ❶, and you’ll return this
    at the end ❺. A loop executes k times ❷. In each pass choose a random number ❸
    and use the same logic (checking whether the randomly selected number was already
    selected) to decide what to add ❹. The argument to prove that this algorithm works
    correctly is along the same lines as for the recursive version, so it won’t be
    repeated here.
  prefs: []
  type: TYPE_NORMAL
- en: The key to performance for Floyd’s algorithm is how it adds a value to the sample
    and checks whether a given value is already in the sample. In other words, it
    needs an efficient implementation of a set. You also could use a bitmap as in
    [Chapters 6](chapter6.xhtml) and [7](chapter7.xhtml) (we’ll leave this for now
    and consider such options in [Chapter 13](chapter13.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Lottery Drawing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another method to consider implies actually replicating a lottery drawing. You
    choose a random element of the set, place it somewhere else, and do it again and
    again until you get the complete sample. [Figure 8-7](chapter8.xhtml#fig8-7) shows
    the process. The set of values is on the left, the selected sample is on the right,
    and the triangle marks the randomly chosen element at each stage.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: A simulated lottery drawing produces a random sample.'
  prefs: []
  type: TYPE_NORMAL
- en: When you remove an element, you swap it with the one in the last place of the
    array to avoid having to shift the whole array, which would slow the code’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Start by creating the array that will get the sample ❶. Loop k times ❷, generating
    a random position ❸ among the first n - i elements of the array, because the already
    sampled elements will go to the end of the array ❹. The chosen element is added
    to the sample array, and it’s swapped so it won’t be considered again in other
    selections ❺. Finally, return the produced sample ❻.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is simple enough, and it has *O*(*k*) performance that cannot
    be improved upon. After all, you want a sample with *k* elements. However, you
    can get a bit more speed if you notice that there’s no actual need for a separate
    sample array.
  prefs: []
  type: TYPE_NORMAL
- en: Fisher-Yates Sampling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the previous lottery sampling algorithm, at any time each element of the
    array is either chosen or not, so you don’t need two arrays. The original one
    will do. [Figure 8-8](chapter8.xhtml#fig8-8) illustrates this idea; the shaded
    numbers are the chosen ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: The lottery sampling algorithm can work in place, without extra
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time an element is chosen, move it to the front of the array, so all
    of its first elements are in the sample and the rest are the nonchosen ones. This
    algorithm is a variation of the Fisher-Yates shuffling method (the same logic
    but applied fewer times, because you don’t want to randomize the whole array;
    only k elements), and you can code it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this algorithm, the i variable points to the corresponding sampled element.
    You loop k times ❶, choosing a random position among the yet-unchosen elements
    ❷, and you do a swap to change the selected element from the unchosen part to
    the chosen one ❸. After completing the loop ❹, return the initial slice (k elements
    long) of the original array.
  prefs: []
  type: TYPE_NORMAL
- en: The Fisher-Yates sampling algorithm is also *O*(*k*); the only difference is
    where the sample is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth’s Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Donald Knuth’s algorithm has the interesting characteristic that the values
    in the sample keep their relative order as in the original array. The algorithm
    is based on probabilities, which directly proves its correctness.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how it works, suppose you want to choose three elements out of
    eight. The probability that the first element will be included is 3/8\. The probability
    that the second element will be chosen depends on whether the first element was
    chosen. If it was, the probability of choosing the second is 2/7 (because having
    selected one of the eight, now you choose two out of the remaining seven), but
    if skipped, the probability of choosing the second is 3/7 (because now you have
    to choose three elements out of the remaining seven).
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm chooses or skips elements based on random numbers and probabilities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to choose an empty sample ❶, an empty array is returned; this is
    the base case for the recursion. Otherwise, you get a random number and compare
    it with the probability: if it’s smaller ❷, you include the first element of the
    array followed by a k – 1 sized sample of the rest. If it’s greater ❸, you select
    all k elements out of the rest of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation avoids recursion and all the destructuring and slicing
    of arrays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As in other algorithms, sample is the array that will be produced ❶. The variables
    toSelect ❷ and toConsider ❸ will keep count of how many values you still have
    to select out of the values not yet considered. You loop until there are no more
    values to choose ❹. Each time, you decide whether to choose or ignore a value,
    according to the probabilistic method described. If the test comes out true ❺,
    add the value to the sample array and decrease the count of pending values to
    select by 1\. Every pass through the loop, we decrease the number of values to
    yet consider ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write it in a more compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that you’ll use k ❶ instead of a toSelect variable ❸, and
    you’ll calculate how many yet-unseen values there are ❷; otherwise, the algorithm
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Reservoir Sampling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final algorithm we’ll consider was created by Alan Waterman, and it’s interesting
    because it can work in an online mode, without needing the whole array of elements
    beforehand. All the other algorithms in this chapter work in offline mode. The
    code goes through the input data, maintaining a suitable random sample at all
    times; it can be stopped at any moment and would have a proper random sample of
    the elements seen so far. This algorithm is quite suitable for large streams,
    where it might be impossible to store all values in memory and then apply one
    of the previous algorithms considered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple case first: choosing just one element out of a sequence of
    undetermined length. (If you knew the length of the sequence, using randomInt(...)
    would be the quickest way to pick an element.) The solution to this problem works
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the first element of the sequence and place it in a reservoir.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the *i*th element in the sequence after the first, use it to replace the
    reservoir value with probability of 1/*i.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose the sequence had 1,000 elements. What’s the probability of choosing
    the very last element? Obviously, it’s 1/1,000\. If you didn’t choose it, when
    you have 999 elements, what’s the probability of choosing the 999th? It would
    be 1/999\. As more and more elements are processed, the probability of choosing
    the *i*th one is always 1/*i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can expand this example to choose a sample of *k* elements; the process
    is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the first *k* elements of the sequence and place them in a reservoir.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the *i*th element in the sequence after those *k*, add it to the reservoir
    value with a probability of *k*/*i* by replacing a randomly selected value of
    the reservoir.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can code this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We won’t work with a stream, but the changes for that are straightforward. Here,
    to know when the sequence is ended you’ll use variable n ❶, and the sample reservoir
    is initialized with the first k elements of the sequence ❷. You loop through the
    data ❸ and do a random test ❹ to see whether the number should go into the array;
    the j variable is used both for the test and to randomly decide what reservoir
    element to replace ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you modify the input array (using its first *k* positions for the reservoir),
    the algorithm looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The differences are how you swap a chosen value into the reservoir ❶ and how
    you return the chosen sample ❷; otherwise, it functions exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter we’ve considered algorithms for generating randomized permutations
    and combinations of an array, methods that are quite useful for several areas
    like gaming or statistics, among others. In the next chapter, we’ll turn to another
    common and important task: searching efficiently for a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**8.1  Good Enough Shuffling**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a logging function that takes a shuffling function as input and runs
    many tests, counting how often each possible permutation is produced, and then
    draw a histogram to visualize its results.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-9](chapter8.xhtml#fig8-9) shows the output from my own tests with
    good results for a shuffle of an array of four elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: A histogram showing that a certain shuffling algorithm produces
    all possible outcomes with similar frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: After 48,000 random tries, all permutations (24 = 4!) were generated, and the
    results seem similar enough. Although this assertion isn’t really valid in a statistical
    way; a χ² (that’s the Greek letter chi) goodness-of-fit test would be required
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2  Random Roll**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have to generate a uniform random triple option: instead of true/false,
    say high/medium/low. Using Math.random(), it’s easy to do, as seen in the randomNum(...)
    function, but can you do this using only randomBit()? Along the same lines, how
    can you generate a uniform die roll (1–6) using randomBit()? Or a 1 to 20 roll
    for a *Dungeons & Dragons* type of game? (This last question is trickier.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3  Not-So-Random Shuffling**'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading the description for random shuffling, a programmer decides to
    make it simpler: instead of bothering to assign random keys and sorting by them,
    the programmer took a sorting algorithm (bubble sort, in this case) and changed
    the comparisons among keys to use a random bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The logic is that of bubble sort (see [Chapter 6](chapter6.xhtml)) but with
    a single change ❶. Why is this a bad shuffle generator? Where did the programmer
    go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4  Bad Swapping Shuffle**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer messed up when implementing the Fisher-Yates shuffling code and
    wrote the following, which seems good enough at first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The difference is in the line in bold. You always choose a random place from
    the complete array. What’s wrong with this code?
  prefs: []
  type: TYPE_NORMAL
- en: '**8.5  Robson’s Top?**'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the maximum length of array that you can shuffle using Robson’s algorithm?
    Be careful; the answer is tricky.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6  Sampling Testing**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you develop something to visually validate sampling functions, along the
    lines of what was required in question 8.1?
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7  Single-Line Repeater**'
  prefs: []
  type: TYPE_NORMAL
- en: A reviewer of the draft for this chapter mentioned that repeatedPick(...), as
    shown in the “Choosing Several Values with Repetition” section on page 147, could
    be written as a single line, in just one statement. What would it be?
  prefs: []
  type: TYPE_NORMAL
- en: '**8.8  Sort to Sample**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the algorithm described in the section “Sampling by Sorting or Shuffling”
    on page 148.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.9  Iterate, Don’t Recurse**'
  prefs: []
  type: TYPE_NORMAL
- en: A recursive function along the lines of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'can be written equivalently in an iterative fashion as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Explain why this works. Also, try this conversion for the factorial(...) function
    from [Chapter 5](chapter5.xhtml) and adapt it for Floyd’s sampleKofN(...) algorithm
    (which will be trickier) to verify what was shown in the text.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.10  No Limits?**'
  prefs: []
  type: TYPE_NORMAL
- en: In Knuth’s sample code, there’s no check to see whether i goes out of bounds;
    why isn’t it needed?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
