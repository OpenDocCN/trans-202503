["```\n❶ XI = [\"send\", None]\n❷ k = 10\nn = 10\nout_deg = G.out_degree()\nvalkey_sorted = sorted(out_deg, key=lambda x: (x[1], x[0]))\n❸ S0 = valkey_sorted[-1][0]\n```", "```\nfrom random import choice\n❶ R = []\n❷ for i in range(k):\n  ❸ message_at = S0\n    Tn = []\n  ❹ for j in range(n):\n        if choice(XI) is not None:\n          ❺ gamma_uq = list(nx.neighbors(G, message_at))\n          ❻ if len(gamma_uq) > 1:\n                vq = choice(gamma_uq)\n                Tn.append((message_at, vq))\n                message_at = vq\n            elif len(gamma_uq) == 1:\n vq = gamma_uq[0]\n                Tn.append((message_at, vq))\n                message_at = vq\n          ❼ else:\n                conc = \"Message terminated at node %s in %d steps\"\n                print( conc % (message_at, len(Tn)))\n                break\n  ❽ R.append((message_at, Tn))\ntot = 0\n❾ for end, path in R:\n    uniq = unique(path)\n    tot = len(uniq) - 1\n❿ print(S0, (tot / len(R)) / (len(G.nodes.keys()) - 1))\n```", "```\nimport graph_funcs as ext\nqx = \"environment\"\n❶ hG = term_subgraph(qx, post_df)\nhub_scores, auth_scores = nx.hits(hG, max_iter=1000, tol=0.01)\nhub_max = max(hub_scores.values())\nS0_i = list(hub_scores.values()).index(hub_max)\n❷ S0 = list(hub_scores.keys())[S0_i]\n\nfor i in range(k):\n    uq = S0\n    Tn = []\n    for j in range(n):\n      ❸ send_msg = ext.hub_send(hub_scores[uq])\n        if send_msg:\n          ❹ vq = ext.scored_neighbor_select(hG, uq, auth_scores)\n            if vq is None:\n                conc = \"Message terminated at node %s in %d steps\"\n                print( conc % (uq, len(Tn)))\n                break\n            else:\n                Tn.append((uq, vq))\n              ❺ uq = vq\n    R.append((uq, Tn))\nended_at = {}\n❻ for end, path in R:\n    if end in ended_at.keys():\n        ended_at[end] += 1\n    else:\n        ended_at[end] = 1\nreturn (S0, ended_at)\n```", "```\nall_runs = {}\nstarted_at = \"\"\n❶ for run_i in range(0, 10):\n  ❷ started_at, results = run_sim([\"environment\"], post_df)\n  ❸ for ks in results:\n        if ks in all_runs.keys():\n            all_runs[ks] += results[ks]\n else:\n            all_runs[ks] = results[ks]\n❹ for node in all_runs.keys():\n    if node != started_at:\n        print(\"%s influenced %s an average of %.2f times\" % (\n            started_at, node, all_runs[node]/10\n        ))\n```", "```\ngutierrezjamie influenced iwatkins an average of 1.80 times\ngutierrezjamie influenced hartmanmatthew an average of 2.20 times\ngutierrezjamie influenced shannon42 an average of 0.90 times\ngutierrezjamie influenced daniel99 an average of 0.70 times\ngutierrezjamie influenced garciajames an average of 1.00 times\ngutierrezjamie influenced grosslinda an average of 0.30 times\n```", "```\ndef term_subgraph(term, df):\n    dat_rows = df[df[\"text\"].str.contains(term)]\n    dat_replies = df[df[\"in_reply_to_id\"].isin(dat_rows[\"id\"].values)]\n    hG = nx.DiGraph()\n    for idx in dat_replies.index:\n        row = dat_replies.loc[idx]\n        hG.add_edge(row[\"in_reply_to_screen_name\"], row[\"user_screen_name\"])    \n    return hG\n```", "```\ndef check_win(G, uq, omega):\n  ❶ if uq != omega and nx.has_path(G, uq, omega):\n        return None\n  ❷ elif uq == omega:\n        return 1\n  ❸ elif not nx.has_path(G, uq, omega):\n        return -1\n```", "```\ndef weighted_choice(scores):\n    totals = []\n    running_total = 0\n  ❶ for w in scores.values():\n        running_total += w\n        totals.append(running_total)\n  ❷ rnd = random() * running_total\n    for i in range(len(totals)):\n      ❸ if rnd <= totals[i]:\n            key = list(scores.keys())[i]\n            return key\n```", "```\nXI = {\n    \"connect\": 2,\n    \"disconnect\": 1,\n    \"pass\": 2\n}\n```", "```\ndef wrs_connect(G, u):\n    scores = {}\n  ❶ for i in range(len(G.nodes.keys())):\n        v = list(G.nodes.keys())[i]\n        if v == u:\n            continue\n      ❷ dpa_score = G.out_degree(u) * G.in_degree(v)      \n        scores[v] = dpa_score\n  ❸ return weighted_choice(scores) # Previously defined choice function\n```", "```\ndef ncap_weights(G, u):\n    u_in = list(G.in_edges(u, data=True))\n    n_capacity = {}\n  ❶ for v,u,d in u_in:\n        n_capacity[v] = d[\"capacity\"]\n  ❷ Q = 1 + max([itm[1] for itm in list(n_capacity.items())])\n  ❸ n_weight = {k: (Q - n_capacity[k]) for k in n_capacity.keys()}\n    return (n_capacity, n_weight)\n```", "```\ndef wrs_disconnect(G, u):\n  ❶ u_in = list(G.in_edges(u))\n    if len(u_in) < 1:\n        return None\n  ❷ caps, scores = ncap_weights(G, u)\n    if scores is not None:\n      ❸ return ext.weighted_choice(scores)\n```", "```\ndef player_one_turn(G, uq, omega):\n  ❶ if G.has_edge(uq, omega):\n        return (omega, G)\n    caps = [d[\"capacity\"] for u,v,d in G.edges(data=True)]\n  ❷ avg_cap = sum(caps) / len(caps)\n\n  ❸ for u in list(G.nodes.keys()):\n        if u == uq:\n            try:\n              ❹ paths = list(nx.all_shortest_paths(G, u, omega))\n            except nx.exception.NetworkXNoPath:\n                return (uq, G)\n          ❺ path = choice(paths)\n            pass_to = path[1]\n        else:\n          ❻ act = ext.weighted_choice(XI)\n          ❼ if act == \"pass\":\n                continue\n          ❽ elif act == \"connect\":\n                v_conn = wrs_connect(G, u)\n                G.add_edge(u, v_conn, capacity=avg_cap)\n          ❾ else:\n                v_disconn = wrs_disconnect(G, u)\n                if v_disconn is None:\n                    continue\n                G.remove_edge(v_disconn, u)\n  ❿ return (pass_to, G)\n```", "```\ndef player_two_random(G):\n  ❶ e = choice(list(G.edges()))\n  ❷ G.remove_edge(*e)\n  ❸ return G\n```", "```\ndef shortest_path_scores(G):\n    pairs = []\n  ❶ for u, v in nx.non_edges(G):\n        if u == v:\n            continue\n        if not nx.has_path(G, u, v):\n            continue\n ❷ uv_paths = list(nx.all_shortest_paths(G, u, v))\n      ❸ avg_len = sum([len(p) for p in uv_paths]) / len(uv_paths)\n        pairs.append(((u, v), len(uv_paths), avg_len))\n    sorted_scores = sorted(\n        pairs,\n      ❹ key=lambda kv: (kv[2], kv[1], kv[0]),\n        reverse=True\n    )\n    return sorted_scores\n```", "```\npath_scores = shortest_path_scores(G)\nk = 10 # Number of random walks\nn = 10 # Number of steps in each walk\n❶ path_weights = {(p[0][0], p[0][1]): p[2] for p in path_scores}\nplayed = []\nfor r in range(25): # Run the simulation 25 times\n  ❷ selected = weighted_choice(path_weights)\n    while selected in played:\n        selected = weighted_choice(path_weights) # Avoid repeated selection\n played.append(selected)    # Track new pair\n    alpha = selected[0]        # Source node\n    omega = selected[1]        # Sink node\n    game_res = []              # Results from k random walks\n  ❸ for i in range(k):         # Perform k random walk simulations\n        newG = G.copy()        # Copy the graph to maintain the original state\n        now_at = alpha\n      ❹ for j in range(n):     # Perform at most n steps in each walk\n          ❺ w = check_win(newG, now_at, omega)\n            if w is not None:\n                game_res.append(w)\n                break\n          ❻ now_at, newG = player_one_turn(newG, now_at, omega)\n          ❼ if not check_win(newG, now_at, omega):\n              ❽ newG = player_two_random(newG)\n  ❾ tally = sum(game_res)\n    avg = tally / len(game_res)\n    print(\"\\t Average %.4f\" % avg)\n```", "```\nAverage 0.7600\nAverage 0.2800\nAverage 0.6000\nAverage 0.1200\nAverage -0.5200\nAverage 0.6800\nAverage -0.7600\n`--snip--`\nAverage 0.9200\nAverage 0.8400\nAverage -0.3600\nAverage 0.5200\nAverage 0.6000\nAverage 0.2000\nAverage -0.5200\n```", "```\ndef player_two_turn(G, uq, omega):\n  ❶ cut_value, partition = nx.minimum_cut(G, uq, omega)\n    reachable, unreachable = partition\n    cutset = set()\n  ❷ for u, nbrs in ((n, G[n]) for n in reachable):\n        cutset.update((u, v) for v in nbrs if v in unreachable)\n  ❸ if len(cutset) >= 2:\n        cut = choice(list(cutset))\n        G.remove_edge(*cut)\n  ❹ elif len(cutset) == 1:\n        cut = list(cutset)[0]\n        G.remove_edge(*cut)\n    return G\n```", "```\nAverage -0.9200\nAverage -1.0000\nAverage -1.0000\nAverage -1.0000\nAverage -0.6000\nAverage -0.8400\nAverage -1.0000\n`--snip--`\nAverage -1.0000\nAverage -0.9200\nAverage -0.9200\nAverage -1.0000\nAverage -1.0000\nAverage -0.3600\nAverage -0.9200\n```"]