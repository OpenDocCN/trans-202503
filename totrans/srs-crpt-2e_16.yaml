- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ELLIPTIC
    CURVES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">椭圆曲线</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'The introduction of *elliptic curve cryptography (ECC)* in 1985 revolutionized
    public-key cryptography. It’s more powerful and efficient than alternatives like
    RSA and classical Diffie–Hellman: ECC with a 256-bit key is stronger than RSA
    with a 4,096-bit key. But it’s also more complex.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1985年引入的*椭圆曲线密码学（ECC）*彻底改变了公钥密码学。它比RSA和经典的Diffie–Hellman等替代方案更强大、更高效：256位密钥的ECC比4096位密钥的RSA更强大。但它也更复杂。
- en: Like RSA, ECC consists mainly of multiplications of large numbers, but it does
    so to combine points on a mathematical curve, called an *elliptic curve* (this
    has nothing to do with an ellipse, by the way). To complicate matters, there are
    many types of elliptic curves—simple and sophisticated, efficient and inefficient,
    and secure and insecure, depending on the use case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像RSA一样，ECC主要由大数的乘法运算组成，但它通过在数学曲线上组合点来进行这些运算，这条曲线被称为*椭圆曲线*（顺便说一下，这与椭圆没有任何关系）。更复杂的是，椭圆曲线有许多类型——简单和复杂、高效和低效、安全和不安全，这取决于使用场景。
- en: 'ECC wasn’t adopted by standardization bodies until the early 2000s, and it
    wasn’t seen in major cryptographic software until much later: OpenSSL added ECC
    in 2005, and the OpenSSH secure connectivity tool waited until 2011\. You’ll find
    ECC in most HTTPS connections, in mobile phones, and in blockchain platforms such
    as Bitcoin and Ethereum. Indeed, elliptic curves allow you to perform common public-key
    cryptography operations such as encryption, signature, and key agreement faster
    than their classical counterparts. Most cryptographic applications that rely on
    the discrete logarithm problem (DLP) also work when based on its elliptic curve
    counterpart, ECDLP, with one notable exception: the Secure Remote Password (SRP)
    protocol.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ECC直到2000年代初才被标准化机构采纳，直到更晚的时间才在主流密码软件中出现：OpenSSL在2005年增加了对ECC的支持，OpenSSH安全连接工具则等到了2011年。如今，你会在大多数HTTPS连接中找到ECC，在手机中，以及像比特币和以太坊这样的区块链平台中。实际上，椭圆曲线使得常见的公钥密码学操作，如加密、签名和密钥协商，比其经典版本更加高效。大多数依赖离散对数问题（DLP）的密码学应用，当基于其椭圆曲线对应物ECDLP时，也能正常工作，其中有一个显著的例外：安全远程密码协议（SRP）。
- en: This chapter focuses on applications of ECC and discusses when and why to use
    ECC over RSA or classical Diffie–Hellman, as well as how to choose the right elliptic
    curve for your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了椭圆曲线密码学（ECC）的应用，并讨论了在何时以及为什么要使用ECC而不是RSA或经典的Diffie–Hellman算法，以及如何选择适合您应用的椭圆曲线。
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is an Elliptic Curve?</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">什么是椭圆曲线？</samp>
- en: An elliptic curve is a *curve* on a plane—a set of points with x- and y-coordinates.
    A curve’s equation defines all the points that belong to that curve. For example,
    the curve *y* = 3 is a horizontal line with the vertical coordinate 3, curves
    of the form *y* = *ax* + *b* with fixed numbers *a* and *b* are straight lines,
    *x*² + *y*² = 1 is a circle of radius 1 centered on the origin, and so on. Whatever
    the type of curve, the points on a curve are (*x*, *y*) pairs that satisfy the
    curve’s equation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线是平面上的一条*曲线*——由具有x和y坐标的点组成。曲线的方程定义了所有属于该曲线的点。例如，曲线*y* = 3是一条纵坐标为3的水平直线，形式为*y*
    = *ax* + *b*且固定常数*a*和*b*的曲线是直线，*x*² + *y*² = 1是一个半径为1、以原点为中心的圆等等。不管是哪种类型的曲线，曲线上的点都是满足该曲线方程的(*x*,
    *y*)坐标对。
- en: In cryptography, an elliptic curve typically has an equation in the form *y*²
    = *x*³ + *ax* + *b* (the *Weierstrass form*), where the constants *a* and *b*
    define the shape of the curve. For example, [Figure 12-1](chapter12.xhtml#fig12-1)
    shows the elliptic curve that satisfies the equation *y*² = *x*³ – 4*x*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，椭圆曲线通常有一种形式的方程 *y*² = *x*³ + *ax* + *b*（*Weierstrass形式*），其中常数*a*和*b*定义了曲线的形状。例如，[图12-1](chapter12.xhtml#fig12-1)显示了满足方程*y*²
    = *x*³ - 4*x*的椭圆曲线。
- en: '![](../images/fig12-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An elliptic curve
    with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">–
    4</samp><samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    shown over the real numbers</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-1：一个椭圆曲线，其方程为</samp> <samp
    class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">–
    4</samp><samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    显示在实数范围内</samp>
- en: This figure displays all the points that make up the curve for *x* between –3
    and 4, be they points on the left side of the curve, which looks like a circle,
    or on the right side, which looks like a parabola. All points have (*x*, *y*)
    coordinates that satisfy the curve’s equation *y*² = *x*³ – 4*x*. For example,
    when *x* = 0, then *y**²* = *x*³ – 4*x* = 0³ – 4 × 0 = 0; hence, *y* = 0 is a
    solution, and the point (0, 0) belongs to the curve. Likewise, if *x* = 2, the
    solution to the equation is *y* = 0, meaning that the point (2, 0) belongs to
    the curve.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了所有使得 *x* 在 –3 和 4 之间的点，无论是位于曲线左侧（看起来像圆形的部分）还是右侧（看起来像抛物线的部分）。所有这些点的 (*x*,
    *y*) 坐标都满足曲线方程 *y*² = *x*³ – 4*x*。例如，当 *x* = 0 时，*y*² = *x*³ – 4*x* = 0³ – 4 ×
    0 = 0；因此，*y* = 0 是一个解，点 (0, 0) 属于该曲线。同样，如果 *x* = 2，方程的解是 *y* = 0，意味着点 (2, 0) 属于该曲线。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In this chapter, I focus on the simplest, most common type of elliptic curves—those
    with an equation like* y*²* *=* x*³* *+* ax *+* b*—but other elliptic curves have
    equations in different forms. For example,* Edwards curves *have equations of
    the form* x*²* *+* y*²* *= 1 +* dx*²*y*²**. Cryptographers sometimes use Edwards
    curves (for example, in the Ed25519 scheme).*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这一章中，我将重点讨论最简单、最常见类型的椭圆曲线——其方程形式为* y*²* =* x*³* +* ax *+* b*——但其他椭圆曲线有不同形式的方程。例如，*Edwards曲线*的方程形式为*
    x*²* +* y*²* = 1 +* dx*²*y*²**。密码学家有时使用Edwards曲线（例如，在Ed25519方案中）。*'
- en: When using elliptic curves for cryptography, it’s crucial to distinguish points
    that belong to the curve from other points, as points off the curve often present
    a security risk. However, the curve’s equation doesn’t always admit solutions,
    at least not in the natural number plane. For example, to find points with the
    horizontal coordinate *x* = 1, you solve *y*² = *x*³ – 4*x* and obtain *y*² =
    *x*³ – 4*x* = 1³ – 4 × 1, resulting in –3\. But *y*² = –3 doesn’t have a solution
    because there’s no number for which *y*² = –3\. There exists a solution in the
    complex numbers (√3*i*), but in practice, elliptic curve cryptography uses only
    natural numbers (ECC works with integer number modulo a prime number, either directly
    or via polynomials). Because there’s no solution to the curve’s equation for *x*
    = 1, the curve has no point at that position on the x-axis, as you can see in
    [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用椭圆曲线进行密码学时，区分属于曲线的点和其他点至关重要，因为曲线外的点通常会带来安全风险。然而，曲线的方程并不总是有解，至少在自然数平面中没有解。例如，要求解横坐标
    *x* = 1 的点，你需要解 *y*² = *x*³ – 4*x*，得到 *y*² = *x*³ – 4*x* = 1³ – 4 × 1，结果为 –3。但
    *y*² = –3 没有解，因为没有任何数字使得 *y*² = –3。在复数范围内存在解（√3*i*），但在实际应用中，椭圆曲线密码学只使用自然数（ECC
    使用的是模素数下的整数，通常是直接运算或通过多项式）。因为 *x* = 1 时曲线的方程没有解，曲线在该位置上没有点，如[图12-1](chapter12.xhtml#fig12-1)所示。
- en: If you try to solve for *x* = –1, you get the equation *y*² = –1 + 4 = 3, which
    has two solutions (*y* = √3 ≈ 1.73 and *y* = –√3 ≈ –1.73), the square root of
    3 and its negative value. The square of both values is 3, and [Figure 12-1](chapter12.xhtml#fig12-1)
    has two points with *x* = –1\. More generally, the curve is symmetric with respect
    to the x-axis for all points that satisfy its equation (as are all elliptic curves
    of the form *y*² = *x*³ + *ax* + *b*, except for *y* = 0).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试求解 *x* = –1，你会得到方程 *y*² = –1 + 4 = 3，它有两个解（*y* = √3 ≈ 1.73 和 *y* = –√3
    ≈ –1.73），即3的平方根及其负值。这两个值的平方都是3，且[图12-1](chapter12.xhtml#fig12-1)中有两个点，*x* = –1。更一般地，曲线对于所有满足其方程的点，相对于x轴是对称的（所有形如*y*²
    = *x*³ + *ax* + *b*的椭圆曲线也是如此，*y* = 0除外）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curves over
    Integers</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数上的椭圆曲线</samp>
- en: 'Here’s a bit of a twist: the curves in elliptic curve cryptography don’t actually
    look like [Figure 12-1](chapter12.xhtml#fig12-1). They’re neither curves nor ellipses.
    They look instead like [Figure 12-2](chapter12.xhtml#fig12-2), which is a cloud
    of points rather than a curve. What’s going on here?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点不同：椭圆曲线加密中的曲线实际上并不像[图12-1](chapter12.xhtml#fig12-1)那样。它们既不是曲线，也不是椭圆。它们更像是[图12-2](chapter12.xhtml#fig12-2)，这是一组点的云，而不是一条曲线。这里到底发生了什么？
- en: '![](../images/fig12-2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The elliptic curve
    with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">–
    4</samp><samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">over</samp>
    <samp class="SANS_Futura_Std_Book_11">Z</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">191</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, the set of integers modulo 191</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-2：方程</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp>
    <samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">– 4</samp><samp class="SANS_Futura_Std_Book_11">x</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在</samp> <samp class="SANS_Futura_Std_Book_11">Z</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">191</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">上，模191的整数集合</samp>
- en: '[Figures 12-1](chapter12.xhtml#fig12-1) and [12-2](chapter12.xhtml#fig12-2)
    are based on the same curve equation, *y*² = *x*³ – 4*x*, but they show the curve’s
    points with respect to different sets of numbers: [Figure 12-1](chapter12.xhtml#fig12-1)
    shows the curve’s points over the set of *real numbers*, which includes negative
    numbers, decimals, and so on. For example, as a continuous curve, it shows the
    points at *x* = 2.0, *x* = 2.1, *x* = 2.00002, and so on. [Figure 12-2](chapter12.xhtml#fig12-2),
    on the other hand, shows only *integers* that satisfy this equation, which excludes
    decimal numbers. Specifically, [Figure 12-2](chapter12.xhtml#fig12-2) shows the
    curve *y*² = *x*³ – 4*x* with respect to the integers *modulo 191*: 0, 1, 2, 3,
    up to 190\. You can denote this set of numbers **Z**[191]. (There’s nothing special
    with 191 here, except that it’s a prime number. I picked a small number to avoid
    having too many points on the graph.) The points in [Figure 12-2](chapter12.xhtml#fig12-2)
    therefore all have x- and y-coordinates that are integers modulo 191 and that
    satisfy the equation *y*² = *x*³ – 4*x*. For example, for *x* = 2, you have *y*²
    = 0, for which *y* = 0 is a valid solution. This tells you that the point (2,
    0) belongs to the curve.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](chapter12.xhtml#fig12-1)和[图12-2](chapter12.xhtml#fig12-2)基于相同的曲线方程，*y*²
    = *x*³ – 4*x*，但它们分别展示了与不同数字集合相关的曲线点：[图12-1](chapter12.xhtml#fig12-1)展示的是*实数*集合上的曲线点，其中包含负数、小数等。例如，作为一条连续曲线，它显示了在*x*
    = 2.0、*x* = 2.1、*x* = 2.00002等位置的点。而[图12-2](chapter12.xhtml#fig12-2)则只展示满足此方程的*整数*，排除了小数。具体来说，[图12-2](chapter12.xhtml#fig12-2)展示了曲线*y*²
    = *x*³ – 4*x*在*模191*的整数集合下的情况：0, 1, 2, 3，一直到190。你可以用**Z**[191]表示这个数字集合。（这里没有特别的意义，除了191是一个素数。我选择了一个小的数字，以避免图表上的点太多。）因此，[图12-2](chapter12.xhtml#fig12-2)中的点的x和y坐标都是模191的整数，并且满足方程*y*²
    = *x*³ – 4*x*。例如，当*x* = 2时，*y*² = 0，*y* = 0是一个有效的解。这意味着点(2, 0)属于该曲线。'
- en: If *x* = 3, you get the equation *y*² = 27 – 12 = 15, which admits two solutions
    in **Z**[191], 46 and 145\. Indeed, 46² = 2,116, with 2,116 mod 191 = 15, and
    145² = 21,025, with 21,025 mod 191 = 15\. Thus, the points (3, 46) and (3, 145)
    both belong to the curve and appear as in [Figure 12-2](chapter12.xhtml#fig12-2)
    (the two points circled on the left).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*x* = 3，你得到方程*y*² = 27 – 12 = 15，它在**Z**[191]中有两个解，46和145。实际上，46² = 2,116，2,116
    mod 191 = 15，145² = 21,025，21,025 mod 191 = 15。因此，点(3, 46)和(3, 145)都属于该曲线，并在[图12-2](chapter12.xhtml#fig12-2)中出现（左侧被圈起来的两个点）。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Figure 12-2](chapter12.xhtml#fig12-2) considers points from the set denoted*
    ***Z***191 *= {0, 1, 2, . . . , 190}, which includes zero. This differs from the
    groups denoted* ***Z***[p]^* *(with a star superscript) that we discussed in the
    context of RSA and Diffie–Hellman. The reason for this difference is that you’ll
    both multiply and add numbers, and you therefore need to ensure that the set of
    numbers includes addition’s identity element (namely 0, such that* x *+ 0 =* x
    *for every* x *in* ***Z***191*).*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[图12-2](chapter12.xhtml#fig12-2) 考虑了从集合 ***Z***191 *= {0, 1, 2, . . . , 190}
    中选取的点，这个集合包括零。这与我们在讨论 RSA 和 Diffie-Hellman 时提到的表示为 ***Z***[p]^*（带星号上标）的群不同。之所以有所不同，是因为你将同时进行数的乘法和加法，因此需要确保数的集合包括加法的恒等元素（即
    0，使得* x *+ 0 = *x* 对于每个 *x* ∈ ***Z***191）。*'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Also, every number* x *has an inverse with respect to addition, denoted –*x*,
    such that* x *+ (–*x*) = 0\. For example, the inverse of 100 in* ***Z***191 *is
    91 because 100 + 91 mod 191 = 0\. Such a set of numbers, where addition and multiplication
    are possible and where each element* x *admits an inverse with respect to addition
    (denoted –*x*) as well as an inverse (except for the element zero) with respect
    to multiplication (denoted 1 /* x*), is called a* field*. When a field has a finite
    number of elements, as in* ***Z***191 *and as with all fields used for elliptic
    curve cryptography, it is a* finite field.'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*另外，每个数字* x *在加法下都有一个逆元素，记作 –*x*，使得* x *+ (–*x*) = 0。例如，100 在 ***Z***191 中的逆元素是
    91，因为 100 + 91 mod 191 = 0。这样的数集，其中加法和乘法都是可能的，并且每个元素 *x* 都有加法逆元素（记作 –*x*），并且除了零元素外，每个元素都有乘法逆元素（记作
    1 /* x*），叫做一个*域*。当一个域包含有限个元素时，就像 ***Z***191 和所有用于椭圆曲线加密的域一样，它是一个*有限域*。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Addition Law</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加法法则</samp>
- en: Now that you know that the points on an elliptic curve are coordinates (*x*,
    *y*) that satisfy the curve’s equation, *y*² = *x*³ + *ax* + *b*, let’s look at
    how to add elliptic curve points with the *addition law*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道椭圆曲线上的点是满足曲线方程 *y*² = *x*³ + *ax* + *b* 的坐标对 (*x*, *y*)，我们来看一下如何使用 *加法法则*
    来加椭圆曲线上的点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Two Points</samp>
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">加法运算两个点</samp>
- en: 'Say you want to add two points on the elliptic curve, *P* and *Q*, to give
    a new point, *R*, that is the sum of these two points. The simplest way to understand
    point addition is to determine the position of *R* = *P* + *Q* on the curve relative
    to *P* and *Q* based on a geometric rule: draw the line that connects *P* and
    *Q*, find the other point of the curve that intersects with this line, and *R*
    is the reflection of this point with respect to the x-axis. For example, in [Figure
    12-3](chapter12.xhtml#fig12-3), the line connecting *P* and *Q* intersects the
    curve at a third point between *P* and *Q*, and the point *P* + *Q* is at the
    same x-coordinate but the inverse y-coordinate.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在椭圆曲线上加两个点，*P* 和 *Q*，得到一个新点 *R*，它是这两个点的和。理解点加法的最简单方法是通过几何规则确定 *R* = *P*
    + *Q* 在曲线上相对于 *P* 和 *Q* 的位置：画出连接 *P* 和 *Q* 的直线，找到与该直线相交的曲线上的另一个点，*R* 是该点相对于 x
    轴的对称点。例如，在 [图12-3](chapter12.xhtml#fig12-3) 中，连接 *P* 和 *Q* 的直线与曲线相交于 *P* 和 *Q*
    之间的第三个点，点 *P* + *Q* 具有相同的 x 坐标，但 y 坐标是其逆值。
- en: '![](../images/fig12-3.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A general case
    of the geometric rule for adding points over an elliptic curve</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-3：椭圆曲线点加法几何规则的一般情况</samp>
- en: This geometric rule is simple, but it won’t directly give you the coordinates
    of the point *R*. You compute the coordinates (*x*R, *y*R) of *R* using the coordinates
    (*x*P, *y*P) of *P* and the coordinates (*x*Q, *y*Q) of *Q* using the formulas
    *x*R *= m*² *– x*P *– x*Q and *y*R *= m(x*P *– x*R*) – y*P , where the value *m
    = (y*Q *– y*P*) / (x*Q *– x*P*)* is the slope of the line connecting *P* and *Q*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何规则很简单，但它并不会直接给出点 *R* 的坐标。你可以使用公式 *x*R = m² – *x*P – *x*Q 和 *y*R = m(*x*P
    – *x*R) – *y*P 计算点 *R* 的坐标 (*x*R, *y*R)，其中 m = (*y*Q – *y*P) / (*x*Q – *x*P) 是连接
    *P* 和 *Q* 的直线的斜率。
- en: Unfortunately, these formulas and the line-drawing trick in [Figure 12-3](chapter12.xhtml#fig12-3)
    don’t always work. If, for example, *P* = *Q*, you can’t draw a line between two
    points (there’s only one), and if *Q* = –*P*, the line doesn’t cross the curve
    again, so there’s no point on the curve to mirror. We’ll explore these in the
    next sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些公式和[图12-3](chapter12.xhtml#fig12-3)中的画线技巧并不总是有效。例如，如果 *P* = *Q*，你就无法在两个点之间画线（因为只有一条），如果
    *Q* = –*P*，则直线不会再次与曲线相交，因此没有曲线上的点可供对称。我们将在接下来的章节中探讨这些情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Point and Its Negative</samp>
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">加点及其负点</samp>
- en: The negative of a point *P* = (*x*P, *y*P) is the point –*P* = (*x*P, –*y*P),
    which is the point mirrored around the x-axis. For any *P*, you can say that *P*
    + (–*P*) = *O*, where *O* is the *point at infinity*. As in [Figure 12-4](chapter12.xhtml#fig12-4),
    the line between *P* and –*P* runs to infinity and never intersects the curve.
    The point at infinity is to elliptic curves what zero is to integers, except that
    it’s only a “virtual” point that you can’t locate at a specific place, because
    it’s infinitely far.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点 *P* = (*x*P, *y*P) 的负点是点 –*P* = (*x*P, –*y*P)，这是围绕 x 轴对称的点。对于任何 *P*，你可以说 *P*
    + (–*P*) = *O*，其中 *O* 是 *无穷远点*。如[图12-4](chapter12.xhtml#fig12-4)所示，*P* 和 –*P*
    之间的直线延伸到无穷远，并且永远不与曲线相交。无穷远点对椭圆曲线来说，类似于零对整数的意义，只不过它是一个“虚拟”点，你无法在特定位置定位它，因为它位于无穷远处。
- en: '![](../images/fig12-4.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The geometric
    rule for adding a point and its negative, or</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+ (–</samp><samp class="SANS_Futura_Std_Book_11">P</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">O,</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">when the line between the points
    never intersects the curve</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-4：加法规则——点及其负点的相加，或</samp>
    <samp class="SANS_Futura_Std_Book_11">P</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+
    (–</samp><samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    =</samp> <samp class="SANS_Futura_Std_Book_11">O,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">当两点之间的直线永远不与曲线相交时</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doubling a Point</samp>
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">点的加倍</samp>
- en: When *P* = *Q* (that is, *P* and *Q* are at the same position), adding *P* and
    *Q* is equivalent to computing *P* + *P*, or 2*P*. This addition operation is
    called a *doubling*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *P* = *Q*（即 *P* 和 *Q* 在同一位置）时，*P* 和 *Q* 的加法等同于计算 *P* + *P*，即 2*P*。这种加法操作称为
    *加倍*。
- en: To find the coordinates of the result *R* = 2*P*, you can’t use the geometric
    rule from the previous section, because you can’t draw a line between *P* and
    itself. Instead, you draw the line *tangent* to the curve at *P*, and 2*P* is
    the negation of the point where this line intersects the curve, as [Figure 12-5](chapter12.xhtml#fig12-5)
    demonstrates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到结果 *R* = 2*P* 的坐标，你不能使用上一节中的几何规则，因为你不能在 *P* 和 *P* 之间画一条直线。相反，你需要画出在 *P* 处与曲线相切的直线，然后
    2*P* 是这条直线与曲线交点的对称点，如[图12-5](chapter12.xhtml#fig12-5)所示。
- en: '![](../images/fig12-5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The geometric
    rule for doubling a point—that is,</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-5：加倍点的几何规则——也就是说，</samp>
    <samp class="SANS_Futura_Std_Book_11">P</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp>
    <samp class="SANS_Futura_Std_Book_11">P</samp>
- en: The formula to determine the coordinates (*x*R, *y*R) of *R* = *P* + *P* is
    slightly different from the formula for a distinct *P* and *Q*. The basic formula
    is *x*R = *m*² – *x*P – *x*Q and *y*R = *m*(*x*P – *x*R) – *y*P , but the value
    of *m* becomes (3*x*P² + *a*) / 2*y*P , where *a* is the curve’s parameter, as
    in *y*² = *x*³ + *ax* + *b*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定 *R* = *P* + *P* 坐标（*x*R, *y*R）的公式与用于计算两个不同点 *P* 和 *Q* 的公式略有不同。基本公式为 *x*R
    = *m*² – *x*P – *x*Q 和 *y*R = *m*(*x*P – *x*R) – *y*P，其中 *m* 的值为 (3*x*P² + *a*)
    / 2*y*P，*a* 是曲线的参数，如 *y*² = *x*³ + *ax* + *b* 中所示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Multiplying Points</samp>
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">点的乘法</samp>
- en: To multiply points on elliptic curves by a given integer number *k*, you determine
    the point *kP* by adding *P* to itself *k* – 1 times. In other words, 2*P* = *P*
    + *P*, 3*P* = *P* + *P* + *P*, and so on. To obtain the x- and y-coordinates of
    *kP*, repeatedly add *P* to itself and apply the preceding addition law.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过给定的整数 *k* 来乘以椭圆曲线上的点，你可以通过将 *P* 加到自身 *k* – 1 次来确定点 *kP*。换句话说，2*P* = *P* +
    *P*，3*P* = *P* + *P* + *P*，依此类推。要获得 *kP* 的 x 和 y 坐标，重复将 *P* 加到自身并应用前述的加法法则。
- en: To compute *kP* efficiently, however, the naive technique of adding *P* by applying
    the addition law *k* – 1 times is far from optimal. For example, if *k* is large
    (of the order of, say, 2^(256)) as it occurs in elliptic curve–based crypto schemes,
    then computing *k* – 1 additions is downright infeasible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要高效地计算 *kP*，通过应用加法法则将 *P* 加到自身 *k* – 1 次的朴素方法远非最优。例如，如果 *k* 很大（例如，2^(256)
    级别），像在基于椭圆曲线的加密方案中出现的那样，那么计算 *k* – 1 次加法几乎是不可行的。
- en: You can gain an exponential speedup by adapting the technique in [Chapter 10](chapter10.xhtml)’s
    “A Fast Exponentiation Algorithm” to compute *x**^e* mod *n*. The difference is
    that you’re multiplying points by an integer rather than computing exponentiations.
    But you can adapt the method to become *double-and-add*, where multiplication
    becomes addition and squaring becomes doubling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用[第10章](chapter10.xhtml)《快速指数算法》中的技巧来计算 *x**^e* mod *n*，你可以获得指数级的加速。不同之处在于，你是通过整数乘法而非计算指数来进行运算。但你可以将这个方法改为*加倍并相加*，在这种情况下，乘法变成加法，平方变成加倍。
- en: 'For example, to compute 8*P* in three additions instead of seven using the
    naive method, first compute *P*[2] = *P* + *P*, then *P*[4] = *P*[2] + *P*[2],
    and finally *P*[4] + *P*[4] = 8*P*. This is the simplest case, when the multiplier
    is a power of two, such as 8 = 2³. Otherwise, for example, to compute 10*P*, proceed
    as follows: observing that 10 is 1010 in binary, start by the most significant
    (“leftmost”) bit and compute the result *R* like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用朴素方法计算 8*P* 需要七次加法，而使用三次加法可以计算 8*P*，首先计算 *P*[2] = *P* + *P*，然后 *P*[4] =
    *P*[2] + *P*[2]，最后 *P*[4] + *P*[4] = 8*P*。这是最简单的情况，当乘数是 2 的幂次方时，例如 8 = 2³。否则，例如，要计算
    10*P*，步骤如下：观察到 10 的二进制表示是 1010，从最重要的（“最左”）位开始，按如下方式计算结果 *R*：
- en: '**Bit 1 **Start by setting *R* = *P*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**位 1** 首先设置 *R* = *P*。'
- en: '**Bit 0 **Double, setting *R* = 2*R* = 2*P*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**位 0** 加倍，设置 *R* = 2*R* = 2*P*。'
- en: '**Bit 1 **Double and add, setting *R* = 2*R* + *P* = 2(2*P*) + *P* = 5*P*.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**位 1** 加倍并相加，设置 *R* = 2*R* + *P* = 2(2*P*) + *P* = 5*P*。'
- en: '**Bit 0 **Double, setting *R* = 2*R* = 2(5*P*) = 10*P*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**位 0** 加倍，设置 *R* = 2*R* = 2(5*P*) = 10*P*。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curve Groups</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">椭圆曲线群</samp>
- en: Not only can you add elliptic curve points together, you can also use them to
    form a group structure. According to the definition of a group (see “Groups” in
    [Chapter 9](chapter9.xhtml)), if the points *P* and *Q* belong to a given curve,
    then *P* + *Q* also belongs to the curve.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以将椭圆曲线上的点相加，还可以使用它们来形成一个群结构。根据群的定义（参见[第9章](chapter9.xhtml)中的“群”），如果点 *P*
    和 *Q* 属于给定的曲线，那么 *P* + *Q* 也属于该曲线。
- en: Furthermore, because addition is *associative*, you have (*P* + *Q*) + *R* =
    *P* + (*Q* + *R*) for any points *P*, *Q*, and *R*. In a group of elliptic curve
    points, we call the identity element the point at infinity and denote it as *O*,
    such that *P* + *O* = *P* for any *P*. Every point *P* = (*x*P, *y*P) has an inverse,
    –*P* = (*x*P , –*y*P), such that *P* + (–*P*) = *O*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于加法是*结合律*的，你有 (*P* + *Q*) + *R* = *P* + (*Q* + *R*) 对于任何点 *P*, *Q*, 和 *R*。在椭圆曲线点的群体中，我们称单位元为无限远点，并用
    *O* 来表示，使得 *P* + *O* = *P* 对于任何 *P*。每个点 *P* = (*x*P, *y*P) 都有一个逆元素，–*P* = (*x*P
    , –*y*P)，使得 *P* + (–*P*) = *O*。
- en: In practice, most elliptic curve–based cryptosystems work with x- and y-coordinates
    that are numbers modulo a prime number, *p* (in other words, numbers in the finite
    field **Z**p). Just as the security of RSA depends on the size of the numbers
    used, the security of an elliptic curve–based cryptosystem depends on the number
    of points on the curve. But how do you know the number of points on an elliptic
    curve, or its *cardinality*? Well, it depends on the curve and the value of *p*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数基于椭圆曲线的加密系统使用的是 *x* 和 *y* 坐标，这些数字是模一个素数 *p* 的数（换句话说，这些数字属于有限域 **Z**p）。正如
    RSA 的安全性依赖于所使用的数字大小一样，基于椭圆曲线的加密系统的安全性也依赖于曲线上的点的数量。那么，你如何知道椭圆曲线上的点的数量，或者它的*基数*呢？其实，这取决于曲线和
    *p* 的值。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Prime fields aren’t the only fields used in elliptic curve cryptography. There
    are also* binary fields*, which are extensions of the two-element field (which
    includes 0 and 1), whose elements are represented as polynomials with binary coefficients.
    Arithmetic over binary fields has the advantage of often being easier to implement
    efficiently in hardware as logic circuits, compared to a general-purpose microprocessor.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*素域并不是椭圆曲线密码学中唯一使用的域。还有* 二进制域*，它是由两个元素域（包括 0 和 1）的扩展，其元素表示为具有二进制系数的多项式。与一般目的的微处理器相比，二进制域上的算术运算通常更容易在硬件逻辑电路中高效实现。*'
- en: There are of the order of *p* points on a curve defined over **Z**p, but you
    can compute the exact number of points with Schoof’s algorithm, which counts points
    on elliptic curves over finite fields. You’ll find this algorithm built into SageMath.
    For example, [Listing 12-1](chapter12.xhtml#Lis12-1) uses Schoof’s algorithm to
    count the number of points on the curve *y*² = *x*³ – 4*x* over **Z**[191] from
    [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线 **Z**p 上大约有 *p* 个点，但你可以使用 Schoof 算法精确计算点的数量，该算法用于计算有限域上的椭圆曲线的点数。你会发现这个算法已经内置在
    SageMath 中。例如，[清单 12-1](chapter12.xhtml#Lis12-1) 使用 Schoof 算法计算 **Z**[191] 上曲线
    *y*² = *x*³ – 4*x* 的点数，参见[图 12-1](chapter12.xhtml#fig12-1)。
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Computing the
    cardinality, or the number of points on a curve</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-1：计算曲线的基数或点数</samp>
- en: In [Listing 12-1](chapter12.xhtml#Lis12-1), you first define the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> as the set over integers modulo
    191; then you define the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    as the elliptic curve over <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp>
    with the coefficients –4 and 0\. Finally, you compute the number of points on
    the curve, or its *cardinality*, *group order*, or just *order*. This count includes
    the point at infinity *O*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 12-1](chapter12.xhtml#Lis12-1)中，首先定义变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp>
    为模 191 的整数集合；然后定义变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> 为系数为
    -4 和 0 的椭圆曲线 <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> 上的曲线。最后，你计算曲线的点数，即它的
    *基数*、*群阶* 或简称 *阶*。此计数包括无穷远点 *O*。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The ECDLP Problem</samp>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">ECDLP 问题</samp>
- en: '[Chapter 9](chapter9.xhtml) introduced the discrete logarithm problem (DLP):
    that of finding the number *y* given some base number *g*, where *x* = *g* *^y*
    mod *p* for some large prime number *p*. Cryptography with elliptic curves has
    a similar problem of finding the number *k* given a base point *P* where the point
    *Q* = *kP*. This is the elliptic curve discrete logarithm problem. Instead of
    numbers, the elliptic curve’s problems operate on points and use multiplication
    instead of exponentiation.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 9 章](chapter9.xhtml)介绍了离散对数问题（DLP）：给定一个基数 *g*，找出一个数 *y*，使得 *x* = *g* *^y*
    mod *p*，其中 *p* 是某个大素数。椭圆曲线密码学有类似的问题，给定基点 *P*，找出数 *k*，使得点 *Q* = *kP*。这就是椭圆曲线离散对数问题。与数字不同，椭圆曲线的问题作用于点，并使用乘法代替指数运算。'
- en: About all elliptic curve cryptography is built on the ECDLP problem, which,
    like DLP, is believed to be hard and has withstood cryptanalysis since its introduction
    in 1985\. One important difference from the classical DLP is that ECDLP allows
    you to work with smaller numbers and still enjoy a similar level of security.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的椭圆曲线密码学都基于 ECDLP 问题，像 DLP 一样，ECDLP 被认为是困难的，并且自 1985 年引入以来经受了密码分析。与经典 DLP
    的一个重要区别是，ECDLP 允许你使用更小的数字，同时仍然享有类似的安全级别。
- en: Generally, when the parameter *p* is *n*-bit, ECC gets you a security level
    of about *n*/2 bits. For example, an elliptic curve taken over numbers modulo
    a 256-bit *p* gives a security level of about 128 bits. For the sake of comparison,
    to achieve a similar security level with DLP or RSA, you need to use numbers of
    several thousands of bits. Using smaller numbers for ECC arithmetic is one reason
    why it’s often faster than RSA or classical Diffie–Hellman.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当参数 *p* 是 *n* 位时，ECC 可以提供约 *n*/2 位的安全性。例如，使用一个模 256 位 *p* 的椭圆曲线可以提供约 128
    位的安全性。为了比较，使用 DLP 或 RSA 达到类似的安全性水平，需要使用几千位的数字。使用更小的数字进行 ECC 运算是它通常比 RSA 或经典的 Diffie–Hellman
    更快的原因之一。
- en: One approach to solving ECDLP is to find a collision between two outputs, *c*[1]*P*
    + *d*[1]*Q* and *c*[2]*P* + *d*[2]*Q*. The points *P* and *Q* in these equations
    are such that *Q* = *kP* for some unknown *k*, and *c*[1], *d*[1], *c*[2], and
    *d*[2] are the numbers you need to find *k*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 解决ECDLP的一种方法是找到两个输出之间的碰撞，*c*[1]*P* + *d*[1]*Q* 和 *c*[2]*P* + *d*[2]*Q*。这些方程中的点
    *P* 和 *Q* 是这样的：*Q* = *kP*，其中 *k* 是一个未知数，而 *c*[1]、*d*[1]、*c*[2] 和 *d*[2]* 是你需要找到
    *k* 的数字。
- en: 'As with the hash function in [Chapter 6](chapter6.xhtml), a collision occurs
    when two different inputs produce the same output. Therefore, to solve ECDLP,
    you need to find points where the following is true:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [第6章](chapter6.xhtml) 中的哈希函数一样，碰撞发生在两个不同的输入产生相同输出时。因此，要解决ECDLP，你需要找到以下条件成立的点：
- en: '![](../images/pg240-1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg240-1.jpg)'
- en: 'Assuming you’ve found the four coefficients, you’re going to recover *k*. For
    this, replace *Q* with the value *kP*, and you have the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经找到了四个系数，接下来你要恢复 *k*。为此，将 *Q* 替换为 *kP* 的值，你会得到以下结果：
- en: '![](../images/pg240-2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg240-2.jpg)'
- en: This tells you that (*c*[1] + *d*[1]*k*) equals (*c*[2] + *d*[2]*k*) when taken
    modulo the number of points on the curve, which isn’t a secret.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你，当对曲线上的点数取模时，(*c*[1] + *d*[1]*k*) 等于 (*c*[2] + *d*[2]*k*)，这并不神秘。
- en: 'From this, you can deduce the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，你可以推导出以下内容：
- en: '![](../images/pg241-1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg241-1.jpg)'
- en: And you’ve found *k*, the solution to ECDLP. Of course, that’s only the big
    picture—the details are more complex and interesting, notably regarding the way
    to recover the coefficients *c*[1], *c*[2], *d*[1], *d*[2].
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你找到了 *k*，也就是ECDLP的解。当然，这只是大致的框架——细节更复杂且更有趣，特别是在如何恢复系数 *c*[1]、*c*[2]、*d*[1]、*d*[2]
    的方式上。
- en: In practice, elliptic curves extend over numbers of at least 256 bits, which
    makes attacking elliptic curve cryptography by finding a collision impractical
    because doing so takes up to 2^(128) operations (the cost of finding a collision
    over 256-bit numbers—see [Chapter 6](chapter6.xhtml)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，椭圆曲线的范围至少为256位数字，这使得通过寻找碰撞来攻击椭圆曲线加密变得不切实际，因为这样做需要最多 2^(128) 次操作（这就是在256位数字上找到碰撞的成本——详见
    [第6章](chapter6.xhtml)）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Key Agreement over Elliptic
    Curves</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_B_11">椭圆曲线上的Diffie–Hellman密钥协商</samp>
- en: Recall from [Chapter 11](chapter11.xhtml) that in the classical Diffie–Hellman
    (DH) key agreement protocol, two parties establish a shared secret by exchanging
    nonsecret values. Given some fixed number *g*, Alice picks a secret random number
    *a*, computes *A* = *g**^a*, and sends *A* to Bob. Then Bob picks a secret random
    *b* and sends *B* = *g**^b* to Alice. Both combine their secret key with the other’s
    public key to produce the same *A**^b* = *B**^a* = *g**^(ab)*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第11章](chapter11.xhtml) 中提到的经典Diffie–Hellman（DH）密钥协商协议，两个参与方通过交换非秘密值来建立共享密钥。给定某个固定数
    *g*，爱丽丝选择一个秘密随机数 *a*，计算 *A* = *g**^a*，并将 *A* 发送给鲍勃。然后鲍勃选择一个秘密随机数 *b*，并将 *B* =
    *g**^b* 发送给爱丽丝。然后，两人将各自的秘密密钥与对方的公钥结合，计算出相同的 *A**^b* = *B**^a* = *g**^(ab)*。
- en: The elliptic curve version of DH, *elliptic curve Diffie–Hellman (ECDH)*, is
    identical to that of classical DH but with different notations. In the case of
    ECC, for some fixed-point *G*, Alice picks a secret random number *a*, computes
    *A* = *aG* (the point *G* multiplied by the integer *a*), and sends *A* to Bob.
    Bob picks a secret random *b*, computes the point *B* = *bG*, and sends it to
    Alice. Then both compute the same shared secret, *aB* = *bA* = *abG*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线版的DH，*椭圆曲线Diffie–Hellman（ECDH）*，与经典DH相同，只是符号不同。在ECC的情况下，给定某个固定点 *G*，爱丽丝选择一个秘密随机数
    *a*，计算 *A* = *aG*（点 *G* 乘以整数 *a*），并将 *A* 发送给鲍勃。鲍勃选择一个秘密随机数 *b*，计算点 *B* = *bG*，并将其发送给爱丽丝。然后，两人都计算相同的共享密钥，*aB*
    = *bA* = *abG*。
- en: 'ECDH is to the ECDLP problem what DH is to DLP: it’s secure as long as ECDLP
    is hard. You can therefore adapt DH protocols that rely on DLP to work with elliptic
    curves and rely on ECDLP as a hardness assumption. For example, authenticated
    DH and Menezes–Qu–Vanstone (MQV) will also be secure when used with elliptic curves.
    In fact, MQV was first defined as working over elliptic curves.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ECDH 与 ECDLP 问题的关系，就像 DH 与 DLP 的关系一样：只要ECDLP问题足够困难，它就安全。因此，你可以将依赖于DLP的DH协议调整为使用椭圆曲线，并依赖ECDLP作为难度假设。例如，认证DH和Menezes–Qu–Vanstone
    (MQV)协议，在与椭圆曲线一起使用时也会是安全的。事实上，MQV最初就是定义为在椭圆曲线上工作的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Signing with Elliptic Curves</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_B_11">椭圆曲线签名</samp>
- en: The main standard algorithm you can use for signing with ECC is *elliptic curve
    digital signature algorithm (ECDSA)*. This algorithm has replaced RSA signatures
    and classical DSA signatures in many applications. ECDSA is a NIST standard, is
    supported in the TLS and SSH protocols, and is the main signature algorithm in
    many blockchain platforms, including Bitcoin and Ethereum.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: As with all signature schemes, ECDSA consists of a *signature generation* algorithm
    that the signer uses to create a signature using their private key and a *verification*
    algorithm that a verifier uses to check a signature’s correctness given the signer’s
    public key. The signer holds a number, *d*, as a private key, and verifiers hold
    the public key, *P* = *dG*. Both know in advance what elliptic curve to use, its
    order (*n*, the number of points in the curve), and the coordinates of a base
    point, *G*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Generation</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To sign a message, the signer first hashes the message with a cryptographic
    hash function such as SHA-256 or BLAKE2 to generate a hash value, *h*, that you
    interpret as a number between 0 and *n* – 1\. Next, the signer picks a random
    number, *k*, between 1 and *n* – 1 and computes *kG*, a point with the coordinates
    (*x*, *y*). The signer now sets *r* = *x* mod *n* and computes *s* = (*h* + *rd*)
    / *k* mod *n* and then uses these values as the signature (*r*, *s*).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The length of the signature depends on the coordinate lengths you’re using.
    For example, when you’re working with a curve where coordinates are 256-bit numbers,
    *r* and *s* are both 256 bits long, yielding a 512-bit-long signature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Verification</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ECDSA verification algorithm uses a signer’s public key to verify the validity
    of a signature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify an ECDSA signature (*r*, *s*) and a message’s hash, *h*, the verifier
    first computes *w* = 1 / *s*, the inverse of *s* in the signature, which is equal
    to *k* / (*h* + *rd*) mod *n*, since *s* is defined as *s* = (*h* + *rd*) / *k*.
    Next, the verifier multiplies *w* with *h* to find *u* according to the following
    formula:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'The verifier then multiplies *w* with *r* to find *v*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Given *u* and *v*, the verifier computes the point *Q* according to the following
    formula:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-3.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the signer’s public key, which is equal to *dG*, and the verifier
    accepts the signature only if the x-coordinate of *Q* is equal to the value *r*
    from the signature.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This process works because, as a last step, you compute the point *Q* by substituting
    the public key *P* with its actual value *dG*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-4.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'When you replace *u* and *v* with their actual values, you obtain the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-5.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: This tells you that (*u* + *vd*) is equal to the value *k*, chosen during signature
    generation, and that *uG* + *vdG* is equal to the point *kG*. In other words,
    the verification algorithm succeeds in computing point *kG*, the same point computed
    during signature generation. Validation is complete once a verifier confirms that
    *kG*’s x-coordinate is equal to the *r* received; otherwise, the signature is
    rejected as invalid.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你 (*u* + *vd*) 等于在签名生成过程中选择的值 *k*，并且 *uG* + *vdG* 等于点 *kG*。换句话说，验证算法成功地计算出了点
    *kG*，这是在签名生成过程中计算的相同点。一旦验证者确认 *kG* 的 x 坐标等于接收到的 *r*，验证就完成；否则，签名会被拒绝为无效。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA vs. RSA Signatures</samp>
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA 与 RSA 签名</samp>
- en: While some view elliptic curve cryptography as an alternative to RSA for public-key
    cryptography, ECC and RSA don’t have much in common. You use RSA only for encryption
    and signatures, and ECC is a family of algorithms that you use to perform encryption,
    generate signatures, perform key agreement, and offer advanced cryptographic functionalities
    such as identity-based encryption (a kind of encryption that uses encryption keys
    derived from a personal identifier, such as an email address).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些人认为椭圆曲线加密学是 RSA 公钥加密的替代方案，但 ECC 和 RSA 并没有太多共同之处。你只在加密和签名时使用 RSA，而 ECC 是一系列算法，你可以用它来执行加密、生成签名、进行密钥协议，并提供高级加密功能，如基于身份的加密（一种使用从个人标识符（如电子邮件地址）派生的加密密钥的加密方式）。
- en: When comparing ECDSA to RSA signatures, recall that in RSA signatures, the signer
    uses their private key *d* to compute a signature as *y* = *x**^d* mod *n*, where
    *x* is the data to be signed and *y* is the signature. Verification uses the public
    key *e* to confirm that *y**^e* mod *n* equals *x*—a process that’s clearly simpler
    than that of ECDSA.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较 ECDSA 和 RSA 签名时，回想一下在 RSA 签名中，签名者使用他们的私钥 *d* 来计算签名，公式为 *y* = *x**^d* mod
    *n*，其中 *x* 是要签名的数据，*y* 是签名。验证过程使用公钥 *e* 来确认 *y**^e* mod *n* 是否等于 *x*——这个过程显然比
    ECDSA 的过程要简单。
- en: RSA’s verification process is often faster than ECC’s signature verification
    because it uses a small public key *e*. Verification of an RSA signature then
    consists only in an exponentiation *y*^(65,537) mod *n.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 的验证过程通常比 ECC 的签名验证更快，因为它使用较小的公钥 *e*。RSA 签名的验证过程仅包括对 *y*^(65,537) mod *n*
    的指数运算。
- en: 'ECC has two major advantages over RSA: shorter signatures and signing speed.
    Because ECC works with shorter numbers, it produces shorter signatures than RSA
    (hundreds of bits long, not thousands of bits), which is an obvious benefit if
    you have to store or transmit numerous signatures. Signing with ECDSA is also
    faster than signing with RSA because ECDSA’s arithmetic with much smaller numbers
    is computationally cheaper. For example, [Listing 12-2](chapter12.xhtml#Lis12-2)
    shows that ECDSA is about 200 times faster at signing and about as fast as RSA
    at verifying (benchmarks on an Apple M2 processor). Note that in this example,
    ECDSA signatures are also shorter than RSA signatures because they’re 512 bits
    (two elements of 256 bits each) rather than 4,096 bits.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ECC 相对于 RSA 有两个主要优势：更短的签名和更快的签名速度。由于 ECC 使用的是较短的数字，它比 RSA 生成的签名更短（只有几百位，而不是几千位），如果需要存储或传输大量签名，这是一个明显的优势。使用
    ECDSA 进行签名也比使用 RSA 更快，因为 ECDSA 使用的是更小的数字，其计算开销更小。例如，[列表 12-2](chapter12.xhtml#Lis12-2)
    显示 ECDSA 在签名速度上比 RSA 快大约 200 倍，验证速度与 RSA 相当（基准测试在 Apple M2 处理器上进行）。请注意，在这个例子中，ECDSA
    签名也比 RSA 签名更短，因为它们是 512 位（由两个 256 位元素组成），而不是 4,096 位。
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Comparing the
    speed of 4,096-bit RSA signatures with 256-bit ECDSA signatures</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-2：比较 4,096 位 RSA 签名与 256
    位 ECDSA 签名的速度</samp>
- en: It’s fair to compare the performance of these differently sized signatures because
    they provide a similar security level. However, in practice, many systems use
    RSA signatures with 2,048 bits, which is orders of magnitude less secure than
    256-bit ECDSA. Thanks to its smaller modulus size, 2,048-bit RSA is faster than
    256-bit ECDSA at verifying, yet still slower at signing, as [Listing 12-3](chapter12.xhtml#Lis12-3)
    shows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这些不同大小的签名性能是公平的，因为它们提供了相似的安全性水平。然而，实际上，许多系统使用 2,048 位的 RSA 签名，这比 256 位的 ECDSA
    安全性低几个数量级。由于其较小的模数大小，2,048 位 RSA 在验证时比 256 位 ECDSA 更快，但在签名时仍然较慢，正如 [列表 12-3](chapter12.xhtml#Lis12-3)
    所示。
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: The speed of
    2,048-bit RSA signatures</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: You should prefer ECDSA to RSA except when signature verification is critical
    *and* you don’t care about signing speed, as in a sign-once, verify-many situation
    (for example, when a Windows executable application is signed once and then verified
    by all the systems executing it).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">EdDSA and Ed25519</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ECDSA was introduced in the early 1990s as an elliptic curve version of DSA,
    the digital signature standard from the NSA standardized by NIST in 1991\. But
    in 1989, cryptographer Claus-Peter Schnorr proposed the so-called Schnorr signature
    scheme, an algorithm simpler and more efficient than (EC)DSA and also suitable
    for elliptic curves. However, Schnorr filed a patent restricting the use of his
    signature scheme, preventing wide adoption and standardization.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'After Schnorr’s patent expired in 2008, cryptographers Daniel J. Bernstein,
    Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang built atop Schnorr’s idea
    to create *Edwards-curve DSA (EdDSA)*, a signature suitable only for elliptic
    curves, with the following advantages:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Simpler than ECDSA
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster than ECDSA, both signing and verification
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic (whereas the ECDSA and Schnorr signatures used a random number
    for signing), eliminating the risks related to flawed randomness
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how the general EdDSA works and what makes its specific instance of
    Ed25519 so appealing. To keep it simple, I’ll provide a simplified overview of
    these schemes. For the full details and rationale behind these schemes, see the
    2011 paper “High-Speed High-Security Signatures” and RFC 8032, “Edwards-Curve
    Digital Signature Algorithm (EdDSA).”
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Note that I use notations similar to those in the original article, which may
    differ from notations previously used in this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Signature</samp>
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like any signature scheme, signing with EdDSA requires a private key and a message,
    but unlike with ECDSA, the private key is a random byte string rather than a random
    (scalar) number. You derive the actual private scalar by hashing the private key
    string. This has several security benefits, including making it easier for applications
    to pick a random key by just dumping raw bytes from a PRNG, rather than ensuring
    that the key has the right format and isn’t weak. It also helps to efficiently
    derive a nonce from the key and the message, which replaces the use of a per-signature
    random value like in ECDSA.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Signing then works as follows, from a 256-bit private key *k* and a message
    *M* of arbitrary size, and given a base point *B*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Compute *a* || *h* = **Hash**(*k*), for a hash function producing 512-bit
    values, where the first 256 bits form the private scalar *a* and the last 256
    bits form the string *h*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Define the public key as *A* = *aB* (in practice, this is precomputed).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compute the message’s “pre-hash” *r* = **Hash**(*h* || *M*) and compute
    the elliptic curve point *R* = *rB*, which is the first part of the signature,
    the *signature point*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Compute the number *S* = *r* + **Hash**(*R*, *A*, *M*) × *a*, the second
    part of the signature.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The signature returned is the pair (*R*, *S*).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The computation bottleneck is thus the scalar-point multiplication *rB*, for
    a fixed base point *B*. When messages are long, the cost of hashing the message
    twice may be significant too. However, unlike in ECDSA, you don’t have to compute
    a modular inverse.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you can optimize implementations—for example, to avoid recomputing
    the public key for every signature. You must also set values to the right type
    (such as numbers subject to modular reduction) and encode them in a reliable and
    nonambiguous format (like curve points).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Verification</samp>
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a signature (*R*, *S*), a message *M*, a public key *A*, and a base point
    *B*, verification consists of checking that *SB* equals *R* + **Hash**(*R*, *A*,
    *M*)*A*. Note that *SB* = *S* × *B.*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'If you replace *S* by its expression evaluated in step 4, *SB* is equal to
    the following values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg245-1.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: In this expression, you know that *rB* = *R* and *aB* = *A*. You thus end up
    with the expected result, *R* + **Hash**(*R*, *A*, *M*) × *A*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Compared to ECDSA, you avoid the computation of a modular inverse. Like ECDSA,
    you need two scalar-point multiplications (*SB* and **Hash**(*R*, *A*, *M*)*A*).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ed25519</samp>
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ed25519 is a specific instance of EdDSA with the following parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A *twisted Edwards curve* based on Curve25519, which you’ll see in the next
    section
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-512 as a hash function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A based point *B* chosen to optimize efficiency
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of 2023, Ed25519 is likely the second most popular elliptic curve signature
    algorithm due to its performance benefits and high security guarantees (see *[https://<wbr>ed25519<wbr>.cr<wbr>.yp<wbr>.to](https://ed25519.cr.yp.to)*).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH, Apple products, and many blockchain platforms use Ed25519 to sign transactions.
    In February 2023, Ed25519 was added as a NIST standard, as part of FIPS 186-5,
    “Digital Signature Standard.”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Ed25519 has suffered from some interoperability issues, as you’ll see later
    in this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encrypting with Elliptic Curves</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although you will typically use elliptic curves for signing, you can encrypt
    with them. But you’ll rarely see people do so in practice because of restrictions
    on the size of the plaintext that can be encrypted: you can fit about 100 bits
    of plaintext, as compared to almost 4,000 in RSA with the same security level.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: You can encrypt with elliptic curves with the *elliptic curve integrated encryption
    scheme (ECIES)*, a *hybrid* scheme combining asymmetric and symmetric cryptography.
    It uses a Diffie–Hellman operation to derive a shared secret key, which protects
    data with an authenticated cipher.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a recipient’s public key *P*, ECIES encrypts a message *M*, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick a random number, *d*, and compute the point *Q* = *dG*, where the base
    point *G* is a fixed parameter. Here, (*d*, *Q*) acts as an ephemeral key pair,
    used only for encrypting *M*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Compute an ECDH shared secret by computing *S* = *dP*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Use a key derivation function (KDF) to derive a symmetric key, *K*, from
    *S*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Encrypt *M* using *K* and a symmetric authenticated cipher, obtaining a
    ciphertext, *C*, and an authentication tag, *T*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECIES ciphertext then consists of the ephemeral public key *Q* followed
    by *C* and *T*. Decryption is straightforward: the recipient computes *S* by multiplying
    *Q* with their private exponent, then derives the key *K*, decrypts *C*, and verifies
    *T*.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing a Curve</samp>
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Criteria to assess the safety of an elliptic curve include the order of the
    group you use (that is, its number of points), its addition formulas, and the
    origin of its parameters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of elliptic curves, but not all are equal for cryptographic
    purposes. Choose coefficients *a* and *b* in the curve’s equation *y*² = *x*³
    + *ax* + *b* carefully, according to established security criteria; otherwise,
    you may end up with an insecure curve. In practice, you’ll use an established
    curve for encryption, but knowing what makes a safe curve will help you choose
    among the several available ones and better understand any associated risks. Here
    are some points to keep in mind:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The order of the group shouldn’t be a product of small numbers; otherwise, solving
    ECDLP becomes much easier.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In “The Addition Law” on [page 235](#sec3), you learned that adding points *P*
    + *Q* required a specific addition formula when *Q* = *P*. Unfortunately, treating
    this case differently from the general one may leak critical information if an
    attacker can distinguish doublings from additions between distinct points. Some
    curves are secure *because* they use a single formula for all point addition.
    (When a curve doesn’t require a specific formula for doublings, it admits a *unified*
    addition law.)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the creators of a curve don’t explain the origin of *a* and *b*, they may
    be suspected of foul play because you can’t know whether they’ve chosen weaker
    values that enable some yet-unknown attack on the cryptosystem.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s review some of the most common curves, especially ones used for signatures
    or Diffie–Hellman key agreement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You’ll find more criteria and details about curves on* [https://<wbr>safecurves<wbr>.cr<wbr>.yp<wbr>.to](https://safecurves.cr.yp.to).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NIST Curves</samp>
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2000, NIST standardized several curves in the FIPS 186 document under “Recommended
    Elliptic Curves for Federal Government Use.” Five NIST curves, called *prime curves*,
    work modulo a prime number (see “Elliptic Curves over Integers” on [page 233](#sec2)).
    Ten other NIST curves work with binary polynomials, mathematical objects that
    make implementation in hardware more efficient. (I won’t cover binary polynomials
    in further detail because they’re seldom used with elliptic curves.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The most common NIST curves are the prime curves. Of these, one of the most
    common is P-256, a curve that works over numbers modulo the 256-bit number *p*
    = 2^(256) – 2^(224) + 2^(192) + 2^(96) – 1\. The equation for P-256 is *y*² =
    *x*³ – 3*x* + *b*, where *b* is a 256-bit number. NIST also provides prime curves
    of 192 bits, 224 bits, 384 bits, and 521 bits (this isn’t a typo; it’s 521, not
    512).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'NIST curves are sometimes criticized because only the NSA, creator of the curves,
    knows the origin of the *b* coefficient in their equations. The explanation they’ve
    provided is that *b* results from hashing a random-looking constant with SHA-1\.
    For example, P-256’s *b* parameter comes from the following constant: <samp class="SANS_TheSansMonoCd_W5Regular_11">c49d3608
    86e70493 6a6678e1 139d26b7 819f7e90</samp>. No one knows why the NSA picked this
    particular constant, but most experts don’t believe the curve’s origin hides any
    weakness.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Curve25519</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Daniel J. Bernstein brought Curve25519 (usually pronounced *curve-twenty-five-five-nineteen*)
    to the world in 2006\. Motivated by performance, he designed Curve25519 to be
    faster and use shorter keys than the standard curves. But Curve25519 also brings
    security benefits; unlike the NIST curves, it has no suspicious constants and
    can use the same unified formula for adding distinct points or for doubling a
    point.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The form of Curve25519’s equation, *y*² = *x*³ + 486662*x*² + *x*, is slightly
    different from the other equations in this chapter, but it still belongs to the
    elliptic curve family. The unusual form of this equation allows for specific implementation
    techniques that make Curve25519 fast in software.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519 works with numbers modulo 2^(255) – 19, a prime number that’s as
    close as possible to 2^(255). The *b* coefficient 486662 is the smallest integer
    that satisfies the security criteria set by Bernstein. Taken together, these features
    make Curve25519 more trustworthy than NIST curves and their fishy coefficients.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Curve25519 is used everywhere—for example, in WhatsApp, TLS 1.3, OpenSSH, and
    many other systems. Following this success, Curve25519 was added to the list of
    NIST-approved curves in February 2023, as part of the document SP 800-186, “Recommendations
    for Discrete Logarithm-based Cryptography: Elliptic Curve Domain Parameters.”'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For the details and rationale behind Curve25519, view the 2016 presentation
    “The First 10 Years of Curve25519” by Daniel J. Bernstein at* [https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/talks<wbr>.html#2016<wbr>.03<wbr>.09](https://cr.yp.to/talks.html#2016.03.09).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Curves</samp>
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As I write this, most cryptographic applications use NIST curves or Curve25519
    (including via Ed25519), but there are other legacy standards in use, and newer
    curves are being promoted and pushed within standardization committees. Old national
    standards include France’s ANSSI curves and Germany’s Brainpool curves: two families
    that don’t support complete addition formulas and that use constants of unknown
    origins.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Some newer curves are more efficient than the older ones and are clear of any
    suspicion; they offer different security levels and various efficiency optimizations.
    Examples include Curve41417, a variant of Curve25519, which works with larger
    numbers and offers a higher level of security (approximately 200 bits); Ed448-Goldilocks,
    a 448-bit curve first proposed in 2014 and specified in RFC 8032; and six curves
    proposed by Diego Aranha et al. in “A Note on High-Security General-Purpose Elliptic
    Curves” (see *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2013<wbr>/647](https://eprint.iacr.org/2013/647)*),
    though these curves are rarely used. The details specific to these curves are
    beyond the scope of this book.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Ristretto initiative (*[https://<wbr>ristretto<wbr>.group](https://ristretto.group)*)
    is a technique for constructing prime-order point groups from elliptic curves
    with non-prime order (and therefore having subgroups). Ristretto offers a safe
    and unambiguous way to represent points on an elliptic curve, eliminating risks
    linked to the structure of Curve25519, for example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A downside of elliptic curves is their relative complexity. The greater number
    of parameters than for RSA or classic Diffie–Hellman leaves a larger attack surface
    and more possibilities for design errors and implementation bugs. ECC implementations
    can also be vulnerable to side-channel attacks, especially their big-number arithmetic—for
    example, when the calculation time depends on secret values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I discuss three examples of vulnerabilities that
    can occur with elliptic curves, even when the implementation is safe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA with Bad Randomness</samp>
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECDSA signing is randomized, as it involves a secret random number *k* when
    setting *s* = (*h* + *rd*) / *k* mod *n*. However, if you reuse the same *k* to
    sign a second message, an attacker could combine the resulting values, *s*[1]
    = (*h*[1] + *rd*) / *k* and *s*[2] = (*h*[2] + *rd*) / *k*, to get *s*[1] – *s*[2]
    = (*h*[1] – *h*[2]) / *k* and then *k* = (*h*[1] – *h*[2]) / (*s*[1] – *s*[2]).
    When you know *k*, you can easily recover the private key *d* by computing the
    following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg249-1.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Unlike RSA signatures, which won’t allow the key to be recovered if using a
    weak PRNG, the use of nonrandom numbers can lead to ECDSA’s *k* being recoverable,
    as happened with the attack on the PlayStation 3 game console in 2010, presented
    by the fail0verflow team at the 27th Chaos Communication Congress in Berlin, Germany.
    They discovered that the same *k* was reused to sign different games and were
    then able to find the signing key, which made it possible to sign any program
    to authorize it to run on the console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Invalid Curve Attacks</samp>
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can elegantly break ECDH if input points are not properly validated. The
    primary reason is that the formulas that give the coordinates for the sum of points
    *P* + *Q* never involve the *b* coefficient of the curve; instead, they rely only
    on the coordinates of *P* and *Q* and the *a* coefficient (when doubling a point).
    The unfortunate consequence is that when adding two points, you can’t be sure
    you’re working on the right curve because you may actually be adding points on
    a different curve with a different *b* coefficient. That means you can break ECDH,
    as the following scenario, the *invalid curve attack*, describes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Say that Alice and Bob are running ECDH and agreed on a curve and a base point,
    *G*. Bob sends his public key *bG* to Alice. Alice, instead of sending a public
    key *aG* on the agreed upon curve, sends a point on a different curve, either
    intentionally or accidentally. Unfortunately, this new curve is weak and allows
    Alice to choose a point *P* for which solving ECDLP is easy. She chooses a point
    of low order, for which there’s a relatively small *k* such that *kP* = *O*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Bob, believing that he has a legitimate public key, computes what he thinks
    is the shared secret *bP*, hashes it, and uses the resulting key to encrypt data
    sent to Alice. When Bob computes *bP*, he’s unknowingly computing on the weaker
    curve. As a result, because *P* was chosen to belong to a small subgroup within
    the larger group of points, the result *bP* also belongs to that small subgroup,
    allowing an attacker to determine the shared secret *bP* efficiently if they know
    the order of *P*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: One way to prevent this is to confirm points *P* and *Q* belong to the right
    curve by ensuring their coordinates satisfy the curve’s equation. This ensures
    you’re able to work on only the secure curve.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Such an invalid curve attack was found in 2015 on certain implementations of
    the TLS protocol, which uses ECDH to negotiate session keys. (For details, see
    the paper “Practical Invalid Curve Attacks on TLS-ECDH” by Tibor Jager, Jörg Schwenk,
    and Juraj Somorovsky.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incompatible Ed25519
    Validation Rules</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You saw that Ed25519 is a signature scheme optimized to offer both efficiency
    and high security guarantees. The designers of Ed25519 described how it works
    in detail in a scientific paper and published a well-coded reference implementation.
    The algorithm was specified as an IETF standard in RFC 8032\. One would expect
    there to be only one version of Ed25519 and different implementations to work
    in exactly the same way: for a given input value, they should all behave identically
    and return the same result.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is not the case. As cryptographer Henry de Valence documented
    in the article “It’s 255:19AM. Do You Know What Your Validation Criteria Are?”
    (see *[https://<wbr>hdevalence<wbr>.ca<wbr>/blog<wbr>/2020<wbr>-10<wbr>-04<wbr>-its<wbr>-25519am](https://hdevalence.ca/blog/2020-10-04-its-25519am)*),
    different implementations of Ed25519 have different criteria for what constitutes
    a valid signature. Indeed, RFC 8032 doesn’t fully describe the validation criteria—and
    many implementations don’t even comply with it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Of the 15 implementations in de Valence’s article, each had its own validation
    criteria. In particular, the validation of points *R* (of the signature) and *A*
    (the public key) is often different, as is the verification of the equality between
    *S* × *B* and *R* + **Hash**(*R*, *A*, *M*) × *A*. Divergences can occur at several
    levels, including the encoding of points (how you assemble bytes to describe their
    coordinates) and the validation that points belong to the right subgroup.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: As a result, different implementations of the same scheme could behave differently—for
    example, in a blockchain network where signatures would be accepted by some nodes
    but rejected by others, a problem for a consensus protocol. All details are explained
    in de Valence’s blog post.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography is a fascinating, complex topic that involves lots
    of mathematics. I haven’t discussed important notions such as a point’s order,
    a curve’s cofactor, projective coordinates, torsion points, and methods for solving
    the ECDLP problem. If you’re mathematically inclined, you’ll find information
    on these and other related topics in the *Handbook of Elliptic and Hyperelliptic
    Curve Cryptography* by Henri Cohen and Gerhard Frey (Chapman and Hall/CRC, 2005).
    The 2013 survey “Elliptic Curve Cryptography in Practice” by Joppe Bos, Alex Halderman,
    Nadia Heninger, Jonathan Moore, Michael Naehrig, and Eric Wustrow also gives an
    illustrated introduction with practical examples (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2013<wbr>/734](https://eprint.iacr.org/2013/734)*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
