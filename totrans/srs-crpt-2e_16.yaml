- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ELLIPTIC
    CURVES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The introduction of *elliptic curve cryptography (ECC)* in 1985 revolutionized
    public-key cryptography. It’s more powerful and efficient than alternatives like
    RSA and classical Diffie–Hellman: ECC with a 256-bit key is stronger than RSA
    with a 4,096-bit key. But it’s also more complex.'
  prefs: []
  type: TYPE_NORMAL
- en: Like RSA, ECC consists mainly of multiplications of large numbers, but it does
    so to combine points on a mathematical curve, called an *elliptic curve* (this
    has nothing to do with an ellipse, by the way). To complicate matters, there are
    many types of elliptic curves—simple and sophisticated, efficient and inefficient,
    and secure and insecure, depending on the use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECC wasn’t adopted by standardization bodies until the early 2000s, and it
    wasn’t seen in major cryptographic software until much later: OpenSSL added ECC
    in 2005, and the OpenSSH secure connectivity tool waited until 2011\. You’ll find
    ECC in most HTTPS connections, in mobile phones, and in blockchain platforms such
    as Bitcoin and Ethereum. Indeed, elliptic curves allow you to perform common public-key
    cryptography operations such as encryption, signature, and key agreement faster
    than their classical counterparts. Most cryptographic applications that rely on
    the discrete logarithm problem (DLP) also work when based on its elliptic curve
    counterpart, ECDLP, with one notable exception: the Secure Remote Password (SRP)
    protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on applications of ECC and discusses when and why to use
    ECC over RSA or classical Diffie–Hellman, as well as how to choose the right elliptic
    curve for your application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is an Elliptic Curve?</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An elliptic curve is a *curve* on a plane—a set of points with x- and y-coordinates.
    A curve’s equation defines all the points that belong to that curve. For example,
    the curve *y* = 3 is a horizontal line with the vertical coordinate 3, curves
    of the form *y* = *ax* + *b* with fixed numbers *a* and *b* are straight lines,
    *x*² + *y*² = 1 is a circle of radius 1 centered on the origin, and so on. Whatever
    the type of curve, the points on a curve are (*x*, *y*) pairs that satisfy the
    curve’s equation.
  prefs: []
  type: TYPE_NORMAL
- en: In cryptography, an elliptic curve typically has an equation in the form *y*²
    = *x*³ + *ax* + *b* (the *Weierstrass form*), where the constants *a* and *b*
    define the shape of the curve. For example, [Figure 12-1](chapter12.xhtml#fig12-1)
    shows the elliptic curve that satisfies the equation *y*² = *x*³ – 4*x*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An elliptic curve
    with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">–
    4</samp><samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    shown over the real numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This figure displays all the points that make up the curve for *x* between –3
    and 4, be they points on the left side of the curve, which looks like a circle,
    or on the right side, which looks like a parabola. All points have (*x*, *y*)
    coordinates that satisfy the curve’s equation *y*² = *x*³ – 4*x*. For example,
    when *x* = 0, then *y**²* = *x*³ – 4*x* = 0³ – 4 × 0 = 0; hence, *y* = 0 is a
    solution, and the point (0, 0) belongs to the curve. Likewise, if *x* = 2, the
    solution to the equation is *y* = 0, meaning that the point (2, 0) belongs to
    the curve.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this chapter, I focus on the simplest, most common type of elliptic curves—those
    with an equation like* y*²* *=* x*³* *+* ax *+* b*—but other elliptic curves have
    equations in different forms. For example,* Edwards curves *have equations of
    the form* x*²* *+* y*²* *= 1 +* dx*²*y*²**. Cryptographers sometimes use Edwards
    curves (for example, in the Ed25519 scheme).*'
  prefs: []
  type: TYPE_NORMAL
- en: When using elliptic curves for cryptography, it’s crucial to distinguish points
    that belong to the curve from other points, as points off the curve often present
    a security risk. However, the curve’s equation doesn’t always admit solutions,
    at least not in the natural number plane. For example, to find points with the
    horizontal coordinate *x* = 1, you solve *y*² = *x*³ – 4*x* and obtain *y*² =
    *x*³ – 4*x* = 1³ – 4 × 1, resulting in –3\. But *y*² = –3 doesn’t have a solution
    because there’s no number for which *y*² = –3\. There exists a solution in the
    complex numbers (√3*i*), but in practice, elliptic curve cryptography uses only
    natural numbers (ECC works with integer number modulo a prime number, either directly
    or via polynomials). Because there’s no solution to the curve’s equation for *x*
    = 1, the curve has no point at that position on the x-axis, as you can see in
    [Figure 12-1](chapter12.xhtml#fig12-1).
  prefs: []
  type: TYPE_NORMAL
- en: If you try to solve for *x* = –1, you get the equation *y*² = –1 + 4 = 3, which
    has two solutions (*y* = √3 ≈ 1.73 and *y* = –√3 ≈ –1.73), the square root of
    3 and its negative value. The square of both values is 3, and [Figure 12-1](chapter12.xhtml#fig12-1)
    has two points with *x* = –1\. More generally, the curve is symmetric with respect
    to the x-axis for all points that satisfy its equation (as are all elliptic curves
    of the form *y*² = *x*³ + *ax* + *b*, except for *y* = 0).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curves over
    Integers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s a bit of a twist: the curves in elliptic curve cryptography don’t actually
    look like [Figure 12-1](chapter12.xhtml#fig12-1). They’re neither curves nor ellipses.
    They look instead like [Figure 12-2](chapter12.xhtml#fig12-2), which is a cloud
    of points rather than a curve. What’s going on here?'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The elliptic curve
    with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">–
    4</samp><samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">over</samp>
    <samp class="SANS_Futura_Std_Book_11">Z</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">191</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, the set of integers modulo 191</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 12-1](chapter12.xhtml#fig12-1) and [12-2](chapter12.xhtml#fig12-2)
    are based on the same curve equation, *y*² = *x*³ – 4*x*, but they show the curve’s
    points with respect to different sets of numbers: [Figure 12-1](chapter12.xhtml#fig12-1)
    shows the curve’s points over the set of *real numbers*, which includes negative
    numbers, decimals, and so on. For example, as a continuous curve, it shows the
    points at *x* = 2.0, *x* = 2.1, *x* = 2.00002, and so on. [Figure 12-2](chapter12.xhtml#fig12-2),
    on the other hand, shows only *integers* that satisfy this equation, which excludes
    decimal numbers. Specifically, [Figure 12-2](chapter12.xhtml#fig12-2) shows the
    curve *y*² = *x*³ – 4*x* with respect to the integers *modulo 191*: 0, 1, 2, 3,
    up to 190\. You can denote this set of numbers **Z**[191]. (There’s nothing special
    with 191 here, except that it’s a prime number. I picked a small number to avoid
    having too many points on the graph.) The points in [Figure 12-2](chapter12.xhtml#fig12-2)
    therefore all have x- and y-coordinates that are integers modulo 191 and that
    satisfy the equation *y*² = *x*³ – 4*x*. For example, for *x* = 2, you have *y*²
    = 0, for which *y* = 0 is a valid solution. This tells you that the point (2,
    0) belongs to the curve.'
  prefs: []
  type: TYPE_NORMAL
- en: If *x* = 3, you get the equation *y*² = 27 – 12 = 15, which admits two solutions
    in **Z**[191], 46 and 145\. Indeed, 46² = 2,116, with 2,116 mod 191 = 15, and
    145² = 21,025, with 21,025 mod 191 = 15\. Thus, the points (3, 46) and (3, 145)
    both belong to the curve and appear as in [Figure 12-2](chapter12.xhtml#fig12-2)
    (the two points circled on the left).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Figure 12-2](chapter12.xhtml#fig12-2) considers points from the set denoted*
    ***Z***191 *= {0, 1, 2, . . . , 190}, which includes zero. This differs from the
    groups denoted* ***Z***[p]^* *(with a star superscript) that we discussed in the
    context of RSA and Diffie–Hellman. The reason for this difference is that you’ll
    both multiply and add numbers, and you therefore need to ensure that the set of
    numbers includes addition’s identity element (namely 0, such that* x *+ 0 =* x
    *for every* x *in* ***Z***191*).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Also, every number* x *has an inverse with respect to addition, denoted –*x*,
    such that* x *+ (–*x*) = 0\. For example, the inverse of 100 in* ***Z***191 *is
    91 because 100 + 91 mod 191 = 0\. Such a set of numbers, where addition and multiplication
    are possible and where each element* x *admits an inverse with respect to addition
    (denoted –*x*) as well as an inverse (except for the element zero) with respect
    to multiplication (denoted 1 /* x*), is called a* field*. When a field has a finite
    number of elements, as in* ***Z***191 *and as with all fields used for elliptic
    curve cryptography, it is a* finite field.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Addition Law</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know that the points on an elliptic curve are coordinates (*x*,
    *y*) that satisfy the curve’s equation, *y*² = *x*³ + *ax* + *b*, let’s look at
    how to add elliptic curve points with the *addition law*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Two Points</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Say you want to add two points on the elliptic curve, *P* and *Q*, to give
    a new point, *R*, that is the sum of these two points. The simplest way to understand
    point addition is to determine the position of *R* = *P* + *Q* on the curve relative
    to *P* and *Q* based on a geometric rule: draw the line that connects *P* and
    *Q*, find the other point of the curve that intersects with this line, and *R*
    is the reflection of this point with respect to the x-axis. For example, in [Figure
    12-3](chapter12.xhtml#fig12-3), the line connecting *P* and *Q* intersects the
    curve at a third point between *P* and *Q*, and the point *P* + *Q* is at the
    same x-coordinate but the inverse y-coordinate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A general case
    of the geometric rule for adding points over an elliptic curve</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This geometric rule is simple, but it won’t directly give you the coordinates
    of the point *R*. You compute the coordinates (*x*R, *y*R) of *R* using the coordinates
    (*x*P, *y*P) of *P* and the coordinates (*x*Q, *y*Q) of *Q* using the formulas
    *x*R *= m*² *– x*P *– x*Q and *y*R *= m(x*P *– x*R*) – y*P , where the value *m
    = (y*Q *– y*P*) / (x*Q *– x*P*)* is the slope of the line connecting *P* and *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, these formulas and the line-drawing trick in [Figure 12-3](chapter12.xhtml#fig12-3)
    don’t always work. If, for example, *P* = *Q*, you can’t draw a line between two
    points (there’s only one), and if *Q* = –*P*, the line doesn’t cross the curve
    again, so there’s no point on the curve to mirror. We’ll explore these in the
    next sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Point and Its Negative</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The negative of a point *P* = (*x*P, *y*P) is the point –*P* = (*x*P, –*y*P),
    which is the point mirrored around the x-axis. For any *P*, you can say that *P*
    + (–*P*) = *O*, where *O* is the *point at infinity*. As in [Figure 12-4](chapter12.xhtml#fig12-4),
    the line between *P* and –*P* runs to infinity and never intersects the curve.
    The point at infinity is to elliptic curves what zero is to integers, except that
    it’s only a “virtual” point that you can’t locate at a specific place, because
    it’s infinitely far.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The geometric
    rule for adding a point and its negative, or</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+ (–</samp><samp class="SANS_Futura_Std_Book_11">P</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">O,</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">when the line between the points
    never intersects the curve</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doubling a Point</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When *P* = *Q* (that is, *P* and *Q* are at the same position), adding *P* and
    *Q* is equivalent to computing *P* + *P*, or 2*P*. This addition operation is
    called a *doubling*.
  prefs: []
  type: TYPE_NORMAL
- en: To find the coordinates of the result *R* = 2*P*, you can’t use the geometric
    rule from the previous section, because you can’t draw a line between *P* and
    itself. Instead, you draw the line *tangent* to the curve at *P*, and 2*P* is
    the negation of the point where this line intersects the curve, as [Figure 12-5](chapter12.xhtml#fig12-5)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The geometric
    rule for doubling a point—that is,</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">P</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The formula to determine the coordinates (*x*R, *y*R) of *R* = *P* + *P* is
    slightly different from the formula for a distinct *P* and *Q*. The basic formula
    is *x*R = *m*² – *x*P – *x*Q and *y*R = *m*(*x*P – *x*R) – *y*P , but the value
    of *m* becomes (3*x*P² + *a*) / 2*y*P , where *a* is the curve’s parameter, as
    in *y*² = *x*³ + *ax* + *b*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Multiplying Points</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To multiply points on elliptic curves by a given integer number *k*, you determine
    the point *kP* by adding *P* to itself *k* – 1 times. In other words, 2*P* = *P*
    + *P*, 3*P* = *P* + *P* + *P*, and so on. To obtain the x- and y-coordinates of
    *kP*, repeatedly add *P* to itself and apply the preceding addition law.
  prefs: []
  type: TYPE_NORMAL
- en: To compute *kP* efficiently, however, the naive technique of adding *P* by applying
    the addition law *k* – 1 times is far from optimal. For example, if *k* is large
    (of the order of, say, 2^(256)) as it occurs in elliptic curve–based crypto schemes,
    then computing *k* – 1 additions is downright infeasible.
  prefs: []
  type: TYPE_NORMAL
- en: You can gain an exponential speedup by adapting the technique in [Chapter 10](chapter10.xhtml)’s
    “A Fast Exponentiation Algorithm” to compute *x**^e* mod *n*. The difference is
    that you’re multiplying points by an integer rather than computing exponentiations.
    But you can adapt the method to become *double-and-add*, where multiplication
    becomes addition and squaring becomes doubling.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to compute 8*P* in three additions instead of seven using the
    naive method, first compute *P*[2] = *P* + *P*, then *P*[4] = *P*[2] + *P*[2],
    and finally *P*[4] + *P*[4] = 8*P*. This is the simplest case, when the multiplier
    is a power of two, such as 8 = 2³. Otherwise, for example, to compute 10*P*, proceed
    as follows: observing that 10 is 1010 in binary, start by the most significant
    (“leftmost”) bit and compute the result *R* like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit 1 **Start by setting *R* = *P*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit 0 **Double, setting *R* = 2*R* = 2*P*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit 1 **Double and add, setting *R* = 2*R* + *P* = 2(2*P*) + *P* = 5*P*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit 0 **Double, setting *R* = 2*R* = 2(5*P*) = 10*P*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curve Groups</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Not only can you add elliptic curve points together, you can also use them to
    form a group structure. According to the definition of a group (see “Groups” in
    [Chapter 9](chapter9.xhtml)), if the points *P* and *Q* belong to a given curve,
    then *P* + *Q* also belongs to the curve.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, because addition is *associative*, you have (*P* + *Q*) + *R* =
    *P* + (*Q* + *R*) for any points *P*, *Q*, and *R*. In a group of elliptic curve
    points, we call the identity element the point at infinity and denote it as *O*,
    such that *P* + *O* = *P* for any *P*. Every point *P* = (*x*P, *y*P) has an inverse,
    –*P* = (*x*P , –*y*P), such that *P* + (–*P*) = *O*.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, most elliptic curve–based cryptosystems work with x- and y-coordinates
    that are numbers modulo a prime number, *p* (in other words, numbers in the finite
    field **Z**p). Just as the security of RSA depends on the size of the numbers
    used, the security of an elliptic curve–based cryptosystem depends on the number
    of points on the curve. But how do you know the number of points on an elliptic
    curve, or its *cardinality*? Well, it depends on the curve and the value of *p*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Prime fields aren’t the only fields used in elliptic curve cryptography. There
    are also* binary fields*, which are extensions of the two-element field (which
    includes 0 and 1), whose elements are represented as polynomials with binary coefficients.
    Arithmetic over binary fields has the advantage of often being easier to implement
    efficiently in hardware as logic circuits, compared to a general-purpose microprocessor.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are of the order of *p* points on a curve defined over **Z**p, but you
    can compute the exact number of points with Schoof’s algorithm, which counts points
    on elliptic curves over finite fields. You’ll find this algorithm built into SageMath.
    For example, [Listing 12-1](chapter12.xhtml#Lis12-1) uses Schoof’s algorithm to
    count the number of points on the curve *y*² = *x*³ – 4*x* over **Z**[191] from
    [Figure 12-1](chapter12.xhtml#fig12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Computing the
    cardinality, or the number of points on a curve</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 12-1](chapter12.xhtml#Lis12-1), you first define the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> as the set over integers modulo
    191; then you define the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    as the elliptic curve over <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp>
    with the coefficients –4 and 0\. Finally, you compute the number of points on
    the curve, or its *cardinality*, *group order*, or just *order*. This count includes
    the point at infinity *O*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The ECDLP Problem</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 9](chapter9.xhtml) introduced the discrete logarithm problem (DLP):
    that of finding the number *y* given some base number *g*, where *x* = *g* *^y*
    mod *p* for some large prime number *p*. Cryptography with elliptic curves has
    a similar problem of finding the number *k* given a base point *P* where the point
    *Q* = *kP*. This is the elliptic curve discrete logarithm problem. Instead of
    numbers, the elliptic curve’s problems operate on points and use multiplication
    instead of exponentiation.'
  prefs: []
  type: TYPE_NORMAL
- en: About all elliptic curve cryptography is built on the ECDLP problem, which,
    like DLP, is believed to be hard and has withstood cryptanalysis since its introduction
    in 1985\. One important difference from the classical DLP is that ECDLP allows
    you to work with smaller numbers and still enjoy a similar level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, when the parameter *p* is *n*-bit, ECC gets you a security level
    of about *n*/2 bits. For example, an elliptic curve taken over numbers modulo
    a 256-bit *p* gives a security level of about 128 bits. For the sake of comparison,
    to achieve a similar security level with DLP or RSA, you need to use numbers of
    several thousands of bits. Using smaller numbers for ECC arithmetic is one reason
    why it’s often faster than RSA or classical Diffie–Hellman.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to solving ECDLP is to find a collision between two outputs, *c*[1]*P*
    + *d*[1]*Q* and *c*[2]*P* + *d*[2]*Q*. The points *P* and *Q* in these equations
    are such that *Q* = *kP* for some unknown *k*, and *c*[1], *d*[1], *c*[2], and
    *d*[2] are the numbers you need to find *k*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the hash function in [Chapter 6](chapter6.xhtml), a collision occurs
    when two different inputs produce the same output. Therefore, to solve ECDLP,
    you need to find points where the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg240-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assuming you’ve found the four coefficients, you’re going to recover *k*. For
    this, replace *Q* with the value *kP*, and you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg240-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tells you that (*c*[1] + *d*[1]*k*) equals (*c*[2] + *d*[2]*k*) when taken
    modulo the number of points on the curve, which isn’t a secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, you can deduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg241-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And you’ve found *k*, the solution to ECDLP. Of course, that’s only the big
    picture—the details are more complex and interesting, notably regarding the way
    to recover the coefficients *c*[1], *c*[2], *d*[1], *d*[2].
  prefs: []
  type: TYPE_NORMAL
- en: In practice, elliptic curves extend over numbers of at least 256 bits, which
    makes attacking elliptic curve cryptography by finding a collision impractical
    because doing so takes up to 2^(128) operations (the cost of finding a collision
    over 256-bit numbers—see [Chapter 6](chapter6.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Key Agreement over Elliptic
    Curves</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall from [Chapter 11](chapter11.xhtml) that in the classical Diffie–Hellman
    (DH) key agreement protocol, two parties establish a shared secret by exchanging
    nonsecret values. Given some fixed number *g*, Alice picks a secret random number
    *a*, computes *A* = *g**^a*, and sends *A* to Bob. Then Bob picks a secret random
    *b* and sends *B* = *g**^b* to Alice. Both combine their secret key with the other’s
    public key to produce the same *A**^b* = *B**^a* = *g**^(ab)*.
  prefs: []
  type: TYPE_NORMAL
- en: The elliptic curve version of DH, *elliptic curve Diffie–Hellman (ECDH)*, is
    identical to that of classical DH but with different notations. In the case of
    ECC, for some fixed-point *G*, Alice picks a secret random number *a*, computes
    *A* = *aG* (the point *G* multiplied by the integer *a*), and sends *A* to Bob.
    Bob picks a secret random *b*, computes the point *B* = *bG*, and sends it to
    Alice. Then both compute the same shared secret, *aB* = *bA* = *abG*.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECDH is to the ECDLP problem what DH is to DLP: it’s secure as long as ECDLP
    is hard. You can therefore adapt DH protocols that rely on DLP to work with elliptic
    curves and rely on ECDLP as a hardness assumption. For example, authenticated
    DH and Menezes–Qu–Vanstone (MQV) will also be secure when used with elliptic curves.
    In fact, MQV was first defined as working over elliptic curves.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Signing with Elliptic Curves</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main standard algorithm you can use for signing with ECC is *elliptic curve
    digital signature algorithm (ECDSA)*. This algorithm has replaced RSA signatures
    and classical DSA signatures in many applications. ECDSA is a NIST standard, is
    supported in the TLS and SSH protocols, and is the main signature algorithm in
    many blockchain platforms, including Bitcoin and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: As with all signature schemes, ECDSA consists of a *signature generation* algorithm
    that the signer uses to create a signature using their private key and a *verification*
    algorithm that a verifier uses to check a signature’s correctness given the signer’s
    public key. The signer holds a number, *d*, as a private key, and verifiers hold
    the public key, *P* = *dG*. Both know in advance what elliptic curve to use, its
    order (*n*, the number of points in the curve), and the coordinates of a base
    point, *G*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Generation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To sign a message, the signer first hashes the message with a cryptographic
    hash function such as SHA-256 or BLAKE2 to generate a hash value, *h*, that you
    interpret as a number between 0 and *n* – 1\. Next, the signer picks a random
    number, *k*, between 1 and *n* – 1 and computes *kG*, a point with the coordinates
    (*x*, *y*). The signer now sets *r* = *x* mod *n* and computes *s* = (*h* + *rd*)
    / *k* mod *n* and then uses these values as the signature (*r*, *s*).
  prefs: []
  type: TYPE_NORMAL
- en: The length of the signature depends on the coordinate lengths you’re using.
    For example, when you’re working with a curve where coordinates are 256-bit numbers,
    *r* and *s* are both 256 bits long, yielding a 512-bit-long signature.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Verification</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ECDSA verification algorithm uses a signer’s public key to verify the validity
    of a signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify an ECDSA signature (*r*, *s*) and a message’s hash, *h*, the verifier
    first computes *w* = 1 / *s*, the inverse of *s* in the signature, which is equal
    to *k* / (*h* + *rd*) mod *n*, since *s* is defined as *s* = (*h* + *rd*) / *k*.
    Next, the verifier multiplies *w* with *h* to find *u* according to the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The verifier then multiplies *w* with *r* to find *v*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given *u* and *v*, the verifier computes the point *Q* according to the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the signer’s public key, which is equal to *dG*, and the verifier
    accepts the signature only if the x-coordinate of *Q* is equal to the value *r*
    from the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process works because, as a last step, you compute the point *Q* by substituting
    the public key *P* with its actual value *dG*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you replace *u* and *v* with their actual values, you obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg242-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tells you that (*u* + *vd*) is equal to the value *k*, chosen during signature
    generation, and that *uG* + *vdG* is equal to the point *kG*. In other words,
    the verification algorithm succeeds in computing point *kG*, the same point computed
    during signature generation. Validation is complete once a verifier confirms that
    *kG*’s x-coordinate is equal to the *r* received; otherwise, the signature is
    rejected as invalid.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA vs. RSA Signatures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While some view elliptic curve cryptography as an alternative to RSA for public-key
    cryptography, ECC and RSA don’t have much in common. You use RSA only for encryption
    and signatures, and ECC is a family of algorithms that you use to perform encryption,
    generate signatures, perform key agreement, and offer advanced cryptographic functionalities
    such as identity-based encryption (a kind of encryption that uses encryption keys
    derived from a personal identifier, such as an email address).
  prefs: []
  type: TYPE_NORMAL
- en: When comparing ECDSA to RSA signatures, recall that in RSA signatures, the signer
    uses their private key *d* to compute a signature as *y* = *x**^d* mod *n*, where
    *x* is the data to be signed and *y* is the signature. Verification uses the public
    key *e* to confirm that *y**^e* mod *n* equals *x*—a process that’s clearly simpler
    than that of ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: RSA’s verification process is often faster than ECC’s signature verification
    because it uses a small public key *e*. Verification of an RSA signature then
    consists only in an exponentiation *y*^(65,537) mod *n.*
  prefs: []
  type: TYPE_NORMAL
- en: 'ECC has two major advantages over RSA: shorter signatures and signing speed.
    Because ECC works with shorter numbers, it produces shorter signatures than RSA
    (hundreds of bits long, not thousands of bits), which is an obvious benefit if
    you have to store or transmit numerous signatures. Signing with ECDSA is also
    faster than signing with RSA because ECDSA’s arithmetic with much smaller numbers
    is computationally cheaper. For example, [Listing 12-2](chapter12.xhtml#Lis12-2)
    shows that ECDSA is about 200 times faster at signing and about as fast as RSA
    at verifying (benchmarks on an Apple M2 processor). Note that in this example,
    ECDSA signatures are also shorter than RSA signatures because they’re 512 bits
    (two elements of 256 bits each) rather than 4,096 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Comparing the
    speed of 4,096-bit RSA signatures with 256-bit ECDSA signatures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It’s fair to compare the performance of these differently sized signatures because
    they provide a similar security level. However, in practice, many systems use
    RSA signatures with 2,048 bits, which is orders of magnitude less secure than
    256-bit ECDSA. Thanks to its smaller modulus size, 2,048-bit RSA is faster than
    256-bit ECDSA at verifying, yet still slower at signing, as [Listing 12-3](chapter12.xhtml#Lis12-3)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: The speed of
    2,048-bit RSA signatures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should prefer ECDSA to RSA except when signature verification is critical
    *and* you don’t care about signing speed, as in a sign-once, verify-many situation
    (for example, when a Windows executable application is signed once and then verified
    by all the systems executing it).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">EdDSA and Ed25519</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ECDSA was introduced in the early 1990s as an elliptic curve version of DSA,
    the digital signature standard from the NSA standardized by NIST in 1991\. But
    in 1989, cryptographer Claus-Peter Schnorr proposed the so-called Schnorr signature
    scheme, an algorithm simpler and more efficient than (EC)DSA and also suitable
    for elliptic curves. However, Schnorr filed a patent restricting the use of his
    signature scheme, preventing wide adoption and standardization.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Schnorr’s patent expired in 2008, cryptographers Daniel J. Bernstein,
    Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang built atop Schnorr’s idea
    to create *Edwards-curve DSA (EdDSA)*, a signature suitable only for elliptic
    curves, with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Simpler than ECDSA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster than ECDSA, both signing and verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic (whereas the ECDSA and Schnorr signatures used a random number
    for signing), eliminating the risks related to flawed randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how the general EdDSA works and what makes its specific instance of
    Ed25519 so appealing. To keep it simple, I’ll provide a simplified overview of
    these schemes. For the full details and rationale behind these schemes, see the
    2011 paper “High-Speed High-Security Signatures” and RFC 8032, “Edwards-Curve
    Digital Signature Algorithm (EdDSA).”
  prefs: []
  type: TYPE_NORMAL
- en: Note that I use notations similar to those in the original article, which may
    differ from notations previously used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Signature</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like any signature scheme, signing with EdDSA requires a private key and a message,
    but unlike with ECDSA, the private key is a random byte string rather than a random
    (scalar) number. You derive the actual private scalar by hashing the private key
    string. This has several security benefits, including making it easier for applications
    to pick a random key by just dumping raw bytes from a PRNG, rather than ensuring
    that the key has the right format and isn’t weak. It also helps to efficiently
    derive a nonce from the key and the message, which replaces the use of a per-signature
    random value like in ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signing then works as follows, from a 256-bit private key *k* and a message
    *M* of arbitrary size, and given a base point *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Compute *a* || *h* = **Hash**(*k*), for a hash function producing 512-bit
    values, where the first 256 bits form the private scalar *a* and the last 256
    bits form the string *h*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Define the public key as *A* = *aB* (in practice, this is precomputed).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compute the message’s “pre-hash” *r* = **Hash**(*h* || *M*) and compute
    the elliptic curve point *R* = *rB*, which is the first part of the signature,
    the *signature point*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Compute the number *S* = *r* + **Hash**(*R*, *A*, *M*) × *a*, the second
    part of the signature.
  prefs: []
  type: TYPE_NORMAL
- en: The signature returned is the pair (*R*, *S*).
  prefs: []
  type: TYPE_NORMAL
- en: The computation bottleneck is thus the scalar-point multiplication *rB*, for
    a fixed base point *B*. When messages are long, the cost of hashing the message
    twice may be significant too. However, unlike in ECDSA, you don’t have to compute
    a modular inverse.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you can optimize implementations—for example, to avoid recomputing
    the public key for every signature. You must also set values to the right type
    (such as numbers subject to modular reduction) and encode them in a reliable and
    nonambiguous format (like curve points).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Verification</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a signature (*R*, *S*), a message *M*, a public key *A*, and a base point
    *B*, verification consists of checking that *SB* equals *R* + **Hash**(*R*, *A*,
    *M*)*A*. Note that *SB* = *S* × *B.*
  prefs: []
  type: TYPE_NORMAL
- en: 'If you replace *S* by its expression evaluated in step 4, *SB* is equal to
    the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg245-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this expression, you know that *rB* = *R* and *aB* = *A*. You thus end up
    with the expected result, *R* + **Hash**(*R*, *A*, *M*) × *A*.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to ECDSA, you avoid the computation of a modular inverse. Like ECDSA,
    you need two scalar-point multiplications (*SB* and **Hash**(*R*, *A*, *M*)*A*).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ed25519</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ed25519 is a specific instance of EdDSA with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A *twisted Edwards curve* based on Curve25519, which you’ll see in the next
    section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-512 as a hash function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A based point *B* chosen to optimize efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of 2023, Ed25519 is likely the second most popular elliptic curve signature
    algorithm due to its performance benefits and high security guarantees (see *[https://<wbr>ed25519<wbr>.cr<wbr>.yp<wbr>.to](https://ed25519.cr.yp.to)*).
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH, Apple products, and many blockchain platforms use Ed25519 to sign transactions.
    In February 2023, Ed25519 was added as a NIST standard, as part of FIPS 186-5,
    “Digital Signature Standard.”
  prefs: []
  type: TYPE_NORMAL
- en: Ed25519 has suffered from some interoperability issues, as you’ll see later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encrypting with Elliptic Curves</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although you will typically use elliptic curves for signing, you can encrypt
    with them. But you’ll rarely see people do so in practice because of restrictions
    on the size of the plaintext that can be encrypted: you can fit about 100 bits
    of plaintext, as compared to almost 4,000 in RSA with the same security level.'
  prefs: []
  type: TYPE_NORMAL
- en: You can encrypt with elliptic curves with the *elliptic curve integrated encryption
    scheme (ECIES)*, a *hybrid* scheme combining asymmetric and symmetric cryptography.
    It uses a Diffie–Hellman operation to derive a shared secret key, which protects
    data with an authenticated cipher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a recipient’s public key *P*, ECIES encrypts a message *M*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick a random number, *d*, and compute the point *Q* = *dG*, where the base
    point *G* is a fixed parameter. Here, (*d*, *Q*) acts as an ephemeral key pair,
    used only for encrypting *M*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Compute an ECDH shared secret by computing *S* = *dP*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Use a key derivation function (KDF) to derive a symmetric key, *K*, from
    *S*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Encrypt *M* using *K* and a symmetric authenticated cipher, obtaining a
    ciphertext, *C*, and an authentication tag, *T*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECIES ciphertext then consists of the ephemeral public key *Q* followed
    by *C* and *T*. Decryption is straightforward: the recipient computes *S* by multiplying
    *Q* with their private exponent, then derives the key *K*, decrypts *C*, and verifies
    *T*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing a Curve</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Criteria to assess the safety of an elliptic curve include the order of the
    group you use (that is, its number of points), its addition formulas, and the
    origin of its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of elliptic curves, but not all are equal for cryptographic
    purposes. Choose coefficients *a* and *b* in the curve’s equation *y*² = *x*³
    + *ax* + *b* carefully, according to established security criteria; otherwise,
    you may end up with an insecure curve. In practice, you’ll use an established
    curve for encryption, but knowing what makes a safe curve will help you choose
    among the several available ones and better understand any associated risks. Here
    are some points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The order of the group shouldn’t be a product of small numbers; otherwise, solving
    ECDLP becomes much easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In “The Addition Law” on [page 235](#sec3), you learned that adding points *P*
    + *Q* required a specific addition formula when *Q* = *P*. Unfortunately, treating
    this case differently from the general one may leak critical information if an
    attacker can distinguish doublings from additions between distinct points. Some
    curves are secure *because* they use a single formula for all point addition.
    (When a curve doesn’t require a specific formula for doublings, it admits a *unified*
    addition law.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the creators of a curve don’t explain the origin of *a* and *b*, they may
    be suspected of foul play because you can’t know whether they’ve chosen weaker
    values that enable some yet-unknown attack on the cryptosystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s review some of the most common curves, especially ones used for signatures
    or Diffie–Hellman key agreement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You’ll find more criteria and details about curves on* [https://<wbr>safecurves<wbr>.cr<wbr>.yp<wbr>.to](https://safecurves.cr.yp.to).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NIST Curves</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2000, NIST standardized several curves in the FIPS 186 document under “Recommended
    Elliptic Curves for Federal Government Use.” Five NIST curves, called *prime curves*,
    work modulo a prime number (see “Elliptic Curves over Integers” on [page 233](#sec2)).
    Ten other NIST curves work with binary polynomials, mathematical objects that
    make implementation in hardware more efficient. (I won’t cover binary polynomials
    in further detail because they’re seldom used with elliptic curves.)
  prefs: []
  type: TYPE_NORMAL
- en: The most common NIST curves are the prime curves. Of these, one of the most
    common is P-256, a curve that works over numbers modulo the 256-bit number *p*
    = 2^(256) – 2^(224) + 2^(192) + 2^(96) – 1\. The equation for P-256 is *y*² =
    *x*³ – 3*x* + *b*, where *b* is a 256-bit number. NIST also provides prime curves
    of 192 bits, 224 bits, 384 bits, and 521 bits (this isn’t a typo; it’s 521, not
    512).
  prefs: []
  type: TYPE_NORMAL
- en: 'NIST curves are sometimes criticized because only the NSA, creator of the curves,
    knows the origin of the *b* coefficient in their equations. The explanation they’ve
    provided is that *b* results from hashing a random-looking constant with SHA-1\.
    For example, P-256’s *b* parameter comes from the following constant: <samp class="SANS_TheSansMonoCd_W5Regular_11">c49d3608
    86e70493 6a6678e1 139d26b7 819f7e90</samp>. No one knows why the NSA picked this
    particular constant, but most experts don’t believe the curve’s origin hides any
    weakness.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Curve25519</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Daniel J. Bernstein brought Curve25519 (usually pronounced *curve-twenty-five-five-nineteen*)
    to the world in 2006\. Motivated by performance, he designed Curve25519 to be
    faster and use shorter keys than the standard curves. But Curve25519 also brings
    security benefits; unlike the NIST curves, it has no suspicious constants and
    can use the same unified formula for adding distinct points or for doubling a
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The form of Curve25519’s equation, *y*² = *x*³ + 486662*x*² + *x*, is slightly
    different from the other equations in this chapter, but it still belongs to the
    elliptic curve family. The unusual form of this equation allows for specific implementation
    techniques that make Curve25519 fast in software.
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519 works with numbers modulo 2^(255) – 19, a prime number that’s as
    close as possible to 2^(255). The *b* coefficient 486662 is the smallest integer
    that satisfies the security criteria set by Bernstein. Taken together, these features
    make Curve25519 more trustworthy than NIST curves and their fishy coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Curve25519 is used everywhere—for example, in WhatsApp, TLS 1.3, OpenSSH, and
    many other systems. Following this success, Curve25519 was added to the list of
    NIST-approved curves in February 2023, as part of the document SP 800-186, “Recommendations
    for Discrete Logarithm-based Cryptography: Elliptic Curve Domain Parameters.”'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For the details and rationale behind Curve25519, view the 2016 presentation
    “The First 10 Years of Curve25519” by Daniel J. Bernstein at* [https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/talks<wbr>.html#2016<wbr>.03<wbr>.09](https://cr.yp.to/talks.html#2016.03.09).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Curves</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As I write this, most cryptographic applications use NIST curves or Curve25519
    (including via Ed25519), but there are other legacy standards in use, and newer
    curves are being promoted and pushed within standardization committees. Old national
    standards include France’s ANSSI curves and Germany’s Brainpool curves: two families
    that don’t support complete addition formulas and that use constants of unknown
    origins.'
  prefs: []
  type: TYPE_NORMAL
- en: Some newer curves are more efficient than the older ones and are clear of any
    suspicion; they offer different security levels and various efficiency optimizations.
    Examples include Curve41417, a variant of Curve25519, which works with larger
    numbers and offers a higher level of security (approximately 200 bits); Ed448-Goldilocks,
    a 448-bit curve first proposed in 2014 and specified in RFC 8032; and six curves
    proposed by Diego Aranha et al. in “A Note on High-Security General-Purpose Elliptic
    Curves” (see *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2013<wbr>/647](https://eprint.iacr.org/2013/647)*),
    though these curves are rarely used. The details specific to these curves are
    beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Ristretto initiative (*[https://<wbr>ristretto<wbr>.group](https://ristretto.group)*)
    is a technique for constructing prime-order point groups from elliptic curves
    with non-prime order (and therefore having subgroups). Ristretto offers a safe
    and unambiguous way to represent points on an elliptic curve, eliminating risks
    linked to the structure of Curve25519, for example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A downside of elliptic curves is their relative complexity. The greater number
    of parameters than for RSA or classic Diffie–Hellman leaves a larger attack surface
    and more possibilities for design errors and implementation bugs. ECC implementations
    can also be vulnerable to side-channel attacks, especially their big-number arithmetic—for
    example, when the calculation time depends on secret values.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I discuss three examples of vulnerabilities that
    can occur with elliptic curves, even when the implementation is safe.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA with Bad Randomness</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECDSA signing is randomized, as it involves a secret random number *k* when
    setting *s* = (*h* + *rd*) / *k* mod *n*. However, if you reuse the same *k* to
    sign a second message, an attacker could combine the resulting values, *s*[1]
    = (*h*[1] + *rd*) / *k* and *s*[2] = (*h*[2] + *rd*) / *k*, to get *s*[1] – *s*[2]
    = (*h*[1] – *h*[2]) / *k* and then *k* = (*h*[1] – *h*[2]) / (*s*[1] – *s*[2]).
    When you know *k*, you can easily recover the private key *d* by computing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg249-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike RSA signatures, which won’t allow the key to be recovered if using a
    weak PRNG, the use of nonrandom numbers can lead to ECDSA’s *k* being recoverable,
    as happened with the attack on the PlayStation 3 game console in 2010, presented
    by the fail0verflow team at the 27th Chaos Communication Congress in Berlin, Germany.
    They discovered that the same *k* was reused to sign different games and were
    then able to find the signing key, which made it possible to sign any program
    to authorize it to run on the console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Invalid Curve Attacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can elegantly break ECDH if input points are not properly validated. The
    primary reason is that the formulas that give the coordinates for the sum of points
    *P* + *Q* never involve the *b* coefficient of the curve; instead, they rely only
    on the coordinates of *P* and *Q* and the *a* coefficient (when doubling a point).
    The unfortunate consequence is that when adding two points, you can’t be sure
    you’re working on the right curve because you may actually be adding points on
    a different curve with a different *b* coefficient. That means you can break ECDH,
    as the following scenario, the *invalid curve attack*, describes.
  prefs: []
  type: TYPE_NORMAL
- en: Say that Alice and Bob are running ECDH and agreed on a curve and a base point,
    *G*. Bob sends his public key *bG* to Alice. Alice, instead of sending a public
    key *aG* on the agreed upon curve, sends a point on a different curve, either
    intentionally or accidentally. Unfortunately, this new curve is weak and allows
    Alice to choose a point *P* for which solving ECDLP is easy. She chooses a point
    of low order, for which there’s a relatively small *k* such that *kP* = *O*.
  prefs: []
  type: TYPE_NORMAL
- en: Bob, believing that he has a legitimate public key, computes what he thinks
    is the shared secret *bP*, hashes it, and uses the resulting key to encrypt data
    sent to Alice. When Bob computes *bP*, he’s unknowingly computing on the weaker
    curve. As a result, because *P* was chosen to belong to a small subgroup within
    the larger group of points, the result *bP* also belongs to that small subgroup,
    allowing an attacker to determine the shared secret *bP* efficiently if they know
    the order of *P*.
  prefs: []
  type: TYPE_NORMAL
- en: One way to prevent this is to confirm points *P* and *Q* belong to the right
    curve by ensuring their coordinates satisfy the curve’s equation. This ensures
    you’re able to work on only the secure curve.
  prefs: []
  type: TYPE_NORMAL
- en: Such an invalid curve attack was found in 2015 on certain implementations of
    the TLS protocol, which uses ECDH to negotiate session keys. (For details, see
    the paper “Practical Invalid Curve Attacks on TLS-ECDH” by Tibor Jager, Jörg Schwenk,
    and Juraj Somorovsky.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incompatible Ed25519
    Validation Rules</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You saw that Ed25519 is a signature scheme optimized to offer both efficiency
    and high security guarantees. The designers of Ed25519 described how it works
    in detail in a scientific paper and published a well-coded reference implementation.
    The algorithm was specified as an IETF standard in RFC 8032\. One would expect
    there to be only one version of Ed25519 and different implementations to work
    in exactly the same way: for a given input value, they should all behave identically
    and return the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is not the case. As cryptographer Henry de Valence documented
    in the article “It’s 255:19AM. Do You Know What Your Validation Criteria Are?”
    (see *[https://<wbr>hdevalence<wbr>.ca<wbr>/blog<wbr>/2020<wbr>-10<wbr>-04<wbr>-its<wbr>-25519am](https://hdevalence.ca/blog/2020-10-04-its-25519am)*),
    different implementations of Ed25519 have different criteria for what constitutes
    a valid signature. Indeed, RFC 8032 doesn’t fully describe the validation criteria—and
    many implementations don’t even comply with it.
  prefs: []
  type: TYPE_NORMAL
- en: Of the 15 implementations in de Valence’s article, each had its own validation
    criteria. In particular, the validation of points *R* (of the signature) and *A*
    (the public key) is often different, as is the verification of the equality between
    *S* × *B* and *R* + **Hash**(*R*, *A*, *M*) × *A*. Divergences can occur at several
    levels, including the encoding of points (how you assemble bytes to describe their
    coordinates) and the validation that points belong to the right subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, different implementations of the same scheme could behave differently—for
    example, in a blockchain network where signatures would be accepted by some nodes
    but rejected by others, a problem for a consensus protocol. All details are explained
    in de Valence’s blog post.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography is a fascinating, complex topic that involves lots
    of mathematics. I haven’t discussed important notions such as a point’s order,
    a curve’s cofactor, projective coordinates, torsion points, and methods for solving
    the ECDLP problem. If you’re mathematically inclined, you’ll find information
    on these and other related topics in the *Handbook of Elliptic and Hyperelliptic
    Curve Cryptography* by Henri Cohen and Gerhard Frey (Chapman and Hall/CRC, 2005).
    The 2013 survey “Elliptic Curve Cryptography in Practice” by Joppe Bos, Alex Halderman,
    Nadia Heninger, Jonathan Moore, Michael Naehrig, and Eric Wustrow also gives an
    illustrated introduction with practical examples (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2013<wbr>/734](https://eprint.iacr.org/2013/734)*).
  prefs: []
  type: TYPE_NORMAL
