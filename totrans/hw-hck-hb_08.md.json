["```\nint checkPassword() {\n    int user_pin[] = {1, 1, 1, 1};\n    int correct_pin[] = {5, 9, 8, 2};\n\n    // Disable the error LED\n    error_led_off();\n // Store four most recent buttons\n    for(int i = 0; i < 4; i++) {\n        user_pin[i] = read_button();\n    }\n\n    // Wait until user presses 'Valid' button\n    while(valid_pressed() == 0);\n\n    // Check stored button press with correct PIN\n    for(int i = 0; i < 4; i++) {\n        if(user_pin[i] != correct_pin[i]) {\n            error_led_on();\n            return 0;\n        }\n    }\n\n    return 1;\n}\n```", "```\nunsigned int do_magic(unsigned int secret_data, unsigned int m, unsigned int n) {\n    unsigned int P = 1;\n    unsigned int s = m;\n    unsigned int i;\n\n    for(i = 0; i < 10; i++) {\n        if (i > 0)\n            s = (s * s) % n;\n\n        if (secret_data & 0x01)\n            P = (P * s) % n;\n\n        secret_data = secret_data >> 1;\n    }\n\n    return P;\n}\n```", "```\n int ei, state = 0;\n 1 for( int i = 0; i < secret_key_size; i++ ){\n     2 ei = (secret_key >> i) & 1;\n     3 if( ei == 0 && state == 0 )\n           // Do nothing, loop for next bit\n       else\n         4 state = 2;\n}\n`--snip--`\n```", "````If the `state` comparison was done first instead, the comparison would never even reach the point of checking the `ei` value once the `state` variable was nonzero (the `state` variable becomes nonzero after processing the first secret key bit set to 1). The simple fix (which may not work with every compiler) is to swap the order of the comparison to be `state == 0 && ei == 0`. This example shows the importance of checking your implementation as a developer and the value in making basic assumptions as an attacker.    As you can see, SPA exploits the fact that different operations introduce differences in power consumption. In practice, you should easily be able to see different instruction paths when they differ by a few dozen clock cycles, but those differences will become harder to see as the instruction paths get closer to taking only a single cycle. The same limitation holds for data-dependent power consumption: if the data affects many clock cycles, you should be able to read the path, but if the difference is just a small power variation at an individual instruction, you’ll see it only on particularly leaky targets. Yet, if these operations directly link to secrets, as in [Figure 8-7](#figure8-7), you should still be able to learn those secrets.    Once the power variations dip below the noise level, SPA has one more trick up its sleeve before you may want to switch to DPA: *signal processing*. If your target executes its critical operations in a constant time with constant data and a constant execution path, you can rerun the SPA operations many times and average the power measurements in order to counter noise. We’ll discuss more elaborate filtering in Chapter 11\\. However, sometimes the leakage is so small that we need heavy statistics to detect it, and that’s where DPA comes in. You’ll learn more about DPA in Chapter 10.    ### SPA on ECDSA    This section uses the companion notebook for this chapter (available at [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)). Keep it handy, as we’ll reference it throughout this section. The section titles in this book match the section titles in the notebook.    #### Goal and Notation    The *Elliptic Curve Digital Signature Algorithm (ECDSA)* uses *elliptic curve cryptography (ECC)* to generate and verify secure signature keys. In this context, a digital *signature* applied to a computer-based document is used to verify cryptographically that a message is from a trusted source or hasn’t been modified by a third party.    The goal is to use SPA to recover the private key `d` from the execution of an ECDSA signature algorithm so that we can use it to sign messages purporting to be the sender. At a high level, the inputs to an ECDSA signature are the private key `d`, the public point `G`, and a message `m`, and the output is a signature `(r,s)`. One weird thing about ECDSA is that the signatures are different every time, even for the same message. (You’ll see why in a moment.) The ECDSA *verification* algorithm verifies a message by taking the public point `G`, public key `pd`, message `m`, and the signature `(r,s)` as inputs. A *point* is nothing more than a set of xy-coordinates on a *curve*—hence the C in ECDSA.    In developing our attack, we rely on the fact that the ECDSA signature algorithm internally uses a random number `k`. This number must be kept secret, because if the value of `k` of a given signature `(r,s)` is revealed, you can solve for `d`. We’re going to extract `k` using SPA and then solve for `d`. We’ll refer to `k` as a *nonce*, because besides requiring secrecy, it must also remain unique (*nonce* is short for “number used once”).    As you can see in the notebook, a few basic functions implement ECDSA signing and verification, and some lines exercise these functions. For the remainder of this notebook, we create a random public/private key `pd/d`. We also create a random message hash `e` (skipping the actual hashing of a message `m`, which is not relevant here). We perform a signing operation and verification operation, just to check that all is well. From here on, we’ll use only the public values, plus a simulated power trace, to recover the private values.    #### Finding a Leaky Operation    Now, let’s tickle your brain. Check the functions `leaky_scalar_mul()` and `ecdsa_sign_leaky()`. As you know, we’re after nonce `k`, so try to find it in the code. Pay specific attention to how nonce `k` is processed by the algorithm and come up with some hypotheses on how it may leak into a power trace. This is an SPA exercise, so try to spot the secret-dependent operations.    As you may have figured out, we’ll attack the calculation of the nonce `k`multiplied by public point `G`. In ECC, this operation is called a *scalar multiplication* because it multiplies a scalar `k` with a point `G`.    The textbook algorithm for scalar multiplication takes the bits of `k` one by one, as implemented in `leaky_scalar_mul()`. If the bit is 0, only a point-doubling is executed. If the bit is 1, both a point-addition and a point-doubling are executed. This is much like textbook RSA modular exponentiation, and as such, it also leads to an SPA leak. If you can differentiate between point-doubling only and point-addition followed by point-doubling, you can find the individual bits of `k`. As mentioned before, we can then calculate the full private key `d`.    #### Simulating SPA Traces of a Leaky ECDSA    In the notebook, `ecdsa_sign_leaky()` signs a given message with a given private key. In doing so, it leaks the simulated timing of the loop iterations in the scalar multiplication implemented in `leaky_scalar_mul()`. We’re obtaining this timing by randomly sampling a normal distribution. In a real target, the timing characteristics will be different from what we do here. However, any measurable timing difference between the operations will be exploitable in the same way.    Next, we turn the timings into a simulated power trace using the function `timeleak_to_trace()`. The start of such a trace will be plotted in the notebook; [Figure 8-8](#figure8-8) also shows an example.  ![f08008](image_fi/278748c08/f08008.png)    Figure 8-8: Simulated ECDSA power consumption trace showing nonce bits      In this simulated trace, you can see an SPA timing leakage where the loops performing point-doublings (secret nonce `k` bit = 0) are shorter in duration than loops that perform both point-addition and point-doubling (secret nonce `k` bit = 1).    #### Measuring Scalar Multiplication Loop Duration    When attacking an unknown nonce, we’ll have a power trace, but we don’t know the bits for `k`. Therefore, we analyze the distances between the peaks using `trace_to_difftime()` in the notebook. This function first applies a vertical threshold to the traces to get rid of amplitude noise and turn the power trace into a “binary” trace. The power trace is now a sequence of 0 (low) and 1 (high) samples.    We’re interested in the duration of all sequences of ones because they measure the duration of the scalar multiplication loop. For example, the sequence [1, 1, 1, 1, 1, 0, 1, 0, 1, 1] turns into the durations [5, 1, 2], corresponding to the number of sequential ones. We apply some NumPy magic (explained in more detail in the notebook) to accomplish this conversion. Next, we plot these durations on top of the binary trace; [Figure 8-9](#figure8-9) shows the result.  ![f08009](image_fi/278748c08/f08009.png)    Figure 8-9: Binary ECDSA power consumption trace showing SPA timing leakage      #### From Durations to Bits    In an ideal world, we would have “long” and “short” durations as well as one cutoff that correctly separates the two. If a duration is below the cutoff, we would have only point-doubling (secret bit 0), or as shown earlier, we would have both point-addition and point-doubling (secret bit 1). Alas, in reality, timing jitter will cause this naive SPA to fail because the cutoff is not able to separate the two distributions perfectly. You can see this effect in the notebook and [Figure 8-10](#figure8-10).  ![f08010](image_fi/278748c08/f08010.png)    Figure 8-10: The distribution of the durations for a double-only (left) and a double-and-add (right) overlap, disallowing the duration to be a perfect predictor.      How do you solve for this? An important insight is that we have a good idea of which bits are likely incorrect: namely, the ones that are closest to the cutoff. In the notebook, the `simple_power_analysis()` function analyzes the duration for each operation. Based on this analysis, it generates a guessed value for `k` and a list of bits in `k` that are closest to the cutoff. The cutoff is determined as the mean of the 25th and 75th percentiles in the duration distribution, as this is more stable than taking the average.    #### Brute-Forcing the Way Out    Since we have an initial guess of `k` and the bits closest to the cutoff, we can simply brute-force those bits. In the notebook, we do this in the `bruteforce()` function. For all candidates for `k`, a value of the private key `d` is calculated.    The function has two means of verifying whether it found the correct `d`. If it has access to the correct `d`, it can cheat by comparing the calculated `d` with the correct `d`. If it doesn’t have access to the correct `d`, it calculates the signature `(r,s)` from the guessed `k` and calculated `d` and then checks that this signature is correct. This process is much, much slower, but it’s something you’ll face when doing this for real.    Even this brute-force attack won’t always yield the correct nonce, so we’ve put it in a giant loop for you. Let it run for a while, and it will recover the private key simply from only SPA timings. After some time, you’ll see something like [Listing 8-4](#listing8-4).    ``` Attempt 16 Guessed k: 0b111111110001100101011110000110101100011100000011001111010011001111010001000010110110110010011001001100000011101000110111010101011010001110011000010001100000010100001101111010000000010010010000110110111100001101001111010110001000110011101000010010100101101 Actual k:  0b111111110001100101011110000110101100011100001011001111010011001111010001000010110110110010011111001100000011101000110111010101011010001110011000010001100000010100001101111010000000010010010000111110111100001101001111010110001000110011101000010010100101101 Bit errors: 4 Bruteforcing bits: [241  60 209 160 161 212  34  21] No key for you.   Attempt 17 Guessed k: 0b11111011101110001001010000100001101011000000100111000001011010011010010000110110000110010010011111000110110111011100110001110101010110000000100110001111101000110010001101001100011101101010111000110111110011101001011110010100011101100011100011011000100 Actual k:  0b11111011101110001001010000100001101011000000110111000001011010011010010000110110000110010110011111000110110111011101110001110101010110000000100110011111101000111010001101001100011101101010111000110111110011101001011110010100011101101011100011011000100 Bit errors: 6 Bruteforcing bits: [103 185 135 205  18 161  90  98] Yeash! Key found:0b110101001000000000010001100011000010100101101011100001101001100010111011101111000011100111101101000010100000111001001111110010111100001010001001010010111100110100100000001001110001010111100100000100101010010101110101001110110100010011100000001100101110 ```    Listing 8-4: Output of the Python ECDSA SPA attack    Once you see this, the SPA algorithm has successfully recovered the key only from some noisy measurements of the simulated durations of the scalar multiplication.    This algorithm has been written to be fairly portable to other ECC (or RSA) implementations. If you’re going after a real target, first creating a simulation like this notebook that mimics the implementation is recommended just to show that you can positively do key extraction. Otherwise, you’ll never know whether your SPA failed because of the noise or because you have a bug somewhere.    ## Summary    Power analysis is a powerful form of a side-channel attack. The most basic type of power analysis is a simple extension of a timing side-channel attack, which gives better visibility into what a program is executing internally. In this chapter, we showed how simple power analysis could break not only password checks but also some real cryptographic systems, including RSA and ECDSA implementations.    Performing this theoretical and simulated trace might not be enough to convince you that power analysis really is a threat to a secure system. Before going further, next we’ll take you through the setup for a basic lab. You’ll get your hands on some hardware and perform basic SPA attacks, allowing you to see the effect of changing instructions or program flow in the power trace. After exploring how power analysis measurement works, we’ll look at advanced forms of power analysis in subsequent chapters.````"]