["```\n; Listing 16-1.asm\n\n; A stand-alone assembly language version of \n; the ubiquitous \"Hello, world!\" program.\n\n; Link in the Windows Win32 API:\n\n            includelib kernel32.lib\n\n; Here are the two Windows functions we will need\n; to send \"Hello, world!\" to the standard console device:\n\n            extrn __imp_GetStdHandle:proc\n            extrn __imp_WriteFile:proc\n\n            .code\nhwStr       byte    \"Hello World!\"\nhwLen       =       $-hwStr\n\n; This is the honest-to-goodness assembly language\n; main program:\n\nmain        proc\n\n; On entry, stack is aligned at 8 mod 16\\. Setting aside\n; 8 bytes for \"bytesWritten\" ensures that calls in main have\n; their stack aligned to 16 bytes (8 mod 16 inside function),\n; as required by the Windows API (which __imp_GetStdHandle and\n; __imp_WriteFile use. They are written in C/C++).\n\n            lea     rbx, hwStr\n            sub     rsp, 8\n            mov     rdi, rsp      ; Hold # of bytes written here\n\n; Note: must set aside 32 bytes (20h) for shadow registers for\n; parameters (just do this once for all functions). \n; Also, WriteFile has a 5th argument (which is NULL), \n; so we must set aside 8 bytes to hold that pointer (and\n; initialize it to zero). Finally, stack must always be \n; 16-byte-aligned, so reserve another 8 bytes of storage\n; to ensure this.\n\n            sub     rsp, 030h  ; Shadow storage for args\n\n; Handle = GetStdHandle(-11);\n; Single argument passed in ECX.\n; Handle returned in RAX.\n\n            mov     rcx, -11                     ; STD_OUTPUT\n            call    qword ptr __imp_GetStdHandle ; Returns handle\n                                                 ; in RAX\n\n; WriteFile(handle, \"Hello World!\", 12, &bytesWritten, NULL);\n; Zero out (set to NULL) \"lpOverlapped\" argument:\n\n            xor     rcx, rcx\n            mov     [rsp + 4 * 8], rcx\n\n            mov     r9, rdi    ; Address of \"bytesWritten\" in R9\n            mov     r8d, hwLen ; Length of string to write in R8D\n            lea     rdx, hwStr ; Ptr to string data in RDX\n            mov     rcx, rax   ; File handle passed in RCX\n            call    qword ptr __imp_WriteFile\n\n; Clean up stack and return:\n\n            add     rsp, 38h\n            ret\nmain        endp\n            end\n```", "```\nml64 listing16-1.asm /link /subsystem:console /entry:main\n```", "```\nincludelib kernel32.lib\n\n; Here are the two Windows functions we will need\n; to send \"Hello, world!\" to the standard console device:\n\nextrn __imp_GetStdHandle:proc\nextrn __imp_WriteFile:proc\n```", "```\n; Listing 16-2\n\n            include    listing16-2.inc\n            includelib kernel32.lib               ; File I/O library\n\n; Include just the files we need from masm64rt.inc:\n\n;           include \\masm32\\include64\\masm64rt.inc\n;           OPTION DOTNAME                        ; Required for macro files\n;           option casemap:none                   ; Case sensitive\n;           include \\masm32\\include64\\win64.inc\n;           include \\masm32\\macros64\\macros64.inc\n;           include \\masm32\\include64\\kernel32.inc\n\n            .data\nbytesWrtn   qword   ?\nhwStr       byte    \"Listing 16-2\", 0ah, \"Hello, World!\", 0\nhwLen       =       sizeof hwStr\n\n            .code\n\n**********************************************************\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    r15\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56            ; Shadow storage\n            and     rsp, -16\n\n            mov     rcx, -11           ; STD_OUTPUT\n            call    __imp_GetStdHandle ; Returns handle\n\n            xor     rcx, rcx\n            mov     bytesWrtn, rcx\n\n            lea     r9, bytesWrtn      ; Address of \"bytesWritten\" in R9\n            mov     r8d, hwLen         ; Length of string to write in R8D \n            lea     rdx, hwStr         ; Ptr to string data in RDX\n            mov     rcx, rax           ; File handle passed in RCX\n            call    __imp_WriteFile\n\nallDone:    leave\n            pop     r15\n            pop     rdi\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\n; listing16-2.inc\n\n; Header file entries extracted from MASM32 header\n; files (placed here rather than including the \n; full MASM32 headers to avoid namespace pollution\n; and speed up assemblies).\n\nPPROC           TYPEDEF PTR PROC        ; For include file prototypes\n\nexterndef __imp_GetStdHandle:PPROC\nexterndef __imp_WriteFile:PPROC\n```", "```\nC:\\>**ml64 /nologo listing16-2.asm kernel32.lib /link /nologo /subsystem:console /entry:asmMain**\n Assembling: listing16-2.asm\n\nC:\\>**listing16-2**\nListing 16-2\nHello, World!\n```", "```\ninclude \\masm32\\include64\\masm64rt.inc\n```", "```\nml64 listing16-2.asm /link /subsystem:console /entry:asmMain\n```", "```\n; Listing 16-3\n\n; Dialog box demonstration.\n\n            include    listing16-3.inc\n            includelib user32.lib\n\n          ; include \\masm32\\include64\\masm64rt.inc\n\n            .data\n\nmsg         byte    \"Dialog Box Demonstration\",0\nDBTitle     byte    \"Dialog Box Title\", 0\n\n            .code\n\n**********************************************************\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n            and     rsp, -16\n\n            xor     rcx, rcx        ; HWin = NULL\n            lea     rdx, msg        ; Message to display\n            lea     r8, DBTitle     ; Dialog box title\n            mov     r9d, MB_OK      ; Has an \"OK\" button\n            call    MessageBox\n\nallDone:    leave\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\n; listing16-3.inc\n\n; Header file entries extracted from MASM32 header\n; files (placed here rather than including the \n; full MASM32 headers to avoid namespace pollution\n; and speed up assemblies).\n\nPPROC           TYPEDEF PTR PROC        ; For include file prototypes\n\nMB_OK                                equ 0h\n\nexterndef __imp_MessageBoxA:PPROC\nMessageBox equ <__imp_MessageBoxA>\n```", "```\nC:\\>**ml64 listing16-3.asm /link /subsystem:windows /entry:asmMain**\n```", "```\n; Listing 16-4 \n\n; File I/O demonstration.\n\n            include    listing16-4.inc\n            include    aoalib.inc   ; To get some constants\n            includelib kernel32.lib ; File I/O library\n\n            .const\nprompt      byte    \"Enter (text) filename:\", 0\nbadOpenMsg  byte    \"Could not open file\", cr, nl, 0\n\n            .data\n\ninHandle    dword   ?\ninputLn     byte    256 dup (0)\n\nfileBuffer  byte    4096 dup (0)\n```", "```\n .code\n\nrcxSave     textequ <[rbp - 8]>\nrdxSave     textequ <[rbp - 16]>\nr8Save      textequ <[rbp - 24]>\nr9Save      textequ <[rbp - 32]>\nr10Save     textequ <[rbp - 40]>\nr11Save     textequ <[rbp - 48]>\nxmm0Save    textequ <[rbp - 64]>\nxmm1Save    textequ <[rbp - 80]>\nxmm2Save    textequ <[rbp - 96]>\nxmm3Save    textequ <[rbp - 112]>\nxmm4Save    textequ <[rbp - 128]>\nxmm5Save    textequ <[rbp - 144]>\nvar1        textequ <[rbp - 160]>\n\nmkActRec    macro\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 256        ; Includes shadow storage\n            and     rsp, -16        ; Align to 16 bytes\n            mov     rcxSave, rcx\n            mov     rdxSave, rdx\n            mov     r8Save, r8\n            mov     r9Save, r9\n            mov     r10Save, r10\n            mov     r11Save, r11\n            movdqu  xmm0Save, xmm0\n            movdqu  xmm1Save, xmm1\n movdqu  xmm2Save, xmm2\n            movdqu  xmm3Save, xmm3\n            movdqu  xmm4Save, xmm4\n            movdqu  xmm5Save, xmm5\n            endm\n\nrstrActRec  macro\n            mov     rcx, rcxSave\n            mov     rdx, rdxSave\n            mov     r8, r8Save \n            mov     r9, r9Save \n            mov     r10, r10Save\n            mov     r11, r11Save\n            movdqu  xmm0, xmm0Save\n            movdqu  xmm1, xmm1Save\n            movdqu  xmm2, xmm2Save\n            movdqu  xmm3, xmm3Save\n            movdqu  xmm4, xmm4Save\n            movdqu  xmm5, xmm5Save\n            leave\n            endm\n```", "```\n; getStdOutHandle - Returns stdout handle in RAX:\n\ngetStdOutHandle proc\n                mkActRec\n                mov     rcx, STD_OUTPUT_HANDLE\n                call    __imp_GetStdHandle  ; Returns handle\n                rstrActRec\n                ret\ngetStdOutHandle endp\n\n; getStdErrHandle - Returns stderr handle in RAX:\n\ngetStdErrHandle proc\n                mkActRec\n                mov     rcx, STD_ERROR_HANDLE\n                call    __imp_GetStdHandle  ; Returns handle\n                rstrActRec\n                ret\ngetStdErrHandle endp\n\n; getStdInHandle - Returns stdin handle in RAX:\n\ngetStdInHandle proc\n               mkActRec\n               mov     rcx, STD_INPUT_HANDLE\n               call    __imp_GetStdHandle   ; Returns handle\n               rstrActRec\n               ret\ngetStdInHandle endp\n```", "```\n; write - Write data to a file handle.\n\n; RAX - File handle.\n; RSI - Pointer to buffer to write.\n; RCX - Length of buffer to write.\n\n; Returns:\n\n; RAX - Number of bytes actually written\n;       or -1 if there was an error.\n\nwrite       proc\n            mkActRec\n\n            mov     rdx, rsi        ; Buffer address\n            mov     r8, rcx         ; Buffer length\n            lea     r9, var1        ; bytesWritten\n            mov     rcx, rax        ; Handle\n            xor     r10, r10        ; lpOverlapped is passed\n            mov     [rsp+4*8], r10  ; on the stack\n            call    __imp_WriteFile\n            test    rax, rax        ; See if error\n            mov     rax, var1       ; bytesWritten\n            jnz     rtnBytsWrtn     ; If RAX was not zero\n            mov     rax, -1         ; Return error status\n\nrtnBytsWrtn:\n            rstrActRec\n            ret\nwrite       endp\n```", "```\n; puts - Outputs a zero-terminated string to standard output device.\n\n; RSI - Address of string to print to standard output.\n\n            .data\nstdOutHnd   qword   0\nhasSOHndl   byte    0\n\n            .code\nputs        proc\n            push    rax\n            push    rcx\n            cmp     hasSOHndl, 0\n            jne     hasHandle\n\n call    getStdOutHandle\n            mov     stdOutHnd, rax\n            mov     hasSOHndl, 1\n\n; Compute the length of the string:\n\nhasHandle:  mov     rcx, -1\nlenLp:      inc     rcx\n            cmp     byte ptr [rsi][rcx * 1], 0\n            jne     lenLp\n\n            mov     rax, stdOutHnd\n            call    write\n\n            pop     rcx\n            pop     rax\n            ret\nputs        endp\n\n; newLn - Outputs a newline sequence to the standard output device:\n\nnewlnSeq    byte    cr, nl\n\nnewLn       proc\n            push    rax\n            push    rcx\n            push    rsi\n            cmp     hasSOHndl, 0\n            jne     hasHandle\n\n            call    getStdOutHandle\n            mov     stdOutHnd, rax\n            mov     hasSOHndl, 1\n\nhasHandle:  lea     rsi, newlnSeq\n            mov     rcx, 2\n            mov     rax, stdOutHnd\n            call    write\n\n            pop     rsi\n            pop     rcx\n            pop     rax\n            ret\nnewLn       endp\n```", "```\n; read - Read data from a file handle.\n\n; EAX - File handle.\n; RDI - Pointer to buffer receive data.\n; ECX - Length of data to read.\n\n; Returns:\n\n; RAX - Number of bytes actually read\n;       or -1 if there was an error.\n\nread        proc\n            mkActRec\n\n            mov     rdx, rdi        ; Buffer address\n            mov     r8, rcx         ; Buffer length\n            lea     r9, var1        ; bytesRead\n            mov     rcx, rax        ; Handle\n            xor     r10, r10        ; lpOverlapped is passed\n            mov     [rsp+4*8], r10  ; on the stack\n            call    __imp_ReadFile\n            test    rax, rax        ; See if error\n            mov     rax, var1       ; bytesRead\n            jnz     rtnBytsRead     ; If RAX was not zero\n            mov     rax, -1         ; Return error status\n\nrtnBytsRead:\n            rstrActRec\n            ret\nread        endp\n```", "```\n; open - Open existing file for reading or writing.\n\n; RSI - Pointer to filename string (zero-terminated).\n; RAX - File access flags.\n;       (GENERIC_READ, GENERIC_WRITE, or\n;       \"GENERIC_READ + GENERIC_WRITE\")\n\n; Returns:\n\n; RAX - Handle of open file (or INVALID_HANDLE_VALUE if there\n;       was an error opening the file).\n\nopen        proc\n            mkActRec\n\n            mov     rcx, rsi               ; Filename\n            mov     rdx, rax               ; Read and write access\n            xor     r8, r8                 ; Exclusive access\n            xor     r9, r9                 ; No special security\n            mov     r10, OPEN_EXISTING     ; Open an existing file\n            mov     [rsp + 4 * 8], r10     \n            mov     r10, FILE_ATTRIBUTE_NORMAL\n            mov     [rsp + 5 * 8], r10\n            mov     [rsp + 6 * 8], r9      ; NULL template file\n            call    __imp_CreateFileA\n            rstrActRec\n            ret\nopen        endp\n```", "```\n; openNew - Creates a new file and opens it for writing.\n\n; RSI - Pointer to filename string (zero-terminated).\n\n; Returns:\n\n; RAX - Handle of open file (or INVALID_HANDLE_VALUE if there\n;       was an error opening the file).\n\nopenNew     proc\n            mkActRec\n\n            mov     rcx, rsi                         ; Filename\n            mov     rdx, GENERIC_WRITE+GENERIC_WRITE ; Access\n xor     r8, r8                           ; Exclusive access\n            xor     r9, r9                           ; No security\n            mov     r10, CREATE_ALWAYS               ; Open a new file\n            mov     [rsp + 4 * 8], r10 \n            mov     r10, FILE_ATTRIBUTE_NORMAL\n            mov     [rsp + 5 * 8], r10\n            mov     [rsp + 6 * 8], r9                ; NULL template\n            call    __imp_CreateFileA\n            rstrActRec\n            ret\nopenNew     endp\n```", "```\n; closeHandle - Closes a file specified by a file handle.\n\n; RAX - Handle of file to close.\n\ncloseHandle proc\n            mkActRec\n\n            call    __imp_CloseHandle\n\n            rstrActRec\n            ret\ncloseHandle endp\n```", "```\n; getLastError - Returns the error code of the last Windows error.\n\n; Returns:\n\n; RAX - Error code.\n\ngetLastError proc\n             mkActRec\n             call   __imp_GetLastError\n             rstrActRec\n             ret\ngetLastError endp\n```", "```\n; stdin_read - Reads data from the standard input.\n\n; RDI - Buffer to receive data.\n; RCX - Buffer count (note that data input will\n;       stop on a newline character if that\n;       comes along before RCX characters have\n;       been read).\n\n; Returns:\n\n; RAX - -1 if error, bytes read if successful.\n\nstdin_read  proc\n            .data\nhasStdInHnd byte    0\nstdInHnd    qword   0\n            .code\n            mkActRec\n            cmp     hasStdInHnd, 0\n            jne     hasHandle\n\n            call    getStdInHandle\n            mov     stdInHnd, rax\n            mov     hasStdInHnd, 1\n\nhasHandle:  mov     rax, stdInHnd   ; Handle\n            call    read\n\n            rstrActRec\n            ret\nstdin_read  endp\n```", "```\n; stdin_getc - Reads a single character from the standard input.\n;              Returns character in AL register.\n\nstdin_getc  proc\n            push    rdi\n            push    rcx\n            sub     rsp, 8\n\n            mov     rdi, rsp\n            mov     rcx, 1\n            call    stdin_read\n            test    eax, eax        ; Error on read?\n            jz      getcErr\n            movzx   rax, byte ptr [rsp]\n\ngetcErr:    add     rsp, 8\n            pop     rcx\n            pop     rdi \n            ret\nstdin_getc  endp\n```", "```\n; readLn - Reads a line of text from the user.\n;          Automatically processes backspace characters\n;          (deleting previous characters, as appropriate).\n;          Line returned from function is zero-terminated\n;          and does not include the ENTER key code (carriage\n;          return) or line feed.\n\n; RDI - Buffer to place line of text read from user.\n; RCX - Maximum buffer length.\n\n; Returns:\n\n; RAX - Number of characters read from the user\n;       (does not include ENTER key).\n\nreadLn      proc\n            push    rbx\n\n            xor     rbx, rbx           ; Character count\n            test    rcx, rcx           ; Allowable buffer is 0?\n            je      exitRdLn\n            dec     rcx                ; Leave room for 0 byte\nreadLp:\n            call    stdin_getc         ; Read 1 char from stdin\n            test    eax, eax           ; Treat error like ENTER\n            jz      lineDone\n            cmp     al, cr             ; Check for ENTER key\n            je      lineDone\n            cmp     al, nl             ; Check for newline code\n            je      lineDone\n            cmp     al, bs             ; Handle backspace character\n            jne     addChar\n\n; If a backspace character came along, remove the previous\n; character from the input buffer (assuming there is a\n; previous character).\n\n            test    rbx, rbx           ; Ignore BS character if no\n            jz      readLp             ; chars in the buffer\n            dec     rbx\n            jmp     readLp\n\n; If a normal character (that we return to the caller),\n; then add the character to the buffer if there is\n; room for it (ignore the character if the buffer is full).\n\naddChar:    cmp     ebx, ecx           ; See if we're at the\n            jae     readLp             ; end of the buffer\n            mov     [rdi][rbx * 1], al ; Save char to buffer\n inc     rbx\n            jmp     readLp\n\n; When the user presses ENTER (or the line feed) key\n; during input, come down here and zero-terminate the string.\n\nlineDone:   mov     byte ptr [rdi][rbx * 1], 0 \n\nexitRdLn:   mov     rax, rbx        ; Return char cnt in RAX\n            pop     rbx\n            ret\nreadLn      endp\n```", "```\n**********************************************************\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n            and     rsp, -16\n\n; Get a filename from the user:\n\n            lea     rsi, prompt\n            call    puts\n\n            lea     rdi, inputLn\n            mov     rcx, lengthof inputLn\n            call    readLn\n\n; Open the file, read its contents, and display\n; the contents to the standard output device:\n\n            lea     rsi, inputLn\n            mov     rax, GENERIC_READ\n            call    open\n\n            cmp     eax, INVALID_HANDLE_VALUE\n            je      badOpen\n\n            mov     inHandle, eax\n\n; Read the file 4096 bytes at a time:\n\nreadLoop:   mov     eax, inHandle\n            lea     rdi, fileBuffer\n            mov     ecx, lengthof fileBuffer\n            call    read\n            test    eax, eax        ; EOF?\n            jz      allDone\n            mov     rcx, rax        ; Bytes to write\n\n            call    getStdOutHandle\n            lea     rsi, fileBuffer\n            call    write\n            jmp     readLoop\n\nbadOpen:    lea     rsi, badOpenMsg\n            call    puts\n\nallDone:    mov     eax, inHandle\n            call    closeHandle\n\n            leave\n            pop     rdi\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**nmake /nologo /f listing16-4.mak**\n        ml64 /nologo listing16-4.asm  /link /subsystem:console /entry:asmMain\n Assembling: listing16-4.asm\nMicrosoft (R) Incremental Linker Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n/OUT:listing16-4.exe\nlisting16-4.obj\n/subsystem:console\n/entry:asmMain\n\nC:\\>**listing16-4**\nEnter (text) filename:listing16-4.mak\nlisting16-4.exe: listing16-4.obj listing16-4.asm\n        ml64 /nologo listing16-4.asm \\\n                /link /subsystem:console /entry:asmMain\n```", "```\n; listing16-4.inc\n\n; Header file entries extracted from MASM32 header\n; files (placed here rather than including the \n; entire set of MASM32 headers to avoid namespace \n; pollution and speed up assemblies).\n\nSTD_INPUT_HANDLE                     equ -10\nSTD_OUTPUT_HANDLE                    equ -11\nSTD_ERROR_HANDLE                     equ -12\nCREATE_NEW                           equ 1\nCREATE_ALWAYS                        equ 2\nOPEN_EXISTING                        equ 3\nOPEN_ALWAYS                          equ 4\nFILE_ATTRIBUTE_READONLY              equ 1h\nFILE_ATTRIBUTE_HIDDEN                equ 2h\nFILE_ATTRIBUTE_SYSTEM                equ 4h\nFILE_ATTRIBUTE_DIRECTORY             equ 10h\nFILE_ATTRIBUTE_ARCHIVE               equ 20h\nFILE_ATTRIBUTE_NORMAL                equ 80h\nFILE_ATTRIBUTE_TEMPORARY             equ 100h\nFILE_ATTRIBUTE_COMPRESSED            equ 800h\nFILE_SHARE_READ                      equ 1h\nFILE_SHARE_WRITE                     equ 2h\nGENERIC_READ                         equ 80000000h\nGENERIC_WRITE                        equ 40000000h\nGENERIC_EXECUTE                      equ 20000000h\nGENERIC_ALL                          equ 10000000h\nINVALID_HANDLE_VALUE                 equ -1\n\nPPROC           TYPEDEF PTR PROC        ; For include file prototypes\n\nexterndef __imp_GetStdHandle:PPROC\nexterndef __imp_WriteFile:PPROC\nexterndef __imp_ReadFile:PPROC\nexterndef __imp_CreateFileA:PPROC\nexterndef __imp_CloseHandle:PPROC\nexterndef __imp_GetLastError:PPROC\n```", "```\nlisting16-4.exe: listing16-4.obj listing16-4.asm\n    ml64 /nologo listing16-4.asm \\\n        /link /subsystem:console /entry:asmMain\n```"]