<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label=" Page 215. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MICROSOFT-WINDOWS-THREAT-INTELLIGENCE</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">For years, Microsoft Defender for Endpoint (MDE) presented a huge challenge for offensive security practitioners because it could detect issues that all the other EDR vendors missed. One of the primary reasons for its effectiveness is its use of the <i>Microsoft-Windows-Threat-Intelligence (EtwTi)</i> ETW provider. Today, developers who publish ELAM drivers use it to access some of the most powerful detection sources on Windows.</p>&#13;
<p class="TX">Despite its name, this ETW provider won’t provide you with attribution information. Rather, it reports on events that were previously unavailable to EDRs, like memory allocations, driver loads, and syscall policy violations to <i>Win32k</i>, the kernel component of the Graphics Device Interface. These events functionally replace the information EDR vendors gleaned from user-mode function hooking, which attackers can easily evade, as covered in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label=" Page 216. "/>Because events from this provider originate from the kernel, the provider is more difficult to evade, has greater coverage than user-mode alternatives, and is less risky than function hooking, as the provider is integrated into the operating system itself. Due to these factors, it is rare to encounter mature EDR vendors that don’t use it as a telemetry source.</p>&#13;
<p class="TX">This chapter covers how the EtwTi provider works, its detection sources, the types of events it emits, and how attackers may evade detection.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-157"/><samp class="SANS_Futura_Std_Bold_B_11">Reverse Engineering the Provider</samp></h2>&#13;
<p class="TNI">Before we cover the types of events emitted by the EtwTi provider, you should understand how it gets the information in the first place. Unfortunately, Microsoft provides no public documentation about the provider’s internals, so discovering this is largely a manual effort.</p>&#13;
<p class="TX">As a case study, this section covers one example of EtwTi’s source: what happens when a developer changes the protection level of a memory allocation to mark it as executable. Malware developers frequently use this technique; they’ll first write shellcode to an allocation marked with read-write (RW) permissions and then change these to read-execute (RX) through an API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp> before they execute the shellcode.</p>&#13;
<p class="TX">When the malware developer calls this API, execution eventually flows down to the syscall for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>. Execution is transferred into the kernel, where some safety checks and validations occur. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!MmProtectVirtualMemory()</samp> is called to change the protection level on the allocation. This is all pretty standard, and it would be reasonable to assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp> would clean up and return at this point. However, one last conditional block of code in the kernel, shown in <a href="#list12-1">Listing 12-1</a>, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp> if the protection change succeeded.</p>&#13;
<pre id="list12-1"><code>if ((-1 &lt; (int)status) &amp;&amp;&#13;
  (status = protectionMask, ProtectionMask = MiMakeProtectionMask(protectionMask),&#13;
  ((uVar2 | ProtectionMask) &amp; 2) != 0)) {&#13;
    puStack_c0 = (ulonglong*)((ulonglong)puStack_c0 &amp; 0xffffffff00000000 | (ulonglong)status);&#13;
    OldProtection = param_4;&#13;
    <b>EtwTiLogProtectExecVm(TargetProcess,AccessMode,BaseAddress,NumberOfBytes);</b>&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-1: The EtwTi function called inside <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtProtectVirtualMemory()</samp></span></p>&#13;
<p class="TX">The name of this function implies that it is responsible for logging protection changes for executable regions of memory.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking That the Provider and Event Are Enabled</samp></h3>&#13;
<p class="TNI">Within the function is a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp>, which is defined in <a href="#list12-2">Listing 12-2</a>. It verifies that a given ETW provider is enabled on the system.</p>&#13;
<pre id="list12-2"><code>BOOLEAN EtwProviderEnabled(&#13;
  REGHANDLE RegHandle,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label=" Page 217. "/>&#13;
  UCHAR     Level,&#13;
  ULONGLONG Keyword&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwProviderEnabled()</samp> definition</span></p>&#13;
<p class="TX">The most interesting part of this function is the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegHandle</samp> parameter, which is the global <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>, in the case of this provider. This handle is referenced in every EtwTi function, meaning we can use it to find other functions of interest. If we examine the cross-reference to the global ETW provider handle, as shown in <a href="#fig12-1">Figure 12-1</a>, we can see 31 other references made to it, most of which are other EtwTi functions.</p>&#13;
<figure class="IMG"><img id="fig12-1" class="img100" src="../images/Figure12-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: Cross-references to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">One of the cross-references originates from <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpInitialize()</samp>, a function called during the boot process that, among other things, is responsible for registering system ETW providers. To do this, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwRegister()</samp> function. The signature for this function is shown in <a href="#list12-3">Listing 12-3</a>.</p>&#13;
<pre id="list12-3"><code>NTSTATUS EtwRegister(&#13;
  LPCGUID            ProviderId,&#13;
  PETWENABLECALLBACK EnableCallback,&#13;
  PVOID              CallbackContext,&#13;
  PREGHANDLE         RegHandle&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwRegister()</samp> definition</span></p>&#13;
<p class="TX">This function is called during the boot process with a pointer to a GUID named <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreatIntProviderGuid</samp>, shown in <a href="#list12-4">Listing 12-4</a>.</p>&#13;
<pre id="list12-4"><code>EtwRegister(&amp;ThreatIntProviderGuid,0,0,&amp;EtwThreatIntProvRegHandle);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-4: Registering <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp></span></p>&#13;
<p class="TX">The GUID pointed to is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> section, shown in <a href="#fig12-2">Figure 12-2</a> as <samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>.</p>&#13;
<figure class="IMG"><img id="fig12-2" class="img100" src="../images/Figure12-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The GUID pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label=" Page 218. "/>If the provider is enabled, the system checks the event descriptor to determine if the specific event is enabled for the provider. This check is performed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwEventEnabled()</samp> function, which takes the provider handle used by <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp> structure corresponding to the event to be logged. Logic determines which <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp> to use based on the calling thread’s context (either user or kernel).</p>&#13;
<p class="TX">Following these checks, the EtwTi function builds out a structure with functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillProcessIdentity()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillVad()</samp>. This structure is not easily statically reversed, but thankfully, it is passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp>, a function used for emitting events. Let’s use a debugger to examine it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining the Events Emitted</samp></h3>&#13;
<p class="TNI">At this point, we know the syscall passes data to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>, which emits an event over ETW using the EtwTi provider. The particular event emitted is still unknown, though. To collect this information, let’s view the data in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PEVENT_DATA_DESCRIPTOR</samp> passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> using WinDbg.</p>&#13;
<p class="TX">By placing a conditional breakpoint on the function that writes the ETW event when its call stack includes <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>, we can further investigate the parameters passed to it (<a href="#list12-5">Listing 12-5</a>).</p>&#13;
<pre id="list12-5"><code>1: kd&gt; <b>bp nt!EtwWrite "r $t0 = 0;</b>&#13;
<b>.foreach (p {k}) {</b>&#13;
<b>  .if ($spat(\"p\", \"nt!EtwTiLogProtectExecVm*\")) {</b>&#13;
<b>    r $t0 = 1; .break</b>&#13;
<b>  }</b>&#13;
<b>};</b>&#13;
<b>.if($t0 = 0) {gc}"</b>&#13;
1: kd&gt; <b>g</b>&#13;
nt!EtwWrite&#13;
fffff807`7b693500 4883ec48        sub  rsp, 48h&#13;
1: kd&gt; <b>k</b>&#13;
 # Child-SP          RetAddr           Call Site&#13;
00 ffff9285`03dc6788 fffff807`7bc0ac99 nt!EtwWrite&#13;
01 ffff9285`03dc6790 fffff807`7ba96860 nt!EtwTiLogProtectExecVm+0x15c031 <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>&#13;
02 ffff9285`03dc69a0 fffff807`7b808bb5 nt!NtProtectVirtualMemory+0x260&#13;
03 ffff9285`03dc6a90 00007ffc`48f8d774 nt!KiSystemServiceCopyEnd+0x25 <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>&#13;
04 00000025`3de7bc78 00007ffc`46ab4d86 0x00007ffc`48f8d774&#13;
05 00000025`3de7bc80 000001ca`0002a040 0x00007ffc`46ab4d86&#13;
06 00000025`3de7bc88 00000000`00000008 0x000001ca`0002a040&#13;
07 00000025`3de7bc90 00000000`00000000 0x8</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-5: Using a conditional breakpoint to watch calls to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogProtectExecVm()</samp></span></p>&#13;
<p class="TX">This call stack shows a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp> surfacing from user mode and hitting the System Service Dispatch Table (SSDT) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which is really just an array of addresses to functions that handle a given syscall. Control is then passed up to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp> where the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is made, just as we identified earlier through static analysis.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label=" Page 219. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">UserDataCount</samp> parameter passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> contains the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp> structures in its fifth parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>. This value will be stored in the R9 register and can be used to display all entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> array, stored in RAX. This is shown in the WinDbg output in <a href="#list12-6">Listing 12-6</a>.</p>&#13;
<pre id="list12-6"><code>1: <b>kd&gt; dq @rax L(@r9*2)</b>&#13;
ffff9285`03dc67e0  ffffa608`af571740 00000000`00000004&#13;
ffff9285`03dc67f0  ffffa608`af571768 00000000`00000008&#13;
ffff9285`03dc6800  ffff9285`03dc67c0 00000000`00000008&#13;
ffff9285`03dc6810  ffffa608`af571b78 00000000`00000001&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-6: Listing the values in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UserData</samp> using the number of entries stored in R9</span></p>&#13;
<p class="TX">The first 64-bit value on each line of the WinDbg output is a pointer to the data, and the next one describes the size of the data in bytes. Unfortunately, this data isn’t named or labeled, so discovering what each descriptor describes is a manual process. To decipher which pointer holds which type of data, we can use the provider GUID collected earlier in this section, <samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>.</p>&#13;
<p class="TX">As discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, ETW providers can register an event manifest, which describes the events emitted by the provider and their contents. We can list these providers using the <i>logman.exe</i> utility, as shown in <a href="#list12-7">Listing 12-7</a>. Searching for the GUID associated with the EtwTi provider reveals that the provider’s name is <i>Microsoft-Windows-Threat-Intelligence</i>.</p>&#13;
<pre id="list12-7"><code>PS &gt; <b>logman query providers | findstr /i "{f4e1897c-bb5d-5668-f1d8-040f4d8dd344}"</b>&#13;
Microsoft-Windows-Threat-Intelligence {F4E1897C-BB5D-5668-F1D8-040F4D8DD344}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-7: Retrieving the provider’s name using</span> <span class="eSANS_Futura_Std_Book_11a">logman.exe</span></p>&#13;
<p class="TX">After identifying the name of the provider, we can pass it to tools such as PerfView to get the provider manifest. When the PerfView command in <a href="#list12-8">Listing 12-8</a> completes, it will create the manifest in the directory from which it was called.</p>&#13;
<pre id="list12-8"><code>PS &gt; <b>PerfView64.exe userCommand DumpRegisteredManifest Microsoft-Windows-Threat-Intelligence</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-8: Using PerfView to dump the provider manifest</span></p>&#13;
<p class="TX">You can view the sections of this manifest that relate to the protection of virtual memory in the generated XML. The most important section for understanding the data in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> array is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">template&gt;</samp> tags, shown in <a href="#list12-9">Listing 12-9</a>.</p>&#13;
<pre id="list12-9"><code>    &lt;templates&gt;&#13;
    <var>--snip--</var>&#13;
    &lt;template tid="KERNEL_THREATINT_TASK_PROTECTVMArgs_V1"&gt;&#13;
    &lt;data name="CallingProcessId" inType="win:UInt32"/&gt;&#13;
    &lt;data name="CallingProcessCreateTime" inType="win:FILETIME"/&gt;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label=" Page 220. "/>&#13;
    &lt;data name="CallingProcessStartKey" inType="win:UInt64"/&gt;&#13;
    &lt;data name="CallingProcessSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="CallingProcessSectionSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="CallingProcessProtection" inType="win:UInt8"/&gt;&#13;
    &lt;data name="CallingThreadId" inType="win:UInt32"/&gt;&#13;
    &lt;data name="CallingThreadCreateTime" inType="win:FILETIME"/&gt;&#13;
    &lt;data name="TargetProcessId" inType="win:UInt32"/&gt;&#13;
    &lt;data name="TargetProcessCreateTime" inType="win:FILETIME"/&gt;&#13;
    &lt;data name="TargetProcessStartKey" inType="win:UInt64"/&gt;&#13;
    &lt;data name="TargetProcessSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="TargetProcessSectionSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="TargetProcessProtection" inType="win:UInt8"/&gt;&#13;
    &lt;data name="OriginalProcessId" inType="win:UInt32"/&gt;&#13;
    &lt;data name="OriginalProcessCreateTime" inType="win:FILETIME"/&gt;&#13;
    &lt;data name="OriginalProcessStartKey" inType="win:UInt64"/&gt;&#13;
    &lt;data name="OriginalProcessSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="OriginalProcessSectionSignatureLevel" inType="win:UInt8"/&gt;&#13;
    &lt;data name="OriginalProcessProtection" inType="win:UInt8"/&gt;&#13;
    &lt;data name="BaseAddress" inType="win:Pointer"/&gt;&#13;
    &lt;data name="RegionSize" inType="win:Pointer"/&gt;&#13;
    &lt;data name="ProtectionMask" inType="win:UInt32"/&gt;&#13;
    &lt;data name="LastProtectionMask" inType="win:UInt32"/&gt;&#13;
    &lt;/template&gt;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-9: ETW provider manifest dumped by PerfView</span></p>&#13;
<p class="TX">Comparing the data sizes specified in the manifests with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp> structures reveals that the data appears in the same order. Using this information, we can extract individual fields of the event. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectionMask</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp> correlate to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NewAccessProtection</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">OldAccessProtection</samp>, respectively. The last two entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> array match their data type. <a href="#list12-10">Listing 12-10</a> shows how we can investigate these values using WinDbg.</p>&#13;
<pre id="list12-10"><code>1: kd&gt; <b>dq @rax L(@r9*2)</b>&#13;
<var>--snip--</var>&#13;
ffff9285`03dc6940 ffff9285`03dc69c0 00000000`00000004&#13;
ffff9285`03dc6950 ffff9285`03dc69c8 00000000`00000004&#13;
1: kd&gt; <b>dd ffff9285`03dc69c0 L1</b>&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> ffff9285`03dc69c0 00000004&#13;
1: kd&gt; <b>dd ffff9285`03dc69c8 L1</b>&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> ffff9285`03dc69c8 00000020</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-10: Evaluating protection mask changes using WinDbg</span></p>&#13;
<p class="TX">We can inspect the values’ contents to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> was originally <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READ</samp> (0x20) and has been changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp> (0x4) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Now we know that removing the executable flag in the memory allocation caused the event to fire.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h-160"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label=" Page 221. "/><samp class="SANS_Futura_Std_Bold_B_11">Determining the Source of an Event</samp></h2>&#13;
<p class="TNI">Although we’ve explored the flow from a user-mode function call to an event being emitted, we’ve done so for a single sensor only, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>. At the time of this writing, there are 11 of these sensors, shown in <a href="#tab12-1">Table 12-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab12-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Security and Security Mitigation Sensors</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Threat-Intelligence Sensors</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Security- Mitigations Sensors</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogBlockNonCetBinaries</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDeviceObjectLoadUnload</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionKernelModeReturnMismatch</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionUserModeReturnMismatch</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectUnLoad</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitChildProcessCreation</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitDynamicCode</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitLowILImageMap</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecView</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitNonMicrosoftBinaries</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitWin32kSystemCalls</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogRedirectionTrustPolicy</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeProcess</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogUserCetSetContextIpValidationFailure</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp></p>&#13;
</td>&#13;
<td class="table TBL"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">An additional 10 sensors relate to security mitigations and are identified by their <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTim</samp> prefix. These sensors emit events through a different provider, Microsoft-Windows-Security-Mitigations, but function identically to the normal EtwTi sensors. They’re responsible for generating alerts about security mitigation violations, such as the loading of low-integrity-level or remote images or the triggering of Arbitrary Code Guard, based on system configuration. While these exploit mitigations are out of scope for this book, you’ll occasionally encounter them while investigating EtwTi sensors.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-161"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Neo4j to Discover the Sensor Triggers</samp></h3>&#13;
<p class="TNI">What causes the sensors in <a href="#tab12-1">Table 12-1</a> to emit events? Thankfully, there is a relatively easy way for us to figure this out. Most measure activity coming from user mode, and for control to transition from user mode to kernel mode, a syscall needs to be made. Execution will land in functions prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> after control is handed to the kernel, and the SSDT will handle the entry-point resolution.</p>&#13;
<p class="TX">Therefore, we can map paths from functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> prefixes to functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTi</samp> prefixes to identify APIs that cause events to be emitted due to actions in user mode. Ghidra and IDA both offer call-tree mapping functions that serve this purpose generally. Their performance can be limited, however. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label=" Page 222. "/>For example, Ghidra’s default search depth is five nodes, and longer searches take exponentially longer. They’re also exceedingly difficult to parse.</p>&#13;
<p class="TX">To address this, we can use a system built for identifying paths, such as the graph database Neo4j. If you’ve ever used BloodHound, the attack path-mapping tool, you’ve used Neo4j in some form. Neo4j can map the relationships (called <i>edges</i>) between any kind of item (called <i>nodes</i>). For example, BloodHound uses Active Directory principals as its nodes and properties like access control entries, group membership, and Microsoft Azure permissions as edges.</p>&#13;
<p class="TX">In order to map nodes and edges, Neo4j supports a query language called Cypher whose syntax lies somewhere between Structured Query Language (SQL) and ASCII art and can often look like a drawn diagram. Rohan Vazarkar, one of the inventors of BloodHound, wrote a fantastic blog post about Cypher queries, “Intro to Cypher,” that remains one of the best resources on the topic.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Dataset to Work with Neo4j</samp></h3>&#13;
<p class="TNI">To work with Neo4j, we need a structured dataset, typically in JSON format, to define nodes and edges. We then load this dataset into the Neo4j database using functions from the Awesome Procedures on Cypher add-on library (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">apoc.load.json()</samp>). After ingestion, the data is queried using Cypher in either the web interface hosted on the Neo4j server or a connected Neo4j client.</p>&#13;
<p class="TX">We must extract the data needed to map call graphs into the graph database from Ghidra or IDA using a plug-in, then convert it to JSON. Specifically, each entry in the JSON object needs to have three properties: a string containing the name of the function that will serve as the node, the entry point offset for later analysis, and the outgoing references (in other words, the functions being called by this function) to serve as the edges.</p>&#13;
<p class="TX">The open source Ghidra script <i>CallTreeToJSON.py</i> iterates over all functions in a program that Ghidra has analyzed, collects the attributes of interest, and creates new JSON objects for ingestion by Neo4j. To map the paths related to the EtwTi sensors, we must first load and analyze <i>ntoskrnl.exe</i>, the kernel image, in Ghidra. Then we can load the Python script into Ghidra’s Script Manager and execute it. This will create a file, <i>xrefs.json</i>, that we can load into Neo4j. It contains the Cypher commands shown in <a href="#list12-11">Listing 12-11</a>.</p>&#13;
<pre id="list12-11"><code>CREATE CONSTRAINT function_name ON (n:Function) ASSERT n.name IS UNIQUE&#13;
CALL apoc.load.json("file:///xref.json") YIELD value&#13;
UNWIND value as func&#13;
MERGE (n:Function {name: func.FunctionName})&#13;
SET n.entrypoint=func.EntryPoint&#13;
WITH n, func&#13;
UNWIND func.CalledBy as cb&#13;
MERGE (m:Function {name:cb})&#13;
MERGE (m)-[:Calls]-&gt;(n)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-11: Loading call trees into Ghidra</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label=" Page 223. "/>After importing the JSON file into Neo4j, we can query the dataset using Cypher.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Call Trees</samp></h3>&#13;
<p class="TNI">To make sure everything is set up correctly, let’s write a query to map the path to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp> sensor. In plain English, the query in <a href="#list12-12">Listing 12-12</a> says, “Return the shortest paths of any length from any function name that begins with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> to the sensor function we specify.”</p>&#13;
<pre id="list12-12"><code>MATCH p=shortestPath((f:Function)-[rCalls*1..]-&gt;(t:Function {name: "EtwTiLogProtectExecVm"}))&#13;
WHERE f.name STARTS WITH 'Nt' RETURN p;</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-12: Mapping the shortest paths between <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Nt</samp> functions and the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EtwTiLogProtectExecVm</samp> sensor</span></p>&#13;
<p class="TX">When entered into Neo4j, it should display the path shown in <a href="#fig12-3">Figure 12-3</a>.</p>&#13;
<figure class="IMG"><img id="fig12-3" class="img50" src="../images/Figure12-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A simple path between a syscall and an EtwTi function</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The call trees for other sensors are far more complex. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogMapExecView()</samp> sensor’s call tree is 12 levels deep, leading all the way back to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtCreatePagingFile()</samp>. You can see this by modifying the sensor name in the previous query, generating the path in <a href="#fig12-4">Figure 12-4</a>.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label=" Page 224. "/>&#13;
<figure class="IMG"><img id="fig12-4" class="img60" src="../images/Figure12-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: Paths from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtCreatePagingFile()</samp></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogMapExecView()</samp></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label=" Page 225. "/>As this example demonstrates, many syscalls indirectly hit the sensor. Enumerating these can be useful if you’re looking for coverage gaps, but the amount of information generated can quickly become overwhelming.</p>&#13;
<p class="TX">You might want to scope your queries to a depth of three to four levels (representing two or three calls); these should return the APIs that are directly responsible for calling the sensor function and hold the conditional logic to do so. Using the previous example, a scoped query would show that the syscall <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSection()</samp> calls the sensor function directly, while the syscall <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSectionEx()</samp> calls it indirectly via a memory manager function, as shown in <a href="#fig12-5">Figure 12-5</a>.</p>&#13;
<figure class="IMG"><img id="fig12-5" class="img100" src="../images/Figure12-5.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: Scoped query that returns more useful results</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Performing this analysis across EtwTi sensor functions yields information about their callers, both direct and indirect. <a href="#tab12-2">Table 12-2</a> shows some of these mappings.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label=" Page 226. "/>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab12-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">EtwTi Sensor-to-Syscall Mappings</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Sensor</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Call tree from syscall (depth = 4)</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MiAllocateVirtualMemory</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriver</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriverImage</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriverIopLoadDriver</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">IopUnloadDriver</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnloadDriver</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp> <samp class="SANS_Futura_Std_Book_11">There are other branches of the call tree that lead to system calls, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IopCompleteRequest()</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspGet ContextThreadInternal()</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspSet ContextThreadInternal()</samp><samp class="SANS_Futura_Std_Book_11">, but these aren’t particularly useful, as many internal functions rely on these functions regardless of whether the APC is being created explicitly.</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp> <span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp> <span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThreadEx</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionMiMapViewOf</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">SectionExCommon</samp> <span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionEx</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">MiReadWriteVirtualMemory</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryMiReadWriteVirtualMemory</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryExMiReadWriteVirtualMemory</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">PspSetContextThreadInternal</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetContextThread</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp> <samp class="SANS_Futura_Std_Book_11">This sensor has additional paths that are not listed and are tied to debugging APIs, including</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtDebugActiveProcess()</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!Nt DebugContinue()</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtRemove ProcessDebug()</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendThread</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadPsSuspendThread</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtChangeThreadStatePsSuspendThread</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendProcess</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendProcessPsMultiResumeThread</samp><span class="symbol">←</span><samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">An important fact to consider when reviewing this dataset is that Ghidra does not factor conditional calls in its call trees but rather looks for <i>call</i> instructions inside functions. This means that while the graphs generated from the Cypher queries are technically correct, they may not be followed in all instances. To demonstrate this, an exercise for the reader is to reverse <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp> to find where the determination to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogAllocExecVm()</samp> sensor is made.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h-164"/><samp class="SANS_Futura_Std_Bold_B_11">Consuming EtwTi Events</samp></h2>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, you learned how EDRs consume events from other ETW providers. To try consuming ETW events from EtwTi, run the commands in <a href="#list12-13">Listing 12-13</a> from an elevated command prompt.</p>&#13;
<pre id="list12-13"><code>PS &gt; <b>logman.exe create trace EtwTi -p Microsoft-Windows-Threat-Intelligence -o C:\EtwTi.etl</b>&#13;
PS &gt; <b>logman.exe start EtwTi</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-13: Logman commands to collect events from the EtwTi provider</span></p>&#13;
<p class="TX">You’ll probably receive an access denied error, despite having run the commands in high integrity. This is due to a security feature implemented by Microsoft in Windows 10 and later versions called <i>Secure ETW</i>, which <span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label=" Page 227. "/>prevents malware processes from reading or tampering with antimalware traces. To accomplish this, Windows allows only processes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_ANTIMALWARE_LIGHT</samp> protection level and services started with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp> service protection type to consume events from the channel.</p>&#13;
<p class="TX">Let’s explore process protection so that you can better understand how consuming events from EtwTi works.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h-165"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Protected Processes</samp></h3>&#13;
<p class="TNI">Process protections allow sensitive processes, such as those that interact with DRM-protected content, to evade interaction by outside processes. While originally created for software such as media players, the introduction of Protected Process Light (PPL) eventually extended this protection to other types of applications. In modern versions of Windows, you’ll find PPL used heavily by not only Windows components but also third-party applications, as seen in the Process Explorer window in <a href="#fig12-6">Figure 12-6</a>.</p>&#13;
<figure class="IMG"><img id="fig12-6" class="img100" src="../images/Figure12-6.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: Protection levels across various processes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can view a process’s protection state in the protection field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure that backs every process on Windows. This field is of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTION</samp>, which is defined in <a href="#list12-14">Listing 12-14</a>.</p>&#13;
<pre id="list12-14"><code>typedef struct _PS_PROTECTION {&#13;
    union {&#13;
        UCHAR Level;&#13;
        struct {&#13;
            UCHAR Type   : 3;&#13;
            UCHAR Audit  : 1;&#13;
            UCHAR Signer : 4;&#13;
        };&#13;
    };&#13;
} PS_PROTECTION, *PPS_PROTECTION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTION</samp> structure definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTION</samp> correlates to a value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_TYPE</samp> enumeration, defined in <a href="#list12-15">Listing 12-15</a>.</p>&#13;
<pre id="list12-15"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label=" Page 228. "/>kd&gt; <b>dt nt!_PS_PROTECTED_TYPE</b>&#13;
   PsProtectedTypeNone = 0n0&#13;
   PsProtectedTypeProtectedLight = 0n1&#13;
   PsProtectedTypeProtected = 0n2&#13;
   PsProtectedTypeMax = 0n3</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_TYPE</samp> enumeration</span></p>&#13;
<p class="TX">Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Signer</samp> member is a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_SIGNER</samp> enumeration, defined in <a href="#list12-16">Listing 12-16</a>.</p>&#13;
<pre id="list12-16"><code>kd&gt; <b>dt nt!_PS_PROTECTED_SIGNER</b>&#13;
   PsProtectedSignerNone = 0n0&#13;
   PsProtectedSignerAuthenticode = 0n1&#13;
   PsProtectedSignerCodeGen = 0n2&#13;
   PsProtectedSignerAntimalware = 0n3&#13;
   PsProtectedSignerLsa = 0n4&#13;
   PsProtectedSignerWindows = 0n5&#13;
   PsProtectedSignerWinTcb = 0n6&#13;
   PsProtectedSignerWinSystem = 0n7&#13;
   PsProtectedSignerApp = 0n8&#13;
   PsProtectedSignerMax = 0n9</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_SIGNER</samp> enumeration</span></p>&#13;
<p class="TX">As an example, let’s take a look at the process protection state of <i>msmpeng.exe</i>, Microsoft Defender’s primary process, using WinDbg, as demonstrated in <a href="#list12-17">Listing 12-17</a>.</p>&#13;
<pre id="list12-17"><code>kd&gt; <b>dt nt!_EPROCESS Protection</b>&#13;
   +0x87a Protection : _PS_PROTECTION&#13;
&#13;
kd&gt; <b>!process 0 0 MsMpEng.exe</b>&#13;
PROCESS ffffa608af571300&#13;
    SessionId: 0   Cid: 1134  Peb: 253d4dc000   ParentCid: 0298&#13;
    DirBase: 0fc7d002 ObjectTable: ffffd60840b0c6c0 HandleCount: 636.&#13;
    Image: MsMpEng.exe&#13;
&#13;
kd&gt; <b>dt nt!_PS_PROTECTION ffffa608af571300</b> <b>+ 0x87a</b>&#13;
    +0x000 Level           : 0x31 '1'&#13;
    +0x000 Type          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> : 0y001&#13;
    +0x000 Audit           : 0y0&#13;
    +0x000 Signer        <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> : 0y0011</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-17: Evaluating</span> <span class="eSANS_Futura_Std_Book_11a">msmpeng.exe</span><span class="eSANS_Futura_Std_Book_Oblique_I_11a">’s process protection level</span></p>&#13;
<p class="TX">The process’s protection type is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedTypeProtectedLight</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and its signer is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware</samp> (a value equivalent to 3 in decimal) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. With this protection level, also referred to as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware-Light</samp>, outside processes have limited ability to request access to the process, and the memory manager will prevent improperly signed modules (such as DLLs and application compatibility databases) from being loaded into the process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h-166"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label=" Page 229. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Protected Process</samp></h3>&#13;
<p class="TNI">Creating a process to run with this protection level is not as simple as passing flags into <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>, however. Windows validates the image file’s digital signature against a Microsoft-owned root certificate authority used to sign many pieces of software, from drivers to third-party applications.</p>&#13;
<p class="TX">It also validates the file by checking for one of several Enhanced Key Usage (EKU) extensions to determine the process’s granted signing level. If this granted signing level doesn’t dominate the requested signing level, meaning that the signer belongs to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DominateMask</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROTECTED_ACCESS</samp> structure, Windows checks whether the signing level is runtime customizable. If so, it checks whether the signing level matches any of the registered runtime signers on the system, and if a match is found, it authenticates the certificate chain with the runtime signer’s registration data, such as the hash of the signer and EKUs. If all checks pass, Windows grants the requested signature level.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registering an ELAM Driver</samp></h4>&#13;
<p class="TNI">To create a process or service with the required protection level, a developer needs a signed ELAM driver. This driver must have an embedded resource, <samp class="SANS_TheSansMonoCd_W5Regular_11">MICROSOFTELAMCERTIFICATEINFO</samp>, that contains the certificate hash and hashing algorithm used for the executables associated with the user-mode process or service to be protected, along with up to three EKU extensions. The operating system will parse or register this information at boot via an internal call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeRegisterElamCertResources()</samp> (or an administrator can do so manually at runtime). If registration happens during the boot process, it occurs during pre-boot, before control is handed to the Windows Boot Manager, as shown in the WinDbg output in <a href="#list12-18">Listing 12-18</a>.</p>&#13;
<pre id="list12-18"><code>1: kd&gt; <b>k</b>&#13;
 # Child-SP          RetAddr           Call Site&#13;
00 ffff8308`ea406828 fffff804`1724c9af nt!SeRegisterElamCertResources&#13;
01 ffff8308`ea406830 fffff804`1724f1ac nt!PipInitializeEarlyLaunchDrivers+0x63&#13;
02 ffff8308`ea4068c0 fffff804`1723ca40 nt!IopInitializeBootDrivers+0x153&#13;
03 ffff8308`ea406a70 fffff804`172436e1 nt!IoInitSystemPreDrivers+0xb24&#13;
04 ffff8308`ea406bb0 fffff804`16f8596b nt!IoInitSystem+0x15&#13;
05 ffff8308`ea406be0 fffff804`16b55855 nt!Phase1Initialization+0x3b&#13;
06 ffff8308`ea406c10 fffff804`16bfe818 nt!PspSystemThreadStartup+0x55&#13;
07 ffff8308`ea406c60 00000000`00000000 nt!KiStartSystemThread+0x28</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-18: ELAM resources registered during the boot process</span></p>&#13;
<p class="TX">You’ll rarely see the manual registration option implemented in enterprise products, as resources parsed at boot require no further interaction at runtime. Still, both options net the same result and can be used interchangeably.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H3" id="sec12"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label=" Page 230. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Signature</samp></h4>&#13;
<p class="TX">After registration, the driver becomes available for comparison when a signing-level match is found. The rest of this section covers the implementation of the consumer application in the context of an endpoint agent.</p>&#13;
<p class="TX">To create the resource and register it with the system, the developer first obtains a certificate that includes the Early Launch and Code Signing EKUs, either from the certificate authority or generated as a self-signed certificate for test environments. We can create a self-signed certificate using the <i>New-SelfSignedCertificate</i> PowerShell cmdlet, as shown in <a href="#list12-19">Listing 12-19</a>.</p>&#13;
<pre id="list12-19"><code>PS &gt; <b>$password = ConvertTo-SecureString -String "ThisIsMyPassword" -Force -AsPlainText</b>&#13;
PS &gt; <b>$cert = New-SelfSignedCertificate -certstorelocation "Cert:\CurrentUser\My"</b>&#13;
<b>&gt;&gt;   -HashAlgorithm SHA256 -Subject "CN=MyElamCert" -TextExtension</b>&#13;
<b>&gt;&gt;   @("2.5.29.37={text}1.3.6.1.4.1.311.61.4.1,1.3.6.1.5.5.7.3.3")</b>&#13;
PS &gt; <b>Export-PfxCertificate -cert $cert -FilePath "MyElamCert.pfx" -Password $password</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-19: Generating and exporting a code-signing certificate</span></p>&#13;
<p class="TX">This command generates a new self-signed certificate, adds both the Early Launch and Code Signing EKUs, then exports it in <i>.pfx</i> format.</p>&#13;
<p class="TX">Next, the developer signs their executable and any dependent DLLs using this certificate. You can do this using the <i>signtool.exe</i> syntax included in <a href="#list12-20">Listing 12-20</a>.</p>&#13;
<pre id="list12-20"><code>PS &gt; <b>signtool.exe sign /fd SHA256 /a /v /ph /f .\MyElamCert.pfx</b>&#13;
<b>&gt;&gt;   /p "ThisIsMyPassword" .\path \to\my\service.exe</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-20: Signing an executable using the generated certificate</span></p>&#13;
<p class="TX">At this point, the service executable meets the signing requirements to be launched as protected. But before it can be started, the driver’s resource must be created and registered.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Resource</samp></h4>&#13;
<p class="TNI">The first piece of information needed to create the resource is the To-Be-Signed (TBS) hash for the certificate. The second piece of information is the certificate’s file-digest algorithm. As of this writing, this field can be one of the following four values: 0x8004 (SHA10), x800C (SHA256), 0x800D (SHA384), or 0x800E (SHA512). We specified this algorithm in the <samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp> parameter when we created the certificate with <i>signtool.exe</i>.</p>&#13;
<p class="TX">We can collect both of these values by using <i>certmgr.exe</i> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp> argument, as shown in <a href="#list12-21">Listing 12-21</a>.</p>&#13;
<pre id="list12-21"><code>PS &gt; <b>.\certmgr.exe -v .\path\to\my\service.exe</b>&#13;
<var>--snip--</var>&#13;
Content Hash (To-Be-Signed Hash)::<span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label=" Page 231. "/>&#13;
    04 36 A7 99 81 81 81 07 2E DF B6 6A 52 56 78 24    '.6.….….jRVx$'&#13;
    E7 CC 5E AA A2 7C 0E A3 4E 00 8D 9B 14 98 97 02    '..^..|..N.……'&#13;
<var>--snip--</var>&#13;
Content SignatureAlgorithm:: 1.2.840.113549.1.1.11 (sha256RSA)&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-21: Retrieving the To Be Signed hash and signature algorithm using</span> <span class="eSANS_Futura_Std_Book_11a">certmgr.exe</span></p>&#13;
<p class="TX">The hash is located under <samp class="SANS_TheSansMonoCd_W5Regular_11">Content Hash</samp> and the signature algorithm under <samp class="SANS_TheSansMonoCd_W5Regular_11">Content SignatureAlgorithm</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a New Resource File</samp></h4>&#13;
<p class="TNI">Now we can add a new resource file to the driver project with the contents shown in <a href="#list12-22">Listing 12-22</a> and compile the driver.</p>&#13;
<pre id="list12-22"><code>MicrosoftElamCertificateInfo MSElamCertInfoID&#13;
{&#13;
      1,&#13;
      L"0436A799818181072EDFB66A52567824E7CC5EAAA27C0EA34E008D9B14989702\0",&#13;
      0x800C,&#13;
      L"\0"&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MicrosoftElamCertificateInfo</samp> resource contents</span></p>&#13;
<p class="TX">The first value of this resource is the number of entries; in our case, there is only one entry, but there may be up to three. Next is the TBS hash that we collected earlier, followed by the hexadecimal value corresponding to the hashing algorithm used (SHA256 in our case).</p>&#13;
<p class="TX">Finally, there is a field in which we can specify additional EKUs. Developers use these to uniquely identify antimalware components signed by the same certificate authority. For example, if there are two services with the same signer on the host, but only one needs to be launched with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp> flag, the developer could add a unique EKU when signing that service and add it to the ELAM driver’s resource. The system will then evaluate this additional EKU when starting the service with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anti-Malware</samp> protection level. Since we’re not providing any additional EKUs in our resource, we pass what equates to an empty string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Signing the Resource</samp></h4>&#13;
<p class="TNI">We then sign the driver using the same syntax we used to sign the service executable (<a href="#list12-23">Listing 12-23</a>).</p>&#13;
<pre id="list12-23"><code>PS &gt; <b>signtool.exe sign /fd SHA256 /a /v /ph /f "MyElamCert.pfx" /p "ThisIsMyPassword"</b>&#13;
<b>&gt;&gt;   .\path\to\my\driver.sys</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-23: Signing the driver with our certificate</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label=" Page 232. "/>Now the resource will be included in the driver and is ready to be installed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Installing the Driver</samp></h4>&#13;
<p class="TNI">If the developer wants the operating system to handle loading the certificate information, they simply create the kernel service as described in <span class="Xref">“Registering an ELAM Driver” on <a href="#sec11">page 229</a></span>. If they would like to install the ELAM certificate at runtime, they can use a registration function in their agent, such as the one shown in <a href="#list12-24">Listing 12-24</a>.</p>&#13;
<pre id="list12-24"><code>BOOL RegisterElamCertInfo(wchar_t* szPath)&#13;
{&#13;
    HANDLE hELAMFile = NULL;&#13;
&#13;
    hELAMFile = CreateFileW(&#13;
        szPath, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING,&#13;
        FILE_ATTRIBUTE_NORMAL, NULL);&#13;
&#13;
    if (hELAMFile == INVALID_HANDLE_VALUE)&#13;
    {&#13;
        wprintf(L"[-] Failed to open the ELAM driver. Error: 0x%x\n",&#13;
            GetLastError());&#13;
        return FALSE;&#13;
    }&#13;
&#13;
    if (!InstallELAMCertificateInfo(hELAMFile))&#13;
    {&#13;
        wprintf(L"[-] Failed to install the certificate info. Error: 0x%x\n",&#13;
            GetLastError());&#13;
        CloseHandle(hELAMFile);&#13;
        return FALSE;&#13;
    }&#13;
&#13;
    wprintf(L"[+] Installed the certificate info");&#13;
    return TRUE;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-24: Installing the certificate on the system</span></p>&#13;
<p class="TX">This code first opens a handle to the ELAM driver containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">MicrosoftElamCertificateInfo</samp> resource. The handle is then passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel 32!InstallELAMCertificateInfo()</samp> to install the certificate on the system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Starting the Service</samp></h4>&#13;
<p class="TNI">All that is left at this point is to create and start the service with the required protection level. This can be done in any number of ways, but it is most frequently done programmatically using the Win32 API. <a href="#list12-25">Listing 12-25</a> shows an example function for doing so.</p>&#13;
<pre id="list12-25"><code>BOOL CreateProtectedService() {&#13;
    SC_HANDLE hSCM = NULL;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label=" Page 233. "/>&#13;
    SC_HANDLE hService = NULL;&#13;
    SERVICE_LAUNCH_PROTECTED_INFO info;&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> hSCM = OpenSCManagerW(NULL, NULL, SC_MANAGER_ALL_ACCESS);&#13;
    if (!hSCM) {&#13;
        return FALSE;&#13;
    }&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> hService = CreateServiceW(&#13;
        hSCM,&#13;
        L"MyEtWTiConsumer",&#13;
        L"Consumer service",&#13;
        SC_MANAGER_ALL_ACCESS,&#13;
        SERVICE_WIN32_OWN_PROCESS,&#13;
        SERVICE_DEMAND_START,&#13;
        SERVICE_ERROR_NORMAL,&#13;
        L"\\path\\to\\my\\service.exe",&#13;
        NULL, NULL, NULL, NULL, NULL);&#13;
    if (!hService) {&#13;
        CloseServiceHandle(hSCM);&#13;
        return FALSE;&#13;
    }&#13;
&#13;
    info.dwLaunchProtected =&#13;
      SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> if (!ChangeServiceConfig2W(&#13;
        hService,&#13;
        SERVICE_CONFIG_LAUNCH_PROTECTED,&#13;
        &amp;info))&#13;
    {&#13;
        CloseServiceHandle(hService);&#13;
        CloseServiceHandle(hSCM);&#13;
        return FALSE;&#13;
    }&#13;
    if (!StartServiceW(hService, 0, NULL)) {&#13;
        CloseServiceHandle(hService);&#13;
        CloseServiceHandle(hSCM);&#13;
        return FALSE;&#13;
    }&#13;
&#13;
    return TRUE;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-25: Creating the consumer service</span></p>&#13;
<p class="TX">First, we open a handle to the Service Control Manager <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the operating system component responsible for overseeing all services on the host. Next, we create the base service via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateServiceW()</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This function accepts information, such as the service name, its display name, and the path to the service binary, and returns a handle to the newly created service when it completes. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ChangeServiceConfig2W()</samp> to set the new service’s protection level <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label=" Page 234. "/>When this function completes successfully, Windows will start the protected consumer service, shown running in the Process Explorer window in <a href="#fig12-7">Figure 12-7</a>.</p>&#13;
<figure class="IMG"><img id="fig12-7" class="img100" src="../images/Figure12-7.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: EtwTi consumer service running with the required protection level</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now it can begin working with events from the EtwTi provider.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h-167"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp></h3>&#13;
<p class="TNI">You can write a consumer for the EtwTi provider in virtually the same way as you would for a normal ETW consumer, a process discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. Once you’ve completed the protection and signing steps described in the previous section, the code for receiving, processing, and extracting data from events is the same as for any other provider.</p>&#13;
<p class="TX">However, because the EtwTi consumer service is protected, you might find it difficult to work with events during development, such as by reading <i>printf</i>-style output. Thankfully, the provider’s manifest can provide you with event formats, IDs, and keywords, which can make working with the events much easier.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h-168"/><samp class="SANS_Futura_Std_Bold_B_11">Evading EtwTi</samp></h2>&#13;
<p class="TNI">Because they live in the kernel, EtwTi sensors provide EDRs with a robust telemetry source that is hard to tamper with. There are, however, a few ways that attackers may either neutralize the sensors’ capabilities or at least coexist with them.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h-169"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coexistence</samp></h3>&#13;
<p class="TNI">The simplest evasion approach involves using Neo4j to return all syscalls that hit EtwTi sensors, then refraining from calling these functions in your operations. This means you’ll have to find alternative ways to perform tasks such as memory allocation, which can be daunting.</p>&#13;
<p class="TX">For example, Cobalt Strike’s Beacon supports three memory allocation methods: <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">MapViewOfFile</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. Those last two methods both call a syscall that EtwTi sensors monitor. The first method, on the other hand, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!RtlAllocateHeap()</samp>, which has no direct outgoing references to EtwTi functions, making it the safest bet. The downside is that it doesn’t support allocations in remote processes, so you can’t perform process injection with it.</p>&#13;
<p class="TX">As with all telemetry sources in this book, remember that some other source might be covering the gaps in the EtwTi sensors. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> as an example, endpoint security agents may track and scan executable heap allocations created by user-mode programs. Microsoft may also modify <span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label=" Page 235. "/>APIs to call the existing sensors or add entirely new sensors at any time. This requires that teams remap the relationships from syscalls to EtwTi sensors on each new build of Windows, which can be time consuming.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h-170"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Handle Overwriting</samp></h3>&#13;
<p class="TNI">Another option is to simply invalidate the global trace handle in the kernel. Upayan Saha’s “Data Only Attack: Neutralizing EtwTi Provider” blog post covers this technique in great detail. It requires the operator to have an arbitrary read-write primitive in a vulnerable driver, such as those present in previous versions of Gigabyte’s <i>atillk64.sys</i> and LG Device Manager’s <i>lha.sys</i>, two signed drivers published by the PC hardware and peripheral manufacturers for legitimate device-support purposes.</p>&#13;
<p class="TX">The primary challenge of this technique is locating the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp> structure, which defines the information used to enable the provider. Inside this structure is a member, <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp>, that we must manually change to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to prevent events from reaching the security product. We can use some of what we’ve already learned about how events are published to help make this process easier.</p>&#13;
<p class="TX">Recall from the previous sections that all sensors use the global <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle REGHANDLE</samp> when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> to emit an event. This handle is actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp> structure, which itself contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp> structure in its <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp> member (offset 0x20), as shown in <a href="#list12-26">Listing 12-26</a>.</p>&#13;
<pre id="list12-26"><code>0: kd&gt; <b>dt nt!_ETW_REG_ENTRY poi(nt!EtwThreatIntProvRegHandle)</b>&#13;
 <var>  --snip--</var>&#13;
 <var>  </var>+0x020 GuidEntry        : 0xffff8e8a`901f3c50 _ETW_GUID_ENTRY&#13;
 <var>  --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-26: Getting the address of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ETW_GUID_ENTRY</samp> structure</span></p>&#13;
<p class="TX">This structure is the kernel’s record of an event provider and contains an array of eight <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp> structures in its <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableInfo</samp> member (offset 0x80). Only the first entry, the contents of which are included in <a href="#list12-27">Listing 12-27</a>, is used by default.</p>&#13;
<pre id="list12-27"><code>0: kd&gt; <b>dx -id 0,0,ffff8e8a90062040 -r1 (*((ntkrnlmp!_TRACE_ENABLE_INFO *)0xffff8e8a901f3cd0))</b>&#13;
(*((ntkrnlmp!_TRACE_ENABLE_INFO *)0xffff8e8a901f3cd0))&#13;
[Type: _TRACE_ENABLE_INFO]&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> [+0x000] IsEnabled         : 0x1 [Type: unsigned long]&#13;
    [+0x004] Level             : 0xff [Type: unsigned char]&#13;
    [+0x005] Reserved1         : 0x0 [Type: unsigned char]&#13;
    [+0x006] LoggerId          : 0x4 [Type: unsigned short]&#13;
    [+0x008] EnableProperty    : 0x40 [Type: unsigned long]&#13;
    [+0x00c] Reserved2         : 0x0 [Type: unsigned long]&#13;
    [+0x010] MatchAnyKeyword   : 0xdcfa5555 [Type: unsigned __int64]&#13;
    [+0x018] MatchAllKeyword   : 0x0 [Type: unsigned __int64]</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-27: Extracting the contents of the first <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_ENABLE_INFO</samp> structure</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label=" Page 236. "/>This member is an unsigned long (really a Boolean, per Microsoft’s documentation) that indicates whether the provider is enabled for the trace session <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">If an attacker can flip this value to 0, they can disable the Microsoft-Windows-Threat-Intelligence provider, preventing the consumer from receiving events. Working back through these nested structures, we can find our target using the following steps:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Finding the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp> pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntRegHandle</samp></li>&#13;
<li class="NL">Finding the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp> pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp> structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp> member (offset 0x20)</li>&#13;
<li class="NL">Adding 0x80 to the address to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp> member of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp> structure in the array</li>&#13;
</ol>&#13;
<p class="TX">Finding the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp> is the most challenging part of this technique, as it requires using the arbitrary read in the vulnerable driver to search for a pattern of opcodes that work with the pointer to the structure.</p>&#13;
<p class="TX">According to his blog post, Saha used <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp> as the starting point of the search, as this function is exported by <i>ntoskrnl.exe</i> and references the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> in an early call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>. Per the Windows calling convention, the first parameter passed to a function is stored in the RCX register. Therefore, this address will be placed into the register prior to the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp> using a <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp> instruction. By searching for the opcodes <samp class="SANS_TheSansMonoCd_W5Regular_11">48 8b 0d</samp> corresponding to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov rcx,qword ptr [x]</samp> from the function entry point until the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>, we can identify the virtual address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>. Then, using the offsets identified earlier, we can set its <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp> member to 0.</p>&#13;
<p class="TX">Another method of locating <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp> is to use its offset from the base address of the kernel. Due to kernel address space layout randomization (KASLR), we can’t know its full virtual address, but its offset has proven to be stable across reboots. For example, on one build of Windows, this offset is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC197D0</samp>, as shown in <a href="#list12-28">Listing 12-28</a>.</p>&#13;
<pre id="list12-28"><code>0: kd&gt; <b>vertarget</b>&#13;
<var>--snip--</var>&#13;
Kernel base = 0xfffff803`02c00000 PsLoadedModuleList = 0xfffff803`0382a230&#13;
<var>--snip--</var>&#13;
&#13;
0: kd&gt; <b>x /0 nt!EtwThreatIntProvRegHandle</b>&#13;
fffff803`038197d0&#13;
&#13;
0: kd&gt; <b>? fffff803`038197d0 - 0xfffff803`02c00000</b>&#13;
Evaluate expression: 12687312 = 00000000`00c197d0</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-28: Finding the offset to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">REGHANDLE</samp></span></p>&#13;
<p class="TX">The last line in this listing subtracts the base address of the kernel from the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>. We can retrieve this base address <span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label=" Page 237. "/>from user mode by running <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp> information class, demonstrated in <a href="#list12-29">Listing 12-29</a>.</p>&#13;
<pre id="list12-29"><code>void GetKernelBaseAddress()&#13;
{&#13;
    NtQuerySystemInformation pfnNtQuerySystemInformation = NULL;&#13;
    HMODULE hKernel = NULL;&#13;
    HMODULE hNtdll = NULL;&#13;
    RTL_PROCESS_MODULES ModuleInfo = {0};&#13;
&#13;
    hNtdll = GetModuleHandle(L"ntdll");&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pfnNtQuerySystemInformation =&#13;
        (NtQuerySystemInformation)GetProcAddress(&#13;
            hNtdll, "NtQuerySystemInformation");&#13;
&#13;
    pfnNtQuerySystemInformation(&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> SystemModuleInformation,&#13;
        &amp;ModuleInfo,&#13;
        sizeof(ModuleInfo),&#13;
        NULL);&#13;
&#13;
    wprintf(L"Kernel Base Address: %p\n",&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> (ULONG64)ModuleInfo.Modules[0].ImageBase);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 12-29: Getting the base address of the kernel</span></p>&#13;
<p class="TX">This function first gets a function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then invokes it, passing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp> information class <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Upon completion, this function will populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROCESS_MODULES</samp> structure (named <samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleInfo</samp>), at which point the address of the kernel can be retrieved by referencing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp> attribute of the first entry in the array <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">You’ll still require a driver with a write-what-where primitive to patch the value, but using this approach avoids us having to parse memory for opcodes. This technique also introduces the problem of tracking offsets to <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp> across all kernel versions on which they operate, however, so it isn’t without its own challenges.</p>&#13;
<p class="TX">Additionally, those who employ this technique must also consider the telemetry it generates. For instance, loading a vulnerable driver is harder on Windows 11, as Hypervisor-Protected Code Integrity is enabled by default, which can block drivers known to contain vulnerabilities. At the detection level, loading a new driver will trigger the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogDriverObjectLoad()</samp> sensor, which may be atypical for the system or environment, causing a response.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec22">&#13;
<h2 class="H1" id="sec22"><span id="h-171"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">The Microsoft-Windows-Threat-Intelligence ETW provider is one of the most important data sources available to an EDR at the time of this writing. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label=" Page 238. "/>It provides unparalleled visibility into processes executing on the system by sitting inline of their execution, similar to function-hooking DLLs. Despite their likeness, however, this provider and its hooks live in the kernel, where they are far less susceptible to evasion through direct attacks. Evading this data source is more about learning to work around it than it is about finding the glaring gap or logical flaw in its implementation.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>