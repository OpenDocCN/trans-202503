- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING ADVANCED GUIs AND SHARING YOUR APP
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: For the GUI desktop version of the Secret Messages app, we’re going to provide
    two large text areas that allow the user to copy and paste long messages in the
    GUI interface. By the end of the chapter, we’ll add a slider for key selection
    like the one shown in [Figure 7-1](ch7.xhtml#ch7fig1), which will make cracking
    Caesar ciphers very easy, even when the key is unknown!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0148-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The Secret Messages encoder/decoder app we’ll build in this chapter*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This version of the app is more user-friendly than the console-based app, and
    we’ll be able to reuse some code from [Chapter 6](ch6.xhtml#ch6) because the algorithm
    for encoding and decoding messages is the same.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Secret Messages GUI App Project
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open Eclipse and create a new Java project by going to **File** ▸ **New** ▸
    **Java Project**. Name the project `SecretMessagesGUI` and then click **Finish**.
    Close any open files and expand the *SecretMessagesGUI* project folder in the
    Package Explorer pane to find the *src* folder. Right-click the *src* folder and
    select **New** ▸ **Class** to create a new Java source code file. Name this `SecretMessagesGUI`
    as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use the Swing toolkit again, so in the New Java Class dialog,
    change the superclass to `javax.swing.JFrame` and select the checkbox to create
    a `main()` method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**, and you’ll see some familiar skeleton code for the *SecretMessagesGUI.java*
    file. Right-click the *SecretMessagesGUI.java* file in the Package Explorer and
    select **Open With** ▸ **WindowBuilder Editor** to begin creating the GUI interface
    for the Secret Messages app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Designing the GUI and Naming Components
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the WindowBuilder Editor’s Design tab. Expand the `javax.swing.JFrame`
    component in the Components pane and select **getContentPane()**. Now go to the
    Properties pane and change the `Layout` property to **Absolute layout**, as shown
    in [Figure 7-2](ch7.xhtml#ch7fig2). This will allow us to position components
    with pixel-perfect accuracy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0149-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Change the Layout property to* ***Absolute layout*** *before placing
    any GUI components.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the Components pane, click **javax.swing.JFrame**. Then, in the Properties
    pane, set the `defaultCloseOperation` to **EXIT_ON_CLOSE**. Also, change the `title`
    property to `Your Name``'s Secret Message App`, as shown in [Figure 7-3](ch7.xhtml#ch7fig3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0149-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Change the defaultCloseOperation and title properties to customize
    the app.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s give ourselves some room to build a slightly larger GUI interface
    so we can encode and decode longer messages. With `javax.swing.JFrame` still selected
    in the Components pane, click the outside border of the window in the design preview.
    Click the small black resize box at the lower-right corner of the window, and
    drag down and to the right to resize the frame to 600 by 400 pixels, as shown
    in [Figure 7-4](ch7.xhtml#ch7fig4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0150-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Resize the JFrame to hold bigger messages.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to begin placing the GUI interface components. For the GUI version
    of the app, we want to be able to encode and decode long messages, so the first
    component we’ll place is a `JTextArea`. Like a `JTextField`, text areas allow
    you to enter text, but a `JTextArea` can hold, display, and even wrap several
    lines of text.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: To insert the first `JTextArea` for the user to input a message, under Components
    in the Palette, click **JTextArea**. Then place it near the top of the `JFrame`
    in the design preview. Click and drag to draw a `JTextArea` approximately one-third
    of the height of the content pane, with a small margin between the `JTextArea`
    and the edge of the frame. The `JTextArea` should be approximately 564 pixels
    wide by 140 pixels tall. Then, in the Properties pane, change the `Variable` property
    to `txtIn`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To create the second `JTextArea` for the outputted message, right-click **txtIn**
    in the Preview pane, select **Copy**, right-click the content pane, and select
    **Paste**. Place the new `JTextArea` near the bottom edge of the frame. To name
    the new `JTextArea`, change the `Variable` property to `txtOut`. You should end
    up with two `JTextArea` components, as shown in [Figure 7-5](ch7.xhtml#ch7fig5).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0151-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Copy and paste txtIn to create a second JTextArea and name it
    txtOut*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add a text field for the encryption key value. Click **JTextField**
    in the Palette pane under Components and then click near the center of the content
    pane to place the `JTextField`. Change the `JTextField`’s `Variable` property
    to `txtKey` and resize it to about half its original size.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Add a `JLabel` to the left of `txtKey`, entering `Key:` as the label’s `text`
    property. Set the `horizontalAlignment` to **RIGHT**. Finally, add a `JButton`
    to the right of `txtKey`, entering the words `Encode/Decode` as the button’s `text`
    property. Expand the width of the button until it shows all the text. The interface
    should look like [Figure 7-6](ch7.xhtml#ch7fig6). To preview the interface without
    running the app, press the small Test GUI button above the Palette, circled in
    [Figure 7-6](ch7.xhtml#ch7fig6).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0151-02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: Test the GUI interface by pressing the Test GUI button above the
    Palette.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the user interface set up, it’s time to code the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Secret Messages GUI App
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Switch back to the source view by clicking the Source tab on the bottom left
    of the design view window. You’ll see that Eclipse has added all the GUI code
    in the *SecretMessagesGUI.java* file. To connect the GUI to our app, we first
    need to add the declarations for the two `JTextArea` variables at the top of the
    `SecretMessagesGUI` class. Eclipse knows that `JTextField` components usually
    need event handlers for user input, so it places `txtKey` at the top of the class,
    but we need to do the same with the two `JTextArea` components, `txtIn` and `txtOut`.
    Add the two bottom lines shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击设计视图窗口左下角的Source选项卡切换回源代码视图。你会看到，Eclipse已经将所有GUI代码添加到了*SecretMessagesGUI.java*文件中。为了将GUI与我们的应用程序连接起来，我们首先需要在`SecretMessagesGUI`类的顶部添加两个`JTextArea`变量的声明。Eclipse知道`JTextField`组件通常需要用户输入的事件处理程序，因此将`txtKey`放在了类的顶部，但我们需要对两个`JTextArea`组件，`txtIn`和`txtOut`，做相同的处理。添加以下两行代码：
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessagesGUI extends JFrame {
- en: private JTextField txtKey;
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtKey;
- en: private JTextArea txtIn;
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtIn;
- en: private JTextArea txtOut;
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextArea txtOut;
- en: 'After declaring the `JTextArea` variables at the top of the file, we need to
    modify the code inside the `SecretMessagesGUI()` constructor. Delete the variable
    type `JTextArea` at the beginning of each of these two lines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部声明`JTextArea`变量后，我们需要修改`SecretMessagesGUI()`构造函数中的代码。删除以下两行开头的`JTextArea`变量类型：
- en: public SecretMessagesGUI() {
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: public SecretMessagesGUI() {
- en: setTitle("Dr. Payne's Secret Message App");
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: setTitle("Dr. Payne的秘密消息应用");
- en: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
- en: getContentPane().setLayout(null);
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().setLayout(null);
- en: txtIn = new JTextArea(); // Delete "JTextArea" from start of line
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn = new JTextArea(); // 删除行首的“JTextArea”
- en: txtIn.setBounds(10, 11, 564, 140);
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn.setBounds(10, 11, 564, 140);
- en: getContentPane().add(txtIn);
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtIn);
- en: txtOut = new JTextArea(); // Delete "JTextArea" from start of line
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut = new JTextArea(); // 删除行首的“JTextArea”
- en: txtOut.setBounds(10, 210, 564, 140);
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setBounds(10, 210, 564, 140);
- en: getContentPane().add(txtOut);
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(txtOut);
- en: With these changes, we’re ready to begin writing the method to encode messages
    whenever the user clicks the Encode/Decode button.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 做了这些修改后，我们就可以开始编写方法来处理每次用户点击“编码/解码”按钮时的消息编码了。
- en: '*Creating the encode() Method*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建 encode() 方法*'
- en: The `encode()` method we’ll write is similar to `checkGuess()` from the Hi-Lo
    guessing game app in [Chapter 3](ch3.xhtml#ch3). The `checkGuess()` method took
    a string that was the user’s guess, but the method didn’t need to return a value,
    so it returned `void`. Unlike `checkGuess()`, `encode()` will take a message and
    an encryption key as values, and instead of returning `void`, it will return an
    encoded message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的`encode()`方法类似于[第3章](ch3.xhtml#ch3)中Hi-Lo猜数字游戏应用的`checkGuess()`方法。`checkGuess()`方法接收一个字符串作为用户的猜测，但该方法不需要返回任何值，所以它返回了`void`。与`checkGuess()`不同，`encode()`将接收一个消息和一个加密密钥作为参数，并且不会返回`void`，而是返回一个编码后的消息。
- en: Methods return values so that the program can use them. We want `encode()` to
    take a message and key from the user and then run some code on those values to
    produce the encoded message, which our program will use as the output for the
    user. When declaring a method that returns information, we state the return value’s
    data type before the name of the method. The type of information we want returned
    from `encode()` is a `String` variable. So, `encode()` will be declared as `public
    String encode()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 方法返回值是为了让程序可以使用它们。我们希望`encode()`方法接收来自用户的消息和密钥，然后对这些值进行处理以生成编码后的消息，程序将把它作为用户的输出。当声明一个返回值的方法时，我们在方法名之前指定返回值的数据类型。我们希望从`encode()`返回的值是一个`String`类型的变量。所以，`encode()`将声明为`public
    String encode()`。
- en: 'We need to tell Java what kind of information we want to pass to `encode()`;
    this information is known as a method’s *parameters*. To declare parameters for
    a method, we place them inside the parentheses following the method name, with
    the data type first and the name of the parameter second. Multiple parameters
    are separated by commas. The declaration for the `encode()` method looks like
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Java我们想要传递给`encode()`的信息是什么，这些信息被称为方法的*参数*。要声明方法的参数，我们将它们放在方法名后的圆括号内，参数的数据类型放在前面，参数的名称放在后面。多个参数用逗号分隔。`encode()`方法的声明如下：
- en: public String encode( String message, int keyVal )
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal )
- en: 'Let’s add braces for the body and place the `encode()` method right below the
    declarations for the two `JTextArea` variables, above the `SecretMessagesGUI()`
    constructor method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: private JTextField txtKey;
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtIn;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtOut;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: public String encode( String message, int keyVal ) {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: public SecretMessagesGUI() {
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse will underline the `encode()` method in red to let you know you haven’t
    returned a value, but that’s because we haven’t written the code inside the method
    body yet. Here we’ll be reusing some of our code from [Chapter 6](ch6.xhtml#ch6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a `String` called `output`, set it equal to an empty string for now,
    and add a line to return `output` as the result of the `encode()` method using
    a `return` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: public String encode( String message, int keyVal ) {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: return output;
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Since `encode()` was declared to return a `String` value and we’re returning
    `output`, which *is* a `String`, Eclipse will remove the red underline to let
    us know we’ve fixed the problem of the missing return value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll reuse a selection of code from the text-based version of the app
    for encoding messages. Open the *SecretMessages* project from [Chapter 6](ch6.xhtml#ch6)
    in the Project Explorer pane.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We can copy the code starting at `char key` and ending at the closing brace
    of the `for` loop, right before `System.out.println(output);` near the end of
    the program. This is the part of the app that encodes a message using the Caesar
    cipher algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the copied code from *SecretMessages.java* into *SecretMessagesGUI.java*,
    inside `encode()`, between the two lines we just added. The finished `encode()`
    method looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: public String encode( String message, int keyVal ) {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: char key = (char) keyVal;
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'Z')
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'A')
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'a')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: input += (keyVal % 10);
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: if (input > '9')
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: input -= 10;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: if (input < '0')
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: input += 10;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: return output;
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Because we named our variables consistently, we can reuse the Caesar cipher
    encryption code. Consistent naming is a good habit, and well-written code in Java
    can be reused across multiple platforms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*Writing the Event Handler for the Encode/Decode Button*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want the user to provide both the input message and the key value that we’ll
    pass along to `encode()` in the GUI interface, and we want the output message
    to be returned when the user presses the Encode/Decode button, so let’s write
    the code to handle the button click event.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the design view in *SecretMessagesGUI.java* and double-click the
    **Encode/Decode** button. Eclipse will switch back to the source view and insert
    the code for the `actionPerformed()` event handler for the Encode/Decode button,
    like the code snippet shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: JButton btnEncodedecode = new JButton("Encode/Decode");
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This is an anonymous inner class, like the one we first encountered in [Chapter
    3](ch3.xhtml#ch3). All we have to add is the code inside `actionPerformed()` to
    tell Java how the button should behave when it’s clicked.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the Encode/Decode button to perform the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Get the input message from `txtIn`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Get the key from `txtKey`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Encode the message using the key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Show the output message in `txtOut`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Think about how we might accomplish each of those steps. Try it yourself before
    reading further and then read below to see how my solution compares.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first step, we can set up a `String` called `message` that gets the
    text from the `txtIn` field. Just like a `JTextField`, a `JTextArea` has a `getText()`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second step, we can get the user’s key from `txtKey` using the `Integer.parseInt()`
    method, which pulls an integer value out of a text string. Then we’ll store the
    integer we get in a variable we’ll call `key`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To encode the message in the third step, we just need to call the `encode()`
    method and pass it two arguments. *Arguments* are the values we give a method
    to serve as its parameters. Remember we defined `encode()` to require two parameters,
    so we’ll need to pass `encode()` two arguments, which will be the variables `message`
    and `key`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call `encode()` with the statement `encode(message, key)`. When it has
    finished executing, it will return the encoded message, which is `output`. Note
    that a method returns the value itself, not the variable the value is stored in.
    That means that the encoded message is stored in `output`, but when `encode()`
    returns `output`, we’re actually getting only the encoded string. In addition
    to that, all the code and variables created inside `encode()` aren’t carried over
    to the rest of the program, so the `output` variable doesn’t exist anymore once
    `encode()` returns. We’ll need to store the value returned by the method in a
    new variable if we want to save it. In order to keep our naming consistent, let’s
    call the new variable `output` too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: String output = encode( message, key );
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll use the `setText()` method to show the `output` message in `txtOut`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: String output = encode( message, key );
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: txtOut.setText( output );
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The `actionPerformed()` method is almost complete, except for some error handling.
    We’ve used the `Integer.parseInt()` method, which can throw exceptions if the
    user enters bad input, so we’ll need to add `try-catch` statements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*Handling Bad Input and User Errors*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code to process button clicks includes a call to `Integer.parseInt()`, and
    we learned back in [Chapter 3](ch3.xhtml#ch3) that this method can throw exceptions
    when the user enters erroneous input. In particular, if the user were to leave
    the `txtKey` field blank or type anything other than an integer into that `JTextField`,
    the `Integer.parseInt()` method would fail.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to protect the program from bad input by using `try-catch` blocks to
    handle exceptions. Since we want to encode or decode a message only when the user
    has correctly entered an encryption key, we can wrap all four lines of `actionPerformed()`
    inside a `try` block by adding the keyword `try` and an opening brace before the
    first line, as well as a closing brace after the fourth line, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: try {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.*parseInt*( txtKey.getText() );
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: String output = encode( message, key );
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: txtOut.setText( output );
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex) {'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse will highlight the closing brace in red, so let’s go ahead and add the
    `catch` block as shown. We’ll need to tell Java what to do when bad input is received,
    and we’ll add those steps inside the braces for the `catch` statement a little
    later. But first, let’s finish the `main()` method so that we can test the app.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the main() Method and Running the App*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like when we created our game app in [Chapter 3](ch3.xhtml#ch3), we need
    to add some setup code to the `main()` method to create an instance of the Secret
    Messages app, correctly size the GUI window, and make the GUI visible to the user.
    Near the bottom of the *SecretMessagesGUI.java* file, find the `main()` method
    stub Eclipse provided and add the following three lines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ➊ SecretMessagesGUI theApp = new SecretMessagesGUI();
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: ➋ theApp.setSize(new java.awt.Dimension(600,400));
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: ➌ theApp.setVisible(true);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ creates a `SecretMessagesGUI` object called `theApp`. The `new`
    keyword followed by the class name runs the constructor method `SecretMessagesGUI()`,
    which sets up all the components of the GUI interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the size of the `JFrame` to match the width and height that we
    used in designing the layout, 600 by 400 pixels ➋. Finally, we set the `JFrame`’s
    `visible` property to `true` ➌, allowing the user to see the GUI. Save these changes
    and then run the app to test it, as shown in [Figure 7-7](ch7.xhtml#ch7fig7).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0157-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: The Secret Messages app is still a bit plain, but it can encode
    and decode messages!*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the full source code for *SecretMessagesGUI.java* to this
    point:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: import javax.swing.JFrame;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: import javax.swing.JTextArea;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: import javax.swing.JTextField;
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: import javax.swing.JLabel;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: import javax.swing.JButton;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: import java.awt.event.ActionListener;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: import java.awt.Dimension;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: import java.awt.event.ActionEvent;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: private JTextField txtKey;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtIn;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtOut;
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: public String encode( String message, int keyVal ) {
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: char key = (char) keyVal;
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'Z')
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'A')
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'a')
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: input += (keyVal % 10);
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: if (input > '9')
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: input -= 10;
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: if (input < '0')
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: input += 10;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: return output;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: public SecretMessagesGUI() {
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: setTitle("Dr. Payne's Secret Message App");
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: setDefaultCloseOperation(JFrame.*EXIT_ON_CLOSE*);
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().setLayout(null);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: txtIn = new JTextArea();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: txtIn.setBounds(10, 11, 564, 140);
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().add(txtIn);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: txtOut = new JTextArea();
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: txtOut.setBounds(10, 210, 564, 140);
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().add(txtOut);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: txtKey = new JTextField();
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: txtKey.setBounds(258, 173, 44, 20);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().add(txtKey);
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: JLabel lblKey = new JLabel("Key:");
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: lblKey.setBounds(202, 176, 46, 14);
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().add(lblKey);
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: JButton btnEncodedecode = new JButton("Encode/Decode");
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: try {
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.*parseInt*( txtKey.getText() );
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: String output = encode( message, key );
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: txtOut.setText( output );
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex) {'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: btnEncodedecode.setBounds(312, 172, 144, 23);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: getContentPane().add(btnEncodedecode);
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: SecretMessagesGUI theApp = new SecretMessagesGUI();
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: theApp.setSize(new java.awt.Dimension(600,400));
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: theApp.setVisible(true);
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This first version of the app is a success, but it leaves a bit to be desired
    visually. We can make the GUI interface look more professional with just a few
    tweaks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Improving the GUI
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s switch back to the design view to correct the issues we noted in the last
    section. First, click the **Encode/Decode** button and make it a bit wider. Different
    computers can have other default fonts and sizes, so give the button a little
    extra room to be safe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s make the font sizes in the two `JTextArea` fields larger and easier
    to read. We want to change the font properties of both text areas, so we can select
    both `txtIn` and `txtOut` at the same time by clicking `txtIn` and then using
    CTRL-click (or ![Images](../images/symbol.jpg)-click) to also select `txtOut`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: With both text areas selected, go to the `font` property in the Properties pane
    and click the three dots next to the font size. The Font Chooser dialog will appear,
    as shown in [Figure 7-8](ch7.xhtml#ch7fig8).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0159-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: We can change the font properties for both JTextArea fields at
    the same time.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Choose a font size of 18 or greater and select a font that you like. Stick with
    a familiar font so that when you share the app with friends on different computers,
    the look and feel won’t change too dramatically. I’ve selected Lucida Console,
    18 point. Click **OK** to save the font selection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s change the background color of the content pane to personalize
    it. Select the content pane by clicking **getContentPane()** in the Components
    pane in the upper left. Then, click the three dots beside the `background` property
    in the Properties pane. In the Color Chooser dialog that pops up, select the **Named
    colors** tab, as shown in [Figure 7-9](ch7.xhtml#ch7fig9). You’ll see a broad
    selection of colors. Choose a color that you like and click **OK**.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0160-01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Change the background color of the content pane and button to
    make the app more stylish.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: You can also change the background color of the Encode/Decode button. You may
    not see all your changes in the design preview, but if you run the app, you should
    see your new selections, as shown in [Figure 7-10](ch7.xhtml#ch7fig10), along
    with any new background color you chose.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0161-01.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: The GUI after you change the button size and font size.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of other properties you can customize based on your preference.
    Explore the Properties pane for each component and adjust things until the app
    looks how you want it. Remember to stop and save your app so your changes don’t
    get erased!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '*Setting Line Wrap and Word Wrap*'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, the messages I’ve used in my examples have been shorter than one line.
    But what happens if we type several lines of text?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try typing or pasting a long sentence into the input text area. I’ll
    use the first sentence of the Gettysburg Address, by US president Abraham Lincoln:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Four score and seven years ago our fathers brought forth on this continent,
    a new nation, conceived in Liberty, and dedicated to the proposition that all
    men are created equal.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You can use this sentence or make up your own long sentence. Either way, as
    soon as you type it in, you’ll notice a problem, as shown in [Figure 7-11](ch7.xhtml#ch7fig11).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0161-02.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Longer messages in the app don’t yet automatically wrap at the
    end of a line.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: To correctly wrap longer lines of text by full words, you’ll need to change
    *two* properties for each text area in the Properties pane. Select both `JTextArea`
    objects again in the design preview and then, under Properties, select the checkboxes
    next to `lineWrap` and `wrapStyleWord`. The first property, `lineWrap`, tells
    Java to wrap text longer than one line down to the next line. Setting the wrap
    style to `wrapStyleWord` tells Java to break the line at the end of a whole word,
    as we do in a word processor or as you see in this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Now save and run the app again. Paste your long sentence into the first text
    box, and you should notice an improvement. Now the text is correctly wrapped across
    multiple lines, with line breaks after the last full word that fits on each line.
    Enter a key and press the **Encode/Decode** button, and you’ll see the same text
    wrapping in the output text area, as shown in [Figure 7-12](ch7.xhtml#ch7fig12).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0162-01.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Changing both the lineWrap and wrapStyleWord properties to true
    results in a nice multiline interface, complete with word wrapping.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: This version of the program is becoming more professional looking, but what
    happens if we enter bad input in the text field for the encryption key? Well,
    nothing yet. We added a `try` statement earlier, but we didn’t complete the `catch`
    statement. Let’s do that now. We’ll also learn how to create pop-up message dialogs
    to alert the user to errors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Handling Bad Input and User Errors: Part 2*'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier in the chapter, we added a `try` block around the button event handler,
    but we left the body of the `catch` statement empty. It’s time to fill that in
    with code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Our `catch` statement will handle bad or missing user input in the `txtKey`
    text field. If the user forgets to enter a value for the encryption key or if
    the value they entered is not a number, one way of handling that is to pop up
    a message describing the problem, like the one shown in [Figure 7-13](ch7.xhtml#ch7fig13).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0163-01.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: A dialog pops up to alert the user to an error.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: After the user closes the pop-up window, another helpful touch is to move the
    cursor to the `txtKey` text field and highlight or select any text there so the
    user can type a new value easily, without needing to click and select the value
    manually.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.swing` toolkit that we’ve been using for GUI components such as `JFrame`
    and `JTextField` also has classes that handle various kinds of pop-up windows.
    Some examples are *input dialogs*, which allow the user to provide text input;
    *confirm dialogs*, which allow the user to select Yes/No/OK or Cancel; and *message
    dialogs*, which provide information to the user in a pop-up window.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message we’d like to provide to the user is best displayed in a message
    dialog. The `javax.swing.JOptionPane` class has a method called `showMessageDialog()`
    that takes two parameters, which are the parent window and the message to display.
    If we were writing a larger application, we would use the parent window parameter
    to center the dialog over the main word processing window, for example. But for
    this app, we can use the keyword `null` to center the dialog over the desktop
    instead, as shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: JOptionPane.showMessageDialog(null,
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '"Please enter a whole number value for the encryption key.");'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: When this line of code is called, it will pop up a message dialog reading “Please
    enter a whole number value for the encryption key.”
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: To add this pop-up error message to the `catch` statement we created earlier,
    go to the design view and double-click the **Encode/Decode** button. This is a
    quick way to have Eclipse take you directly to the source code for the button-click
    event handler that contains the `catch` statement.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'After the error message is displayed, we’ll also want to place the cursor in
    the `txtKey` field and select any text currently in the `txtKey` field, as we
    did for the Hi-Lo guessing game GUI app. We’ll add the message dialog and the
    same `requestFocus()` and `selectAll()` statements we used in the Hi-Lo guessing
    game app inside the braces for the `catch` statement. The finished event handler
    code for the Encode/Decode button looks like the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: btnEncodedecode.addActionListener(new ActionListener() {
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: try {
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: String message = txtIn.getText();
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: int key = Integer.parseInt( txtKey.getText() );
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: String output = encode( message, key );
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: txtOut.setText( output );
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception ex) {'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: JOptionPane.*showMessageDialog*(null,
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '"Please enter a whole number value for the encryption key.");'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: txtKey.requestFocus();
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: txtKey.selectAll();
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '*When you add JOptionPane, if you don’t use the content assist or if you see
    an error at JOptionPane, you may need to press ctrl-shift-O to import the javax.swing
    .JOptionPane class correctly at the top of your code.*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Run the app now, either leaving the key field blank or entering nonnumeric text
    as the key. The message dialog will pop up, asking you to enter a valid key. It
    will also highlight the text in the key field so that it’s easy to type a whole
    number when the dialog closes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: A first-time user might not know what to type into the key field, so adding
    a default value might also be a helpful UI tweak. Click the Design tab, select
    the `txtKey` text field, and enter a default key value into the `text` property
    in the Properties pane. I’ll choose `3` as my default encryption key, but you
    can choose any number. Let’s also change the `horizontalAlignment` property of
    the `txtKey` field to **CENTER**. Feel free to change other properties to make
    `txtKey` look exactly like you want, including the font color and style.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding a Slider to the Secret Messages GUI*'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll add one more user interface improvement to the Secret Messages app—a numeric
    slider that will allow the user to quickly slide through key values and see how
    the message changes with each new key.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In design view, under Components in the Palette, select the **JSlider** component.
    Hover over the middle left of the design preview, beside the key prompt, and click
    to drop the `JSlider` into place as shown in [Figure 7-14](ch7.xhtml#ch7fig14)—you
    can adjust the position later if needed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0165-01.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Add a JSlider to the graphical user interface for a quick, easy
    way to try different key values.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s customize some properties of the `JSlider`. First, let’s change its
    background color to match the rest of the app. With the new `JSlider` selected
    in the design preview, click the three dots next to the `background` property
    in the Properties pane, go to **Named colors** in the Color Chooser dialog, and
    pick the same color you used for the rest of the GUI. Click **OK** to save the
    new background color for the slider.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add custom labels, tick marks, and a default value for the slider.
    First, turn on the `paintLabels` property by selecting the **true** checkbox beside
    it. Second, enter a `maximum` value of `26` and a `minimum` value of `–26` to
    make it easy to choose a key value in the correct range.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the `minorTickSpacing` property, enter a value of `1`—this will add
    small tick marks on the slider track to help the user see the range of possible
    values. Then, for the `majorTickSpacing` property, enter `13`—this will show a
    label every 13 values between `-26` and `26` on the slider. Now, turn on the `paintTicks`
    property by selecting the **true** checkbox next to it. The complete Properties
    pane with all the changes we’ve made is shown in [Figure 7-15](ch7.xhtml#ch7fig15).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0165-02.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Customizing the properties of the slider*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done! Change the default value of the slider to match your default
    key value in the key text field by modifying the `value` property. I selected
    `3` as my default key value, so I’ll enter `3` in the `value` property for the
    slider. Finally, you’ll need to make the slider a bit taller to show the labels,
    as shown in the finished slider in [Figure 7-16](ch7.xhtml#ch7fig16).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0166-01.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: The Secret Messages app with the GUI slider in place*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add the code to make the slider work, allowing the user to slide
    easily among various key values to encode and decode messages quickly.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Code Cracking with the Slider
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want the user to be able to change the encryption key value by clicking and
    dragging the slider we added in the previous section, so next we’re going to add
    an event handler to listen for changes to the slider.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Right-click or CONTROL-click the slider in the design preview and go to **Add
    event handler** ▸ **change** ▸ **stateChanged**, as shown in [Figure 7-17](ch7.xhtml#ch7fig17).
    The `stateChanged` event handler will work similarly to the `actionPerformed`
    event handler for the Encode/Decode button, but it will run anytime the user changes
    the slider’s position to update the encryption key value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0166-02.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: Adding an event handler to the slider that will detect when the
    user changes the slider’s value*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click to add the `stateChanged` event handler to the slider, Eclipse
    will automatically generate another anonymous inner class, much like the one it
    created for the Encode/Decode button. But before we check out the anonymous inner
    class, we’ll need to add the `JSlider` to the top of the class with the `JTextArea`
    declarations. To do that, we have to declare the `JSlider` as an instance variable.
    Add the last line shown here to the declarations at the top of the `SecretMessagesGUI`
    class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessagesGUI extends JFrame {
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: private JTextField txtKey;
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtIn;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: private JTextArea txtOut;
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: private JSlider slider;
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, scroll back down to the slider code. Remember, you can switch back to
    design view and right-click to add the event handler again to go directly to the
    code anytime you get lost. Now, change the first line, removing the `JSlider`
    type declaration, as shown here:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: slider = new JSlider();
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The first action we’d like the slider to do is update the `txtKey` text field
    to show the slider’s current position. We can get the slider’s current position
    with the `getValue()` method, and we can set the text of the `txtKey` field with
    its `setText()` method. Adding those together, we can write the first line of
    the `stateChanged()` method:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: txtKey.setText( "" + slider.getValue() );
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The `slider.getValue()` method returns an integer—the current position value
    of the slider—so we added an empty string to the number to turn it into a string
    or text value. This will change the `txtKey` text field to show the slider’s value.
    But it doesn’t automatically re-encode the message using the new value yet. If
    you run the app now, you still need to click the Encode/Decode button to change
    the message.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the code in the `stateChanged()` method so that the slider updates
    the message like the Encode/Decode button would. We can copy the code from inside
    the `try` statement for the Encode/Decode button and paste it after the first
    line of the `stateChanged()` method for the slider, making only one change:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: slider = new JSlider();
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: txtKey.setText( "" + slider.getValue() );
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: ➊  String message = txtIn.getText();
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: ➋  int key = slider.getValue();
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: ➌  String output = encode( message, key );
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: ➍  txtOut.setText( output );
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➊, ➌, and ➍ are copied directly from the Encode/Decode button’s
    event handler, but we’ve made a small change at ➋. Instead of parsing the value
    out of the text field, we can access the slider’s value directly as an integer
    using the `getValue()` method. This means we don’t need a `try-catch` statement,
    because we’re no longer relying on the user to supply a hand-typed value. This
    is more convenient for the user and more secure for the programmer, as using the
    GUI slider removes one potential error while also making the interface easier
    to use.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes and run the application, and you’ll see that you can type in
    a message and then change the position of the slider to try different encryption
    key values. To test the ability to decode, copy an encoded message from the bottom
    text area using CTRL-C (or ![Image](../images/symbol.jpg)-C) and paste it into
    the top text area using CTRL-V (or ![Image](../images/symbol.jpg)-V). Then slide
    the slider to the left or right until you see the original message again.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll even be able to “crack” the Caesar cipher encryption for messages that
    you don’t have the key to by sliding the slider slowly until you can read the
    decoded message in the bottom text area. Give it a try! Type the following message
    into the top text area of your app:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Epdetyr esp lmtwtej ez mcplv esp Nlpdlc ntaspc htes xj Dpncpe Xpddlrp laa...
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Then, slide the slider to the far left and slowly slide it to the right until
    it reveals the secret message. Can you tell what secret key was used to encode
    the message? See [Figure 7-18](ch7.xhtml#ch7fig18) for a hint.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0168-01.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: You can use the Secret Messages app to break Caesar cipher messages
    by sliding the slider left and right until a plaintext message appears!*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Moving the slider to `-11` results in a plaintext English message, so the secret
    key must have been `11`. You may also notice that `15` will break the message
    (because 15 = 26 – 11). You can always find a couple of values that work to break
    messages in the basic Latin alphabet. Of course, you can send messages in other
    languages as well, as shown in [Figure 7-19](ch7.xhtml#ch7fig19).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0169-01.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Any languages that use characters in the basic Latin alphabet
    can be used with this version of the Secret Messages app to send and receive encoded
    messages; Spanish (left) and French (right) are shown here.*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: You can copy and paste encoded messages back and forth with your friends using
    email, Twitter, and Facebook—you can even send encoded text messages, although
    that would be easier to do from your mobile device. We’ll see how to turn this
    Secret Messages desktop app into a mobile app in [Chapter 8](ch8.xhtml#ch8).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: For now, in order to share secret messages back and forth, it would be nice
    to be able to share your Secret Messages app with your friends easily. We’ll learn
    to do that in the following section.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus: Sharing Your App as a Runnable JAR File'
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For it to be really useful, you need to be able to share the Secret Messages
    app with your friends—possibly even with friends who don’t know how to code in
    Java and don’t have Eclipse installed on their computer.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The great news is that Eclipse and Java make it easy to export an application
    as a runnable file and share it with any of the millions of computers worldwide
    that run Java. Your friends don’t even have to download the Java JDK developer’s
    edition; all they need is the JRE, which comes installed on most computers. Eclipse
    can export an application in a runnable Java archive (JAR) file that you can share
    by email, USB flash drive, or some other means. All your friends have to do is
    double-click the JAR file, and they’ll be able to run your app!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: To export a runnable JAR file from Eclipse, go to **File** ▸ **Export**. Then
    expand the *Java* folder and click **Runnable JAR file**, as shown in [Figure
    7-20](ch7.xhtml#ch7fig20).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0170-01.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: Share your application with others by exporting a runnable JAR
    file.*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**, and Eclipse will ask you for a launch configuration and an export
    destination. The launch configuration means which class or app you’d like to run
    and from which project. Under **Launch configuration**, click the drop-down list
    and choose **SecretMessagesGUI – SecretMessagesGUI**. This means you want to run
    the *SecretMessagesGUI.class* file in the *SecretMessagesGUI* project.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '*You have to compile and run your application at least once to have a launch
    configuration for that app.*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The export destination is just the location and filename you want to use for
    your executable app. Under **Export destination**, click **Browse** and then select
    the destination folder you’d like to save your finished app in, such as your *Desktop*
    folder, for example. Give your program file a name, like *Secret Messages.jar*.
    You can use spaces (or other special characters) to name your file exactly how
    you’d like people to see it when they open it. When you’ve made your selections,
    as shown in [Figure 7-21](ch7.xhtml#ch7fig21), click **Save** and then **Finish**.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0171-01.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: Choose a location and name for your runnable JAR file.*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: You may see a warning after clicking Finish, but you can ignore it and click
    **OK**. Go to wherever you saved your JAR file, and you should see a Java icon
    with your filename, as shown in [Figure 7-22](ch7.xhtml#ch7fig22). Now you should
    be able to run the program and send and receive coded messages.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0171-02.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: The desktop icon for the executable JAR file, on Windows (left)
    and on macOS (right)*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '*On newer versions of macOS, you’ll need to hold down CONTROL when you click
    the app the first time, then select **Open**, and finally click **Open** on the
    dialog that pops up to allow the app to run.*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Some email programs may block files ending in *.jar* as a safety precaution,
    but you can upload the file to your favorite file-sharing program (Dropbox, Google
    Drive, or SkyDrive, for example) and share the file from there. Once your friend
    has the file, all they have to do is run it, and you can share scrambled messages
    with each other.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also export a runnable JAR file for the GUI guessing game app from
    Chapter 3\. Just follow these same steps for the* GuessingGame.java *file in the*
    GuessingGame *project.*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You reused code from the text-based Secret Messages app in this app, and you
    substantially expanded your understanding of GUI interface design and programming.
    Here are some of the skills covered in this chapter:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: • Naming GUI components and variables consistently for code readability and
    reusability
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: • Reusing algorithms, such as the `encode()` method that we copied from the
    text-based version of this app
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: • Declaring methods that accept parameters and return information
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: • Writing more advanced event handlers for a wider variety of GUI components,
    including buttons, sliders, and text fields
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: • Working with properties of GUI components in design view to customize the
    UI further
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: • Setting line wrap and word wrap for `JTextArea` objects
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: • Popping up `javax.swing.JOptionPane` dialogs, including message dialogs
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: • Adding and working with a `JSlider` GUI slider
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: • Changing a text field’s text using a `stateChanged()` event handler on a slider
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: • Exporting a runnable JAR file to share your app with friends
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Programming Challenges
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these programming challenges to review and practice what you’ve learned
    and to expand your programming skills by trying something new. Visit the book’s
    website at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '*#1: Movin’ On Up!*'
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Secret Messages app is great for sending simple, encoded messages to your
    friends, but it’s also fun to use all by yourself. One task that gets repetitive
    from time to time is copying encoded messages from the output text area and pasting
    them into the input text area. Your first programming challenge is to create a
    Move Up ^ button, which moves the encoded message up and automatically decodes
    it!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Place the Move Up ^ button next to the Encode/Decode button. Then, add an event
    handler that will get the text from the `txtOut` text area and set it as the text
    of the `txtIn` text area. As a bonus, have the event handler for the Move Up ^
    button change the slider to the opposite of its value. You can also change the
    background of the button to match the rest of your app. A sample solution to this
    challenge is shown in [Figure 7-23](ch7.xhtml#ch7fig23).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0173-01.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-23: Adding a Move Up ^ button to swap the message and slider value
    to automatically decode your message*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '*#2: Scrolling Away!*'
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another improvement we could make to the app would be to handle even longer
    messages. In this case, we should add a scroll bar along the side and scroll down
    automatically whenever the user enters a message too long for the input text area.
    The `JTextArea` won’t add a scroll bar by itself, but Eclipse makes adding a scroll
    bar to any text area quick and easy!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In the design view, right-click either of the `JTextArea` boxes and select **Surround
    with** ▸ **javax.swing.JScrollPane**, as shown in [Figure 7-24](ch7.xhtml#ch7fig24).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0173-02.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-24: Adding an automatic scroll bar to a JTextArea*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to do this for the other `JTextArea` as well. Run the app when you’re
    finished, typing a long selection of text into the input text box to see the scroll
    bar appear automatically. In [Figure 7-25](ch7.xhtml#ch7fig25), I’ve pasted the
    entire US Constitution into the input text area and encoded it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0174-01.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-25: By adding a JScrollPane around each JTextArea, you can encode
    text as long as the US Constitution or even longer!*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Only part of the text is visible in [Figure 7-25](ch7.xhtml#ch7fig25), but now
    there is a scroll bar along the right side of both text areas. The scroll bar
    lets us know that there’s more text than will fit into the text area, and all
    we have to do is scroll down to see it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: To customize the app even more, explore the Properties pane for each of the
    GUI components we’ve added and change various property values such as background
    colors, fonts, and so on. Make the app your own and share it with friends to show
    off what you’ve created!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '*#3: Changing the Text to Change the Slider*'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this challenge, let’s make one last tweak to the user interface. When the
    user slides the slider, the key value shown in the text field changes. But what
    if we want the slider to move whenever the value in the text field changes?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll want to add an event handler to the txtKey text field. Right-click
    the txtKey JTextField and then go to **Add event handler*** ▸ ***key*** ▸ ***keyReleased***.
    *This will create an event handler that listens for keystrokes in the txtKey text
    field.*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, you’ll need to write code for the event handler that will
    get the integer value from the text field and set the slider to that value. Remember
    to use a `try-catch` block when dealing with user-supplied text. Good luck!
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
