<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="37" id="Page_37"/><a class="XrefDestination" id="4"/><span class="XrefDestination" id="xref-503007c04-001"/>4</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="MySQLDataTypes"/><span class="XrefDestination" id="xref-503007c04-002"/>MySQL Data Types</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll look at all of the available MySQL data types. You’ve already seen that <code>int</code> and <code>varchar</code> can be used for integer and character data, but MySQL also has data types to store dates, times, and even binary data. You’ll explore how to choose the best data types for your columns and the pros and cons of each type.</p>
<p>When you create a table, you define each column’s data type based on the kind of data you’ll store in that column. For example, you wouldn’t use a data type that allows only numbers for a column that stores names. You might additionally consider the range of values that the column will have to accommodate. If a column needs to store a value like 3.1415, you should use a data type that allows decimal values with four positions after the decimal point. Lastly, if more than one data type can handle the values your column will need to store, you should choose the one that uses the least amount of storage.</p>
<p>Say you want to create a table, <code>solar_eclipse</code>, that includes data about solar eclipses, including the date of the eclipse, the time it occurs, the type of eclipse, and its magnitude. Your raw data might look like <a href="#table4-1" id="tableanchor4-1">Table 4-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><span epub:type="pagebreak" title="38" id="Page_38"/><a id="table4-1" href="#tableanchor4-1">Table 4-1</a>: Data on Solar Eclipses</p></figcaption>
<table id="table-503007c04-0001" border="1">
<thead>
<tr>
<td><b>Eclipse date</b></td>
<td><b>Time of greatest eclipse</b></td>
<td><b>Eclipse type</b></td>
<td><b>Magnitude</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>2022-04-30    </td>
<td>20:42:36                  </td>
<td>Partial</td>
<td>0.640</td>
</tr>
<tr>
<td>2022-10-25    </td>
<td>11:01:20                  </td>
<td>Partial</td>
<td>0.862</td>
</tr>
<tr>
<td>2023-04-20    </td>
<td>04:17:56                  </td>
<td>Hybrid</td>
<td>1.013</td>
</tr>
</tbody>
</table>
</figure>
<p>In order to store this data in a MySQL database, you’ll create a table with four columns:</p>
<pre><code>create table solar_eclipse
(
    eclipse_date                date,
    time_of_greatest_eclipse    time,
    eclipse_type                varchar(10),
    magnitude                   decimal(4,3)
);</code></pre>
<p>In this table, each of the four columns has been defined with a different data type. Since the <code>eclipse_date</code> column will store dates, you use the <code>date</code> data type. The <code>time</code> data type, which is designed to store time data, is applied to the <code>time_of_greatest_eclipse</code> column.</p>
<p>For the <code>eclipse_type</code> column, you use the <code>varchar</code> data type because you need to store variable-length character data. You don’t expect these values to be long, so you use <code>varchar(10)</code> to set the maximum number of characters to 10.</p>
<p>For the <code>magnitude</code> column, you use the <code>decimal</code> data type and specify that the values will have four digits total and three digits after the decimal point.</p>
<p>Let’s look at these and several other data types in more depth, and explore when it’s appropriate to use each one.</p>
<h2 id="h1-503007c04-0001"><a class="XrefDestination" id="StringDataTypes"/><span class="XrefDestination" id="xref-503007c04-003"/>String Data Types</h2>
<p class="BodyFirst">A <em>string</em> is a set of characters, including letters, numbers, whitespace characters like spaces and tabs, and symbols like punctuation marks. For values that include only numbers, you should use a numeric data type rather than a string data type. You would use a string data type for a value like <code>I love MySQL 8.0!</code> but a numeric data type for a value like <code>8.0</code>.</p>
<p>This section will examine MySQL’s string data types.</p>
<h3 id="h2-503007c04-0001"><a class="XrefDestination" id="char"/><span class="XrefDestination" id="xref-503007c04-004"/>char</h3>
<p class="BodyFirst">The <code>char</code> data type is used for <em>fixed-length</em> strings—that is, strings that hold an exact number of characters. To define a column within a <code>country_code</code> table to store three-letter country codes like <code>USA</code>, <code>GBR</code>, and <code>JPN</code>, use <code>char(3)</code>, like so:</p>
<pre><code>create table country_code
(
    country_code    <b>char(3)</b>
);</code></pre>
<p><span epub:type="pagebreak" title="39" id="Page_39"/>When defining columns with the <code>char</code> data type, you specify the length of the string inside the parentheses. The <code>char</code> data type defaults to one character if you leave out the parentheses, though in cases where you want only one character, it’s clearer to specify <code>char(1)</code> than just <code>char</code>.</p>
<p>The length of the string cannot exceed the length defined within the parentheses. If you tried to insert <code>JAPAN</code> into the <code>country_code</code> column, MySQL would reject the value because the column has been defined to store a maximum of three characters. However, MySQL will allow you to insert a string with fewer than three characters, such as <code>JP</code>; it simply adds a space to the end of <code>JP</code> and saves the value in the column.</p>
<p>You can define a <code>char</code> data type with up to 255 characters. If you try to define a column with a data type of <code>char(256)</code> you’ll get an error message because it’s out of <code>char</code>’s range.</p>
<h3 id="h2-503007c04-0002"><a class="XrefDestination" id="varchar"/><span class="XrefDestination" id="xref-503007c04-005"/>varchar</h3>
<p class="BodyFirst">The <code>varchar</code> data type, which you’ve seen before, is for <em>variable-length</em> strings, or strings that can hold <em>up to</em> a specified number of characters. It’s useful when you need to store strings but aren’t sure exactly how long they will be. For example, to create an <code>interesting_people</code> table and then define a column called <code>interesting_name</code> that stores various names, you need to be able to accommodate short names like <code>Jet Li</code> as well as long names like <code>Hubert Blaine Wolfeschlegelsteinhausenbergerdorff</code>:</p>
<pre><code>create table interesting_people
(
    interesting_name    <b>varchar(100)</b>
);</code></pre>
<p>In the parentheses, you define a character limit of 100 for the <code>interesting_name</code> column because you don’t anticipate that anybody’s name in the database will be over 100 characters.</p>
<p>The number of characters that <code>varchar</code> can accept depends on your MySQL configuration. Your database administrator (DBA) can help you, or you can use this quick hack to determine your maximum. Write a <code>create table</code> statement with a column that has an absurdly long <code>varchar</code> maximum value:</p>
<pre><code>create table test_varchar_size
(
    huge_column <b>varchar(999999999)</b>
);</code></pre>
<p>The <code>create table</code> statement will fail, giving you an error message like</p>
<pre><code>Error Code: 1074. Column length too big for column 'huge_column'
(max = 16383);
use BLOB or TEXT instead</code></pre>
<p>The table was not created because the <code>varchar</code> definition was too large, but the error message told you that the maximum number of characters that <code>varchar</code> can accept in this environment is 16,383, or <code>varchar(16383)</code>.</p>
<p><span epub:type="pagebreak" title="40" id="Page_40"/>The <code>varchar</code> data type is mostly used for small strings. When you’re storing more than 5,000 characters, I recommend using the <code>text</code> data type instead (we’ll get to it momentarily).</p>
<h3 id="h2-503007c04-0003"><a class="XrefDestination" id="enum"/><span class="XrefDestination" id="xref-503007c04-006"/>enum</h3>
<p class="BodyFirst">The <code>enum</code> data type, short for <em>enumeration</em>, lets you create a list of values that you want to allow in a string column. Here’s how to create a table called <code>student</code> with a <code>student_class</code> column that can accept only one of the following values—<code>Freshman</code>, <code>Sophomore</code>, <code>Junior</code>, or <code>Senior</code>:</p>
<pre><code>create table student
    (
    student_id     int,
    student_class  <b>enum('Freshman','Sophomore','Junior','Senior')</b>
    );</code></pre>
<p>If you try to add a value to the column other than the ones in the list of permitted values, it will be rejected. You can add only one of the permitted values to the <code>student_class</code> column; a student can’t be both a freshman and a sophomore.</p>
<h3 id="h2-503007c04-0004"><a class="XrefDestination" id="set"/><span class="XrefDestination" id="xref-503007c04-007"/>set</h3>
<p class="BodyFirst">The <code>set</code> data type is similar to the <code>enum</code> data type, but <code>set</code> allows you to select multiple values. In the following <code>create table</code> statement, you define a list of languages for a <code>language_spoken</code> column in a table called <code>interpreter</code>:</p>
<pre><code>create table interpreter
    (
    interpreter_id     int,
    language_spoken    <b>set('English','German','French','Spanish')</b>
    );</code></pre>
<p>The <code>set</code> data type allows you to add any or all of the languages in the set to the <code>language_spoken</code> column, as someone might speak one or more of these languages. If you try to add any value to the column other than the ones in the list, however, they will be rejected.</p>
<h3 id="h2-503007c04-0005"><a class="XrefDestination" id="tinytext,text,mediumtext,andlongtext"/><span class="XrefDestination" id="xref-503007c04-008"/>tinytext, text, mediumtext, and longtext</h3>
<p class="BodyFirst">MySQL includes four text data types that store variable-length strings:</p>
<table id="tabular-503007c04-0002" border="1" class="TabularList">
<tbody>
<tr>
<td><code class="bold">tinytext</code></td>
<td>Stores up to 255 characters</td>
</tr>
<tr>
<td><code class="bold"><code>text</code></code></td>
<td>Stores up to 65,535 characters, which is approximately 64KB</td>
</tr>
<tr>
<td><code class="bold">mediumtext</code></td>
<td>Stores up to 16,777,215 characters, approximately 16MB</td>
</tr>
<tr>
<td><code class="bold">longtext</code></td>
<td>Stores up to 4,294,967,295 characters, approximately 4GB</td>
</tr>
</tbody>
</table>
<p><span epub:type="pagebreak" title="41" id="Page_41"/>The following <code>create table</code> statement creates a table named <code>book</code> that contains four columns. The last three columns, <code>author_bio</code>, <code>book_proposal</code>, and <code>entire_book</code>, all use text data types of different sizes:</p>
<pre><code>create table book
    (
    book_id            int,
    author_bio         tinytext,
    book_proposal      text,
    entire_book        mediumtext
    );</code></pre>
<p>You use the <code>tinytext</code> data type for the <code>author_bio</code> column because you don’t anticipate any author biographies larger than 255 characters. This also forces users to make sure their bios have fewer than 255 characters. You choose the <code>text</code> data type for the <code>book_proposal</code> column because you aren’t expecting any book proposals of over 64KB. Finally, you choose the <code>mediumtext</code> data type for the <code>entire_book</code> column to limit the size of books to 16MB.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><a class="XrefDestination" id="StringFormatting"/><span class="XrefDestination" id="xref-503007c04-009"/>String Formatting</h2>
<p class="BoxBodyFirst">String values must be surrounded by single quotes or double quotes. The following query uses single quotes around the string <code>Town Supply</code>:</p>
<pre><code>select  *
from    store
where   store_name = <code class="bold">'Town Supply'</code>;</code></pre>
<p>This query uses double quotes:</p>
<pre><code>select  *
from    store
where   store_name = <code class="bold">"Town Supply"</code>;</code></pre>
<p>Both queries return the same values. Things get more interesting when you want to compare strings that have special characters in them, like apostrophes, quotes, or tabs. For example, using single quotes for <code>Town Supply</code> works fine, but using single quotes for the string <code>Bill's Supply</code></p>
<pre><code>select  *
from    store
where   store_name = <code class="bold">'Bill's Supply'</code>;</code></pre>
<p class="BoxBodyContinued">results in the following error:</p>
<pre><code>Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 's Supply'' at line 1</code></pre>
<p><span epub:type="pagebreak" title="42" id="Page_42"/>MySQL is confused because the single quotes at the beginning and the end of the string are the same character as the apostrophe in <code>Bill's</code>. It’s not clear whether the apostrophe is ending the string or part of the string.</p>
<p>You can work around the problem by surrounding the string in double quotes instead of single quotes:</p>
<pre><code>select  *
from    store
where   store_name = <code class="bold">"Bill's Supply"</code>;</code></pre>
<p class="BoxBodyContinued">Now MySQL knows that the apostrophe is part of the string.</p>
<p>You can also fix the error by surrounding the string in single quotes and <em>escaping</em> the apostrophe:</p>
<pre><code>select  *
from    store
where   store_name = <code class="bold">'Bill\'s Supply'</code>;</code></pre>
<p class="BoxBodyContinued">The backslash character is the escape character, and it creates an <em>escape sequence</em> that tells MySQL the next character is part of the string. There are other escape sequences available as well:</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>\"</code></span></span>  Double quote</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>\n</code></span></span>  Newline (linefeed)</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>\r</code></span></span>  Carriage return</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>\t</code></span></span>  Tab</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>\\</code></span></span>  Backslash</p>
<p>You can use escape sequences to add special characters to strings, like the double quotes around the nickname Kitty:</p>
<pre><code>select  *
from    accountant
where   accountant_name = <code class="bold">"Kathy \"Kitty\" McGillicuddy"</code>;</code></pre>
<p class="BoxBodyContinued">In this case you could also wrap the string in single quotes so you don’t have to escape the double quotes:</p>
<pre><code>select  *
from    accountant
where   accountant_name = <code class="bold">'Kathy "Kitty" McGillicuddy'</code>;</code></pre>
<p class="BoxBodyContinued">Either way, the result returned is <code>Kathy "Kitty" McGillicuddy</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c04-0002"><span epub:type="pagebreak" title="43" id="Page_43"/><a class="XrefDestination" id="BinaryDataTypes"/><span class="XrefDestination" id="xref-503007c04-010"/>Binary Data Types</h2>
<p class="BodyFirst">MySQL provides data types to store <em>binary</em> data, or raw data in byte format that is not human-readable.</p>
<h3 id="h2-503007c04-0006"><a class="XrefDestination" id="tinyblob,blob,mediumblob,longblob"/><span class="XrefDestination" id="xref-503007c04-011"/>tinyblob, blob, mediumblob, and longblob</h3>
<p class="BodyFirst">A <em>binary large object (BLOB)</em> is a variable-length string of bytes. You can use BLOBs to store binary data like images, PDF files, and videos. BLOB data types come in the same sizes as the text data types. While <code>tinytext</code> can store up to 255 characters, <code>tinyblob</code> can store up to 255 bytes.</p>
<table id="tabular-503007c04-0003" border="1" class="TabularList">
<tbody>
<tr>
<td><code class="bold">tinyblob</code></td>
<td>Stores up to 255 bytes</td>
</tr>
<tr>
<td><code class="bold"><code>blob</code></code></td>
<td>Stores up to 65,535 bytes, approximately 64KB</td>
</tr>
<tr>
<td><code class="bold">mediumblob</code></td>
<td>Stores up to 16,777,215 bytes, approximately 16MB</td>
</tr>
<tr>
<td><code class="bold">longblob</code></td>
<td>Stores up to 4,294,967,295 bytes, approximately 4GB</td>
</tr>
</tbody>
</table>
<h3 id="h2-503007c04-0007"><a class="XrefDestination" id="binary"/><span class="XrefDestination" id="xref-503007c04-012"/>binary</h3>
<p class="BodyFirst">The <code>binary</code> data type is for fixed-length binary data. It’s similar to the <code>char</code> data type, except that it’s used for strings of binary data rather than character strings. You specify the size of the byte string within the parentheses like so:</p>
<pre><code>create table encryption
    (
    key_id          int,
    encryption_key  <b>binary(50)</b>
    );</code></pre>
<p>For the column called <code>encryption_key</code> in the <code>encryption</code> table, you set the maximum size of the byte string to 50 bytes.</p>
<h3 id="h2-503007c04-0008"><a class="XrefDestination" id="varbinary"/><span class="XrefDestination" id="xref-503007c04-013"/>varbinary</h3>
<p class="BodyFirst">The <code>varbinary</code> data type is for variable-length binary data. You specify the maximum size of the byte string within the parentheses:</p>
<pre><code>create table signature
    (
    signature_id    int,
    signature       varbinary(400)
    );</code></pre>
<p>Here, you’re creating a column called <code>signature</code> (in a table of the same name) with a maximum size of 400 bytes.</p>
<h3 id="h2-503007c04-0009"><span epub:type="pagebreak" title="44" id="Page_44"/><a class="XrefDestination" id="bit"/><span class="XrefDestination" id="xref-503007c04-014"/>bit</h3>
<p class="BodyFirst">One of the lesser-used data types, <code>bit</code> is used for storing bit values. You can specify how many bits you want to store, up to a maximum of 64. A definition of <code>bit(15)</code> allows you to store up to 15 bits.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><a class="XrefDestination" id="StringsofCharactersvsStringsofBytes"/><span class="XrefDestination" id="xref-503007c04-015"/>Strings of Characters vs. Strings of Bytes</h2>
<p class="BoxBodyFirst">A <em>character string</em>, usually just called a <em>string</em>, is a human-readable set of characters. A <em>byte string</em>, on the other hand, is a string of bytes. Byte strings aren’t human-readable.</p>
<p>In the following table, named <code>animal</code>, the <code>animal_desc</code> column has been defined with the <code>tinytext</code> data type and the <code>animal_picture</code> column has been defined with the <code>mediumblob</code> data type:</p>
<pre><code>create table animal
    (
    animal_name     varchar(20),
    animal_desc     tinytext,
    animal_picture  mediumblob
    );</code></pre>
<p>Here is the result when you query the table using MySQL Workbench.</p>
<figure class="graphic"><img src="image_fi/503007c04/g04001.png" class="" alt="" width="488" height="270"/></figure>
<p>The contents of the <code>animal_desc</code> column are human-readable, but MySQL Workbench displays the contents of <code>animal_picture</code> as <code>BLOB</code> because that column value is set to a byte string format.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c04-0003"><a class="XrefDestination" id="NumericDataTypes"/><span class="XrefDestination" id="xref-503007c04-016"/>Numeric Data Types</h2>
<p class="BodyFirst">MySQL provides data types to store numbers of different sizes. The numeric type to use also depends upon whether the numbers you want to store contain decimal points.</p>
<h3 id="h2-503007c04-0010"><span epub:type="pagebreak" title="45" id="Page_45"/><a class="XrefDestination" id="tinyint,smallint,mediumint,int,andbigint"/><span class="XrefDestination" id="xref-503007c04-017"/>tinyint, smallint, mediumint, int, and bigint</h3>
<p class="BodyFirst">Integers are whole numbers without a fraction or decimal. Integer values can be positive, negative, or zero. MySQL includes the following integer data types:</p>
<table id="tabular-503007c04-0004" border="1" class="TabularList">
<tbody>
<tr>
<td><code class="bold">tinyint</code></td>
<td>Stores integer values that range from –128 to 127, or 1 byte of storage</td>
</tr>
<tr>
<td><code class="bold">smallint</code></td>
<td>Stores integer values ranging from –32,768 to 32,767, or 2 bytes of storage</td>
</tr>
<tr>
<td><code class="bold">mediumint</code></td>
<td>Stores integer values ranging from –8,388,608 to 8,388,607, or 3 bytes of storage</td>
</tr>
<tr>
<td><code class="bold">int</code></td>
<td>Stores integer values from –2,147,483,648 to 2,147,483,647, or 4 bytes of storage</td>
</tr>
<tr>
<td><code class="bold">bigint</code></td>
<td>Stores integer values that range from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, or 8 bytes of storage</td>
</tr>
</tbody>
</table>
<p>How do you know which integer type is right for your data? Take a look at the <code>planet_stat</code> table in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>.</p>
<pre><code>create table planet_stat
(
    planet            varchar(20),
    miles_from_earth  bigint,
    diameter_km       mediumint
);</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Creating a table on planet statistics</p>
<p>This table contains statistics about planets using <code>varchar(20)</code> to store the planet’s name, <code>bigint</code> to store its distance from Earth in miles, and <code>mediumint</code> for the planet’s diameter (in kilometers).</p>
<p>Looking at the results, you can see that Neptune is 2,703,959,966 miles from Earth. In this case, <code>bigint</code> is the appropriate choice for that column, as <code>int</code> wouldn’t have been large enough for that value.</p>
<pre><code>planet   miles_from_earth  diameter_km
-------  ----------------  -----------
Mars             48678219         6792
Jupiter         390674712       142984
Saturn          792248279       120536
Uranus         1692662533        51118
Neptune        2703959966        49528</code></pre>
<p>Considering that <code>int</code> takes 4 bytes of storage and <code>bigint</code> takes 8 bytes, using <code>bigint</code> for a column where <code>int</code> would have been large enough means taking up more disk space than necessary. In small tables, using <code>int</code> where a <code>smallint</code> or a <code>mediumint</code> would have sufficed won’t cause any problems. But if your table has 20 million rows, it pays to take the time to size the columns correctly—those extra bytes add up. </p>
<p><span epub:type="pagebreak" title="46" id="Page_46"/>One technique you can use for space efficiency is defining integer data types as <code>unsigned</code>. By default, the integer data types allow you to store negative and positive integers. If you won’t need any negative numbers, you can use <code>unsigned</code> to prevent negative values and increase the number of positive numbers. For example, the <code>tinyint</code> data type gives you a default range of values between –128 and 127, but if you specify <code>unsigned</code>, your range becomes 0 to 255.</p>
<p>If you specify <code>smallint</code> as <code>unsigned</code>, your range becomes 0 to 65,535. Specifying the <code>mediumint</code> data type gives you a range of 0 to 16,777,215, and specifying <code>int</code> changes the range to 0 through 4,294,967,295.</p>
<p>In <a href="#listing4-1">Listing 4-1</a>, you defined the <code>miles_from_earth</code> column as a <code>bigint</code>, but if you take advantage of the larger <code>unsigned</code> upper range values, you can fit the values into an <code>int</code> data type instead. You can be confident using <code>unsigned</code> for this column, as it will never need to store a negative number—no planet will ever be less than zero miles away from Earth:</p>
<pre><code>create table planet_stat
(
    planet            varchar(20),
    miles_from_earth  <b>int unsigned, -- Now using int unsigned, not bigint</b>
    diameter_km       mediumint
);</code></pre>
<p>By defining the column as <code>unsigned</code>, you can use the more compact <code>int</code> type and save disk space.</p>
<h3 id="h2-503007c04-0011"><a class="XrefDestination" id="Boolean"/><span class="XrefDestination" id="xref-503007c04-018"/>Boolean</h3>
<p class="BodyFirst">Boolean values have only two states: true or false; on or off; 1 or 0. Technically, MySQL doesn’t have a data type to capture boolean values; they’re stored in MySQL as <code>tinyint(1)</code>. You can use the synonym <code>bool</code> to create columns to store boolean values. When you define a column as <code>bool</code>, it creates a <code>tinyint(1)</code> column behind the scenes.</p>
<p>This table called <code>food</code> has two boolean columns, <code>organic_flag</code> and <code>gluten_free_flag</code>, to tell you whether a food is organic or gluten-free:</p>
<pre><code>create table food
(
    food              varchar(30),
    organic_flag      bool,
    gluten_free_flag  bool
);</code></pre>
<p>It’s common practice to add the suffix <code>_flag</code> to columns that contain boolean values, such as <code>organic_flag</code>, because setting the value to <code>true</code> or <code>false</code> can be compared to raising or lowering a flag, respectively.</p>
<p>To view the structure of a table, you can use the <code>describe</code>, or <code>desc</code>, command. <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a> shows the result of running <code>desc food;</code> in MySQL Workbench.</p>
<span epub:type="pagebreak" title="47" id="Page_47"/><figure>
<img src="image_fi/503007c04/f04001.png" class="keyline" alt="" width="385" height="164"/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: Describing the <span class="LiteralInCaption"><code>food</code></span> table in MySQL Workbench</p></figcaption>
</figure>
<p>You can see that, although the <code>organic_flag</code> and <code>gluten_free_flag</code> columns were created with the <code>bool</code> synonym, the data type that was used to create those columns is <code>tinyint(1)</code>.</p>
<h2 id="h1-503007c04-0004"><a class="XrefDestination" id="DecimalDataTypes"/><span class="XrefDestination" id="xref-503007c04-019"/>Decimal Data Types</h2>
<p class="BodyFirst">For numbers that contain decimal points, MySQL provides the <code>decimal</code>, <code>float</code>, and <code>double</code> data types. Whereas <code>decimal</code> stores exact values, <code>float</code> and <code>double</code> store approximate values. For that reason, if you are storing values that can be handled equally well by <code>decimal</code>, <code>float</code>, or <code>double</code>, I recommend using the <code>decimal</code> data type.</p>
<p class="ListHead"><b><code>decimal</code></b></p>
<ol class="none">
<li>The <code>decimal</code> data type allows you to define precision and scale. <em>Precision</em> is the total number of digits that you can store, and <em>scale</em> is the number of digits after the decimal point. The <code>decimal</code> data type is often used for monetary values with a scale of 2.
<p class="ListBody">For example, if you define a <code>price</code> column as <code>decimal(5,2)</code>, you can store values between –999.99 and 999.99. A precision of <code>5</code> means you can store five total digits, and a scale of <code>2</code> means you can store two digits after the decimal point.</p>
<p class="ListBody">The following synonyms are available for the <code>decimal</code> type: <code>numeric(5,2)</code>, <code>dec(5,2)</code>, and <code>fixed(5,2)</code>. All of these are equivalent and create a data type of <code>decimal(5,2)</code>.</p></li>
</ol>
<p class="ListHead"><b><code>float</code></b></p>
<ol class="none">
<li>The <code>float</code> data type stores numeric data with a floating-point decimal. Unlike the <code>decimal</code> data type, where the scale is defined, a floating-point number has a decimal point that isn’t always in the same location—the decimal point can <em>float</em> within the number. A <code>float</code> data type could represent the number 1.234, 12.34, or 123.4.</li>
</ol>
<p class="ListHead"><b><code>double</code></b></p>
<ol class="none">
<li>The <code>double</code> data type, short for <code>double precision</code>, also allows you to store a number with an undefined scale that has a decimal point someplace in the number. The <code>double</code> data type is similar to <code>float</code> except that <code>double</code> can store numbers more accurately. In MySQL, storing a <code>float</code> uses 4 bytes and storing a <code>double</code> uses 8. For floating-point numbers with many digits, use the <code>double</code> data type.</li>
</ol>
<h2 id="h1-503007c04-0005"><span epub:type="pagebreak" title="48" id="Page_48"/><a class="XrefDestination" id="DateandTimeDataTypes"/><span class="XrefDestination" id="xref-503007c04-020"/>Date and Time Data Types</h2>
<p class="BodyFirst">For dates and times, MySQL provides the <code>date</code>, <code>time</code>, <code>datetime</code>, <code>timestamp</code>, and <code>year</code> data types.</p>
<p class="ListHead"><b><code>date</code></b></p>
<ol class="none">
<li>The <code>date</code> data type stores dates in <code>YYYY-MM-DD</code> format (year, month, and day, respectively).</li>
</ol>
<p class="ListHead"><b><code>time</code></b></p>
<ol class="none">
<li>The <code>time</code> data type stores times in <code>hh:mm:ss</code> format, representing hours, minutes, and seconds.</li>
</ol>
<p class="ListHead"><b><code>datetime</code></b></p>
<ol class="none">
<li>The <code>datetime</code> data type is for storing both the date and time in one value with the format <code>YYYY-MM-DD hh:mm:ss</code>.</li>
</ol>
<p class="ListHead"><b><code>timestamp</code></b></p>
<ol class="none">
<li>The <code>timestamp</code> data type also stores the date and the time in one value with the same format <code>YYYY-MM-DD hh:mm:ss</code>, though <code>timestamp</code> stores the <em>current</em> date and time, while <code>datetime</code> is designed for other date and time values.
<p class="ListBody">The range of values that <code>timestamp</code> accepts is smaller; dates must be between the year 1970 and 2038. The <code>datetime</code> data type accepts a wider range of dates, from the years 1000 to 9999. You should use <code>timestamp</code> only when you want to stamp the current date and time value, such as to save the date and time that a row was updated.</p></li>
</ol>
<p class="ListHead"><b><code>year</code></b></p>
<ol class="none">
<li>The <code>year</code> data type stores the year in the <code>YYYY</code> format.</li>
</ol>
<h2 id="h1-503007c04-0006"><a class="XrefDestination" id="ThejsonDataType"/><span class="XrefDestination" id="xref-503007c04-021"/>The json Data Type</h2>
<p class="BodyFirst"><em>JavaScript Object Notation (JSON)</em> is a popular format for sending data between computers. MySQL provides the <code>json</code> data type to allow you to store and retrieve entire JSON documents in your database. MySQL will check that a JSON document contains valid JSON before allowing it to be saved in a <code>json</code> column.</p>
<p>A simple JSON document might look like this:</p>
<pre><code>{
   "department":"Marketing",
   "city":"Detroit",
   "managers":[
      {
         "name":"Tom McBride",
         "age":29
      },
      {
         "name":"Jill Hatfield",
<span epub:type="pagebreak" title="49" id="Page_49"/>         "age":25
      }
   ]
}</code></pre>
<p>JSON documents contain key/value pairs. In this example, <code>department</code> is a key and <code>Marketing</code> is a value. These keys and values don’t correspond to rows and columns in your table; instead, the entire JSON document can be saved in a column that has the <code>json</code> data type. Later, you can extract properties from the JSON document using MySQL queries.</p>
<h2 id="h1-503007c04-0007"><a class="XrefDestination" id="SpatialDataTypes"/><span class="XrefDestination" id="xref-503007c04-022"/>Spatial Data Types</h2>
<p class="BodyFirst">MySQL provides data types for representing geographical location data, or <em>geodata</em>. This type of data helps answer questions like “What city am I in?” or “How many Chinese restaurants are within 5 miles of my location?”</p>
<table id="tabular-503007c04-0005" border="1" class="TabularList">
<tbody>
<tr>
<td><code class="bold">geometry</code></td>
<td>Stores location values of any geographical type, including <code>point</code>, <code>linestring</code>, and<code> polygon</code> types</td>
</tr>
<tr>
<td><code class="bold">point</code></td>
<td>Represents a location with a particular latitude and longitude, like your current location</td>
</tr>
<tr>
<td><code class="bold">linestring</code></td>
<td>Represents points and the curve between them, such as the location of a highway</td>
</tr>
<tr>
<td><code class="bold">polygon</code></td>
<td>Represents a boundary, such as around a country or city</td>
</tr>
<tr>
<td><code class="bold">multipoint</code></td>
<td>Stores an unordered collection of <code>point</code> types</td>
</tr>
<tr>
<td><code class="bold">multilinestring</code></td>
<td>Stores a collection of <code>linestring</code> types</td>
</tr>
<tr>
<td><code class="bold">emultipolygon</code></td>
<td>Stores a collection of <code>polygon</code> typess</td>
</tr>
<tr>
<td><code class="bold">geometrycollection</code></td>
<td>Stores a collection of <code>geometry</code> types</td>
</tr>
</tbody>
</table>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxListNumberCustom1"><b>4-1.</b>	Create a database named <code>rapper</code> and write a <code>create table</code> statement for the <code>album</code> table. The <code>album</code> table should have five columns:</p>
<ul class="disc">
<li>The <code>rapper_id</code> column should use an unsigned <code>smallint</code> data type.</li>
<li>The <code>album_name</code> column should be a variable-length string that can hold up to 100 characters.</li>
<li>The <code>explicit_lyrics_flag</code> should store a boolean value.</li>
<li>The <code>album_revenue</code> column should store a monetary amount with a precision of 12 and a scale of 2.</li>
<li>The <code>album_content</code> column should use the <code>longblob</code> data type.</li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c04-0008"><span epub:type="pagebreak" title="50" id="Page_50"/><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-503007c04-024"/>Summary</h2>
<p class="BodyFirst">In this chapter, you explored the available MySQL data types and when to use them. In the next chapter, you’ll look at ways to retrieve data from multiple tables using different MySQL join types, and display that data in a single result set.</p>
</section>
</div>
</div>
</body></html>