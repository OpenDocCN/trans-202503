- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulnerability Seeking
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have around 150 domains to explore for various vulnerabilities: code injection,
    path traversal, faulty access controls, and so on. Hackers new to this type of
    exercise often feel overwhelmed by the sheer number of possibilities. Where to
    start? How much time should we spend on each website? Each page? What if we miss
    something?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is probably the phase that will challenge your confidence the most. I
    will share as many shortcuts as possible in this book, but believe me when I say
    that for this particular task, the oldest recipe in the world is the most effective
    one: *the more you practice, the better you will get.* The more fantastic and
    incredible the vulnerabilities you encounter, the more confidence you will gain,
    not only in yourself, but also in the inevitability of human errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice Makes Perfect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So how do you get started? Well, completing capture-the-flag (CTF) challenges
    is one way to master the very basic principles of exploits like SQL injections,
    cross-site scripting (XSS), and other web vulnerabilities. But be aware that these
    exercises poorly reflect the reality of a vulnerable application; they were designed
    by enthusiasts as amusing puzzles rather than the result of an honest mistake
    or a lazy copy-paste from a Stack Overflow post.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to learn about exploits is to try them in a safe environment.
    For example, experiment with SQL injections by spinning up a web server and a
    database in your lab, writing an app, and experimenting with it. Discover the
    subtleties of different SQL parsers, write your own filters to prevent injections,
    try to bypass those same filters, and so on. Get into the mind of a developer,
    face the challenge of parsing unknown input to build a database query or persist
    information across devices and sessions, and you will quickly catch yourself making
    the same dangerous assumptions the developers fall prey to. And as the saying
    goes, behind every great vulnerability there lies a false assumption lurking to
    take credit. Any stack will do for experimentation purposes: Apache + PHP, Nginx
    + Django, NodeJS + Firebase, and so on. Learn how to use these frameworks, understand
    where they store settings and secrets, and determine how they encode or filter
    user input.'
  prefs: []
  type: TYPE_NORMAL
- en: With time, you’ll develop a keen eye for spotting not only potentially vulnerable
    parameters, but how they are being manipulated by the application. Your mindset
    will change from “How can I make it work?” to “How can I abuse or break it?” Once
    this gear starts revolving in the back of your head, you will not be able to turn
    it off—trust me.
  prefs: []
  type: TYPE_NORMAL
- en: I also encourage you to take a look at what others are doing. I find great delight
    in reading bug bounty reports shared by researchers on Twitter, Medium, and other
    platforms like *https://pentester.land*. Not only will you be inspired by the
    tooling and methodology, but you will also be reassured, in some sense, that even
    the biggest corporations fail at the most basic features like password reset forms.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, for our purposes we are not in penetration test engagement, so time
    will be the least of our concerns. It is in fact our most precious ally. We will
    spend as much time as we deem necessary on each website. Your flair and curiosity
    are all the permissions you need to spend the whole day toying with any given
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Hidden Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back to our list of domains. When dealing with a full cloud environment, there
    is a shortcut that will help us learn more about websites and indeed prioritize
    them: we can reveal the real domains behind public-facing domains. Cloud providers
    usually produce unique URLs for each resource created by a customer, such as servers,
    load balancers, storage, managed databases, and content distribution endpoints.
    Take Akamai, a global content delivery network (CDN), for example. For a regular
    server, Akamai will create a domain name like *e9657.b.akamaiedge.net* to optimize
    packet transfer to that server. But no company will seriously use this unpronounceable
    domain for the public; they’ll hide it behind a glamorous name like *stellar.mxrads.com*
    or *victory.gretschpolitco.com*. The browser may think it is communicating with
    *victory.gretschpolitico.com*, but the network packet is actually being sent to
    the IP address of *e9657.b.akamaiedge.net*, which then forwards the packet to
    its final destination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can somehow figure out these hidden cloud names concealed behind each
    of the websites we retrieved, we may deduce the cloud service the websites rely
    on and thus focus on those services more likely to exhibit misconfigurations:
    Akamai is nice, but AWS S3 (storage service) and API Gateway (managed proxy) are
    more interesting, as we shall soon see. Or, if we know that a website is behind
    an AWS Application Load Balancer, for example, we can anticipate some parameter
    filtering and therefore adjust our payloads. Even more interesting, we can try
    looking up the “origin” or real server IP address and thus bypass the intermediary
    cloud service altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our list of domains and push our DNS recon an extra step to
    find these hidden domains. We want to look for *CNAME* *entries* (name records
    that point to other name records) rather than IP addresses (as the more common
    A records do). The command `getent hosts` pulls these CNAME records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that *thor.mxrads.com* is indeed behind an Akamai distribution point.
  prefs: []
  type: TYPE_NORMAL
- en: Not all alternative domains are registered as CNAME records; some are created
    as ALIAS records that do not explicitly show up in the name resolution process.
    For these stubborn cases, we can guess the AWS service by looking up the IP address
    in the public range published in the AWS documentation under General Reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could not find a simple tool to perform this type of extended DNS reconnaissance,
    so I wrote a script to automate the process: *DNS Charts*, found at [https://dnscharts.hacklikeapornstar.com/](https://dnscharts.hacklikeapornstar.com/).
    We build a list of domains and then feed it to DNS Charts to look for those CNAME
    entries, with some additional regex matching to guess the cloud service. The result
    is printed in a colorful graph that highlights the underlying interactions between
    domains, as well as the main cloud services used by a company. [Figure 5-1](#figure5-1)
    shows some sample output of the tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/501263c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: List of services used by MXR Ads'
  prefs: []
  type: TYPE_NORMAL
- en: 'One glance at this graph gives us a pretty clear image of the most interesting
    endpoints to target first. The majority of domains we retrieved are hosted on
    AWS and use a mixture of the following services: *CloudFront*, a distribution
    network; *S3*, Amazon’s storage service; and *ELB*, a load balancer. The rest
    use the Akamai distribution network.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the dashboard URL of GP (top center) points to a domain belonging
    to MXR Ads (bottom left). We were right about their close relationship; it’s even
    reflected in their respective infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: We have a few leads here. For example, the *gretschpol-alb-1463804911.eu-west-1\.
    . .* subdomain refers to an AWS Application Load Balancer (AWS ALB), suggested
    by the *alb* part of the URL. According to AWS documentation, this is a layer
    7 load balancer that’s responsible for distributing incoming traffic. In theory,
    a layer 7 load balancer is capable of parsing HTTP requests and even blocking
    some payloads when linked to the AWS Web Application Firewall (AWS WAF). Whether
    that is indeed the case is open for speculation and will require active probing,
    of course.
  prefs: []
  type: TYPE_NORMAL
- en: The application load balancer can wait, however. We already picked up our list
    of winners the moment we laid eyes on the graph. We will start with the all-too-tempting
    AWS S3 URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the S3 URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS S3 is a highly redundant and cheap storage service offered by Amazon, starting
    at just $0.023 per GB, plus data transfer. Objects stored in S3 are organized
    into *buckets*. Each bucket has a unique name and URL across all AWS accounts
    (see [Figure 5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501263c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: S3 storage bucket as it appears in the web console'
  prefs: []
  type: TYPE_NORMAL
- en: S3 can host anything from JavaScript files to database backups. Following its
    rapid adoption by many companies, both small and massive, one could often hear
    in a meeting when speaking of a random file, “Oh, just put it on S3!”
  prefs: []
  type: TYPE_NORMAL
- en: This kind of concentration of easily available data on the internet draws hackers
    like bees to a flower, and sure enough, small and prestigious companies alike
    shared the same scandalous journal headlines. Open and vulnerable S3 buckets cost
    these companies terabytes of sensitive data, like customer information, transaction
    histories, and much more. Breaching a company has never been easier. You can even
    find a list of open S3 buckets at [https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our little DNS graph in [Figure 5-1](#figure5-1) showed that we have four S3
    URLs—dl.mxrads.com, misc.mxrads.com, assets.mxrads.com, and resource.mxrads.com—but
    in fact there may be more to uncover. Before we examine these buckets, we’ll weed
    these out. Sometimes Akamai and CloudFront can hide S3 buckets behind ALIAS records.
    To be thorough, we will loop over the 18 Akamai and CloudFront URLs and take a
    hard look at the `Server` directive in the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two more buckets to add to the mix. Great. We proceed to load our first
    bucket URL, dl.mxrads.com (an alias for mxrads-files.s3.eu-west-1.amazonaws.com),
    in the browser, hoping to gain entry to whatever the bucket stores. Unfortunately,
    we immediately get slapped with a rather explicit error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![g05001](image_fi/501263c05/g05001.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Access denied`.'
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to what this message may suggest, we are not technically forbidden
    from accessing objects in the bucket. We are simply not allowed to list the bucket’s
    content, very much like how the `Options -Indexes` in an Apache server disables
    directory listing.
  prefs: []
  type: TYPE_NORMAL
- en: S3 Bucket Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following one too many scandals involving insecure S3 buckets, AWS has tightened
    up its default access controls. Each bucket now has a sort of public switch that
    the user can easily activate to disallow any type of public access. It might seem
    like a basic feature to have, except that a bucket’s access list is governed by
    not one, not two, not three, but four overlapping settings beneath the public
    switch! How very convoluted. One can almost forgive companies for messing up their
    configuration. These settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Access control lists (ACLs) Explicit rules stating which AWS accounts can access
    which resources (deprecated).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS) Rules and constraints placed on HTTP requests
    originating from other domains, which can filter based on the request’s user agent
    string, HTTP method, IP address, resource name, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bucket policy A JavaScript Object Notation (JSON) document with rules stating
    which actions are allowed, by whom, and under which conditions. The bucket policy
    replaces ACLs as the nominal way of protecting a bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identity and Access Management (IAM) policies Similar to bucket policies, but
    these JSON documents are attached to users/groups/roles instead of buckets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of a bucket policy that allows anyone to get an object from
    the bucket but disallows any other operation on the bucket, such as listing its
    contents, writing files, changing its policy, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: AWS combines rules from these four settings to decide whether or not to accept
    an incoming operation. Presiding over these four settings is the master switch,
    called *Block public access*, which when turned on disables all public access,
    even if it’s explicitly authorized by one of the four underlying settings.
  prefs: []
  type: TYPE_NORMAL
- en: Complicated? That’s putting it mildly. I encourage you to set up an AWS account
    and explore the intricacies of S3 buckets to develop the right reflexes in recognizing
    and abusing overly permissive S3 settings.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Buckets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back to our list of buckets. We skim through them and are again denied entry
    for all except *misc.mxrads.com*, which, strangely enough, returns an empty page.
    The absence of error is certainly encouraging. Let’s probe further using the AWS
    command line. First, we install the AWS command line interface (CLI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The AWS CLI does not accept S3 URLs, so we need to figure out the real bucket
    name behind *misc.mxrads.com*. Most of the time, this is as simple as inspecting
    the domain’s CNAME record, which in this case yields mxrads-misc.s3-website.eu-west-1.amazonaws.com.
    This tells us that the bucket’s name is mxrads-misc. If inspecting the CNAME doesn’t
    work, we need more elaborate tricks, such as injecting special characters like
    `%C0` in the URL, or appending invalid parameters, in an attempt to get S3 to
    display an error page containing the bucket name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this bucket name, we can leverage the full power of the AWS CLI.
    Let’s start by retrieving a full list of objects present in the bucket and saving
    it to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a lot of objects—too many to manually inspect. To find out exactly how
    many, we grep the `"Key"` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! We have more than 400,000 files stored in this single bucket. That’s
    as good a catch as they come. In the list of objects, note the empty *index.html*
    at the root of the S3 bucket; an S3 bucket can be set up to act as a website hosting
    static files like JavaScript code, images, and HTML, and this *index.html* file
    is what’s responsible for the blank page we got earlier when running the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time for some poor man’s data mining. Let’s use regex patterns to look
    up SQL scripts, bash files, backup archives, JavaScript files, config files, VirtualBox
    snapshots—anything that might give us valuable credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a list of files with some potential. We then download these candidates
    using `aws s3api get-object` and methodically go through each of them, hoping
    to land on some form of valid credentials. An interesting fact to keep in mind
    is that AWS does not log S3 object operations like `get-object` and `put-object`
    by default, so we can download files to our heart’s content with the knowledge
    that no one has tracked our movements. Sadly, that much cannot be said of the
    rest of the AWS APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Hours of research later and we still have nothing, zip, nada. It seems most
    of the scripts are old three-liners used to download public documents, fetch other
    scripts, automate routine commands, or create dummy SQL tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to try something else. Maybe there are files with sensitive data that
    escaped our previous pattern filter. Maybe files with uncommon extensions hiding
    in the pile. To find these files, we run an aggressive inverted search that weeds
    out common and useless files like images, Cascading Style Sheets (CSS), and fonts
    in an effort to reveal some hidden gems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: HTML files are not exactly the special files we had in mind, but since they
    represent more than 75 percent of the files in this bucket, we’d better take a
    look. Opening them up, we see that they appear to be saved pages from news websites
    around the world. Somewhere in this messy GP infrastructure, an application is
    fetching web pages and storing them in this bucket. We want to know why.
  prefs: []
  type: TYPE_NORMAL
- en: Remember in the Introduction when I spoke about that special *hacker flair*?
    This is it. This is the kind of find that should send tingling sensations down
    your spine!
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Web-Facing Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Where is this damn application hiding? To weed it out, we go back to our DNS
    reconnaissance results from [Figure 5-1](#figure5-1) and, sure enough, the perfect
    suspect jumps out screaming from the lot: *demo.mxrads.com*. We saw the same “demo”
    keyword in the S3 keys with HTML files. We didn’t even have to grep.'
  prefs: []
  type: TYPE_NORMAL
- en: We enter *demo.mxrads.com* in the browser and see that the main image and headline
    seem to describe the behavior we were looking for (see [Figure 5-3](#figure5-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/501263c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: Home page of demo.mxrads.com'
  prefs: []
  type: TYPE_NORMAL
- en: To take a closer look at this page, we’ll fire up Burp Suite, a local web proxy
    that conveniently intercepts and relays every HTTP request coming from our browser
    (OWASP fans can use ZAP, the Zed Attack Proxy). We reload *demo.mxrads.com* with
    Burp running and see the requests made by the site trickling down in real time,
    as shown in [Figure 5-4](#figure5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/501263c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Burp inspection of the MXR Ads demo page'
  prefs: []
  type: TYPE_NORMAL
- en: This is a great attack surface. Using Burp, we can intercept these HTTP(S) requests,
    alter them on the fly, repeat them at will, and even configure regex rules to
    automatically match and replace headers. If you’ve ever done a web pentest or
    CTF challenge, you must have used a similar tool. But we’ll set that aside for
    now and continue our investigation.
  prefs: []
  type: TYPE_NORMAL
- en: We return to inspecting the *demo.mxrads.com* site. As we would suspect from
    a company like MXR Ads, this website offers to showcase demo ads on multiple browsers
    and devices, and also on some featured websites like *nytimes.com and *theregister.com*
    (see [Figure 5-5](#figure5-5)). Sales teams around the world likely leverage these
    features to convince media partners that their technology seamlessly integrates
    with any web framework. Pretty clever.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![f05005](image_fi/501263c05/f05005.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5-5: MXR Ads feature showcasing ads on various popular sites'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll inspect the page by trying out the feature. We choose to display an ad
    on the *New York Times* website, and a new content window pops up with a lovely
    ad for a random perfume brand stacked in the middle of today’s NYT’s main page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This demo page may seem like a harmless feature: we point to a website, and
    the app fetches its actual content and adds a video player with a random ad to
    show potential clients what MXR Ads can do. What vulnerabilities could it possibly
    introduce? So many . . .'
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at how to exploit this app, let’s first assess what’s happening
    behind the scenes using Burp Proxy. What happens when we click the NYT option
    to showcase an ad? We see the results in [Figure 5-6](#figure5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/501263c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: The HTTP History tab after we click the NYT option on *demo.mxrads.com*'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t get much HTTP traffic, that’s for sure. Once the web page is loaded,
    the server responds with an “HTTP/1.1 101 Switching Protocols” message, then no
    more communication appears in the HTTP History tab. We need to switch to the WebSockets
    History tab to follow the rest of the exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Interception with WebSocket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*WebSocket* is another communication protocol alongside HTTP, but unlike HTTP
    WebSocket is a full-duplex communication channel. In the regular HTTP protocol,
    each server response matches a client request. The server does not maintain state
    between two requests; rather, the state is handled by cookies and headers, which
    help the backend application remember who is calling which resource. WebSockets
    operate differently: the client and server establish a full-duplex and binding
    tunnel where each one can initiate communications at will. It is not uncommon
    to have several incoming messages for one outgoing message, or vice versa. (For
    more on WebSockets, check out [https://blog.teamtreehouse.com/an-introduction-to-websockets/](https://blog.teamtreehouse.com/an-introduction-to-websockets/).)
    The beautiful aspect of WebSockets is that they do not require HTTP cookies and
    therefore don’t bother supporting them. These are the same cookies that maintain
    the user authentication session! So whenever there is a switch from HTTP to WebSocket
    in authenticated sessions, there is an opportunity to bypass access control by
    directly fetching sensitive resources using WebSocket instead of HTTP—but that’s
    another class of vulnerability for another time. [Figure 5-7](#figure5-7) shows
    our WebSockets History tab.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/501263c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: The WebSockets History tab for *demo.mxrads.com*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebSocket communication seems pretty straightforward: each message to the
    server is composed of a URL (*nytimes.com*) followed by metrics related to the
    user’s browser (Mozilla/5.0\. . .), along with an identifier of the ad to display
    (437). Burp cannot replay (*repeat* in Burp terminology) past WebSocket communications,
    so to tamper with the WebSocket message we need to manually trigger it from the
    demo website.'
  prefs: []
  type: TYPE_NORMAL
- en: We turn on intercept mode in the Burp options, which will allow us to catch
    the next message exchanged and update it on the fly (see [Figure 5-8](#figure5-8)).
    For instance, let’s see if we can get the MRX Ads site to fetch the home page
    of that Nginx container we set up in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05008](image_fi/501263c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Intercepting a web page in Burp'
  prefs: []
  type: TYPE_NORMAL
- en: 'We forward the modified request and head to our Docker container to explore
    the logs. We grab the container ID using `docker ps` and then feed it to `docker
    logs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The MXR Ads app does indeed fetch URLs in real time! Why is that so awesome,
    you ask? Well, not all domains and IP addresses were created equal, you see. Some
    IP addresses have particular purposes. A perfect example is the 127.0.0.0/8 block
    that refers to the loopback address (the host itself), or 192.168.0.0/16, which
    is reserved for private networks. One lesser-known IP address range is 169.254.0.0/16,
    which is reserved by the Internet Engineering Task Force (IETF) for link-local
    addressing, meaning this range is only valid for communication inside a network
    and cannot be routed to the internet. Whenever a computer fails to acquire an
    IP address through DHCP, for instance, it assigns itself an IP in this range.
    More importantly, this range is also used by many cloud providers to expose private
    APIs to their virtual machines, so they become aware of their own environment.
  prefs: []
  type: TYPE_NORMAL
- en: On almost all cloud providers, a call to the IP 169.254.169.254 is routed to
    the hypervisor and retrieves information about internal matters such as the machine’s
    hostname, internal IP, firewall rules, and so forth. This is a trove of metadata
    that could give us a sneak peek into the company’s internal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a go, shall we? With Burp intercept mode still on, we trigger
    another WebSocket message to showcase an ad on the *New York Times*, but this
    time we replace the URL in the message body with the default AWS metadata URL,
    *http://169.254.169.254/latest*, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We wait for a response from the server—remember it’s asynchronous—but nothing
    comes back.
  prefs: []
  type: TYPE_NORMAL
- en: 'MXR Ads is not making things easy for us. It’s reasonable to assume that the
    URL is explicitly banned in the app for precisely this reason. Or maybe the app
    simply expects a valid domain? Let’s replace the metadata IP with a more innocuous
    IP (for instance, that of our Nginx container):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We check the logs and, sure enough, we see the request from the app coming
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so some IP addresses are allowed, but 169.254.169.254 must be explicitly
    banned by the app. Time to whip out our bag of dirty string-parsing tricks. Though
    IP addresses are commonly expressed in decimal format, browsers and web clients
    are in fact happy with more esoteric representations, like hexadecimal or octal.
    For instance, all the following IP addresses are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can try to get around the IP address ban by trying out its hex, dotted hex,
    and octal alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, simple hexadecimal formatting does the job, and we get the famous
    output of AWS’s metadata API, as shown in [Figure 5-9](#figure5-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05009](image_fi/501263c05/f05009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-9: Output of the AWS metadata URL'
  prefs: []
  type: TYPE_NORMAL
- en: In the Raw section at the bottom of [Figure 5-9](#figure5-9), the strings 1.0,
    2007-01-19, 2007-03-01, and so on are the different versions of the metadata endpoint.
    Rather than specify a specific date, we can use the keyword */latest* in the path
    to get the most data possible, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: This output, of course, confirms that we have a valid case for server-side request
    forgery. Time for some damage!
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *server-side request forgery (SSRF**)* attack involves us forcing some server-side
    application to make HTTP requests to a domain of our choosing. This can sometimes
    grant us access to internal resources or unprotected admin panels.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We start gathering basic information about the machine running this web page–fetching
    application, again using Burp’s intercept mode. After intercepting our request,
    we substitute the hex-encoded metadata IP for the originally requested URL and
    then append AWS’s metadata API name to the end, as shown in [Listing 5-1](#listing5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Basic information on the web app, pulled from the metadata API'
  prefs: []
  type: TYPE_NORMAL
- en: From this we see that the demo app is running in the `eu-west-1` region, indicating
    one of Amazon’s datacenters in Ireland. There are dozens of regions available
    in AWS. While companies strive to distribute their most important applications
    across multiple regions, auxiliary services and sometimes backends tend to concentrate
    in a subset of regions. The instance ID, a unique identifier assigned to each
    virtual machine spawned in the EC2 service, is `i-088c8e93dd5703ccc` 1. This information
    can come in handy when executing AWS API calls targeting the machine running the
    ad application.
  prefs: []
  type: TYPE_NORMAL
- en: The image ID `ami-02df9ea15c1778c9c` 2 refers to the snapshot used to run the
    machine, such as an Ubuntu or CoreOS image. Machine images can be public (available
    to all AWS customers) or private (available only to specific accounts). This particular
    AMI ID is private, as it cannot be found on the AWS EC2 console. Had the AMI ID
    not been private, we could have spawned a similar instance of the snapshot to
    test future payloads or scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the public hostname gives us a direct route to the machine running
    the demo application (or *EC2 instance* in AWS jargon), provided local firewall
    rules allow us to reach it. This machine’s public IP can be deduced from its canonical
    hostname: `3.248.221.147` 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of network configuration, let’s pull the firewall configuration from
    the metadata API, as shown in [Listing 5-2](#listing5-2). Understanding what firewall
    rules exist can give you hints about other hosts that interact with this system
    and what services may be running on it, even if they aren’t publicly accessible.
    Firewall rules are managed in objects called *security groups*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: Firewall configuration of the web app'
  prefs: []
  type: TYPE_NORMAL
- en: We need the network’s MAC address to retrieve network information from the metadata
    API. The AWS account owner is used to build *Amazon Resource Names* *(ARNs**)*,
    which are unique identifiers for users, policies, and pretty much every resource
    on AWS; this is essential information that will prove useful in future API calls.
    The ARN is unique per account, so MXR Ads’ account ID is and will remain 886371554408
    for everything—even though a company may and often will have multiple AWS accounts,
    as we will later see.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only list the security groups’ names and not the actual firewall rules,
    but that already carries enough information to guess the actual firewall rules.
    The `elb` section in the `elb_http_prod_eu-west-1` set, for example, indicates
    that this set most likely grants the load balancer access to the server. The third
    security group is interesting: `common_ssh_private-eu-west-1`. Based on its name,
    it’s safe to assume that only a select few machines, usually called *bastions*,
    have the ability to connect through SSH to the rest of the infrastructure. If
    we can somehow land on one of these precious instances, that would open up many,
    many doors! It’s funny how we are still stuck outside the organization yet can
    already get a sense of its infrastructure design ideas.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dirty Secret of the Metadata API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are far from done, of course, so let’s kick it up a notch. As we saw in Chapter
    3, AWS offers the possibility to execute a script when the machine boots for the
    first time. This script is usually referred to as *user-data*. We used it to set
    up our own infrastructure and bootstrap Docker containers. Great news—that same
    *user-data* is available via the metadata API in a single query. By sending one
    more request through Burp to the MXR Ads demo app, we can see they sure as hell
    used it to set up their own machines, as shown in [Listing 5-3](#listing5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: Snippet of the *user-data* script executed on the machine’s first
    boot'
  prefs: []
  type: TYPE_NORMAL
- en: We get a torrent of data streams on the screen, filling our hearts with warm
    and fuzzy feelings. SSRF in all its glory. Let’s inspect what we got with this
    last command.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to accepting plain bash scripts, *cloud-init* supports the file
    format *cloud-config*, which uses a declarative syntax to prepare and schedule
    boot operations. *Cloud-config* is supported by many distributions, including
    CoreOS, which appears to be the OS powering this machine 1.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cloud-config* uses a YAML syntax, which uses whitespace and newlines to delimit
    lists, values, and so on. The *cloud-config* file describes instructions to set
    up services, create accounts, execute commands, write files, and perform other
    tasks involved in boot operations. Some find it cleaner and easier to understand
    than a crude bash script.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the most important bits of the *user-data* script we retrieved
    (see [Listing 5-4](#listing5-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: Continuation of the *user-data* script'
  prefs: []
  type: TYPE_NORMAL
- en: First, the file sets up a service to be executed at the machine’s boot time
    1. This service pulls the `demo-client` application image 2 and proceeds to run
    the container using a well-furnished `docker` `run` command 3.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the multiple `--env-file` switches 4 that ask Docker to load environment
    variables from custom text files, one of which is so conveniently named *secrets.env*!
    The million-dollar question, of course, is where are these files located?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a small chance they are baked directly into the AMI image, but then
    making updates to configuration files would be the Everest of inconvenience for
    MXR Ads. To update a database password, the company would need to bake and release
    a new CoreOS image. Not very efficient. No, chances are the secrets file is either
    dynamically fetched via S3 or embedded directly in the same *user-data* script.
    Indeed, if we scroll a bit further we come across the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Brilliant. The content of this blob is base64-encoded, so we’ll decode it, decompress
    it, and marvel at its content, as shown in [Listing 5-5](#listing5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: A snippet of the decoded *secrets.env* file containing passwords'
  prefs: []
  type: TYPE_NORMAL
- en: Jackpot! The blob has yielded many passwords to access Cassandra clusters (Cassandra
    is a highly resilient NoSQL database usually deployed to handle large-scale data
    with minimal latency). We also get two obscure passwords holding untold promise.
    Of course, passwords alone are not enough. We need the associated host machines
    and usernames, but so does the application, so we can assume the second environment
    file from [Listing 5-4](#listing5-4), *env.file*, should contain all the missing
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling further down *user-data*, however, we find no definition of *env.file*.
    But we do come across a shell script, *get-region-params.sh*, that seems to reset
    our precious *env.file* (see [Listing 5-6](#listing5-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: A discovery service that seems to interact with *env.file*'
  prefs: []
  type: TYPE_NORMAL
- en: It seems likely this script will create *env.file*. Let’s dive into the content
    of *get-region-params.sh*, created three lines below (see [Listing 5-7](#listing5-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: The lines in charge of creating *get-region-params.sh* in the
    *user**-**data* script'
  prefs: []
  type: TYPE_NORMAL
- en: We have another encoded blob 1. Using some `base64` and `gunzip` magic, we translate
    this pile of garbage to a normal bash script that defines various endpoints, usernames,
    and other parameters, depending on the region where the machine is running (see
    [Listing 5-8](#listing5-8)). I will skip over the many conditional branches and
    case switch statements to only print the relevant parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: A snippet of the decoded *get-region-params.sh* script'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the S3 buckets mxrads-dl 1 and mxrads-misc 2 we came across earlier during
    reconnaissance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the script, we can see that the instance is using the metadata API
    to retrieve its own region and build endpoints and usernames based on that information.
    That’s the first step a company will take toward infrastructure resilience: it
    packages an app, nay, an environment, that can run on any hypervisor, in any datacenter,
    in any country. Powerful stuff, for sure, with the caveat, as we are witnessing
    firsthand, that a simple SSRF vulnerability could expose all of the application’s
    secrets to anyone willing to poke at it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-referencing this file with passwords we got from [Listing 5-5](#listing5-5)
    and making educated guesses based on the variable names, we can reconstruct the
    following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cassandra-delivery.prod.euw1.mxrads.tech**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: userdc-euw1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Password: gQMUUHsVuuUyo003jqFU'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**cassandra-usersync.prod.euw1.mxrads.tech**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: usersync-euw1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Password: QZ6bhOWiCprQPetIhtSv'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some machines are missing usernames, and other passwords are missing their matching
    hostnames, but we will figure it all out in time. For now, this is everything
    we can fully put together.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, the only thing preventing us from accessing these databases
    is basic, boring firewall rules. These endpoints resolve to internal IPs, unreachable
    from the dark corner of the internet where our attack server lies, so unless we
    figure out a way to change these firewall rules or bypass them altogether, we
    are stuck with a pile of worthless credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that’s not entirely true. There is one set of credentials that we haven’t
    yet retrieved, and unlike the previous ones, it is not usually subject to IP restrictions:
    the machine’s IAM role.'
  prefs: []
  type: TYPE_NORMAL
- en: On most cloud providers, you can assign a *role* to a machine, which is a set
    of default credentials. This gives the machine the ability to seamlessly authenticate
    to the cloud provider and inherit whatever permissions are assigned to that role.
    Any application or script running on the machine can claim that role, and this
    avoids the nasty habit of hardcoding secrets in the code. Seems perfect . . .
    again, on paper.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, when an EC2 machine (or, more accurately, an instance profile) impersonates
    an IAM role, it retrieves a set of temporary credentials that embody that role’s
    privileges. These credentials are made available to the machine through—you guessed
    it—the metadata API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the */latest/meta-data/iam/security-credentials* endpoint to retrieve
    the role’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the machine was assigned the demo-role.ec2 role. Let’s pull
    its temporary credentials, again by calling the metadata API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We get the `AccessKeyId` and `SecretAccessKey`, which together form the classic
    AWS API credentials, as well as an access token that validates this set of temporary
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we can load these keys into any AWS client and interact with MXR
    Ads’ account from any IP in the world using the machine’s identity: demo-role.ec2\.
    If this role allows the machine access to S3 buckets, we have access to those
    buckets. If the machine can terminate instances, now so can we. We can take over
    this instance’s identity and privileges for the next six hours before the credentials
    are reset 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When this grace period expires, we can once again retrieve a new set of valid
    credentials. Now you understand why SSRF is my new best friend. Here we register
    the AWS credentials in our home directory under the profile name `demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems like we are on a roll! Unfortunately, just as we start to tighten our
    grip around the target, AWS comes at us with yet another blow: IAM.'
  prefs: []
  type: TYPE_NORMAL
- en: AWS IAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS IAM is the authentication and authorization service, and it can be something
    of a quagmire. By default, users and roles have almost zero privileges. They cannot
    see their own information, like their usernames or access key IDs, because even
    these trivial API calls require explicit permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, regular IAM users like developers have some basic rights of self-inspection
    so they can do things like list their group membership, but that’s hardly the
    case for an instance profile attached to a machine. When we try to get basic information
    about the role demo-role-ec2, we get an astounding error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`aws iam get-role \`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: An application does not usually evaluate its set of permissions at runtime;
    it just performs the API calls as dictated by the code and acts accordingly. This
    means we have valid AWS credentials, but at the moment we have absolutely no idea
    how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have to do some research. Almost every AWS service has some API call that
    describes or lists all its resources (`describe-instances` for EC2, `list-buckets
    for S3, and so on). So, we can slowly start probing the most common services to
    see what we can do with these credentials and work our way up to testing all of
    AWS’s myriad services.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]*'
  prefs: []
  type: TYPE_NORMAL
