- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Vulnerability Seeking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞探索
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'We have around 150 domains to explore for various vulnerabilities: code injection,
    path traversal, faulty access controls, and so on. Hackers new to this type of
    exercise often feel overwhelmed by the sheer number of possibilities. Where to
    start? How much time should we spend on each website? Each page? What if we miss
    something?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有大约150个领域需要探索各种漏洞：代码注入、路径遍历、错误的访问控制等等。对于新手黑客来说，面对如此多的可能性，往往会感到不知所措。该从哪里开始？我们应该在每个网站上花多少时间？每个页面呢？如果我们错过了什么怎么办？
- en: 'This is probably the phase that will challenge your confidence the most. I
    will share as many shortcuts as possible in this book, but believe me when I say
    that for this particular task, the oldest recipe in the world is the most effective
    one: *the more you practice, the better you will get.* The more fantastic and
    incredible the vulnerabilities you encounter, the more confidence you will gain,
    not only in yourself, but also in the inevitability of human errors.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最能挑战你信心的阶段。我会在本书中分享尽可能多的捷径，但相信我，当我说对于这个特定任务，世界上最古老的秘诀是最有效的：*你练得越多，做得越好*。你遇到的漏洞越奇妙、不可思议，你获得的信心就越多，不仅是在自己身上，也是在人的错误不可避免性上。
- en: Practice Makes Perfect
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习成就完美
- en: So how do you get started? Well, completing capture-the-flag (CTF) challenges
    is one way to master the very basic principles of exploits like SQL injections,
    cross-site scripting (XSS), and other web vulnerabilities. But be aware that these
    exercises poorly reflect the reality of a vulnerable application; they were designed
    by enthusiasts as amusing puzzles rather than the result of an honest mistake
    or a lazy copy-paste from a Stack Overflow post.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何开始呢？完成夺旗（CTF）挑战是一种掌握SQL注入、跨站脚本（XSS）和其他Web漏洞基本原理的方法。但要注意，这些练习很难反映脆弱应用程序的现实；它们是由爱好者设计的有趣谜题，而不是由于诚实的错误或从Stack
    Overflow帖子中懒得复制粘贴的结果。
- en: 'The best way to learn about exploits is to try them in a safe environment.
    For example, experiment with SQL injections by spinning up a web server and a
    database in your lab, writing an app, and experimenting with it. Discover the
    subtleties of different SQL parsers, write your own filters to prevent injections,
    try to bypass those same filters, and so on. Get into the mind of a developer,
    face the challenge of parsing unknown input to build a database query or persist
    information across devices and sessions, and you will quickly catch yourself making
    the same dangerous assumptions the developers fall prey to. And as the saying
    goes, behind every great vulnerability there lies a false assumption lurking to
    take credit. Any stack will do for experimentation purposes: Apache + PHP, Nginx
    + Django, NodeJS + Firebase, and so on. Learn how to use these frameworks, understand
    where they store settings and secrets, and determine how they encode or filter
    user input.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习漏洞的最佳方式是尝试在安全环境中进行实验。例如，通过在实验室中启动一个Web服务器和一个数据库，编写一个应用并进行实验，来尝试SQL注入。发现不同SQL解析器的细微差别，编写自己的过滤器来防止注入，尝试绕过这些过滤器，等等。进入开发者的思维，面对解析未知输入来构建数据库查询或跨设备和会话持久化信息的挑战，你会很快发现自己会做出开发者常常犯的相同危险假设。正如俗话所说，每个伟大漏洞背后都隐藏着一个错误的假设，等待着借机得分。任何栈都适合进行实验：Apache
    + PHP，Nginx + Django，NodeJS + Firebase，等等。学习如何使用这些框架，了解它们存储设置和机密信息的地方，并确定它们如何对用户输入进行编码或过滤。
- en: With time, you’ll develop a keen eye for spotting not only potentially vulnerable
    parameters, but how they are being manipulated by the application. Your mindset
    will change from “How can I make it work?” to “How can I abuse or break it?” Once
    this gear starts revolving in the back of your head, you will not be able to turn
    it off—trust me.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你将培养出敏锐的眼光，不仅能发现潜在的漏洞参数，还能了解它们是如何被应用程序操控的。你的思维方式将从“我如何让它工作？”转变为“我如何滥用或破坏它？”一旦这个齿轮开始在你脑海中转动，你将无法关闭它——相信我。
- en: I also encourage you to take a look at what others are doing. I find great delight
    in reading bug bounty reports shared by researchers on Twitter, Medium, and other
    platforms like *https://pentester.land*. Not only will you be inspired by the
    tooling and methodology, but you will also be reassured, in some sense, that even
    the biggest corporations fail at the most basic features like password reset forms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我也鼓励你看看别人都在做什么。我非常喜欢阅读研究人员在 Twitter、Medium 和其他平台上分享的漏洞赏金报告，比如 *https://pentester.land*。你不仅会被工具和方法论所启发，还会在某种程度上得到安慰，知道即使是最庞大的公司也会在最基本的功能上，如密码重置表单，出现失败。
- en: Thankfully, for our purposes we are not in penetration test engagement, so time
    will be the least of our concerns. It is in fact our most precious ally. We will
    spend as much time as we deem necessary on each website. Your flair and curiosity
    are all the permissions you need to spend the whole day toying with any given
    parameter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸好，对于我们的目的，我们并没有进行渗透测试工作，因此时间不是我们最担心的问题。实际上，时间是我们最宝贵的盟友。我们会在每个网站上花费我们认为必要的时间。你的灵感和好奇心就是你所需要的所有权限，可以让你整天玩弄任何给定的参数。
- en: Revealing Hidden Domains
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示隐藏域名
- en: 'Back to our list of domains. When dealing with a full cloud environment, there
    is a shortcut that will help us learn more about websites and indeed prioritize
    them: we can reveal the real domains behind public-facing domains. Cloud providers
    usually produce unique URLs for each resource created by a customer, such as servers,
    load balancers, storage, managed databases, and content distribution endpoints.
    Take Akamai, a global content delivery network (CDN), for example. For a regular
    server, Akamai will create a domain name like *e9657.b.akamaiedge.net* to optimize
    packet transfer to that server. But no company will seriously use this unpronounceable
    domain for the public; they’ll hide it behind a glamorous name like *stellar.mxrads.com*
    or *victory.gretschpolitco.com*. The browser may think it is communicating with
    *victory.gretschpolitico.com*, but the network packet is actually being sent to
    the IP address of *e9657.b.akamaiedge.net*, which then forwards the packet to
    its final destination.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的域名列表。当处理一个完整的云环境时，有一个捷径可以帮助我们更好地了解网站，并确实让我们优先考虑它们：我们可以揭示隐藏在公共域名背后的真实域名。云服务提供商通常会为客户创建的每个资源（如服务器、负载均衡器、存储、托管数据库和内容分发端点）生成唯一的
    URL。以全球内容分发网络（CDN）Akamai 为例。对于常规服务器，Akamai 会创建一个像 *e9657.b.akamaiedge.net* 这样的域名，以优化数据包传输到该服务器。但没有公司会认真地将这个无法发音的域名公开使用；他们会把它隐藏在一个像
    *stellar.mxrads.com* 或 *victory.gretschpolitco.com* 这样华丽的名字后面。浏览器可能认为它正在与 *victory.gretschpolitico.com*
    通信，但网络数据包实际上是发送到 *e9657.b.akamaiedge.net* 的 IP 地址，然后再转发到最终目标。
- en: 'If we can somehow figure out these hidden cloud names concealed behind each
    of the websites we retrieved, we may deduce the cloud service the websites rely
    on and thus focus on those services more likely to exhibit misconfigurations:
    Akamai is nice, but AWS S3 (storage service) and API Gateway (managed proxy) are
    more interesting, as we shall soon see. Or, if we know that a website is behind
    an AWS Application Load Balancer, for example, we can anticipate some parameter
    filtering and therefore adjust our payloads. Even more interesting, we can try
    looking up the “origin” or real server IP address and thus bypass the intermediary
    cloud service altogether.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够弄清楚这些隐藏的云域名，它们藏在我们获取的每个网站后面，我们也许能推测出这些网站依赖的云服务，从而将重点放在那些更容易出现配置错误的服务上：Akamai
    很好，但 AWS S3（存储服务）和 API Gateway（托管代理）更加有趣，正如我们很快会看到的那样。或者，如果我们知道一个网站位于 AWS 应用负载均衡器后面，例如，我们可以预测某些参数过滤，从而调整我们的有效载荷。更有趣的是，我们可以尝试查找“源”或真实的服务器
    IP 地址，从而绕过中介云服务。
- en: 'Let’s go back to our list of domains and push our DNS recon an extra step to
    find these hidden domains. We want to look for *CNAME* *entries* (name records
    that point to other name records) rather than IP addresses (as the more common
    A records do). The command `getent hosts` pulls these CNAME records:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的域名列表，并将 DNS 调查再推进一步，以找出这些隐藏的域名。我们要寻找 *CNAME* *记录*（指向其他名称记录的名称记录），而不是
    IP 地址（如更常见的 A 记录）。命令 `getent hosts` 可以提取这些 CNAME 记录：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that *thor.mxrads.com* is indeed behind an Akamai distribution point.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，*thor.mxrads.com* 确实位于 Akamai 的分发节点后面。
- en: Not all alternative domains are registered as CNAME records; some are created
    as ALIAS records that do not explicitly show up in the name resolution process.
    For these stubborn cases, we can guess the AWS service by looking up the IP address
    in the public range published in the AWS documentation under General Reference.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有替代域名都注册为 CNAME 记录；有些是作为 ALIAS 记录创建的，在名称解析过程中不会明确显示出来。对于这些顽固的情况，我们可以通过查看
    AWS 文档中发布的公共范围中的 IP 地址来猜测 AWS 服务，这些文档位于常规参考部分。
- en: 'I could not find a simple tool to perform this type of extended DNS reconnaissance,
    so I wrote a script to automate the process: *DNS Charts*, found at [https://dnscharts.hacklikeapornstar.com/](https://dnscharts.hacklikeapornstar.com/).
    We build a list of domains and then feed it to DNS Charts to look for those CNAME
    entries, with some additional regex matching to guess the cloud service. The result
    is printed in a colorful graph that highlights the underlying interactions between
    domains, as well as the main cloud services used by a company. [Figure 5-1](#figure5-1)
    shows some sample output of the tool.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到一个简单的工具来执行这种扩展的 DNS 探测，所以我编写了一个脚本来自动化这个过程：*DNS Charts*，可以在 [https://dnscharts.hacklikeapornstar.com/](https://dnscharts.hacklikeapornstar.com/)
    找到。我们构建一个域名列表，然后将其输入到 DNS Charts 中，查找这些 CNAME 记录，并使用一些额外的正则表达式匹配来猜测云服务。结果会以彩色图表的形式展示，突出显示域名之间的基本交互，以及公司使用的主要云服务。[图
    5-1](#figure5-1) 显示了该工具的一些示例输出。
- en: '![f05001](image_fi/501263c05/f05001.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/501263c05/f05001.png)'
- en: 'Figure 5-1: List of services used by MXR Ads'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：MXR Ads 使用的服务列表
- en: 'One glance at this graph gives us a pretty clear image of the most interesting
    endpoints to target first. The majority of domains we retrieved are hosted on
    AWS and use a mixture of the following services: *CloudFront*, a distribution
    network; *S3*, Amazon’s storage service; and *ELB*, a load balancer. The rest
    use the Akamai distribution network.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一瞥这张图，我们就能清楚地看到首先要关注的最有趣的端点。我们检索到的大多数域名都托管在 AWS 上，并使用以下服务的混合：*CloudFront*，分发网络；*S3*，亚马逊的存储服务；以及
    *ELB*，负载均衡器。其余域名使用 Akamai 分发网络。
- en: Notice how the dashboard URL of GP (top center) points to a domain belonging
    to MXR Ads (bottom left). We were right about their close relationship; it’s even
    reflected in their respective infrastructures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GP（顶部中间）仪表板的 URL 指向一个属于 MXR Ads（底部左侧）的域名。我们关于它们紧密关系的猜测是正确的；这在它们各自的基础设施中得到了体现。
- en: We have a few leads here. For example, the *gretschpol-alb-1463804911.eu-west-1\.
    . .* subdomain refers to an AWS Application Load Balancer (AWS ALB), suggested
    by the *alb* part of the URL. According to AWS documentation, this is a layer
    7 load balancer that’s responsible for distributing incoming traffic. In theory,
    a layer 7 load balancer is capable of parsing HTTP requests and even blocking
    some payloads when linked to the AWS Web Application Firewall (AWS WAF). Whether
    that is indeed the case is open for speculation and will require active probing,
    of course.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一些线索。例如，*gretschpol-alb-1463804911.eu-west-1\. .* 子域名指向一个 AWS 应用负载均衡器（AWS
    ALB），这是由 URL 中的 *alb* 部分提示的。根据 AWS 文档，这是一个第 7 层负载均衡器，负责分配传入的流量。理论上，第 7 层负载均衡器能够解析
    HTTP 请求，甚至在与 AWS Web 应用防火墙（AWS WAF）连接时阻止某些负载。是否真是如此还需要进一步推测，并且当然需要进行主动探测。
- en: The application load balancer can wait, however. We already picked up our list
    of winners the moment we laid eyes on the graph. We will start with the all-too-tempting
    AWS S3 URLs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，应用负载均衡器可以稍等一下。我们一眼就看到了图表，已经找出了我们的获胜者。我们将从那诱人的 AWS S3 URL 开始。
- en: Investigating the S3 URLs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查 S3 URLs
- en: AWS S3 is a highly redundant and cheap storage service offered by Amazon, starting
    at just $0.023 per GB, plus data transfer. Objects stored in S3 are organized
    into *buckets*. Each bucket has a unique name and URL across all AWS accounts
    (see [Figure 5-2](#figure5-2)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AWS S3 是亚马逊提供的高度冗余且廉价的存储服务，起价仅为每 GB $0.023，另外还需支付数据传输费用。存储在 S3 中的对象被组织为 *存储桶*。每个存储桶都有一个独特的名称和
    URL，适用于所有 AWS 账户（见[图 5-2](#figure5-2)）。
- en: '![f05002](image_fi/501263c05/f05002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/501263c05/f05002.png)'
- en: 'Figure 5-2: S3 storage bucket as it appears in the web console'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：S3 存储桶在 Web 控制台中的显示方式
- en: S3 can host anything from JavaScript files to database backups. Following its
    rapid adoption by many companies, both small and massive, one could often hear
    in a meeting when speaking of a random file, “Oh, just put it on S3!”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: S3 可以托管从 JavaScript 文件到数据库备份的任何内容。在许多大大小小的公司快速采用之后，你常常会听到在会议中提到某个随机文件时，人们说：“哦，放到
    S3 上就行！”
- en: This kind of concentration of easily available data on the internet draws hackers
    like bees to a flower, and sure enough, small and prestigious companies alike
    shared the same scandalous journal headlines. Open and vulnerable S3 buckets cost
    these companies terabytes of sensitive data, like customer information, transaction
    histories, and much more. Breaching a company has never been easier. You can even
    find a list of open S3 buckets at [https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集中在互联网上易于获取的数据吸引了黑客，犹如蜜蜂飞向花朵，而事实证明，无论是小公司还是知名企业，都曾因为此事成为丑闻的主角。公开且易受攻击的S3桶让这些公司丢失了数TB的敏感数据，如客户信息、交易历史等。如今，突破一家公司的安全从未如此简单。你甚至可以在[https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/)上找到公开S3桶的列表。
- en: 'Our little DNS graph in [Figure 5-1](#figure5-1) showed that we have four S3
    URLs—dl.mxrads.com, misc.mxrads.com, assets.mxrads.com, and resource.mxrads.com—but
    in fact there may be more to uncover. Before we examine these buckets, we’ll weed
    these out. Sometimes Akamai and CloudFront can hide S3 buckets behind ALIAS records.
    To be thorough, we will loop over the 18 Akamai and CloudFront URLs and take a
    hard look at the `Server` directive in the HTTP response:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图5-1](#figure5-1)中的小型DNS图展示了四个S3 URL——dl.mxrads.com、misc.mxrads.com、assets.mxrads.com和resource.mxrads.com——但实际上可能还有更多需要揭示的内容。在检查这些桶之前，我们先将这些URL过滤掉。有时，Akamai和CloudFront可以通过ALIAS记录隐藏S3桶。为了彻底，我们将遍历18个Akamai和CloudFront的URL，并仔细查看HTTP响应中的`Server`指令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have two more buckets to add to the mix. Great. We proceed to load our first
    bucket URL, dl.mxrads.com (an alias for mxrads-files.s3.eu-west-1.amazonaws.com),
    in the browser, hoping to gain entry to whatever the bucket stores. Unfortunately,
    we immediately get slapped with a rather explicit error:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还要再添加两个桶。太好了。我们接着在浏览器中加载第一个桶的URL：dl.mxrads.com（mxrads-files.s3.eu-west-1.amazonaws.com的别名），希望能够访问桶中的内容。不幸的是，我们立刻被一个相当明确的错误信息拦住了：
- en: '![g05001](image_fi/501263c05/g05001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![g05001](image_fi/501263c05/g05001.png)'
- en: '`Access denied`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`访问被拒绝`。'
- en: Contrary to what this message may suggest, we are not technically forbidden
    from accessing objects in the bucket. We are simply not allowed to list the bucket’s
    content, very much like how the `Options -Indexes` in an Apache server disables
    directory listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个消息可能暗示的相反，我们并没有被技术性地禁止访问桶中的对象。我们只是不能列出桶的内容，就像Apache服务器中的`Options -Indexes`指令禁用了目录列出一样。
- en: S3 Bucket Security
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: S3桶安全性
- en: 'Following one too many scandals involving insecure S3 buckets, AWS has tightened
    up its default access controls. Each bucket now has a sort of public switch that
    the user can easily activate to disallow any type of public access. It might seem
    like a basic feature to have, except that a bucket’s access list is governed by
    not one, not two, not three, but four overlapping settings beneath the public
    switch! How very convoluted. One can almost forgive companies for messing up their
    configuration. These settings are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了一系列关于不安全S3桶的丑闻后，AWS已经收紧了默认的访问控制。现在，每个桶都有一个类似公共开关的功能，用户可以轻松激活它来禁止任何类型的公共访问。这个功能看起来似乎很基础，然而桶的访问列表由不止一个、不止两个、不止三个，而是四个重叠的设置来管理，且都在这个公共开关下！真是复杂到极点。几乎可以原谅公司在配置时出现错误。这些设置如下：
- en: Access control lists (ACLs) Explicit rules stating which AWS accounts can access
    which resources (deprecated).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问控制列表（ACL）明确规定了哪些AWS账户可以访问哪些资源（已弃用）。
- en: Cross-Origin Resource Sharing (CORS) Rules and constraints placed on HTTP requests
    originating from other domains, which can filter based on the request’s user agent
    string, HTTP method, IP address, resource name, and so on.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）是对来自其他域的HTTP请求施加的规则和约束，可以根据请求的用户代理字符串、HTTP方法、IP地址、资源名称等进行筛选。
- en: Bucket policy A JavaScript Object Notation (JSON) document with rules stating
    which actions are allowed, by whom, and under which conditions. The bucket policy
    replaces ACLs as the nominal way of protecting a bucket.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桶策略 一种JavaScript对象表示法（JSON）文档，规则说明了哪些操作是允许的，谁可以执行，在哪些条件下可以执行。桶策略取代了ACL，成为保护桶的名义方式。
- en: Identity and Access Management (IAM) policies Similar to bucket policies, but
    these JSON documents are attached to users/groups/roles instead of buckets.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份与访问管理（IAM）策略 类似于桶策略，但这些JSON文档附加在用户/组/角色上，而不是桶上。
- en: 'Here’s an example of a bucket policy that allows anyone to get an object from
    the bucket but disallows any other operation on the bucket, such as listing its
    contents, writing files, changing its policy, and so on:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个桶策略示例，允许任何人从桶中获取对象，但禁止对桶进行任何其他操作，例如列出其内容、写入文件、更改其策略等：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: AWS combines rules from these four settings to decide whether or not to accept
    an incoming operation. Presiding over these four settings is the master switch,
    called *Block public access*, which when turned on disables all public access,
    even if it’s explicitly authorized by one of the four underlying settings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AWS结合这四个设置的规则来决定是否接受一个传入的操作。主控这些设置的是名为*Block public access*的总开关，当它开启时，会禁用所有公共访问，即使其中某个设置明确授权了公共访问。
- en: Complicated? That’s putting it mildly. I encourage you to set up an AWS account
    and explore the intricacies of S3 buckets to develop the right reflexes in recognizing
    and abusing overly permissive S3 settings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂吗？那真是轻描淡写了。我鼓励你创建一个AWS账户，探索S3桶的复杂性，培养识别和滥用过于宽松S3设置的正确反应。
- en: Examining the Buckets
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查桶
- en: 'Back to our list of buckets. We skim through them and are again denied entry
    for all except *misc.mxrads.com*, which, strangely enough, returns an empty page.
    The absence of error is certainly encouraging. Let’s probe further using the AWS
    command line. First, we install the AWS command line interface (CLI):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的桶列表。我们浏览了一遍，除了*misc.mxrads.com*外，其他都无法访问，奇怪的是，*misc.mxrads.com*返回了一个空白页面。没有出现错误肯定是个好兆头。让我们使用AWS命令行进一步探查。首先，我们安装AWS命令行接口（CLI）：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The AWS CLI does not accept S3 URLs, so we need to figure out the real bucket
    name behind *misc.mxrads.com*. Most of the time, this is as simple as inspecting
    the domain’s CNAME record, which in this case yields mxrads-misc.s3-website.eu-west-1.amazonaws.com.
    This tells us that the bucket’s name is mxrads-misc. If inspecting the CNAME doesn’t
    work, we need more elaborate tricks, such as injecting special characters like
    `%C0` in the URL, or appending invalid parameters, in an attempt to get S3 to
    display an error page containing the bucket name.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI不接受S3 URL，因此我们需要弄清楚*misc.mxrads.com*背后的真实桶名。大多数时候，这个过程非常简单，只需要检查域名的CNAME记录，这个案例中返回的是mxrads-misc.s3-website.eu-west-1.amazonaws.com。这告诉我们桶的名称是mxrads-misc。如果检查CNAME不奏效，我们需要更多的技巧，比如在URL中注入特殊字符如`%C0`，或者附加无效的参数，试图让S3显示包含桶名称的错误页面。
- en: 'Armed with this bucket name, we can leverage the full power of the AWS CLI.
    Let’s start by retrieving a full list of objects present in the bucket and saving
    it to a text file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到这个桶名后，我们可以利用AWS CLI的强大功能。首先，通过命令列出桶内所有对象，并将结果保存到一个文本文件中：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get a lot of objects—too many to manually inspect. To find out exactly how
    many, we grep the `"Key"` parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了很多对象——太多了，无法手动检查。为了确切知道有多少个对象，我们使用grep来查找"Key"参数：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Bingo! We have more than 400,000 files stored in this single bucket. That’s
    as good a catch as they come. In the list of objects, note the empty *index.html*
    at the root of the S3 bucket; an S3 bucket can be set up to act as a website hosting
    static files like JavaScript code, images, and HTML, and this *index.html* file
    is what’s responsible for the blank page we got earlier when running the URL.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 万无一失！我们在这个单一的桶里存储了超过40万个文件。这已经算是一次非常不错的发现了。在对象列表中，注意到S3桶根目录下有一个空的*index.html*文件；S3桶可以被设置为充当静态文件的网站托管，比如JavaScript代码、图片和HTML文件，而这个*index.html*文件就是导致我们之前运行URL时看到空白页面的原因。
- en: 'It’s time for some poor man’s data mining. Let’s use regex patterns to look
    up SQL scripts, bash files, backup archives, JavaScript files, config files, VirtualBox
    snapshots—anything that might give us valuable credentials:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行一些简易的数据挖掘了。让我们使用正则表达式查找SQL脚本、bash文件、备份档案、JavaScript文件、配置文件、VirtualBox快照——任何可能为我们提供有价值凭证的内容：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This gives us a list of files with some potential. We then download these candidates
    using `aws s3api get-object` and methodically go through each of them, hoping
    to land on some form of valid credentials. An interesting fact to keep in mind
    is that AWS does not log S3 object operations like `get-object` and `put-object`
    by default, so we can download files to our heart’s content with the knowledge
    that no one has tracked our movements. Sadly, that much cannot be said of the
    rest of the AWS APIs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一些潜在的文件列表。然后我们使用`aws s3api get-object`下载这些候选文件，并系统地逐一检查它们，希望能够找到某种有效的凭证。一个值得注意的事实是，AWS
    默认不记录 S3 对象操作，如 `get-object` 和 `put-object`，因此我们可以尽情下载文件，知道没有人会跟踪我们的行为。遗憾的是，AWS
    的其他 API 并非如此。
- en: Hours of research later and we still have nothing, zip, nada. It seems most
    of the scripts are old three-liners used to download public documents, fetch other
    scripts, automate routine commands, or create dummy SQL tables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 几小时的研究后，我们仍然一无所获，什么都没有。似乎大多数脚本都是旧的三行代码，用于下载公共文档、获取其他脚本、自动化例行命令或创建虚拟 SQL 表。
- en: 'Time to try something else. Maybe there are files with sensitive data that
    escaped our previous pattern filter. Maybe files with uncommon extensions hiding
    in the pile. To find these files, we run an aggressive inverted search that weeds
    out common and useless files like images, Cascading Style Sheets (CSS), and fonts
    in an effort to reveal some hidden gems:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试一些其他的方法了。也许有些敏感数据文件逃过了我们之前的模式过滤，也许有些带有不常见扩展名的文件藏在一堆文件中。为了找到这些文件，我们进行了一次激进的反向搜索，排除了常见且无用的文件，如图片、层叠样式表（CSS）和字体，试图揭示一些隐藏的宝藏：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: HTML files are not exactly the special files we had in mind, but since they
    represent more than 75 percent of the files in this bucket, we’d better take a
    look. Opening them up, we see that they appear to be saved pages from news websites
    around the world. Somewhere in this messy GP infrastructure, an application is
    fetching web pages and storing them in this bucket. We want to know why.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文件并不是我们所期望的特殊文件，但由于它们占据了此存储桶中超过 75% 的文件，我们最好还是看一下。打开这些文件，我们看到它们似乎是来自世界各地新闻网站保存的页面。在这个混乱的
    GP 基础设施中，某个应用程序正在抓取网页并将它们存储在这个存储桶里。我们想知道这是为什么。
- en: Remember in the Introduction when I spoke about that special *hacker flair*?
    This is it. This is the kind of find that should send tingling sensations down
    your spine!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在引言中我提到的那个特别的*黑客风采*吗？这就是它。这样的发现应该会让你脊背发凉！
- en: Inspecting the Web-Facing Application
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查面向 Web 的应用程序
- en: 'Where is this damn application hiding? To weed it out, we go back to our DNS
    reconnaissance results from [Figure 5-1](#figure5-1) and, sure enough, the perfect
    suspect jumps out screaming from the lot: *demo.mxrads.com*. We saw the same “demo”
    keyword in the S3 keys with HTML files. We didn’t even have to grep.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个该死的应用程序藏在哪里？为了找出它，我们回到[图 5-1](#figure5-1)中的 DNS 侦察结果，果然，一个完美的嫌疑人从一堆中跳了出来，直截了当地出现在眼前：*demo.mxrads.com*。我们在包含
    HTML 文件的 S3 键中也看到了相同的“demo”关键字。我们甚至不需要使用 `grep`。
- en: We enter *demo.mxrads.com* in the browser and see that the main image and headline
    seem to describe the behavior we were looking for (see [Figure 5-3](#figure5-3)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中输入*demo.mxrads.com*，看到主页的图片和标题似乎描述了我们正在寻找的行为（见[图 5-3](#figure5-3)）。
- en: '![f05003](image_fi/501263c05/f05003.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/501263c05/f05003.png)'
- en: 'Figure 5-3: Home page of demo.mxrads.com'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：demo.mxrads.com 的首页
- en: To take a closer look at this page, we’ll fire up Burp Suite, a local web proxy
    that conveniently intercepts and relays every HTTP request coming from our browser
    (OWASP fans can use ZAP, the Zed Attack Proxy). We reload *demo.mxrads.com* with
    Burp running and see the requests made by the site trickling down in real time,
    as shown in [Figure 5-4](#figure5-4).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更仔细地查看这个页面，我们启动了 Burp Suite，这是一款本地 Web 代理，方便地拦截并转发来自浏览器的每个 HTTP 请求（OWASP 粉丝可以使用
    ZAP，Zed 攻击代理）。我们在运行 Burp 的情况下重新加载*demo.mxrads.com*，并看到网站发出的请求实时流出，如[图 5-4](#figure5-4)所示。
- en: '![f05004](image_fi/501263c05/f05004.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/501263c05/f05004.png)'
- en: 'Figure 5-4: Burp inspection of the MXR Ads demo page'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：Burp 检查 MXR 广告演示页面
- en: This is a great attack surface. Using Burp, we can intercept these HTTP(S) requests,
    alter them on the fly, repeat them at will, and even configure regex rules to
    automatically match and replace headers. If you’ve ever done a web pentest or
    CTF challenge, you must have used a similar tool. But we’ll set that aside for
    now and continue our investigation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的攻击面。使用 Burp，我们可以拦截这些 HTTP(S) 请求，实时修改它们，随意重复它们，甚至可以配置正则表达式规则自动匹配和替换头信息。如果你曾经做过网页渗透测试或
    CTF 挑战，肯定用过类似的工具。但我们先放一放这个，继续我们的调查。
- en: We return to inspecting the *demo.mxrads.com* site. As we would suspect from
    a company like MXR Ads, this website offers to showcase demo ads on multiple browsers
    and devices, and also on some featured websites like *nytimes.com and *theregister.com*
    (see [Figure 5-5](#figure5-5)). Sales teams around the world likely leverage these
    features to convince media partners that their technology seamlessly integrates
    with any web framework. Pretty clever.*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回检查 *demo.mxrads.com* 网站。正如我们从像 MXR Ads 这样的公司所预料的，这个网站提供在多个浏览器和设备上展示演示广告的功能，还可以在一些知名网站上展示广告，例如
    *nytimes.com* 和 *theregister.com*（见[图 5-5](#figure5-5)）。全球的销售团队可能会利用这些功能来说服媒体合作伙伴，他们的技术可以与任何网页框架无缝集成。真是挺聪明的。
- en: '*![f05005](image_fi/501263c05/f05005.png)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*![f05005](image_fi/501263c05/f05005.png)'
- en: 'Figure 5-5: MXR Ads feature showcasing ads on various popular sites'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：MXR Ads 功能在多个流行网站上展示广告
- en: We’ll inspect the page by trying out the feature. We choose to display an ad
    on the *New York Times* website, and a new content window pops up with a lovely
    ad for a random perfume brand stacked in the middle of today’s NYT’s main page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过尝试这个功能来检查页面。我们选择在 *纽约时报* 网站上展示广告，随后一个新的内容窗口弹出，展示了一个精美的随机香水品牌广告，广告位于今天纽约时报主页的中间。
- en: 'This demo page may seem like a harmless feature: we point to a website, and
    the app fetches its actual content and adds a video player with a random ad to
    show potential clients what MXR Ads can do. What vulnerabilities could it possibly
    introduce? So many . . .'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示页面看起来可能是一个无害的功能：我们指定一个网站，应用程序获取其实际内容，并添加一个带有随机广告的视频播放器，向潜在客户展示 MXR Ads 能做些什么。它可能引入什么漏洞呢？有很多……
- en: Before we look at how to exploit this app, let’s first assess what’s happening
    behind the scenes using Burp Proxy. What happens when we click the NYT option
    to showcase an ad? We see the results in [Figure 5-6](#figure5-6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究如何利用这个应用之前，先用 Burp Proxy 评估一下背后的情况。当我们点击 NYT 选项来展示广告时会发生什么？我们在[图 5-6](#figure5-6)中可以看到结果。
- en: '![f05006](image_fi/501263c05/f05006.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](image_fi/501263c05/f05006.png)'
- en: 'Figure 5-6: The HTTP History tab after we click the NYT option on *demo.mxrads.com*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：我们点击 *demo.mxrads.com* 上的 NYT 选项后，HTTP 历史标签页的内容
- en: We don’t get much HTTP traffic, that’s for sure. Once the web page is loaded,
    the server responds with an “HTTP/1.1 101 Switching Protocols” message, then no
    more communication appears in the HTTP History tab. We need to switch to the WebSockets
    History tab to follow the rest of the exchange.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到太多 HTTP 流量，这点是肯定的。网页加载完成后，服务器以“HTTP/1.1 101 Switching Protocols”消息响应，然后
    HTTP 历史标签页中再没有任何通信。我们需要切换到 WebSockets 历史标签页，以继续跟踪剩余的交换过程。
- en: Interception with WebSocket
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 WebSocket 进行拦截
- en: '*WebSocket* is another communication protocol alongside HTTP, but unlike HTTP
    WebSocket is a full-duplex communication channel. In the regular HTTP protocol,
    each server response matches a client request. The server does not maintain state
    between two requests; rather, the state is handled by cookies and headers, which
    help the backend application remember who is calling which resource. WebSockets
    operate differently: the client and server establish a full-duplex and binding
    tunnel where each one can initiate communications at will. It is not uncommon
    to have several incoming messages for one outgoing message, or vice versa. (For
    more on WebSockets, check out [https://blog.teamtreehouse.com/an-introduction-to-websockets/](https://blog.teamtreehouse.com/an-introduction-to-websockets/).)
    The beautiful aspect of WebSockets is that they do not require HTTP cookies and
    therefore don’t bother supporting them. These are the same cookies that maintain
    the user authentication session! So whenever there is a switch from HTTP to WebSocket
    in authenticated sessions, there is an opportunity to bypass access control by
    directly fetching sensitive resources using WebSocket instead of HTTP—but that’s
    another class of vulnerability for another time. [Figure 5-7](#figure5-7) shows
    our WebSockets History tab.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebSocket* 是一种与 HTTP 并行的通信协议，但不同于 HTTP，WebSocket 是一个全双工通信通道。在常规的 HTTP 协议中，每个服务器响应都对应一个客户端请求。服务器不会在两个请求之间保持状态；而是通过
    cookies 和 headers 来处理状态，这些帮助后端应用程序记住是谁在访问哪个资源。WebSocket 的工作方式不同：客户端和服务器建立一个全双工和绑定的通道，双方都可以随时发起通信。一个
    outgoing 消息可能会对应多个 incoming 消息，反之亦然。（关于 WebSocket 的更多信息，查看 [https://blog.teamtreehouse.com/an-introduction-to-websockets/](https://blog.teamtreehouse.com/an-introduction-to-websockets/)。）WebSocket
    的一个美妙之处在于，它们不需要 HTTP cookies，因此也不需要支持它们。这些 cookies 正是用来维持用户认证会话的！所以当会话从 HTTP 切换到
    WebSocket 时，便有机会通过直接使用 WebSocket 而不是 HTTP 获取敏感资源，从而绕过访问控制——但这属于另一类漏洞，下次再聊。[图 5-7](#figure5-7)
    显示了我们的 WebSocket 历史标签。'
- en: '![f05007](image_fi/501263c05/f05007.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![f05007](image_fi/501263c05/f05007.png)'
- en: 'Figure 5-7: The WebSockets History tab for *demo.mxrads.com*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：*demo.mxrads.com* 的 WebSocket 历史标签
- en: 'The WebSocket communication seems pretty straightforward: each message to the
    server is composed of a URL (*nytimes.com*) followed by metrics related to the
    user’s browser (Mozilla/5.0\. . .), along with an identifier of the ad to display
    (437). Burp cannot replay (*repeat* in Burp terminology) past WebSocket communications,
    so to tamper with the WebSocket message we need to manually trigger it from the
    demo website.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 通信看起来相当简单：每条发往服务器的消息都由一个 URL（*nytimes.com*）组成，后面跟着与用户浏览器相关的指标（Mozilla/5.0...），以及要显示的广告的标识符（437）。Burp
    无法重放（在 Burp 术语中称为 *repeat*）过去的 WebSocket 通信，因此要篡改 WebSocket 消息，我们需要从 demo 网站手动触发它。
- en: We turn on intercept mode in the Burp options, which will allow us to catch
    the next message exchanged and update it on the fly (see [Figure 5-8](#figure5-8)).
    For instance, let’s see if we can get the MRX Ads site to fetch the home page
    of that Nginx container we set up in Chapter 3.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Burp 选项中开启拦截模式，这将允许我们捕捉下一个交换的消息，并实时更新（见 [图 5-8](#figure5-8)）。例如，让我们看看是否能让
    MRX Ads 网站获取我们在第 3 章设置的 Nginx 容器的主页。
- en: '![f05008](image_fi/501263c05/f05008.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![f05008](image_fi/501263c05/f05008.png)'
- en: 'Figure 5-8: Intercepting a web page in Burp'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：在 Burp 中拦截网页
- en: 'We forward the modified request and head to our Docker container to explore
    the logs. We grab the container ID using `docker ps` and then feed it to `docker
    logs`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改后的请求转发，并前往我们的 Docker 容器查看日志。我们使用 `docker ps` 获取容器 ID，然后将其传递给 `docker logs`：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The MXR Ads app does indeed fetch URLs in real time! Why is that so awesome,
    you ask? Well, not all domains and IP addresses were created equal, you see. Some
    IP addresses have particular purposes. A perfect example is the 127.0.0.0/8 block
    that refers to the loopback address (the host itself), or 192.168.0.0/16, which
    is reserved for private networks. One lesser-known IP address range is 169.254.0.0/16,
    which is reserved by the Internet Engineering Task Force (IETF) for link-local
    addressing, meaning this range is only valid for communication inside a network
    and cannot be routed to the internet. Whenever a computer fails to acquire an
    IP address through DHCP, for instance, it assigns itself an IP in this range.
    More importantly, this range is also used by many cloud providers to expose private
    APIs to their virtual machines, so they become aware of their own environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MXR Ads 应用确实实时获取 URL！你问为什么这么厉害？嗯，并不是所有的域名和 IP 地址都是一样的，你知道吗？某些 IP 地址有特定的用途。一个典型的例子是
    127.0.0.0/8 阻止，它指向回环地址（即主机自身），或者 192.168.0.0/16，这是为私有网络保留的。一个较少为人知的 IP 地址范围是 169.254.0.0/16，这是由互联网工程任务组（IETF）为链路本地寻址保留的，这意味着这个范围仅对网络内部的通信有效，不能路由到互联网。例如，每当一台计算机无法通过
    DHCP 获取 IP 地址时，它会自行为自己分配一个该范围内的 IP 地址。更重要的是，这个范围还被许多云服务提供商用于将私有 API 暴露给它们的虚拟机，以便它们了解自己的环境。
- en: On almost all cloud providers, a call to the IP 169.254.169.254 is routed to
    the hypervisor and retrieves information about internal matters such as the machine’s
    hostname, internal IP, firewall rules, and so forth. This is a trove of metadata
    that could give us a sneak peek into the company’s internal architecture.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有的云服务提供商中，调用 IP 地址 169.254.169.254 会被路由到虚拟机监控程序，并获取有关内部事项的信息，如机器的主机名、内部
    IP 地址、防火墙规则等。这是一个包含大量元数据的宝库，可以让我们一窥公司的内部架构。
- en: 'Let’s give it a go, shall we? With Burp intercept mode still on, we trigger
    another WebSocket message to showcase an ad on the *New York Times*, but this
    time we replace the URL in the message body with the default AWS metadata URL,
    *http://169.254.169.254/latest*, as shown next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来试试吧，怎么样？在 Burp 截取模式仍然开启的情况下，我们触发另一个 WebSocket 消息，以在《纽约时报》上展示一个广告，但这次我们将消息体中的
    URL 替换为默认的 AWS 元数据 URL，*http://169.254.169.254/latest*，如下面所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We wait for a response from the server—remember it’s asynchronous—but nothing
    comes back.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待服务器的响应——记住它是异步的——但什么也没有返回。
- en: 'MXR Ads is not making things easy for us. It’s reasonable to assume that the
    URL is explicitly banned in the app for precisely this reason. Or maybe the app
    simply expects a valid domain? Let’s replace the metadata IP with a more innocuous
    IP (for instance, that of our Nginx container):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MXR Ads 并没有让事情变得简单。可以合理推测，应用中明确禁止了该 URL，正是出于这个原因。或者也许应用只是期望一个有效的域名？我们可以将元数据
    IP 替换为一个更无害的 IP 地址（例如我们 Nginx 容器的 IP）：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We check the logs and, sure enough, we see the request from the app coming
    through:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查日志，果然，看到来自应用的请求传了过来：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Okay, so some IP addresses are allowed, but 169.254.169.254 must be explicitly
    banned by the app. Time to whip out our bag of dirty string-parsing tricks. Though
    IP addresses are commonly expressed in decimal format, browsers and web clients
    are in fact happy with more esoteric representations, like hexadecimal or octal.
    For instance, all the following IP addresses are equivalent:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有些 IP 地址是被允许的，但 169.254.169.254 必须在应用中被明确禁止。是时候拿出我们的脏字符串解析技巧了。尽管 IP 地址通常以十进制格式表示，但浏览器和
    Web 客户端实际上也能接受更为冷门的表示法，比如十六进制或八进制。例如，以下所有的 IP 地址是等效的：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can try to get around the IP address ban by trying out its hex, dotted hex,
    and octal alternatives.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过尝试其十六进制、点分十六进制和八进制的替代形式来绕过 IP 地址禁令。
- en: In this case, simple hexadecimal formatting does the job, and we get the famous
    output of AWS’s metadata API, as shown in [Figure 5-9](#figure5-9).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，简单的十六进制格式化即可完成任务，我们得到了 AWS 元数据 API 的著名输出，如 [图 5-9](#figure5-9) 所示。
- en: '![f05009](image_fi/501263c05/f05009.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f05009](image_fi/501263c05/f05009.png)'
- en: 'Figure 5-9: Output of the AWS metadata URL'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：AWS 元数据 URL 的输出
- en: In the Raw section at the bottom of [Figure 5-9](#figure5-9), the strings 1.0,
    2007-01-19, 2007-03-01, and so on are the different versions of the metadata endpoint.
    Rather than specify a specific date, we can use the keyword */latest* in the path
    to get the most data possible, as we’ll see in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-9](#figure5-9) 的底部的 Raw 部分，字符串 1.0、2007-01-19、2007-03-01 等是元数据端点的不同版本。我们可以使用路径中的关键字
    */latest* 来获取尽可能多的数据，而不是指定特定的日期，正如我们将在下一节中看到的。
- en: This output, of course, confirms that we have a valid case for server-side request
    forgery. Time for some damage!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出当然确认了我们有一个有效的服务器端请求伪造案例。是时候造成一些损害了！
- en: Server-Side Request Forgery
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端请求伪造
- en: A *server-side request forgery (SSRF**)* attack involves us forcing some server-side
    application to make HTTP requests to a domain of our choosing. This can sometimes
    grant us access to internal resources or unprotected admin panels.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器端请求伪造（SSRF）* 攻击是指我们强迫某些服务器端应用向我们选择的域发起 HTTP 请求。这有时能让我们访问内部资源或未受保护的管理员面板。'
- en: Exploring the Metadata
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索元数据
- en: We start gathering basic information about the machine running this web page–fetching
    application, again using Burp’s intercept mode. After intercepting our request,
    we substitute the hex-encoded metadata IP for the originally requested URL and
    then append AWS’s metadata API name to the end, as shown in [Listing 5-1](#listing5-1).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始收集关于运行此网页获取应用程序的机器的基本信息，再次使用 Burp 的拦截模式。在拦截我们的请求后，我们将十六进制编码的元数据 IP 替换为原始请求的
    URL，然后将 AWS 的元数据 API 名称附加到末尾，如 [Listing 5-1](#listing5-1) 所示。
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-1: Basic information on the web app, pulled from the metadata API'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-1：从元数据 API 获取的 Web 应用基本信息
- en: From this we see that the demo app is running in the `eu-west-1` region, indicating
    one of Amazon’s datacenters in Ireland. There are dozens of regions available
    in AWS. While companies strive to distribute their most important applications
    across multiple regions, auxiliary services and sometimes backends tend to concentrate
    in a subset of regions. The instance ID, a unique identifier assigned to each
    virtual machine spawned in the EC2 service, is `i-088c8e93dd5703ccc` 1. This information
    can come in handy when executing AWS API calls targeting the machine running the
    ad application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们看到示范应用运行在 `eu-west-1` 区域，这表示它位于亚马逊位于爱尔兰的数据中心之一。AWS 提供了数十个区域。尽管公司努力将其最重要的应用分布在多个区域，但辅助服务和有时的后端通常会集中在少数几个区域中。实例
    ID 是分配给每个在 EC2 服务中启动的虚拟机的唯一标识符，其值为 `i-088c8e93dd5703ccc` 1。当执行针对运行广告应用程序的机器的 AWS
    API 调用时，这些信息可能会非常有用。
- en: The image ID `ami-02df9ea15c1778c9c` 2 refers to the snapshot used to run the
    machine, such as an Ubuntu or CoreOS image. Machine images can be public (available
    to all AWS customers) or private (available only to specific accounts). This particular
    AMI ID is private, as it cannot be found on the AWS EC2 console. Had the AMI ID
    not been private, we could have spawned a similar instance of the snapshot to
    test future payloads or scripts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像 ID `ami-02df9ea15c1778c9c` 2 指的是用于运行该机器的快照，例如 Ubuntu 或 CoreOS 镜像。机器镜像可以是公开的（所有
    AWS 客户都可用）或私有的（仅对特定账户可用）。这个特定的 AMI ID 是私有的，因为它无法在 AWS EC2 控制台上找到。如果该 AMI ID 不是私有的，我们本可以启动该快照的类似实例来测试未来的有效载荷或脚本。
- en: 'Finally, the public hostname gives us a direct route to the machine running
    the demo application (or *EC2 instance* in AWS jargon), provided local firewall
    rules allow us to reach it. This machine’s public IP can be deduced from its canonical
    hostname: `3.248.221.147` 3.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，公共主机名为我们提供了直接通往运行示范应用程序（或 AWS 行话中的 *EC2 实例*）的路径，前提是本地防火墙规则允许我们访问它。该机器的公共
    IP 可以从其规范主机名推导出来：`3.248.221.147` 3。
- en: Speaking of network configuration, let’s pull the firewall configuration from
    the metadata API, as shown in [Listing 5-2](#listing5-2). Understanding what firewall
    rules exist can give you hints about other hosts that interact with this system
    and what services may be running on it, even if they aren’t publicly accessible.
    Firewall rules are managed in objects called *security groups*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 说到网络配置，让我们从元数据 API 获取防火墙配置，如 [Listing 5-2](#listing5-2) 所示。了解现有的防火墙规则可以帮助我们推测出与该系统交互的其他主机以及可能运行的服务，即使它们并不对外公开。防火墙规则由名为
    *安全组* 的对象进行管理。
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-2: Firewall configuration of the web app'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-2：Web 应用的防火墙配置
- en: We need the network’s MAC address to retrieve network information from the metadata
    API. The AWS account owner is used to build *Amazon Resource Names* *(ARNs**)*,
    which are unique identifiers for users, policies, and pretty much every resource
    on AWS; this is essential information that will prove useful in future API calls.
    The ARN is unique per account, so MXR Ads’ account ID is and will remain 886371554408
    for everything—even though a company may and often will have multiple AWS accounts,
    as we will later see.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要网络的 MAC 地址来从元数据 API 中检索网络信息。AWS 账户所有者用于构建 *Amazon 资源名称* *(ARNs)*，这是用于标识用户、策略和几乎所有
    AWS 资源的唯一标识符；这些信息在未来的 API 调用中非常有用。ARN 对每个账户都是唯一的，因此 MXR Ads 的账户 ID 是并将始终保持 886371554408
    —— 即使一个公司可能且通常会有多个 AWS 账户，正如我们稍后会看到的那样。
- en: 'We can only list the security groups’ names and not the actual firewall rules,
    but that already carries enough information to guess the actual firewall rules.
    The `elb` section in the `elb_http_prod_eu-west-1` set, for example, indicates
    that this set most likely grants the load balancer access to the server. The third
    security group is interesting: `common_ssh_private-eu-west-1`. Based on its name,
    it’s safe to assume that only a select few machines, usually called *bastions*,
    have the ability to connect through SSH to the rest of the infrastructure. If
    we can somehow land on one of these precious instances, that would open up many,
    many doors! It’s funny how we are still stuck outside the organization yet can
    already get a sense of its infrastructure design ideas.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能列出安全组的名称，而不能列出实际的防火墙规则，但这已经提供了足够的信息来推测实际的防火墙规则。例如，`elb_http_prod_eu-west-1`
    集合中的 `elb` 部分表明该集合很可能允许负载均衡器访问服务器。第三个安全组很有趣：`common_ssh_private-eu-west-1`。根据其名称，可以合理推测只有少数几台机器，通常被称为
    *bastions*，能够通过 SSH 连接到其余的基础设施。如果我们能够以某种方式进入其中一个珍贵的实例，那将为我们打开许多、许多的门！有趣的是，我们仍然被困在组织外面，但已经能够对其基础设施设计理念有些许了解。
- en: The Dirty Secret of the Metadata API
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据 API 的脏秘密
- en: We are far from done, of course, so let’s kick it up a notch. As we saw in Chapter
    3, AWS offers the possibility to execute a script when the machine boots for the
    first time. This script is usually referred to as *user-data*. We used it to set
    up our own infrastructure and bootstrap Docker containers. Great news—that same
    *user-data* is available via the metadata API in a single query. By sending one
    more request through Burp to the MXR Ads demo app, we can see they sure as hell
    used it to set up their own machines, as shown in [Listing 5-3](#listing5-3).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还远未完成，所以让我们再加把劲。正如我们在第 3 章中看到的，AWS 提供了在机器首次启动时执行脚本的功能。这个脚本通常被称为 *user-data*。我们曾用它来设置自己的基础设施并启动
    Docker 容器。好消息——这个同样的 *user-data* 可以通过元数据 API 通过一次查询获取。通过向 Burp 发送另一个请求到 MXR Ads
    演示应用，我们可以看到他们肯定使用了它来设置自己的机器，如 [示例 5-3](#listing5-3) 所示。
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-3: Snippet of the *user-data* script executed on the machine’s first
    boot'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3：在机器首次启动时执行的 *user-data* 脚本片段
- en: We get a torrent of data streams on the screen, filling our hearts with warm
    and fuzzy feelings. SSRF in all its glory. Let’s inspect what we got with this
    last command.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一大波数据流在屏幕上滚动，心中充满了温暖和愉快的感觉。这就是 SSRF 的辉煌表现。让我们检查一下通过这个命令得到的数据。
- en: In addition to accepting plain bash scripts, *cloud-init* supports the file
    format *cloud-config*, which uses a declarative syntax to prepare and schedule
    boot operations. *Cloud-config* is supported by many distributions, including
    CoreOS, which appears to be the OS powering this machine 1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受普通的 bash 脚本，*cloud-init* 还支持 *cloud-config* 文件格式，它使用声明性语法来准备和调度启动操作。*Cloud-config*
    被许多发行版所支持，包括 CoreOS，看起来它是支持这台机器的操作系统 1。
- en: '*Cloud-config* uses a YAML syntax, which uses whitespace and newlines to delimit
    lists, values, and so on. The *cloud-config* file describes instructions to set
    up services, create accounts, execute commands, write files, and perform other
    tasks involved in boot operations. Some find it cleaner and easier to understand
    than a crude bash script.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cloud-config* 使用 YAML 语法，利用空格和换行符来分隔列表、值等。*cloud-config* 文件描述了设置服务、创建账户、执行命令、写入文件和执行启动操作中其他任务的指令。一些人发现它比粗糙的
    bash 脚本更简洁、更容易理解。'
- en: Let’s break down the most important bits of the *user-data* script we retrieved
    (see [Listing 5-4](#listing5-4)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们检索到的 *user-data* 脚本中最重要的部分（见 [示例 5-4](#listing5-4)）。
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-4: Continuation of the *user-data* script'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4：*user-data* 脚本的继续部分
- en: First, the file sets up a service to be executed at the machine’s boot time
    1. This service pulls the `demo-client` application image 2 and proceeds to run
    the container using a well-furnished `docker` `run` command 3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该文件设置了一个将在机器启动时执行的服务 1。这个服务拉取`demo-client`应用镜像 2，并使用精心配置的`docker` `run`命令
    3 启动容器。
- en: Notice the multiple `--env-file` switches 4 that ask Docker to load environment
    variables from custom text files, one of which is so conveniently named *secrets.env*!
    The million-dollar question, of course, is where are these files located?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，多个`--env-file`开关 4 要求Docker从自定义文本文件加载环境变量，其中一个文件恰巧命名为*secrets.env*！当然，百万美元的问题是，这些文件到底存放在哪里？
- en: 'There is a small chance they are baked directly into the AMI image, but then
    making updates to configuration files would be the Everest of inconvenience for
    MXR Ads. To update a database password, the company would need to bake and release
    a new CoreOS image. Not very efficient. No, chances are the secrets file is either
    dynamically fetched via S3 or embedded directly in the same *user-data* script.
    Indeed, if we scroll a bit further we come across the following snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有可能直接嵌入到AMI镜像中，但如果是那样，更新配置文件对于MXR Ads来说将是登上珠穆朗玛峰般的不便。要更新数据库密码，公司需要制作并发布一个新的CoreOS镜像。这显然效率不高。不，概率更大的是，*secrets.env*文件要么是通过S3动态获取的，要么直接嵌入到相同的*user-data*脚本中。事实上，如果我们继续向下滚动，我们会看到以下片段：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Brilliant. The content of this blob is base64-encoded, so we’ll decode it, decompress
    it, and marvel at its content, as shown in [Listing 5-5](#listing5-5).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 精彩。这段二进制数据经过base64编码，所以我们将解码、解压，并惊叹其内容，如[列表 5-5](#listing5-5)所示。
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-5: A snippet of the decoded *secrets.env* file containing passwords'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5：包含密码的解码*secrets.env*文件片段
- en: Jackpot! The blob has yielded many passwords to access Cassandra clusters (Cassandra
    is a highly resilient NoSQL database usually deployed to handle large-scale data
    with minimal latency). We also get two obscure passwords holding untold promise.
    Of course, passwords alone are not enough. We need the associated host machines
    and usernames, but so does the application, so we can assume the second environment
    file from [Listing 5-4](#listing5-4), *env.file*, should contain all the missing
    pieces.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 赚到了！这个二进制数据包含了多个访问Cassandra集群的密码（Cassandra是一种高度弹性的NoSQL数据库，通常用于处理大规模数据并保持最小的延迟）。我们还得到了两个含有无限潜力的密码。当然，仅凭密码还不够。我们还需要关联的主机和用户名，而应用程序也是如此，因此我们可以假设[列表
    5-4](#listing5-4)中的第二个环境文件*env.file*应包含所有缺失的信息。
- en: Scrolling further down *user-data*, however, we find no definition of *env.file*.
    But we do come across a shell script, *get-region-params.sh*, that seems to reset
    our precious *env.file* (see [Listing 5-6](#listing5-6)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续向下滚动*user-data*时，我们并没有找到*env.file*的定义。但我们确实发现了一个shell脚本*get-region-params.sh*，它似乎会重置我们宝贵的*env.file*（见[列表
    5-6](#listing5-6)）。
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-6: A discovery service that seems to interact with *env.file*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-6：似乎与*env.file*交互的发现服务
- en: It seems likely this script will create *env.file*. Let’s dive into the content
    of *get-region-params.sh*, created three lines below (see [Listing 5-7](#listing5-7)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很可能会创建*env.file*。让我们深入了解三行之后创建的*get-region-params.sh*的内容（见[列表 5-7](#listing5-7)）。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 5-7: The lines in charge of creating *get-region-params.sh* in the
    *user**-**data* script'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：负责在*user-data*脚本中创建*get-region-params.sh*的行
- en: We have another encoded blob 1. Using some `base64` and `gunzip` magic, we translate
    this pile of garbage to a normal bash script that defines various endpoints, usernames,
    and other parameters, depending on the region where the machine is running (see
    [Listing 5-8](#listing5-8)). I will skip over the many conditional branches and
    case switch statements to only print the relevant parts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个编码的二进制数据 1。通过使用一些`base64`和`gunzip`技巧，我们将这堆垃圾转换为一个普通的bash脚本，该脚本定义了各种端点、用户名以及其他参数，具体取决于机器运行的区域（请参见[列表
    5-8](#listing5-8)）。我将跳过许多条件分支和case语句，只打印相关部分。
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-8: A snippet of the decoded *get-region-params.sh* script'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：解码后的*get-region-params.sh*脚本片段
- en: Notice the S3 buckets mxrads-dl 1 and mxrads-misc 2 we came across earlier during
    reconnaissance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在侦查过程中遇到的S3存储桶mxrads-dl 1和mxrads-misc 2。
- en: 'Looking at the script, we can see that the instance is using the metadata API
    to retrieve its own region and build endpoints and usernames based on that information.
    That’s the first step a company will take toward infrastructure resilience: it
    packages an app, nay, an environment, that can run on any hypervisor, in any datacenter,
    in any country. Powerful stuff, for sure, with the caveat, as we are witnessing
    firsthand, that a simple SSRF vulnerability could expose all of the application’s
    secrets to anyone willing to poke at it.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这个脚本，我们可以看到实例正在使用元数据 API 来检索它自己的区域并基于这些信息构建端点和用户名。这是公司朝着基础设施弹性迈出的第一步：它打包了一个应用，甚至是一个环境，能够在任何虚拟化管理程序、任何数据中心、任何国家/地区运行。无疑是强大的东西，但有个警告——正如我们亲眼所见，简单的
    SSRF 漏洞可能暴露应用程序的所有秘密给任何愿意尝试的人。
- en: 'Cross-referencing this file with passwords we got from [Listing 5-5](#listing5-5)
    and making educated guesses based on the variable names, we can reconstruct the
    following credentials:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交叉引用这个文件与我们从[列出 5-5](#listing5-5)获取的密码，并根据变量名进行合理推测，我们可以重建以下凭证：
- en: '**cassandra-delivery.prod.euw1.mxrads.tech**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**cassandra-delivery.prod.euw1.mxrads.tech**'
- en: 'Username: userdc-euw1'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名：userdc-euw1
- en: 'Password: gQMUUHsVuuUyo003jqFU'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码：gQMUUHsVuuUyo003jqFU
- en: '**cassandra-usersync.prod.euw1.mxrads.tech**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**cassandra-usersync.prod.euw1.mxrads.tech**'
- en: 'Username: usersync-euw1'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名：usersync-euw1
- en: 'Password: QZ6bhOWiCprQPetIhtSv'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码：QZ6bhOWiCprQPetIhtSv
- en: Some machines are missing usernames, and other passwords are missing their matching
    hostnames, but we will figure it all out in time. For now, this is everything
    we can fully put together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有些机器缺少用户名，其他密码也缺少相应的主机名，但我们会在时间中慢慢搞清楚。目前，这是我们可以完全整理出来的所有内容。
- en: With this information, the only thing preventing us from accessing these databases
    is basic, boring firewall rules. These endpoints resolve to internal IPs, unreachable
    from the dark corner of the internet where our attack server lies, so unless we
    figure out a way to change these firewall rules or bypass them altogether, we
    are stuck with a pile of worthless credentials.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，唯一阻止我们访问这些数据库的就是基本的、防火墙规则。这些端点解析到内部 IP 地址，无法从我们攻击服务器所在的互联网角落访问，因此除非我们想出改变这些防火墙规则或完全绕过它们的方法，否则我们将被一堆无用的凭证卡住。
- en: 'Well, that’s not entirely true. There is one set of credentials that we haven’t
    yet retrieved, and unlike the previous ones, it is not usually subject to IP restrictions:
    the machine’s IAM role.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不完全正确。我们还没有获取到一组凭证，与之前的凭证不同，它通常不受 IP 限制：机器的 IAM 角色。
- en: On most cloud providers, you can assign a *role* to a machine, which is a set
    of default credentials. This gives the machine the ability to seamlessly authenticate
    to the cloud provider and inherit whatever permissions are assigned to that role.
    Any application or script running on the machine can claim that role, and this
    avoids the nasty habit of hardcoding secrets in the code. Seems perfect . . .
    again, on paper.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数云服务提供商中，你可以为机器分配一个*角色*，这是一组默认凭证。这样机器就能够无缝地进行云提供商身份验证，并继承分配给该角色的任何权限。任何在机器上运行的应用或脚本都可以声明该角色，这样就避免了在代码中硬编码密钥的糟糕习惯。看起来完美……再次强调，仅仅是纸面上的完美。
- en: In reality, when an EC2 machine (or, more accurately, an instance profile) impersonates
    an IAM role, it retrieves a set of temporary credentials that embody that role’s
    privileges. These credentials are made available to the machine through—you guessed
    it—the metadata API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当 EC2 机器（或者更准确地说，是实例配置文件） impersonates IAM 角色时，它会获取一组临时凭证，代表该角色的权限。这些凭证通过——你猜对了——元数据
    API 提供给机器。
- en: 'We call the */latest/meta-data/iam/security-credentials* endpoint to retrieve
    the role’s name:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用*/latest/meta-data/iam/security-credentials* 端点来检索该角色的名称：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that the machine was assigned the demo-role.ec2 role. Let’s pull
    its temporary credentials, again by calling the metadata API:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该机器被分配了 demo-role.ec2 角色。让我们再次通过调用元数据 API 来获取它的临时凭证：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We get the `AccessKeyId` and `SecretAccessKey`, which together form the classic
    AWS API credentials, as well as an access token that validates this set of temporary
    credentials.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`AccessKeyId`和`SecretAccessKey`，它们共同构成了经典的 AWS API 凭证，以及一个验证这组临时凭证的访问令牌。
- en: 'In theory, we can load these keys into any AWS client and interact with MXR
    Ads’ account from any IP in the world using the machine’s identity: demo-role.ec2\.
    If this role allows the machine access to S3 buckets, we have access to those
    buckets. If the machine can terminate instances, now so can we. We can take over
    this instance’s identity and privileges for the next six hours before the credentials
    are reset 1.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以将这些密钥加载到任何 AWS 客户端，并通过机器的身份：demo-role.ec2，在世界上任何 IP 上与 MXR Ads 的账户进行交互。如果该角色允许机器访问
    S3 存储桶，那么我们就可以访问这些存储桶。如果机器可以终止实例，那么我们也可以。我们可以接管该实例的身份和权限，在凭证被重置之前的六个小时内继续使用。
- en: 'When this grace period expires, we can once again retrieve a new set of valid
    credentials. Now you understand why SSRF is my new best friend. Here we register
    the AWS credentials in our home directory under the profile name `demo`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个宽限期到期后，我们可以再次检索到一组新的有效凭证。现在你明白为什么 SSRF 是我新最好的朋友了。在这里，我们将 AWS 凭证注册在主目录下，配置文件名称为
    `demo`：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Seems like we are on a roll! Unfortunately, just as we start to tighten our
    grip around the target, AWS comes at us with yet another blow: IAM.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们有了突破！不幸的是，就在我们开始紧握目标时，AWS 又给我们带来了新的挑战：IAM。
- en: AWS IAM
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS IAM
- en: AWS IAM is the authentication and authorization service, and it can be something
    of a quagmire. By default, users and roles have almost zero privileges. They cannot
    see their own information, like their usernames or access key IDs, because even
    these trivial API calls require explicit permission.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: AWS IAM 是身份验证和授权服务，它可能是一个非常复杂的系统。默认情况下，用户和角色几乎没有任何权限。他们无法看到自己的信息，如用户名或访问密钥 ID，因为即使是这些简单的
    API 调用也需要明确的权限。
- en: 'Obviously, regular IAM users like developers have some basic rights of self-inspection
    so they can do things like list their group membership, but that’s hardly the
    case for an instance profile attached to a machine. When we try to get basic information
    about the role demo-role-ec2, we get an astounding error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，像开发人员这样的普通 IAM 用户拥有一些基本的自查权限，使他们可以列出自己的组成员身份，但对于附加到机器的实例角色来说情况就完全不同了。当我们尝试获取关于角色
    demo-role-ec2 的基本信息时，出现了一个令人震惊的错误：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`aws iam get-role \`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws iam get-role \`'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: An application does not usually evaluate its set of permissions at runtime;
    it just performs the API calls as dictated by the code and acts accordingly. This
    means we have valid AWS credentials, but at the moment we have absolutely no idea
    how to use them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序通常不会在运行时评估它的权限集；它只会执行代码所规定的 API 调用并相应地操作。这意味着我们拥有有效的 AWS 凭证，但目前我们完全不知道如何使用它们。
- en: We’ll have to do some research. Almost every AWS service has some API call that
    describes or lists all its resources (`describe-instances` for EC2, `list-buckets
    for S3, and so on). So, we can slowly start probing the most common services to
    see what we can do with these credentials and work our way up to testing all of
    AWS’s myriad services.`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些研究。几乎每个 AWS 服务都有一些 API 调用，用来描述或列出其所有资源（EC2 的 `describe-instances`、S3
    的 `list-buckets` 等等）。因此，我们可以慢慢开始探测最常用的服务，看看我们可以用这些凭证做什么，然后逐步测试 AWS 的各种服务。
- en: '[PRE27]*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]*'
