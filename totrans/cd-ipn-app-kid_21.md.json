["```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nenum BrickLevel: CGFloat {\n\n    --*snip*\n --\n\n}\n\n// This enum defines the states the game may be in\n\nenum\n GameState {\n\n    case\n notRunning\n\n    case\n running\n\n}\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nvar brickLevel = BrickLevel.low\n\n// The current game state is tracked\n\nvar\n gameState = GameState\n .notRunning\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    gameState\n = .running\n\n    resetSkater()\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    gameState\n = .notRunning\n\n   if score > highScore {\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    startGame\n () // ← Remove this line of code\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    if\n gameState\n != .running\n {\n\n        return\n\n    }\n\n     // Slowly increase the scrollSpeed as the game progresses\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n UIKit\n\nclass\n MenuLayer: SKSpriteNode\n {\n\n}\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nimport\n SpriteKit\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n// Tells the MenuLayer to display a message and to\n\n// optionally display a score\n\nfunc\n display(message: String\n , score: Int\n ?) {\n\n}\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc display(message: String, score: Int?) {\n\n   // Create a message label using the passed-in message\n\n➊\n let\n messageLabel: SKLabelNode\n = SKLabelNode\n (text: message)\n\n   // Set the label's starting position to the left of the menu layer\n\n➋\n let\n messageX = -frame\n .width\n\n➌\n let\n messageY = frame\n .height\n / 2.0\n\n   messageLabel.position\n = CGPoint\n (x: messageX, y: messageY)\n\n➍\n messageLabel.horizontalAlignmentMode\n = .center\n\n   messageLabel.fontName\n = \"Courier-Bold\"\n\n   messageLabel.fontSize\n = 48.0\n\n   messageLabel.zPosition\n = 20\n\n   self\n .addChild\n (messageLabel)\n\n}\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\n   self.addChild(messageLabel)\n\n   // Animate the message label to the center of the screen\n\n ➊\n let\n finalX = frame\n .width\n / 2.0\n\n ➋\n let\n messageAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n ➍\n messageLabel.run\n (messageAction)\n\n}\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nclass MenuLayer: SKSpriteNode {\n\n   // Tells the MenuLayer to display a message and to\n\n   // optionally display a score\n\n   func display(message: String, score: Int?) {\n\n       --*snip*\n --\n\n       messageLabel.run(messageAction)\n\n       // If a score was passed in to the method, display it\n\n       if let\n scoreToDisplay = score {\n\n // Create the score text from the score Int\n\n       let\n scoreString = String\n (format: \"Score: %04d\"\n , scoreToDisplay)\n\n       let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: scoreString)\n\n       // Set the label's starting position to the right\n\n       // of the menu layer\n\n     ➊\n let\n scoreLabelX = frame\n .width\n\n     ➋\n let\n scoreLabelY = messageLabel.position\n .y\n - \n\n           messageLabel.frame\n .height\n\n       scoreLabel.position\n = CGPoint\n (x: scoreLabelX, y: scoreLabelY)\n\n       scoreLabel.horizontalAlignmentMode\n = .center\n\n       scoreLabel.fontName\n = \"Courier-Bold\"\n\n       scoreLabel.fontSize\n = 32.0\n\n       scoreLabel.zPosition\n = 20\n\n       addChild\n (scoreLabel)\n\n       // Animate the score label to the center of the screen\n\n     ➌\n let\n scoreAction = SKAction\n .moveTo\n (x: finalX, duration: 0.3\n )\n\n       scoreLabel.run\n (scoreAction)\n\n    }\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    *--snip--*\n\n    view.addGestureRecognizer(tapGesture)\n\n    startGame\n () // ← Remove this line of code\n\n    // Add a menu overlay with \"Tap to play\" text\n\n ➊\n let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n ➋\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n  ➌\n menuLayer.anchorPoint\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.position\n = CGPoint\n (x: 0.0\n , y: 0.0\n )\n\n   menuLayer.zPosition\n = 30\n\n   menuLayer.name\n = \"menuLayer\"\n\n ➍\n menuLayer.display\n (message: \"Tap to play\"\n , score: nil\n )\n\n   addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc gameOver() {\n\n    --*snip*\n --\n\n    if score > highScore {\n\n        --*snip*\n --\n\n    }\n\n    // Show the \"Game Over!\" menu overlay\n\n    let\n menuBackgroundColor = UIColor\n .black\n .withAlphaComponent\n (0.4\n )\n\n let\n menuLayer = MenuLayer\n (color: menuBackgroundColor, size: frame\n .size\n )\n\n    menuLayer.anchorPoint\n = CGPoint\n .zero\n\n    menuLayer.position\n = CGPoint\n .zero\n\n    menuLayer.zPosition\n = 30\n\n    menuLayer.name\n = \"menuLayer\"\n\n    menuLayer.display\n (➊\n message: \"Game Over!\"\n , ➋\n score: score\n )\n\n    addChild\n (menuLayer)\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n➊\n if\n gameState\n ==\n .running\n {\n\n // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n      }\n\n➋\n } else\n {\n\n      // If the game is not running, tapping starts a new game\n\n   ➌\n if let\n menuLayer: SKSpriteNode\n = childNode\n (withName: \"menuLayer\"\n ) \n\n         as\n ? SKSpriteNode\n {\n\n       ➍\n menuLayer.removeFromParent\n ()\n\n      }\n\n   ➎\n startGame\n ()\n\n  }\n\n}\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc handleTap(tapGesture: UITapGestureRecognizer) {\n\n    if gameState == .running {\n\n       // Make the skater jump if player taps while she is on the ground if skater.isOnGround {\n\n          skater.physicsBody?.applyImpulse(CGVector(dx: 0.0, dy: 260.0))\n\n          run\n (SKAction\n .playSoundFileNamed\n (\"jump.wav\"\n , \n\n              waitForCompletion: false\n ))\n\n       }\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --*snip*\n --\n\n            updateScoreLabelText()\n\n            run\n (SKAction\n .playSoundFileNamed\n (\"gem.wav\"\n , \n\n                waitForCompletion: false\n ))\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc setupPhysicsBody() {\n\n    --*snip*\n --\n\n}\n\nfunc\n createSparks() {\n\n // Find the sparks emitter file in the project's bundle\n\n  ➊\n let\n bundle = Bundle\n .main\n\n  ➋\n if let\n sparksPath = bundle.path\n (forResource: \"sparks\"\n , ofType: \"sks\"\n ) {\n\n       // Create a Sparks emitter node\n\n     ➌\n let\n sparksNode = NSKeyedUnarchiver\n .unarchiveObject\n\n            (withFile: sparksPath) as\n ! SKEmitterNode\n\n     ➍\n sparksNode.position\n = CGPoint\n (x: 0.0\n , y: -50.0\n )\n\n     ➎\n addChild\n (sparksNode)\n\n }\n\n}\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc createSparks() {\n\n    --*snip*\n --\n\n    if let sparksPath = bundle.path(forResource: \"sparks\", ofType: \"sks\") {\n\n        --*snip*\n --\n\n        addChild(sparksNode)\n\n // Run an action to wait half a second and then remove the emitter\n\n     ➊\n let\n waitAction = SKAction\n .wait\n (forDuration: 0.5\n )\n\n     ➋\n let\n removeAction = SKAction\n .removeFromParent\n ()\n\n     ➌\n let\n waitThenRemove = SKAction\n .sequence\n ([waitAction, removeAction])\n\n     ➍\n sparksNode.run\n (waitThenRemove)\n\n }\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater && ![](Image00184.jpg)\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n     ➊\n if let\n velocityY = skater\n .physicsBody\n ?.velocity\n .dy\n {\n\n         ➋\n if\n !skater\n .isOnGround\n && velocityY < 100.0\n {\n\n            ➌\n skater\n .createSparks\n ()\n\n           }\n\n      }\n\n      skater.isOnGround = true\n\n    }\n\n```"]