- en: Chapter 7. Levels, Sound, and More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 关卡、声音与更多
- en: In this chapter, we’ll add a few finishing touches to *Bubble Shooter* and cover
    a few more features of HTML5\. Right now, the bubble grid could fill up the entire
    page in no time, giving players no room to fire bubbles. To prevent this from
    happening, we’ll make the game end if the player adds more than two rows to the
    bottom of the board. We’ll also implement multiple levels and high scores using
    the Local Storage API, smooth out animation with `requestAnimationFrame`, and
    add sound to the game with HTML5\. Let’s start by adding multiple levels and high
    scores.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将为*Bubble Shooter*添加一些收尾工作，并讲解HTML5的更多功能。现在，气泡网格可能会迅速填满整个页面，导致玩家没有空间发射气泡。为了防止这种情况发生，我们将设置当玩家向棋盘底部添加超过两行时，游戏结束。我们还将使用本地存储API实现多个关卡和高分，利用`requestAnimationFrame`平滑动画，并通过HTML5为游戏添加声音。让我们从添加多个关卡和高分开始。
- en: Multiple Levels and High Scores
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个关卡和高分
- en: 'It’s possible to complete a level by clearing out all of the bubbles, but thereafter,
    if you want to play again, you must refresh the browser. Obviously, this is not
    satisfactory for a game, and a few other game flow elements are missing:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一个关卡后，理论上可以通过清除所有气泡来完成，但如果你想重新开始游戏，则必须刷新浏览器。显然，这对于一款游戏来说是不令人满意的，而且还缺少一些其他的游戏流程元素：
- en: A limited supply of bubbles (otherwise, the player can continue firing forever
    and cause the bubble counter to display negative numbers!)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的气泡供应（否则，玩家可以无限发射，导致气泡计数器显示负数！）
- en: A scoring system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个计分系统
- en: End-of-level conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡结束条件
- en: Further levels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续关卡
- en: The game will award points for each bubble popped, and those points will add
    up to the player’s score. We already have the information we need to limit the
    player’s bubble supply, because we count the bubbles, although our count can go
    into negative numbers. To add multiple levels that increase in difficulty, we’ll
    give the player fewer bubbles at each level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将为每个爆破的气泡奖励积分，这些积分将累计到玩家的分数中。我们已经拥有限制玩家气泡供应所需的信息，因为我们在计数气泡，尽管我们的计数可能会变成负数。为了添加多个逐渐增加难度的关卡，我们将在每个关卡给予玩家更少的气泡。
- en: New Game State Variables
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的游戏状态变量
- en: The first steps we need to take are incorporating the bubble counter and creating
    other game state variables. We could create a new object to store all of the game
    state parameters, such as the player’s score, the number of bubbles remaining,
    the level number, and so on. Alternatively, we could store these as variables
    inside the `Game` object. I’ve opted for the latter because there are only three
    values to track. If you need to track more information or if the information to
    track is more complex, it’s best to store the data in its own object to keep *game.js*
    as small and readable as possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是整合气泡计数器并创建其他游戏状态变量。我们可以创建一个新对象来存储所有的游戏状态参数，例如玩家的分数、剩余气泡数、关卡编号等。或者，我们可以将这些作为变量存储在`Game`对象内部。我选择了后者，因为我们只需要追踪三个值。如果你需要追踪更多信息，或者追踪的信息更复杂，最好将数据存储在单独的对象中，以保持*game.js*尽可能简洁和易读。
- en: 'Let’s add a few new variables to the top of the `Game` class and give the player
    a different number of bubbles to complete the level based on the level number:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Game`类的顶部添加一些新变量，并根据关卡编号为玩家提供不同数量的气泡来完成关卡：
- en: '*game.js*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve created new variables for the number of points to award for each bubble
    ➊, the player’s current level ➋, their current score ➌, and a high score ➍. When
    the game starts, we reduce the number of bubbles by 5 for every level the player
    has completed ➎. At the first level, players are given 70 bubbles, at level 2,
    they have 65, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了新的变量来记录每个气泡的奖励积分 ➊、玩家当前的关卡 ➋、他们当前的分数 ➌，以及一个高分 ➍。当游戏开始时，我们会根据玩家已完成的关卡减少5个气泡
    ➎。在第一个关卡，玩家将获得70个气泡，在第二个关卡，他们有65个，以此类推。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You may notice a couple of problems with the way we are calculating the number
    of bubbles available. First, it’s impossible to complete level 14, because the
    number of bubbles the user would be given would be zero at this point. Second,
    the levels leading up to this will be extremely difficult. It’s hard to imagine
    being able to complete a level with 20 or 30 bubbles, let alone only 10 or 15!
    I’ll leave a solution to this problem as an exercise for the end of the chapter.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会注意到我们在计算可用气泡数量时存在一些问题。首先，完成第14关是不可能的，因为此时用户将得到零个气泡。其次，之前的关卡也会变得非常困难。很难想象只用20或30个气泡就能完成一个关卡，更别提只有10或15个了！我将把这个问题的解决方案留给章节最后作为练习。*'
- en: Display Level and Score
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示关卡和分数
- en: We don’t have anywhere to display the score yet, so we’ll add a DOM element
    to *index.html* for that, as well as somewhere to display the current level and
    high score. The bar at the top of the screen is a good place in the layout to
    display that information. The new elements are shown at the top of [Figure 7-1](ch07.html#screen_layout_showing_levelcomma_scoreco
    "Figure 7-1. Screen layout showing level, score, and high score display").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有地方来显示分数，所以我们将在 *index.html* 中添加一个 DOM 元素来显示分数，以及一个显示当前关卡和最高分的地方。屏幕顶部的条形区域是一个很好的布局位置来显示这些信息。新元素如图
    [Figure 7-1](ch07.html#screen_layout_showing_levelcomma_scoreco "图 7-1. 显示关卡、分数和最高分的屏幕布局")
    所示。
- en: '![Screen layout showing level, score, and high score display](httpatomoreillycomsourcenostarchimages2184537.png.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![显示关卡、分数和最高分的屏幕布局](httpatomoreillycomsourcenostarchimages2184537.png.jpg)'
- en: Figure 7-1. Screen layout showing level, score, and high score display
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. 显示关卡、分数和最高分的屏幕布局
- en: '*index.html*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Three new `<div>` elements were added: one each for the level number ➊, the
    current game score ➋, and the high score ➌. Each `<div>` has an element to display
    the label and then a value.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了三个新的 `<div>` 元素：分别用于显示关卡数字 ➊、当前游戏分数 ➋ 和最高分 ➌。每个 `<div>` 都有一个元素来显示标签，然后是一个值。
- en: 'These also need style definitions in *main.css*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也需要在 *main.css* 中定义样式：
- en: '*main.css*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I haven’t styled each of the three elements individually; instead, I’ve given
    them a common class of `top_bar_box` ➊. The basic CSS styling gives each element
    a width of 250 pixels and floats it to the left, so the elements form a row at
    the top of the screen inside `top_bar`. The label and value displayed for each
    element is inside a `<div>`, so the styling for that is applied without creating
    a new CSS class ➋.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有单独为这三个元素分别设置样式；相反，我给它们分配了一个共同的类 `top_bar_box` ➊。基础的 CSS 样式为每个元素设置了 250 像素的宽度，并将其浮动到左侧，因此这些元素会在
    `top_bar` 内部排列成一行，位于屏幕顶部。每个元素显示的标签和值都放在一个 `<div>` 中，因此其样式直接应用在这个 `<div>` 上，而不需要创建新的
    CSS 类 ➋。
- en: 'Now let’s award some points to the player and display their score and level.
    Points need to be awarded and displayed whenever bubbles are popped or orphaned,
    and score and level values should be displayed at the start of the game. First,
    we need functions in *ui.js* to draw the values to the screen. We’ll put them
    inside *ui.js* to continue to keep *game.js* free of display code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为玩家奖励一些分数，并显示他们的分数和关卡。当气泡被戳破或孤立时，需要奖励并显示分数，游戏开始时也应该显示分数和关卡值。首先，我们需要在 *ui.js*
    中编写函数，将这些值绘制到屏幕上。我们将它们放在 *ui.js* 中，以便继续保持 *game.js* 不包含显示代码：
- en: '*ui.js*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`drawScore` ➊ and `drawHighScore` ➋ accept score values and draw them into
    the relevant `<div>`s on the screen. `drawLevel` writes the level number but adds
    1 to it first, because the internal level state starts at zero ➌. Although all
    three of these functions contain only a single line of code, it’s a good idea
    to create separate functions for them and write, for example, `ui.drawScore(score)`
    rather than `$("#score").text(score)` each time you update the score value. Then,
    if you want to add visual effects to any of the elements when they change, you
    can do so in one function without tracking down every instance where the score
    is updated. If you want the score to flash, say, every time it increases, then
    you would only need to make the change in one place.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawScore` ➊ 和 `drawHighScore` ➋ 接受分数值并将其绘制到屏幕上相关的 `<div>` 中。`drawLevel` 写入关卡数字，但首先会加
    1，因为内部关卡状态从零开始 ➌。虽然这三个函数都只有一行代码，但最好为它们创建独立的函数，并且像这样编写 `ui.drawScore(score)`，而不是每次更新分数时都写
    `$("#score").text(score)`。然后，如果你想在元素变化时添加视觉效果，可以只在一个函数中进行修改，而不必追踪每个更新分数的地方。如果你希望分数在每次增加时闪烁，那么你只需要在一个地方进行修改。'
- en: 'Now we add calls to these functions into *game.js* within `startGame` and `clickScreen`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这些函数调用添加到 *game.js* 的 `startGame` 和 `clickScreen` 中：
- en: '*game.js*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We draw the score and level at game start ➊. When bubbles are popped, we first
    want to make a set of all of the bubbles that are both popped and orphaned. This
    is done by concatenating two arrays—the popped list and orphaned list ➋—and then
    multiplying `POINTS_PER_BUBBLE` by the length of the new array ➌. We then increment
    the score internally ➍, but we only update the display once the bubble has finished
    firing at the end of `delay` ➎. If you reload and start the game, your score should
    now increment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏开始时绘制分数和关卡 ➊。当气泡被消除时，我们首先要生成一组所有被消除且孤立的气泡。这通过连接两个数组——已消除的列表和孤立的列表 ➋ 来完成，然后将
    `POINTS_PER_BUBBLE` 乘以新数组的长度 ➌。接着，我们内部增加分数 ➍，但只有在气泡在 `delay` 结束时射击完成后，才会更新显示 ➎。如果你重新加载并开始游戏，你的分数应该会递增。
- en: 'Next, we’ll check for the end game conditions. Two states could result in the
    end game being reached: the player could run out of bubbles to fire, or the player
    could pop all the bubbles in the game board. If the former, then we want to show
    players a final score and have them start a new game at the first level. If the
    latter, then we want to clear the board, increment the level number, and prompt
    to start the next level.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查游戏结束条件。两种状态可能导致游戏结束：玩家可能用尽气泡，或者玩家可能清空了棋盘上的所有气泡。如果是前者，我们希望显示玩家的最终得分，并让他们从第一关开始新游戏。如果是后者，我们希望清空棋盘，增加关卡数，并提示开始下一关。
- en: 'We know that game state only changes as a result of the player firing a bubble,
    so the only place we need to check for possible end game conditions is after we
    calculate the result of any collision. We’ll do this immediately after the bubble
    has been fired, which happens inside `clickGameScreen` inside `Game`. If the board
    is empty or the player has run out of bubbles, we’ll end the game; if not, we’ll
    give the player the next bubble to fire. Make the following change to *game.js*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道游戏状态只会在玩家射出气泡后改变，所以我们唯一需要检查是否存在游戏结束条件的地方是碰撞结果计算之后。我们将在气泡射出后立即进行检查，这个过程发生在
    `Game` 中的 `clickGameScreen` 内。如果棋盘为空或玩家已用尽气泡，我们将结束游戏；如果没有，我们将给玩家下一个要射击的气泡。请在 *game.js*
    中做如下更改：
- en: '*game.js*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We first check to see if the player has run out of bubbles ➊ and then check
    to see if the board is cleared of bubbles ➋. If neither is true, we retrieve the
    next bubble as usual ➌. A new function called `endGame` uses a Boolean to determine
    whether the player has won or lost the level: `false` means the player lost (by
    running out of bubbles), and `true` means the player won (by clearing the board).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查玩家是否已经没有气泡 ➊，然后检查棋盘上是否没有气泡 ➋。如果都不成立，我们将像往常一样获取下一个气泡 ➌。一个名为 `endGame` 的新函数使用布尔值来判断玩家是赢了还是输了：`false`
    表示玩家输了（因为气泡用完了），`true` 表示玩家赢了（因为清空了棋盘）。
- en: 'Note the call to `board.isEmpty`, which is a method that we haven’t written
    yet. Let’s do that now by adding the following into the *board.js* class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用 `board.isEmpty`，这是一个我们尚未编写的方法。现在让我们通过将以下内容添加到 *board.js* 类中来实现它：
- en: '*board.js*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `isEmpty` function checks to see if a call to the `getBubbles` method returns
    any objects. If the array has a length of zero, all the bubbles have been popped.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 函数检查是否调用 `getBubbles` 方法返回任何对象。如果数组的长度为零，则说明所有气泡已被消除。'
- en: The second possible end game condition is if the player adds more than two new
    rows to the bottom of the board. We already have a function, `getRows`, to return
    the array of rows, so we just need to check whether its length is greater than
    the maximum number of rows we’ll permit, which is 11.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可能的游戏结束条件是玩家在棋盘底部添加超过两行新行。我们已经有一个函数 `getRows` 用于返回行数组，所以我们只需要检查其长度是否大于我们允许的最大行数，即
    11。
- en: '*game.js*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To make the code easy to read, we’ll store the maximum number of rows allowed
    in a variable called `MAX_ROWS` ➊ and then we’ll check to see whether the number
    of rows on the board is greater than this number ➋; if so, we’ll end the game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码易于阅读，我们将允许的最大行数存储在一个名为 `MAX_ROWS` 的变量中 ➊，然后我们检查棋盘上的行数是否大于这个数字 ➋；如果是，我们将结束游戏。
- en: We also need to display messages to the player indicating a win or loss, a score,
    and so on. If we have a large number of different messages to show, we might create
    some JavaScript code to dynamically create and display dialogs. But we only have
    a couple of variations, so we’ll hardcode them into the HTML. The dialog we’ll
    show will look the same as the one for starting the game but with more information,
    as shown in [Figure 7-2](ch07.html#end_game_dialog "Figure 7-2. The end game dialog").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向玩家显示一些消息，指示胜利或失败、得分等。如果需要显示大量不同的消息，我们可能会编写一些 JavaScript 代码来动态创建和显示对话框。但我们只有几种变化，因此我们将它们硬编码到
    HTML 中。我们将显示的对话框将与启动游戏时的对话框相同，但会有更多的信息，如图 [7-2](ch07.html#end_game_dialog "图 7-2.
    游戏结束对话框") 所示。
- en: '![The end game dialog](httpatomoreillycomsourcenostarchimages2184539.png.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束对话框](httpatomoreillycomsourcenostarchimages2184539.png.jpg)'
- en: Figure 7-2. The end game dialog
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2. 游戏结束对话框
- en: 'Let’s add the structure for this to *index.html* now:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将结构添加到 *index.html* 文件中：
- en: '*index.html*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our game only ever shows one dialog ➊, which contains a message for the final
    score ➋, whether the level was completed or failed. If the player reaches a new
    high score, we’ll show that message ➌. The Level Failed! ➍ or Level Complete!
    ➎ messages will be shown depending on the situation. Finally, a single button
    will enable the next game to start ➏, which will lead to either the next level
    ➐ or a brand-new game ➑. We can determine after the button has been clicked whether
    the game is being restarted or continued, because we’ll know the current level
    number.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏只会显示一个对话框 ➊，其中包含最终得分的消息 ➋，以及关卡是完成还是失败。如果玩家达到了新的高分，我们将显示该消息 ➌。Level Failed!
    ➍ 或 Level Complete! ➎ 消息将根据情况显示。最后，一个按钮将启用下一场游戏的开始 ➏，这将导致进入下一关 ➐ 或全新游戏 ➑。我们可以在点击按钮后确定是重新开始游戏还是继续进行，因为我们知道当前的关卡编号。
- en: 'When we show the `end_game` dialog, we’ll show or hide the `level_complete`
    or `level_failed` classes, as appropriate, to display the correct messages. Notice
    that the `level_complete` class is attached to both the Level Complete! message
    ➎ and the Next Level button ➐, whereas the `level_failed` class is attached to
    the Level Failed! message ➍ and the New Game button ➑. This will enable us to,
    for example, hide all of the `level_failed` elements with a single jQuery call:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示 `end_game` 对话框时，我们将根据需要显示或隐藏 `level_complete` 或 `level_failed` 类，以显示正确的消息。注意，`level_complete`
    类附加在 Level Complete! 消息 ➎ 和 Next Level 按钮 ➐ 上，而 `level_failed` 类则附加在 Level Failed!
    消息 ➍ 和 New Game 按钮 ➑ 上。这使我们可以通过一次 jQuery 调用隐藏所有 `level_failed` 元素：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is one of the advantages of using HTML and CSS for the user interface,
    and it’s possible because *Bubble Shooter* is a relatively simple game. But even
    if you had a much larger range of messages to show in a dialog, you could still
    use jQuery to create DOM elements and use CSS to style them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 HTML 和 CSS 构建用户界面的一个优点，之所以可行，是因为*泡泡射手*是一个相对简单的游戏。但是，即便你需要在对话框中展示更多的消息，仍然可以使用
    jQuery 来创建 DOM 元素并利用 CSS 进行样式设置。
- en: 'The dialog will inherit some styling from the `dialog` class definition, but
    we need to add some more definitions to *main.css*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框将继承 `dialog` 类定义中的一些样式，但我们需要向 *main.css* 添加更多的定义：
- en: '*main.css*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now want to create the `endGame` function in *game.js*. This will display
    the end-of-game dialog with the appropriate win or lose message and then allow
    the player to either play the next level or start a new game:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要在 *game.js* 中创建 `endGame` 函数。这个函数将显示游戏结束的对话框，显示适当的胜利或失败消息，然后允许玩家继续玩下一关或重新开始新游戏：
- en: '*game.js*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check to see if the player’s score is higher than the value of `highScore`,
    which starts at zero ➊. If so, `highScore` is updated ➋ and we show the `new_high_score`
    element inside the game completion dialog ➌. Then a call to `ui.drawHighScore`
    occurs, which we created when we updated the in-game scoring display ➍. If there
    isn’t a new high score, the message is hidden ➎.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查玩家的分数是否高于 `highScore` 的值，`highScore` 初始值为零 ➊。如果是，`highScore` 将更新 ➋，并且我们会在游戏完成对话框中显示
    `new_high_score` 元素 ➌。然后调用 `ui.drawHighScore`，这是我们在更新游戏内得分显示时创建的 ➍。如果没有新的高分，消息将被隐藏
    ➎。
- en: The next branch checks if the player has won and, if so ➏, increments `level`
    by 1\. If the player lost, `score` and `level` are reset to zero ➐. Then we need
    to enable the `startGame` button again by binding the `click` event to it ➑, clear
    the rest of the bubbles from the display ➒, and call a new method in *ui.js* that
    will display the game over dialog.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的分支检查玩家是否获胜，如果是的话 ➏，则将 `level` 增加 1。如果玩家失败，`score` 和 `level` 会重置为零 ➐。接着，我们需要通过将
    `click` 事件绑定到 `startGame` 按钮上 ➑ 来重新启用它，清除显示中的其余气泡 ➒，并调用 *ui.js* 中的一个新方法来显示游戏结束的对话框。
- en: Note that it doesn’t matter whether the player is playing the first level or
    the fiftieth, because `startGame` just draws the current level and starts the
    game; therefore, we don’t need to create a new function to handle new levels.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论玩家是玩第一个关卡还是第五十个关卡，这都无关紧要，因为 `startGame` 只是绘制当前关卡并开始游戏；因此，我们不需要为新关卡创建一个新函数。
- en: 'But the display isn’t the only part of the game that should react to a game
    over. The player shouldn’t be able to shoot bubbles anymore either! Let’s also
    create a function called `endGame` in *ui.js*. Whereas `endGame` in *game.js*
    deals with the game logic aspects to finishing a level, the code in *ui.js* will
    handle the visual aspects of ending the game, such as showing the dialog and populating
    it with the player’s score:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，显示并不是游戏中唯一需要响应游戏结束的部分。玩家也不应该再能发射气泡！我们还需要在 *ui.js* 中创建一个名为 `endGame` 的函数。与
    *game.js* 中的 `endGame` 处理结束关卡的游戏逻辑方面不同，*ui.js* 中的代码将处理结束游戏的视觉方面，如显示对话框并填充玩家的分数：
- en: '*ui.js*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the game is finished, the `endGame` method ensures that clicks ➊ in the
    game area will no longer trigger the `clickGameScreen` function, because we don’t
    want the player to fire bubbles when the game is over. It also updates the bubbles
    remaining display to zero ➋ and shows the correct win/lose message inside the
    dialog ➌. Then we show the dialog with the messages for Level Complete! or Level
    Failed! inside ➍.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，`endGame` 方法确保在游戏区域的点击 ➊ 不再触发 `clickGameScreen` 函数，因为我们不希望玩家在游戏结束后继续发射气泡。它还会将剩余气泡的显示更新为零
    ➋，并在对话框内显示正确的胜负消息 ➌。然后，我们展示带有“关卡完成！”或“关卡失败！”信息的对话框 ➍。
- en: Ending Levels Efficiently
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效结束关卡
- en: 'Currently, *Bubble Shooter*’s end game can be a bit tedious: the player is
    left firing bubbles until they form groups large enough to pop. This can also
    prove problematic if the bubbles don’t come out in the right color combinations.
    For example, if the only bubble on the board is blue and the randomizer generates
    only red bubbles, the player might fail a level through no fault of their own!
    Rather than expect the player to clear every bubble, we’ll give them a quick ending
    when they clear all but the last five bubbles in the top row. When that happens,
    the remaining top row bubbles will pop, and everything else will drop down as
    if it were an orphaned group (using the `kaboom` routine).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*Bubble Shooter* 的游戏结束可能有点乏味：玩家被迫继续发射气泡，直到它们组合成足够大的群体来爆破。如果气泡的颜色组合不正确，这也可能会成为问题。例如，如果板上的唯一气泡是蓝色的，而随机生成器只生成红色气泡，玩家可能会因无法避免的原因而失败！与其让玩家清除每个气泡，我们会在他们清除完除最上面一排剩余的五个气泡外的所有气泡时，快速结束游戏。当这种情况发生时，剩下的顶行气泡将会爆破，其他气泡会像孤立群体一样掉落（使用
    `kaboom` 例程）。
- en: Anticipate and Alleviate Player Frustrations
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 预见并缓解玩家的挫败感
- en: Always think ahead about how your game could become frustrating and solve the
    problem in advance. By doing so, you’ll improve the game and keep players coming
    back for more. In *Bubble Shooter*, a level could be impossible to complete because
    the bubbles didn’t appear in the correct order. This situation is a perfect example
    of what can happen when a possible outcome—in this case, a *single* bubble being
    left on the board and not being poppable—isn’t considered during the original
    game design. Game programming is almost always iterative, and rarely will your
    first version be the final one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 永远提前考虑你的游戏可能会让玩家感到挫败的地方，并提前解决这个问题。这样，你就能改善游戏体验，让玩家愿意回头继续玩。在 *Bubble Shooter*
    中，某些关卡可能因为气泡没有按正确顺序出现而无法完成。这种情况是一个完美的例子，说明了在原始游戏设计中没有考虑到的可能结果——在这种情况下，剩下一个气泡在板上且无法爆破——会发生什么。游戏编程几乎总是迭代性的，你的第一个版本很少是最终版。
- en: After we calculate the current set to pop, we’ll check how many bubbles are
    left anytime the player pops bubbles. If five or fewer bubbles remain on the board
    after the player has finished firing bubbles, we’ll pop those for free and take
    the player straight to the game’s end.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们计算出当前需要消除的泡泡集合后，每当玩家消除泡泡时，我们会检查剩余的泡泡数量。如果玩家射击泡泡后，棋盘上剩余五个或更少的泡泡，我们会免费消除这些泡泡，并直接带玩家进入游戏结束界面。
- en: 'The check to determine if the level is nearly complete will be inside `clickGameScreen`
    in *game.js*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 判断关卡是否接近完成的检查将会放在`clickGameScreen`函数中，位置在*game.js*文件里：
- en: '*game.js*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we retrieve the top row ➊, and then we loop through it, counting the
    number of bubbles ➋. If five or fewer bubbles are present ➌, we pop all of the
    bubbles in the top row ➍ and add them to the list of popped bubbles ➎ so they
    contribute to the player’s score ➏.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取最上面一行的泡泡 ➊，然后我们遍历这一行，统计泡泡的数量 ➋。如果存在五个或更少的泡泡 ➌，我们会消除这一行的所有泡泡 ➍，并将它们加入已消除泡泡的列表
    ➎，这样它们就会计入玩家的得分 ➏。
- en: You should now be able to play through an entire game level, clear the board,
    and see a prompt to start the next level. Congratulations! You just finished your
    first fully playable game.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够完成一个完整的游戏关卡，清除棋盘，并看到提示开始下一关。恭喜！你刚刚完成了第一个完整可玩的游戏。
- en: But before you put *Bubble Shooter* in front of another player, let’s make the
    high score persist from one session to the next rather than resetting every time
    the browser window is closed. After all, what’s the point of a high score if you
    can’t come back to challenge it later?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在你把*泡泡射手*展示给其他玩家之前，先让我们确保高分在每次游戏会话间持久保存，而不是每次关闭浏览器窗口时都重置。毕竟，如果不能回来挑战高分，那高分还有什么意义呢？
- en: High Score Persistence with Web Storage
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web存储保持高分
- en: Although *Bubble Shooter* has no server-side component to save high scores,
    we can use the Web Storage system that comes with HTML5 to save them to the local
    machine. Players who play again with the same browser will see the previous high
    score, which gives them a target to beat.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*泡泡射手*没有服务器端组件来保存高分，但我们可以利用HTML5提供的Web存储系统将高分保存到本地计算机中。使用相同浏览器再次游戏的玩家将看到上次的高分，这给他们提供了一个挑战目标。
- en: '*Bubble Shooter* is a casual game: the user will open it, play a few levels
    until they fail, and then close the browser tab. Remembering the high score is
    a good idea, but we don’t need to retain any other data. Regardless, the principle
    of using Web Storage to persist data from one game session to the next is the
    same even if you’re storing a much larger amount of information.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*泡泡射手*是一个休闲游戏：玩家会打开它，玩几个关卡直到失败，然后关闭浏览器标签。记住高分是个不错的主意，但我们不需要保留其他数据。无论如何，即使你要存储更多信息，使用Web存储来保持数据从一个游戏会话到另一个会话的持久性原理也是一样的。'
- en: Web Storage vs. Cookies
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web存储与Cookies
- en: On the client side, Web Storage behaves in a similar way to cookies, but the
    implementation details (and advantages) are very different. Web Storage is easier
    to access than cookies are because data is stored in name/value pairs. Unlike
    with cookies, there is no server-side access to the contents of Web Storage, because
    data isn’t transmitted as part of an HTTP request. The contents of the store are
    restricted by domain, so different subdomains have different stores. We could
    store the high score in a cookie, but there’s no reason to do so, and the storage
    format as well as the overhead of transmitting data unnecessarily to the server
    on each request makes a cookie a worse option than Web Storage. Trying to store
    large amounts of data (such as the layout of the current board) in a cookie can
    also cause performance issues, because this data is transmitted to the server
    with each request. For example, when the browser tries to download an image file
    of only a few kilobytes, it could also have to send a large amount of extraneous
    data to the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，Web存储的行为与Cookies类似，但实现细节（以及优点）大不相同。Web存储比Cookies更容易访问，因为数据以名称/值对的形式存储。与Cookies不同，Web存储的内容不会通过HTTP请求传输，因此没有服务器端访问权限。存储的内容受域名限制，不同的子域名拥有不同的存储空间。我们本可以将高分存储在Cookie中，但没有必要这么做，存储格式以及每次请求时不必要地将数据传输到服务器的开销，使得Cookie比Web存储更不合适。尝试将大量数据（例如当前棋盘的布局）存储在Cookie中也可能导致性能问题，因为这些数据会随每个请求一起传输到服务器。例如，当浏览器尝试下载一个仅几KB的图像文件时，可能还会不得不把大量多余的数据一起发送给服务器。
- en: Web Storage, on the other hand, gives you more space than cookies do, although
    the exact amount isn’t defined in the HTML specification and is set individually
    by the browser vendors. The current lowest common figure among the main web browsers
    is 5MB; that limit applies to all data stored within a domain. Google Chrome,
    Firefox, and Internet Explorer 9 on a desktop all provide up to 10MB, but the
    Android browser on phone and tablet devices provides as little as 2MB. Compare
    that with the maximum cookie storage—anything upwards of 300 cookies of 4KB each—and
    you can see that even at the lower limits, Web Storage provides much more storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而 Web 存储提供的空间比 cookies 更多，尽管在 HTML 规范中并未定义具体数量，浏览器厂商单独设定了该限制。目前，主流浏览器之间的最低共同限制是
    5MB；该限制适用于一个域名下的所有数据。桌面版 Google Chrome、Firefox 和 Internet Explorer 9 提供最多 10MB
    的存储，而安卓设备的浏览器仅提供 2MB。与最大 cookie 存储量（每个 cookie 4KB，最多可存储 300 个）相比，即使在最低限制下，Web
    存储提供的空间也大得多。
- en: Because browser limits can change regularly, if you plan to place large amounts
    of data into Web Storage, there’s no substitute for testing on specific devices;
    however, for small elements such as the high score in *Bubble Shooter*, the space
    limits are irrelevant.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器限制可能会定期变化，如果你打算将大量数据存储到 Web 存储中，最好的做法是测试特定设备；然而，对于像 *Bubble Shooter* 这样的高分这种小型元素，空间限制不重要。
- en: Adding Data to Web Storage
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Web 存储中添加数据
- en: 'Web Storage comes in two parts: Session Storage and Local Storage. We’ll only
    look at Local Storage, which is best for persisting data across sessions. The
    principles of storing and accessing data are largely the same for Session Storage,
    although the persistence and security differ slightly. As the name might imply,
    Session Storage only persists for the duration of the browser session. The data
    disappears when the user closes their browser window. This type of storage might
    be useful for a multipage web application where data needs to persist from one
    page to the next, but it’s obviously unsuited to storing a high score. Once you’re
    familiar with Local Storage, you’ll be able to adapt to working with Session Storage
    if you need to use it.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Web 存储分为两部分：会话存储（Session Storage）和本地存储（Local Storage）。我们只看本地存储，它最适合在会话间持久化数据。存储和访问数据的原则在会话存储中大体相同，尽管持久性和安全性有所不同。顾名思义，会话存储仅在浏览器会话期间有效，用户关闭浏览器窗口时数据会消失。这种存储方式可能对多页面的
    Web 应用程序有用，其中数据需要从一页传递到下一页，但显然不适合存储高分。一旦你熟悉了本地存储，你就能够在需要使用会话存储时适应它。
- en: 'The format for adding a piece of data to `localStorage` is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 向`localStorage`添加数据的格式如下：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `key` is a string, such as `"high_score"`, and `value` is also a string,
    or a number or other object that can be automatically converted to a string. Note
    that if you try to pass in a complex object, such as an array, the conversion
    to a string may result in the name of the object (that is, `Array`) rather than
    the data you want to store. So if in doubt, perform a conversion yourself. For
    more complex data, you can use `JSON.stringify` to save objects and `JSON.parse`
    to retrieve them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`是一个字符串，例如`"high_score"`，`value`也是一个字符串，或者是可以自动转换为字符串的数字或其他对象。需要注意的是，如果你尝试传入复杂对象，如数组，转换为字符串可能会得到对象的名称（即`Array`），而不是你想要存储的数据。因此，如果有疑问，最好自己进行转换。对于更复杂的数据，可以使用`JSON.stringify`保存对象，使用`JSON.parse`来检索它们。'
- en: 'To retrieve data, you just need the `key`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，你只需要`key`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`localStorage.getItem` always returns values as strings, so you’ll need to
    use `parseInt` or `parseFloat` to convert them to numerical data.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage.getItem`总是返回字符串值，因此你需要使用`parseInt`或`parseFloat`将其转换为数字数据。'
- en: 'If the game were more complex or took longer to play, you might want to save
    more data, such as the current level as well as the high score. In that case,
    we could just keep on adding strings:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏更复杂或需要更长时间来玩，你可能希望保存更多数据，比如当前关卡以及最高分。在这种情况下，我们可以继续添加字符串：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or we could create an object and JSON encode it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以创建一个对象并对其进行 JSON 编码：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, when we want to retrieve the data, we would use this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们想要检索数据时，我们会使用这个：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The general principle is that if you can convert your data into a string and
    decode it from a string when you want to retrieve it, you can save it to Local
    Storage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一般原则是，如果你能将数据转换为字符串，并且在需要检索数据时从字符串中解码它，你就可以将数据保存到本地存储中。
- en: In *Bubble Shooter*, to save the high score, the Local Storage entry will be
    called `high_score`. At game initialization, we want to check whether an existing
    value is stored and, if so, use that in place of the zero that is currently hardcoded
    in. When the player has set a new record, we’ll set the Local Storage value to
    the new high score.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*泡泡射手*游戏中，为了保存最高分，Local Storage 条目将被命名为`high_score`。在游戏初始化时，我们需要检查是否已有现有的值存储，如果有的话，就使用该值替代当前硬编码的零。当玩家创造新纪录时，我们会将
    Local Storage 中的值更新为新的最高分。
- en: 'In *game.js*, we’ll make additions to `init` and `endGame` to retrieve and
    set the high score:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*game.js*中，我们将对`init`和`endGame`进行修改，以获取并设置最高分：
- en: '*game.js*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we check whether `localStorage` is supported by the browser, by using
    another Modernizr detector, and whether a value for `high_score` exists ➊. If
    a high score exists, we set `highScore` to the contents in the store ➋. We make
    sure to wrap the value with a `parseInt`, because values in the store are returned
    as strings and we want to work with an integer. We then display the high score
    ➌. To save the score, we add a line to `endGame` to check whether `localStorage`
    is supported ➍ and then save to it ➎.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查浏览器是否支持`localStorage`，通过使用另一个Modernizr检测器，查看是否存在`high_score`的值 ➊。如果存在最高分，我们将`highScore`设置为存储中的内容
    ➋。我们确保将该值用`parseInt`包装，因为存储中的值是以字符串形式返回的，而我们想要使用整数。然后，我们展示最高分 ➌。为了保存分数，我们在`endGame`中添加一行，检查是否支持`localStorage`
    ➍，然后将数据保存到其中 ➎。
- en: Reload the browser and play through a game. At first, any score you get should
    become the new high score. But if you close the browser and reload the game, the
    high score should be populated with your previous value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载浏览器并玩一局游戏。首先，任何你得到的分数应该都会成为新的最高分。但如果你关闭浏览器并重新加载游戏，最高分应该会显示为你之前的值。
- en: You could also use Web Storage to save things like language preferences, player
    profiles, or game state progression. Just be mindful of what you store there,
    because the values inside the storage system are open to calls from the JavaScript
    console. That means there’s nothing to stop particularly tech-savvy players from
    updating data themselves! In the next chapter, we’ll briefly discuss security
    issues in HTML5 games, but for now we can rely on the fact that there’s really
    no incentive to set an impossibly high score to try to beat.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Web Storage 来保存像语言偏好、玩家档案或游戏状态进度等内容。只要注意你存储的内容，因为存储系统中的值可以被 JavaScript
    控制台调用。这意味着没有什么能阻止那些技术比较熟练的玩家自己更新数据！在下一章，我们会简要讨论 HTML5 游戏中的安全问题，但目前我们可以依赖这样一个事实：实际上没有人有动力设定一个不可能的高分来挑战。
- en: Smoothing Animations with requestAnimationFrame
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用requestAnimationFrame平滑动画
- en: 'We use `setTimeout` to time animations in *jquery.kaboom.js* and when we trigger
    frame updates in the canvas version of *Bubble Shooter*. `setTimeout` is cross-browser
    compatible and relatively simple: set the timeout value to 40 milliseconds, and
    you can expect 25 frames per second.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*jquery.kaboom.js*中使用`setTimeout`来计时动画，并在*泡泡射手*的画布版本中触发帧更新。`setTimeout`具有跨浏览器兼容性，且相对简单：将超时值设置为40毫秒，就可以达到每秒25帧的效果。
- en: However, there are downsides to using `setTimeout`. The main problem is that
    if the browser is busy with something else, the next iteration may not be called
    for more than 40 milliseconds. In some cases, it might take a lot longer and the
    user will start to notice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`setTimeout`也有一些缺点。主要的问题是，如果浏览器正忙于其他任务，下一个迭代可能会延迟超过40毫秒。在某些情况下，可能需要更长时间，而用户会开始注意到这一点。
- en: We could recode movement so that objects move a distance proportional to the
    time elapsed since the last update, effectively ignoring the 40 millisecond figure.
    But we’d still have to accept the fact that whatever value we set the timeout
    delay to will be too low for some setups and those displays won’t be able to keep
    up. On systems that can handle much faster updates, we could display much smoother
    animations, but if we set the timeout value to 10 milliseconds to handle those
    cases, slower systems will see an adverse effect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新编码移动逻辑，使得对象的移动距离与自上次更新以来的时间成正比，从而有效地忽略40毫秒的时间间隔。但我们仍然需要接受这样一个事实：无论我们将超时延迟设置为多少，一些配置较差的设备可能无法跟上。在能够处理更快更新的系统上，我们可以显示更流畅的动画，但如果我们将超时值设置为10毫秒以应对这些情况，较慢的系统就会出现负面效果。
- en: Fortunately, HTML5 introduced `requestAnimationFrame`, an alternative to `setTimeout`
    that is better suited to animation. Rather than making the programmer guess what
    kind of frame rate *might* work, the browser calls the function passed to `requestAnimationFrame`
    whenever it is ready to draw a new update. The time between updates might be much
    faster (or slower!) than 40 milliseconds, but at least we know that we’re neither
    making a processing logjam worse nor having the system sit idle when we could
    spend extra cycles smoothing the animations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HTML5引入了`requestAnimationFrame`，它是`setTimeout`的替代方案，更适合动画。浏览器不会让程序员去猜测可能适用的帧率，而是每当准备好绘制新更新时，调用传递给`requestAnimationFrame`的函数。更新之间的时间可能比40毫秒快得多（或慢得多！），但至少我们知道我们既不会让处理瓶颈变得更糟，也不会让系统空闲着，而是可以利用额外的处理周期来平滑动画。
- en: A New Perspective on Frame Updates
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于帧更新的新视角
- en: 'We have to think differently about frame updates when switching to `requestAnimationFrame`.
    Currently, *before* `setTimeout` runs, we tell the browser how long to wait. We
    assume that the time elapsed is the time we expected to elapse. For example, in
    `moveAll` in *jquery.kaboom.js*, we set a timeout of 40 milliseconds:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到`requestAnimationFrame`时，我们需要以不同的方式思考帧更新。目前，*在*`setTimeout`运行之前，我们告诉浏览器等待多长时间。我们假设经过的时间就是我们预计要经过的时间。例如，在*jquery.kaboom.js*中的`moveAll`函数中，我们设置了一个40毫秒的超时：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We then update the position of the bubbles assuming that 40 milliseconds—1/25th
    of a second—has elapsed. However, with `requestAnimationFrame`, we don’t specify
    a frame rate. In the `moveAll` function in *jquery.kaboom.js*, if `requestAnimationFrame`
    did happen to run this routine every 40 milliseconds, we wouldn’t need to change
    anything. But if it ran every, say, 20 milliseconds, we couldn’t keep the same
    values of `dx` and `dy`, or our whole animation would run much faster—twice as
    fast, in fact, because it would add `dx` and `dy` twice as often.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们假设已经过去了40毫秒——1/25秒——并更新气泡的位置。然而，在使用`requestAnimationFrame`时，我们并没有指定帧率。在*jquery.kaboom.js*中的`moveAll`函数中，如果`requestAnimationFrame`每40毫秒运行一次这个例程，我们就不需要做任何改变。但如果它每20毫秒运行一次，我们就不能保持相同的`dx`和`dy`值，否则我们的整个动画将运行得更快——实际上是两倍的速度，因为它会以两倍的频率增加`dx`和`dy`。
- en: Instead, we need to find out how many milliseconds have elapsed and then adjust
    our animation step size. We can even apply the same math techniques to `setTimeout`
    animations to get better results on older browsers that don’t support `requestAnimationFrame`.
    As shown in [Figure 7-3](ch07.html#bubble_positions_with_different_frame_ra "Figure 7-3. Bubble
    positions with different frame rates"), the less time that’s elapsed since the
    bubble was last drawn, the less distance we have to move it along its path.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要找出已经过去了多少毫秒，然后调整我们的动画步长。我们甚至可以将相同的数学方法应用于`setTimeout`动画，从而在不支持`requestAnimationFrame`的旧浏览器上获得更好的效果。如[图
    7-3](ch07.html#bubble_positions_with_different_frame_ra "图 7-3. 不同帧率下的气泡位置")所示，自上次绘制气泡以来经过的时间越少，我们就需要沿路径移动气泡的距离越少。
- en: '![Bubble positions with different frame rates](httpatomoreillycomsourcenostarchimages2184541.png.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![不同帧率下的气泡位置](httpatomoreillycomsourcenostarchimages2184541.png.jpg)'
- en: Figure 7-3. Bubble positions with different frame rates
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3. 不同帧率下的气泡位置
- en: Code Compatibility with Polyfills
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码兼容性与Polyfill
- en: 'Modernizr will help us build the `setTimeout` fallback. `requestAnimationFrame`
    is still regarded as prestandards by many browsers, so prefixed versions are available
    for Webkit, Mozilla, and so on, which Modernizr can fill in for us. Add the following
    to *game.js*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr将帮助我们构建`setTimeout`的回退。由于`requestAnimationFrame`仍然被许多浏览器视为标准之前的技术，因此为Webkit、Mozilla等提供了带前缀的版本，而Modernizr可以为我们填充这些前缀。将以下内容添加到*game.js*：
- en: '*game.js*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This single line of new code says that if `requestAnimationFrame` (vendor-prefixed
    if necessary) is defined, then set `window.requestAnimationFrame` to the contents
    of `requestAnimationFrame`. If `requestAnimationFrame` is not defined, then we
    create a new function that accepts a function as a parameter and calls that function
    after 40 milliseconds using `setTimeout`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行新代码表示，如果`requestAnimationFrame`（如有必要，带厂商前缀）已定义，则将`window.requestAnimationFrame`设置为`requestAnimationFrame`的内容。如果`requestAnimationFrame`没有定义，则我们创建一个新函数，接受一个函数作为参数，并在40毫秒后使用`setTimeout`调用该函数。
- en: This technique is known as a *polyfill*. Polyfills attempt to mimic or patch
    in new functionality to a browser where it’s not supported natively, allowing
    you to use new technologies in your code without having to always worry about
    forking your code or providing fallbacks yourself. The name comes from the filling
    substance Polyfilla, because the technique involves filling in the cracks in browser
    support.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为 *polyfill*。Polyfill 尝试在浏览器中模拟或补充新功能，尤其是那些浏览器原生不支持的功能，让你在代码中使用新技术，而不必总是担心需要分叉代码或自行提供回退方案。这个名字来自填充物
    Polyfilla，因为这种技术涉及填补浏览器支持的空白。
- en: 'Polyfills are written to support all kinds of functionality in older browsers.
    For example, to store the player’s high score, we’re using the Local Storage API.
    This isn’t available in older browsers, but we could achieve the same effect by
    storing the data in a cookie. There are two ways to approach this: one way is
    to write an `if/else` statement every time we access Local Storage to check if
    it exists and, if not, branch to run some cookie code. Alternatively, we could
    create an object called `localStorage` and add methods for `getItem` and `setItem`
    that use cookies to save and retrieve data.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfills 被编写来支持旧版浏览器中的各种功能。例如，为了存储玩家的最高分，我们使用了本地存储 API。这在旧版浏览器中不可用，但我们可以通过将数据存储在
    cookie 中来实现相同的效果。有两种方法可以解决这个问题：一种方法是每次访问本地存储时编写 `if/else` 语句，检查是否存在本地存储，如果没有，就分支执行一些
    cookie 代码。另一种方法是创建一个名为 `localStorage` 的对象，并为 `getItem` 和 `setItem` 方法添加使用 cookies
    存取数据的功能。
- en: 'Polyfills are rarely perfect solutions: `setTimeout` and `requestAnimationFrame`
    may operate in very similar ways, but sometimes the differences may be important.
    In the Local Storage example, we might be able to use cookies in exactly the same
    way as Local Storage, but if we tried to store a lot of data, we’d run into problems.
    Polyfills can enhance browser compatibility without a lot of code, but it’s important
    to know the limitations of any polyfill you use.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfills 很少是完美的解决方案：`setTimeout` 和 `requestAnimationFrame` 的操作方式非常相似，但有时这些差异可能是重要的。在本地存储的例子中，我们也许可以像使用本地存储一样使用
    cookies，但如果我们尝试存储大量数据，就会遇到问题。Polyfills 可以增强浏览器兼容性，而无需大量代码，但了解你使用的 polyfill 的局限性也很重要。
- en: Once we have the polyfill for `requestAnimationFrame`, as far as the rest of
    our code is concerned, `requestAnimationFrame` is supported, and we can use it
    regardless of the browser. We know that in truth, a `setTimeout` call is running
    behind the scenes and that sometimes the animation won’t run as smoothly as it
    would with the natively supported `requestAnimationFrame` method. But as far as
    the code that calls it is concerned, the function behaves in the same way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `requestAnimationFrame` 的 polyfill，就像其他代码一样，我们可以在任何浏览器中使用 `requestAnimationFrame`。我们知道实际上
    `setTimeout` 调用在幕后运行，有时动画可能不会像原生支持的 `requestAnimationFrame` 方法那样平滑运行。但是从调用它的代码角度来看，该函数的行为是一样的。
- en: 'Now that we have a working `requestAnimationFrame` polyfill, we can replace
    our calls to `setTimeout` in *game.js* with calls to the new function in `startGame`
    and `renderFrame`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可用的 `requestAnimationFrame` polyfill，我们可以将 *game.js* 中对 `setTimeout`
    的调用替换为 `startGame` 和 `renderFrame` 中对新函数的调用：
- en: '*game.js*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must make similar changes inside *jquery.kaboom.js* to use `requestAnimationFrame`
    rather than `setTimeout`. The `kaboom` function internally assumes that 40 milliseconds
    elapses between frames, giving a frame rate of 25 frames per second, but as we
    now know, with `requestAnimationFrame` the elapsed time may vary. Again, we need
    to calculate how much time has elapsed and calculate movement proportionally:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 *jquery.kaboom.js* 中做类似的修改，使用 `requestAnimationFrame` 替代 `setTimeout`。`kaboom`
    函数内部假设每帧之间的间隔是 40 毫秒，从而实现每秒 25 帧的帧率，但如我们现在所知，使用 `requestAnimationFrame` 时，间隔时间可能会有所不同。同样，我们需要计算已经过去的时间，并按比例计算运动：
- en: '*jquery.kaboom.js*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*jquery.kaboom.js*'
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we define an empty variable called `prevTime` ➊ to store the timestamp
    of the last rendered frame, which is null initially. Each time `moveAll` is called,
    we retrieve the current timestamp ➋ and calculate the time elapsed since the last
    frame ➌. Our initial calculations were based on 40 milliseconds having elapsed,
    so to calculate the correct position, we scale the proportion of the frame elapsed
    accordingly ➍. If only 8 milliseconds have elapsed, `frameProportion` will be
    0.2, and the animation will update in smaller but more frequent steps. If 80 milliseconds
    have elapsed, `frameProportion` will be 2, and the animation will update in larger
    steps. The end effect is that the bubbles take the same time to drop off the screen
    regardless of the frame rate. To prepare for the next frame, we update `prevTime`
    to the current timestamp ➎.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为 `prevTime` 的空变量 ➊，用来存储上次渲染的帧的时间戳，初始值为 null。每次调用 `moveAll` 时，我们获取当前时间戳
    ➋ 并计算自上次帧以来经过的时间 ➌。我们最初的计算基于已经经过了 40 毫秒，因此为了计算正确的位置，我们相应地缩放帧的经过比例 ➍。如果只有 8 毫秒已经过去，`frameProportion`
    将是 0.2，动画会更新得更小且更频繁。如果已经过去 80 毫秒，`frameProportion` 将是 2，动画会以较大的步伐更新。最终效果是，不管帧率如何，气泡都需要相同的时间才能从屏幕上掉落。为了准备下一个帧，我们将
    `prevTime` 更新为当前时间戳 ➎。
- en: 'Also, `setTimeout` is replaced with `requestAnimationFrame` in two places:
    once when the animation is started ➏ and once for each frame loop ➐.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`setTimeout` 在两个地方被 `requestAnimationFrame` 替代：一次是在动画开始时 ➏，一次是在每个帧循环时 ➐。
- en: Reload the game and run it again to make sure it works properly. You probably
    won’t see a difference in performance unless you have a particularly slow browser
    setup. However, now you can be confident that everyone who plays *Bubble Shooter*
    will see bubbles moving and falling at the same speeds, even if the frame update
    rates vary between devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载游戏并再次运行它，确保它正常工作。除非你有特别慢的浏览器设置，否则你可能不会看到性能上的差异。然而，现在你可以放心地知道，所有玩 *Bubble
    Shooter* 的玩家都将看到气泡以相同的速度移动和掉落，即使不同设备之间的帧更新率有所不同。
- en: Adding Sound with HTML5
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML5 添加声音
- en: A game never feels like a game without sound! HTML5 provides some increasingly
    powerful options for processing and playing back audio. I say *increasingly powerful*
    because browser support is being improved all the time. You can manipulate wave
    files byte by byte, record from the microphone, perform dynamic mixing, and take
    advantage of a whole host of features in addition to the woeful audio options
    that HTML offered not long ago. Let’s look at the basic features of HTML5 audio.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没有声音，游戏就不像游戏！HTML5 提供了一些越来越强大的选项来处理和播放音频。我说 *越来越强大* 是因为浏览器的支持一直在不断提升。你可以逐字节操作波形文件、从麦克风录音、进行动态混音，并利用许多其他功能，远远超过
    HTML 以前提供的可悲的音频选项。让我们看看 HTML5 音频的基本功能。
- en: The HTML5 Audio API
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5 音频 API
- en: 'Historically, HTML has implemented audio poorly, offering no reliable way to
    embed and control sounds within web pages. This changed with HTML5, and you can
    embed a sound directly into a page with a simple tag, such as this one:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，HTML 实现音频的方式非常差，没有提供可靠的方式来在网页中嵌入和控制声音。HTML5 改变了这一点，你可以通过一个简单的标签将声音直接嵌入页面，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On its own, this isn’t a lot of help for a game in which we want to programmatically
    start and stop sounds so they can react to events like bubbles popping. Fortunately,
    HTML5 also provides a way to play audio through a JavaScript API without using
    HTML tags at all.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这对于一个我们希望以编程方式启动和停止声音的游戏帮助不大，因为声音需要响应像气泡爆炸这样的事件。幸运的是，HTML5 还提供了一种通过 JavaScript
    API 播放音频的方法，完全不需要使用 HTML 标签。
- en: 'The JavaScript equivalent of the preceding HTML fragment, which just embeds
    and plays a single file, is this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 HTML 片段的 JavaScript 等效版本，它仅嵌入并播放一个单一的文件，如下所示：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can try this with any MP3 file you have. The parameter passed into the `new
    Audio` call is the URL to the sound file. If you place it in the *bubbleshoot*
    folder and change the parameter to the file’s name, you can run the previous command
    in the JavaScript console and the sound should play.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何 MP3 文件来试试这个示例。传递给`new Audio`调用的参数是声音文件的 URL。如果你把它放在*bubbleshoot*文件夹中，并将参数更改为文件名，你可以在
    JavaScript 控制台中运行前面的命令，声音应该会播放。
- en: 'The sound will stop naturally when it ends, and you can use the `stop` method
    to end a sound at any point during playback:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当声音结束时，它会自然停止，你可以使用 `stop` 方法在播放的任何时刻停止声音：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Those are the only commands we need, but take time to look through the audio
    API specification to see the growing potential for sound delivery in browsers.
    As well as methods and properties that affect the basic playback of audio, such
    as changing the volume of a sound or skipping to a specific point in a file, there
    is functionality for recording from input devices, mixing sounds, changing stereo,
    and even 3D sound positioning, as well as ways to post-process sounds to add effects
    such as echo. These are increasingly being supported in mainstream browsers, such
    as Google Chrome and Firefox, with improvements arriving in each new version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要的唯一命令，但可以花时间浏览音频 API 规范，了解浏览器中声音传输的更多潜力。除了影响音频基本播放的各种方法和属性（例如更改音量或跳转到文件中的特定位置）外，还有许多功能，如从输入设备录音、混音、改变立体声，甚至是
    3D 声音定位，以及后期处理音效以添加回声等效果。这些功能越来越多地被主流浏览器支持，例如 Google Chrome 和 Firefox，每个新版本都会带来改进。
- en: 'If you want to play multiple sounds simultaneously, you must create multiple
    `Audio` objects. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时播放多个声音，必须创建多个 `Audio` 对象。例如：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To just play different sounds one after another, you could reuse an `Audio`
    object by changing the object’s `src` property. But to play multiple sounds at
    the same time, you need as many objects in existence as sounds that you plan to
    play simultaneously. As you’ll see in *Bubble Shooter*, this means that if we
    want to pop a group of 20 bubbles, we’ll need 20 sound objects to play the 20
    popping sounds at the same time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是想依次播放不同的声音，你可以通过更改 `Audio` 对象的 `src` 属性来重用该对象。但是，要同时播放多个声音，你需要为计划同时播放的每个声音创建一个
    `Audio` 对象。正如你在 *Bubble Shooter* 中看到的那样，这意味着如果我们想要打破一组 20 个气泡，我们需要 20 个声音对象来同时播放这
    20 个气泡破裂的声音。
- en: 'Popping Bubbles: Complete with Sound'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打破气泡：配上声音
- en: We’ll add HTML5 sound support to *Bubble Shooter* using the audio API so a sound
    plays for each bubble popped. Grab the file *pop.mp3* from *[http://www.buildanhtml5game.com/](http://www.buildanhtml5game.com/)*
    and put it in a new folder called *_mp3* inside the game folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用音频 API 向 *Bubble Shooter* 添加 HTML5 音频支持，使每次气泡被打破时都会播放声音。从 *[http://www.buildanhtml5game.com/](http://www.buildanhtml5game.com/)*
    下载 *pop.mp3* 文件，并将其放入游戏文件夹中的一个名为 *_mp3* 的新文件夹中。
- en: First, create a class to play the sounds. We’ll wrap the HTML5 audio functionality
    in our own code, which will prevent an error from being thrown in browsers that
    don’t support HTML5 audio. Create a new file in the *_js* folder called *sounds.js*
    and then add the file to load in *index.html*. Sound processing, like rendering
    and the user interface, is another piece of functionality that’s best to keep
    separate from game logic wherever possible. By creating a separate file to handle
    playback, we can put all of our sound-handling code in one place.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个类来播放声音。我们将把 HTML5 音频功能封装在我们自己的代码中，这样可以防止在不支持 HTML5 音频的浏览器中抛出错误。在 *_js*
    文件夹中创建一个名为 *sounds.js* 的新文件，然后将其添加到 *index.html* 中。声音处理（如渲染和用户界面）是一个功能模块，最好在可能的情况下将其与游戏逻辑分开。通过创建一个单独的文件来处理播放，我们可以将所有音频处理代码集中在一个地方。
- en: We’ll reuse `Audio` objects, so we’ll create these as the code is initialized.
    Then, whenever a sound needs to play, we’ll pull out the next object in the queue,
    change the `src` to the file we want to play, and then play it. We’ll set a cap
    of 10 sounds that can play simultaneously, which is a low number, but even on
    the rare occasion when a player is popping more than 10 bubbles at a time, there’s
    no need to play more than 10 sounds.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用 `Audio` 对象，因此会在代码初始化时创建这些对象。然后，每当需要播放声音时，我们就从队列中取出下一个对象，将 `src` 属性更改为我们想播放的文件，然后播放它。我们将设置一个最大同时播放声音数为
    10，这是一个较小的数字，但即使在极少数情况下，玩家一次打破超过 10 个气泡，也不需要播放超过 10 个声音。
- en: '*sounds.js*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*sounds.js*'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A new object called `BubbleShoot.Sounds` contains the array `soundObjects` ➊,
    which we’ll use to store the ten `Audio` objects. These are initialized as soon
    as the code is loaded ➋. We also keep track of which object to use with the variable
    `curSoundNum` ➌.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `BubbleShoot.Sounds` 的新对象包含了数组 `soundObjects` ➊，我们将用它来存储十个 `Audio` 对象。这些对象在代码加载后立即初始化
    ➋。我们还通过变量 `curSoundNum` ➌ 来追踪当前使用的对象。
- en: 'Next, we create the object to play the sound ➍, which contains a single method
    to play a sound ➎. It will accept two parameters: the URL of the sound file to
    play and the volume to play the sound at, which is a decimal number between 0
    (silent) and 1 (full volume).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个对象来播放声音 ➍，它包含一个方法来播放声音 ➎。它将接受两个参数：要播放的声音文件的URL和播放声音的音量值，音量值是一个在0（静音）和1（最大音量）之间的十进制数。
- en: We use Modernizr to check whether or not HTML5 audio is supported, and if it
    is, we grab the current `Audio` object from the `soundObjects` array ➏, set its
    `src` property to the URL of the file to play ➐, set its volume ➑, and then play
    it ➒. If audio isn’t supported, the method will do nothing, but because of our
    check for `Modernizr.audio`, no error will be thrown.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Modernizr来检查是否支持HTML5音频，如果支持，我们就从`soundObjects`数组中获取当前的`Audio`对象 ➏，将其`src`属性设置为要播放的文件的URL
    ➐，设置它的音量 ➑，然后播放它 ➒。如果不支持音频，该方法将不做任何操作，但由于我们检查了`Modernizr.audio`，因此不会抛出错误。
- en: Finally, we increment the value of `curSoundNum` ➓ so that next time `play`
    is called, we will grab the next object in the queue. Then, we make sure that
    the value of `curSoundNum` is never greater than the number of `sound` objects
    in the `soundObjects` array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增加`curSoundNum`的值 ➓，这样下一次调用`play`时，我们就能从队列中获取下一个对象。然后，我们确保`curSoundNum`的值永远不会大于`soundObjects`数组中`sound`对象的数量。
- en: If we want to play more sounds, we could push more `Audio` objects into the
    `soundObjects` array. Currently, if we try to play more than 10 sounds at once,
    only the last 10 sounds will play.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想播放更多的声音，可以将更多的`Audio`对象推入`soundObjects`数组。目前，如果我们尝试一次播放超过10个声音，只有最后10个声音会被播放。
- en: 'Sound control will happen inside *game.js* with a call to the `BubbleShoot.Sounds.play`
    function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 音效控制将在*game.js*中通过调用`BubbleShoot.Sounds.play`函数来完成：
- en: '*game.js*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We want to play as many sounds as there are bubbles to pop, and we also want
    to start the sound at the same time we start the animation ➊. We pass the play
    method of `Sounds` two parameters: a relative URL to the MP3 file to play ➋ and
    a volume, which will be a random number between .5 and 1 ➌.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望播放与气泡数量相同的声音，并且还希望在启动动画的同时开始播放声音➊。我们将`Sounds`的播放方法传入两个参数：要播放的MP3文件的相对URL
    ➋ 和音量值，它是一个在0.5到1之间的随机数 ➌。
- en: Increase Immersion with Variety
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 增加沉浸感的多样性
- en: Why do we pass a random volume level? Try passing in a value of 1 and popping
    some bubbles. Then compare this effect to that of the random value. It’s only
    a small change, but the variation in volume provides just enough differentiation
    between each sound to make it slightly less mechanical. We could do other things
    to make the effect even more natural, such as using a set of sounds rather than
    just one MP3 file so not every bubble sounds the same or changing the timing between
    pops so they aren’t evenly spaced. Experimenting to create the most immersive
    experience possible and doing it with minimum effort are tasks you’ll become more
    proficient at as you develop more games.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要传递一个随机的音量值？试着传入一个值为1并弹出一些气泡。然后将这个效果与随机值的效果进行比较。这只是一个小的变化，但音量的变化提供了足够的差异，使得每个声音听起来稍微不那么机械。我们还可以做其他事情使效果更加自然，比如使用一组声音而不是仅仅一个MP3文件，这样就不会每个气泡都听起来一样，或者调整爆泡的时间间隔，让它们不再是均匀间隔的。通过实验来创造最具沉浸感的体验，并以最小的努力做到这一点，是随着你开发更多游戏，你会变得更加熟练的任务。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have a simple sound to add a bit of atmosphere, you’ve finished
    building *Bubble Shooter*! The game should play on older browsers, using CSS for
    positioning and animations, and it will work well on newer browsers that support
    the `canvas` element. We have persistent high scores and audio, and we’ve developed
    the animations in such a way that they should perform well regardless of the player’s
    system speed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了一个简单的声音来增添一些气氛，你已经完成了*Bubble Shooter*的构建！这个游戏应该可以在较旧的浏览器上运行，使用CSS进行定位和动画，并且在支持`canvas`元素的较新浏览器上也能正常运行。我们有持久的高分和音频，并且我们已经以这样的方式开发了动画，使得无论玩家的系统速度如何，它们都应该表现良好。
- en: In the next chapter, we’ll explore some other parts of HTML5 that aren’t directly
    related to the game you just built. You’ll learn some pointers on how to deploy
    your game to Web and mobile environments, and you’ll see what the future holds
    for HTML5.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索一些与您刚刚构建的游戏不直接相关的HTML5的其他部分。你将学习如何将游戏部署到Web和移动环境，并且你将了解HTML5的未来发展方向。
- en: Further Practice
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: Toward the end of each level, the player can only have bubbles of one, two,
    or three colors left on the board. Giving them a bubble of a color that won’t
    match any of these causes the player to waste a shot and can make the game more
    difficult to complete. Change the bubble-generating algorithm so that it gives
    players only bubbles of a color that can potentially form a match. For example,
    if only red and blue bubbles remain, the firing bubble should be either red or
    blue. You will need to amend `getNextBubble` in *game.js* and choose a bubble
    `type` from one of the types that exist in the `Board` object.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个关卡结束时，玩家的棋盘上只能剩下1、2或3种颜色的气泡。如果给他们一个无法与这些颜色匹配的气泡，会导致玩家浪费一次射击，并使游戏更难完成。修改气泡生成算法，使得玩家只能获得可能形成匹配的气泡。例如，如果只剩下红色和蓝色气泡，发射的气泡应该是红色或蓝色。你需要修改
    *game.js* 中的 `getNextBubble` 方法，并从 `Board` 对象中现有的气泡类型中选择一个 `type`。
- en: As noted in [Multiple Levels and High Scores](ch07.html#multiple_levels_and_high_scores
    "Multiple Levels and High Scores"), the game will become unplayable after a few
    levels because the number of bubbles allowed becomes too small. Instead of subtracting
    five bubbles per level, create an algorithm that makes levels progressively harder
    but makes it possible to complete a level. Perhaps the smallest number of fired
    bubbles a player can complete a level in is 30, and we want them to reach this
    level of difficulty on level 15\. Before this point, the step from level 1 to
    2 might be, say, five bubbles fewer, but the step from level 14 to 15 might be
    only one fewer. Write an equation or other method to decrease the number of bubbles
    allowed and increase the difficulty in this way.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如在[多个关卡与高分](ch07.html#multiple_levels_and_high_scores "多个关卡与高分")中所提到的，游戏在经过几个关卡后会变得无法继续，因为允许的气泡数量变得过小。为了避免每个关卡减少五个气泡的设定，可以创建一个算法，使得关卡逐渐变难，但仍然可以完成。比如，玩家能完成一个关卡所需的最少气泡数为
    30，我们希望他们在第 15 关达到这个难度。在这之前，从第 1 关到第 2 关的气泡减少量可能是 5 个，而从第 14 关到第 15 关的减少量可能仅为
    1 个。编写一个方程或其他方法来减少允许的气泡数量，并以此方式增加难度。
- en: Give players an incentive to repeat levels by awarding stars for a completion
    grade instead of the pass or fail condition that currently exists. You could award
    one star whenever the player clears the level, two stars if they clear with more
    than 25 percent of the level’s bubble allocation remaining, and three stars if
    they complete the level by firing only half the bubbles they were given. Add information
    to the level completion dialog to show the player how many stars they earned.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为完成度评分而不是当前的通过或失败条件来激励玩家重复关卡。你可以在玩家通关时奖励 1 星，如果他们在剩余超过 25% 气泡的情况下通关，奖励 2 星；如果他们仅用一半的气泡完成关卡，奖励
    3 星。向关卡完成对话框中添加信息，显示玩家获得了多少星。
- en: Once you’ve added the preceding star system, create a way to store the number
    of stars the player has obtained for each level. Then you can show them not only
    how many stars they’ve attained but also a message when they beat a previous best.
    Currently, we store the number of bubbles remaining, the player’s score, and current
    level number as variables inside `Game`. But now the best approach might be to
    create an object that stores each level and records the number of stars. Save
    this data to Local Storage for when the player returns to the game.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了前述的星级系统，创建一个方法来存储玩家在每个关卡中获得的星数。这样你就可以不仅显示玩家获得的星数，还可以在他们打破之前的最佳成绩时，显示一条消息。目前，我们将剩余气泡数、玩家得分和当前关卡号作为变量存储在
    `Game` 中。但现在，最佳的方法可能是创建一个对象，存储每个关卡并记录星数。将这些数据保存到 Local Storage 中，以便玩家下次返回游戏时使用。
- en: Write a polyfill to add Local Storage support to older browsers using cookies.
    You’ll need to create an object called `window.localStorage`, if one doesn’t already
    exist, and create `getItem` and `setItem` methods.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 polyfill 来为旧版浏览器添加 Local Storage 支持，使用 cookies 实现。如果 `window.localStorage`
    对象不存在，你需要创建它，并实现 `getItem` 和 `setItem` 方法。
