- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PLOTTING, DRAWING, AND A BIT OF SET THEORY
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore how to exploit DrRacket’s ability to display
    graphical information. In particular, we’ll look at various ways of generating
    two-dimensional function plots as well as using some built-in graphics primitives
    (circles, rectangles, and so on) to create more-complex drawings. After introducing
    the basics, we’ll look at a few extended applications, involving set theory, the
    golden spiral, and the game of Nim.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All plotting functions will require the *plot* library, so be sure to execute
    the following before trying any of the examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With that out of the way, let’s begin with something simple and familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '***X-Y Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All two-dimensional plots use the `plot` function. This function takes either
    a single function or a list of functions, and generates a plot for each. Once
    a plot has been generated, if desired, it can be saved as a bitmap by right-clicking
    on the plot and clicking Save Image. . . from the pop-up menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plot` function accepts a number of keyword arguments (all of which are
    optional), but as a minimum, it’s probably a good idea to specify the plot limits
    since DrRacket can’t always determine the proper plot bounds. Here’s an example
    of generating a simple plot of the sine function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 4-1](ch04.xhtml#ch4fig1). Please note that figures
    are shown in grayscale, but when you input the code on your computer, graphs will
    appear in color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Example plot using sine function*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `sin` function is enclosed in a `function` form. The `function`
    is something called a *renderer*; it controls how the function argument passed
    to it gets rendered. The `function` form allows you to add optional keyword parameters
    to control how the individual function is displayed. In this case we specify that
    the sine function is rendered in a blue color.
  prefs: []
  type: TYPE_NORMAL
- en: The following code creates a plot that displays both the sine and cosine functions
    by combining them into a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The resulting plot is shown in [Figure 4-2](ch04.xhtml#ch4fig2). Notice that
    we’ve specified a narrower plot range for the cosine function and added text labels
    to both functions so that they can easily be differentiated on the plot. We’ve
    also overridden the default labels with specific values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: The sine and cosine functions*'
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates some additional plotting capabilities (see [Figure
    4-3](ch04.xhtml#ch4fig3) for the output).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’re using a new `inverse` form in our list of functions to plot.
    This form works by using the y-axis as the axis for the independent variable.
    In this way, we effectively plot the inverse function without actually having
    to derive it algebraically. In addition we’ve specified some additional styles
    to help differentiate the plot curves. The sine curve is printed dotted, and the
    inverse square function is printed with a thicker line. The plot legend has been
    moved to the lower left corner by specifying `#:legend-anchor` ’`bottom-left`
    as an optional value to the `plot` function.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code, you should get something like [Figure 4-3](ch04.xhtml#ch4fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Sine and inverse square*'
  prefs: []
  type: TYPE_NORMAL
- en: Next we take a look at parametric plots.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parametric Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A curve in a plane is said to be parameterized if the coordinates of the curve,
    (x, y), are represented by functions of a variable (or *parameter*), say *t*.
    Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameterizing a Circle**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard definition of a circle centered at the origin is the set of all
    points equidistant from the origin. We can state this definition either algebraically
    as an implicit equation or via a pair of trigonometric expressions as illustrated
    in [Figure 4-4](ch04.xhtml#ch4fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Circle definitions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 4-4](ch04.xhtml#ch4fig4) (a), the circle is defined by this algebraic
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*r*² = *x*² + *y*²'
  prefs: []
  type: TYPE_NORMAL
- en: 'To plot this as an x-y plot, we have to explicitly express *y* in terms of
    *x*, where the positive values of the expression give the top half of the circle
    and the negative values give the bottom half:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p079-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) (b) illustrates defining the circle in terms
    of the parameter *θ*. In this case the x- and y-coordinates of the curve are given
    by the trigonometric expressions cos *θ* and sin *θ* respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: In Racket, parametric curves are defined in terms of a function that takes the
    parameter as its argument and returns a `vector` containing the computed values
    of *x* and *y*. The code below plots both the algebraic and the parametric versions
    of the circles. We’ve offset the parametric version so that it appears to the
    right of the algebraic version (see [Chapter 2](ch02.xhtml) for information on
    the `infix` package and usage of `@` below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ve made use of the `infix` package and the `at-exp` language extension so
    that we can present the algebraic expressions in a more natural form. We begin
    with definitions of the half-circle functions `c1` ➊ and `c2` ➋. The parametric
    version is given as `cp` ➌. Notice that `cp` is housed in a form that begins with
    `parametric` ➍ and a plot range specified as 0 to 2*π*. The output of this code
    is shown in [Figure 4-5](ch04.xhtml#ch4fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Explicit versus parametric plots*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Circles in Motion**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s face it: static circles are pretty boring. In this section we’ll take
    a look at circles in motion. Specifically, we’ll examine the path that a fixed
    point on a circle takes as it rolls along a straight line without slipping. The
    curve that describes this path is called a *cycloid*. We set the scene in [Figure
    4-6](ch04.xhtml#ch4fig6), where a circle of radius *r* has rolled distance *x*
    from the origin. The point of interest is the dot marked with a *P*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Cycloid scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the math needed to create a parametric plot of point *P*
    that lies on a circle with radius *r* rolling without slipping on a straight line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the circle rolls without slipping, the length of the arc from *x* to
    *P* is equal to *d*. We can express this as *d* = *θr*. Thus, as the circle rotates
    by angle *θ*, the x-coordinate of *P* is *d - r*sin*θ*. But *d* = *rθ*, so *x*
    = *rθ - r*sin*θ* = *r*(*θ -* sin*θ*). It’s clear that *y* is simply given by *y*
    = *r*(1 *-* cos*θ*). Here’s the code for the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case we’ve used the `#:samples` keyword to increase the number of samples
    used to generate the plot, giving it a smoother appearance. Here’s the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The plot curve has been superimposed on the original scene setup in [Figure
    4-7](ch04.xhtml#ch4fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Cycloid*'
  prefs: []
  type: TYPE_NORMAL
- en: Later we’ll see how to animate this so that we can actually see it in motion.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Hypocycloid**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Instead of having our circle rolling on a straight line, we could have it rolling
    on another circle. Indeed, if the one circle is larger than the other, we could
    have the smaller circle rolling inside the larger circle. A curve generated in
    this fashion is called a *hypocycloid*. Here we create a parametric plot for a
    hypocycloid based on a circle with radius *r* and a larger circle with radius
    *R* where the smaller circle rolls without slipping in the interior of the larger
    circle. We assume that the larger circle is centered at the origin ([Figure 4-8](ch04.xhtml#ch4fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Hypocycloid setup*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the circle rolls without slipping, the arc length *s* is given by *s*
    = *rθ* = R*ϕ*, so ![Image](../images/p084.jpg). The center of the smaller circle
    (*q* in the diagram) is at a distance *R - r* from the origin. To assist in our
    analysis, we’ve zoomed in on the smaller circle and provided some additional guidelines
    in [Figure 4-9](ch04.xhtml#ch4fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0084-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Setup zoomed in*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0084-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this it’s clear that the x-coordinate of *P* is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0084-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Likewise the y-coordinate of *P* is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p084-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We put this all together in the following Racket code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may enjoy the fruits of our labor in [Figure 4-10](ch04.xhtml#ch4fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Hypocycloid plot*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To whet your appetite to further explore these fascinating curves, here’s another
    question for you: for what ratio of radii is a hypocycloid a straight line?'
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting to the Point***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far we’ve concentrated on generating continuous curves, but what if you
    want to plot individual points? Yes, Grasshopper, this too is possible. A *point*,
    from a plotting perspective, is just a vector with two numbers in it. For example,
    `#(1 2)` is a point. To plot a set of points, you just need to provide the `plot`
    routine a list consisting of vector points. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the output in [Figure 4-11](ch04.xhtml#ch4fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: A face drawn with points*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case we’re using the `parameterize` form, which lets us specify the
    physical size of the plot in pixels (`plot-width` and `plot-height`) and suppress
    the plot labels. Note that the `#:size` keyword parameter is also expressed in
    pixels. The first point list is a single point that we use for the face. The `#:sym`
    keyword argument specifies what type of symbol to use to print the point. We’re
    using a filled circle specified by the symbol ’`fullcircle` for the face. There’s
    a large variety of predefined symbols (search for “known-point-symbols” in the
    documentation), but you may also use a Unicode character or a string.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the ability to plot points, we can connect them together with
    lines using the `line` form. Like points, lines consist of a list of two-element
    vectors. The `plot` routine treats this list as a sequence of line segment end
    points and plots them appropriately. Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is shown in [Figure 4-12](ch04.xhtml#ch4fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Plotting lines and points*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Polar Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Polar plots are created with . . . (you guessed it!) the `polar` form. The
    `polar` form is supplied with a function that returns the distance from the origin
    when supplied with an angle of rotation. The simplest possible function to be
    used in a polar plot is that of a unit circle, which in the guise of a lambda
    expression would be `(`λ `(`θ`) 1)`. A slightly more ambitious example would be
    that of a counterclockwise spiral defined as `(`λ `(`θ`)` θ`)`. Here’s the code
    for both plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve taken advantage of some plot parameters to suppress the axis tick marks
    and labels. This code produces the following output in [Figure 4-13](ch04.xhtml#ch4fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: Basic polar plots*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the plots are in a list. In Racket a plot is just another data value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s produce the plot shown in [Figure 4-14](ch04.xhtml#ch4fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: The polar rose*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a function that goes from 0 to 1 and back to 0 again. Sounds like the
    sine function. We need it to take these values as it goes from 0 to *π*/2 (and
    repeating up to 2*π*), so the function we need is *r*[*θ*] = sin(2*θ*). The code
    to plot this is then the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the small addition of parameter *k* to the function *r*[*θ*] = sin(*kθ*),
    it’s possible to produce a large variety of interesting curves (see [Figure 4-15](ch04.xhtml#ch4fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/04fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: Polar roses*'
  prefs: []
  type: TYPE_NORMAL
- en: As another example of a polar plot, here’s the code we used to produce the golden
    spiral first introduced on [page 68](ch03.xhtml#page_68) in [Chapter 3](ch03.xhtml)
    and reproduced here in [Figure 4-16](ch04.xhtml#ch4fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So now we have the actual code used to generate the golden spiral we first encountered
    in [Chapter 3](ch03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: The golden spiral*'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’ve tried to give a good overview of the plotting capabilities that
    DrRacket affords, there’s even more: contours, interval graphs, error bars, vector
    fields, the list goes on. I encourage you to consult the documentation for additional
    topics that may be of interest to you. For now, though, we’ll be moving on to
    creating drawings using graphics primitives.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing in Racket requires something called a *drawing context (DC)*. You can
    think of this as a canvas where the drawing takes place. Drawing contexts can
    be set up for various objects such as bitmaps, PostScript files, or a Racket GUI
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike coordinates used for plotting functions, drawing contexts use coordinates
    where the y-axis is inverted as shown in [Figure 4-17](ch04.xhtml#ch4fig17). Note
    that the origin is at the upper left corner of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: Drawing coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: 'All drawings created using the Racket drawing library will need to import the
    *draw* library, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we’ll focus on creating simple drawings using a bitmap drawing
    context. To create such a context, we need a bitmap (via `make-bitmap` as shown
    below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a bitmap drawing context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need some drawing tools. In real life we use pens to draw lines and
    brushes to fill in areas on a canvas; with Racket it’s much the same. We can tell
    Racket the type of pen we want to use in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first method is a quick and dirty way of setting a solid black pen with
    a width of 2\. The second method creates a *pen object* and sends it to the drawing
    context. Colors can be specified as either a string name as shown above, or a
    color object where red, green, blue, and optionally alpha (transparency) values
    can be specified. Each of these values must fall in the range 0–255 (inclusive).
    For example the following inputs will create a cyan color object and set the drawing
    context to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An equivalent, but slightly more efficient way to perform the above would be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Brushes control the type of fill used inside of two-dimensional objects like
    rectangles and circles. Like pens, brushes can be defined in a couple of different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example will create a brush that produces a blue cross-hatch fill.
    The second example uses a *brush object* that has a solid red fill. An equivalent
    but slightly different way to achieve the same effect in the second example would
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With these preliminaries out of the way, we can actually start drawing by using
    `send` to send drawing commands to the drawing context. To draw a single line
    segment, we would input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This would draw a line segment beginning at (10, 10) and ending at (30, 25).
    We have added the line to the drawing context, but it’s not immediately displayed.
    To actually see the line, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p093-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that `drawing` was defined earlier and is the actual bitmap we are
    drawing to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rectangles are just as easy to produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters (0, 0) are the x- and y-coordinates of the upper left
    corner of the rectangle. The next two are the width and height.
  prefs: []
  type: TYPE_NORMAL
- en: Circles and ellipses are handled in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case the parameters specify a *bounding box* that contains the ellipse,
    where again the first two parameters are the x- and y-coordinates of the upper
    left corner of the bounding rectangle and the next two are its width and height
    (see the gray area in [Figure 4-18](ch04.xhtml#ch4fig18)—we’ll discuss the wedge
    shape later).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0094-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: Ellipse bounding box*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the drawing, we simply print the variable (`drawing`) that contains
    the bitmap we’ve been drawing to (via the drawing context `dc`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text can be added to a drawing with the `draw-text` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the last two parameters specify the x- and y-coordinates of the
    upper left corner of the text.
  prefs: []
  type: TYPE_NORMAL
- en: To pull these ideas together, here is some simple code to draw a crude automobile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running this code will produce the the stunning work of art shown in [Figure
    4-19](ch04.xhtml#ch4fig19). Depending on your computer the output may look a bit
    different (primarily due to how fonts are handled).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: A stunning work of art*'
  prefs: []
  type: TYPE_NORMAL
- en: The drawing library contains much more functionality than we’ve illustrated
    here, but we’ve learned enough to get started. We’ll make practical use of our
    new skills (and learn some new ones) in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Set Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be thinking that a chapter on graphics is an odd place to host a discussion
    about set theory, and you’d be right. But it’s easier to understand set theory
    when you can see it, and we can use DrRacket’s excellent graphics capabilities
    to illustrate various basic concepts about set theory. We’ll also get to see some
    additional features of the graphics library.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *set* is just some arbitrary collection of things, such as *{*5, 1/2, 7,
    12*}* or *{*car, bus, train*}*. One distinguishing feature of a mathematical set
    is that a mathematical set is not allowed to contain two identical objects. For
    example *{*8, 2, 9, 2*}* is *not* a set, since the number 2 occurs twice (such
    a thing is typically called a *bag* or *multiset*). We can indicate that something
    is in a set by the *member* (or *in*) symbol: ∈. For instance 5 ∈ *{*8, 2, 5,
    9, 3*}*. Likewise, we can specify that something is not in a set by the not-member
    symbol: ∉, as in 7 ∉ *{*8, 2, 9, 3*}*.'
  prefs: []
  type: TYPE_NORMAL
- en: In Racket, a set can be represented by an object called a *hash set*. A hash
    set can be either mutable or immutable, depending on how it’s constructed. A mutable
    hash set is created with the `mutable-set` form and an immutable set is constructed
    with the `set` form. We can test whether an element is a member of a hash set
    with `set-member?`. Elements can be added to a mutable set by the `set-add!` form
    and a new set can be created from an old (immutable) one by the `set-add` form.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, `mset` will designate a mutable set and `iset`
    will designate an immutable set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we were not able to use `set-add` on our mutable set ➊, and we
    were not able to use `set-add!` on our immutable set ➌. Further, while it did
    not generate an error, adding the number 7 to `mset` ➋ had no effect since 7 was
    already a member.
  prefs: []
  type: TYPE_NORMAL
- en: In many mathematical texts, sets are illustrated by using a diagram that contains
    a rectangle and one or more circles. These diagrams are known as *Venn diagrams*.
    The rectangle is used to designate all the items of interest (called the *universe
    of discourse*—we’ll use the symbol *U* to represent this), and circles are used
    to represent particular sets. To aid in our exploration, we’ll define some helper
    methods to draw various objects in these diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code through `(define dc (new bitmap-dc% [bitmap venn]))` should be familiar
    from our previous discussions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit inconvenient to have our drawing origin in the upper left corner,
    with the y-axis inverted, so we use a new feature called a *transformation*. We
    use the `scale` transform to scale our drawing environment by 1 in the x-axis
    direction and -1 in the y-axis direction. This keeps everything the same size,
    but inverts the y-axis so that up is in the positive direction. To get the origin
    in the middle of the diagram, we use `translate` to center it. (There’s also a
    rotate transformation, but it’s not needed for our present purposes.)
  prefs: []
  type: TYPE_NORMAL
- en: The `set-smoothing` argument to `send dc` enables or disables anti-aliased smoothing
    for a drawing. The default value of ’`unsmoothed` produces drawings with a slightly
    jagged appearance.
  prefs: []
  type: TYPE_NORMAL
- en: The `IN-BRUSH` will be used as the color to designate things that are in a set,
    and the `OUT-BRUSH` is for the color to indicate things that are not in a set.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a couple of methods to actually do some drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `rect` method will draw a rectangle whose center is at coordinates (x,y)
    with width and height of `w` and `h` respectively. And `b` is the brush that we
    want to use to draw the rectangle. Similarly, `circle` will draw a circle whose
    center is at coordinates (*x, y*), with radius `r`, and brush `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ll only have occasion to draw a single rectangle (representing the
    universe of discourse, *U*), we create a special function such that it draws it
    appropriately; we only need to supply it with a brush for the color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try these out (see [Figure 4-20](ch04.xhtml#ch4fig20)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/04fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: A diagram indicating a single set*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our universe of discourse is the integers (that is, *U* = ℤ). We can
    represent the set of even numbers by the green circle. Now suppose that we’re
    interested in anything that is *not* an even number. This is the *complement*
    of the set of even numbers. The set complement of *A* can be represented as *A*^(*c*),
    Ā, or *A*’. We represent this in a Venn diagram as follows (and shown in [Figure
    4-21](ch04.xhtml#ch4fig21)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/04fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: Items not in the set*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used `erase` to clear the drawing context before generating the
    next diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets can be combined in various ways. Suppose we have two sets: *A* and *B*.
    One way to combine these sets is to form a new set that is the unique combination
    of all the elements from set *A* and *B*. This operation is called *set union*,
    and is designated by the symbol ∪. If *C* is the union of *A* and *B*, the mathematical
    expression to reflect this is *C* = *A* ∪ *B*. Using *set-builder* notation, the
    set complement would be expressed as *A*^(*c*) = *{x* ∈ *U* ∣ *x* ∉ *A}*. In words
    this would be “the set of all *x* in U such that *x* is not in *A*."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to think of the union of sets *A* and *B* is to see that it consists
    of following components:'
  prefs: []
  type: TYPE_NORMAL
- en: All the elements that are in *A* and not in *B* (left partial circle).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the elements that are in *B* and not in *A* (right partial circle).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the elements that are in both *A* and *B* (the central shape of the diagram—this
    shape is called a *vesica* *piscis*, Latin for “bladder of a fish").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Figure 4-22](ch04.xhtml#ch4fig22) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-22: Set union*'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Short Mathematical Detour***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to be able to draw the Venn diagram components in [Figure 4-22](ch04.xhtml#ch4fig22),
    we’ll need to do a few straightforward calculations first. We’ll base our calculation
    on the nomenclature illustrated in [Figure 4-23](ch04.xhtml#ch4fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0100-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-23: How to draw a Venn diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to find the values of *x*[*i*], *y*[*i*], *θ*, and *ϕ* shown
    in [Figure 4-23](ch04.xhtml#ch4fig23). Assume that *x*[*c*], *y*[*c*], and *r*
    are given. Note that the circles are clearly symmetric about the y-axis, which
    eases our task somewhat. It’s immediate that *x*[*i*] = 0\. The equation of a
    circle with center on the x-axis is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (x - x[c])² + y² = r²
  prefs: []
  type: TYPE_NORMAL
- en: 'The intersection points occur at *x* = 0\. With this substitution and solving
    for *y*, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0100-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given *y*, the angles are easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0100-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s exercise a new DrRacket graphics feature called *paths*. The path
    functionality allows one to draw arbitrary figures. A path is constructed by selecting
    a starting location and building a sequence of segments to define the entire path.
    Path segments can consist of straight lines, arcs and something called bezier
    curves (see the manual). We construct a filled path to represent the center portion
    of the Venn diagram (the *vesica piscis*) with the following method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Within the `let*` form we find direct translations of Equations (4.1) ➊ and
    (4.2) ➋. The identifier `path` is then bound to a new `dc-path%` object ➌. Paths
    work sort of like drawing contexts in that path commands are sent to the path
    object to build the path. The code then positions us at the initial location to
    draw the first arc ➍ . The first arc is then drawn ➎, and completed by mirroring
    the first arc ➏. The path `arc` command works like a drawing context `draw-ellipse`
    command. The only difference is that `arc` takes additional parameters specifying
    the start and stop angles. The finished path is then sent to the drawing context
    to be rendered ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing Conclusions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With `piscis` under our belt, we have most of the machinery we need to draw
    any binary set operation. To aid in our quest, let’s define a simple function
    to generate the final diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We define a new light green color in `SET-BRUSH` to identify the sets participating
    in the operation. The `venn-bin` method (the `bin` part just refers to the fact
    that it’s drawing a binary operation) takes three brushes, one to identify each
    component of the diagram. The rest of the code should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the union diagram we saw in [Figure 4-22](ch04.xhtml#ch4fig22),
    we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate Racket’s set operations we’ll use two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result of forming the union (*A* ∪ *B*) of the two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that sets are not guaranteed to be in any particular order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next operation is *set intersection*. Set intersection is designated by
    the symbol ∩. The intersection of *A* and *B* consists of all the elements that
    are in both *A* and *B*. That’s *A* ∩ *B* = *{x* ∣ *x* ∈ *A* and *x* ∈ *B}*. The
    Venn diagram for intersection is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It’s also shown in [Figure 4-24](ch04.xhtml#ch4fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-24: Set intersection*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of Racket code for intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is *set difference*. Set difference is designated by the symbol *\*.
    The set difference of *A* and *B* consists of all the elements that are in *A*
    that are not also in *B*. That’s *A \ B* = *{x* ∣ *x* ∈ *A* and *x* ∉ *B}*. The
    Venn diagram for set difference is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It’s also shown in [Figure 4-25](ch04.xhtml#ch4fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-25: Set difference*'
  prefs: []
  type: TYPE_NORMAL
- en: Set difference is performed with the `set-subtract` function in Racket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our final operation is *symmetric difference*. Symmetric difference is designated
    by the symbol △. The symmetric difference of *A* and *B* consists of all the elements
    that are in *A* or *B*, but are not also in both *A* and *B*. That’s *A* △ *B*
    = {*x* ∣ *x* ∈ *A* or *x* ∈ *B*, but not *x* ∈ *A* and *x* ∈ *B*}. The Venn diagram
    for symmetric difference is given by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See an example in [Figure 4-26](ch04.xhtml#ch4fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-26: Symmetric difference*'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric set difference is performed with the `set-symmetric-difference` function
    in Racket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '***Are We Related?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a couple of important relationships in the theory of sets that you
    should be aware of. The first is the concept of *subsets*. A set *A* is a subset
    of another set *B* if all the elements of *A* are also elements of *B*. This relationship
    is represented by the symbol ⊆. In Racket it’s possible to test whether one set
    is a subset of another with the predicate `subset?`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: A subset relationship like the one in the first example can be represented by
    the Venn diagram shown in [Figure 4-27](ch04.xhtml#ch4fig27). In this case the
    inner circle is entirely enclosed by the outer circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-27: A subset relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: If a set *A* is a subset of *B*, but *A* ≠ *B*, *A* is said to be a *proper
    subset* of *B*. This is designated by the symbol ⊂. Racket provides the `proper-subset?`
    predicate to perform this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Given sets *A* and *B*, the *Cartesian product* is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A* × *B* = {(*a*, *b*) | ∣ *a* ∈ *A* and *b* ∈ *B*}'
  prefs: []
  type: TYPE_NORMAL
- en: While Racket doesn’t have a built-in function that returns the Cartesian product
    of two sets, it’s easy enough to produce our own version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But a somewhat more succinct version is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'From this it can be seen that the Cartesian product is the set of all possible
    pairs of values that can be generated from two given sets. Subsets of Cartesian
    products are frequently used to define relationships. For example, if *A* = {1,
    2, 3, 4}, we can express the “less than” relationship as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the first value in each pair is always less than the second element.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our brief foray into applying DrRacket’s graphical capabilities
    to the exciting topic of set theory. Next we’ll take a look at a couple of extended
    applications where we utilize these capabilities to explore additional topics
    in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin with an old acquaintance, the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fibonacci Revisited***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we learned in the last chapter in the Fibonacci and Friends section, it’s
    always possible to tile a rectangle with squares whose sides are given by the
    Fibonacci sequence. In this section we’ll create a function that can draw the
    tiling for any Fibonacci number (up to the screen limit). The tiling begins in
    the center of the drawing canvas and proceeds by essentially spiraling out from
    that point. Before we dive into writing code for this, a little analysis will
    guide our way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tiling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Observe [Figure 4-28](ch04.xhtml#ch4fig28). We’ll use the upper left corner
    of each square as a reference point (as indicated by the black quadrants). Each
    arrow indicates the direction we must move to create the next Fibonacci square.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-28: Tile analysis*'
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is the *n*th Fibonacci number (*F*[*n*]), we designate *f*[*n*] as the
    *n*th Fibonacci square with sides of length *s*[*n*] (this is just some constant
    multiple of *F*[*n*]). The coordinates of the upper left corner of *f*[*n*] will
    be given by (*x*[*n*], *y*[*n*]). We assume the drawing is initialized with *f*[1]
    and *f*[2] as indicated by the two small, unlabeled squares in the center of the
    drawing. Moving up from *f*[2] to *f*[3], we see that (*x*[3], *y*[3]) = (*x*[1],
    *y*[2] - 2). We can generalize this to (*x*[n], *y*[n]) = (*x*[n-2], y[n-1] -
    s[n]) whenever we move from one tile to another in an upward direction. [Table
    4-1](ch04.xhtml#ch4tab1) gives the change in coordinates for all four directions.
    Since the pattern repeats itself after four moves, the applicable move is given
    in the remainder (*n* mod 4) column.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1**: Direction Coordinates'
  prefs: []
  type: TYPE_NORMAL
- en: '| Direction | Coordinates | *n* mod 4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *↑* | (x[n-2], y[n-1] – s[n]) | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| ← | (x[n-1] – s[n], y[n-1]) | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *↓* | (x[n-1], y[n-1] + s[n-1]) | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| → | (x[n-1] + s[n-1], y[n-2]) | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'This table tells us that at any stage of the drawing process we’ll need access
    to not only *F*[*n*] and *F*[*n-*1], but also (x[n-1], y[n-1]) and (*x*[n-2],
    *y*[n-2]). We’ll use the second method introduced in the Fibonacci and Friends
    section to produce *F*[*n*] in our drawing code. Hence, we’ll describe a `draw-tiles`
    function that takes a Fibonacci *n* and returns four values: *x*[*n-*1], *y*[*n-*1],
    *x*[*n-*2], and *y*[*n-*2]. These values along with *F*[*n*] and *F*[*n-*1] will
    be used to draw the *n*th tile.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-29](ch04.xhtml#ch4fig29) shows the result from calling `(draw-tiles
    10)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-29: A Fibonacci tiling*'
  prefs: []
  type: TYPE_NORMAL
- en: Our code begins with some constant definitions to establish the parameters to
    be used in the rest of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There should be sufficient comments here to determine what’s what. We’ve fudged
    a bit by adding some offset values to account for the asymmetric nature of the
    tiling.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set up our drawing surface, pen, and brush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define two functions: one to compute *F*[*n*] and the other, `draw-n`,
    to actually produce the tiling in [Listing 4-1](ch04.xhtml#ch04list1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Fibonacci with Tiling*'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw-n` function is the workhorse of this process. This procedure is recursively
    called ➎ until the desired number of tiles is drawn. First, we compute *F*[*n*]
    ➊ and *F*[*n-*1] ➌. Then we simply multiply these numbers by the constant `UNIT`
    ➋ ➍ to determine the sizes of the squares. Next, we determine the coordinates
    of the upper left corner of the square as described during the discussion of [Table
    4-1](ch04.xhtml#ch4tab1) ➏ ➐. Following this, the tile is actually drawn ➑. Finally,
    the values *x*[*n-*1], *y*[*n-*1], *x*[*n-*2], and *y*[*n-*2] mentioned in our
    analysis section above are returned ➒ as these values are needed by the preceding
    recursive call ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually produce the drawing, we have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: It initializes the drawing with the two unit squares, calls `draw-n`, and outputs
    the constructed bitmap to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, calling `(draw-tiles 10)` will produce the output shown previously
    in [Figure 4-29](ch04.xhtml#ch4fig29).
  prefs: []
  type: TYPE_NORMAL
- en: '**The Golden Spiral (Approximation)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To produce the golden spiral discussed in [Chapter 3](ch03.xhtml) (and reproduced
    in [Figure 4-30](ch04.xhtml#ch4fig30)), we only need to make a few additions to
    our tiling code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-30: The golden spiral*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by defining a new drawing pen and brush to be used for creating the
    spiral.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce the spiral, we’ll be using the `draw-arc` function. This function
    works just like `draw-ellipse` except that it takes two additional arguments that
    specify the start and stop angles for the arc. These values are designated by
    *θ*[0] and *θ*[1] in [Figure 4-18](ch04.xhtml#ch4fig18). By default, arcs use
    a filled brush, so to keep from covering the tiles, we define `TRANS-BRUSH` as
    a transparent brush. The spirals are produced by drawing an arc each time a tile
    is produced. We predefine the various angles (in radians) we will need to use
    for the arcs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the actual function used to draw the spiral segments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: First, we determine the start and stop angles for the arcs ➊, as well as the
    x-coordinate and y-coordinate of the location to draw the arcs. Next, we switch
    to the appropriate pen and brush to draw the arc. Finally, the drawing context
    is reset to the one needed to draw the tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change needed to the `draw-n` code is to add this single line immediately
    after the `(draw-tile x y sn)` statement ➑ in [Listing 4-1](ch04.xhtml#ch04list1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: With this change, calling `(draw-tiles 10)` will now produce the tiling overlaid
    by the golden spiral as shown in [Figure 4-30](ch04.xhtml#ch4fig30).
  prefs: []
  type: TYPE_NORMAL
- en: '***Nim***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nim is a strategy game in which two players take turns removing objects from
    distinct heaps. On each turn, a player must remove at least one object, and may
    remove any number of objects provided they all come from the same heap. The winner
    of the game is the player who removes the last object. This game can also be played
    where the person who removes the last object loses, but in our version, the player
    who takes the last object wins.
  prefs: []
  type: TYPE_NORMAL
- en: In this version of Nim we’ll have three piles with up to 15 balls in each pile,
    as shown in [Figure 4-31](ch04.xhtml#ch4fig31). Instead of two human players,
    this time it will be man versus machine, you against the computer, *mano a mano*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-31: Nim starting piles*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up the Graphics**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll begin with some basic definitions to establish some useful constants.
    Most of these should be fairly obvious. The `BOARD` references are to the brown
    board the balls rest on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The linchpin of Nim’s graphics is the `draw-pile` routine, shown below, which
    draws a single pile of balls. This code calls `draw-ball` with the x- and y- coordinates
    of the location of the center of each ball. It draws each row (see `draw-row`),
    bottom up, until there are either no more balls or the row has its full complement
    of balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we come to the code that actually draws the entire Nim environment,
    `draw-game`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This routine simply draws rectangles for the background and board under the
    piles. It then calls `draw-pile` once for each pile. The number of balls contained
    in each pile is stored in the vector variable `pile`. For reference, the pile
    number is shown below each pile.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gameplay**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Nim is a bit unusual in the world of games in that a perfect play strategy is
    known to exist. It’s relatively easy to implement, but it’s not obvious. So once
    you’ve programmed this, you can spring it on one of your unsuspecting friends
    and have the computer beat the snot out of them.
  prefs: []
  type: TYPE_NORMAL
- en: The key to this strategy is something called the *nim-sum*. The nim-sum is simply
    the bitwise exclusive-or of the number of pieces in each pile. The exclusive-or
    operator is given by the mathematical symbol ⊕ and is often designated as xor.
    It’s computed in Racket by the function `bitwise-xor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitwise exlusive-or is computed as follows: if you are combining two single
    bits and both bits are the same, then the result is 0; otherwise, it’s 1\. For
    example, 1 ⊕ 1 = 0 and 1 ⊕ 0 = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Racket we can display the binary representation of a number by using `"`˜`b"`
    in the form string of the `printf` statement. For example, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if you take the bitwise exclusive-or in each corresponding bit position
    of 13[10] = 1101[2] and 9[10] = 1001[2] , you wind up with 0100[2].
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the winning strategy is just to finish every move with a
    nim-sum (that is, an exclusive-or) of 0\. This is always possible if the nim-sum
    is not zero before the move. The way to achieve this is with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Designate *b*[0], *b*[1], and *b*[2], as the number of balls in piles 0, 1,
    and 2 respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let *s* = *b*[0] ⊕ *b*[1] ⊕ *b*[2] be the nim-sum of the all the pile sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute *n*[0] = *s* ⊕ *b*[0], *n*[1] = *s* ⊕ *b*[1], and *n*[2] = *s* ⊕ *b*[2].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of the three piles, at least one of the values *n*[0], *n*[1], or *n*[2] will
    be numerically less than the number of items in the corresponding pile. We select
    from one of these piles and designate it by the letter *i*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The winning play is then to simply reduce pile *i* to size *n*[*i*]. That is,
    the move is to remove *b*[*i*] *- n*[*i*] balls from pile *i*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the nim-sum is zero at the beginning of a player’s turn, that player will
    lose if their opponent plays perfectly. In that case, the best strategy is to
    stall by picking a single ball from one of the piles and hope that the opponent
    will make a mistake at some point. The reason this strategy works is somewhat
    technical, but an analysis can be found in the Wikipedia article at *[https://en.wikipedia.org/wiki/Nim](https://en.wikipedia.org/wiki/Nim)*.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the actual Racket code to find a winning move.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define `nim-sum` as `bitwise-xor` ➊. Next, we have the helper function
    `random-pile` ➋, which just finds a random pile that has balls. We use this to
    implement the stalling strategy mentioned above. `find-move` implements our overall
    playing strategy mentioned in the itemized steps above. This function returns
    two values: the pile number and the number of balls to remove from the pile. Now
    we compute the overall nim-sum ➌ (step 2 in the above procedure). This sum is
    then tested ➍, and if it’s zero, it simply returns a random pile with one ball
    to be removed. The computation mentioned in step 3 above is performed ➎. The local
    function `test?` ➏ determines whether *n*[*i*] < *b*[*i*]. The local function
    `move` returns the pile number and the number of balls to remove as mentioned
    in step 5 above. Finally, we perform tests to determine which pile to use ➐.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we create code for the player to enter their move, we define a few helper
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `apply-move` function updates the designated pile by removing the specified
    number of balls. The `game-over?` function tests whether there are any balls left
    to play. And the `valid-move?` function tests whether a given move is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tying it all together is the function that implements the following game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The player enters their move by specifying the pile number followed by the
    number of balls to remove. For instance, to remove 5 balls from pile 1, one would
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To make things interesting, we define an `init` function that randomly initializes
    each pile with from 10 to 15 balls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-32](ch04.xhtml#ch4fig32) illustrates a game in progress.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-32: Nim: game in progress*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we played with plotting, grappled with graphics, and in the
    process discovered Racket’s extensive capability for visual representation. In
    the next chapter, we’ll build upon this capability to escape the confines of the
    command line to produce animations and take the first steps toward making interactive
    applications.
  prefs: []
  type: TYPE_NORMAL
