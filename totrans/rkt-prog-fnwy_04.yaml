- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: PLOTTING, DRAWING, AND A BIT OF SET THEORY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图、绘制与一些集合论
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: In this chapter, we’ll explore how to exploit DrRacket’s ability to display
    graphical information. In particular, we’ll look at various ways of generating
    two-dimensional function plots as well as using some built-in graphics primitives
    (circles, rectangles, and so on) to create more-complex drawings. After introducing
    the basics, we’ll look at a few extended applications, involving set theory, the
    golden spiral, and the game of Nim.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用 DrRacket 显示图形信息的功能。具体来说，我们将查看生成二维函数图表的各种方法，以及使用一些内建的图形原语（圆形、矩形等）来创建更复杂的绘图。在介绍基本知识后，我们还将探讨一些扩展应用，包括集合论、黄金螺旋和尼姆游戏。
- en: Plotting
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘图
- en: All plotting functions will require the *plot* library, so be sure to execute
    the following before trying any of the examples in this section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有绘图函数都需要*plot*库，因此在尝试本节中的任何示例之前，请确保先执行以下操作。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With that out of the way, let’s begin with something simple and familiar.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些都解决了，我们就从一些简单而熟悉的内容开始吧。
- en: '***X-Y Plots***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***X-Y 图表***'
- en: All two-dimensional plots use the `plot` function. This function takes either
    a single function or a list of functions, and generates a plot for each. Once
    a plot has been generated, if desired, it can be saved as a bitmap by right-clicking
    on the plot and clicking Save Image. . . from the pop-up menu.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有二维图表都使用`plot`函数。此函数接受单个函数或函数列表，并为每个函数生成一个图表。生成图表后，如果需要，可以通过右键点击图表并选择弹出菜单中的“保存图像…”将其保存为位图。
- en: 'The `plot` function accepts a number of keyword arguments (all of which are
    optional), but as a minimum, it’s probably a good idea to specify the plot limits
    since DrRacket can’t always determine the proper plot bounds. Here’s an example
    of generating a simple plot of the sine function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`函数接受多个关键字参数（所有参数都是可选的），但至少建议指定图表的范围，因为 DrRacket 并不总是能确定适当的图表边界。以下是生成简单正弦函数图表的示例：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result is shown in [Figure 4-1](ch04.xhtml#ch4fig1). Please note that figures
    are shown in grayscale, but when you input the code on your computer, graphs will
    appear in color.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图 4-1](ch04.xhtml#ch4fig1)所示。请注意，图像显示为灰度，但当你在电脑上输入代码时，图形将显示为彩色。
- en: '![Image](../images/04fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig01.jpg)'
- en: '*Figure 4-1: Example plot using sine function*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：使用正弦函数的示例图表*'
- en: Notice that the `sin` function is enclosed in a `function` form. The `function`
    is something called a *renderer*; it controls how the function argument passed
    to it gets rendered. The `function` form allows you to add optional keyword parameters
    to control how the individual function is displayed. In this case we specify that
    the sine function is rendered in a blue color.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sin`函数被包含在`function`形式中。`function`是一个被称为*渲染器*的东西；它控制传递给它的函数参数的渲染方式。`function`形式允许你添加可选的关键字参数来控制单个函数的显示方式。在这种情况下，我们指定正弦函数以蓝色渲染。
- en: The following code creates a plot that displays both the sine and cosine functions
    by combining them into a list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过将正弦函数和余弦函数合并到一个列表中来创建一个显示这两个函数的图表。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The resulting plot is shown in [Figure 4-2](ch04.xhtml#ch4fig2). Notice that
    we’ve specified a narrower plot range for the cosine function and added text labels
    to both functions so that they can easily be differentiated on the plot. We’ve
    also overridden the default labels with specific values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如[图 4-2](ch04.xhtml#ch4fig2)所示。请注意，我们为余弦函数指定了更窄的图表范围，并为两个函数添加了文本标签，以便它们可以在图表上轻松区分。我们还使用特定的值覆盖了默认标签。
- en: '![Image](../images/04fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig02.jpg)'
- en: '*Figure 4-2: The sine and cosine functions*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：正弦和余弦函数*'
- en: The following code demonstrates some additional plotting capabilities (see [Figure
    4-3](ch04.xhtml#ch4fig3) for the output).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一些额外的绘图功能（请参见[图 4-3](ch04.xhtml#ch4fig3)查看输出）。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we’re using a new `inverse` form in our list of functions to plot.
    This form works by using the y-axis as the axis for the independent variable.
    In this way, we effectively plot the inverse function without actually having
    to derive it algebraically. In addition we’ve specified some additional styles
    to help differentiate the plot curves. The sine curve is printed dotted, and the
    inverse square function is printed with a thicker line. The plot legend has been
    moved to the lower left corner by specifying `#:legend-anchor` ’`bottom-left`
    as an optional value to the `plot` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在绘图函数的列表中使用了一种新的`inverse`形式。该形式通过将y轴作为自变量的轴来工作。这样，我们可以有效地绘制反函数，而无需代数推导出来。我们还指定了一些附加样式来帮助区分不同的曲线。正弦曲线使用虚线显示，而反平方函数则用更粗的线条表示。通过为`plot`函数指定`#:legend-anchor`
    `'bottom-left`，我们将图例移到了左下角。
- en: If you run the code, you should get something like [Figure 4-3](ch04.xhtml#ch4fig3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，应该会得到类似[图4-3](ch04.xhtml#ch4fig3)的结果。
- en: '![Image](../images/04fig03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig03.jpg)'
- en: '*Figure 4-3: Sine and inverse square*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：正弦与反平方*'
- en: Next we take a look at parametric plots.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看看参数化绘图。
- en: '***Parametric Plots***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***参数化绘图***'
- en: A curve in a plane is said to be parameterized if the coordinates of the curve,
    (x, y), are represented by functions of a variable (or *parameter*), say *t*.
    Let’s look at an example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个平面中的曲线是参数化的，那么曲线的坐标（x，y）是由一个变量（或*参数*）的函数表示的，假设该参数为*t*。我们来看一个例子。
- en: '**Parameterizing a Circle**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**圆的参数化**'
- en: The standard definition of a circle centered at the origin is the set of all
    points equidistant from the origin. We can state this definition either algebraically
    as an implicit equation or via a pair of trigonometric expressions as illustrated
    in [Figure 4-4](ch04.xhtml#ch4fig4).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的圆定义是以原点为圆心的所有点的集合，且这些点与原点的距离相等。我们可以通过隐式方程的代数形式或通过一对三角函数表达式来表示这一定义，如[图4-4](ch04.xhtml#ch4fig4)所示。
- en: '![Image](../images/04fig04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig04.jpg)'
- en: '*Figure 4-4: Circle definitions*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：圆的定义*'
- en: 'In [Figure 4-4](ch04.xhtml#ch4fig4) (a), the circle is defined by this algebraic
    expression:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-4](ch04.xhtml#ch4fig4)（a）中，圆是通过这个代数表达式来定义的：
- en: '*r*² = *x*² + *y*²'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*r*² = *x*² + *y*²'
- en: 'To plot this as an x-y plot, we have to explicitly express *y* in terms of
    *x*, where the positive values of the expression give the top half of the circle
    and the negative values give the bottom half:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其绘制为x-y图，我们必须明确地将*y*表示为*x*的函数，其中表达式的正值给出圆的上半部分，负值则给出下半部分：
- en: '![Image](../images/p079-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/p079-01.jpg)'
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) (b) illustrates defining the circle in terms
    of the parameter *θ*. In this case the x- and y-coordinates of the curve are given
    by the trigonometric expressions cos *θ* and sin *θ* respectively.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.xhtml#ch4fig4)（b）说明了如何通过参数*θ*来定义圆。在这种情况下，曲线的x和y坐标分别由三角函数cos *θ*和sin
    *θ*给出。'
- en: In Racket, parametric curves are defined in terms of a function that takes the
    parameter as its argument and returns a `vector` containing the computed values
    of *x* and *y*. The code below plots both the algebraic and the parametric versions
    of the circles. We’ve offset the parametric version so that it appears to the
    right of the algebraic version (see [Chapter 2](ch02.xhtml) for information on
    the `infix` package and usage of `@` below).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Racket中，参数曲线是通过一个函数来定义的，该函数以参数为其输入并返回一个包含计算出的*x*和*y*值的`vector`。下面的代码绘制了代数和参数版本的圆。我们已经将参数版本偏移，使其出现在代数版本的右侧（关于`infix`包及`@`的使用，请参见[第2章](ch02.xhtml)）。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve made use of the `infix` package and the `at-exp` language extension so
    that we can present the algebraic expressions in a more natural form. We begin
    with definitions of the half-circle functions `c1` ➊ and `c2` ➋. The parametric
    version is given as `cp` ➌. Notice that `cp` is housed in a form that begins with
    `parametric` ➍ and a plot range specified as 0 to 2*π*. The output of this code
    is shown in [Figure 4-5](ch04.xhtml#ch4fig5).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`infix`包和`at-exp`语言扩展，以便以更自然的形式呈现代数表达式。我们从定义半圆函数`c1` ➊和`c2` ➋开始。参数化版本表示为`cp`
    ➌。请注意，`cp`被置于一个从`parametric` ➍开始的形式中，并且指定了0到2*π*的绘图范围。此代码的输出显示在[图4-5](ch04.xhtml#ch4fig5)中。
- en: '![Image](../images/04fig05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig05.jpg)'
- en: '*Figure 4-5: Explicit versus parametric plots*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：显式与参数化绘图*'
- en: '**Circles in Motion**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**圆的运动**'
- en: 'Let’s face it: static circles are pretty boring. In this section we’ll take
    a look at circles in motion. Specifically, we’ll examine the path that a fixed
    point on a circle takes as it rolls along a straight line without slipping. The
    curve that describes this path is called a *cycloid*. We set the scene in [Figure
    4-6](ch04.xhtml#ch4fig6), where a circle of radius *r* has rolled distance *x*
    from the origin. The point of interest is the dot marked with a *P*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，静态圆形真的很无聊。在这一节中，我们将探讨圆形的运动。具体来说，我们将研究一个固定点在圆上滚动时沿直线无滑移运动所形成的路径。描述这一路径的曲线叫做*摆线*。我们在[图
    4-6](ch04.xhtml#ch4fig6)中设定了场景，其中一个半径为*r*的圆已经从原点滚动了距离*x*。感兴趣的点是标记为*P*的点。
- en: '![Image](../images/04fig06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig06.jpg)'
- en: '*Figure 4-6: Cycloid scene*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：摆线场景*'
- en: Let’s take a look at the math needed to create a parametric plot of point *P*
    that lies on a circle with radius *r* rolling without slipping on a straight line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看生成参数图所需的数学知识，目标是绘制一个点*P*的轨迹，这个点位于一个半径为*r*的圆上，圆在直线上无滑移地滚动。
- en: 'Since the circle rolls without slipping, the length of the arc from *x* to
    *P* is equal to *d*. We can express this as *d* = *θr*. Thus, as the circle rotates
    by angle *θ*, the x-coordinate of *P* is *d - r*sin*θ*. But *d* = *rθ*, so *x*
    = *rθ - r*sin*θ* = *r*(*θ -* sin*θ*). It’s clear that *y* is simply given by *y*
    = *r*(1 *-* cos*θ*). Here’s the code for the plot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于小圆在大圆内无滑移地滚动，从*x*到*P*的弧长等于*d*。我们可以将其表示为*d* = *θr*。因此，当小圆转动角度*θ*时，*P*的x坐标为*d
    - r*sin*θ*。但由于*d* = *rθ*，所以*x* = *rθ - r*sin*θ* = *r*(*θ - sin*θ*)。显然，*y*的值仅由*y*
    = *r*(1 - cos*θ*)给出。以下是绘图代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case we’ve used the `#:samples` keyword to increase the number of samples
    used to generate the plot, giving it a smoother appearance. Here’s the plot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`#:samples`关键字来增加生成图像时使用的采样点数量，从而使得图形看起来更平滑。以下是生成的图像。
- en: '![Image](../images/p082.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p082.jpg)'
- en: The plot curve has been superimposed on the original scene setup in [Figure
    4-7](ch04.xhtml#ch4fig7).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的曲线已经被叠加到[图 4-7](ch04.xhtml#ch4fig7)中的原始场景设置上。
- en: '![Image](../images/04fig08.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig08.jpg)'
- en: '*Figure 4-7: Cycloid*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：摆线*'
- en: Later we’ll see how to animate this so that we can actually see it in motion.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将展示如何对其进行动画处理，这样我们就能看到它的运动效果。
- en: '**The Hypocycloid**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内摆线**'
- en: Instead of having our circle rolling on a straight line, we could have it rolling
    on another circle. Indeed, if the one circle is larger than the other, we could
    have the smaller circle rolling inside the larger circle. A curve generated in
    this fashion is called a *hypocycloid*. Here we create a parametric plot for a
    hypocycloid based on a circle with radius *r* and a larger circle with radius
    *R* where the smaller circle rolls without slipping in the interior of the larger
    circle. We assume that the larger circle is centered at the origin ([Figure 4-8](ch04.xhtml#ch4fig8)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以让圆形沿直线滚动，还可以让它在另一个圆上滚动。事实上，如果一个圆的半径大于另一个，我们可以让小圆在大圆内滚动。以这种方式生成的曲线叫做*内摆线*。在这里，我们为内摆线创建了一个基于半径为*r*的小圆和半径为*R*的大圆的参数图，其中小圆在大圆内部无滑移地滚动。我们假设大圆的圆心在原点([图
    4-8](ch04.xhtml#ch4fig8))。
- en: '![Image](../images/04fig09.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig09.jpg)'
- en: '*Figure 4-8: Hypocycloid setup*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：内摆线设置*'
- en: Since the circle rolls without slipping, the arc length *s* is given by *s*
    = *rθ* = R*ϕ*, so ![Image](../images/p084.jpg). The center of the smaller circle
    (*q* in the diagram) is at a distance *R - r* from the origin. To assist in our
    analysis, we’ve zoomed in on the smaller circle and provided some additional guidelines
    in [Figure 4-9](ch04.xhtml#ch4fig9).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于小圆在大圆内无滑移地滚动，弧长*s*由公式*s* = *rθ* = R*ϕ*给出，因此![Image](../images/p084.jpg)。小圆的圆心（图中的*q*）与原点的距离为*R
    - r*。为了帮助分析，我们放大了小圆并在[图 4-9](ch04.xhtml#ch4fig9)中提供了一些额外的参考线。
- en: '![Image](../images/p0084-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0084-01.jpg)'
- en: '*Figure 4-9: Setup zoomed in*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：放大后的设置*'
- en: 'Note the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下几点：
- en: '![Image](../images/p0084-03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0084-03.jpg)'
- en: 'From this it’s clear that the x-coordinate of *P* is given by the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以清楚地看到，*P*的x坐标由以下公式给出：
- en: '![Image](../images/p0084-04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0084-04.jpg)'
- en: 'Likewise the y-coordinate of *P* is given by the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*P*的y坐标由以下公式给出：
- en: '![Image](../images/p084-6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p084-6.jpg)'
- en: 'We put this all together in the following Racket code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有这些结合起来，写成了以下Racket代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may enjoy the fruits of our labor in [Figure 4-10](ch04.xhtml#ch4fig10).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 4-10](ch04.xhtml#ch4fig10)中看到我们工作的成果。
- en: '![Image](../images/04fig11.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig11.jpg)'
- en: '*Figure 4-10: Hypocycloid plot*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：内滚线图*'
- en: 'To whet your appetite to further explore these fascinating curves, here’s another
    question for you: for what ratio of radii is a hypocycloid a straight line?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激发你进一步探索这些迷人曲线的兴趣，给你另一个问题：对于什么半径比率，内滚线是直线？
- en: '***Getting to the Point***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***直击要点***'
- en: 'So far we’ve concentrated on generating continuous curves, but what if you
    want to plot individual points? Yes, Grasshopper, this too is possible. A *point*,
    from a plotting perspective, is just a vector with two numbers in it. For example,
    `#(1 2)` is a point. To plot a set of points, you just need to provide the `plot`
    routine a list consisting of vector points. Here’s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们集中在生成连续曲线，但如果你想绘制单个点怎么办？是的，Grasshopper，这也是可以的。从绘图角度来看，一个*点*只是一个包含两个数字的向量。例如，`#(1
    2)`是一个点。要绘制一组点，你只需向`plot`例程提供一个由向量点组成的列表。以下是一个示例：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And here’s the output in [Figure 4-11](ch04.xhtml#ch4fig11).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图 4-11](ch04.xhtml#ch4fig11)中的输出结果。
- en: '![Image](../images/04fig12.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig12.jpg)'
- en: '*Figure 4-11: A face drawn with points*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-11：用点绘制的面部*'
- en: In this case we’re using the `parameterize` form, which lets us specify the
    physical size of the plot in pixels (`plot-width` and `plot-height`) and suppress
    the plot labels. Note that the `#:size` keyword parameter is also expressed in
    pixels. The first point list is a single point that we use for the face. The `#:sym`
    keyword argument specifies what type of symbol to use to print the point. We’re
    using a filled circle specified by the symbol ’`fullcircle` for the face. There’s
    a large variety of predefined symbols (search for “known-point-symbols” in the
    documentation), but you may also use a Unicode character or a string.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用的是`parameterize`形式，它允许我们指定图表的物理大小（以像素为单位，`plot-width`和`plot-height`），并抑制图表标签。请注意，`#:size`关键字参数也以像素表示。第一个点列表是我们用于绘制面部的单个点。`#:sym`关键字参数指定用于打印该点的符号类型。我们使用的是一个填充圆圈，用符号`fullcircle`表示面部。预定义符号种类繁多（可以在文档中搜索“known-point-symbols”），但你也可以使用Unicode字符或字符串。
- en: Now that we have the ability to plot points, we can connect them together with
    lines using the `line` form. Like points, lines consist of a list of two-element
    vectors. The `plot` routine treats this list as a sequence of line segment end
    points and plots them appropriately. Here’s an example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制点了，我们可以使用`line`形式将它们连接成线条。像点一样，线条由两个元素的向量列表组成。`plot`例程将该列表视为一系列线段的端点，并适当地绘制它们。以下是一个示例。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The resulting plot is shown in [Figure 4-12](ch04.xhtml#ch4fig12):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表显示在[图 4-12](ch04.xhtml#ch4fig12)中：
- en: '![Image](../images/04fig13.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig13.jpg)'
- en: '*Figure 4-12: Plotting lines and points*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：绘制线条和点*'
- en: '***Polar Plots***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***极坐标图***'
- en: 'Polar plots are created with . . . (you guessed it!) the `polar` form. The
    `polar` form is supplied with a function that returns the distance from the origin
    when supplied with an angle of rotation. The simplest possible function to be
    used in a polar plot is that of a unit circle, which in the guise of a lambda
    expression would be `(`λ `(`θ`) 1)`. A slightly more ambitious example would be
    that of a counterclockwise spiral defined as `(`λ `(`θ`)` θ`)`. Here’s the code
    for both plots:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 极坐标图是通过...（你猜对了！）`polar`形式创建的。`polar`形式接受一个函数，该函数在给定旋转角度时返回原点的距离。最简单的极坐标图函数是单位圆，其作为lambda表达式的形式为`(`λ
    `(`θ`) 1)`。一个稍微更复杂的示例是逆时针螺旋线，定义为`(`λ `(`θ`)` θ`)`。以下是两个图表的代码：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve taken advantage of some plot parameters to suppress the axis tick marks
    and labels. This code produces the following output in [Figure 4-13](ch04.xhtml#ch4fig13).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用一些图表参数抑制了坐标轴刻度和标签。此代码在[图 4-13](ch04.xhtml#ch4fig13)中生成以下输出。
- en: '![Image](../images/04fig14.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig14.jpg)'
- en: '*Figure 4-13: Basic polar plots*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-13：基本极坐标图*'
- en: Notice that the plots are in a list. In Racket a plot is just another data value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图表是以列表的形式呈现的。在Racket中，图表只是另一种数据值。
- en: Let’s produce the plot shown in [Figure 4-14](ch04.xhtml#ch4fig14).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成[图 4-14](ch04.xhtml#ch4fig14)中所示的图表。
- en: '![Image](../images/04fig15.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig15.jpg)'
- en: '*Figure 4-14: The polar rose*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-14：极玫瑰*'
- en: 'We need a function that goes from 0 to 1 and back to 0 again. Sounds like the
    sine function. We need it to take these values as it goes from 0 to *π*/2 (and
    repeating up to 2*π*), so the function we need is *r*[*θ*] = sin(2*θ*). The code
    to plot this is then the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个从0到1再回到0的函数。这听起来像是正弦函数。我们需要它在从0到*π*/2（并重复直到2*π*）的过程中产生这些值，因此我们需要的函数是*r*[*θ*]
    = sin(2*θ*)。绘制此图的代码如下：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the small addition of parameter *k* to the function *r*[*θ*] = sin(*kθ*),
    it’s possible to produce a large variety of interesting curves (see [Figure 4-15](ch04.xhtml#ch4fig15)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对函数*r*[*θ*] = sin(*kθ*)添加一个小的参数*k*，就能产生各种有趣的曲线（见[图 4-15](ch04.xhtml#ch4fig15)）。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Image](../images/04fig16.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig16.jpg)'
- en: '*Figure 4-15: Polar roses*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-15：极坐标玫瑰*'
- en: As another example of a polar plot, here’s the code we used to produce the golden
    spiral first introduced on [page 68](ch03.xhtml#page_68) in [Chapter 3](ch03.xhtml)
    and reproduced here in [Figure 4-16](ch04.xhtml#ch4fig16).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个极坐标绘图的示例，以下是我们用来绘制黄金螺旋的代码，黄金螺旋最早在[第3章](ch03.xhtml)的[第68页](ch03.xhtml#page_68)介绍，并在此处的[图
    4-16](ch04.xhtml#ch4fig16)中重新绘制。
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So now we have the actual code used to generate the golden spiral we first encountered
    in [Chapter 3](ch03.xhtml).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了用于生成黄金螺旋的实际代码，这是我们在[第3章](ch03.xhtml)首次遇到的。
- en: '![Image](../images/04fig17.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig17.jpg)'
- en: '*Figure 4-16: The golden spiral*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-16：黄金螺旋*'
- en: 'While we’ve tried to give a good overview of the plotting capabilities that
    DrRacket affords, there’s even more: contours, interval graphs, error bars, vector
    fields, the list goes on. I encourage you to consult the documentation for additional
    topics that may be of interest to you. For now, though, we’ll be moving on to
    creating drawings using graphics primitives.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尽力提供了DrRacket绘图功能的概述，但其实还有更多：等高线图、区间图、误差条、向量场，等等。我鼓励你查阅文档，了解更多可能对你有兴趣的主题。不过，接下来我们将继续讨论使用图形原语创建图形。
- en: Drawing
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘图
- en: Drawing in Racket requires something called a *drawing context (DC)*. You can
    think of this as a canvas where the drawing takes place. Drawing contexts can
    be set up for various objects such as bitmaps, PostScript files, or a Racket GUI
    application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Racket中绘图需要一种称为*绘图上下文（DC）*的东西。你可以把它当作绘图发生的画布。绘图上下文可以为各种对象设置，例如位图、PostScript文件或Racket
    GUI应用程序。
- en: Unlike coordinates used for plotting functions, drawing contexts use coordinates
    where the y-axis is inverted as shown in [Figure 4-17](ch04.xhtml#ch4fig17). Note
    that the origin is at the upper left corner of the canvas.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于绘制函数的坐标不同，绘图上下文使用的坐标系中的y轴是反转的，如[图 4-17](ch04.xhtml#ch4fig17)所示。请注意，原点位于画布的左上角。
- en: '![Image](../images/04fig18.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig18.jpg)'
- en: '*Figure 4-17: Drawing coordinates*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-17：绘制坐标*'
- en: 'All drawings created using the Racket drawing library will need to import the
    *draw* library, like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有使用Racket绘图库创建的图形都需要导入*draw*库，如下所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this section, we’ll focus on creating simple drawings using a bitmap drawing
    context. To create such a context, we need a bitmap (via `make-bitmap` as shown
    below):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍使用位图绘图上下文创建简单的图形。要创建这样的上下文，我们需要一个位图（通过`make-bitmap`，如下所示）：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need a bitmap drawing context:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个位图绘图上下文：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need some drawing tools. In real life we use pens to draw lines and
    brushes to fill in areas on a canvas; with Racket it’s much the same. We can tell
    Racket the type of pen we want to use in a couple of ways:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些绘图工具。在现实生活中，我们用钢笔画线条，用画笔填充画布上的区域；在Racket中也是如此。我们可以通过几种方式告诉Racket我们想使用什么样的笔：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first method is a quick and dirty way of setting a solid black pen with
    a width of 2\. The second method creates a *pen object* and sends it to the drawing
    context. Colors can be specified as either a string name as shown above, or a
    color object where red, green, blue, and optionally alpha (transparency) values
    can be specified. Each of these values must fall in the range 0–255 (inclusive).
    For example the following inputs will create a cyan color object and set the drawing
    context to use it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是通过设置宽度为2的实心黑色笔进行快速且简便的绘制。第二个方法是创建一个*笔对象*并将其发送到绘图上下文。颜色可以通过字符串名称指定，如上所示，也可以通过颜色对象指定，其中红色、绿色、蓝色以及可选的alpha（透明度）值可以被指定。每个这些值必须在0到255之间（包括0和255）。例如，以下输入将创建一个青色颜色对象，并设置绘图上下文使用它。
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An equivalent, but slightly more efficient way to perform the above would be
    the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一种等效的，但略微高效的方法是执行以下操作：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Brushes control the type of fill used inside of two-dimensional objects like
    rectangles and circles. Like pens, brushes can be defined in a couple of different
    ways:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 画刷控制二维图形（如矩形和圆形）内部的填充类型。像钢笔一样，画刷可以通过几种不同的方式定义：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first example will create a brush that produces a blue cross-hatch fill.
    The second example uses a *brush object* that has a solid red fill. An equivalent
    but slightly different way to achieve the same effect in the second example would
    be the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将创建一个画刷，产生蓝色的交叉填充效果。第二个例子使用一个*画刷对象*，它有一个实心的红色填充。第二个例子中达到相同效果的另一种方法如下：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With these preliminaries out of the way, we can actually start drawing by using
    `send` to send drawing commands to the drawing context. To draw a single line
    segment, we would input the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些前期准备后，我们可以实际开始绘图，通过使用 `send` 向绘图上下文发送绘图命令来实现。要绘制一条单独的线段，我们输入以下代码：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This would draw a line segment beginning at (10, 10) and ending at (30, 25).
    We have added the line to the drawing context, but it’s not immediately displayed.
    To actually see the line, we do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将绘制一条从 (10, 10) 到 (30, 25) 的线段。我们已经将这条线添加到绘图上下文中，但它并不会立即显示。为了实际看到这条线，我们需要做以下操作：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This produces the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下效果：
- en: '![Image](../images/p093-01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p093-01.jpg)'
- en: Remember that `drawing` was defined earlier and is the actual bitmap we are
    drawing to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前定义的 `drawing` 变量，它是我们正在绘制的实际位图。
- en: 'Rectangles are just as easy to produce:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形也同样容易绘制：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first two parameters (0, 0) are the x- and y-coordinates of the upper left
    corner of the rectangle. The next two are the width and height.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数 (0, 0) 是矩形左上角的 x 和 y 坐标。接下来的两个参数是矩形的宽度和高度。
- en: Circles and ellipses are handled in a similar fashion.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形和椭圆的处理方式类似。
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case the parameters specify a *bounding box* that contains the ellipse,
    where again the first two parameters are the x- and y-coordinates of the upper
    left corner of the bounding rectangle and the next two are its width and height
    (see the gray area in [Figure 4-18](ch04.xhtml#ch4fig18)—we’ll discuss the wedge
    shape later).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，参数指定了一个*包围盒*，它包含了椭圆，再次强调，第一个两个参数是包围矩形左上角的 x 和 y 坐标，接下来的两个参数是矩形的宽度和高度（参见[图
    4-18](ch04.xhtml#ch4fig18)中的灰色区域——我们稍后将讨论楔形）。
- en: '![Image](../images/p0094-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0094-01.jpg)'
- en: '*Figure 4-18: Ellipse bounding box*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-18：椭圆包围盒*'
- en: 'To display the drawing, we simply print the variable (`drawing`) that contains
    the bitmap we’ve been drawing to (via the drawing context `dc`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示绘图，我们只需打印包含我们正在绘制的位图的变量（通过绘图上下文 `dc`）：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It produces this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生这样的效果：
- en: '![Image](../images/04fig19.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig19.jpg)'
- en: Text can be added to a drawing with the `draw-text` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以通过 `draw-text` 方法添加到绘图中。
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the last two parameters specify the x- and y-coordinates of the
    upper left corner of the text.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最后两个参数指定了文本左上角的 x 和 y 坐标。
- en: To pull these ideas together, here is some simple code to draw a crude automobile.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些思想结合起来，这里有一些简单的代码来绘制一个粗略的汽车。
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running this code will produce the the stunning work of art shown in [Figure
    4-19](ch04.xhtml#ch4fig19). Depending on your computer the output may look a bit
    different (primarily due to how fonts are handled).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生[图 4-19](ch04.xhtml#ch4fig19)中显示的惊艳艺术作品。根据你的计算机，输出可能会有所不同（主要是由于字体的处理方式不同）。
- en: '![Image](../images/04fig20.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig20.jpg)'
- en: '*Figure 4-19: A stunning work of art*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-19：一件惊艳的艺术作品*'
- en: The drawing library contains much more functionality than we’ve illustrated
    here, but we’ve learned enough to get started. We’ll make practical use of our
    new skills (and learn some new ones) in the next sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图库包含了比我们在这里展示的更多功能，但我们已经学到了足够的知识来开始使用。在接下来的章节中，我们将实际应用我们的新技能（并学习一些新技能）。
- en: Set Theory
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合论
- en: You might be thinking that a chapter on graphics is an odd place to host a discussion
    about set theory, and you’d be right. But it’s easier to understand set theory
    when you can see it, and we can use DrRacket’s excellent graphics capabilities
    to illustrate various basic concepts about set theory. We’ll also get to see some
    additional features of the graphics library.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得将集合论的讨论放在图形章节中是一个奇怪的选择，你说得对。但是，当你能看到图形时，集合论会更容易理解，我们可以利用 DrRacket 出色的图形功能来说明集合论的一些基本概念。我们还将看到图形库的一些额外功能。
- en: '***The Basics***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'A *set* is just some arbitrary collection of things, such as *{*5, 1/2, 7,
    12*}* or *{*car, bus, train*}*. One distinguishing feature of a mathematical set
    is that a mathematical set is not allowed to contain two identical objects. For
    example *{*8, 2, 9, 2*}* is *not* a set, since the number 2 occurs twice (such
    a thing is typically called a *bag* or *multiset*). We can indicate that something
    is in a set by the *member* (or *in*) symbol: ∈. For instance 5 ∈ *{*8, 2, 5,
    9, 3*}*. Likewise, we can specify that something is not in a set by the not-member
    symbol: ∉, as in 7 ∉ *{*8, 2, 9, 3*}*.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 就是一些任意的元素集合，例如 *{*5, 1/2, 7, 12*}* 或 *{*汽车, 公交车, 火车*}*。数学集合的一个显著特点是，数学集合不允许包含两个相同的元素。例如
    *{*8, 2, 9, 2*}* 不是一个集合，因为数字 2 出现了两次（这种情况通常称为 *袋* 或 *多重集合*）。我们可以通过 *成员*（或 *属于*）符号
    ∈ 来表示某个元素属于某个集合。例如 5 ∈ *{*8, 2, 5, 9, 3*}*。同样，我们也可以通过 *非成员* 符号 ∉ 来表示某个元素不属于某个集合，例如
    7 ∉ *{*8, 2, 9, 3*}*。'
- en: In Racket, a set can be represented by an object called a *hash set*. A hash
    set can be either mutable or immutable, depending on how it’s constructed. A mutable
    hash set is created with the `mutable-set` form and an immutable set is constructed
    with the `set` form. We can test whether an element is a member of a hash set
    with `set-member?`. Elements can be added to a mutable set by the `set-add!` form
    and a new set can be created from an old (immutable) one by the `set-add` form.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，集合可以通过一个名为 *hash set* 的对象来表示。一个哈希集合可以是可变的或不可变的，取决于它是如何构建的。可变哈希集合是通过
    `mutable-set` 形式创建的，而不可变集合是通过 `set` 形式构建的。我们可以使用 `set-member?` 来测试一个元素是否是哈希集合的成员。元素可以通过
    `set-add!` 形式添加到可变集合中，并且可以通过 `set-add` 形式从一个旧的（不可变的）集合中创建一个新的集合。
- en: In the examples that follow, `mset` will designate a mutable set and `iset`
    will designate an immutable set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，`mset` 将指定一个可变集合，`iset` 将指定一个不可变集合。
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Observe that we were not able to use `set-add` on our mutable set ➊, and we
    were not able to use `set-add!` on our immutable set ➌. Further, while it did
    not generate an error, adding the number 7 to `mset` ➋ had no effect since 7 was
    already a member.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法在可变集合 ➊ 上使用 `set-add`，也无法在不可变集合 ➌ 上使用 `set-add!`。此外，尽管没有产生错误，但将数字 7 添加到
    `mset` ➋ 上没有任何效果，因为 7 已经是成员。
- en: In many mathematical texts, sets are illustrated by using a diagram that contains
    a rectangle and one or more circles. These diagrams are known as *Venn diagrams*.
    The rectangle is used to designate all the items of interest (called the *universe
    of discourse*—we’ll use the symbol *U* to represent this), and circles are used
    to represent particular sets. To aid in our exploration, we’ll define some helper
    methods to draw various objects in these diagrams.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数学文献中，集合通过包含一个矩形和一个或多个圆的图示来表示。这些图示被称为 *韦恩图*。矩形用于表示所有感兴趣的项目（称为 *讨论宇宙* —— 我们将使用符号
    *U* 来表示它），而圆形用于表示特定的集合。为了帮助我们进行探索，我们将定义一些辅助方法来绘制这些图示中的各种对象。
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code through `(define dc (new bitmap-dc% [bitmap venn]))` should be familiar
    from our previous discussions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define dc (new bitmap-dc% [bitmap venn]))` 这段代码应该对我们之前的讨论很熟悉。'
- en: It’s a bit inconvenient to have our drawing origin in the upper left corner,
    with the y-axis inverted, so we use a new feature called a *transformation*. We
    use the `scale` transform to scale our drawing environment by 1 in the x-axis
    direction and -1 in the y-axis direction. This keeps everything the same size,
    but inverts the y-axis so that up is in the positive direction. To get the origin
    in the middle of the diagram, we use `translate` to center it. (There’s also a
    rotate transformation, but it’s not needed for our present purposes.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘图原点放在左上角，并且 y 轴方向翻转，这有些不方便，因此我们使用一种叫做 *变换* 的新特性。我们使用 `scale` 变换来按 x 轴方向放大
    1 倍，按 y 轴方向放大 -1 倍。这保持了所有东西的大小不变，但将 y 轴翻转，使得向上变为正方向。为了将原点放置在图示的中央，我们使用 `translate`
    来居中它。（还有一种旋转变换，但我们当前的目的不需要使用它。）
- en: The `set-smoothing` argument to `send dc` enables or disables anti-aliased smoothing
    for a drawing. The default value of ’`unsmoothed` produces drawings with a slightly
    jagged appearance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`set-smoothing` 参数用于 `send dc`，可以启用或禁用绘图的抗锯齿平滑。默认值为 `unsmoothed`，会产生略显锯齿的绘图效果。'
- en: The `IN-BRUSH` will be used as the color to designate things that are in a set,
    and the `OUT-BRUSH` is for the color to indicate things that are not in a set.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`IN-BRUSH` 将用作表示集合中元素的颜色，而 `OUT-BRUSH` 用于表示集合外元素的颜色。'
- en: Next, we’ll create a couple of methods to actually do some drawing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些方法来实际进行绘图。
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `rect` method will draw a rectangle whose center is at coordinates (x,y)
    with width and height of `w` and `h` respectively. And `b` is the brush that we
    want to use to draw the rectangle. Similarly, `circle` will draw a circle whose
    center is at coordinates (*x, y*), with radius `r`, and brush `b`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`rect` 方法将绘制一个矩形，其中心位于坐标 (x,y)，宽度和高度分别为 `w` 和 `h`。`b` 是我们想要用来绘制矩形的画笔。类似地，`circle`
    将绘制一个圆，其中心位于坐标 (*x, y*)，半径为 `r`，画笔为 `b`。'
- en: Since we’ll only have occasion to draw a single rectangle (representing the
    universe of discourse, *U*), we create a special function such that it draws it
    appropriately; we only need to supply it with a brush for the color.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要绘制一个矩形（表示讨论宇宙 *U*），我们创建一个特殊函数，使其能够适当地绘制；我们只需要为它提供颜色的画笔。
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s try these out (see [Figure 4-20](ch04.xhtml#ch4fig20)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这些（参见 [图 4-20](ch04.xhtml#ch4fig20)）。
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Image](../images/04fig21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig21.jpg)'
- en: '*Figure 4-20: A diagram indicating a single set*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-20：表示单一集合的图示*'
- en: 'Suppose our universe of discourse is the integers (that is, *U* = ℤ). We can
    represent the set of even numbers by the green circle. Now suppose that we’re
    interested in anything that is *not* an even number. This is the *complement*
    of the set of even numbers. The set complement of *A* can be represented as *A*^(*c*),
    Ā, or *A*’. We represent this in a Venn diagram as follows (and shown in [Figure
    4-21](ch04.xhtml#ch4fig21)):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的讨论宇宙是整数（即 *U* = ℤ）。我们可以用绿色圆圈表示偶数集。现在假设我们对任何*不是*偶数的元素感兴趣。这就是偶数集的*补集*。*A*
    的集合补集可以表示为 *A*^(*c*)，Ā，或 *A*’。我们在维恩图中表示如下（并参见[图 4-21](ch04.xhtml#ch4fig21)）：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Image](../images/04fig22.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig22.jpg)'
- en: '*Figure 4-21: Items not in the set*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-21：集合外的元素*'
- en: Note that we used `erase` to clear the drawing context before generating the
    next diagram.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在生成下一个图示之前，我们使用了 `erase` 来清除绘图上下文。
- en: 'Sets can be combined in various ways. Suppose we have two sets: *A* and *B*.
    One way to combine these sets is to form a new set that is the unique combination
    of all the elements from set *A* and *B*. This operation is called *set union*,
    and is designated by the symbol ∪. If *C* is the union of *A* and *B*, the mathematical
    expression to reflect this is *C* = *A* ∪ *B*. Using *set-builder* notation, the
    set complement would be expressed as *A*^(*c*) = *{x* ∈ *U* ∣ *x* ∉ *A}*. In words
    this would be “the set of all *x* in U such that *x* is not in *A*."'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以以多种方式组合。假设我们有两个集合：*A* 和 *B*。一种组合这些集合的方式是形成一个新的集合，这个集合是集合 *A* 和 *B* 中所有元素的唯一组合。这个操作叫做*集合并*，用符号
    ∪ 表示。如果 *C* 是 *A* 和 *B* 的并集，那么数学表达式表示为 *C* = *A* ∪ *B*。使用*集合构造*符号，集合补集可以表示为 *A*^(*c*)
    = *{x* ∈ *U* ∣ *x* ∉ *A}*。用语言表达就是“*U* 中所有 *x* 的集合，使得 *x* 不在 *A* 中。”
- en: 'Another way to think of the union of sets *A* and *B* is to see that it consists
    of following components:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种理解集合 *A* 和 *B* 并集的方法是将其看作由以下几个部分组成：
- en: All the elements that are in *A* and not in *B* (left partial circle).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在 *A* 中而不在 *B* 中的元素（左侧部分圆形）。
- en: All the elements that are in *B* and not in *A* (right partial circle).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在 *B* 中而不在 *A* 中的元素（右侧部分圆形）。
- en: All the elements that are in both *A* and *B* (the central shape of the diagram—this
    shape is called a *vesica* *piscis*, Latin for “bladder of a fish").
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有同时在 *A* 和 *B* 中的元素（图示的中央形状——这个形状称为*鱼膀胱*，拉丁语为“鱼的膀胱”）。
- en: See [Figure 4-22](ch04.xhtml#ch4fig22) for an example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 [图 4-22](ch04.xhtml#ch4fig22) 以查看示例。
- en: '![Image](../images/04fig23.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig23.jpg)'
- en: '*Figure 4-22: Set union*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-22：集合并*'
- en: '***A Short Mathematical Detour***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***简短的数学绕行***'
- en: In order to be able to draw the Venn diagram components in [Figure 4-22](ch04.xhtml#ch4fig22),
    we’ll need to do a few straightforward calculations first. We’ll base our calculation
    on the nomenclature illustrated in [Figure 4-23](ch04.xhtml#ch4fig23).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够绘制 [图 4-22](ch04.xhtml#ch4fig22) 中的维恩图组件，我们首先需要做一些简单的计算。我们的计算将基于 [图 4-23](ch04.xhtml#ch4fig23)
    中说明的命名法。
- en: '![Image](../images/p0100-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0100-01.jpg)'
- en: '*Figure 4-23: How to draw a Venn diagram*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-23：如何绘制维恩图*'
- en: 'Let’s see how to find the values of *x*[*i*], *y*[*i*], *θ*, and *ϕ* shown
    in [Figure 4-23](ch04.xhtml#ch4fig23). Assume that *x*[*c*], *y*[*c*], and *r*
    are given. Note that the circles are clearly symmetric about the y-axis, which
    eases our task somewhat. It’s immediate that *x*[*i*] = 0\. The equation of a
    circle with center on the x-axis is given by the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何找到[图 4-23](ch04.xhtml#ch4fig23)中显示的 *x*[*i*]、*y*[*i*]、*θ* 和 *ϕ* 的值。假设
    *x*[*c*]、*y*[*c*] 和 *r* 已知。注意，圆形显然关于 y 轴对称，这在某种程度上简化了我们的任务。可以立即得出 *x*[*i*] = 0。一个以
    x 轴为中心的圆的方程如下所示：
- en: (x - x[c])² + y² = r²
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (x - x[c])² + y² = r²
- en: 'The intersection points occur at *x* = 0\. With this substitution and solving
    for *y*, we have the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 交点出现在 *x* = 0。通过这个代入并解出 *y*，我们得到以下结果：
- en: '![Image](../images/p0100-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0100-02.jpg)'
- en: 'Given *y*, the angles are easy:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *y*，角度很容易求出：
- en: '![Image](../images/p0100-03.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0100-03.jpg)'
- en: Now let’s exercise a new DrRacket graphics feature called *paths*. The path
    functionality allows one to draw arbitrary figures. A path is constructed by selecting
    a starting location and building a sequence of segments to define the entire path.
    Path segments can consist of straight lines, arcs and something called bezier
    curves (see the manual). We construct a filled path to represent the center portion
    of the Venn diagram (the *vesica piscis*) with the following method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来练习一种新的 DrRacket 图形功能，称为 *路径*。路径功能允许绘制任意的图形。路径是通过选择起始位置并构建一系列段来定义整个路径。路径段可以由直线、弧线和一种称为贝塞尔曲线的图形组成（请参见手册）。我们通过以下方法构建一个填充路径来表示韦恩图的中心部分（*vesica
    piscis*）。
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Within the `let*` form we find direct translations of Equations (4.1) ➊ and
    (4.2) ➋. The identifier `path` is then bound to a new `dc-path%` object ➌. Paths
    work sort of like drawing contexts in that path commands are sent to the path
    object to build the path. The code then positions us at the initial location to
    draw the first arc ➍ . The first arc is then drawn ➎, and completed by mirroring
    the first arc ➏. The path `arc` command works like a drawing context `draw-ellipse`
    command. The only difference is that `arc` takes additional parameters specifying
    the start and stop angles. The finished path is then sent to the drawing context
    to be rendered ➐.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `let*` 表达式中，我们可以找到方程 (4.1) ➊ 和 (4.2) ➋ 的直接翻译。标识符 `path` 然后被绑定到一个新的 `dc-path%`
    对象 ➌。路径的工作方式有点像绘图上下文，路径命令会发送到路径对象来构建路径。代码随后将我们定位到初始位置，以绘制第一个弧线 ➍。然后绘制第一个弧线 ➎，并通过镜像第一个弧线来完成它
    ➏。路径 `arc` 命令类似于绘图上下文中的 `draw-ellipse` 命令。唯一的区别是，`arc` 需要额外的参数来指定起始角度和结束角度。完成的路径会被发送到绘图上下文中渲染
    ➐。
- en: '***Drawing Conclusions***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***得出结论***'
- en: With `piscis` under our belt, we have most of the machinery we need to draw
    any binary set operation. To aid in our quest, let’s define a simple function
    to generate the final diagrams.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了 `piscis` 后，我们已经具备了绘制任何二元集合运算所需的大部分工具。为了帮助我们的任务，让我们定义一个简单的函数来生成最终的图表。
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We define a new light green color in `SET-BRUSH` to identify the sets participating
    in the operation. The `venn-bin` method (the `bin` part just refers to the fact
    that it’s drawing a binary operation) takes three brushes, one to identify each
    component of the diagram. The rest of the code should be self-explanatory.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `SET-BRUSH` 中定义了一种新的浅绿色，用于标识参与运算的集合。`venn-bin` 方法（`bin` 部分只是指它在绘制二元操作）接受三种刷子，每种刷子标识图表中的一个组件。其余的代码应该是不言自明的。
- en: 'To generate the union diagram we saw in [Figure 4-22](ch04.xhtml#ch4fig22),
    we use:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们在[图 4-22](ch04.xhtml#ch4fig22)中看到的并集图，我们使用：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To illustrate Racket’s set operations we’ll use two sets:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Racket 的集合操作，我们将使用两个集合：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the result of forming the union (*A* ∪ *B*) of the two sets:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是形成两个集合的并集 (*A* ∪ *B*) 后的结果：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that sets are not guaranteed to be in any particular order.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，集合不一定按任何特定顺序排列。
- en: 'Our next operation is *set intersection*. Set intersection is designated by
    the symbol ∩. The intersection of *A* and *B* consists of all the elements that
    are in both *A* and *B*. That’s *A* ∩ *B* = *{x* ∣ *x* ∈ *A* and *x* ∈ *B}*. The
    Venn diagram for intersection is given by the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的操作是 *集合交集*。集合交集由符号 ∩ 表示。*A* 和 *B* 的交集包含所有同时属于 *A* 和 *B* 的元素。即 *A* ∩ *B*
    = *{x* ∣ *x* ∈ *A* 且 *x* ∈ *B}*。交集的韦恩图如下所示：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s also shown in [Figure 4-24](ch04.xhtml#ch4fig24).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它也显示在[图 4-24](ch04.xhtml#ch4fig24)中。
- en: '![Image](../images/04fig25.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig25.jpg)'
- en: '*Figure 4-24: Set intersection*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-24：集合交集*'
- en: 'Here’s an example of Racket code for intersection:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Racket 代码的交集示例：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next up is *set difference*. Set difference is designated by the symbol *\*.
    The set difference of *A* and *B* consists of all the elements that are in *A*
    that are not also in *B*. That’s *A \ B* = *{x* ∣ *x* ∈ *A* and *x* ∉ *B}*. The
    Venn diagram for set difference is given by the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 *集合差异*。集合差异由符号 *\* 表示。*A* 和 *B* 的集合差异包含所有属于 *A* 但不属于 *B* 的元素。即 *A \ B*
    = {*x* ∣ *x* ∈ *A* 且 *x* ∉ *B*}。集合差异的维恩图如下所示：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It’s also shown in [Figure 4-25](ch04.xhtml#ch4fig25).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它也显示在 [图 4-25](ch04.xhtml#ch4fig25) 中。
- en: '![Image](../images/04fig26.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig26.jpg)'
- en: '*Figure 4-25: Set difference*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-25：集合差异*'
- en: Set difference is performed with the `set-subtract` function in Racket.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 集合差异通过 Racket 中的 `set-subtract` 函数执行。
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our final operation is *symmetric difference*. Symmetric difference is designated
    by the symbol △. The symmetric difference of *A* and *B* consists of all the elements
    that are in *A* or *B*, but are not also in both *A* and *B*. That’s *A* △ *B*
    = {*x* ∣ *x* ∈ *A* or *x* ∈ *B*, but not *x* ∈ *A* and *x* ∈ *B*}. The Venn diagram
    for symmetric difference is given by
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终操作是 *对称差异*。对称差异由符号 △ 表示。*A* 和 *B* 的对称差异包含所有属于 *A* 或 *B* 但不同时属于 *A* 和 *B*
    的元素。即 *A* △ *B* = {*x* ∣ *x* ∈ *A* 或 *x* ∈ *B*，但 *x* 不属于 *A* 且不属于 *B*}。对称差异的维恩图如下所示：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See an example in [Figure 4-26](ch04.xhtml#ch4fig26).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [图 4-26](ch04.xhtml#ch4fig26) 中的示例。
- en: '![Image](../images/04fig27.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig27.jpg)'
- en: '*Figure 4-26: Symmetric difference*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-26：对称差异*'
- en: Symmetric set difference is performed with the `set-symmetric-difference` function
    in Racket.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对称集合差异通过 Racket 中的 `set-symmetric-difference` 函数执行。
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***Are We Related?***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***我们有关联吗？***'
- en: There are a couple of important relationships in the theory of sets that you
    should be aware of. The first is the concept of *subsets*. A set *A* is a subset
    of another set *B* if all the elements of *A* are also elements of *B*. This relationship
    is represented by the symbol ⊆. In Racket it’s possible to test whether one set
    is a subset of another with the predicate `subset?`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合理论中，有几个重要的关系是你应该了解的。第一个是 *子集* 的概念。如果集合 *A* 的所有元素也都是集合 *B* 的元素，那么集合 *A* 是集合
    *B* 的子集。这个关系由符号 ⊆ 表示。在 Racket 中，可以使用谓词 `subset?` 来测试一个集合是否是另一个集合的子集。
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A subset relationship like the one in the first example can be represented by
    the Venn diagram shown in [Figure 4-27](ch04.xhtml#ch4fig27). In this case the
    inner circle is entirely enclosed by the outer circle.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例中的子集关系可以通过 [图 4-27](ch04.xhtml#ch4fig27) 中的维恩图表示。在这种情况下，内圈完全被外圈包围。
- en: '![Image](../images/04fig28.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig28.jpg)'
- en: '*Figure 4-27: A subset relationship*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-27：子集关系*'
- en: If a set *A* is a subset of *B*, but *A* ≠ *B*, *A* is said to be a *proper
    subset* of *B*. This is designated by the symbol ⊂. Racket provides the `proper-subset?`
    predicate to perform this function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合 *A* 是集合 *B* 的子集，但 *A* ≠ *B*，则称 *A* 为 *B* 的 *真子集*。这个关系由符号 ⊂ 表示。Racket 提供了
    `proper-subset?` 谓词来执行此功能。
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Given sets *A* and *B*, the *Cartesian product* is defined as the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 给定集合 *A* 和 *B*，*笛卡尔积* 定义如下：
- en: '*A* × *B* = {(*a*, *b*) | ∣ *a* ∈ *A* and *b* ∈ *B*}'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* × *B* = {(*a*, *b*) | *a* ∈ *A* 且 *b* ∈ *B*}'
- en: While Racket doesn’t have a built-in function that returns the Cartesian product
    of two sets, it’s easy enough to produce our own version.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Racket 没有内建的函数返回两个集合的笛卡尔积，但我们可以轻松地自己实现一个版本。
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But a somewhat more succinct version is the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个更简洁的版本如下：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'which we can test as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式进行测试：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From this it can be seen that the Cartesian product is the set of all possible
    pairs of values that can be generated from two given sets. Subsets of Cartesian
    products are frequently used to define relationships. For example, if *A* = {1,
    2, 3, 4}, we can express the “less than” relationship as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，笛卡尔积是从两个给定集合中生成的所有可能值对的集合。笛卡尔积的子集常常用于定义关系。例如，如果 *A* = {1, 2, 3, 4}，我们可以如下表示“小于”关系：
- en: '{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}'
- en: Observe that the first value in each pair is always less than the second element.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每对中的第一个值总是小于第二个元素。
- en: This completes our brief foray into applying DrRacket’s graphical capabilities
    to the exciting topic of set theory. Next we’ll take a look at a couple of extended
    applications where we utilize these capabilities to explore additional topics
    in mathematics.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的探索结束了我们利用 DrRacket 的图形功能，探讨集合理论这一激动人心的主题。接下来，我们将看看几个扩展应用，利用这些功能来探索数学中的其他主题。
- en: Applications
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用
- en: Let’s begin with an old acquaintance, the Fibonacci sequence.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个老朋友开始，斐波那契数列。
- en: '***Fibonacci Revisited***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***斐波那契复习***'
- en: As we learned in the last chapter in the Fibonacci and Friends section, it’s
    always possible to tile a rectangle with squares whose sides are given by the
    Fibonacci sequence. In this section we’ll create a function that can draw the
    tiling for any Fibonacci number (up to the screen limit). The tiling begins in
    the center of the drawing canvas and proceeds by essentially spiraling out from
    that point. Before we dive into writing code for this, a little analysis will
    guide our way.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个章节的斐波那契与朋友部分所学，使用斐波那契数列给出的边长的正方形始终可以平铺一个矩形。在这一部分，我们将创建一个可以绘制任何斐波那契数（直到屏幕限制）的平铺的函数。平铺从绘图画布的中心开始，并通过从该点螺旋状扩展出去。我们在编写这段代码之前，进行一些小的分析将帮助我们找到方向。
- en: '**Tiling**'
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**平铺**'
- en: Observe [Figure 4-28](ch04.xhtml#ch4fig28). We’ll use the upper left corner
    of each square as a reference point (as indicated by the black quadrants). Each
    arrow indicates the direction we must move to create the next Fibonacci square.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[图 4-28](ch04.xhtml#ch4fig28)。我们将使用每个正方形的左上角作为参考点（如黑色象限所示）。每个箭头表示我们必须移动的方向，以创建下一个斐波那契正方形。
- en: '![Image](../images/04fig29.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig29.jpg)'
- en: '*Figure 4-28: Tile analysis*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-28：瓷砖分析*'
- en: If *n* is the *n*th Fibonacci number (*F*[*n*]), we designate *f*[*n*] as the
    *n*th Fibonacci square with sides of length *s*[*n*] (this is just some constant
    multiple of *F*[*n*]). The coordinates of the upper left corner of *f*[*n*] will
    be given by (*x*[*n*], *y*[*n*]). We assume the drawing is initialized with *f*[1]
    and *f*[2] as indicated by the two small, unlabeled squares in the center of the
    drawing. Moving up from *f*[2] to *f*[3], we see that (*x*[3], *y*[3]) = (*x*[1],
    *y*[2] - 2). We can generalize this to (*x*[n], *y*[n]) = (*x*[n-2], y[n-1] -
    s[n]) whenever we move from one tile to another in an upward direction. [Table
    4-1](ch04.xhtml#ch4tab1) gives the change in coordinates for all four directions.
    Since the pattern repeats itself after four moves, the applicable move is given
    in the remainder (*n* mod 4) column.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 是第 *n* 个斐波那契数（*F*[*n*]），我们将 *f*[*n*] 定义为具有边长 *s*[*n*] 的第 *n* 个斐波那契正方形（这只是
    *F*[*n*] 的某个常数倍）。*f*[*n*] 的左上角坐标为（*x*[*n*]，*y*[*n*]）。我们假设绘图已经初始化，*f*[1] 和 *f*[2]
    如图中心的两个小正方形所示。从 *f*[2] 向上移动到 *f*[3]，我们看到（*x*[*3*]，*y*[*3*]）=（*x*[*1*]，*y*[*2*]
    - 2）。我们可以将这一点推广为（*x*[*n*]，*y*[*n*]）=（*x*[*n-2*]，*y*[*n-1*] - *s*[*n*]），每当我们从一个正方形移动到另一个正方形时，方向向上。[表
    4-1](ch04.xhtml#ch4tab1) 给出了四个方向的坐标变化。由于模式在四次移动后会重复，因此适用的移动由余数（*n* mod 4）列给出。
- en: '**Table 4-1**: Direction Coordinates'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1**：方向坐标'
- en: '| Direction | Coordinates | *n* mod 4 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 方向 | 坐标 | *n* mod 4 |'
- en: '| --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *↑* | (x[n-2], y[n-1] – s[n]) | 3 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| *↑* | (x[n-2], y[n-1] – s[n]) | 3 |'
- en: '| ← | (x[n-1] – s[n], y[n-1]) | 0 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| ← | (x[n-1] – s[n], y[n-1]) | 0 |'
- en: '| *↓* | (x[n-1], y[n-1] + s[n-1]) | 1 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| *↓* | (x[n-1], y[n-1] + s[n-1]) | 1 |'
- en: '| → | (x[n-1] + s[n-1], y[n-2]) | 2 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| → | (x[n-1] + s[n-1], y[n-2]) | 2 |'
- en: 'This table tells us that at any stage of the drawing process we’ll need access
    to not only *F*[*n*] and *F*[*n-*1], but also (x[n-1], y[n-1]) and (*x*[n-2],
    *y*[n-2]). We’ll use the second method introduced in the Fibonacci and Friends
    section to produce *F*[*n*] in our drawing code. Hence, we’ll describe a `draw-tiles`
    function that takes a Fibonacci *n* and returns four values: *x*[*n-*1], *y*[*n-*1],
    *x*[*n-*2], and *y*[*n-*2]. These values along with *F*[*n*] and *F*[*n-*1] will
    be used to draw the *n*th tile.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这张表告诉我们，在绘制过程中任何阶段，我们不仅需要访问 *F*[*n*] 和 *F*[*n-*1]，还需要（x[n-1], y[n-1]）和（*x*[*n-2]，*y*[*n-2]）。我们将使用斐波那契与朋友部分介绍的第二种方法来生成绘图代码中的
    *F*[*n*]。因此，我们将描述一个 `draw-tiles` 函数，该函数接收一个斐波那契 *n* 并返回四个值：*x*[*n-*1]，*y*[*n-*1]，*x*[*n-*2]，和
    *y*[*n-*2]。这些值与 *F*[*n*] 和 *F*[*n-*1] 一起用于绘制第 *n* 个瓷砖。
- en: '[Figure 4-29](ch04.xhtml#ch4fig29) shows the result from calling `(draw-tiles
    10)`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-29](ch04.xhtml#ch4fig29) 显示了调用 `(draw-tiles 10)` 后的结果。'
- en: '![Image](../images/04fig30.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig30.jpg)'
- en: '*Figure 4-29: A Fibonacci tiling*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-29：斐波那契平铺*'
- en: Our code begins with some constant definitions to establish the parameters to
    be used in the rest of the program.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从一些常量定义开始，以设定在程序其余部分中使用的参数。
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There should be sufficient comments here to determine what’s what. We’ve fudged
    a bit by adding some offset values to account for the asymmetric nature of the
    tiling.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该有足够的注释来说明每个部分的作用。我们通过添加一些偏移值来弥补瓷砖不对称的特性。
- en: Next we set up our drawing surface, pen, and brush.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置绘图表面、画笔和画刷。
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we define two functions: one to compute *F*[*n*] and the other, `draw-n`,
    to actually produce the tiling in [Listing 4-1](ch04.xhtml#ch04list1):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义两个函数：一个用于计算*F*[*n*]，另一个是`draw-n`，用于实际生成[清单 4-1](ch04.xhtml#ch04list1)中的瓷砖：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 4-1: Fibonacci with Tiling*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1: 使用瓷砖的斐波那契数列*'
- en: The `draw-n` function is the workhorse of this process. This procedure is recursively
    called ➎ until the desired number of tiles is drawn. First, we compute *F*[*n*]
    ➊ and *F*[*n-*1] ➌. Then we simply multiply these numbers by the constant `UNIT`
    ➋ ➍ to determine the sizes of the squares. Next, we determine the coordinates
    of the upper left corner of the square as described during the discussion of [Table
    4-1](ch04.xhtml#ch4tab1) ➏ ➐. Following this, the tile is actually drawn ➑. Finally,
    the values *x*[*n-*1], *y*[*n-*1], *x*[*n-*2], and *y*[*n-*2] mentioned in our
    analysis section above are returned ➒ as these values are needed by the preceding
    recursive call ➎.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw-n`函数是这个过程的核心。这个过程会递归调用➎，直到绘制出所需数量的瓷砖。首先，我们计算*F*[*n*] ➊和*F*[*n-*1] ➌。然后，我们将这些数字乘以常量`UNIT`
    ➋ ➍来确定方块的大小。接下来，我们根据[表 4-1](ch04.xhtml#ch4tab1)中讨论的内容确定方块左上角的坐标 ➏ ➐。然后，实际绘制瓷砖
    ➑。最后，我们返回在上述分析部分中提到的值*x*[*n-*1]、*y*[*n-*1]、*x*[*n-*2]和*y*[*n-*2] ➒，因为这些值是前一个递归调用➎所需要的。'
- en: 'To actually produce the drawing, we have this code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际绘制图形，我们有以下代码：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It initializes the drawing with the two unit squares, calls `draw-n`, and outputs
    the constructed bitmap to the screen.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 它用两个单位方块初始化绘图，调用`draw-n`，并将构建的位图输出到屏幕上。
- en: Finally, calling `(draw-tiles 10)` will produce the output shown previously
    in [Figure 4-29](ch04.xhtml#ch4fig29).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`(draw-tiles 10)`将生成之前在[图 4-29](ch04.xhtml#ch4fig29)中展示的输出。
- en: '**The Golden Spiral (Approximation)**'
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**黄金螺旋（近似）**'
- en: To produce the golden spiral discussed in [Chapter 3](ch03.xhtml) (and reproduced
    in [Figure 4-30](ch04.xhtml#ch4fig30)), we only need to make a few additions to
    our tiling code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制在[第3章](ch03.xhtml)中讨论的黄金螺旋（并在[图 4-30](ch04.xhtml#ch4fig30)中再现），我们只需在我们的瓷砖代码中添加几行内容。
- en: '![Image](../images/04fig31.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig31.jpg)'
- en: '*Figure 4-30: The golden spiral*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-30: 黄金螺旋*'
- en: We begin by defining a new drawing pen and brush to be used for creating the
    spiral.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的绘图画笔和画刷，用于绘制螺旋。
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To produce the spiral, we’ll be using the `draw-arc` function. This function
    works just like `draw-ellipse` except that it takes two additional arguments that
    specify the start and stop angles for the arc. These values are designated by
    *θ*[0] and *θ*[1] in [Figure 4-18](ch04.xhtml#ch4fig18). By default, arcs use
    a filled brush, so to keep from covering the tiles, we define `TRANS-BRUSH` as
    a transparent brush. The spirals are produced by drawing an arc each time a tile
    is produced. We predefine the various angles (in radians) we will need to use
    for the arcs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制螺旋，我们将使用`draw-arc`函数。这个函数的工作方式与`draw-ellipse`相似，不同之处在于它多了两个参数，用来指定弧线的起始角度和终止角度。这些值在[图
    4-18](ch04.xhtml#ch4fig18)中由*θ*[0]和*θ*[1]表示。默认情况下，弧线使用填充画刷，因此为了避免覆盖瓷砖，我们将`TRANS-BRUSH`定义为透明画刷。螺旋是通过每绘制一个瓷砖就绘制一个弧线来产生的。我们预先定义了绘制弧线时需要用到的各种角度（以弧度为单位）：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next we define the actual function used to draw the spiral segments.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了用于绘制螺旋段的实际函数。
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: First, we determine the start and stop angles for the arcs ➊, as well as the
    x-coordinate and y-coordinate of the location to draw the arcs. Next, we switch
    to the appropriate pen and brush to draw the arc. Finally, the drawing context
    is reset to the one needed to draw the tiles.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定弧线的起始角度和终止角度 ➊，以及绘制弧线的位置的x坐标和y坐标。接下来，我们切换到适当的画笔和画刷来绘制弧线。最后，绘图上下文被重置为绘制瓷砖所需的状态。
- en: 'The only change needed to the `draw-n` code is to add this single line immediately
    after the `(draw-tile x y sn)` statement ➑ in [Listing 4-1](ch04.xhtml#ch04list1):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对`draw-n`代码所需的唯一修改是在[清单 4-1](ch04.xhtml#ch04list1)中的`(draw-tile x y sn)`语句 ➑后立即添加这一行：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With this change, calling `(draw-tiles 10)` will now produce the tiling overlaid
    by the golden spiral as shown in [Figure 4-30](ch04.xhtml#ch4fig30).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，调用 `(draw-tiles 10)` 现在会生成一个覆盖黄金螺旋的瓷砖，如 [图 4-30](ch04.xhtml#ch4fig30)
    所示。
- en: '***Nim***'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Nim***'
- en: Nim is a strategy game in which two players take turns removing objects from
    distinct heaps. On each turn, a player must remove at least one object, and may
    remove any number of objects provided they all come from the same heap. The winner
    of the game is the player who removes the last object. This game can also be played
    where the person who removes the last object loses, but in our version, the player
    who takes the last object wins.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Nim 是一款策略游戏，两个玩家轮流从不同的堆中移除物体。每一轮，玩家必须至少移除一个物体，并且可以移除任意数量的物体，只要它们都来自同一个堆。游戏的胜者是最后移除物体的玩家。这个游戏也可以修改为移除最后一个物体的玩家输，但在我们这个版本中，移除最后一个物体的玩家获胜。
- en: In this version of Nim we’ll have three piles with up to 15 balls in each pile,
    as shown in [Figure 4-31](ch04.xhtml#ch4fig31). Instead of two human players,
    this time it will be man versus machine, you against the computer, *mano a mano*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 Nim 中，我们将有三个堆，每个堆最多有15个球，如 [图 4-31](ch04.xhtml#ch4fig31) 所示。这次不再是两个玩家对战，而是人类对机器，*mano
    a mano*。
- en: '![Image](../images/04fig32.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig32.jpg)'
- en: '*Figure 4-31: Nim starting piles*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-31：Nim 开始的堆*'
- en: '**Setting Up the Graphics**'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置图形**'
- en: We’ll begin with some basic definitions to establish some useful constants.
    Most of these should be fairly obvious. The `BOARD` references are to the brown
    board the balls rest on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些基本定义开始，以建立一些有用的常量。这些常量大多数应该是相当明显的。`BOARD`引用的是球体所放置的棕色板。
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The linchpin of Nim’s graphics is the `draw-pile` routine, shown below, which
    draws a single pile of balls. This code calls `draw-ball` with the x- and y- coordinates
    of the location of the center of each ball. It draws each row (see `draw-row`),
    bottom up, until there are either no more balls or the row has its full complement
    of balls.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Nim 图形的关键是 `draw-pile` 函数，如下所示，它绘制了一个单独的球堆。此代码使用球的中心位置的 x 和 y 坐标调用 `draw-ball`。它从下到上绘制每一行（见
    `draw-row`），直到没有更多球或该行已经包含所有球。
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we come to the code that actually draws the entire Nim environment,
    `draw-game`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看一下实际上绘制整个 Nim 环境的代码 `draw-game`：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This routine simply draws rectangles for the background and board under the
    piles. It then calls `draw-pile` once for each pile. The number of balls contained
    in each pile is stored in the vector variable `pile`. For reference, the pile
    number is shown below each pile.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程只是绘制了背景和堆下的矩形板。然后它会为每个堆调用一次 `draw-pile`。每个堆中包含的球的数量存储在向量变量 `pile` 中。作为参考，堆的编号显示在每个堆下方。
- en: '**Gameplay**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**游戏玩法**'
- en: Nim is a bit unusual in the world of games in that a perfect play strategy is
    known to exist. It’s relatively easy to implement, but it’s not obvious. So once
    you’ve programmed this, you can spring it on one of your unsuspecting friends
    and have the computer beat the snot out of them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Nim 游戏在所有游戏中有点不同，因为已知存在一种完美的游戏策略。它相对容易实现，但并不显而易见。所以，一旦你编写了这个程序，你就可以将它用在一个毫无戒备的朋友身上，让电脑把他打得一败涂地。
- en: The key to this strategy is something called the *nim-sum*. The nim-sum is simply
    the bitwise exclusive-or of the number of pieces in each pile. The exclusive-or
    operator is given by the mathematical symbol ⊕ and is often designated as xor.
    It’s computed in Racket by the function `bitwise-xor`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这一策略的关键是所谓的 *nim-sum*。nim-sum 就是每个堆中物体数量的按位异或。异或运算符用数学符号 ⊕ 表示，通常称为 xor。它可以通过
    Racket 的 `bitwise-xor` 函数来计算。
- en: 'Bitwise exlusive-or is computed as follows: if you are combining two single
    bits and both bits are the same, then the result is 0; otherwise, it’s 1\. For
    example, 1 ⊕ 1 = 0 and 1 ⊕ 0 = 1.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或的计算方法如下：如果你在结合两个单一的比特且两个比特相同，则结果为0；否则，结果为1。例如，1 ⊕ 1 = 0 和 1 ⊕ 0 = 1。
- en: 'In Racket we can display the binary representation of a number by using `"`˜`b"`
    in the form string of the `printf` statement. For example, we have the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，我们可以通过在 `printf` 语句的格式字符串中使用 `"`˜`b"` 来显示数字的二进制表示。例如，我们有如下代码：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice that if you take the bitwise exclusive-or in each corresponding bit position
    of 13[10] = 1101[2] and 9[10] = 1001[2] , you wind up with 0100[2].
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你在对应的比特位置上对13[10] = 1101[2] 和 9[10] = 1001[2] 进行按位异或运算，你会得到 0100[2]。
- en: 'It turns out that the winning strategy is just to finish every move with a
    nim-sum (that is, an exclusive-or) of 0\. This is always possible if the nim-sum
    is not zero before the move. The way to achieve this is with the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，获胜的策略就是每次操作结束时使 nim-sum（即异或）为 0。如果在操作之前 nim-sum 不为零，那么这种方法总是可行的。实现这一点的方法如下：
- en: Designate *b*[0], *b*[1], and *b*[2], as the number of balls in piles 0, 1,
    and 2 respectively.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 *b*[0]、*b*[1] 和 *b*[2]* 为堆 0、堆 1 和堆 2 中的球数。
- en: Let *s* = *b*[0] ⊕ *b*[1] ⊕ *b*[2] be the nim-sum of the all the pile sizes.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 *s* = *b*[0] ⊕ *b*[1] ⊕ *b*[2] 为所有堆大小的 nim-sum。
- en: Compute *n*[0] = *s* ⊕ *b*[0], *n*[1] = *s* ⊕ *b*[1], and *n*[2] = *s* ⊕ *b*[2].
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *n*[0] = *s* ⊕ *b*[0]、*n*[1] = *s* ⊕ *b*[1] 和 *n*[2] = *s* ⊕ *b*[2]。
- en: Of the three piles, at least one of the values *n*[0], *n*[1], or *n*[2] will
    be numerically less than the number of items in the corresponding pile. We select
    from one of these piles and designate it by the letter *i*.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这三堆中，至少有一个值 *n*[0]、*n*[1] 或 *n*[2] 的数值将小于对应堆中的物品数量。我们从其中一堆中选择，并用字母 *i* 来表示它。
- en: The winning play is then to simply reduce pile *i* to size *n*[*i*]. That is,
    the move is to remove *b*[*i*] *- n*[*i*] balls from pile *i*.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获胜的操作是将堆 *i* 的大小减少到 *n*[*i*]。也就是说，这一步是从堆 *i* 中移除 *b*[*i*] *- n*[*i*] 个球。
- en: If the nim-sum is zero at the beginning of a player’s turn, that player will
    lose if their opponent plays perfectly. In that case, the best strategy is to
    stall by picking a single ball from one of the piles and hope that the opponent
    will make a mistake at some point. The reason this strategy works is somewhat
    technical, but an analysis can be found in the Wikipedia article at *[https://en.wikipedia.org/wiki/Nim](https://en.wikipedia.org/wiki/Nim)*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在玩家回合开始时 nim-sum 为零，那么如果对手完美发挥，该玩家将会输。在这种情况下，最佳策略是通过从其中一堆中取出一个球来拖延时间，并希望对手在某个时刻犯错。之所以这种策略有效，原因有点技术性，不过可以在维基百科的文章中找到分析，链接为
    *[https://en.wikipedia.org/wiki/Nim](https://en.wikipedia.org/wiki/Nim)*。
- en: This brings us to the actual Racket code to find a winning move.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了实际的 Racket 代码，用于找到获胜的操作。
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, we define `nim-sum` as `bitwise-xor` ➊. Next, we have the helper function
    `random-pile` ➋, which just finds a random pile that has balls. We use this to
    implement the stalling strategy mentioned above. `find-move` implements our overall
    playing strategy mentioned in the itemized steps above. This function returns
    two values: the pile number and the number of balls to remove from the pile. Now
    we compute the overall nim-sum ➌ (step 2 in the above procedure). This sum is
    then tested ➍, and if it’s zero, it simply returns a random pile with one ball
    to be removed. The computation mentioned in step 3 above is performed ➎. The local
    function `test?` ➏ determines whether *n*[*i*] < *b*[*i*]. The local function
    `move` returns the pile number and the number of balls to remove as mentioned
    in step 5 above. Finally, we perform tests to determine which pile to use ➐.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `nim-sum` 定义为 `bitwise-xor` ➊。接下来，我们有辅助函数 `random-pile` ➋，它只是找到一个有球的随机堆。我们用它来实现上述提到的拖延策略。`find-move`
    实现了我们在上面列出的整体游戏策略。该函数返回两个值：堆的编号和从堆中移除的球数。现在我们计算整体的 nim-sum ➌（上面步骤 2）。然后测试这个和 ➍，如果它为零，它就返回一个随机堆，移除一个球。上面步骤
    3 中提到的计算执行 ➎。局部函数 `test?` ➏ 确定 *n*[*i*] 是否小于 *b*[*i*]。局部函数 `move` 返回堆的编号和要移除的球数，如步骤
    5 所示。最后，我们进行测试以确定使用哪个堆 ➐。
- en: Before we create code for the player to enter their move, we define a few helper
    functions.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为玩家输入他们的操作创建代码之前，我们定义了一些辅助函数。
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `apply-move` function updates the designated pile by removing the specified
    number of balls. The `game-over?` function tests whether there are any balls left
    to play. And the `valid-move?` function tests whether a given move is valid.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply-move` 函数通过移除指定数量的球来更新指定的堆。`game-over?` 函数测试是否还有球可以继续操作。`valid-move?`
    函数测试给定的操作是否有效。'
- en: 'Tying it all together is the function that implements the following game loop:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容结合起来的是实现以下游戏循环的函数：
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The player enters their move by specifying the pile number followed by the
    number of balls to remove. For instance, to remove 5 balls from pile 1, one would
    enter the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过指定堆的编号和要移除的球数来输入他们的操作。例如，要从堆 1 中移除 5 个球，可以输入以下内容：
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To make things interesting, we define an `init` function that randomly initializes
    each pile with from 10 to 15 balls.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更有趣，我们定义了一个 `init` 函数，它会随机初始化每个堆，球的数量在 10 到 15 个之间。
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[Figure 4-32](ch04.xhtml#ch4fig32) illustrates a game in progress.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-32](ch04.xhtml#ch4fig32)展示了正在进行中的游戏。'
- en: '![Image](../images/04fig33.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig33.jpg)'
- en: '*Figure 4-32: Nim: game in progress*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-32: Nim: 游戏进行中*'
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we played with plotting, grappled with graphics, and in the
    process discovered Racket’s extensive capability for visual representation. In
    the next chapter, we’ll build upon this capability to escape the confines of the
    command line to produce animations and take the first steps toward making interactive
    applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们玩转了绘图，探索了图形，并在过程中发现了 Racket 在视觉表现方面的强大功能。在下一章，我们将基于这个功能，突破命令行的局限，制作动画，并迈出创建互动应用程序的第一步。
