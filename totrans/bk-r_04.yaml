- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**MATRICES AND ARRAYS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵与数组**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: By now, you have a solid handle on using vectors in R. A *matrix* is simply
    several vectors stored together. Whereas the size of a vector is described by
    its length, the size of a matrix is specified by a number of rows and a number
    of columns. You can also create higher-dimensional structures that are referred
    to as *arrays*. In this chapter, we’ll begin by looking at how to work with matrices
    before increasing the dimension to form arrays.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经能够熟练使用 R 中的向量了。一个*矩阵*实际上是几个向量的集合。而向量的大小由其长度描述，矩阵的大小则通过行数和列数来指定。你还可以创建更高维度的结构，称为*数组*。在本章中，我们将首先了解如何处理矩阵，然后再增加维度形成数组。
- en: '**3.1 Defining a Matrix**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.1 定义矩阵**'
- en: The matrix is an important mathematical construct, and it’s essential to many
    statistical methods. You typically describe a matrix *A* as an *m* × *n* matrix;
    that is, *A* will have exactly *m* rows and *n* columns. This means *A* will have
    a total of *mn* entries, with each entry *a[i,j]* having a unique position given
    by its specific row (*i* = 1,2, ..., *m*) and column (*j* = 1, 2, ..., *n*).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个重要的数学构造，并且是许多统计方法的基础。你通常将矩阵 *A* 描述为一个 *m* × *n* 矩阵；即 *A* 将有 *m* 行和 *n*
    列。这意味着 *A* 将有总共 *mn* 个条目，每个条目 *a[i,j]* 都有一个独特的位置，由其特定的行（*i* = 1,2, ..., *m*）和列（*j*
    = 1, 2, ..., *n*）给出。
- en: 'You can therefore express a matrix as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以按以下方式表示矩阵：
- en: '![image](../images/f0040-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0040-01.jpg)'
- en: 'To create a matrix in R, use the aptly named `matrix` command, providing the
    entries of the matrix to the `data` argument as a vector:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 R 中创建一个矩阵，可以使用恰如其分的`matrix`命令，将矩阵的条目作为向量传递给`data`参数：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You must make sure that the length of this vector matches exactly with the number
    of desired rows (`nrow`) and columns (`ncol`). You can elect not to supply `nrow`
    and `ncol` when calling `matrix`, in which case R’s default behavior is to return
    a single-column matrix of the entries in `data`. For example, `matrix(data=c(-3,2,893,0.17))`
    would be identical to `matrix(data=c(-3,2,893,0.17),nrow=4,ncol=1)`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保这个向量的长度与所需的行数（`nrow`）和列数（`ncol`）完全匹配。你也可以选择在调用`matrix`时不提供`nrow`和`ncol`，在这种情况下，R
    的默认行为是返回一个包含`data`条目的单列矩阵。例如，`matrix(data=c(-3,2,893,0.17))`与`matrix(data=c(-3,2,893,0.17),nrow=4,ncol=1)`是相同的。
- en: '***3.1.1 Filling Direction***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.1 填充方向***'
- en: 'It’s important to be aware of how R fills up the matrix using the entries from
    `data`. Looking at the previous example, you can see that the 2 × 2 matrix `A`
    has been filled in a *column-by-column* fashion when reading the `data` entries
    from left to right. You can control how R fills in data using the argument `byrow`,
    as shown in the following examples:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解 R 如何使用来自 `data` 的条目填充矩阵。通过查看前面的示例，你可以看到 2 × 2 矩阵 `A` 是按 *列* 填充的，即从左到右读取
    `data` 条目。你可以使用 `byrow` 参数控制 R 填充数据的方式，如以下示例所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, I’ve instructed R to provide a 2 × 3 matrix containing the digits 1 through
    6\. By using the optional argument `byrow` and setting it to `FALSE`, you explicitly
    tell R to fill this 2 × 3 structure in a column-wise fashion, by filling each
    column before moving to the next, reading the `data` argument vector from left
    to right. This is R’s default handling of the `matrix` function, so if the `byrow`
    argument isn’t supplied, the software will assume `byrow=FALSE`. [Figure 3-1](ch03.xhtml#ch3fig1)
    illustrates this behavior.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我指示 R 提供一个包含数字 1 到 6 的 2 × 3 矩阵。通过使用可选参数`byrow`并将其设置为`FALSE`，你明确告诉 R 按列填充这个
    2 × 3 结构，即在移动到下一列之前填充每一列，从左到右读取`data`参数向量。这是 R 对`matrix`函数的默认处理方式，因此如果没有提供`byrow`参数，软件将默认`byrow=FALSE`。[图
    3-1](ch03.xhtml#ch3fig1)展示了这一行为。
- en: '![image](../images/f03-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-01.jpg)'
- en: '*Figure 3-1: Filling a 2* × *3 matrix in a column-wise fashion with* `byrow=FALSE`
    *(R default)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：按列填充 2 × 3 矩阵，`byrow=FALSE`（R 默认）*'
- en: Now, let’s repeat the same line of code but set `byrow=TRUE`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重复相同的代码行，但将`byrow=TRUE`。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The resulting 2 × 3 structure has now been filled in a row-wise fashion, as
    shown in [Figure 3-2](ch03.xhtml#ch3fig2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 结果得到的 2 × 3 结构现在已经按行填充，如[图 3-2](ch03.xhtml#ch3fig2)所示。
- en: '![image](../images/f03-02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-02.jpg)'
- en: '*Figure 3-2: Filling a 2* × *3 matrix in a row-wise fashion with* `byrow=TRUE`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：按行填充 2 × 3 矩阵，`byrow=TRUE`*'
- en: '***3.1.2 Row and Column Bindings***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.2 行和列绑定***'
- en: 'If you have multiple vectors of equal length, you can quickly build a matrix
    by binding together these vectors using the built-in R functions, `rbind` and
    `cbind`. You can either treat each vector as a row (by using the command `rbind`)
    or treat each vector as a column (using the command `cbind`). Say you have the
    two vectors `1:3` and `4:6`. You can reconstruct the 2 × 3 matrix in [Figure 3-2](ch03.xhtml#ch3fig2)
    using `rbind` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个相同长度的向量，可以通过使用内置的R函数`rbind`和`cbind`将这些向量快速地构建为一个矩阵。你可以将每个向量视为一行（使用命令`rbind`），或者将每个向量视为一列（使用命令`cbind`）。假设你有两个向量`1:3`和`4:6`。你可以通过以下方式使用`rbind`重建[图3-2](ch03.xhtml#ch3fig2)中的2
    × 3矩阵：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `rbind` has bound together the vectors as two rows of a matrix, with
    the top-to-bottom order of the rows matching the order of the vectors supplied
    to `rbind`. The same matrix could be constructed as follows, using `cbind`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`rbind`将向量作为矩阵的两行连接在一起，行的自上而下顺序与提供给`rbind`的向量顺序一致。可以使用`cbind`按以下方式构造相同的矩阵：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, you have three vectors each of length 2\. You use `cbind` to glue together
    these three vectors in the order they were supplied, and each vector becomes a
    column of the resulting matrix.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有三个长度为2的向量。你使用`cbind`按提供的顺序将这三个向量粘合在一起，每个向量成为结果矩阵的一列。
- en: '***3.1.3 Matrix Dimensions***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.3 矩阵维度***'
- en: Another useful function, `dim`, provides the dimensions of a matrix stored in
    your workspace.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的函数`dim`可以提供存储在工作空间中的矩阵的维度。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having defined a matrix `mymat` using `rbind`, you can confirm its dimensions
    with `dim`, which returns a vector of length 2; `dim` always supplies the number
    of rows first, followed by the number of columns. You can also use two related
    functions: `nrow` (which provides the number of rows only) and `ncol` (which provides
    the number of columns only). In the last command shown, you use `dim` and your
    knowledge of vector subsetting to extract the same result that `ncol` would give
    you.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了矩阵`mymat`之后，你可以使用`dim`确认其维度，`dim`会返回一个长度为2的向量；`dim`总是首先提供行数，然后是列数。你还可以使用两个相关的函数：`nrow`（只提供行数）和`ncol`（只提供列数）。在最后的命令中，你使用`dim`和向量子集的知识来提取与`ncol`相同的结果。
- en: '**3.2 Subsetting**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.2 子集操作**'
- en: Extracting and subsetting elements from matrices in R is much like extracting
    elements from vectors. The only complication is that you now have an additional
    dimension. Element extraction still uses the square-bracket operator, but now
    it must be performed with both a row *and* a column position, given strictly in
    the order of `[row`,column]. Let’s start by creating a 3 × 3 matrix, which I’ll
    use for the examples in this section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从矩阵中提取和子集元素的过程与从向量中提取元素类似。唯一的复杂之处在于，现在你有了一个额外的维度。元素提取仍然使用方括号操作符，但现在必须同时提供行和列的位置，严格按照`[row,
    column]`的顺序。让我们从创建一个3 × 3的矩阵开始，我将使用它来展示本节中的示例。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To tell R to “look at the third row of `A` and give me the element from the
    second column,” you execute the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要让R“查看`A`的第三行并给我第二列的元素”，你可以执行以下操作：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As expected, you’re given the element at position `[3,2]`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，你得到了位于位置`[3,2]`的元素。
- en: '***3.2.1 Row, Column, and Diagonal Extractions***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.1 行、列和对角线提取***'
- en: 'To extract an entire row or column from a matrix, you simply specify the desired
    row or column number and leave the other value blank. It’s important to note that
    *you must still include* the comma that separates the row and column numbers—this
    is how R distinguishes between a request for a row and a request for a column.
    The following returns the second column of `A`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要从矩阵中提取整个行或列，你只需要指定所需的行或列编号，并将另一个值留空。需要注意的是，*你仍然必须包括*用来分隔行和列编号的逗号——这是R区分请求行和请求列的方式。以下代码返回矩阵`A`的第二列：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following examines the first row:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查第一行：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that whenever an extraction (or deletion, covered in a moment) results
    in a single value, single row, or single column, R will always return stand-alone
    vectors comprised of the requested values. You can also perform more complicated
    extractions, for example requesting whole rows or columns, or multiples rows or
    columns, where the result must be returned as a new matrix of the appropriate
    dimensions. Consider the following subsets:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当一个提取（或删除，稍后讨论）结果为单一值、单行或单列时，R总是会返回一个独立的向量，其中包含所请求的值。你还可以执行更复杂的提取，例如请求整行或整列，或者多行或多列，结果将以新的矩阵形式返回，并具有适当的维度。考虑以下子集：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first command returns the second and third rows of `A`, and the second command
    returns the third and first columns of `A`. The last command accesses the third
    and first rows of `A`, in that order, and from those rows it returns the second
    and third column elements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令返回`A`的第二行和第三行，第二条命令返回`A`的第三列和第一列。最后一条命令访问`A`的第三行和第一行，并按顺序返回这两行的第二列和第三列元素。
- en: You can also identify the values along the diagonal of a square matrix (that
    is, a matrix with an equal number of rows and columns) using the `diag` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`diag`命令来识别方阵（即行列数相等的矩阵）沿对角线的值。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This returns a vector with the elements along the diagonal of `A`, starting
    at `A[1,1]`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个向量，包含`A`沿对角线的元素，从`A[1,1]`开始。
- en: '***3.2.2 Omitting and Overwriting***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.2 省略与覆盖***'
- en: 'To delete or omit elements from a matrix, you again use square brackets, but
    this time with negative indexes. The following provides `A` without its second
    column:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除或省略矩阵中的元素，你再次使用方括号，但这次使用负索引。以下命令返回没有第二列的`A`：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following removes the first row from `A` and retrieves the third and second
    column values, in that order, from the remaining two rows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从`A`中删除第一行，并按顺序获取剩余两行的第三列和第二列的值：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following produces `A` without its first row and second column:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令返回没有第一行和第二列的`A`：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, this deletes the first row and then deletes the second and third columns
    from the result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这条命令删除第一行，然后删除结果中的第二列和第三列：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this final operation leaves you with only the last two elements of
    the first column of `A`, so this result is returned as a stand-alone vector rather
    than a matrix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个最终操作只留下了`A`第一列的最后两个元素，因此结果作为独立向量而不是矩阵返回。
- en: To overwrite particular elements, or entire rows or columns, you identify the
    elements to be replaced and then assign the new values, as you did with vectors
    in [Section 2.3.3](ch02.xhtml#ch02lev2sec22). The new elements can be a single
    value, a vector of the same length as the number of elements to be replaced, or
    a vector whose length evenly divides the number of elements to be replaced. To
    illustrate this, let’s first create a copy of `A` and call it `B`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖特定元素或整个行或列，你需要识别要替换的元素，然后分配新的值，正如你在[第2.3.3节](ch02.xhtml#ch02lev2sec22)中对向量所做的那样。新的元素可以是一个单一值，一个长度与要替换元素数量相同的向量，或一个长度能够整除要替换元素数量的向量。为了说明这一点，让我们首先创建`A`的副本，并将其命名为`B`。
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following overwrites the second row of `B` with the sequence `1`, `2`,
    and `3`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用序列`1`、`2`和`3`覆盖`B`的第二行：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following overwrites the second column elements of the first and third
    rows with `900`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用`900`覆盖第一行和第三行的第二列元素：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, you replace the third column of `B` with the values in the third *row*
    of `B`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你用`B`的第三*行*的值替换`B`的第三列。
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To try R’s vector recycling, let’s now overwrite the first and third column
    elements of rows 1 and 3 (a total of four elements) with the two values `-7` and
    `7`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试R的向量回收，我们现在将第一行和第三行的第一列和第三列元素（共四个元素）用两个值`-7`和`7`覆盖。
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The vector of length 2 has replaced the four elements *in a column-wise fashion*.
    The replacement vector `c(-7,7)` overwrites the elements at positions (1,1) and
    (3,1), in that order, and is then repeated to overwrite (1,3) and (3,3), in that
    order.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为2的向量以*按列的方式*替换了这四个元素。替换向量`c(-7,7)`按顺序覆盖了位置(1,1)和(3,1)的元素，然后重复该过程，按顺序覆盖(1,3)和(3,3)的元素。
- en: 'To highlight the role of index order on matrix element replacement, consider
    the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出索引顺序对矩阵元素替换的影响，请考虑以下示例：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The four values in the replacement vector have overwritten the four specified
    elements, again in a column-wise fashion. In this case, because I specified the
    first and second columns in reverse order, the overwriting proceeded accordingly,
    filling the second column before moving to the first. Position (1,2) is matched
    with `65`, followed by (3,2) with `-65`; then (1,1) becomes `88`, and (3,1) becomes
    `-88`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 替换向量中的四个值已按列的顺序覆盖了四个指定的元素。在这种情况下，由于我反向指定了第一列和第二列，因此覆盖操作依次进行，先填充第二列，再转到第一列。位置（1,2）对应`65`，然后（3,2）对应`-65`；接着（1,1）变成`88`，（3,1）变成`-88`。
- en: If you just want to replace the diagonal of a square matrix, you can avoid explicit
    indexes and directly overwrite the values using the `diag` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想替换一个方阵的对角线元素，你可以避免显式索引，直接使用`diag`命令来覆盖值。
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Exercise 3.1**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3.1**'
- en: Construct and store a 4 × 2 matrix that’s filled row-wise with the values 4.3,
    3.1, 8.2, 8.2, 3.2, 0.9, 1.6, and 6.5, in that order.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造并存储一个4 × 2的矩阵，按行顺序填充值4.3、3.1、8.2、8.2、3.2、0.9、1.6和6.5。
- en: Confirm the dimensions of the matrix from (a) are 3 × 2 if you remove any one
    row.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从(a)中删除任意一行，确认矩阵的维度是3 × 2。
- en: Overwrite the second column of the matrix from (a) with that same column sorted
    from smallest to largest.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用按从小到大的顺序排序的相同列，覆盖矩阵（a）中的第二列。
- en: What does R return if you delete the fourth row and the first column from (c)?
    Use `matrix` to ensure the result is a single-column matrix, rather than a vector.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从(c)中删除第四行和第一列，R会返回什么？使用`matrix`确保结果是一个单列矩阵，而不是一个向量。
- en: Store the bottom four elements of (c) as a new 2 × 2 matrix.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将(c)中的底部四个元素存储为新的2 × 2矩阵。
- en: Overwrite, in this order, the elements of (c) at positions (4,2), (1,2), (4,1),
    and (1,1) with –![image](../images/1by2.jpg) of the two values on the diagonal
    of (e).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按此顺序，覆盖(c)中位置（4,2）、（1,2）、（4,1）和（1,1）的元素，使用矩阵（e）对角线上的两个值的–![image](../images/1by2.jpg)。
- en: '**3.3 Matrix Operations and Algebra**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.3 矩阵运算与代数**'
- en: You can think of matrices in R from two perspectives. First, you can use these
    structures purely as a computational tool in programming to store and operate
    on results, as you’ve seen so far. Alternatively, you can use matrices for their
    mathematical properties in relevant calculations, such as the use of matrix multiplication
    for expressing regression model equations. This distinction is important because
    the mathematical behavior of matrices is not always the same as the more generic
    data handling behavior. Here I’ll briefly describe some special matrices, as well
    as some of the most common mathematical operations involving matrices, and the
    corresponding functionality in R. If the mathematical behavior of matrices isn’t
    of interest to you, you can skip this section for now and refer to it later as
    needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两个角度理解R中的矩阵。首先，你可以纯粹将这些结构作为编程中的计算工具，用来存储和操作结果，正如你迄今所见。其次，你可以利用矩阵在相关计算中的数学性质，例如使用矩阵乘法表示回归模型方程。这个区别很重要，因为矩阵的数学行为并不总是与更通用的数据处理行为相同。在这里，我将简要介绍一些特殊的矩阵，以及一些涉及矩阵的最常见数学运算和R中的相应功能。如果矩阵的数学行为对你不感兴趣，你可以暂时跳过这一部分，稍后根据需要再参考。
- en: '***3.3.1 Matrix Transpose***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.1 矩阵转置***'
- en: For any *m* × *n* matrix *A*, its *transpose*, *A*^⊤, is the *n* × *m* matrix
    obtained by writing either its columns as rows or its rows as columns.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何*m* × *n*矩阵*A*，它的*转置*，*A*^⊤，是通过将其列写成行或将其行写成列得到的*n* × *m*矩阵。
- en: 'Here’s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '![image](../images/f0047-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0047-01.jpg)'
- en: In `R`, the transpose of a matrix is found with the function `t`. Let’s create
    a new matrix and then transpose it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`R`中，矩阵的转置可以通过`t`函数找到。让我们创建一个新矩阵，然后对其进行转置。
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you “transpose the transpose” of *A*, you’ll recover the original matrix.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对* A *进行“转置再转置”，你将恢复原始矩阵。
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***3.3.2 Identity Matrix***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.2 单位矩阵***'
- en: The *identity matrix* written as *I*[*m*] is a particular kind of matrix used
    in mathematics. It’s a square *m* × *m* matrix with ones on the diagonal and zeros
    elsewhere.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*单位矩阵*写作*I*[*m*]，是数学中一种特殊类型的矩阵。它是一个*m* × *m*的方阵，对角线上的元素为1，其他位置为0。'
- en: 'Here’s an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '![image](../images/f0048-01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0048-01.jpg)'
- en: 'You can create an identity matrix of any dimension using the standard `matrix`
    function, but there’s a quicker approach using `diag`. Earlier, I used `diag`
    on an existing matrix to extract or overwrite its diagonal elements. You can also
    use it as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的 `matrix` 函数创建任意维度的单位矩阵，但有一种更快捷的方法可以使用 `diag`。之前，我在一个现有的矩阵上使用了 `diag`
    来提取或覆盖它的对角元素。你也可以按以下方式使用它：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here you see `diag` can be used to easily produce an identity matrix. To clarify,
    the behavior of `diag` depends on what you supply to it as its argument `x`. If,
    as earlier, `x` is a matrix, `diag` will retrieve the diagonal elements of the
    matrix. If `x` is a single positive integer, as is the case here, then `diag`
    will produce the identity matrix of the corresponding dimension. You can find
    more uses of `diag` on its help page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到 `diag` 可以用来轻松生成单位矩阵。为进一步说明，`diag` 的行为取决于你传递给它的参数 `x`。如果像之前那样，`x` 是一个矩阵，`diag`
    会提取该矩阵的对角元素。如果 `x` 是一个正整数，就像这里的情况，`diag` 会生成对应维度的单位矩阵。你可以在 `diag` 的帮助页面找到更多的用法。
- en: '***3.3.3 Scalar Multiple of a Matrix***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.3 矩阵的标量倍数***'
- en: A scalar value is just a single, univariate value. Multiplication of any matrix
    *A* by a scalar value *a* results in a matrix in which every individual element
    is multiplied by *a*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标量值只是一个单一的、一维的值。任何矩阵 *A* 与标量值 *a* 相乘，都会得到一个新的矩阵，其中每个元素都被 *a* 乘以。
- en: 'Here’s an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![image](../images/f0049-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0049-01.jpg)'
- en: R will perform this multiplication in an element-wise manner, as you might expect.
    Scalar multiplication of a matrix is carried out using the standard arithmetic
    `*` operator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: R 会以逐元素的方式执行此乘法，正如你所期望的那样。矩阵的标量乘法是通过标准的算术 `*` 运算符来执行的。
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***3.3.4 Matrix Addition and Subtraction***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.4 矩阵加法和减法***'
- en: Addition or subtraction of two matrices of equal size is also performed in an
    element-wise fashion. Corresponding elements are added or subtracted from one
    another, depending on the operation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个相同大小矩阵的加法或减法也是逐元素进行的。对应的元素会根据操作进行加法或减法。
- en: 'Here’s an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![image](../images/f0049-02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0049-02.jpg)'
- en: You can add or subtract any two equally sized matrices with the standard `+`
    and `-` symbols.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的 `+` 和 `-` 符号来加减任何两个相同大小的矩阵。
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***3.3.5 Matrix Multiplication***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.5 矩阵乘法***'
- en: In order to *multiply* two matrices *A* and *B* of size *m* × *n* and *p* ×
    *q*, it must be true that *n* = *p*. The resulting matrix *A* · *B* will have
    the size *m* × *q*. The elements of the product are computed in a row-by-column
    fashion, where the value at position (*AB*)[*i,j*] is computed by element-wise
    multiplication of the entries in row *i* of *A* by the entries in column *j* of
    *B*, summing the result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了*乘*两个矩阵 *A* 和 *B*，它们的大小分别为 *m* × *n* 和 *p* × *q*，必须满足 *n* = *p*。结果矩阵 *A* ·
    *B* 的大小将是 *m* × *q*。乘积的元素是按行乘列的方式计算的，其中位置 (*AB*)[*i,j*] 的值是通过将 *A* 的第 *i* 行的每个元素与
    *B* 的第 *j* 列的每个元素进行逐元素相乘并求和得到的。
- en: 'Here’s an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![image](../images/f0050-01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0050-01.jpg)'
- en: Note that, in general, multiplication of appropriately sized matrices (denoted,
    say, with *C* and *D*) is not commutative; that is, *CD* ≠ *DC*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常情况下，适当大小的矩阵（例如，*C* 和 *D*）的乘法不是交换的；也就是说，*CD* ≠ *DC*。
- en: Unlike addition, subtraction, and scalar multiplication, matrix multiplication
    is not a simple element-wise calculation, and the standard `*` operator cannot
    be used. Instead, you must use R’s matrix product operator, written with percent
    symbols as `%*%`. Before you try this operator, let’s first store the two example
    matrices and check to make sure the number of columns in the first matrix matches
    the number of rows in the second matrix using `dim`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法、减法和标量乘法不同，矩阵乘法不是简单的逐元素计算，标准的 `*` 运算符不能使用。相反，你必须使用 R 的矩阵乘积运算符，它是由百分号符号 `%*%`
    表示的。在你尝试此运算符之前，让我们先存储这两个示例矩阵，并使用 `dim` 检查确保第一个矩阵的列数与第二个矩阵的行数匹配。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This confirms the two matrices are compatible for multiplication, so you can
    proceed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了这两个矩阵可以进行相乘，因此你可以继续操作。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can show that matrix multiplication is noncommutative using the same two
    matrices. Switching the order of multiplication gives you an entirely different
    result.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用相同的两个矩阵来证明矩阵乘法是不可交换的。改变乘法的顺序会得到完全不同的结果。
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***3.3.6 Matrix Inversion***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.6 矩阵求逆***'
- en: 'Some square matrices can be *inverted*. The inverse of a matrix *A* is denoted
    *A*^(–1). An invertible matrix satisfies the following equation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方阵是可以*逆转*的。矩阵 *A* 的逆矩阵用 *A*^(–1) 表示。一个可逆矩阵满足以下方程：
- en: '*AA*^(–1) = *I*[*m*]'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*AA*^(–1) = *I*[*m*]'
- en: 'Here’s an example of a matrix and its inverse:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个矩阵及其逆矩阵的示例：
- en: '![image](../images/f0051-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0051-01.jpg)'
- en: Matrices that are not invertible are referred to as *singular*. Inverting a
    matrix is often necessary when solving equations with matrices and has important
    practical ramifications. There are several different approaches to matrix inversion,
    and these calculations can become extremely computationally expensive as you increase
    the size of a matrix. We won’t go into too much detail here, but if you’re interested,
    see Golub and Van Loan ([1989](ref.xhtml#ref26)) for formal discussions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不可逆的矩阵被称为*奇异矩阵*。当使用矩阵解方程时，求矩阵的逆是常常需要的，并且具有重要的实际意义。矩阵求逆有多种方法，随着矩阵大小的增大，这些计算会变得非常耗费计算资源。我们在这里不会深入讨论，但如果你感兴趣，可以参考
    Golub 和 Van Loan（[1989](ref.xhtml#ref26)）的正式讨论。
- en: For now, I’ll just show you the R function solve as one option for inverting
    a matrix.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将向你展示 R 语言中的 `solve` 函数作为求矩阵逆的一个选项。
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also verify that the product of these two matrices (using matrix multiplication
    rules) results in the 2 × 2 identity matrix.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以验证这两个矩阵的乘积（使用矩阵乘法规则）会得到一个 2 × 2 的单位矩阵。
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Exercise 3.2**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3.2**'
- en: 'Calculate the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算如下内容：
- en: '![image](../images/f0052-01.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0052-01.jpg)'
- en: 'Store these two matrices:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储这两个矩阵：
- en: '![image](../images/f0052-02.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0052-02.jpg)'
- en: Which of the following multiplications are possible? For those that are, compute
    the result.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下哪些乘法是可能的？对于那些可以的，计算结果。
- en: '*A* · *B*'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*A* · *B*'
- en: '*A* ^⊤ · *B*'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*A* ^⊤ · *B*'
- en: '*B* ^⊤ · (*A* · *A* ^⊤)'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*B* ^⊤ · (*A* · *A* ^⊤)'
- en: (*A* · *A* ^⊤) · *B* ^⊤
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*A* · *A* ^⊤) · *B* ^⊤
- en: '[(*B* · *B* ^⊤) + (*A* · *A* ^⊤) − 100*I*[3]]^(−1)'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[(*B* · *B* ^⊤) + (*A* · *A* ^⊤) − 100*I*[3]]^(−1)'
- en: For
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于
- en: '![image](../images/f0052-03.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0052-03.jpg)'
- en: confirm that *A*^(–1) · *A* − *I[4]* provides a 4 × 4 matrix of zeros.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证 *A*^(–1) · *A* − *I[4]* 结果是一个 4 × 4 的零矩阵。
- en: '**3.4 Multidimensional Arrays**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.4 多维数组**'
- en: Just as a matrix (a “rectangle” of elements) is the result of increasing the
    dimension of a vector (a “line” of elements), the dimension of a matrix can be
    increased to get more complex data structures. In R, vectors and matrices can
    be considered special cases of the more general *array*, which is how I’ll refer
    to these types of structures when they have more than two dimensions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像矩阵（一个“矩形”元素集合）是通过增加向量（一个“线”元素集合）的维度得到的结果一样，矩阵的维度也可以增加，从而得到更复杂的数据结构。在 R 中，向量和矩阵可以被认为是更一般的*数组*的特殊情况，当它们具有超过两个维度时，我将用这个术语来指代这些结构。
- en: So, what’s the next step up from a matrix? Well, just as a matrix is considered
    to be a collection of vectors of equal length, a three-dimensional array can be
    considered to be a collection of equally dimensioned matrices, providing you with
    a rectangular prism of elements. You still have a fixed number of rows and a fixed
    number of columns, as well as a new third dimension called a *layer*. [Figure
    3-3](ch03.xhtml#ch3fig3) illustrates a three-row, four-column, two-layer (3 ×
    4 × 2) array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，矩阵的下一步是什么呢？就像矩阵被认为是相同长度的向量集合一样，三维数组可以被认为是等维度矩阵的集合，从而为你提供一个元素的长方体。你仍然有固定数量的行和列，以及一个新的第三维度，称为*层*。[图
    3-3](ch03.xhtml#ch3fig3)展示了一个三行四列两层（3 × 4 × 2）的数组。
- en: '![image](../images/f03-03.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f03-03.jpg)'
- en: '*Figure 3-3: A conceptual diagram of a 3* × *4* × *2 array. The index of each
    element is given at the corresponding position. These indexes are provided in
    the strict order of* `[row,column,layer]`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：一个 3* × *4* × *2 数组的概念图。每个元素的索引在相应位置给出。这些索引是严格按照* `[行，列，层]`的顺序提供的。*'
- en: '***3.4.1 Definition***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.1 定义***'
- en: 'To create these data structures in R, use the `array` function and specify
    the individual elements in the `data` argument as a vector. Then specify size
    in the `dim` argument as another vector with a length corresponding to the number
    of dimensions. Note that `array` fills the entries of each layer with the elements
    in `data` in a strict column-wise fashion, starting with the first layer. Consider
    the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中创建这些数据结构时，使用 `array` 函数，并将 `data` 参数中的元素指定为一个向量。然后，在 `dim` 参数中指定大小，作为一个向量，其长度对应于维度的数量。注意，`array`
    按列的顺序严格地填充每一层的条目，从第一层开始。考虑以下示例：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives you an array of the same size as in [Figure 3-3](ch03.xhtml#ch3fig3)—each
    of the two layers constitutes a 3 × 4 matrix. In this example, note the order
    of the dimensions supplied to `dim`: `c(rows`,columns,layers). Just like a single
    matrix, the product of the dimension sizes of an array will yield the total number
    of elements. As you increase the dimension further, the `dim` vector must be extended
    accordingly. For example, a four-dimensional array is the next step up and can
    be thought of as *blocks* of three-dimensional arrays. Suppose you had a four-dimensional
    array comprised of three copies of `AR`, the three-dimensional array just defined.
    This new array can be stored in R as follows (once again, the array is filled
    column-wise):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一个和[图 3-3](ch03.xhtml#ch3fig3)一样大小的数组——每个层构成一个 3 × 4 的矩阵。在这个例子中，注意提供给`dim`的维度顺序：`c(行,列,层)`。就像单个矩阵一样，数组的维度大小乘积将得出元素的总数。随着维度的增加，`dim`向量必须相应地扩展。例如，四维数组是下一个层次，可以看作是*三维数组的块*。假设你有一个四维数组，由三个`AR`（即刚才定义的三维数组）组成。这个新数组可以如下方式在R中存储（同样，数组按列填充）：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With `BR` you now have three copies of `AR`. Each of these copies is split into
    its two layers so R can print the object to the screen. As before, the rows are
    indexed by the first digit, the columns by the second digit, and the layers by
    the third digit. The new fourth digit indexes the blocks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BR`，你现在拥有三个`AR`的副本。这些副本被拆分为两个层，以便R能够将对象打印到屏幕上。和之前一样，行由第一位数字索引，列由第二位数字索引，层由第三位数字索引。新的第四位数字索引块。
- en: '***3.4.2 Subsets, Extractions, and Replacements***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.2 子集、提取和替换***'
- en: Even though high-dimensional objects can be difficult to conceptualize, R indexes
    them consistently. This makes extracting elements from these structures straightforward
    now that you know how to subset matrices—you just have to keep using commas in
    the square brackets as separators of the dimensions being accessed. This is highlighted
    in the examples that follow.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管高维对象可能难以概念化，但R会始终如一地对它们进行索引。这使得提取这些结构中的元素变得直接简单，因为你已经学会了如何对子集矩阵进行操作——你只需继续在方括号中使用逗号作为维度之间的分隔符。接下来的例子会强调这一点。
- en: Suppose you want the second row of the second layer of the previously created
    array `AR`. You just enter these exact dimensional locations of `AR` in square
    brackets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要获取之前创建的数组`AR`的第二层的第二行。你只需在方括号中输入`AR`的这些精确维度位置。
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The desired elements have been extracted as a vector of length 4\. If you want
    specific elements from this vector, say the third and first, in that order, you
    can call the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的元素已被提取为一个长度为4的向量。如果你想从这个向量中获取特定的元素，比如第三个和第一个（按这个顺序），你可以调用以下代码：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, this literal method of subsetting makes dealing with even highdimensional
    objects in R manageable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这种字面量的子集方法使得处理R中的高维对象变得可控。
- en: 'An extraction that results in multiple vectors will be presented as columns
    in the returned matrix. For example, to extract the first rows of both layers
    of `AR`, you enter this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 产生多个向量的提取会在返回的矩阵中以列的形式呈现。例如，要提取`AR`的两个层的第一行，你可以输入如下代码：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The returned object has the first rows of each of the two matrix layers. However,
    it has returned each of these vectors as a *column* of the single returned matrix.
    As this example shows, when multiple vectors are extracted from an array, they
    will be returned as columns by default. This means extracted rows will not necessarily
    be returned as rows.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象包含了每个矩阵层的第一行。然而，它返回的这些向量被作为单个返回矩阵的*列*。正如这个例子所示，当从数组中提取多个向量时，它们会默认作为列返回。这意味着提取的行不一定会作为行返回。
- en: Turning to the object `BR`, the following gives you the single element of the
    second row and first column of the matrix in the first layer of the three-dimensional
    array located in the third block.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 转到对象`BR`，下面的代码会给你三维数组中位于第三块的矩阵第一层的第二行第一列的单一元素。
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Again, you just need to look at the position of the index in the square brackets
    to know which values you are asking R to return from the array. The following
    examples highlight this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你只需查看方括号中索引的位置，就能知道你要求R从数组中返回哪些值。以下示例强调了这一点：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This returns all the values in the first row of the first block. Since I left
    the column and layer indexes blank in this subset `[1,,,1]`, the command has returned
    values for all four columns and both layers in that block of `BR`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回第一个块中第一行的所有值。由于我在这个子集`[1,,,1]`中没有指定列和层的索引，这个命令返回了`BR`块中所有四列和两个层的值。
- en: 'Next, the following line returns all the values in the second layer of the
    array `BR`, composed of three matrices:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下代码将返回`BR`数组第二层中的所有值，该层由三个矩阵组成：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This last example highlights a feature noted earlier, where multiple vectors
    from `AR` were returned as a matrix. Broadly speaking, if you have an extraction
    that results in multiple *d*-dimensional arrays, the result will be an array of
    the next-highest dimension, *d* + 1\. In the last example, you extracted multiple
    (two-dimensional) matrices, and they were returned as a three-dimensional array.
    This is demonstrated again in the next example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的这个例子突出了前面提到的一个特性，其中从`AR`提取的多个向量作为矩阵返回。一般来说，如果你进行提取操作并得到多个*d*维数组，结果将会是下一个维度（*d*
    + 1）的数组。在最后的例子中，你提取了多个（二维）矩阵，它们作为三维数组返回。这个特性在接下来的例子中再次得到展示：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This extracts the elements at rows 3 and 2 (in that order), column 4, for all
    layers and for all array blocks. Consider the following final example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取所有层和所有数组块中，第三行和第二行（按顺序），第四列的元素。考虑下面的最后一个例子：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here you’ve asked R to return the entire second rows of the first layers of
    all the arrays stored in `BR`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你要求R返回存储在`BR`中的所有数组第一层的完整第二行。
- en: Deleting and overwriting elements in high-dimensional arrays follows the same
    rules as for stand-alone vectors and matrices. You specify the dimension positions
    the same way, using negative indexes (for deletion) or using the assignment operator
    for overwriting.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 删除和覆盖高维数组中的元素遵循与独立向量和矩阵相同的规则。你通过负索引（用于删除）或使用赋值运算符（用于覆盖）来指定维度位置。
- en: You can use the `array` function to create one-dimensional arrays (vectors)
    and two-dimensional arrays (matrices) should you want to (by setting the `dim`
    argument to be of length 1 or 2, respectively). Note, though, that vectors in
    particular may be treated differently by some functions if created with `array`
    instead of `c` (see the help file `?array` for technical details). For this reason,
    and to make large sections of code more readable, it’s more conventional in R
    programming to use the specific vector- and matrix-creation functions `c` and
    `matrix`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`array`函数来创建一维数组（向量）和二维数组（矩阵），如果需要的话（通过设置`dim`参数的长度为1或2）。不过需要注意的是，尤其是向量，在使用`array`而不是`c`创建时，某些函数可能会以不同的方式对待它们（有关技术细节，请参见帮助文件`?array`）。因此，为了使大段代码更具可读性，在R编程中通常更倾向于使用特定的向量和矩阵创建函数`c`和`matrix`。
- en: '**Exercise 3.3**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习3.3**'
- en: Create and store a three-dimensional array with six layers of a 4 × 2 matrix,
    filled with a decreasing sequence of values between 4.8 and 0.1 of the appropriate
    length.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并存储一个三维数组，包含六层4 × 2矩阵，矩阵中的值是从4.8到0.1的递减序列，长度适当。
- en: Extract and store as a new object the fourth- and first-row elements, in that
    order, of the second column only of all layers of (a).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取并存储第二列中所有层的第四行和第一行元素，顺序为：第四行，第一行，作为一个新对象。
- en: Use a fourfold repetition of the second row of the matrix formed in (b) to fill
    a new array of dimensions 2 × 2 × 2 × 3.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩阵（b）中第二行的四次重复，填充一个新的2 × 2 × 2 × 3维数组。
- en: Create a new array comprised of the results of deleting the sixth layer of (a).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新数组，包含删除（a）第六层后的结果。
- en: Overwrite the second and fourth row elements of the second column of layers
    1, 3, and 5 of (d) with −99.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用−99覆盖（d）中第1层、第3层和第5层的第二列的第二行和第四行元素。
- en: '**Important Code in This Chapter**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章中的重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `matrix` | Create a matrix | [Section 3.1](ch03.xhtml#ch03lev1sec12), [p.
    40](ch03.xhtml#page_40) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `matrix` | 创建一个矩阵 | [第3.1节](ch03.xhtml#ch03lev1sec12)，[第40页](ch03.xhtml#page_40)
    |'
- en: '| `rbind` | Create a matrix (bind rows) | [Section 3.1.2](ch03.xhtml#ch03lev2sec25),
    [p. 41](ch03.xhtml#page_41) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `rbind` | 创建一个矩阵（按行绑定） | [第3.1.2节](ch03.xhtml#ch03lev2sec25)，[第41页](ch03.xhtml#page_41)
    |'
- en: '| `cbind` | Create a matrix (bind columns) | [Section 3.1.2](ch03.xhtml#ch03lev2sec25),
    [p. 42](ch03.xhtml#page_42) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `cbind` | 创建一个矩阵（按列绑定） | [第3.1.2节](ch03.xhtml#ch03lev2sec25)，[第42页](ch03.xhtml#page_42)
    |'
- en: '| `dim` | Get matrix dimensions | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `nrow` | Get number of rows | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `ncol` | Get number of columns | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `[ , ]` | Matrix/array subsetting | [Section 3.2](ch03.xhtml#ch03lev1sec13),
    [p. 43](ch03.xhtml#page_43) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `diag` | Diagonal elements/identity matrix | [Section 3.2.1](ch03.xhtml#ch03lev2sec27),
    [p. 44](ch03.xhtml#page_44) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `t` | Matrix transpose | [Section 3.3.1](ch03.xhtml#ch03lev2sec29), [p. 47](ch03.xhtml#page_47)
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `*` | Scalar matrix multiple | [Section 3.3.3](ch03.xhtml#ch03lev2sec31),
    [p. 49](ch03.xhtml#page_49) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `+`, `-` | Matrix addition/subtraction | [Section 3.3.4](ch03.xhtml#ch03lev2sec32),
    [p. 49](ch03.xhtml#page_49) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `%*%` | Matrix multiplication | [Section 3.3.5](ch03.xhtml#ch03lev2sec33),
    [p. 50](ch03.xhtml#page_50) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Matrix inversion | [Section 3.3.6](ch03.xhtml#ch03lev2sec34), [p.
    51](ch03.xhtml#page_51) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `array` | Create an array | [Section 3.4.1](ch03.xhtml#ch03lev2sec35), [p.
    53](ch03.xhtml#page_53) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
