- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MATRICES AND ARRAYS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By now, you have a solid handle on using vectors in R. A *matrix* is simply
    several vectors stored together. Whereas the size of a vector is described by
    its length, the size of a matrix is specified by a number of rows and a number
    of columns. You can also create higher-dimensional structures that are referred
    to as *arrays*. In this chapter, we’ll begin by looking at how to work with matrices
    before increasing the dimension to form arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1 Defining a Matrix**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The matrix is an important mathematical construct, and it’s essential to many
    statistical methods. You typically describe a matrix *A* as an *m* × *n* matrix;
    that is, *A* will have exactly *m* rows and *n* columns. This means *A* will have
    a total of *mn* entries, with each entry *a[i,j]* having a unique position given
    by its specific row (*i* = 1,2, ..., *m*) and column (*j* = 1, 2, ..., *n*).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can therefore express a matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0040-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a matrix in R, use the aptly named `matrix` command, providing the
    entries of the matrix to the `data` argument as a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You must make sure that the length of this vector matches exactly with the number
    of desired rows (`nrow`) and columns (`ncol`). You can elect not to supply `nrow`
    and `ncol` when calling `matrix`, in which case R’s default behavior is to return
    a single-column matrix of the entries in `data`. For example, `matrix(data=c(-3,2,893,0.17))`
    would be identical to `matrix(data=c(-3,2,893,0.17),nrow=4,ncol=1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.1.1 Filling Direction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s important to be aware of how R fills up the matrix using the entries from
    `data`. Looking at the previous example, you can see that the 2 × 2 matrix `A`
    has been filled in a *column-by-column* fashion when reading the `data` entries
    from left to right. You can control how R fills in data using the argument `byrow`,
    as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve instructed R to provide a 2 × 3 matrix containing the digits 1 through
    6\. By using the optional argument `byrow` and setting it to `FALSE`, you explicitly
    tell R to fill this 2 × 3 structure in a column-wise fashion, by filling each
    column before moving to the next, reading the `data` argument vector from left
    to right. This is R’s default handling of the `matrix` function, so if the `byrow`
    argument isn’t supplied, the software will assume `byrow=FALSE`. [Figure 3-1](ch03.xhtml#ch3fig1)
    illustrates this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Filling a 2* × *3 matrix in a column-wise fashion with* `byrow=FALSE`
    *(R default)*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s repeat the same line of code but set `byrow=TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The resulting 2 × 3 structure has now been filled in a row-wise fashion, as
    shown in [Figure 3-2](ch03.xhtml#ch3fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Filling a 2* × *3 matrix in a row-wise fashion with* `byrow=TRUE`'
  prefs: []
  type: TYPE_NORMAL
- en: '***3.1.2 Row and Column Bindings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you have multiple vectors of equal length, you can quickly build a matrix
    by binding together these vectors using the built-in R functions, `rbind` and
    `cbind`. You can either treat each vector as a row (by using the command `rbind`)
    or treat each vector as a column (using the command `cbind`). Say you have the
    two vectors `1:3` and `4:6`. You can reconstruct the 2 × 3 matrix in [Figure 3-2](ch03.xhtml#ch3fig2)
    using `rbind` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `rbind` has bound together the vectors as two rows of a matrix, with
    the top-to-bottom order of the rows matching the order of the vectors supplied
    to `rbind`. The same matrix could be constructed as follows, using `cbind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have three vectors each of length 2\. You use `cbind` to glue together
    these three vectors in the order they were supplied, and each vector becomes a
    column of the resulting matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.1.3 Matrix Dimensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful function, `dim`, provides the dimensions of a matrix stored in
    your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined a matrix `mymat` using `rbind`, you can confirm its dimensions
    with `dim`, which returns a vector of length 2; `dim` always supplies the number
    of rows first, followed by the number of columns. You can also use two related
    functions: `nrow` (which provides the number of rows only) and `ncol` (which provides
    the number of columns only). In the last command shown, you use `dim` and your
    knowledge of vector subsetting to extract the same result that `ncol` would give
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2 Subsetting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extracting and subsetting elements from matrices in R is much like extracting
    elements from vectors. The only complication is that you now have an additional
    dimension. Element extraction still uses the square-bracket operator, but now
    it must be performed with both a row *and* a column position, given strictly in
    the order of `[row`,column]. Let’s start by creating a 3 × 3 matrix, which I’ll
    use for the examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To tell R to “look at the third row of `A` and give me the element from the
    second column,” you execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expected, you’re given the element at position `[3,2]`.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.2.1 Row, Column, and Diagonal Extractions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To extract an entire row or column from a matrix, you simply specify the desired
    row or column number and leave the other value blank. It’s important to note that
    *you must still include* the comma that separates the row and column numbers—this
    is how R distinguishes between a request for a row and a request for a column.
    The following returns the second column of `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following examines the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that whenever an extraction (or deletion, covered in a moment) results
    in a single value, single row, or single column, R will always return stand-alone
    vectors comprised of the requested values. You can also perform more complicated
    extractions, for example requesting whole rows or columns, or multiples rows or
    columns, where the result must be returned as a new matrix of the appropriate
    dimensions. Consider the following subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first command returns the second and third rows of `A`, and the second command
    returns the third and first columns of `A`. The last command accesses the third
    and first rows of `A`, in that order, and from those rows it returns the second
    and third column elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can also identify the values along the diagonal of a square matrix (that
    is, a matrix with an equal number of rows and columns) using the `diag` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This returns a vector with the elements along the diagonal of `A`, starting
    at `A[1,1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.2.2 Omitting and Overwriting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To delete or omit elements from a matrix, you again use square brackets, but
    this time with negative indexes. The following provides `A` without its second
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following removes the first row from `A` and retrieves the third and second
    column values, in that order, from the remaining two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following produces `A` without its first row and second column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, this deletes the first row and then deletes the second and third columns
    from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that this final operation leaves you with only the last two elements of
    the first column of `A`, so this result is returned as a stand-alone vector rather
    than a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: To overwrite particular elements, or entire rows or columns, you identify the
    elements to be replaced and then assign the new values, as you did with vectors
    in [Section 2.3.3](ch02.xhtml#ch02lev2sec22). The new elements can be a single
    value, a vector of the same length as the number of elements to be replaced, or
    a vector whose length evenly divides the number of elements to be replaced. To
    illustrate this, let’s first create a copy of `A` and call it `B`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following overwrites the second row of `B` with the sequence `1`, `2`,
    and `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following overwrites the second column elements of the first and third
    rows with `900`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, you replace the third column of `B` with the values in the third *row*
    of `B`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To try R’s vector recycling, let’s now overwrite the first and third column
    elements of rows 1 and 3 (a total of four elements) with the two values `-7` and
    `7`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The vector of length 2 has replaced the four elements *in a column-wise fashion*.
    The replacement vector `c(-7,7)` overwrites the elements at positions (1,1) and
    (3,1), in that order, and is then repeated to overwrite (1,3) and (3,3), in that
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To highlight the role of index order on matrix element replacement, consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The four values in the replacement vector have overwritten the four specified
    elements, again in a column-wise fashion. In this case, because I specified the
    first and second columns in reverse order, the overwriting proceeded accordingly,
    filling the second column before moving to the first. Position (1,2) is matched
    with `65`, followed by (3,2) with `-65`; then (1,1) becomes `88`, and (3,1) becomes
    `-88`.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to replace the diagonal of a square matrix, you can avoid explicit
    indexes and directly overwrite the values using the `diag` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 3.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Construct and store a 4 × 2 matrix that’s filled row-wise with the values 4.3,
    3.1, 8.2, 8.2, 3.2, 0.9, 1.6, and 6.5, in that order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the dimensions of the matrix from (a) are 3 × 2 if you remove any one
    row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the second column of the matrix from (a) with that same column sorted
    from smallest to largest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does R return if you delete the fourth row and the first column from (c)?
    Use `matrix` to ensure the result is a single-column matrix, rather than a vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the bottom four elements of (c) as a new 2 × 2 matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite, in this order, the elements of (c) at positions (4,2), (1,2), (4,1),
    and (1,1) with –![image](../images/1by2.jpg) of the two values on the diagonal
    of (e).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**3.3 Matrix Operations and Algebra**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of matrices in R from two perspectives. First, you can use these
    structures purely as a computational tool in programming to store and operate
    on results, as you’ve seen so far. Alternatively, you can use matrices for their
    mathematical properties in relevant calculations, such as the use of matrix multiplication
    for expressing regression model equations. This distinction is important because
    the mathematical behavior of matrices is not always the same as the more generic
    data handling behavior. Here I’ll briefly describe some special matrices, as well
    as some of the most common mathematical operations involving matrices, and the
    corresponding functionality in R. If the mathematical behavior of matrices isn’t
    of interest to you, you can skip this section for now and refer to it later as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.1 Matrix Transpose***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For any *m* × *n* matrix *A*, its *transpose*, *A*^⊤, is the *n* × *m* matrix
    obtained by writing either its columns as rows or its rows as columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0047-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In `R`, the transpose of a matrix is found with the function `t`. Let’s create
    a new matrix and then transpose it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you “transpose the transpose” of *A*, you’ll recover the original matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '***3.3.2 Identity Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *identity matrix* written as *I*[*m*] is a particular kind of matrix used
    in mathematics. It’s a square *m* × *m* matrix with ones on the diagonal and zeros
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0048-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create an identity matrix of any dimension using the standard `matrix`
    function, but there’s a quicker approach using `diag`. Earlier, I used `diag`
    on an existing matrix to extract or overwrite its diagonal elements. You can also
    use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here you see `diag` can be used to easily produce an identity matrix. To clarify,
    the behavior of `diag` depends on what you supply to it as its argument `x`. If,
    as earlier, `x` is a matrix, `diag` will retrieve the diagonal elements of the
    matrix. If `x` is a single positive integer, as is the case here, then `diag`
    will produce the identity matrix of the corresponding dimension. You can find
    more uses of `diag` on its help page.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.3.3 Scalar Multiple of a Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A scalar value is just a single, univariate value. Multiplication of any matrix
    *A* by a scalar value *a* results in a matrix in which every individual element
    is multiplied by *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0049-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: R will perform this multiplication in an element-wise manner, as you might expect.
    Scalar multiplication of a matrix is carried out using the standard arithmetic
    `*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '***3.3.4 Matrix Addition and Subtraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Addition or subtraction of two matrices of equal size is also performed in an
    element-wise fashion. Corresponding elements are added or subtracted from one
    another, depending on the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0049-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can add or subtract any two equally sized matrices with the standard `+`
    and `-` symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '***3.3.5 Matrix Multiplication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to *multiply* two matrices *A* and *B* of size *m* × *n* and *p* ×
    *q*, it must be true that *n* = *p*. The resulting matrix *A* · *B* will have
    the size *m* × *q*. The elements of the product are computed in a row-by-column
    fashion, where the value at position (*AB*)[*i,j*] is computed by element-wise
    multiplication of the entries in row *i* of *A* by the entries in column *j* of
    *B*, summing the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that, in general, multiplication of appropriately sized matrices (denoted,
    say, with *C* and *D*) is not commutative; that is, *CD* ≠ *DC*.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike addition, subtraction, and scalar multiplication, matrix multiplication
    is not a simple element-wise calculation, and the standard `*` operator cannot
    be used. Instead, you must use R’s matrix product operator, written with percent
    symbols as `%*%`. Before you try this operator, let’s first store the two example
    matrices and check to make sure the number of columns in the first matrix matches
    the number of rows in the second matrix using `dim`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This confirms the two matrices are compatible for multiplication, so you can
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can show that matrix multiplication is noncommutative using the same two
    matrices. Switching the order of multiplication gives you an entirely different
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '***3.3.6 Matrix Inversion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some square matrices can be *inverted*. The inverse of a matrix *A* is denoted
    *A*^(–1). An invertible matrix satisfies the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AA*^(–1) = *I*[*m*]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a matrix and its inverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0051-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Matrices that are not invertible are referred to as *singular*. Inverting a
    matrix is often necessary when solving equations with matrices and has important
    practical ramifications. There are several different approaches to matrix inversion,
    and these calculations can become extremely computationally expensive as you increase
    the size of a matrix. We won’t go into too much detail here, but if you’re interested,
    see Golub and Van Loan ([1989](ref.xhtml#ref26)) for formal discussions.
  prefs: []
  type: TYPE_NORMAL
- en: For now, I’ll just show you the R function solve as one option for inverting
    a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also verify that the product of these two matrices (using matrix multiplication
    rules) results in the 2 × 2 identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 3.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0052-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Store these two matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0052-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Which of the following multiplications are possible? For those that are, compute
    the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*A* · *B*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A* ^⊤ · *B*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*B* ^⊤ · (*A* · *A* ^⊤)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: (*A* · *A* ^⊤) · *B* ^⊤
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[(*B* · *B* ^⊤) + (*A* · *A* ^⊤) − 100*I*[3]]^(−1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0052-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: confirm that *A*^(–1) · *A* − *I[4]* provides a 4 × 4 matrix of zeros.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**3.4 Multidimensional Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as a matrix (a “rectangle” of elements) is the result of increasing the
    dimension of a vector (a “line” of elements), the dimension of a matrix can be
    increased to get more complex data structures. In R, vectors and matrices can
    be considered special cases of the more general *array*, which is how I’ll refer
    to these types of structures when they have more than two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the next step up from a matrix? Well, just as a matrix is considered
    to be a collection of vectors of equal length, a three-dimensional array can be
    considered to be a collection of equally dimensioned matrices, providing you with
    a rectangular prism of elements. You still have a fixed number of rows and a fixed
    number of columns, as well as a new third dimension called a *layer*. [Figure
    3-3](ch03.xhtml#ch3fig3) illustrates a three-row, four-column, two-layer (3 ×
    4 × 2) array.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: A conceptual diagram of a 3* × *4* × *2 array. The index of each
    element is given at the corresponding position. These indexes are provided in
    the strict order of* `[row,column,layer]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***3.4.1 Definition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create these data structures in R, use the `array` function and specify
    the individual elements in the `data` argument as a vector. Then specify size
    in the `dim` argument as another vector with a length corresponding to the number
    of dimensions. Note that `array` fills the entries of each layer with the elements
    in `data` in a strict column-wise fashion, starting with the first layer. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you an array of the same size as in [Figure 3-3](ch03.xhtml#ch3fig3)—each
    of the two layers constitutes a 3 × 4 matrix. In this example, note the order
    of the dimensions supplied to `dim`: `c(rows`,columns,layers). Just like a single
    matrix, the product of the dimension sizes of an array will yield the total number
    of elements. As you increase the dimension further, the `dim` vector must be extended
    accordingly. For example, a four-dimensional array is the next step up and can
    be thought of as *blocks* of three-dimensional arrays. Suppose you had a four-dimensional
    array comprised of three copies of `AR`, the three-dimensional array just defined.
    This new array can be stored in R as follows (once again, the array is filled
    column-wise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With `BR` you now have three copies of `AR`. Each of these copies is split into
    its two layers so R can print the object to the screen. As before, the rows are
    indexed by the first digit, the columns by the second digit, and the layers by
    the third digit. The new fourth digit indexes the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.4.2 Subsets, Extractions, and Replacements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though high-dimensional objects can be difficult to conceptualize, R indexes
    them consistently. This makes extracting elements from these structures straightforward
    now that you know how to subset matrices—you just have to keep using commas in
    the square brackets as separators of the dimensions being accessed. This is highlighted
    in the examples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want the second row of the second layer of the previously created
    array `AR`. You just enter these exact dimensional locations of `AR` in square
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The desired elements have been extracted as a vector of length 4\. If you want
    specific elements from this vector, say the third and first, in that order, you
    can call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, this literal method of subsetting makes dealing with even highdimensional
    objects in R manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extraction that results in multiple vectors will be presented as columns
    in the returned matrix. For example, to extract the first rows of both layers
    of `AR`, you enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The returned object has the first rows of each of the two matrix layers. However,
    it has returned each of these vectors as a *column* of the single returned matrix.
    As this example shows, when multiple vectors are extracted from an array, they
    will be returned as columns by default. This means extracted rows will not necessarily
    be returned as rows.
  prefs: []
  type: TYPE_NORMAL
- en: Turning to the object `BR`, the following gives you the single element of the
    second row and first column of the matrix in the first layer of the three-dimensional
    array located in the third block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you just need to look at the position of the index in the square brackets
    to know which values you are asking R to return from the array. The following
    examples highlight this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This returns all the values in the first row of the first block. Since I left
    the column and layer indexes blank in this subset `[1,,,1]`, the command has returned
    values for all four columns and both layers in that block of `BR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the following line returns all the values in the second layer of the
    array `BR`, composed of three matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This last example highlights a feature noted earlier, where multiple vectors
    from `AR` were returned as a matrix. Broadly speaking, if you have an extraction
    that results in multiple *d*-dimensional arrays, the result will be an array of
    the next-highest dimension, *d* + 1\. In the last example, you extracted multiple
    (two-dimensional) matrices, and they were returned as a three-dimensional array.
    This is demonstrated again in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This extracts the elements at rows 3 and 2 (in that order), column 4, for all
    layers and for all array blocks. Consider the following final example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve asked R to return the entire second rows of the first layers of
    all the arrays stored in `BR`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting and overwriting elements in high-dimensional arrays follows the same
    rules as for stand-alone vectors and matrices. You specify the dimension positions
    the same way, using negative indexes (for deletion) or using the assignment operator
    for overwriting.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `array` function to create one-dimensional arrays (vectors)
    and two-dimensional arrays (matrices) should you want to (by setting the `dim`
    argument to be of length 1 or 2, respectively). Note, though, that vectors in
    particular may be treated differently by some functions if created with `array`
    instead of `c` (see the help file `?array` for technical details). For this reason,
    and to make large sections of code more readable, it’s more conventional in R
    programming to use the specific vector- and matrix-creation functions `c` and
    `matrix`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.3**'
  prefs: []
  type: TYPE_NORMAL
- en: Create and store a three-dimensional array with six layers of a 4 × 2 matrix,
    filled with a decreasing sequence of values between 4.8 and 0.1 of the appropriate
    length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract and store as a new object the fourth- and first-row elements, in that
    order, of the second column only of all layers of (a).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a fourfold repetition of the second row of the matrix formed in (b) to fill
    a new array of dimensions 2 × 2 × 2 × 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new array comprised of the results of deleting the sixth layer of (a).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the second and fourth row elements of the second column of layers
    1, 3, and 5 of (d) with −99.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix` | Create a matrix | [Section 3.1](ch03.xhtml#ch03lev1sec12), [p.
    40](ch03.xhtml#page_40) |'
  prefs: []
  type: TYPE_TB
- en: '| `rbind` | Create a matrix (bind rows) | [Section 3.1.2](ch03.xhtml#ch03lev2sec25),
    [p. 41](ch03.xhtml#page_41) |'
  prefs: []
  type: TYPE_TB
- en: '| `cbind` | Create a matrix (bind columns) | [Section 3.1.2](ch03.xhtml#ch03lev2sec25),
    [p. 42](ch03.xhtml#page_42) |'
  prefs: []
  type: TYPE_TB
- en: '| `dim` | Get matrix dimensions | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  prefs: []
  type: TYPE_TB
- en: '| `nrow` | Get number of rows | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  prefs: []
  type: TYPE_TB
- en: '| `ncol` | Get number of columns | [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    [p. 42](ch03.xhtml#page_42) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ , ]` | Matrix/array subsetting | [Section 3.2](ch03.xhtml#ch03lev1sec13),
    [p. 43](ch03.xhtml#page_43) |'
  prefs: []
  type: TYPE_TB
- en: '| `diag` | Diagonal elements/identity matrix | [Section 3.2.1](ch03.xhtml#ch03lev2sec27),
    [p. 44](ch03.xhtml#page_44) |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Matrix transpose | [Section 3.3.1](ch03.xhtml#ch03lev2sec29), [p. 47](ch03.xhtml#page_47)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Scalar matrix multiple | [Section 3.3.3](ch03.xhtml#ch03lev2sec31),
    [p. 49](ch03.xhtml#page_49) |'
  prefs: []
  type: TYPE_TB
- en: '| `+`, `-` | Matrix addition/subtraction | [Section 3.3.4](ch03.xhtml#ch03lev2sec32),
    [p. 49](ch03.xhtml#page_49) |'
  prefs: []
  type: TYPE_TB
- en: '| `%*%` | Matrix multiplication | [Section 3.3.5](ch03.xhtml#ch03lev2sec33),
    [p. 50](ch03.xhtml#page_50) |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Matrix inversion | [Section 3.3.6](ch03.xhtml#ch03lev2sec34), [p.
    51](ch03.xhtml#page_51) |'
  prefs: []
  type: TYPE_TB
- en: '| `array` | Create an array | [Section 3.4.1](ch03.xhtml#ch03lev2sec35), [p.
    53](ch03.xhtml#page_53) |'
  prefs: []
  type: TYPE_TB
