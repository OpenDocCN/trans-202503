- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONTAINERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixing bugs in `std::vector` is equal parts delight (it is the bestest data
    structure) and terror (if I mess it up, the world explodes).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Stephan T. Lavavej (Principal Developer, Visual C++ Libraries). Tweet dated
    3:11 am on August 22, 2016.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: The *standard template library* (*STL*) is the portion of the stdlib that provides
    containers and the algorithms to manipulate them, with iterators serving as the
    interface between the two. In the next three chapters, you’ll learn more about
    each of these components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'A *container* is a special data structure that stores objects in an organized
    way that follows specific access rules. There are three kinds of containers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Sequence containers store elements consecutively, as in an array.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative containers store sorted elements.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unordered associative containers store hashed objects.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative and unordered associative containers offer rapid search for individual
    elements. All containers are RAII wrappers around their contained objects, so
    they manage the storage durations and lifetimes of the elements they own. Additionally,
    each container provides some set of member functions that perform various operations
    on the object collection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ programs use containers all the time. Which container you choose
    for a particular application depends on the required operations, the contained
    objects’ characteristics, and efficiencies under particular access patterns. This
    chapter surveys the vast container landscape covered between the STL and Boost.
    Because there are so many containers in these libraries, you’ll explore the most
    popular ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequence Containers**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sequence containers* are STL containers that allow sequential member access.
    That is, you can start from one end of the container and iterate through to the
    other end. But except for this commonality, sequence containers are a varied and
    motley crew. Some containers have a fixed length; others can shrink and grow as
    program needs dictate. Some allow indexing directly into the container, whereas
    you can only access others sequentially. Additionally, each sequence container
    has unique performance characteristics that make it desirable in some situations
    and undesirable in others.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Working with sequence containers should feel intuitive because you’ve been acquainted
    with a primitive one since “Arrays” on [page 42](ch02.xhtml#page_42), where you
    saw the built-in or “C-style” array `T[]`. You’ll begin the survey of sequence
    containers by looking at the built-in array’s more sophisticated, cooler younger
    brother `std::array`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '***Arrays***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The STL provides `std::array` in the `<array>` header. An `array` is a sequential
    container that holds a fixed-size, contiguous series of elements. It combines
    the sheer performance and efficiency of built-in arrays with the modern conveniences
    of supporting copy/move construction/assignment, knowing its own size, providing
    bounds-checked member access, and other advanced features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You should use `array` instead of built-in arrays in virtually all situations.
    It supports almost all the same usage patterns as `operator[]` to access elements,
    so there aren’t many situations in which you’ll need a built-in array instead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also offers a `boost::array` in Boost Array’s `<boost/array.hpp>`. You
    shouldn’t need to use the Boost version unless you have a very old C++ tool chain.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `array<`T, S > class template takes two template parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The contained type T
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fixed size of the array S
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can construct an `array` and built-in arrays using the same rules. To summarize
    these rules from “Arrays” on [page 42](ch02.xhtml#page_42), the preferred method
    is to use braced initialization to construct an `array`. Braced initialization
    fills the `array` with the values contained in the braces and fills the remaining
    elements with zeros. If you omit initialization braces, the `array` contains uninitialized
    values depending on its storage duration. [Listing 13-1](ch13.xhtml#ch13ex01)
    illustrates braced initialization with several `array` declarations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Initializing a `std::array`. You might get compiler warnings
    from `REQUIRE(local_array[0] != 0);` ➍, since `local_array` has uninitialized
    elements.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: You declare an `array` of 10 `int` objects called `static_array` with static
    storage duration ➊. You haven’t used braced initialization, but its elements initialize
    to zero anyway ➋, thanks to the initialization rules covered in “Arrays” on [page
    42](ch02.xhtml#page_42).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Next, you try declaring another `array` of 10 `int` objects, this time with
    automatic storage duration ➌. Because you haven’t used braced initialization,
    `local_array` contains uninitialized elements (that have an extremely low probability
    of equaling zero ➍).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you use braced initialization to declare another `array` and to fill
    the first four elements ➎. All remaining elements get set to zero ➏.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Element Access**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The three main methods by which you can access arbitrary `array` elements are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '`operator[]`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `operator[]` and `at` methods take a single `size_t` argument corresponding
    to the index of the desired element. The difference between these two lies in
    bounds checking: if the index argument is out of bounds, `at` will throw a `std::out_of_range`
    exception, whereas `operator[]` will cause undefined behavior. The function template
    `get` takes a template parameter of the same specification. Because it’s a template,
    the index must be known at compile time.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '*Recall from “The `size_t` Type” on [page 41](ch02.xhtml#page_41) that a `size_t`
    object guarantees that its maximum value is sufficient to represent the maximum
    size in bytes of all objects. It is for this reason that `operator[]` and `at`
    take a `size_t` rather than an `int`, which makes no such guarantee.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下在《`size_t`类型》一节中，位于[第41页](ch02.xhtml#page_41)的内容，`size_t`对象保证其最大值足以表示所有对象的最大字节大小。正因为如此，`operator[]`和`at`方法使用`size_t`而非`int`，后者并不做出此类保证。*'
- en: A major bonus of using `get` is that you get compile-time bounds checking, as
    illustrated in [Listing 13-2](ch13.xhtml#ch13ex02).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get`的一个重要优势是，你可以获得编译时的边界检查，正如[列表13-2](ch13.xhtml#ch13ex02)所示。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Accessing elements of an `array`. Uncommenting `// fib[4] =
    5;`* ➍ *will cause undefined behavior, whereas uncommenting `// std::get<4>(fib);`*
    ➓ *will cause compilation failure.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-2：访问`array`元素。取消注释`// fib[4] = 5;`* ➍ *将导致未定义行为，而取消注释`// std::get<4>(fib);`*
    ➓ *将导致编译失败。*'
- en: You declare an array of length 4 called `fib` ➊. Using `operator[]` ➋ you can
    set elements and retrieve them ➌. The out of bounds write you’ve commented out
    would cause undefined behavior; there is no bounds checking with `operator[]`
    ➍.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个长度为4的数组`fib` ➊。使用`operator[]` ➋你可以设置元素并检索它们 ➌。你注释掉的越界写入将导致未定义行为；`operator[]`没有边界检查
    ➍。
- en: You can use `at` for the same read ➎ and write ➏ operations, and you can safely
    perform an out-of-bounds operation thanks to bounds checking ➐.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`at`进行相同的读取 ➎ 和写入 ➏ 操作，并且可以安全地执行越界操作，因为有边界检查 ➐。
- en: Finally, you can use `std::get` to `set` ➑ and `get` ➒ elements. The `get` element
    also performs bounds checking, so `// std::get<4>(fib);` ➓ will fail to compile
    if uncommented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`std::get`来`设置` ➑ 和`获取` ➒ 元素。`get`元素还会进行边界检查，因此如果取消注释，`// std::get<4>(fib);`
    ➓ 将无法编译。
- en: You’ve also have a `front` and a `back` method, which return references to the
    first and last elements of the array. You’ll get undefined behavior if you call
    one of these methods if the array has zero length, as [Listing 13-3](ch13.xhtml#ch13ex03)
    illustrates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有`front`和`back`方法，它们分别返回数组的第一个和最后一个元素的引用。如果数组长度为零，调用这些方法将导致未定义行为，正如[列表13-3](ch13.xhtml#ch13ex03)所示。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Using the convenience methods `front` and `back` on a `std::array`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-3：在`std::array`上使用便捷方法`front`和`back`*'
- en: You can use the `front` and `back` methods to set ➊➍ and get ➋➎ the first and
    last elements of an `array`. Of course, `fib[0]` is identical to `fib.front()`
    ➌, and `fib[3]` is identical to `fib.back()` ➏. The `front()` and `back()` methods
    are simply convenience methods. Additionally, if you’re writing generic code,
    some containers will offer `front` and `back` but not `operator[]`, so it’s best
    to use the `front` and `back` methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`front`和`back`方法来设置 ➊➍ 和获取 ➋➎ `array`的第一个和最后一个元素。当然，`fib[0]`与`fib.front()`
    ➌ 完全相同，`fib[3]`与`fib.back()` ➏ 完全相同。`front()`和`back()`方法只是便捷方法。此外，如果你在编写通用代码时，某些容器可能提供`front`和`back`，但不提供`operator[]`，因此最好使用`front`和`back`方法。
- en: '**Storage Model**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: An `array` doesn’t make allocations; rather, like a built-in array, it contains
    all of its elements. This means copies will generally be expensive, because each
    constituent element needs to be copied. Moves can be expensive, depending on whether
    the underlying type of the `array` also has move construction and move assignment,
    which are relatively inexpensive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`不进行内存分配；相反，它像内建数组一样，包含其所有元素。这意味着复制通常会很昂贵，因为每个组成元素都需要复制。移动可能会很昂贵，具体取决于`array`的底层类型是否也支持移动构造和移动赋值，而这些操作相对便宜。'
- en: 'Each `array` is just a built-in array underneath. In fact, you can extract
    a pointer to the first element of an `array` using four distinct methods:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`array`底层其实就是一个内建数组。实际上，你可以通过四种不同的方法提取指向`array`第一个元素的指针：
- en: The go-to method is to use the `data` method. As advertised, this returns a
    pointer to the first element.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的方法是使用`data`方法。正如其宣传所说，它返回指向第一个元素的指针。
- en: The other three methods involve using the address-of operator `&` on the first
    element, which you can obtain using `operator[]`, `at`, and `front`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他三种方法涉及使用取地址操作符`&`在第一个元素上，这些元素可以通过`operator[]`、`at`和`front`获得。
- en: You should use `data`. If the `array` is empty, the address-of-based approaches
    will return undefined behavior.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用`data`。如果`array`为空，基于取地址操作的方法将返回未定义行为。
- en: '[Listing 13-4](ch13.xhtml#ch13ex04) illustrates how to obtain a pointer using
    these four methods.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-4](ch13.xhtml#ch13ex04)展示了如何通过这四种方法获得指针。'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Obtaining a pointer to the first element of a `std::array`*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-4：获取`std::array`第一个元素的指针*'
- en: After initializing the `array color`, you obtain a pointer to the first element,
    the letter `o`, using the `data` method ➊. When you dereference the resulting
    `color_ptr`, you obtain the letter `o` as expected ➋. This pointer is identical
    to the pointer obtained from the `address-of-`plus-`front` ➌, -`at` ➍, and -`operator[]`
    ➎ approaches.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`array color`后，你可以通过`data`方法 ➊ 获取指向第一个元素的指针，即字母`o`。当你解引用得到的`color_ptr`时，你会如预期得到字母`o`
    ➋。这个指针与通过`address-of-`加`front` ➌、`at` ➍ 和`operator[]` ➎ 方法获得的指针是相同的。
- en: To conclude arrays, you can query the size of an `array` using either the `size`
    or `max_size` methods. (These are identical for an `array`.) Because an `array`
    has a fixed size, these method’s values are static and known at compile time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结数组时，你可以使用`size`或`max_size`方法查询`array`的大小。（这两个方法对于`array`来说是相同的。）因为`array`的大小是固定的，这些方法的值在编译时就已经确定。
- en: '**A Crash Course in Iterators**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**迭代器速成课程**'
- en: The interface between containers and algorithms is the iterator. An iterator
    is a type that knows the internal structure of a container and exposes simple,
    pointer-like operations to a container’s elements. [Chapter 14](ch14.xhtml#ch14)
    is dedicated entirely to iterators, but you need to know the very basics here
    so you can explore how to use iterators to manipulate containers and how containers
    expose iterators to users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与算法之间的接口就是迭代器。迭代器是一种知道容器内部结构的类型，并向容器元素暴露类似指针的简单操作。[第14章](ch14.xhtml#ch14)专门讲解迭代器，但你在这里需要了解一些基本知识，以便你能够探索如何使用迭代器操作容器，以及容器如何向用户暴露迭代器。
- en: 'Iterators come in various flavors, but they all support at least the following
    operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器有不同的种类，但它们都至少支持以下操作：
- en: Get the current element (`operator*`)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前元素（`operator*`）
- en: Go to the next element (`operator++`)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到下一个元素（`operator++`）
- en: Assign an iterator equal to another iterator (`operator=`)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个迭代器赋值给另一个迭代器（`operator=`）
- en: You can extract iterators from all STL containers (including `array`) using
    their `begin` and `end` methods. The `begin` method returns an iterator pointing
    to the first element, and the `end` method returns a pointer to one element past
    the last element. [Figure 13-1](ch13.xhtml#ch13fig01) illustrates where the `begin`
    and `end` iterators point in an array of three elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过所有STL容器（包括`array`）的`begin`和`end`方法提取迭代器。`begin`方法返回一个指向第一个元素的迭代器，而`end`方法返回指向最后一个元素之后的元素的指针。[图
    13-1](ch13.xhtml#ch13fig01)展示了`begin`和`end`迭代器在一个包含三个元素的数组中的指向位置。
- en: '![image](../images/fig13_1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_1.jpg)'
- en: '*Figure 13-1: A half-open range over an `array` of three elements*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：一个包含三个元素的`array`的半开区间*'
- en: The arrangement in [Figure 13-1](ch13.xhtml#ch13fig01), where `end()` points
    after the last element, is called a *half-open range*. It might seem counterintuitive
    at first—why not have a closed range where `end()` points to the last element—but
    a half-open range has some advantages. For example, if a container is empty, `begin()`
    will return the same value as `end()`. This allows you to know that, regardless
    of whether the container is empty, if the iterator equals `end()`, you’ve traversed
    the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 13-1](ch13.xhtml#ch13fig01)中的排列，其中`end()`指向最后一个元素之后的位置，称为*半开区间*。这可能一开始看起来不太直观——为什么不使用闭区间，让`end()`指向最后一个元素——但半开区间有其优势。例如，如果一个容器为空，`begin()`会返回与`end()`相同的值。这让你能够知道，无论容器是否为空，只要迭代器等于`end()`，就表示你已经遍历了容器。
- en: '[Listing 13-5](ch13.xhtml#ch13ex05) illustrates what happens with half-open
    range iterators and empty containers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 13-5](ch13.xhtml#ch13ex05)展示了半开区间迭代器和空容器的行为。'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-5: With an empty `array`, the `begin` iterator equals the `end`
    iterator.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-5：对于一个空的`array`，`begin`迭代器等于`end`迭代器。*'
- en: Here, you construct an empty array `e` ➊, and the `begin` ➋ and `end` ➌ iterators
    are equal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个空数组`e` ➊，并且`begin` ➋ 和`end` ➌ 迭代器是相等的。
- en: '[Listing 13-6](ch13.xhtml#ch13ex06) examines how to use iterators to perform
    pointer-like operations over a non-empty `array`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 13-6](ch13.xhtml#ch13ex06)展示了如何使用迭代器在一个非空的`array`上执行类似指针的操作。'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-6: Basic `array` iterator operations*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-6：基本的`array`迭代器操作*'
- en: The `array easy_as` contains the elements 1, 2, and 3 ➊. You invoke `begin`
    on `easy_as` to obtain an iterator `iter` pointing to the first element ➋. The
    dereference operator yields the first element 1, because this is the first element
    in the `array` ➌. Next, you increment `iter` so it points to the next element
    ➍. You continue in this fashion until you reach the last element ➎. Incrementing
    the pointer one last time puts you 1 past the last element ➏, so `iter` equals
    `easy_as.end()`, indicating that you’ve traversed the `array` ➐.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Recall from “Range Expressions” on [page 235](ch08.xhtml#page_235) that you
    can build your own types for use in range expressions by exposing a `begin` and
    an `end` method, as implemented in the `FibonacciIterator` in [Listing 8-29](ch08.xhtml#ch08ex29).
    Well, containers already do all this work for you, meaning you can use any STL
    container as a range expression. [Listing 13-7](ch13.xhtml#ch13ex07) illustrates
    by iterating over an `array`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-7: Range-based `for` loops and `array`s*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: You initialize an `array` ➊ and a `sum` variable ➋. Because `array` is a valid
    range, you can use it in a ranged-based `for` loop ➌. This enables you to accumulate
    the `sum` of each `element` ➍.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 13-1](ch13.xhtml#ch13tab01) provides a partial list of `array` operations.
    In this table, `a`, `a1`, and `a2` are of type `std::array<T, S>`, `t` is of type
    `T`, `S` is the fixed length of the array, and `i` is of type `size_t`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** A Partial List of `std::array` Operations'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `array<`T`,` S`>{` ... `}` | Performs braced initialization of a newly constructed
    array. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `~array` | Destructs all elements contained by the array. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| a1 `=` a2 | Copy-assigns all the members of a1 with the members of a2. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| a.`at`(i) | Returns a reference to element i of a. Throws `std::out_of_range`
    if out of bounds. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| a`[`i`]` | Returns a reference to element i of a. Undefined behavior if out
    of bounds. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `get<`i`>``(`a`)` | Returns a reference to element i of a. Fails to compile
    if out of bounds. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| a`.front()` | Returns a reference to first element. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| a`.back()` | Returns a reference to last element. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| a`.data()` | Returns a raw pointer to the first element if the array is non-empty.
    For empty arrays, returns a valid but non-dereferencable pointer. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| a`.empty()` | Returns `true` if the array’s size is zero; otherwise `false`.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| a.`size()` | Returns the size of the array. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| a`.max_size()` | Identical to a`.size()`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| a.`fill(`t`)` | Copy-assigns t to every element of a. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| a1`.swap(`a2`)``swap(`a1`,` a2`)` | Exchanges each element of a1 with those
    of a2. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| a`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| a`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| a`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| a`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| a`.cend()` | 返回指向最后一个元素之后的 `const` 迭代器。 |'
- en: '| a1 `==` a2a1 `!=` a2a1 `>` a2a1 `>=` a2a1 `<` a2a1 `<=` a2 | Equal if all
    elements are equal.Greater than/less than comparisons proceed from first element
    to last. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| a1 `==` a2a1 `!=` a2a1 `>` a2a1 `>=` a2a1 `<` a2a1 `<=` a2 | 如果所有元素相等，则相等。大于/小于比较从第一个元素到最后一个元素进行。
    |'
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The partial operations in [Table 13-1](ch13.xhtml#ch13tab01) function as quick,
    reasonably comprehensive references. For gritty details, refer to the freely available
    online references [https://cppreference.com/](https://cppreference.com/) and [http://cplusplus.com/](http://cplusplus.com/),
    as well as Chapter 31 of The C++ Programming Language, 4th Edition, by Bjarne
    Stroustrup and [Chapters 7](ch07.xhtml#ch07), [8](ch08.xhtml#ch08), and [12](ch12.xhtml#ch12)
    of The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Table 13-1](ch13.xhtml#ch13tab01) 中的部分操作可以作为快速且合理全面的参考。有关详细信息，请参考免费在线文献 [https://cppreference.com/](https://cppreference.com/)
    和 [http://cplusplus.com/](http://cplusplus.com/)，以及 Bjarne Stroustrup 的《C++ 程序设计语言》第
    4 版的第 31 章，以及 Nicolai M. Josuttis 的《C++ 标准库》第二版中的第 7 章](ch07.xhtml#ch07)，[8](ch08.xhtml#ch08)
    和 [12](ch12.xhtml#ch12) 。*'
- en: '***Vectors***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vectors***'
- en: The `std::vector` available in the STL’s `<vector>` header is a sequential container
    that holds a dynamically sized, contiguous series of elements. A `vector` manages
    its storage dynamically, requiring no outside help from the programmer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 的 `<vector>` 头文件中，`std::vector` 是一个顺序容器，存储着一个动态大小的、连续的元素序列。`vector` 动态管理其存储，不需要程序员的外部帮助。
- en: The `vector` is the workhorse of the sequential-data-structure stable. For a
    very modest overhead, you gain substantial flexibility over the `array`. Plus,
    `vector` supports almost all of the same operations as an `array` and adds a slew
    of others. If you have a fixed number of elements on hand, you should strongly
    consider an `array` because you’ll get some small reductions in overhead versus
    a `vector`. In all other situations, your go-to sequential container is the `vector`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 是顺序数据结构中的工作马。仅有少量开销，你就能获得比 `array` 更多的灵活性。而且，`vector` 支持几乎与 `array`
    相同的所有操作，并且增加了许多其他功能。如果你手头有固定数量的元素，你应该强烈考虑使用 `array`，因为它相对于 `vector` 会有一些小的开销减少。在所有其他情况下，你的首选顺序容器是
    `vector`。'
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::vector` in
    the `<boost/container/vector.hpp>` header.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了一个位于 `<boost/container/vector.hpp>` 头文件中的 `boost::container::vector`。*'
- en: '**Constructing**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: The class template `std::vector<T, Allocator>` takes two template parameters.
    The first is the contained type `T`, and the second is the allocator type `Allocator`,
    which is optional and defaults to `std::allocator<T>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::vector<T, Allocator>` 接受两个模板参数。第一个是元素类型 `T`，第二个是分配器类型 `Allocator`，这是可选的，默认值为
    `std::allocator<T>`。
- en: You have much more flexibility in constructing `vector`s than you do with arrays.
    A `vector` supports user-defined allocators because vectors need to allocate dynamic
    memory. You can default construct a `vector` so it contains no elements. You might
    want to construct an empty vector so you can fill it with a variable number of
    elements depending on what happens during runtime. [Listing 13-8](ch13.xhtml#ch13ex08)
    illustrates default constructing a `vector` and checking that it contains no elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相比数组，你在构造 `vector` 时具有更大的灵活性。`vector` 支持用户定义的分配器，因为 `vector` 需要动态分配内存。你可以默认构造一个不包含任何元素的
    `vector`。你可能想构造一个空的 `vector`，以便根据运行时的情况填充一个可变数量的元素。[Listing 13-8](ch13.xhtml#ch13ex08)
    展示了默认构造一个 `vector` 并检查它是否包含元素。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-8: A `vector` supports default construction.*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-8：`vector` 支持默认构造。*'
- en: You declare a `vector` containing elements of type `const char*` ➊ called `vec`.
    Because it’s been default constructed ➋, the `vector` contains no elements, and
    the `empty` method returns `true` ➌.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个包含 `const char*` 类型元素的 `vector` ➊，名为 `vec`。由于它是默认构造的 ➋，因此 `vector` 不包含任何元素，`empty`
    方法返回 `true` ➌。
- en: You can use braced initialization with a `vector`. Similar to how you brace
    initialize an array, this fills the vector with the specified elements, as [Listing
    13-9](ch13.xhtml#ch13ex09) illustrates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用花括号初始化来初始化 `vector`。类似于如何用花括号初始化数组，这种方式会用指定的元素填充 `vector`，如 [Listing 13-9](ch13.xhtml#ch13ex09)
    所示。
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-9: A `vector` supports braced initializers.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-9：`vector` 支持花括号初始化。*'
- en: Here, you construct a `vector` called `fib` and use braced initializers ➊. After
    initialization, the `vector` contains the five elements 1, 1, 2, 3, and 5 ➋.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你构造了一个名为`fib`的`vector`并使用大括号初始化器 ➊。初始化后，`vector`包含五个元素1、1、2、3和5 ➋。
- en: If you want to populate a `vector` with many identical values, you can use one
    of the *fill constructors*. To fill construct a `vector`, you first pass a `size_t`
    corresponding to the number of elements you want to fill. Optionally, you can
    pass a `const` reference to an object to copy. Sometimes you want to initialize
    all your elements to the same value, for example, to keep track of counts related
    to particular indices. You might also have a `vector` of some user-defined type
    that keeps track of program state, and you might need to keep track of such state
    by index.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用许多相同的值来填充一个`vector`，你可以使用其中一个*填充构造函数*。要进行填充构造`vector`，你首先传入一个`size_t`值，表示你要填充的元素数量。你还可以选择传入一个`const`引用对象，以便进行复制。有时，你可能希望将所有元素初始化为相同的值，例如跟踪与特定索引相关的计数。你可能还有一个用于跟踪程序状态的某个用户定义类型的`vector`，你可能需要通过索引来追踪这些状态。
- en: Unfortunately, the general rule to use braced initialization to construct objects
    breaks down here. With `vector`, you must use parentheses to invoke these constructors.
    To the compiler, `std::vector<int>{ 99, 100 }` specifies an initialization list
    with the elements 99 and 100, which will construct a vector with the two elements
    99 and 100\. What if you want a vector with 99 copies of the number 100?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用大括号初始化构造对象的通用规则在这里失效了。对于`vector`，你必须使用圆括号来调用这些构造函数。对于编译器来说，`std::vector<int>{
    99, 100 }`指定了一个包含99和100两个元素的初始化列表，这将构造一个包含99和100两个元素的`vector`。如果你想要一个包含99个100的副本的`vector`，该怎么办呢？
- en: In general, the compiler will try very hard to treat the initializer list as
    elements to fill the vector with. You can try to memorize the rules (refer to
    Item 7 of *Effective Modern C++* by Scott Meyers) or just commit to using parentheses
    for stdlib container constructors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会尽力将初始化列表视为用于填充`vector`的元素。你可以尝试记住这些规则（参考Scott Meyers的《*Effective Modern
    C++*》第7条）或者干脆决定在使用标准库容器构造函数时总是使用圆括号。
- en: '[Listing 13-10](ch13.xhtml#ch13ex10) highlights the initializer list/braced
    initialization general rule for STL containers.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-10](ch13.xhtml#ch13ex10)展示了STL容器的一般初始化列表/大括号初始化规则。'
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-10: A `vector` supports braced initializers and fill constructors.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：一个`vector`支持大括号初始化器和填充构造函数。*'
- en: 'The first example uses braced initialization to construct a vector with two
    elements ➊: 5 at index 0 ➋ and 9 at index 1 ➌. The second example uses parentheses
    to invoke the fill constructor ➍, which fills the vector with five copies of the
    number 9, so the first ➎ and last ➏ elements are both 9.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用大括号初始化构造了一个包含两个元素的`vector` ➊：索引0处的5 ➋ 和索引1处的9 ➌。第二个示例使用圆括号调用填充构造函数 ➍，该构造函数将`vector`填充为五个9的副本，因此第一个
    ➎ 和最后一个 ➏ 元素都是9。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This notational clash is unfortunate and isn’t the result of some well-thought-out
    trade-off. The reasons are purely historical and related to backward compatibility.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种符号冲突是不幸的，并非经过深思熟虑的权衡结果。其原因纯粹是历史原因，并与向后兼容性相关。*'
- en: You can also construct `vector`s from a half-open range by passing in the `begin`
    and `end` iterators of the range you want to copy. In various programming contexts,
    you might want to splice out a subset of some range and copy it into a `vector`
    for further processing. For example, you could construct a `vector` that copies
    all the elements contained by an `array`, as in [Listing 13-11](ch13.xhtml#ch13ex11).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入目标范围的`begin`和`end`迭代器来从半开区间构造`vector`。在各种编程上下文中，你可能希望从某个范围中提取出一部分子集并将其复制到`vector`中以进行进一步处理。例如，你可以构造一个`vector`，复制一个`array`中包含的所有元素，就像在[清单
    13-11](ch13.xhtml#ch13ex11)中展示的那样。
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-11: Constructing a `vector` from a range*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-11：从范围构造一个`vector`*'
- en: You construct the array `fib_arr` with five elements ➊. To construct the vector
    `fib_vec` with the elements contained in `fib_arr`, you invoke the `begin` and
    `end` methods on `fib_arr` ➋. The resulting `vector` has copies of the `array`’s
    elements ➌ and has the same `size` ➍.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用五个元素构造了数组`fib_arr` ➊。要使用`fib_arr`中的元素构造`fib_vec`，你需要调用`fib_arr`的`begin`和`end`方法
    ➋。结果是，构造的`vector`包含了`array`的元素副本 ➌，并且具有相同的`size` ➍。
- en: At a high level, you can think of this constructor as taking pointers to the
    beginning and the end of some target sequence. It will then copy that target sequence.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你可以把这个构造函数理解为接受指向某个目标序列的开始和结束的指针。它将会复制这个目标序列。
- en: '**Move and Copy Semantics**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With `vector`s, you have full copy/move construction/assignment support. Any
    `vector` copy operation is potentially very expensive, because these are element-wise
    or deep copies. Move operations, on the other hand, are usually very fast, because
    the contained elements reside in dynamic memory and the moved-from `vector` can
    simply pass ownership to the moved-into `vector`; there’s no need to move the
    contained elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Element Access**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `vector` supports most of the same element access operations as `array`:
    `at`, `operator[]`, `front`, `back`, and `data`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: As with an `array`, you can query the number of contained elements in a `vector`
    using the `size` method. This method’s return value can vary at runtime. You can
    also determine whether a `vector` contains any elements with the `empty` method,
    which returns `true` if the `vector` contains no elements; otherwise, it returns
    `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Elements**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can use various methods to insert elements into a `vector`. If you want
    to replace all the elements in a `vector`, you can use the `assign` method, which
    takes an initialization list and replaces all the existing elements. If needed,
    the `vector` will resize to accommodate a larger list of elements, as [Listing
    13-12](ch13.xhtml#ch13ex12) illustrates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-12: The `assign` method of a `vector`*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Here, you construct a `vector` ➊ with seven elements ➋. When you assign a new,
    smaller initializer list ➌, all the elements get replaced ➍, and the vector’s
    `size` updates to reflect the new contents ➎.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to insert a single new element into a vector, you can use the `insert`
    method, which expects two arguments: an iterator and an element to insert. It
    will insert a copy of the given element just before the existing element pointed
    to by the iterator, as shown in [Listing 13-13](ch13.xhtml#ch13ex13).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-13: The `insert` method of a `vector`*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: You initialize a vector with three zeros ➊ and generate an iterator pointing
    to the third element of `zeros` ➋. Next, you insert the value 10 immediately before
    the third element by passing the iterator and the value 10 ➌. The third element
    of `zeros` is now 10 ➍. The `zeros` vector now contains four elements ➎.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time you use `insert`, existing iterators become invalid. For example,
    in [Listing 13-13](ch13.xhtml#ch13ex13) you must not reuse `third_element`: the
    vector could have resized and relocated in memory, leaving the old iterator dangling
    in garbage memory.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To insert an element to the end of a `vector`, you use the `push_back` method.
    Unlike `insert`, `push_back` doesn’t require an iterator argument. You simply
    provide the element to copy into the `vector`, as shown in [Listing 13-14](ch13.xhtml#ch13ex14).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-14: The `push_back` method of a `vector`*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Again, you initialize a `vector` with three zeros ➊, but this time you insert
    the element 10 to the back of the `vector` using the `push_back` method ➋. The
    `vector` now contains four elements, the last of which equals 10 ➌.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，你初始化了一个包含三个零的`vector` ➊，但这次你使用`push_back`方法将元素10插入到`vector`的末尾 ➋。`vector`现在包含四个元素，最后一个元素是10
    ➌。
- en: You can construct new elements in place using the `emplace` and `emplace_back`
    methods. The `emplace` method is a variadic template that, like `insert`, accepts
    an iterator as its first argument. The remaining arguments get forwarded to the
    appropriate constructor. The `emplace_back` method is also a variadic template,
    but like `push_back`, it doesn’t require an iterator. It accepts any number of
    arguments and forwards those to the appropriate constructor. [Listing 13-15](ch13.xhtml#ch13ex15)
    illustrates these two methods by emplacing a few `pair`s into a `vector`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`emplace`和`emplace_back`方法在原地构造新元素。`emplace`方法是一个变参模板，像`insert`一样，它将一个迭代器作为第一个参数。其余的参数将被转发到适当的构造函数。`emplace_back`方法也是一个变参模板，但像`push_back`一样，它不需要迭代器。它接受任意数量的参数，并将这些参数转发到适当的构造函数。[列表13-15](ch13.xhtml#ch13ex15)通过将一些`pair`添加到`vector`中来展示这两种方法。
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-15: The `emplace_back` and `emplace` methods of a `vector`*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-15：`vector`的`emplace_back`和`emplace`方法*'
- en: 'Here, you default construct a `vector` containing `pair`s of `int`s ➊. Using
    the `emplace_back` method, you push three pairs onto the vector: 2, 30 ➋; 3, 20
    ➌; and 4, 15 ➍. These values get forwarded directly to the constructor of `pair`,
    which gets constructed in place. Next, you use `emplace` to insert a new `pair`
    at the beginning of the vector by passing the result of `factors.begin()` as the
    first argument ➎. This causes all the elements in the vector to shift down to
    make room for the new `pair` (1 ➏, 60 ➐).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造了一个包含`int`类型`pair`的`vector` ➊。使用`emplace_back`方法，你将三个`pair`推入`vector`中：2，30
    ➋；3，20 ➌；以及4，15 ➍。这些值直接传递给`pair`的构造函数，从而在原地构造了`pair`。接着，你使用`emplace`方法通过传递`factors.begin()`的结果作为第一个参数，向`vector`的开头插入一个新的`pair`
    ➎。这会导致`vector`中的所有元素向下移动，为新的`pair`腾出空间（1 ➏，60 ➐）。
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s absolutely nothing special about a `std::vector<std::pair<int, int>>`.
    It’s just like any other `vector`. The individual elements in this sequential
    container just happen to be a `pair`. Because `pair` has a constructor that accepts
    two arguments, one for `first` and one for `second`, `emplace_back` can add a
    new element by simply passing the two values it should write into the newly created
    `pair`.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*`std::vector<std::pair<int, int>>`其实没有什么特别的。它和其他的`vector`一样。这个顺序容器中的每个元素恰好是一个`pair`。由于`pair`有一个接受两个参数的构造函数，一个用于`first`，一个用于`second`，`emplace_back`可以通过直接传递这两个值来将一个新元素添加到`pair`中。*'
- en: Because the emplacement methods can construct elements in place, it seems they
    should be more efficient than the insertion methods. This intuition is often correct,
    but for complicated and unsatisfying reasons it’s not always faster. As a general
    rule, use the emplacement methods. If you determine a performance bottleneck,
    also try the insertion methods. See Item 42 of *Effective Modern C++* by Scott
    Meyers for a treatise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`emplace`方法可以原地构造元素，因此它们似乎应该比插入方法更高效。这种直觉通常是正确的，但由于复杂且令人不满意的原因，它并不总是更快。一般来说，使用`emplace`方法。如果你发现性能瓶颈，也可以尝试插入方法。有关详细讨论，请参阅Scott
    Meyers的《*Effective Modern C++*》第42条。
- en: '**Storage Model**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: Although `vector` elements are contiguous in memory, like an `array`, the similarities
    stop there. A `vector` has dynamic size, so it must be able to resize. The allocator
    of a `vector` manages the dynamic memory underpinning the `vector`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`vector`的元素在内存中是连续的，像`array`一样，但相似之处仅此而已。`vector`的大小是动态的，因此它必须能够调整大小。`vector`的分配器管理着支撑`vector`的动态内存。
- en: Because allocations are expensive, a `vector` will request more memory than
    it needs to contain the current number of elements. Once it can no longer add
    any more elements, it will request additional memory. The memory for a `vector`
    is always contiguous, so if there isn’t enough space at the end of the existing
    vector, it will allocate a whole new region of memory and move all the elements
    of the `vector` into the new region. The number of elements a `vector` holds is
    called its *size*, and the number of elements it could theoretically hold before
    having to resize is called its *capacity*. [Figure 13-2](ch13.xhtml#ch13fig02)
    illustrates a `vector` containing three elements with additional capacity for
    three more.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存分配开销较大，`vector`会请求比实际需要的元素数量更多的内存空间。一旦它无法再添加更多元素，它会请求额外的内存。`vector`的内存总是连续的，因此如果现有`vector`的末尾没有足够的空间，它会分配一个全新的内存区域，并将所有元素移动到新区域中。`vector`所包含的元素数量称为它的*大小*，而它在不需要重新调整大小之前理论上能容纳的元素数量称为它的*容量*。[图13-2](ch13.xhtml#ch13fig02)展示了一个包含三元素的`vector`，并且额外有三元素的容量。
- en: '![image](../images/fig13_2.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_2.jpg)'
- en: '*Figure 13-2: The `vector` storage model*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：`vector`存储模型*'
- en: 'As [Figure 13-2](ch13.xhtml#ch13fig02) shows, the `vector` continues past the
    last element. The capacity determines how many elements the `vector` could hold
    in this space. In this figure, the size is three and the capacity is six. You
    can think of the memory in a `vector` as an auditorium: it might have a capacity
    of 500 but a crowd size of only 250.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13-2](ch13.xhtml#ch13fig02)所示，`vector`在最后一个元素之后继续存在。容量决定了`vector`在这块空间中能容纳多少元素。在此图中，大小是三，容量是六。你可以把`vector`中的内存想象成一个礼堂：它可能有500的容量，但观众人数只有250。
- en: The upshot of this design is that inserting at the end of a `vector` is extremely
    fast (unless the `vector` needs to resize). Inserting anywhere else incurs additional
    cost, because the `vector` needs to move elements around to make room.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的结果是，向`vector`末尾插入元素非常快速（除非`vector`需要重新调整大小）。在其他位置插入则会增加额外的开销，因为`vector`需要移动元素以腾出空间。
- en: You can obtain the vector’s current capacity via the `capacity` method, and
    you can obtain the absolute maximum capacity that a `vector` could resize to with
    the `max_size` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`capacity`方法获取`vector`当前的容量，也可以通过`max_size`方法获取`vector`理论上能扩展到的最大容量。
- en: If you know ahead of time that you’ll need a certain capacity, you can use the
    `reserve` method, which takes a single `size_t` argument corresponding to the
    number of elements you want capacity for. On the other hand, if you’ve just removed
    several elements and want to return memory to the allocator, you can use the `shrink_to_fit`
    method, which declares that you have excess capacity. The allocator can decide
    to reduce capacity or not (it’s a non-binding call).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提前知道自己需要某个容量，可以使用`reserve`方法，它接受一个`size_t`类型的参数，表示你希望为多少个元素预留空间。另一方面，如果你刚刚删除了几个元素，并希望将内存归还给分配器，你可以使用`shrink_to_fit`方法，表示你有多余的容量。分配器可以决定是否减少容量（这是一个非强制性的调用）。
- en: Additionally, you can delete all the elements in a vector and set its size to
    zero using the `clear` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`clear`方法删除`vector`中的所有元素，并将其大小设置为零。
- en: '[Listing 13-16](ch13.xhtml#ch13ex16) demonstrates all these storage-related
    methods in a cohesive story: you create an empty vector, reserve a bunch of space,
    add some elements, release excess capacity, and finally empty the vector.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单13-16](ch13.xhtml#ch13ex16)展示了所有这些与存储相关的方法，呈现了一个连贯的故事：你创建一个空的`vector`，预留一大块空间，添加一些元素，释放多余的容量，最后清空`vector`。'
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-16: The storage management functions of a `vector`. (Strictly speaking,
    `kb_store.capacity() >= 3` ➏ ➑ is not guaranteed because the call is non-binding.)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单13-16：`vector`的存储管理功能。（严格来说，`kb_store.capacity() >= 3` ➏ ➑不是保证的，因为这个调用是非强制性的。）*'
- en: You construct a `vector` of `array` objects called `kb_store`, which stores
    1 KiB chunks ➊. Unless you’re using a peculiar platform with no dynamic memory,
    `kb_store.max_size()` will be greater than zero; because you default initialize
    the `vector`, it’s empty ➋.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建了一个名为`kb_store`的`vector`数组对象，用于存储1 KiB的块➊。除非你使用的是没有动态内存的特殊平台，否则`kb_store.max_size()`的值会大于零；因为你对`vector`进行了默认初始化，它是空的➋。
- en: Next, you reserve 1,024 elements ➌, which doesn’t change the vector’s empty
    status but increases its capacity to match ➍. The `vector` now has 1,024 × 1 KiB
    = 1 MiB of contiguous space reserved. After reserving space, you emplace three
    arrays and check that `kb_store.size()` increased accordingly ➎.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你为1,024个元素保留空间 ➌，这并不会改变vector的空状态，但它会增加容量以匹配 ➍。此时，`vector` 已预留了 1,024 ×
    1 KiB = 1 MiB 的连续空间。保留空间后，你插入了三个数组，并检查`kb_store.size()`是否按预期增加 ➎。
- en: You’ve reserved space for 1,024 elements. To release the 1,024 – 3 = 1,021 elements
    you aren’t using back to the allocator, you call `shrink_to_fit`, which reduces
    the capacity to 3 ➏.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为1,024个元素保留了空间。为了将1,024 - 3 = 1,021个未使用的元素释放回分配器，你调用了`shrink_to_fit`，它将容量减少为3
    ➏。
- en: Finally, you invoke `clear` on the `vector` ➐, which destructs all elements
    and reduces its size to zero. However, the capacity remains unchanged because
    you haven’t made another call to `shrink_to_fit` ➑. This is significant because
    the vector doesn’t want to do extra work if you’re going to add elements again.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你在`vector` ➐上调用了`clear`，它销毁了所有元素并将其大小减少为零。然而，容量保持不变，因为你没有再次调用`shrink_to_fit`
    ➑。这很重要，因为如果你以后再添加元素，vector 不希望做额外的工作。
- en: '**A Partial List of Supported Operations**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持操作的部分列表**'
- en: '[Table 13-2](ch13.xhtml#ch13tab02) provides a partial list of `vector` operations.
    In this table, `v`, `v1`, and `v2` are of type `std::vector<T>`, `t` is of type
    `T`, `alc` is an appropriate allocator, and `itr` is an iterator. An asterisk
    (*) indicates that this operation invalidates raw pointers and iterators to `v`’s
    elements in at least some circumstances.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-2](ch13.xhtml#ch13tab02)提供了`vector`操作的部分列表。在此表中，`v`、`v1`和`v2`是`std::vector<T>`类型，`t`是`T`类型，`alc`是合适的分配器，`itr`是迭代器。星号(*)表示在某些情况下，该操作会使指向`v`元素的原始指针和迭代器失效。'
- en: '**Table 13-2:** A Partial List of `std::vector` Operations'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-2：** `std::vector`操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `vector<`T`>{ ...,` [alc]} | Performs braced initialization of a newly constructed
    vector. Uses alc`=std::allocator<`T`>` by default. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>{ ...,` [alc]} | 执行新构造的vector的花括号初始化。默认使用alc`=std::allocator<`T`>`。
    |'
- en: '| `vector<`T`>(`s`,[`t`], [`alc`])` | Fills the newly constructed vector with
    s number of copies of t. If no t is provided, default constructs T instances.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(`s`,[`t`], [`alc`])` | 用t的s个副本填充新构造的vector。如果没有提供t，则默认构造T的实例。
    |'
- en: '| `vector<`T`>(`v`)` | Deep copy of v; allocates new memory. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(`v`)` | 对v进行深度复制；分配新内存。 |'
- en: '| `vector<`T`>(move(`v`))` | Takes ownership of memory, elements in v. No allocations.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(move(`v`))` | 获取v中元素的内存所有权，不会重新分配内存。 |'
- en: '| `~vector` | Destructs all elements contained by the vector and releases dynamic
    memory. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `~vector` | 销毁vector包含的所有元素并释放动态内存。 |'
- en: '| v`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| v`.begin()` | 返回指向第一个元素的迭代器。 |'
- en: '| v`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| v`.cbegin()` | 返回指向第一个元素的`const`迭代器。 |'
- en: '| v`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| v`.end()` | 返回指向最后一个元素之后位置的迭代器。 |'
- en: '| v`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| v`.cend()` | 返回指向最后一个元素之后位置的`const`迭代器。 |'
- en: '| v1 `=` v2 | v1 destructs its elements; copies each v2 element. Only allocates
    if it needs to resize to fit v2’s elements.* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| v1 `=` v2 | v1销毁其元素；复制每个v2元素。只有在需要调整大小以适应v2的元素时才会分配内存。* |'
- en: '| v1 `=` `move(`v2`)` | v1 destructs its elements; moves each v2 element. Only
    allocates if it needs to resize to fit v2’s elements.* |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| v1 `=` `move(`v2`)` | v1销毁其元素；移动每个v2元素。只有在需要调整大小以适应v2的元素时才会分配内存。* |'
- en: '| v`.at(`0`)` | Accesses element 0 of v. Throws `std::out_of_range` if out
    of bounds. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| v`.at(`0`)` | 访问v的第0个元素。如果越界，抛出`std::out_of_range`异常。 |'
- en: '| v`[`0`]` | Accesses element 0 of v. Undefined behavior if out of bounds.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| v`[`0`]` | 访问v的第0个元素。如果越界，行为未定义。 |'
- en: '| v`.front()` | Accesses first element. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| v`.front()` | 访问第一个元素。 |'
- en: '| v`.back()` | Accesses last element. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| v`.back()` | 访问最后一个元素。 |'
- en: '| v`.data()` | Returns a raw pointer to the first element if array is non-empty.
    For empty arrays, returns a valid but non-dereferencable pointer. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| v`.data()` | 返回指向第一个元素的原始指针（如果数组非空）。对于空数组，返回一个有效但不可解引用的指针。 |'
- en: '| v`.assign({` ... `})` | Replaces the contents of v with the elements ....*
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| v`.assign({` ... `})` | 用元素替换v的内容 ....* |'
- en: '| v`.assign(`s`,` t`)` | Replaces the contents of v with s number of copies
    of t.* |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| v`.assign(`s`,` t`)` | 用s个t的副本替换v的内容。* |'
- en: '| v`.empty()` | Returns `true` if vector’s size is zero; otherwise `false`.
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| v`.empty()` | 如果 vector 的大小为零，则返回 `true`；否则返回 `false`。 |'
- en: '| v`.size()` | Returns the number of elements in the vector. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| v`.size()` | 返回 vector 中元素的数量。 |'
- en: '| v`.capacity()` | Returns the maximum number of elements the vector could
    hold without having to resize. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| v`.capacity()` | 返回 vector 可以容纳的最大元素数量，而无需调整大小。 |'
- en: '| v`.shrink_to_fit()` | Might reduce the vector’s storage so `capacity()` equals
    `size()`.* |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| v`.shrink_to_fit()` | 可能会减少 vector 的存储，使 `capacity()` 等于 `size()`。* |'
- en: '| v`.resize(`s`, [`t`])` | Resizes v to contain s elements. If this shrinks
    v, destructs elements at the end. If this grows v, inserts default constructed
    Ts or copies of t if provided.* |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| v`.resize(`s`, [`t`])` | 调整 v 的大小为 s 个元素。如果缩小 v，会销毁末尾的元素。如果扩展 v，则插入默认构造的
    T 元素，或者如果提供了 t，则插入 t 的副本。* |'
- en: '| v`.reserve(`s`)` | Increases the vector’s storage so it can contain at least
    s elements.* |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| v`.reserve(`s`)` | 增加 vector 的存储，以便它至少能够容纳 s 个元素。* |'
- en: '| v`.max_size()` | Returns the maximum possible size the vector can resize
    to. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| v`.max_size()` | 返回 vector 可以扩展到的最大可能大小。 |'
- en: '| v`.clear()` | Removes all elements in v, but capacity remains.* |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| v`.clear()` | 删除 v 中的所有元素，但容量保持不变。* |'
- en: '| v`.insert(`itr`,` t`)` | Inserts a copy of t just before the element pointed
    to by itr; v’s range must contain itr.* |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| v`.insert(`itr`,` t`)` | 在由 itr 指向的元素之前插入 t 的副本；v 的范围必须包含 itr。* |'
- en: '| v`.push_back(`t`)` | Inserts a copy of t at the end of v.* |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| v`.push_back(`t`)` | 在 v 的末尾插入 t 的副本。* |'
- en: '| v`.emplace(`itr`,` ...`)` | Constructs a T in place by forwarding the arguments
    ... to the appropriate constructor. Element inserted just before the element pointed
    to by itr.* |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| v`.emplace(`itr`,` ...`)` | 通过将参数 ... 转发给适当的构造函数，在 itr 指向的元素之前就地构造一个 T 元素。*
    |'
- en: '| v`.emplace_back(`...`)` | Constructs a T in place by forwarding the arguments
    ... to the appropriate constructor. Element inserted at the end of v.* |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| v`.emplace_back(`...`)` | 通过将参数 ... 转发给适当的构造函数，在 v 的末尾就地构造一个 T 元素。* |'
- en: '| v1`.swap(`v2`)``swap(`v1`,` v2`)` | Exchanges each element of v1 with those
    of v2.* |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| v1`.swap(`v2`)``swap(`v1`,` v2`)` | 交换 v1 和 v2 的每个元素。* |'
- en: '| v1 `==` v2v1 `!=` v2v1 `>` v2v1 `>=` v2v1 `<` v2v1 `<=` v2 | Equal if all
    elements are equal.Greater than/less than comparisons proceed from first element
    to last. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| v1 `==` v2v1 `!=` v2v1 `>` v2v1 `>=` v2v1 `<` v2v1 `<=` v2 | 如果所有元素相等，则为相等。大于/小于的比较从第一个元素到最后一个元素进行。
    |'
- en: '***Niche Sequential Containers***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***小众顺序容器***'
- en: The `vector` and `array` containers are the clear choice in most situations
    in which you need a sequential data structure. If you know the number of elements
    you’ll need ahead of time, use an `array`. If you don’t, use a `vector`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数需要顺序数据结构的情况下，`vector` 和 `array` 容器是首选。如果你事先知道所需的元素数量，使用 `array`。如果不知道，使用
    `vector`。
- en: You might find yourself in a niche situation where `vector` and `array` don’t
    have the performance characteristics you desire. This section highlights a number
    of alternative sequential containers that might offer superior performance characteristics
    in such a situation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一个特殊的情况，在这种情况下，`vector` 和 `array` 无法提供你所需的性能特性。本节重点介绍了一些可能在这种情况下提供更高性能特性的替代顺序容器。
- en: '**Deque**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双端队列**'
- en: A *deque* (pronounced “deck”) is a sequential container with fast insert and
    remove operations from the front and back. Deque is a portmanteau of **d**ouble*-***e**nded
    **que**ue. The STL implementation `std::deque` is available from the `<deque>`
    header.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*deque*（发音为“deck”）是一个顺序容器，具有快速的插入和删除操作，支持从前端和后端进行操作。Deque 是 **d**ouble*-***e**nded
    **que**ue 的合成词。STL 实现的 `std::deque` 可通过 `<deque>` 头文件使用。'
- en: '**NOTE**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::deque` in the
    `<boost/container/deque.hpp>` header.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了一个 `boost::container::deque`，定义在 `<boost/container/deque.hpp>`
    头文件中。*'
- en: A `vector` and a `deque` have very similar interfaces, but internally their
    storage models are totally different. A `vector` guarantees that all elements
    are sequential in memory, whereas a `deque`’s memory is usually scattered about,
    like a hybrid between a `vector` and a `list`. This makes large resizing operations
    more efficient and enables fast element insertion/deletion at the container’s
    front.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 和 `deque` 有非常相似的接口，但它们的内部存储模型完全不同。`vector` 保证所有元素在内存中是连续的，而 `deque`
    的内存通常是分散的，类似于 `vector` 和 `list` 的混合体。这使得大规模调整大小操作更加高效，并且支持在容器的前端快速插入/删除元素。'
- en: Constructing and accessing members are identical operations for `vector`s and
    `deque`s.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 构造和访问成员对 `vector` 和 `deque` 来说是相同的操作。
- en: Because the internal structure of `deque` is complex, it doesn’t expose a `data`
    method. In exchange, you gain access to `push_front` and `emplace_front`, which
    mirror the `push_back` and `emplace_back` that you’re familiar with from `vector`.
    [Listing 13-17](ch13.xhtml#ch13ex17) illustrates how to use `push_back` and `push_front`
    to insert values into a `deque` of `char`s.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `deque` 的内部结构复杂，它没有暴露 `data` 方法。作为交换，你可以访问 `push_front` 和 `emplace_front`，它们与
    `vector` 中你熟悉的 `push_back` 和 `emplace_back` 相对应。[Listing 13-17](ch13.xhtml#ch13ex17)
    展示了如何使用 `push_back` 和 `push_front` 向 `deque` 中插入 `char` 类型的值。
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 13-17: A `deque` supports `push_front` and `push_back`.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-17：`deque` 支持 `push_front` 和 `push_back`。*'
- en: After constructing an empty `deque`, you push alternating letters to the front
    ➊ and back ➋ of the `deque` so it contains the elements `c`, `a`, `i`, and `n`
    ➌.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个空的 `deque` 后，你将交替的字母推送到 `deque` 的前端 ➊ 和后端 ➋，使其包含元素 `c`、`a`、`i` 和 `n` ➌。
- en: '**NOTE**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It would be a very bad idea to attempt to extract a string here, for example,
    `&deckard[0]`, because `deque` makes no guarantees about internal layout.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*例如，尝试提取一个字符串，如 `&deckard[0]`，将是一个非常糟糕的主意，因为 `deque` 对内部布局没有任何保证。*'
- en: 'The `vector` methods not implemented by `deque`, along with an explanation
    for their absence, are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque` 没有实现的 `vector` 方法及其缺失的解释如下：'
- en: '**`capacity`, `reserve`** Because the internal structure is complicated, it
    might not be efficient to compute capacity. Also, `deque` allocations are relatively
    fast because a `deque` doesn’t relocate existing elements, so reserving memory
    ahead of time is unnecessary.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**`capacity`, `reserve`** 由于内部结构复杂，计算容量可能效率不高。而且，`deque` 的分配相对较快，因为 `deque`
    不会重新定位现有元素，因此不需要提前预留内存。'
- en: '**`data`** The elements of `deque` are not contiguous.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**`data`** `deque` 的元素不是连续存储的。'
- en: '[Table 13-3](ch13.xhtml#ch13tab03) summarizes the additional operators offered
    by a `deque` but not by a `vector`. In this table, `d` is of type `std::deque<T>`
    and `t` is of type `T`. An asterisk (*) indicates that this operation invalidates
    iterators to `v`’s elements in at least some circumstances. (Pointers to existing
    elements remain valid.)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-3](ch13.xhtml#ch13tab03) 总结了 `deque` 提供的额外运算符，而 `vector` 没有。在该表中，`d`
    的类型是 `std::deque<T>`，`t` 的类型是 `T`。星号（*）表示在某些情况下，此操作会使迭代器失效，指向 `v` 元素的迭代器失效。（指向现有元素的指针保持有效。）'
- en: '**Table 13-3:** A Partial List of `std::deque` Operations'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-3：** `std::deque` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| d`.emplace_front(`...`)` | Constructs an element in place at the front of
    the d by forwarding all arguments to the appropriate constructor.* |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| d`.emplace_front(`...`)` | 通过将所有参数转发给适当的构造函数，在 d 的前端原地构造一个元素。* |'
- en: '| d`.push_front(`t`)` | Constructs an element in place at the front of the
    d by copying t.* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| d`.push_front(`t`)` | 通过复制 t 在 d 的前端原地构造一个元素。* |'
- en: '| d`.pop_front()` | Removes the element at the front of d.* |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| d`.pop_front()` | 移除 d 的前端元素。* |'
- en: '**List**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**List**'
- en: A *list* is a sequence container with fast insert/remove operations everywhere
    but with no random element access. The STL implementation `std::list` is available
    from the `<list>` header.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*list* 是一种序列容器，具有快速的插入/删除操作，但不支持随机访问元素。STL 实现的 `std::list` 可以通过 `<list>` 头文件使用。'
- en: '**NOTE**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::list` in the
    `<boost/container/list.hpp>` header.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了 `<boost/container/list.hpp>` 头文件中的 `boost::container::list`。*'
- en: The `list` is implemented as a doubly linked list, a data structure composed
    of *nodes*. Each node contains an element, a forward link (“flink”), and a backward
    link (“blink”). This is completely different from a `vector`, which stores elements
    in contiguous memory. As a result, you cannot use `operator[]` or `at` to access
    arbitrary elements in a `list`, because such operations would be very inefficient.
    (These methods are simply not available in `list` because of their horrible performance
    characteristics.) The trade-off is that inserting and removing elements in a `list`
    is much faster. All you need to update are the flinks and blinks of an element’s
    neighbors rather than shuffling potentially large, contiguous element ranges.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 实现为双向链表，这是一种由 *节点* 组成的数据结构。每个节点包含一个元素、一个前向链接（“flink”）和一个后向链接（“blink”）。这与
    `vector` 完全不同，后者将元素存储在连续的内存中。因此，你不能使用 `operator[]` 或 `at` 来访问 `list` 中的任意元素，因为这些操作效率非常低。（这些方法在
    `list` 中根本不可用，因为它们的性能表现非常差。）其权衡是，在 `list` 中插入和移除元素的速度要快得多。你只需要更新元素邻居的 flinks 和
    blinks，而不需要移动可能很大的连续元素范围。'
- en: The `list` container supports the same constructor patterns as `vector`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 容器支持与 `vector` 相同的构造函数模式。 |'
- en: You can perform special operations on lists, such as splicing elements from
    one list into another using the `splice` method, removing consecutive duplicate
    elements using the `unique` method, and even sorting the elements of a container
    using the `sort` method. Consider, for example, the `remove_if` method. The `remove_if`
    method accepts a function object as a parameter, and it traverses the `list` while
    invoking the function object on each element. If the result is `true`, `remove_if`
    removes the element. [Listing 13-18](ch13.xhtml#ch13ex18) illustrates how to use
    the `remove_if` method to eliminate all the even numbers of a `list` with a lambda
    predicate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对列表执行特殊操作，例如使用 `splice` 方法将元素从一个列表拼接到另一个列表，使用 `unique` 方法移除连续的重复元素，甚至使用 `sort`
    方法对容器中的元素进行排序。例如，考虑 `remove_if` 方法。`remove_if` 方法接受一个函数对象作为参数，并在遍历 `list` 时对每个元素调用该函数对象。如果返回
    `true`，`remove_if` 就会移除该元素。[Listing 13-18](ch13.xhtml#ch13ex18) 说明了如何使用 `remove_if`
    方法通过 lambda 谓词删除 `list` 中的所有偶数。
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-18: A `list` supports `remove_if`.*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-18：`list` 支持 `remove_if`。*'
- en: Here, you use braced initialization to fill a `list` of `int` objects ➊. Next,
    you use the `remove_if` method to remove all the even numbers ➋. Because only
    even numbers modulo 2 equal zero, this lambda tests whether a number is even.
    To establish that `remove_if` has extracted the even elements 22 and 44, you create
    an iterator pointing at the beginning of the list ➌, check its value ➍, and increment
    ➎ until you reach the end of the list ➏.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，你使用大括号初始化填充 `int` 类型对象的 `list` ➊。接下来，你使用 `remove_if` 方法移除所有偶数 ➋。因为只有偶数对 2
    取余为零，所以这个 lambda 表达式用来测试一个数字是否是偶数。为了验证 `remove_if` 已经移除偶数元素 22 和 44，你创建一个指向列表开头的迭代器
    ➌，检查其值 ➍，并递增 ➎，直到达到列表末尾 ➏。
- en: 'All the `vector` methods not implemented by `list`, along with an explanation
    for their absence, are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `vector` 方法在 `list` 中没有实现，以及它们未实现的解释如下： |
- en: '**`capacity`, `reserve`, `shrink_to_fit`** Because `list` acquires memory incrementally,
    it doesn’t require periodic resizing.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**`capacity`, `reserve`, `shrink_to_fit`** 由于 `list` 是增量地分配内存，因此不需要定期调整大小。
    |'
- en: '**`operator[]`, `at`** Random element access is prohibitively expensive on
    `list`s.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**`operator[]`, `at`** 在 `list` 上随机访问元素代价昂贵。 |'
- en: '**`data`** Unneeded because `list` elements are not contiguous.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**`data`** 不需要，因为 `list` 元素不是连续存储的。 |'
- en: '[Table 13-4](ch13.xhtml#ch13tab04) summarizes the additional operators offered
    by a `list` but not by a `vector`. In this table, `lst`, `lst1`, and `lst2` are
    of type `std::list<T>`, and `t` is of type `T`. The arguments `itr1`, `itr2a`,
    and `itr2b` are `list` iterators. An asterisk (*) indicates that the operation
    invalidates iterators to `v`’s elements in at least some circumstances. (Pointers
    to existing elements remain valid.)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-4](ch13.xhtml#ch13tab04) 总结了 `list` 提供但 `vector` 不提供的额外操作符。在此表中，`lst`、`lst1`
    和 `lst2` 是 `std::list<T>` 类型，`t` 是 `T` 类型。`itr1`、`itr2a` 和 `itr2b` 是 `list` 迭代器。星号
    (*) 表示在某些情况下，该操作会使指向 `v` 元素的迭代器无效。（指向现有元素的指针仍然有效。） |'
- en: '**Table 13-4:** A Partial List of `std::list` Operations'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-4：** `std::list` 操作的部分列表 |'
- en: '| **Operation** | **Notes** |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| lst`.emplace_front(`...`)` | Constructs an element in place at the front
    of the `d` by forwarding all arguments to the appropriate constructor. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| lst`.emplace_front(`...`)` | 通过将所有参数转发给相应的构造函数，在 `d` 的前端构造一个元素。 |'
- en: '| lst`.push_front(`t`)` | Constructs an element in place at the front of d
    by copying t. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| lst`.push_front(`t`)` | 通过复制 t 在 d 的前端构造一个元素。 |'
- en: '| lst`.pop_front()` | Removes the element at the front of d. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| lst`.pop_front()` | 移除 d 中位于前端的元素。 |'
- en: '| lst`.push_back(`t`)` | Constructs an element in place at the back of d by
    copying t. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| lst`.push_back(`t`)` | 通过复制 t 在 d 的末尾构造一个元素。 |'
- en: '| lst`.pop_back()` | Removes the element at the back of d. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| lst`.pop_back()` | 移除 d 中位于末尾的元素。 |'
- en: '| lst1`.splice(`itr1`,`lst2`,` [itr2a]`,` [itr2b]`)` | Transfers items from
    lst2 into lst1 at position itr1. Optionally, only transfer the element at itr2a
    or the elements within the half-open range itr2a to itr2b. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| lst1`.splice(`itr1`,`lst2`,` [itr2a]`,` [itr2b]`)` | 将 lst2 中的元素转移到 lst1
    中的 itr1 位置。可选地，只转移 itr2a 处的元素或从 itr2a 到 itr2b 半开区间内的元素。 |'
- en: '|  lst`.remove(`t`)`  | Removes all elements in lst equal to t. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| lst`.remove(`t`)` | 移除 lst 中所有等于 t 的元素。 |'
- en: '| lst`.remove_if(`pred`)` | Eliminates elements in lst where pred returns true;
    pred accepts a single T argument. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| lst`.remove_if(`pred`)` | 删除 lst 中符合 pred 条件的元素；pred 接受一个类型为 T 的单一参数。 |'
- en: '| lst`.unique(`pred`)` | Eliminates duplicate consecutive elements in lst according
    to the function object pred, which accepts two T arguments and returns t1 `==`
    t2. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| lst`.unique(`pred`)` | 根据函数对象pred消除lst中相邻重复的元素，pred接受两个T类型参数并返回t1 `==` t2。
    |'
- en: '| lst1`.merge(`lst2`,` comp`)` | Merges lst1 and lst2 according to the function
    object comp, which accepts two T arguments and returns t1 `<` t2. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| lst1`.merge(`lst2`,` comp`)` | 根据函数对象comp将lst1和lst2合并，comp接受两个T类型参数并返回t1
    `<` t2。 |'
- en: '| lst`.sort(`comp`)` | Sorts lst according to the function object comp. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| lst`.sort(`comp`)` | 根据函数对象comp对lst进行排序。 |'
- en: '| lst`.reverse()` | Reverses the order of lst’s elements (mutates lst). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| lst`.reverse()` | 反转lst中元素的顺序（会改变lst）。 |'
- en: '**NOTE**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STL also offers a `std::forward_list` in the `<forward_list>` header,
    which is a singly linked list that only allows iteration in one direction. The
    `forward_list` is slightly more efficient than `list`, and it’s optimized for
    situations in which you need to store very few (or no) elements.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*STL还在`<forward_list>`头文件中提供了`std::forward_list`，它是一个单向链表，只允许朝一个方向遍历。`forward_list`比`list`稍微高效，且在需要存储极少量（或没有）元素的情况下进行了优化。*'
- en: '**Stacks**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈**'
- en: The STL provides three *container adapters* that encapsulate other STL containers
    and expose special interfaces for tailored situations. The adapters are the stack,
    the queue, and the priority queue.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了三种*容器适配器*，它们封装了其他STL容器，并为特定情况暴露了特殊接口。这些适配器分别是栈（stack）、队列（queue）和优先队列（priority
    queue）。
- en: 'A *stack* is a data structure with two fundamental operations: push and pop.
    When you *push* an element onto a stack, you insert the element onto the stack’s
    end. When you *pop* an element off a stack, you remove the element from the stack’s
    end. This arrangement is called *last-in*, *first-out*: the last element to be
    pushed onto a stack is the first to be popped off.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*（stack）是一种具有两种基本操作的数据结构：压栈（push）和弹栈（pop）。当你将一个元素压入栈中时，你将该元素插入到栈的末端。当你从栈中弹出一个元素时，你将元素从栈的末端移除。这个排列方式叫做*后进先出*（last-in,
    first-out）：最后被压入栈的元素是第一个被弹出的元素。'
- en: The STL offers the `std::stack` in the `<stack>` header. The class template
    `stack` takes two template parameters. The first is the underlying type of the
    wrapped container, such as `int`, and the second is the type of the wrapped container,
    such as `deque` or `vector`. This second argument is optional and defaults to
    `deque`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: STL在`<stack>`头文件中提供了`std::stack`。类模板`stack`有两个模板参数，第一个是被封装容器的底层类型，例如`int`，第二个是被封装容器的类型，例如`deque`或`vector`。第二个参数是可选的，默认值为`deque`。
- en: To construct a `stack`, you can pass a reference to a `deque`, a `vector`, or
    a `list` to encapsulate. This way, the `stack` translates its operations, such
    as `push` and `pop`, into methods that the underlying container understands, like
    `push_back` and `pop_back`. If you provide no constructor argument, the `stack`
    uses a `deque` by default. The second template parameter must match this container’s
    type.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个`stack`，你可以传递一个`deque`、`vector`或`list`的引用来封装。这样，`stack`会将其操作，如`push`和`pop`，转换为底层容器能够理解的方法，比如`push_back`和`pop_back`。如果没有提供构造函数参数，`stack`默认使用`deque`。第二个模板参数必须与此容器的类型匹配。
- en: To obtain a reference to the element on top of a `stack`, you use the `top`
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`stack`顶部元素的引用，可以使用`top`方法。
- en: '[Listing 13-19](ch13.xhtml#ch13ex19) illustrates how to use a `stack` to wrap
    a `vector`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-19](ch13.xhtml#ch13ex19)演示了如何使用`stack`来封装`vector`。'
- en: '[PRE18]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-19: Using a `stack` to wrap a `vector`*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-19：使用`stack`封装`vector`*'
- en: You construct a `vector` of `int`s called `vec` containing the elements 1 and
    3 ➊. Next, you pass `vec` into the constructor of a new `stack`, making sure to
    supply the second template parameter `decltype(vec)` ➋. The top element in `stack`
    is now 3, because this is the last element in `vec` ➌. After the first `pop` ➍,
    you push a new element 2 onto the `stack` ➎. Now, the `top` element is 2 ➏. After
    another `pop`-`top`-`pop` series, the `stack` is empty ➐.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个名为`vec`的`int`类型的`vector`，其中包含元素1和3 ➊。接着，你将`vec`传入新`stack`的构造函数，并确保提供第二个模板参数`decltype(vec)`
    ➋。`stack`中的顶部元素现在是3，因为这是`vec`中的最后一个元素 ➌。在第一次`pop`之后 ➍，你将新元素2压入`stack` ➎。此时，`top`元素是2
    ➏。经过另一次`pop`-`top`-`pop`的操作后，`stack`为空 ➐。
- en: '[Table 13-5](ch13.xhtml#ch13tab05) summarizes the operations of `stack`. In
    this table, `s`, `s1`, and `s2` are of type `std::stack<T>`; `t` is of type `T`;
    and `ctr` is a container of type `ctr_type<T>`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-5](ch13.xhtml#ch13tab05)总结了`stack`的操作。在此表中，`s`、`s1`和`s2`的类型为`std::stack<T>`；`t`的类型为`T`；`ctr`是类型为`ctr_type<T>`的容器。'
- en: '**Table 13-5:** A Summary of `std::stack` Operations'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-5：** `std::stack`操作概述'
- en: '| **Operation** | **Notes** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `stack<`T, `[`ctr_type<T>`]>([`ctr`])` | Constructs a stack of Ts using ctr
    as its internal container reference. If no container is provided, constructs an
    empty deque. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `stack<`T, `[`ctr_type<T>`]>([`ctr`])` | 使用ctr作为内部容器引用构造T类型的栈。如果没有提供容器，则构造一个空的deque。
    |'
- en: '| s`.empty()` | Returns `true` if container is empty. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| s`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| s`.size()` | Returns number of elements in container. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| s`.size()` | 返回容器中元素的数量。 |'
- en: '| s`.top()` | Returns a reference to the element on top of the `stack`. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| s`.top()` | 返回`stack`顶部元素的引用。 |'
- en: '| s`.push(t)` | Puts a copy of t onto the end of the container. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| s`.push(t)` | 将t的副本放入容器末尾。 |'
- en: '| s`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| s`.emplace(`...`)` | 通过转发...到适当的构造函数，在原地构造一个T。 |'
- en: '| s`.pop()` | Removes the element at the end of the container. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| s`.pop()` | 移除容器末尾的元素。 |'
- en: '| s1`.swap(`s2`)``swap(`s1`,` s2`)` | Exchanges the contents of s2 with s1.
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| s1`.swap(`s2`)``swap(`s1`,`s2`)` | 交换s1和s2的内容。 |'
- en: '**Queues**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**队列**'
- en: A *queue* is a data structure that, like a stack, has push and pop as its fundamental
    operations. Unlike a stack, a queue is *first-in*, *first-out*. When you push
    an element into a queue, you insert onto the queue’s end. When you pop an element
    off the queue, you remove from the queue’s beginning. This way, the element that
    has been in the queue the longest is the one to get popped off.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是一种数据结构，像栈一样，它的基本操作是推入（push）和弹出（pop）。与栈不同，队列是*先进先出*（first-in, first-out）。当你将一个元素推入队列时，你是将元素插入队列的末尾。当你弹出一个元素时，你是从队列的开头移除元素。这样，在队列中待得最久的元素就是最先被弹出的元素。'
- en: The STL offers the `std::queue` in the `<queue>` header. Like `stack`, `queue`
    takes two template parameters. The first parameter is the underlying type of the
    wrapped container, and the optional second parameter is the type of the wrapped
    container, which also defaults to `deque`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::queue`，它位于`<queue>`头文件中。像`stack`一样，`queue`接受两个模板参数。第一个参数是被包装容器的底层类型，第二个参数是被包装容器的类型，默认为`deque`。
- en: Among STL containers, you can only use `deque` or `list` as the underlying container
    for a `queue`, because pushing and popping from the front of a `vector` is inefficient.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL容器中，你只能使用`deque`或`list`作为`queue`的底层容器，因为从`vector`的前端推入和弹出元素效率较低。
- en: You can access the element at the front or back of a queue using the `front`
    and `back` methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`front`和`back`方法访问队列前端或后端的元素。
- en: '[Listing 13-20](ch13.xhtml#ch13ex20) shows how to use a `queue` to wrap a `deque`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-20](ch13.xhtml#ch13ex20)展示了如何使用`queue`来包装`deque`。'
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-20: Using a `queue` to wrap a `deque`*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-20: 使用`queue`包装`deque`*'
- en: You start with a `deque` containing the elements 1 and 2 ➊, which you pass into
    a queue called `easy_as` ➋. Using the `front` and `back` methods, you can validate
    that the queue begins with a 1 ➌ and ends with a 2 ➍. When you `pop` the first
    element, 1, you’re left with a queue containing just the single element 2 ➎. You
    then `push` 3 ➏, so the method `front` yields 2 ➐ and `back` yields 3 ➑. After
    two more iterations of `pop`-`front`, you’re left with an empty `queue` ➒.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个包含元素1和2的`deque`开始 ➊，并将其传入一个名为`easy_as`的队列 ➋。使用`front`和`back`方法，你可以验证队列的开头是1
    ➌，结尾是2 ➍。当你弹出第一个元素1时，队列中只剩下单一元素2 ➎。然后你将3推入队列 ➏，此时`front`方法返回2 ➐，`back`方法返回3 ➑。再进行两次`pop`-`front`操作后，队列为空
    ➒。
- en: '[Table 13-6](ch13.xhtml#ch13tab06) summarizes the operations of `queue`. In
    this table, `q`, `q1`, and `q2` are of type `std::queue<T>`; `t` is of type `T`;
    and `ctr` is a container of type `ctr_type<T>`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-6](ch13.xhtml#ch13tab06)总结了`queue`的操作。在这张表中，`q`、`q1`和`q2`是`std::queue<T>`类型；`t`是`T`类型；`ctr`是`ctr_type<T>`类型的容器。'
- en: '**Table 13-6:** A Summary of `std::queue` Operations'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-6：** `std::queue`操作概述'
- en: '| **Operation** | **Notes** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `queue<`T`, [`ctr_type<T>`]>([`ctr`])` | Constructs a queue of Ts using ctr
    as its internal container. If no container is provided, constructs an empty `deque`.
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `queue<`T`, [`ctr_type<T>`]>([`ctr`])` | 使用ctr作为内部容器构造T类型的队列。如果没有提供容器，则构造一个空的`deque`。
    |'
- en: '| q`.empty()` | Returns `true` if container is empty. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| q`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| q`.size()` | Returns number of elements in container. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| q`.size()` | 返回容器中元素的数量。 |'
- en: '|  q`.front()`  | Returns a reference to the element in front of the `queue`.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  q`.front()`  | 返回队列前端元素的引用。 |'
- en: '| q`.back()` | Returns a reference to the element in back of the `queue`. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| q`.back()` | 返回 `queue` 中最后一个元素的引用。 |'
- en: '| q`.push(`t`)` | Puts a copy of t onto the end of the container. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| q`.push(`t`)` | 将 t 的副本放到容器的末尾。 |'
- en: '| q`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| q`.emplace(`...`)` | 通过转发 ... 到适当的构造函数，原地构造一个 T。 |'
- en: '| q`.pop()` | Removes the element at the front of the container. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| q`.pop()` | 移除容器中前面的元素。 |'
- en: '| q1`.swap(`q2`)` `swap(`q1`,` q2`)` | Exchanges the contents of q2 with q1.
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| q1`.swap(`q2`)` `swap(`q1`,` q2`)` | 交换 q2 和 q1 的内容。 |'
- en: '**Priority Queues (Heaps)**'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**优先队列（堆）**'
- en: A *priority queue* (also called a heap) is a data structure that supports `push`
    and `pop` operations and keeps elements sorted according to some user-specified
    *comparator object*. The comparator object is a function object invokable with
    two parameters, returning `true` if the first argument is less than the second.
    When you `pop` an element from a priority queue, you remove the element that is
    greatest, according to the comparator object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列*（也叫堆）是一种支持 `push` 和 `pop` 操作的数据结构，它根据某个用户指定的 *比较器对象* 对元素进行排序。比较器对象是一个函数对象，接受两个参数，并在第一个参数小于第二个参数时返回
    `true`。当你从优先队列中 `pop` 一个元素时，你会移除根据比较器对象确定的最大元素。'
- en: 'The STL offers the `std::priority_queue` in the `<queue>` header. A `priority_queue`
    has three template parameters:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了 `<queue>` 头文件中的 `std::priority_queue`。`priority_queue` 有三个模板参数：
- en: The underlying type of the wrapped container
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装容器的底层类型
- en: The type of the wrapped container
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装容器的类型
- en: The type of the comparator object
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较器对象的类型
- en: Only the underlying type is mandatory. The wrapped container type defaults to
    `vector` (probably because it’s the most widely used sequential container), and
    the comparator object type defaults to `std::less`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 只有底层类型是必需的。包装容器类型默认为 `vector`（可能因为它是最常用的顺序容器），比较器对象类型默认为 `std::less`。
- en: '**NOTE**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `std::less` class template is available from the `<functional>` header,
    and it returns `true` if the first argument is less than the second.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*`std::less` 类模板可在 `<functional>` 头文件中找到，如果第一个参数小于第二个参数，则返回 `true`。*'
- en: The `priority_queue` has an identical interface to a `stack`. The only difference
    is that stacks `pop` elements according to the last-in, first-out arrangement,
    whereas priority queues `pop` elements according to the comparator object criteria.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority_queue` 的接口与 `stack` 相同。唯一的区别是栈按照后进先出的顺序 `pop` 元素，而优先队列则根据比较器对象的标准来
    `pop` 元素。'
- en: '[Listing 13-21](ch13.xhtml#ch13ex21) illustrates the basic usage of `priority_queue`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-21](ch13.xhtml#ch13ex21) 展示了 `priority_queue` 的基本用法。'
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-21: Basic `priority_queue` usage*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-21：`priority_queue` 的基本用法*'
- en: Here, you default construct a `priority_queue` ➊, which internally initializes
    an empty `vector` to hold its elements. You push the elements 1.0, 2.0, and 1.5
    into the `priority_queue`, which sorts the elements in descending order so the
    container represents them in the order 2.0 1.5 1.0.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造一个 `priority_queue` ➊，它内部初始化一个空的 `vector` 来存储元素。你将元素 1.0、2.0 和 1.5
    推入 `priority_queue`，它会按降序对元素进行排序，因此容器中的元素顺序是 2.0 1.5 1.0。
- en: You assert that `top` yields 2.0 ➋, pop this element off the `priority_queue`,
    and then invoke `push` with the new element 1.0\. The container now represents
    them in the order 1.5 ➌ 1.0 ➍ 1.0 ➎, which you verify with a series of `top`-`pop`
    operations until the container is empty ➏.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你确认 `top` 返回的是 2.0 ➋，然后从 `priority_queue` 中移除该元素，再用新元素 1.0 调用 `push`。此时容器中的元素顺序变为
    1.5 ➌ 1.0 ➍ 1.0 ➎，你通过一系列的 `top` 和 `pop` 操作验证这一点，直到容器为空 ➏。
- en: '**NOTE**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A `priority_queue` holds its elements in a tree structure, so if you peered
    into its underlying container, the memory ordering wouldn’t match the orders implied
    by [Listing 13-21](ch13.xhtml#ch13ex21).*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*`priority_queue` 将其元素存储在树结构中，因此如果你查看其底层容器，内存顺序将与 [清单 13-21](ch13.xhtml#ch13ex21)
    所示的顺序不匹配。*'
- en: '[Table 13-7](ch13.xhtml#ch13tab07) summarizes the operations of `priority_queue`.
    In this table, `pq`, `pq1`, and `pq2` are of type `std::priority_queue<T>`; `t`
    is of type `T`; `ctr` is a container of type `ctr_type<T>`; and `srt` is a container
    of type `srt_type<T>`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-7](ch13.xhtml#ch13tab07) 总结了 `priority_queue` 的操作。在此表中，`pq`、`pq1` 和 `pq2`
    的类型是 `std::priority_queue<T>`；`t` 的类型是 `T`；`ctr` 是类型为 `ctr_type<T>` 的容器；`srt`
    是类型为 `srt_type<T>` 的容器。'
- en: '**Table 13-7:** A Summary of `std::priority_queue` Operations'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-7：** `std::priority_queue` 操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `priority_queue <`T`,` `[`ctr_type<T>`],` `[`cmp_type`]>([`cmp`], [`ctr`])`
    | Constructs a `priority_queue` of Ts using ctr as its internal container and
    srt as its comparator object. If no container is provided, constructs an empty
    `deque`. Uses `std::less` as default sorter. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `priority_queue <`T`,` `[`ctr_type<T>`],` `[`cmp_type`]>([`cmp`], [`ctr`])`
    | 使用`ctr`作为内部容器，`srt`作为比较器对象，构造一个`priority_queue`。如果没有提供容器，则构造一个空的`deque`，并默认使用`std::less`作为排序器。
    |'
- en: '| pq`.empty()` | Returns `true` if container is empty. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| pq`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| pq`.size()` | Returns number of elements in container. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| pq`.size()` | 返回容器中的元素数量。 |'
- en: '| pq`.top()` | Returns a reference to the greatest element in the container.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| pq`.top()` | 返回容器中最大元素的引用。 |'
- en: '| pq`.push(`t`)` | Puts a copy of t onto the end of the container. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| pq`.push(`t`)` | 将t的副本放到容器的末尾。 |'
- en: '| pq`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| pq`.emplace(`...`)` | 通过转发...到适当的构造函数来原地构造一个T。 |'
- en: '| pq`.pop()` | Removes the element at the end of the container. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| pq`.pop()` | 移除容器末尾的元素。 |'
- en: '| pq1`.swap(`pq2`) swap(`pq1`,` pq2`)` | Exchanges the contents of s2 with
    s1. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| pq1`.swap(`pq2`) swap(`pq1`,` pq2`)` | 交换s2和s1的内容。 |'
- en: '**Bitsets**'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bitsets**'
- en: A *bitset* is a data structure that stores a fixed-size bit sequence. You can
    manipulate each bit.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*bitset*是一种存储固定大小位序列的数据结构。你可以操作每一位。'
- en: The STL offers the `std::bitset` in the `<bitset>` header. The class template
    `bitset` takes a single template parameter corresponding to the desired size.
    You could achieve similar functionality using a `bool array`, but `bitset` is
    optimized for space efficiency and provides some special convenience operations.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::bitset`，位于`<bitset>`头文件中。类模板`bitset`接受一个对应所需大小的单一模板参数。你也可以使用`bool数组`实现类似的功能，但`bitset`在空间效率上进行了优化，并提供了一些特殊的便捷操作。
- en: '**NOTE**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STL specializes `std::vector<bool>`, so it might benefit from the same
    space efficiencies as `bitset`. (Recall from “Template Specialization” on [page
    178](ch06.xhtml#page_178) that template specialization is the process of making
    certain kinds of template instantiations more efficient.) Boost offers `boost::dynamic_bitset`,
    which provides dynamic sizing at runtime.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*STL专门化了`std::vector<bool>`，因此它可能像`bitset`一样从相同的空间效率中受益。（回想一下在[第178页](ch06.xhtml#page_178)的“模板特化”中提到的，模板特化是使某些类型的模板实例化更加高效的过程。）Boost提供了`boost::dynamic_bitset`，它在运行时提供动态大小。*'
- en: A default constructed `bitset` contains all zero (false) bits. To initialize
    bitsets with other contents, you can provide an `unsigned long long` value. This
    integer’s bitwise representation sets the value of `bitset`. You can access individual
    bits in the `bitset` using `operator[]`. [Listing 13-22](ch13.xhtml#ch13ex22)
    demonstrates how to initialize a `bitset` with an integer literal and extract
    its elements.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的`bitset`包含所有零（假）位。要初始化具有其他内容的`bitset`，你可以提供一个`unsigned long long`值。该整数的按位表示设置`bitset`的值。你可以使用`operator[]`访问`bitset`中的单个位。[列表13-22](ch13.xhtml#ch13ex22)展示了如何用整数字面量初始化`bitset`并提取其元素。
- en: '[PRE21]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-22: Initializing a `bitset` with an integer*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-22：使用整数初始化`bitset`*'
- en: You initialize a `bitset` with the 4-bit *nybble* `0101` ➊. So, the first ➋
    and third ➍ elements are zero, and the second ➌ and fourth ➎ elements are 1.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你用4位*nybble* `0101` ➊初始化一个`bitset`。因此，第一 ➋ 和第三 ➍ 个元素为零，第二 ➌ 和第四 ➎ 个元素为1。
- en: You can also provide a string representation of the desired `bitset`, as shown
    in [Listing 13-23](ch13.xhtml#ch13ex23).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个字符串表示所需的`bitset`，如[列表13-23](ch13.xhtml#ch13ex23)所示。
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-23: Initializing a `bitset` with a string*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-23：使用字符串初始化`bitset`*'
- en: Here, you construct a `bitset` called `bs1` using the same integer nybble `0b0110`
    ➊ and another `bitset` called `bs2` using the string literal `0110` ➋. Both of
    these initialization approaches produce identical `bitset` objects ➌.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用相同的整数nybble `0b0110` ➊构造一个名为`bs1`的`bitset`，并使用字符串字面量`0110` ➋构造另一个名为`bs2`的`bitset`。这两种初始化方式生成相同的`bitset`对象
    ➌。
- en: '[Table 13-8](ch13.xhtml#ch13tab08) summarizes the operations of `bitset`. In
    this table, `bs`, `bs 1`, and `bs 2` are of type `std::bitset<N>`, and `i` is
    a `size_t`.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-8](ch13.xhtml#ch13tab08)总结了`bitset`的操作。在此表中，`bs`、`bs 1`和`bs 2`的类型为`std::bitset<N>`，而`i`是一个`size_t`。'
- en: '**Table 13-8:** A Summary of `std::bitset` Operations'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-8：** `std::bitset`操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `bitset<`N`>([`val`])` | Constructs a `bitset` with initial value val, which
    can be either a string of 0s and 1s or an `unsigned long long`. Default constructor
    initializes all bits to zero. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `bitset<`N`>([`val`])` | 构造一个初始值为val的`bitset`，其中val可以是由0和1组成的字符串或`unsigned
    long long`。默认构造函数将所有位初始化为零。 |'
- en: '| bs`[`i`]` | Returns the value of the i-th bit: 1 returns true; 0 returns
    false. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| bs`[`i`]` | 返回第i位的值：1返回true；0返回false。 |'
- en: '| bs`.test(`i`)` | Returns the value of the i-th bit: 1 returns true; 0 returns
    false. Performs bounds checking; throws `std::out_of_range`. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| bs`.test(`i`)` | 返回第i位的值：1返回true；0返回false。执行边界检查；抛出`std::out_of_range`异常。
    |'
- en: '| bs`.set()` | Sets all bits to 1. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| bs`.set()` | 将所有位设置为1。 |'
- en: '| bs`.set(`i`,` val`)` | Sets the i-th bit to val. Performs bounds checking;
    throws `std::out_of_range`. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| bs`.set(`i`,` val`)` | 将第i位设置为val。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.reset()` | Sets all bits to 0. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| bs`.reset()` | 将所有位设置为0。 |'
- en: '| bs`.reset(`i`)` | Sets the i-th bit to zero. Performs bounds checking; throws
    `std::out_of_range`. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| bs`.reset(`i`)` | 将第i位设置为零。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.flip()` | Flips all the bits: (0 becomes 1; 1 becomes 0). |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| bs`.flip()` | 翻转所有位：(0变为1；1变为0)。 |'
- en: '| bs`.flip(`i`)` | Flips the i-th bit. Performs bounds checking; throws `std::out_of_range`.
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| bs`.flip(`i`)` | 翻转第i位。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.count()` | Returns the number of bits set to 1. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| bs`.count()` | 返回设置为1的位数。 |'
- en: '| bs`.size()` | Returns the size N of the bitset. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| bs`.size()` | 返回`bitset`的大小N。 |'
- en: '| bs`.any()` | Returns `true` if any bits are set to 1. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| bs`.any()` | 如果任何位都设置为1，返回`true`。 |'
- en: '| bs`.none()` | Returns `true` if all bits are set to 0. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| bs`.none()` | 如果所有位都设置为0，返回`true`。 |'
- en: '| bs`.all()` | Returns `true` if all bits are set to 1. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| bs`.all()` | 如果所有位都设置为1，返回`true`。 |'
- en: '| bs`.to_string()` | Returns the `string` representation of the bitset. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_string()` | 返回`bitset`的`string`表示形式。 |'
- en: '| bs`.to_ulong()` | Returns the `unsigned long` representation of the bitset.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_ulong()` | 返回`bitset`的`unsigned long`表示形式。 |'
- en: '| bs`.to_ullong()` | Returns the `unsigned long long` representation of the
    bitset. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_ullong()` | 返回`bitset`的`unsigned long long`表示形式。 |'
- en: '**Special Sequential Boost Containers**'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**特殊顺序Boost容器**'
- en: Boost provides an abundance of special containers, and there simply isn’t enough
    room to explore all their features here. [Table 13-9](ch13.xhtml#ch13tab09) provides
    the names, headers, and brief descriptions of a number of them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Boost提供了大量的特殊容器，这里没有足够的空间来探讨它们的所有特性。[表13-9](ch13.xhtml#ch13tab09)提供了其中一些容器的名称、头文件和简要描述。
    |
- en: '**NOTE**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Refer to the Boost Container documentation for more information.*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参考Boost容器文档获取更多信息。*'
- en: '**Table 13-9:** Special Boost Containers'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-9：** 特殊Boost容器'
- en: '| **Class/Header** | **Description** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **类/头文件** | **描述** |'
- en: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | Intrusive containers impose
    requirements on the elements they contain (such as inheriting from a particular
    base class). In exchange, they offer substantial performance gains. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | 入侵式容器对它们所包含的元素有要求（例如，元素必须继承自某个基类）。作为交换，它们提供了显著的性能提升。
    |'
- en: '| `boost::container::stable_vector``<boost/container/stable_vector.hpp>` |
    A vector without contiguous elements but guarantees that iterators and references
    to elements remain valid as long as the element isn’t erased (as with `list`).
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::stable_vector``<boost/container/stable_vector.hpp>` |
    一个没有连续元素的向量，但保证只要元素未被删除（如同`list`一样），迭代器和对元素的引用将保持有效。 |'
- en: '| `boost::container::slist``<boost/container/slist.hpp>` | A `forward_list`
    with a fast `size` method. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::slist``<boost/container/slist.hpp>` | 一个带有快速`size`方法的`forward_list`。
    |'
- en: '| `boost::container::static_vector``<boost/container/static_vector.hpp>` |
    A hybrid between array and vector that stores a dynamic number of elements up
    to a fixed size. Elements are stored within the memory of `stable_vector`, like
    an `array`. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::static_vector``<boost/container/static_vector.hpp>` |
    介于数组和向量之间的混合容器，存储动态数量的元素，最多到固定大小。元素像`array`一样存储在`stable_vector`的内存中。 |'
- en: '| `boost::container::small_vector``<boost/container/small_vector.hpp>` | A
    `vector`-like container optimized for holding a small number of elements. Contains
    some preallocated space, avoiding dynamic allocation. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::small_vector``<boost/container/small_vector.hpp>` | 一种类似于`vector`的容器，优化用于存储少量元素。包含一些预分配的空间，避免动态分配。
    |'
- en: '| `boost::circular_buffer``<boost/circular_buffer.hpp>` | A fixed-capacity,
    queue-like container that fills elements in a circular fashion; a new element
    overwrites the oldest element once capacity is reached. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_array``<boost/multi_array.hpp>` | An array-like container that
    accepts multiple dimensions. Rather than having, for example, an array of arrays
    of arrays, you can specify a three-dimensional `multi_array` x that allows element
    access, such as x`[5][1][2]`. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `boost::ptr_vector``boost::ptr_list``<boost/ptr_container/*.hpp>` | Having
    a collection of smart pointers can be suboptimal. Pointer vectors manage a collection
    of dynamic objects in a more efficient and user-friendly way. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost Intrusive also contains some specialized containers that provide performance
    benefits in certain situations. These are primarily useful for library implementers.*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Associative Containers**'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Associative containers* allow for very fast element search. Sequential containers
    have some natural ordering that allows you to iterate from the beginning of the
    container to the end in a well-specified order. Associative containers are a bit
    different. This container family splits along three axes:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Whether elements contain keys (a set) or key-value pairs (a map)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether elements are ordered
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether keys are *unique*
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Sets***'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `std::set` available in the STL’s `<set>` header is an associative container
    that contains sorted, unique elements called *keys*. Because `set` stores sorted
    elements, you can insert, remove, and search efficiently. In addition, `set` supports
    sorted iteration over its elements, and you have complete control over how keys
    sort using comparator objects.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also provides a `boost::container::set` in the `<boost/container/set.hpp>`
    header.*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing**'
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The class template `set<T, Comparator, Allocator>` takes three template parameters:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The key type `T`
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comparator type that defaults to `std::less`
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The allocator type that defaults to `std::allocator<T>`
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have a lot of flexibility when constructing `set`s. Each of the following
    constructors accepts an optional comparator and allocator (whose types must match
    their corresponding template parameters):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor that initializes an empty `set`
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move and copy constructors with the usual behavior
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A range constructor that copies the elements from the range into the set
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A braced initializer
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 13-24](ch13.xhtml#ch13ex24) showcases each of these constructors.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-24: The constructors of a `set`*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: You default construct ➊ and brace initialize ➋ two different `set`s. The default
    constructed `set` called `emp` is empty ➌, and the braced initialized `set` called
    `fib` has four elements ➍. You include five elements in the braced initializer,
    so why only four elements? Recall that `set` elements are unique, so the 1 enters
    only once.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Next, you copy construct `fib`, which results in two `set`s with size 4 ➎ ➏.
    On the other hand, the move constructor empties the moved-from set ➐ and transfers
    the elements to the new `set` ➑.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Then you can initialize a `set` from a range. You construct an `array` with
    five elements and then pass it as a range to a `set` constructor using the `cbegin`
    and `cend` methods. As with the braced initialization earlier in the code, the
    `set` contains only four elements because duplicates are discarded ➒.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '**Move and Copy Semantics**'
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to move/copy constructors, move/copy assignment operators are also
    available. As with other container copy operations, `set` copies are potentially
    very slow because each element needs to get copied, and move operations are usually
    fast because elements reside in dynamic memory. A `set` can simply pass ownership
    without disturbing the elements.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '**Element Access**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You have several options for extracting elements from a `set`. The basic method
    is `find`, which takes a `const` reference to a key and returns an iterator. If
    the `set` contains an element-matching key, `find` will return an iterator pointing
    to the found element. If the `set` does not, it will return an iterator pointing
    to `end`. The `lower_bound` method returns an iterator to the first element *not
    less than* the key argument, whereas the `upper_bound` method returns the first
    element *greater than* the given key.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set` class supports two additional lookup methods, mainly for compatibility
    of non-unique associative containers:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The `count` method returns the number of elements matching the key. Because
    `set` elements are unique, `count` returns either 0 or 1.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equal_range` method returns a half-open range containing all the elements
    matching the given key. The range returns a `std::pair` of iterators with `first`
    pointing to the matching element and `second` pointing to the element after `first`.
    If `equal_range` finds no matching element, `first` and `second` both point to
    the first element greater than the given key. In other words, the pair returned
    by `equal_range` is equivalent to a `pair` of `lower_bound` as `first` and `upper_bound`
    as `second`.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 13-25](ch13.xhtml#ch13ex25) illustrates these two access methods.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-25: A `set` member access*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: First, you construct a `set` with the four elements 1 2 3 5 ➊. Using `find`,
    you can extract an iterator to the element 3\. You can also determine that 8 isn’t
    in the `set`, because `find` returns an iterator pointing to `end` ➋. You can
    determine similar information with `count`, which returns 1 when you give the
    key 3 and 0 when you give the key 8 ➌. When you pass 3 to the `lower_bound` method,
    it returns an iterator pointing to 3 because this is the first element that’s
    not less than the argument ➍. When you pass this to `upper_bound`, on the other
    hand, you obtain a pointer to the element 5, because this is the first element
    greater than the argument ➎. Finally, when you pass 3 to the `equal_range` method,
    you obtain a `pair` of iterators. The `first` iterator points to 3, and the `second`
    iterator points to 5, the element just after 3 ➏.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: A `set` also exposes iterators through its `begin` and `end` methods, so you
    can use range-based `for` loops to iterate through the `set` from least element
    to greatest.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Elements**'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have three options when adding elements to a `set`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '`insert` to copy an existing element into the `set`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to in-place construct a new element into the `set`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace_hint` to in-place construct a new element, just like `emplace` (because
    adding an element requires sorting). The difference is the `emplace_hint` method
    takes an iterator as its first argument. This iterator is the search’s starting
    point (a hint). If the iterator is close to the correct position for the newly
    inserted element, this can provide a substantial speedup.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 13-26](ch13.xhtml#ch13ex26) illustrates the several ways to insert
    elements into a `set`.'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 13-26: Inserting into a `set`*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Both `insert` ➊ and `emplace` ➋ add the element 8 into `fib`, so when you invoke
    `find` with 8, you get an iterator pointing to the new element. You can achieve
    the same effect a bit more efficiently with `emplace_hint` ➌. Because you know
    ahead of time that the new element 8 is greater than all the other elements in
    the `set`, you can use `end` as the hint.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to `insert`, `emplace`, or `emplace_hint` a key that’s already
    present in the `set`, the operation has no effect. All three of these methods
    return a `std::pair<Iterator, bool>` where the `second` element indicates whether
    the operation resulted in insertion (`true`) or not (`false`). The iterator at
    `first` points to either the newly inserted element or the existing element that
    prevented insertion.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing Elements**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can remove elements from a set using `erase`, which is overloaded to accept
    a key, an iterator, or a half-open range, as shown in [Listing 13-27](ch13.xhtml#ch13ex27).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 13-27: Removing from a `set`*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, you call `erase` with the key 3, which removes the corresponding
    element from the `set`. When you invoke `find` on 3, you get an iterator pointing
    to the `end`, indicating that no matching element was found ➊. In the second test,
    you invoke `clear`, which eliminates all the elements from the `set` ➋.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage Model**'
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Set operations are fast because sets are typically implemented as *red-black
    trees*. These structures treat each element as a node. Each node has one parent
    and up to two children, its left and right legs. Each node’s children are sorted
    so all children to the left are less than the children to the right. This way,
    you can perform searches much quicker than with linear iteration, as long as a
    tree’s branches are roughly balanced (equal in length). Red-black trees have additional
    facilities for rebalancing branches after insertions and deletions.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '*For details on red-black trees, refer to *Data Structures and Algorithms in
    C++* by Adam Drozdek.*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: "[Table 13-10](ch13.xhtml#ch13tab10) summarizes the operations of `set`. Operations\
    \ `s`, `s1`, and `s2` are of type `std::set<T,[cmp_type<T>]>`. `T` is the contained\
    \ element/key type, and `itr`, `beg`, and `end` are `set` iterators. The variable\
    \ `t` is a `T`. A dagger (\x86)denotes a method that returns a `std::pair<Iterator,\
    \ bool>`, where the iterator points to the resulting element and the `bool` equals\
    \ `true` if the method inserted an element and `false` if the element already\
    \ existed."
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-10:** A Summary of `std::set`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| `set<`T`>{` ...`, [`cmp`], [`alc`] }` | Performs braced initialization of
    a newly constructed set. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: '| `set<`T`>{` beg`,` end`,` `[`cmp`], [`alc`] }` | Range constructor that copies
    elements from the half-open range beg to end. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
- en: '| `set``<`T`>(`s`)` | Deep copy of s; allocates new memory. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
- en: '| `set<`T`>(move(`s`))` | Takes ownership of memory; elements in s. No allocations.
    |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
- en: '| `~set` | Destructs all elements contained by the set and releases dynamic
    memory. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
- en: '| s1 `=` s2 | s1 destructs its elements; copies each s2 element. Only allocates
    if it needs to resize to fit s2’s elements. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
- en: '| s1 `= move(`s2`)` | s1 destructs its elements; moves each s2 element. Only
    allocates if it needs to resize to fit s2’s elements. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
- en: '| s`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
- en: '| s`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
- en: '| s`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
- en: '| s`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
- en: '| s`.find(`t`)` | Returns an iterator pointing to the element matching t or
    s.`end()` if no such element exists. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '| s`.count(`t`)` | Returns 1 if set contains t; otherwise 0. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
- en: '| s`.equal_range(`t`)` | Returns a `pair` of iterators corresponding to the
    half-open range of elements matching t. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
- en: '| s`.lower_bound(`t`)` | Returns an iterator pointing to the first element
    not less than t or s.`end()` if no such element exists. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
- en: '| s`.upper_bound(`t`)` | Returns an iterator pointing to the first element
    greater than t or s.`end()` if no such element exists. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: '| s`.clear()` | Removes all elements from the set. |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '| s`.erase(`t`)` | Removes the element equal to t. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
- en: '| s`.erase(`itr`)` | Removes the element pointed to by itr. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '| s`.erase(`beg`,` end`)` | Removes all elements on the half-open range from
    beg to end. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: "| s`.insert(`t`)` | Inserts a copy of t into the set.\x86 |"
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: "| s`.emplace(`...`)` | Constructs a T in place by forwarding the arguments\
    \ ....\x86 |"
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: "| s`.emplace_hint(`itr`,` ...`)` | Constructs a T in place by forwarding the\
    \ arguments .... Uses itr as a hint for where to insert the new element.\x86 |"
  id: totrans-470
  prefs: []
  type: TYPE_TB
- en: '| s`.empty()` | Returns `true` if set’s size is zero; otherwise `false`. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '| s`.size()` | Returns the number of elements in the set. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| s`.max_size()` | Returns the maximum number of elements in the set. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| s`.extract(`t`)`s`.extract(`itr`)` | Obtains a node handle that owns the
    element matching t or pointed to by itr. (This is the only way to remove a move-only
    element.) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| s1`.merge(`s2`)`s1`.merge(move(`s2`))` | Splices each element of s2 into
    s1. If argument is an rvalue, will move the elements into s1. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '| s1`.swap(`s2`)``swap(`s1`,` s2`)` | Exchanges each element of s1 with those
    of s2. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '**Multisets**'
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `std::multiset` available in the STL’s `<set>` header is an associative
    container that contains sorted, *non-unique* keys. A `multiset` supports the same
    operations as a `set`, but it will store redundant elements. This has important
    ramifications for two methods:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The method `count` can return values other than 0 or 1\. The `count` method
    of `multiset` will tell you how many elements matched the given key.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `equal_range` can return half-open ranges containing more than one
    element. The `equal_range` method of `multiset` will return a range containing
    all the elements matching the given key.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might want to use a `multiset` rather than a `set` if it’s important that
    you store multiple elements with the same key. For example, you could store all
    of an address’s occupants by treating the address as a key and each member of
    the house as an element. If you used a `set`, you’d be stuck having only a single
    occupant.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-28](ch13.xhtml#ch13ex28) illustrates using a `multiset`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 13-28: Accessing `multiset` elements*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `set` in [Listing 13-24](ch13.xhtml#ch13ex24), `multiset` permits multiple
    1s, so size returns 5, the number of elements you provided in the braced initializers
    ➊. When you count the number of 1s, you get 2 ➋. You can use `equal_range` to
    iterate over these elements. Using structured binding syntax, you obtain a `begin`
    and `end` iterator ➌. You iterate over the two 1s ➍ ➎ and arrive at the end of
    the half-open range ➏.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Every operation in [Table 13-10](ch13.xhtml#ch13tab10) works for `multiset`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also provides a `boost::container::multiset` in the `<boost/container/set.hpp>`
    header.*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '***Unordered Sets***'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `std::unordered_set` available in the STL’s `<unordered_set>` header is
    an associative container that contains *unsorted*, unique keys. The `unordered_set`
    supports most of the same operations as `set` and `multiset`, but its internal
    storage model is completely different.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also provides a `boost::unordered_set` in the `<boost/unordered_set.hpp>`
    header.*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using a comparator to sort elements into a red-black tree, an `unordered_set`
    is usually implemented as a hash table. You might want to use an `unordered_set`
    in a situation in which there is no natural ordering among the keys and you don’t
    need to iterate through the collection in such an order. You might find that in
    many situations, you could use either a `set` or an `unordered_set`. Although
    they appear quite similar, their internal representations are fundamentally different,
    so they’ll have different performance characteristics. If performance is an issue,
    measure how both perform and use the one that’s more appropriate.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage Model: Hash Tables**'
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A hash function, or a *hasher*, is a function that accepts a key and returns
    a unique `size_t` value called a hash code. The `unordered_set` organizes its
    elements into a hash table, which associates a hash code with a collection of
    one or more elements called a *bucket*. To find an element, an `unordered_set`
    computes its hash code and then searches through the corresponding bucket in the
    hash table.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never seen a hash table before, this information might be a lot to
    take in, so let’s look at an example. Imagine you had a large group of people
    that you needed to sort into some kind of sensible groups to find an individual
    easily. You could group people by birthday, which would give you 365 groups (well,
    366 if you count February 29 for leap years). The birthday is like a hash function
    that returns one of 365 values for each person. Each value forms a bucket, and
    all people in the same bucket have the same birthday. In this example, to find
    a person, you first determine their birthday, which gives you the correct bucket.
    Then you can search through the bucket to find the person you’re looking for.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the hash function is quick and there aren’t too many elements per
    bucket, `unordered_set`s have even more impressive performance than their ordered
    counterparts: the contained element count doesn’t increase insertion, search,
    and deletion times. When two different keys have the same hash code, it’s called
    a *hash collision*. When you have a hash collision, it means that the two keys
    will reside in the same bucket. In the preceding birthday example, many people
    will have the same birthday, so there will be a lot of hash collisions. The more
    hash collisions there are, the larger the buckets will be, and the more time you’ll
    spend searching through a bucket for the correct element.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function has several requirements:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a `Key` and returns a `size_t` hash code.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t throw exceptions.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equal keys yield equal hash codes.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unequal keys yield unequal hash codes with high probability. (There is a low
    probability of a hash collision.)
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STL provides the hasher class template `std::hash<T>` in the `<functional>`
    header, which contains specializations for fundamental types, enumeration types,
    pointer types, `optional`, `variant`, smart pointers, and more. As an example,
    [Listing 13-29](ch13.xhtml#ch13ex29) illustrates how `std::hash<long>` meets the
    equivalence criteria.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 13-29: The `std::hash<long>` returns equal hash codes for equal keys
    and unequal hash codes for unequal keys.*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: You construct a hasher of type `std::hash<long>` ➊ and use it to compute the
    hash code of 42, storing the result into `size_t hash_code_42` ➋. When you invoke
    `hasher` with 42 again, you obtain the same value ➌. When you invoke hasher with
    `43` instead, you obtain a different value ➍.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Once an `unordered_set` hashes a key, it can obtain a bucket. Because the bucket
    is a list of possible matching elements, you need a function object that determines
    equality between a key and a bucket element. The STL provides the class template
    `std::equal_to<T>` in the `<functional>` header, which simply invokes `operator==`
    on its arguments, as [Listing 13-30](ch13.xhtml#ch13ex30) illustrates.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 13-30: The `std::equal_to<long>` calls `operator==` on its arguments
    to determine equality.*'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ve initialized an `equal_to<long>` called `long_equal_to` ➊. When
    you invoke `long_equal_to` with equal arguments, it returns `true` ➋. When you
    invoke it with unequal arguments, it returns `false` ➌.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '*For brevity, this chapter won’t cover implementing your own hashing and equivalence
    functions, which you’ll need if you want to construct unordered containers given
    user-defined key types. See [Chapter 7](ch07.xhtml#ch07) of *The C++ Standard
    Library*, 2nd Edition, by Nicolai Josuttis.*'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing**'
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The class template `std::unordered_set<T, Hash, KeyEqual, Allocator>` takes
    four template parameters:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Key type `T`
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Hash` hash function type, which defaults to `std::hash<T>`
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `KeyEqual` equality function type, which defaults to `std::equal_to<T>`
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Allocator` allocator type, which defaults to `std::allocator<T>`
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `unordered_set` supports equivalent constructors to `set` with adjustments
    for the different template parameters (`set` needs a `Comparator`, whereas `unordered_set`
    needs a `Hash` and a `KeyEqual`). For example, you can use `unordered_set` as
    a drop-in replacement for `set` in [Listing 13-24](ch13.xhtml#ch13ex24), because
    `unordered_set` has range constructors and copy/move constructors and supports
    braced initialization.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported set Operations**'
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An `unordered_set` supports all `set` operations in [Table 13-10](ch13.xhtml#ch13tab10)
    except for `lower_bound` and `upper_bound`, because `unordered_set` doesn’t sort
    its elements.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '**Bucket Management**'
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Generally, the reason you reach for an `unordered_set` is its high performance.
    Unfortunately, this performance comes at a cost: `unordered_set` objects have
    a somewhat complicated interior structure. You have various knobs and dials you
    can use to inspect and modify this internal structure at runtime.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: The first control measure you have is to customize the bucket count of the `unordered_set`
    (that is, the number of buckets, not the number of elements in a particular bucket).
    Each `unordered_set` constructor takes a `size_t bucket_count` as its first argument,
    which defaults to some implementation-defined value. [Table 13-11](ch13.xhtml#ch13tab11)
    lists the main `unordered_set` constructors.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-11:** The `unordered_set` Constructors'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set<`T`>(``[`bck`], [`hsh`], [`keq`], [`alc`])` | Bucket size
    bck has an implementation-defined default value. Uses hsh`=std::hash<`T`>`, keq`=std::equal_to<`T`>`,
    and alc`=std::allocator<`T`>` by default. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set<`T`>(`...`,` `[`bck`], [`hsh`], [`keq`], [`alc`])` | Performs
    braced initialization of a newly constructed unordered set. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set<`T`>(`beg`,` end `[`bck`],` `[`hsh`], [`keq`], [`alc`])` |
    Constructs an unordered set with the elements on the half-open range from beg
    to end. |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set<`T`>(`s`)` | Deep copy of s; allocates new memory. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
- en: '| `unordered_set<`T`>(move(`s`))` | Takes ownership of memory; elements in
    s. No allocations. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
- en: You can inspect the number of buckets in an `unordered_set` using the `bucket_count`
    method. You can also obtain the maximum bucket count using the `max_bucket_count`
    method.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: An important concept in the runtime performance of `unordered_set` is its *load
    factor*, the average number of elements per bucket. You can obtain the load factor
    of an `unordered_set` using the `load_factor` method, which is equivalent to `size()`
    divided by `bucket_count()`. Each `unordered_set` has a maximum load factor, which
    triggers an increase in the bucket count and a potentially expensive rehashing
    of all the contained elements. A *rehashing* is an operation where elements get
    reorganized into new buckets. This requires that you generate new hashes for each
    element, which can be a relatively computationally expensive operation.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain the maximum load factor using the `max_load_factor`, which is
    overloaded, so you can set a new maximum load factor (it defaults to 1.0).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: To avoid expensive rehashing at inopportune times, you can manually trigger
    a rehashing using the `rehash` method, which accepts a `size_t` argument for the
    desired bucket count. You can also use the `reserve` method, which instead accepts
    a `size_t` argument for the desired *element* count.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-31](ch13.xhtml#ch13ex31) illustrates some of these basic bucket
    management operations.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 13-31: The `unordered_set` bucket management*'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: You construct an `unordered_set` and specify a bucket count of 100 ➊. This results
    in a `bucket_count` of at least 100 ➋, which must be less than or equal to the
    `max_bucket_count` ➌. By default, the `max_load_factor` is 1.0 ➍.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: In the next test, you invoke `reserve` with enough space for a hundred thousand
    elements ➎. After inserting an element, the `load_factor` should be less than
    or equal to one one-hundred-thousandth (0.00001) ➏ because you’ve reserved enough
    space for a hundred thousand elements. As long as you stay below this threshold,
    you won’t need a rehashing. After inserting a hundred thousand elements ➐, the
    `load_factor` should still be less than or equal to 1 ➑. This demonstrates that
    you needed no rehashing, thanks to `reserve`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '**Unordered Multisets**'
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `std::unordered_multiset` available in the STL’s `<unordered_set>` header
    is an associative container that contains unsorted, *non-unique* keys. An `unordered_multiset`
    supports all the same constructors and operations as an `unordered_set`, but it
    will store redundant elements. This relationship is analogous to `unordered_set`s
    and `set`s: both `equal_range` and `count` have slightly different behavior to
    account for the non-uniqueness of keys.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also provides a `boost::unordered_multiset` in the `<boost/unordered_set.hpp>`
    header.*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '***Maps***'
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `std::map` available in the STL’s `<map>` header is an associative container
    that contains key-value pairs. The keys of a `map` are sorted and unique, and
    `map` supports all the same operations as `set`. In fact, you can think of a `set`
    as a special kind of `map` containing keys and empty values. Accordingly, `map`
    supports efficient insertion, removal, and search, and you have control over sorting
    with comparator objects.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage of working with a map instead of a set of pairs is that
    `map` works as an *associative array*. An associative array takes a key rather
    than an integer-valued index. Think of how you use the `at` and `operator[]` methods
    to access indices in sequential containers. Because sequential containers have
    a natural ordering of elements, you use an integer to refer to them. The associative
    array allows you to use types other than integers to refer to elements. For example,
    you could use a string or a `float` as a key.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: To enable associative array operations, `map` supports a number of useful operations;
    for example, allowing you to insert, modify, and retrieve values by their associated
    keys.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing**'
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The class template `map<Key, Value, Comparator, Allocator>` takes four template
    parameters. The first is the key type `Key`. The second is the value type `Value`.
    The third is the comparator type, which defaults to `std::less`. The fourth parameter
    is the allocator type, which defaults to `std::allocator<T>`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'The map constructors are direct analogues to the constructors of `set`: a default
    constructor that initializes an empty `map`; move and copy constructors with the
    usual behavior; a range constructor that copies the elements from the range into
    the map; and a braced initializer. The main difference is in the braced initializer,
    because you need to initialize key-value pairs instead of just keys. To achieve
    this nested initialization, you use nested initializer lists, as [Listing 13-32](ch13.xhtml#ch13ex32)
    illustrates.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 13-32: A `std::map` supports default construction and braced initialization.*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Here, you default construct a `map` with keys of type `const char*` and values
    of type `int` ➊. This results in an empty `map` ➋. In the second test, you again
    have a `map` with keys of type `const char*` and values of type `int` ➌, but this
    time you use braced initialization ➍ to pack four elements into the `map` ➎.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '**Move and Copy Semantics**'
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The move and copy semantics of `map` are identical to those of `set`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage Model**'
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Both `map` and `set` use the same red-black tree internal structure.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '**Element Access**'
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The major advantage to using a `map` instead of a `set` of `pair` objects is
    that `map` offers two associative array operations: `operator[]` and `at`. Unlike
    the sequential containers supporting these operations, like `vector` and `array`,
    which take a `size_t` index argument, `map` takes a `Key` argument and returns
    a reference to the corresponding value. As with sequential containers, `at` will
    throw a `std::out_of_range` exception if the given `key` doesn’t exist in the
    `map`. Unlike with sequential containers, `operator[]` won’t cause undefined behavior
    if the `key` doesn’t exist; instead, it will (silently) default construct a `Value`
    and insert the corresponding key-value pair into the map, even if you only intended
    to perform a read, as [Listing 13-33](ch13.xhtml#ch13ex33) illustrates.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 13-33: A `std::map` is an associative array with several access methods.*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `map` called `pub_year` containing two elements ➊. Next, you
    use `operator[]` to extract the value corresponding to the key `colour_of_magic`
    ➋. You also use `operator[]` to insert the new key-value pair `equal_rites`, `1987`
    ➌ and then retrieve it ➍. Notice that when you attempt to retrieve an element
    with the key `mort` (which doesn’t exist), the map has silently default-initialized
    an `int` for you ➎.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Using `at`, you can still set and retrieve ➏ elements, but if you attempt to
    access a key that doesn’t exist, you get a `std::out_of_range` exception ➐.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: A `map` supports all the `set`-like, element-retrieval operations. For example,
    `map` supports `find`, which accepts a `key` argument and returns an iterator
    pointing to the key-value `pair` or, if no matching key is found, to the end of
    `map`. Also similarly supported are `count`, `equal_range`, `lower_bound`, and
    `upper_bound`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Elements**'
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to the element access methods `operator[]` and `at`, you also have
    all the `insert` and `emplace` methods available from `set`. You simply need to
    treat each key-value pair as a `std::pair<Key, Value>`. As with `set`, `insert`
    returns a pair containing an iterator and a `bool`. The iterator points to the
    inserted element, and the `bool` answers whether `insert` added a new element
    (`true`) or not (`false`), as [Listing 13-34](ch13.xhtml#ch13ex34) illustrates.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 13-34: A `std::map` supports `insert` to add new elements.*'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'You default construct a `map` ➊ and use the `insert` method with a braced initializer
    for a `pair` ➋. This construction is roughly equivalent to the following:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After insertion, the `map` now contains one element ➌. Next, you create a stand-alone
    `pair` ➍ and then pass it as an argument to `insert` ➎. This inserts a copy into
    the `map`, so it now contains two elements ➏.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: When you attempt to invoke `insert` with a new element with the same `the_light_fantastic`
    key ➐, you get an iterator pointing to the element you already inserted ➎. The
    key (`first`) and the value (`second`) match ➑. The return value `is_new` indicates
    that no new element was inserted ➒, and you still have two elements ➓. This behavior
    mirrors the `insert` behavior of `set`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: A `map` also offers an `insert_or_assign` method, which, unlike `insert`, will
    overwrite an existing value. Also unlike `insert`, `insert_or_assign` accepts
    separate key and value arguments, as [Listing 13-35](ch13.xhtml#ch13ex35) illustrates.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 13-35: A `std::map` supports `insert_or_assign` to overwrite existing
    elements.*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `map` with a single element ➊ and then call `insert_or _assign`
    to reassign the value associated with the key `the_light_fantastic` to 1986 ➋.
    The iterator points to the existing element, and when you query the corresponding
    value with `second`, you see the value updated to 1986 ➌. The `is_new` return
    value also indicates that you’ve updated an existing element rather than inserting
    a new one ➍.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing Elements**'
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like `set`, `map` supports `erase` and `clear` to remove elements, as shown
    in [Listing 13-36](ch13.xhtml#ch13ex36).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 13-36: A `std::map` supports element removal.*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `map` with two elements ➊. In the first test, you invoke `erase`
    on the element with key `mort` ➋, so when you try to `find` it, you get back `end`
    ➌. In the second test, you clear `map` ➍, which causes `empty` to return `true`
    ➎.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '**List of Supported Operations**'
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: "[Table 13-12](ch13.xhtml#ch13tab12) summarizes the supported operations of\
    \ `map`. A key `k` has type `K`. A value `v` has type `V`. `P` is the type `pair<K,\
    \ V>`, and `p` is of type `P`. The map `m` is `map<K, V>`. A dagger (\x86) denotes\
    \ a method that returns a `std::pair<Iterator, bool>`, where the iterator points\
    \ to the resulting element and the `bool` equals `true` if the method inserted\
    \ an element and `false` if the element already existed."
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-12:** A Partial List of Supported `map` Operations'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
- en: '| `map<`T`>{` ...`, [`cmp`], [`alc`] }` | Performs braced initialization of
    a newly constructed map. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
- en: '| `map<`T`>{` beg`,` end`, [`cmp`], [`alc`] }` | Range constructor that copies
    elements from the half-open range beg to end. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
- en: '| `map<`T`>(`m`)` | Deep copy of m; allocates new memory. |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
- en: '| map`<`T`>(move(`m`))` | Takes ownership of memory; elements in m. No allocations.
    |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
- en: '| `~map` | Destructs all elements contained by the map and releases dynamic
    memory. |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
- en: '| m1 `=` m2 | m1 destructs its elements; copies each m2 element. Only allocates
    if it needs to resize to fit m2’s elements. |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '| m1 `= move(`m2`)` | m1 destructs its elements; moves each m2 element. Only
    allocates if it needs to resize to fit m2’s elements. |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| m`.at(`k`)` | Accesses the value corresponding to the key k. Throws `std::out_of_bounds`
    if key not found. |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: '| m`[`k`]` | Accesses the value corresponding to the key k. If the key is not
    found, inserts a new key-value pair using k and a default initialized value. |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
- en: '| m`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
- en: '| m`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: '| m`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
- en: '| m`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
- en: '| m`.find(`k`)` | Returns an iterator pointing to the element matching k, or
    m`.end()` if no such element exists. |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
- en: '| m`.count(`k`)` | Returns 1 if the map contains k; otherwise 0. |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
- en: '| m`.equal_range(`k`)` | Returns a `pair` of iterators corresponding to the
    half-open range of elements matching k. |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
- en: '| m`.lower_bound(`k`)` | Returns an iterator pointing to the first element
    not less than k, or t.`end()` if no such element exists. |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: '| m`.upper_bound(`k`)` | Returns an iterator pointing to the first element
    greater than k, or t`.end()` if no such element exists. |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
- en: '| m`.clear()` | Removes all elements from the map. |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
- en: '| m`.erase(`k`)` | Removes the element with key k. |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
- en: '| m`.erase(`itr`)` | Removes the element pointed to by itr. |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
- en: '| m`.erase(`beg`,` end`)` | Removes all elements on the half-open range from
    beg to end. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
- en: "| m`.insert(`p`)` | Inserts a copy of the pair p into the map.\x86 |"
  id: totrans-609
  prefs: []
  type: TYPE_TB
- en: "| m`.insert_or_assign(`k`,` v`)` | If k exists, overwrites the corresponding\
    \ value with v. If k doesn’t exist, inserts the pair k, v into the map.\x86 |"
  id: totrans-610
  prefs: []
  type: TYPE_TB
- en: "| m`.emplace(`...`)` | Constructs a P in place by forwarding the arguments\
    \ ....\x86 |"
  id: totrans-611
  prefs: []
  type: TYPE_TB
- en: "| m`.emplace_hint(`k`, ...)` | Constructs a P in place by forwarding the arguments`...`.\
    \ Uses itr as a hint for where to insert the new element.\x86 |"
  id: totrans-612
  prefs: []
  type: TYPE_TB
- en: '| m`.try_emplace(`itr`,` ...`)` | If key k exists, does nothing. If k doesn’t
    exist, constructs a V in place by forwarding the arguments .... |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
- en: '| m`.empty()` | Returns `true` if map’s size is zero; otherwise `false`. |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
- en: '| m`.size()` | Returns the number of elements in the map. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
- en: '| m`.max_size()` | Returns the maximum number of elements in the map. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
- en: '| m`.extract(`k`)`m`.extract(`itr`)` | Obtains a node handle that owns the
    element matching k or pointed to by itr. (This is the only way to remove a move-only
    element.) |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
- en: '| m1`.merge(`m2`)`m1`.merge(move(`m2`))` | Splices each element of m2 into
    m1. If argument is an rvalue, will move the elements into m1. |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
- en: '| m1`.swap(`m2`)``swap(`m1`,` m2`)` | Exchanges each element of m1 with those
    of m2. |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
- en: '**Multimaps**'
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `std::multimap` available in the STL’s `<map>` header is an associative
    container that contains key-value pairs with *non-unique* keys. Because the keys
    are not unique, `multimap` doesn’t support the associative array features that
    `map` does. Namely, `operator[]` and `at` aren’t supported. As with `multiset`,
    `multimap` offers element access primarily through the `equal_range` method, as
    [Listing 13-37](ch13.xhtml#ch13ex37) illustrates.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 13-37: A `std::multimap` supports non-unique keys.*'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: You construct an `array` containing a message ➊. You also default construct
    a `multimap<char, size_t>` called `indices` that you’ll use to store the index
    of every character in the message ➋. By looping through the array, you can store
    each character in the message along with its index as a new element in `multimap`
    ➌. Because you’re allowed to have non-unique keys, you can use the `count` method
    to reveal how many indices you insert with the key `a` ➍. You can also use the
    `equal_range` method to obtain the half-open range of indices with the key `d`
    ➎. Using the resulting `begin` and `end` iterators, you can see that the message
    has the letter `d` at indices 23 ➏ and 59 ➐.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Aside from `operator[]` and `at`, every operation in [Table 13-12](ch13.xhtml#ch13tab12)
    works for `multimap` as well. (Note that the `count` method can take on values
    other than 0 and 1.)
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '**Unordered Maps and Unordered Multimaps**'
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unordered maps and unordered multimaps are completely analogous to unordered
    sets and unordered multisets. The `std::unordered_map` and `std::unordered_multimap`
    are available in the STL’s `<unordered_map>` header. These associative containers
    typically use a red-black tree like their `set` counterparts. They also require
    a hash function and an equivalence function, and they support the bucket interface.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost offers the `boost::unordered_map` and `boost::unordered_multimap` in
    the `<boost/unordered_map.hpp>` header.*'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '***Niche Associative Containers***'
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use `set`, `map`, and their associated non-unique and unordered counterparts
    as the default choices when you need associative data structures. When special
    needs arise, Boost libraries offer a number of specialized associative containers,
    as highlighted in [Table 13-13](ch13.xhtml#ch13tab13).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-13:** Special Boost Containers'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class/Header** | **Description** |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
- en: '| `boost::container::flat_map``<boost/container/flat_map.hpp>` | Similar to
    an STL `map`, but it’s implemented like an ordered vector. This means fast random
    element access. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
- en: '| `boost::container::flat_set``<boost/container/flat_set.hpp>` | Similar to
    an STL `set`, but it’s implemented like an ordered vector. This means fast random
    element access. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
- en: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | Intrusive containers impose
    requirements on the elements they contain (such as inheriting from a particular
    base class). In exchange, they offer substantial performance gains. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
- en: '| `boost::multi_index_container``<boost/multi_index_container.hpp>` | Permits
    you to create associative arrays taking multiple indices rather than just one
    (like a map). |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
- en: '| `boost::ptr_set``boost::ptr_unordered_map``boost::ptr_unordered_set``<boost/ptr_container/*.hpp>`
    | Having a collection of smart pointers can be suboptimal. Pointer vectors manage
    a collection of dynamic objects in a more efficient and user-friendly way. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
- en: '| `boost::bimap``<` `boost/bimap.hpp>` | A bimap is an associative container
    that allows both types to be used as a key. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
- en: '| `boost::heap::binomial_heap``boost::heap::d_ary_heap``boost::heap::fibonacci_heap``boost::heap::pairing_heap``boost::heap::priority_queue``boost::heap::skew_heap``<boost/heap/*.hpp>`
    | The Boost Heap containers implement more advanced, featureful versions of `priority_queue`.
    |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
- en: '**Graphs and Property Trees**'
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section discusses two specialized Boost libraries that serve niche but
    valuable purposes: modeling graphs and property trees. A *graph* is a set of objects
    in which some have a pairwise relation. The objects are called *verti**ces,*and
    their relations are called *edges*. [Figure 13-3](ch13.xhtml#ch13fig03) illustrates
    a graph containing four vertices and five edges.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig13_3.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3:A graph containing four vertices and five edges*'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Each square represents a vertex, and each arrow represents an edge.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: A *property tree* is a tree structure storing nested key-value pairs. The hierarchical
    nature of a property tree’s key-value pairs makes it a hybrid between a map and
    a graph; each key-value pair has a relation to other key-value pairs. [Figure
    13-4](ch13.xhtml#ch13fig04) illustrates an example property tree containing nested
    key-value pairs.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig13_4.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: An example property tree*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'The root element has three children: name, year, and features. In [Figure 13-4](ch13.xhtml#ch13fig04),
    name has a value finfisher, year has a value 2014, and features has three children:
    process with value LSASS, driver with value mssounddx.sys, and arch with value
    32.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '**The Boost Graph Library**'
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Boost Graph Library* (BGL) is a set of collections and algorithms for
    storing and manipulating graphs. The BGL offers three containers that represent
    graphs:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::adjacency_list` in the `<boost/graph/adjacency_list.hpp>` header
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boost::adjacency_matrix` in the `<boost/graph/adjacency_matrix.hpp>` header
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boost::edge_list` in the `<boost/graph/ edge_list.hpp>` header
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You use two non-member functions to build graphs: `boost::add_vertex` and `boost::add_edge`.
    To add a vertex to one of the BGL graph containers, you pass the graph object
    to `add_vertex`, which will return reference to the new vertex object. To add
    an edge, we pass the source vertex, the destination vertex, then the graph to
    `add_edge`.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: BGL contains a number of graph-specific algorithms. You can count the number
    of vertices in a graph object by passing it to the non-member function `boost::num_vertices`
    and the number of edges using `boost::num_edges`. You can also query a graph for
    adjacent vertices. Two vertices are *adjacent* if they share an edge. To get the
    vertices adjacent to a particular vertex, you can pass it and the graph object
    to the non-member function `boost::adjacent_ vertices`. This returns a half-open
    range as a `std::pair` of iterators.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-38](ch13.xhtml#ch13ex38) illustrates how you can build the graph
    represented in [Figure 13-3](ch13.xhtml#ch13fig03), count its vertices and edges,
    and compute adjacent vertices.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 13-38: The `boost::adjacency_list` stores graph data.*'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ve constructed an `adjacency_list` called `graph` ➊, then added four
    vertices using `add_vertex` ➋. Next, you add all the edges represented in [Figure
    13-3](ch13.xhtml#ch13fig03) using `add_edge` ➌. Then `num_vertices` shows you
    that you’ve added four vertices ➍, and `num_edges` tells you that you’ve added
    five edges ➎.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ve determined the `adjacent_vertices` to `vertex_1`, which you
    unpack into the iterators `begin` and `end` ➏. You use these iterators to construct
    a `std::set` ➐, which you use to show that `vertex_2` ➑ and `vertex_3` ➒ are adjacent,
    but `vertex_4` is not ➓.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '**Boost Property Trees**'
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost offers the `boost::property_tree::ptree` in the `<boost/property_tree/ptree.hpp>`
    header. This is a property tree that permits us to build and query property trees,
    as well as some limited serialization into various formats.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: The tree `ptree` is default constructible. Default constructing will build an
    empty `ptree`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: You can insert elements into a `ptree` using its `put` method, which takes a
    path and a value argument. A *path* is a sequence of one or more nested keys separated
    by a period (**.**), and a *value* is an arbitrarily typed object.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: You can get subtrees from a `ptree` using the `get_child` method, which takes
    the path of the desired subtree. If the subtree does not have any children (a
    so-called *leaf node*), you can also use the method template `get_value` to extract
    the corresponding value from the key-value pair; `get_value` takes a single template
    parameter corresponding to the desired output type.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `ptree` supports serialization and deserialization to several formats
    including Javascript object notation (JSON), the Windows initialization file (INI)
    format, the extensible markup language (XML), and a custom, `ptree`-specific format
    called INFO. For example, to write a `ptree` into a file in JSON format, you could
    use the `boost::property_tree::write_json` function from the `<boost/property_tree/json_parser.hpp>`
    header. The function `write_json` accepts two arguments: the path to the desired
    output file and a `ptree` reference.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-39](ch13.xhtml#ch13ex39) highlights these basic `ptree` functions
    by building a `ptree` representing the property tree in [Figure 13-4](ch13.xhtml#ch13fig04),
    writing the `ptree` to file as JSON, and reading it back.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 13-39: The `boost::property_tree::ptree` method stores tree data.
    Output shows the contents of `rootkit.json`.*'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ve default constructed a `ptree` ➊, which you populate with the key
    values shown in [Figure 13-4](ch13.xhtml#ch13fig04). Keys with parents, such as
    `arch` ➋, use periods to show the appropriate path. Using `get_child`, you’ve
    extracted the subtree for key `year`. Because it’s a leaf node (having no children),
    you also invoke `get_value`, specifying the output type as `int` ➌.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: Next, you write the `ptree`’s JSON representation to the file `rootkit.json`
    ➍. To ensure that you get the same property tree back, you default construct another
    `ptree` called `p_copy` and pass it into `read_json` ➎. This copy is equivalent
    to the original ➏, illustrating that the serialization-deserialization operation
    is successful.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializer Lists**'
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can accept initializer lists in your user-defined types by incorporating
    the `std::initializer_list` container available in the STL’s `<initializer_list>`
    header. The `initializer_list` is a class template that takes a single template
    parameter corresponding to the underlying type contained in the initializer list.
    This template serves as a simple proxy for accessing the elements of an initializer
    list.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initializer_list` is immutable and supports three operations:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: The `size` method returns the number of elements in the `initializer_list`.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `begin` and `end` methods return the usual half-open-range iterators.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, you should design functions to accept an `initializer_list` by value.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-40](ch13.xhtml#ch13ex40) implements a `SquareMatrix` class that
    stores a matrix with equal numbers of rows and columns. Internally, the class
    will hold elements in a `vector` of `vector`s.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 13-40: An implementation of a `SquareMatrix`*'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Here, you declare a convenience `square_root` function that finds the square
    root of a `size_t`, throwing an exception if the argument isn’t a perfect square
    ➊. The `SquareMatrix` class template defines a single constructor that accepts
    a `std::initializer` called `val` ➋. This permits braced initialization.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to determine the dimensions of `SquareMatrix`. Use the `square_root`
    function to compute the square root of `val.size()` ➌ and store this into the
    `dim` field, which represents the number of rows and columns of the `SquareMatrix`
    instance. You can then use `dim` to initialize the vector of vectors `data` using
    its fill constructor ➍. Each of these `vector`s will correspond to a row in `SquareMatrix`.
    Next, you extract an iterator pointing to the first element in `initializer_list`
    ➎. You iterate over each row in `SquareMatrix`, assigning the corresponding `vector`
    to the appropriate half-open range ➏. You increment the iterator on each iteration
    to point to the next row ➐.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implement an `at` method to permit element access. You perform
    bounds checking ➑ and then return a reference to the desired element by extracting
    the appropriate `vector` and element ➒.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-41](ch13.xhtml#ch13ex41) illustrates how to use braced initialization
    to generate a `SquareMatrix` object.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 13-41: Using braced initializers with a `SquareMatrix`*'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: You use braced initializers to set up `SquareMatrix` ➊. Because the initializer
    list contains 16 elements, you end up with a `dim` of 4 ➋. You can use `at` to
    obtain a reference to any element, meaning you can set ➌ and get ➍➎ elements.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began with a discussion of the two go-to sequence containers, `array`
    and `vector`, which offer you a great balance between performance and features
    in a wide range of applications. Next, you learned about several sequence containers—`deque`,
    `list`, `stack`, `queue`, `priority_queue`, and `bitset`—that fill in when `vector`
    doesn’t meet the demands of a particular application. Then you explored the major
    associative containers, `set` and `map`, and their unordered/multipermutations.
    You also learned about two niche Boost containers, `graph` and `ptree`. The chapter
    wrapped up with a brief discussion of incorporating `initializer_list`s into user-defined
    types.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '**13-1.** Write a program that default constructs a `std::vector` of unsigned
    longs. Print the `capacity` of `vector` and then `reserve` 10 elements. Next,
    append the first 20 elements of the Fibonacci series to the vector. Print `capacity`
    again. Does `capacity` match the number of elements in the vector? Why or why
    not? Print the elements of `vector` using a range-based `for` loop.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '**13-2.** Rewrite [Listings 2-9](ch02.xhtml#ch02ex09), [2-10](ch02.xhtml#ch02ex10),
    and [2-11](ch02.xhtml#ch02ex11) in [Chapter 2](ch02.xhtml#ch02) using `std::array`.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '**13-3.** Write a program that accepts any number of command line arguments
    and prints them in alphanumerically sorted order. Use a `std::set<const char*>`
    to store the elements, then iterate over the `set` to obtain the sorted result.
    You’ll need to implement a custom comparator that compares two C-style strings.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '**13-4.** Write a program that default constructs a `std::vector` of unsigned
    longs. Print the `capacity` of `vector` and then `reserve` 10 elements. Next,
    append the first 20 elements of the Fibonacci series to the vector. Print `capacity`
    again. Does `capacity` match the number of elements in the vector? Why or why
    not? Print the elements of `vector` using a range-based `for` loop.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '**13-5.** Consider the following program that profiles the performance of a
    function summing a Fibonacci series:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This program contains a computationally intensive function `fib_sum` ➊ that
    computes the sum of a Fibonacci series with a given length. Adapt your code from
    Exercise 13-1 by (a) generating the appropriate vector and (b) summing over the
    result with a range-based `for` loop. The `random` function ➋ returns a random
    number between 1,000 and 2,000, and the `Stopwatch` class ➌ adopted from [Listing
    12-25](ch12.xhtml#ch12ex25) in [Chapter 12](ch12.xhtml#ch12) helps you determine
    elapsed time. In the program’s `main`, you perform a million evaluations of the
    `fib_sum` function using random input ➎. You time how long this takes and print
    the result before exiting the program ➐. Compile the program and run it a few
    times to get an idea of how long your program takes to run. (This is called a
    *baseline*.)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '**13-6.** Next, comment out ➎ and uncomment ➏. Implement the function `cached_fib_sum`
    ➍ so you first check whether you’ve computed `fib_sum` for the given length yet.
    (Treat the length `n` as a key into the cache.) If the key is present in the cache,
    simply return the result. If the key isn’t present, compute the correct answer
    with `fib_sum`, store the new key-value entry into `cache`, and return the result.
    Run the program again. Is it faster? Try `unordered_map` instead of `map`. Could
    you use a `vector` instead? How fast can you get the program to run?'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Implement a Matrix class like `SquareMatrix` in [Listing 13-38](ch13.xhtml#ch13ex38).
    Your `Matrix` should allow unequal numbers of rows and columns. Accept as your
    constructor’s first argument the number of rows in `Matrix`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
