<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_9"/><strong><span class="big">2</span><br/>DATA STORAGE FORMATS</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">You may be used to thinking of computers as hardware devices for storing collections of programs, files, and graphics. In this book, we’ll look at computers in a different way: as billions of two-state switches and one or more <em>control units</em>—devices that can both detect and change the states of the switches.</p>&#13;
<p class="indent">In <a href="ch01.xhtml">Chapter 1</a>, we discussed communicating with the world outside the computer using input and output. In this chapter, we’ll begin exploring how computers encode data for storage in memory, and we’ll write some programs in C that explore these concepts.</p>&#13;
<h3 class="h3" id="ch02lev1sec1"><strong>Switches and Groups of Switches</strong></h3>&#13;
<p class="noindent">Whatever you’re doing on your computer—streaming a video, posting on social media, writing a program—it’s done by combinations of two-state switches interacting with each other. Each combination of switches represents a possible state the computer can be in. If you wanted to describe what was happening on your computer, you could list a combination of switches. In plain English, this would be something like “The first switch is on, the second one is also on, but the third is off, while the fourth is on.” But describing the <span epub:type="pagebreak" id="page_10"/>computer this way would be difficult, because modern computers use billions of switches. Instead, we use a more concise, numeric notation.</p>&#13;
<h4 class="h4" id="ch02lev2sec1"><em><strong>Representing Switches with Bits</strong></em></h4>&#13;
<p class="noindent">You’re probably familiar with the <em>decimal system</em>, which uses the digits 0 to 9 to write numbers. We want to represent switches numerically, but our switches have only 2 states, not 10. Here, the <em>binary system</em>—a two-digit system that uses <code>0</code>s and <code>1</code>s—is useful.</p>&#13;
<p class="indent">We’ll use a <em>binary digit</em>, commonly shortened to <em>bit</em>, to represent the state of a switch. A bit can have two values: <code>0</code>, which represents that a switch is “off,” and <code>1</code>, which represents that a switch is “on.” If we wanted, we could assign the opposite values to these digits; all that matters is that we’re consistent. Let’s use bits to simplify our statement about switches: we have a computer in which the first, second, and fourth switches are on and the third is off. In binary, we would represent this as <code>1101</code>.</p>&#13;
<h4 class="h4" id="ch02lev2sec2"><em><strong>Representing Groups of Bits</strong></em></h4>&#13;
<p class="noindent">Even with binary, sometimes we have so many bits that the number is un-readable. In those cases, we use <em>hexadecimal digits</em> to specify bit patterns. The hexadecimal system has 16 digits, each of which can represent one group of 4 bits. <a href="ch02.xhtml#ch2tab1">Table 2-1</a> shows all 16 possible combinations of 4 bits and the corresponding hexadecimal digit for each combination. After using hexadecimal for a while, you will probably memorize this table, but if you forget it, an online search will quickly bring up a hexadecimal-to-binary converter.</p>&#13;
<p class="tabcap" id="ch2tab1"><strong>Table 2-1:</strong> The Hexadecimal Representation of 4 Bits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>One hexadecimal digit</strong></th>&#13;
<th class="tab_th"><strong>Four binary digits (bits)</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1"><code>0000</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg"><code>0001</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>2</code></td>&#13;
<td class="bg1"><code>0010</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>3</code></td>&#13;
<td class="bg"><code>0011</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>4</code></td>&#13;
<td class="bg1"><code>0100</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>5</code></td>&#13;
<td class="bg"><code>0101</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>6</code></td>&#13;
<td class="bg1"><code>0110</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>7</code></td>&#13;
<td class="bg"><code>0111</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>8</code></td>&#13;
<td class="bg1"><code>1000</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>9</code></td>&#13;
<td class="bg"><code>1001</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>a</code></td>&#13;
<td class="bg1"><code>1010</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>b</code></td>&#13;
<td class="bg"><code>1011</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>c</code></td>&#13;
<td class="bg1"><code>1100</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>d</code></td>&#13;
<td class="bg"><code>1101</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>e</code></td>&#13;
<td class="bg1"><code>1110</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>f</code></td>&#13;
<td class="bg"><code>1111</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_11"/>&#13;
<p class="indent">Using hexadecimal, we can write <code>1101</code>, or “on, on, off, on,” with a single digit: <code>d</code><sub>16</sub> = <code>1101</code><sub>2</sub>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When it isn’t clear from the context, I will indicate the base of a number in this text with a subscript. For example, 100<sub>10</sub> is in decimal,</em> <span class="codeitalic">100</span><em><sub>16</sub> is in hexadecimal, and</em> <span class="codeitalic">100</span><em><sub>2</sub> is in binary.</em></p>&#13;
</div>&#13;
<p class="indent">The <em>octal</em> system, based on the number 8, is less common, but you will encounter it occasionally. The eight octal digits span from <code>0</code> to <code>7</code>, and each digit represents a group of 3 bits. <a href="ch02.xhtml#ch2tab2">Table 2-2</a> shows the correspondence between each possible group of 3 bits and its corresponding single octal digit.</p>&#13;
<p class="tabcap" id="ch2tab2"><strong>Table 2-2:</strong> The Octal Representation of 3 Bits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>One octal digit</strong></th>&#13;
<th class="tab_th"><strong>Three binary digits (bits)</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1"><code>000</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg"><code>001</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>2</code></td>&#13;
<td class="bg1"><code>010</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>3</code></td>&#13;
<td class="bg"><code>011</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>4</code></td>&#13;
<td class="bg1"><code>100</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>5</code></td>&#13;
<td class="bg"><code>101</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>6</code></td>&#13;
<td class="bg1"><code>110</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>7</code></td>&#13;
<td class="bg"><code>111</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, the 4-bit example we’re using, <code>1101</code><sub>2</sub>, would be written <code>15</code><sub>8</sub> in octal.</p>&#13;
<h4 class="h4" id="ch02lev2sec3"><em><strong>Using Hexadecimal Digits</strong></em></h4>&#13;
<p class="noindent">Hexadecimal digits are especially convenient when we need to specify the state of a group of, say, 16 or 32 switches. In place of each group of 4 bits, we can write one hexadecimal digit. For example:</p>&#13;
<pre class="prec">6c2a<sub>16</sub> = 0110110000101010<sub>2</sub>&#13;
&#13;
0123abcd<sub>16</sub> = 00000001001000111010101111001101<sub>2</sub></pre>&#13;
<p class="indent">A single bit is rarely useful for storing data. The smallest number of bits that can be accessed at a time in a computer is defined as a <em>byte</em>. In most modern computers, a byte consists of 8 bits, but there are exceptions to the 8-bit byte. For example, the CDC 6000 series of scientific mainframe computers used a 6-bit byte.</p>&#13;
<p class="indent">In the C and C++ programming languages, prefixing a number with <code>0x</code>—that’s a zero and a lowercase <em>x</em>—specifies that the number is expressed in hexadecimal. Prefixing a number with only a <code>0</code> specifies octal representation. C++ allows us to specify a value in binary by prefixing the number with <code>0b</code>. Although the <code>0b</code> notation for specifying binary is not part of standard C, <span epub:type="pagebreak" id="page_12"/>our compiler, <code>gcc</code>, allows it. Thus, when we write C or C++ code in this book, these all mean the same thing:</p>&#13;
<pre class="pre">100 = 0x64 = 0144 = 0b01100100</pre>&#13;
<p class="indent">If you’re using a different C compiler, you may not be able to use the <code>0b</code> syntax to specify binary.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch2exe1">2.1     Express the following bit patterns in hexadecimal:</p>&#13;
<p class="alpha">(a)     <code>0100 0101 0110 0111</code></p>&#13;
<p class="alpha">(b)     <code>1000 1001 1010 1011</code></p>&#13;
<p class="alpha">(c)     <code>1111 1110 1101 1100</code></p>&#13;
<p class="alpha">(d)     <code>0000 0010 0101 0010</code></p>&#13;
<p class="box-list" id="ch2exe2">2.2     Express the following hexadecimal patterns in binary:</p>&#13;
<p class="alpha">(a)     <code>83af</code></p>&#13;
<p class="alpha">(b)     <code>9001</code></p>&#13;
<p class="alpha">(c)     <code>aaaa</code></p>&#13;
<p class="alpha">(d)     <code>5555</code></p>&#13;
<p class="box-list" id="ch2exe3">2.3     How many bits are represented by each of the following?</p>&#13;
<p class="alpha">(a)     <code>ffffffff</code></p>&#13;
<p class="alpha">(b)     <code>7fff58b7def0</code></p>&#13;
<p class="alpha">(c)     <code>1111</code><sub>2</sub></p>&#13;
<p class="alpha">(d)     <code>1111</code><sub>16</sub></p>&#13;
<p class="box-list" id="ch2exe4">2.4     How many hexadecimal digits are required to represent each of the following?</p>&#13;
<p class="alpha">(a)     8 bits</p>&#13;
<p class="alpha">(b)     32 bits</p>&#13;
<p class="alpha">(c)     64 bits</p>&#13;
<p class="alpha">(d)     10 bits</p>&#13;
<p class="alpha">(e)     20 bits</p>&#13;
<p class="alpha">(f)     7 bits</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec2"><strong>The Mathematical Equivalence of Binary and Decimal</strong></h3>&#13;
<p class="noindent">In the previous section, you learned that binary digits are a natural way to show the states of switches within the computer. You also learned that we can use hexadecimal to show the state of four switches with a single character. In this section, I’ll show you some of the mathematical properties of the binary number system and how it translates to and from the more familiar decimal (base 10) number system.</p>&#13;
<h4 class="h4" id="ch02lev2sec4"><em><strong>Getting to Know Positional Notation</strong></em></h4>&#13;
<p class="noindent">By convention, we use positional notation when writing numbers. <em>Positional notation</em> means that the value of a symbol depends on its position within a <span epub:type="pagebreak" id="page_13"/>group of symbols. In the familiar decimal number system, we use the symbols 0, 1, . . . , 9 to represent numbers.</p>&#13;
<p class="indent">In the number 50, the value of the symbol 5 is 50 because it’s in the <em>tens position</em>, and any number in that position is multiplied by 10. In the number 500, the value of the symbol 5 is 500 because it’s in the <em>hundreds position</em>. The symbol 5 is the same in any position, but its value depends on the position it occupies within the number.</p>&#13;
<p class="indent">Taking this a step further, in the decimal number system, the integer 123 is taken to mean</p>&#13;
<div class="image1"><img src="../images/pg41_Image_5.jpg" alt="Image" width="176" height="16"/></div>&#13;
<p class="noindent">or:</p>&#13;
<div class="image1"><img src="../images/pg41_Image_6.jpg" alt="Image" width="241" height="22"/></div>&#13;
<p class="noindent">In this example, the rightmost digit, 3, is the <em>least significant digit</em> because its value contributes the least to the number’s total value. The leftmost digit, 1, is the <em>most significant digit</em> because it contributes the most value.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>ANOTHER NUMBER SYSTEM</strong></p>&#13;
<p class="box-para">Before positional notations were invented, people used counting systems to keep track of numerical quantities. The <em>Roman numeral</em> system is a well-known example of a counting system. It uses the symbols I for 1, V for 5, X for 10, L for 50, and so on. To represent two things, you simply use two I’s: II. Similarly, XX represents 20 things.</p>&#13;
<p class="box-para">The two main rules of the Roman numeral system are that symbols that represent larger values come first, and if a symbol representing a smaller value is placed before a larger one, then the value of the smaller one is subtracted from the immediately following larger one. For example, IV represents 4 because I (1) is less than V (5), so it is subtracted from the value represented by V.</p>&#13;
<p class="box-para">There is no symbol for zero in the Roman numeral system because the symbol 0 isn’t needed in counting systems. In a positional system, we need a symbol to mark the fact that there is no value in that position, but the position still counts toward the value being represented: the zeros in 500 tell us that there are no values in the tens position or the ones position. There is just a value of 5 in the hundreds position.</p>&#13;
<p class="box-para">The invention of positional notations greatly simplified arithmetic and led to the mathematics we know today. If you need to convince yourself, divide 60 (LX) by 3 (III) in the Roman numeral system. (Answer: XX.)</p>&#13;
</div>&#13;
<p class="indent">The <em>base</em>, or <em>radix</em>, of the decimal number system—that is, the number of unique digits—is 10. This means there are 10 symbols to represent the digits 0 through 9. Moving a digit one place to the left increases its value by a factor of 10. Moving it one place to the right decreases its value by a factor of 10. The positional notation generalizes to any radix <em>r</em> as</p>&#13;
<div class="image1"><img src="../images/pg41_Image_7.jpg" alt="Image" width="466" height="42"/></div>&#13;
<p class="noindent">where there are <em>n</em> digits in the number and each <em>d<sub>i</sub></em> is a single digit with 0 <em>≤ d<sub>i</sub></em> &lt; <em>r</em>.</p>&#13;
<span epub:type="pagebreak" id="page_14"/>&#13;
<p class="indent">This expression tells us how to determine the value of each digit in the number. We determine the position of each digit in the number by counting from the right, starting with zero. At each position, we raise the radix, <em>r</em>, to the power of its position and then multiply that number by the value of the digit. Adding all the results gives us the value represented by the number.</p>&#13;
<p class="indent">The radix in the binary number system is 2, so there are only two symbols for representing the digits. This means that <em>d<sub>i</sub></em> = <code>0</code>, <code>1</code>, and we can write this expression as</p>&#13;
<div class="image1"><img src="../images/pg42_Image_8.jpg" alt="Image" width="479" height="26"/></div>&#13;
<p class="noindent">where there are <em>n</em> digits in the number and each <em>d<sub>i</sub></em> = <code>0</code> or <code>1</code>.</p>&#13;
<p class="indent">In the next section, we’ll convert binary numbers to and from unsigned decimals. <em>Signed</em> numbers can be either positive or negative, but <em>unsigned</em> numbers have no sign. We’ll discuss signed numbers in <a href="ch03.xhtml">Chapter 3</a>.</p>&#13;
<h4 class="h4" id="ch02lev2sec5"><em><strong>Converting Binary to Unsigned Decimal</strong></em></h4>&#13;
<p class="noindent">You can easily convert from binary to decimal by computing the value of 2 raised to the power of the position it’s in and then multiplying that by the value of the bit in that position. For example:</p>&#13;
<div class="image1"><img src="../images/pg42_Image_9.jpg" alt="Image" width="497" height="122"/></div>&#13;
<p class="indent">Using pseudocode, the procedure for converting binary to decimal can be summarized as:</p>&#13;
<pre class="pre">Let result = 0&#13;
Repeat for each i = 0, ..., (n - 1)&#13;
    Add d<sub>i</sub> × 2<sup>i</sup> to result</pre>&#13;
<p class="noindent">At each bit position, this algorithm computes 2<em><sup>i</sup></em> and then multiplies by the respective bit value, either <code>0</code> or <code>1</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although we’re considering only integers at this point, this algorithm does generalize to fractional values. Simply continue the exponents of the radix,</em> r<em>, on to negative values—that is,</em> r<sup>n – <em>1</em></sup>, r<sup>n – <em>2</em></sup><em>, . . . ,</em> r<em><sup>1</sup>,</em> r<em><sup>0</sup>,</em> r<sup>–<em>1</em></sup>, r<sup>–<em>2</em></sup><em>, . . . This will be covered in detail in <a href="ch19.xhtml">Chapter 19</a>.</em></p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch2exe5">2.5     Looking at the generalized equation in this section, what are the values of <em>r</em>, <em>n</em>, and each <em>d<sub>i</sub></em> for the decimal number 29,458,254 and the hexadecimal number <code>29458254</code>?</p>&#13;
<span epub:type="pagebreak" id="page_15"/>&#13;
<p class="box-list" id="ch2exe6">2.6     Convert the following 8-bit binary numbers to decimal:</p>&#13;
<p class="alpha">(a)     <code>1010 1010</code></p>&#13;
<p class="alpha">(b)     <code>0101 0101</code></p>&#13;
<p class="alpha">(c)     <code>1111 0000</code></p>&#13;
<p class="alpha">(d)     <code>0000 1111</code></p>&#13;
<p class="alpha">(e)     <code>1000 0000</code></p>&#13;
<p class="alpha">(f)     <code>0110 0011</code></p>&#13;
<p class="alpha">(g)     <code>0111 1011</code></p>&#13;
<p class="alpha">(h)     <code>1111 1111</code></p>&#13;
<p class="box-list" id="ch2exe7">2.7     Convert the following 16-bit binary numbers to decimal:</p>&#13;
<p class="alpha">(a)     <code>1010 1011 1100 1101</code></p>&#13;
<p class="alpha">(b)     <code>0001 0011 0011 0100</code></p>&#13;
<p class="alpha">(c)     <code>1111 1110 1101 1100</code></p>&#13;
<p class="alpha">(d)     <code>0000 0111 1101 1111</code></p>&#13;
<p class="alpha">(e)     <code>1000 0000 0000 0000</code></p>&#13;
<p class="alpha">(f)     <code>0000 0100 0000 0000</code></p>&#13;
<p class="alpha">(g)     <code>0111 1011 1010 1010</code></p>&#13;
<p class="alpha">(h)     <code>0011 0000 0011 1001</code></p>&#13;
<p class="box-list" id="ch2exe8">2.8     Develop an algorithm to convert hexadecimal to decimal and then convert the following 16-bit numbers to decimal:</p>&#13;
<p class="alpha">(a)     <code>a000</code></p>&#13;
<p class="alpha">(b)     <code>ffff</code></p>&#13;
<p class="alpha">(c)     <code>0400</code></p>&#13;
<p class="alpha">(d)     <code>1111</code></p>&#13;
<p class="alpha">(e)     <code>8888</code></p>&#13;
<p class="alpha">(f)     <code>0190</code></p>&#13;
<p class="alpha">(g)     <code>abcd</code></p>&#13;
<p class="alpha">(h)     <code>5555</code></p>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec6"><em><strong>Converting Unsigned Decimal to Binary</strong></em></h4>&#13;
<p class="noindent">If we want to convert an unsigned decimal integer, <em>N</em>, to binary, we set it equal to the previous expression for binary numbers to give the equation</p>&#13;
<div class="image1"><img src="../images/pg43_Image_10.jpg" alt="Image" width="518" height="26"/></div>&#13;
<p class="noindent">where each <em>d<sub>i</sub></em> = <code>0</code> or <code>1</code>. We divide both sides of this equation by 2, and the exponent of each 2 term on the right side decreases by 1, giving</p>&#13;
<div class="image1"><img src="../images/pg43_Image_11.jpg" alt="Image" width="591" height="38"/></div>&#13;
<p class="noindent">where <em>N</em><sub>1</sub> is the integer part and the remainder, <em>r</em><sub>0</sub>, is <code>0</code> for even numbers and <code>1</code> for odd numbers. Doing a little rewriting, we have the equivalent equation:</p>&#13;
<div class="image1"><img src="../images/pg43_Image_12.jpg" alt="Image" width="553" height="43"/></div>&#13;
<p class="indent">All the terms within the parentheses on the right side are integers. The integer part of both sides of an equation must be equal, and the fractional parts must also be equal. That is, we have</p>&#13;
<div class="image1"><img src="../images/pg43_Image_13.jpg" alt="Image" width="442" height="25"/></div>&#13;
<span epub:type="pagebreak" id="page_16"/>&#13;
<p class="noindent">and:</p>&#13;
<div class="image1"><img src="../images/pg44_Image_14.jpg" alt="Image" width="66" height="44"/></div>&#13;
<p class="indent">Thus, you can see that <em>d</em><sub>0</sub> = <em>r</em><sub>0</sub>. Subtracting <em>r</em><sub>0</sub> /2 (which equals <em>d</em><sub>0</sub>/2) from both sides of our expanded equation gives us:</p>&#13;
<div class="image1"><img src="../images/pg44_Image_15.jpg" alt="Image" width="442" height="33"/></div>&#13;
<p class="indent">Again, we divide both sides by 2:</p>&#13;
<div class="image1"><img src="../images/pg44_Image_16.jpg" alt="Image" width="589" height="69"/></div>&#13;
<p class="indent">Using the same reasoning as earlier, <em>d</em><sub>1</sub> = <em>r</em><sub>1</sub>. We can produce the binary representation of a number by working from right to left, repeatedly dividing by 2, and using the remainder as the value of the respective bit. This is summarized in the following algorithm, where the forward slash (<code>/</code>) is the integer division operator and the percent sign (<code>%</code>) is the modulo operator:</p>&#13;
<pre class="pre">quotient = N&#13;
i = 0&#13;
d<sub>i</sub> = quotient % 2&#13;
quotient = quotient / 2&#13;
While quotient != 0&#13;
    i = i + 1&#13;
    d<sub>i</sub> = quotient % 2&#13;
    quotient = quotient / 2</pre>&#13;
<p class="indent">Some programming tasks require a specific bit pattern—for example, programming a hardware device. In these cases, specifying a bit pattern rather than a numerical value is more natural. We can think of the bits in groups of four and use hexadecimal to specify each group. For example, if our algorithm required the use of zeros alternating with ones—<code>0101 0101 0101 0101 0101 0101 0101 0101</code>—we could convert this to the decimal value 431,655,765, or we could express it in hexadecimal as <code>0x55555555</code> (shown here in C/C++ syntax). Once you’ve memorized <a href="ch02.xhtml#ch2tab1">Table 2-1</a>, you’ll find it much easier to work with hexadecimal for bit patterns.</p>&#13;
<p class="indent">The discussion in these two sections has dealt only with unsigned integers. The representation of signed integers depends upon some architectural features of the CPU that we’ll discuss in <a href="ch03.xhtml">Chapter 3</a>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch2exe9">2.9     Convert the following unsigned decimal integers to their 8-bit hexadecimal representation:</p>&#13;
<p class="alpha">(a)     100</p>&#13;
<p class="alpha">(b)     123</p>&#13;
<p class="alpha">(c)     10</p>&#13;
<p class="alpha">(d)     88</p>&#13;
<span epub:type="pagebreak" id="page_17"/>&#13;
<p class="alpha">(e)     255</p>&#13;
<p class="alpha">(f)     16</p>&#13;
<p class="alpha">(g)     32</p>&#13;
<p class="alpha">(h)     128</p>&#13;
<p class="box-list1" id="ch2exe10">2.10     Convert the following unsigned decimal integers to their 16-bit hexadecimal representation:</p>&#13;
<p class="alpha">(a)     1,024</p>&#13;
<p class="alpha">(b)     1,000</p>&#13;
<p class="alpha">(c)     32,768</p>&#13;
<p class="alpha">(d)     32,767</p>&#13;
<p class="alpha">(e)     256</p>&#13;
<p class="alpha">(f)     65,535</p>&#13;
<p class="alpha">(g)     4,660</p>&#13;
<p class="alpha">(h)     43,981</p>&#13;
<p class="box-list1" id="ch2exe11">2.11     Invent a code that would allow you to store letter grades with plus or minus (that is, the grades A, A–, B+, B, B–, . . . , D, D–, F). How many bits are required for your code?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec3"><strong>Storing Data in Memory</strong></h3>&#13;
<p class="noindent">We now have the language necessary to begin discussing how data is stored in computer memory. We’ll start with how memory is organized. There are two general kinds of memory used for storing program instructions and data in a computer:</p>&#13;
<p class="noindenta"><strong>Random-access memory (RAM)</strong></p>&#13;
<p class="noindent2">Once a bit (switch) is set to either <code>0</code> or <code>1</code>, it stays in that state until the control unit actively changes it or the power is turned off. The control unit can both read and change the state of a bit.</p>&#13;
<p class="indent1">The name <em>random-access memory</em> is misleading. Here, <em>random access</em> means that it takes the same amount of time to access any byte in the memory, not that any randomness is involved when reading the byte. We contrast RAM with <em>sequential access memory (SAM)</em>, where the amount of time it takes to access a byte depends on its position in some sequence. An example of SAM is magnetic tape, which is typically used for backups, where retrieval speed is less important. The length of time it takes to access a byte depends on the physical location of the byte stored on the tape with respect to the current position of the tape.</p>&#13;
<p class="noindenta"><strong>Read-only memory (ROM)</strong></p>&#13;
<p class="noindent2">The control unit can read the state of each bit in ROM but can’t change it. You can reprogram some types of ROM with specialized hardware, but the bits remain in the new state when the power is turned off. ROM is also called <em>nonvolatile memory (NVM)</em>.</p>&#13;
<h4 class="h4" id="ch02lev2sec7"><em><strong>Memory Addresses</strong></em></h4>&#13;
<p class="noindent">Each byte in memory has a location, or address, much like the room number in an office building. The address of a specific byte never changes. That is, <span epub:type="pagebreak" id="page_18"/>the 957th byte from the beginning of memory will always be the 957th byte. However, the state (content) of each of the bits—<code>0</code> or <code>1</code>—in any given byte can be changed.</p>&#13;
<p class="indent">Computer scientists typically express the address of each byte in memory in hexadecimal, starting the numbering at zero. Thus, we would say that the 957th byte is at address <code>0x3bc</code> (= 956 in decimal).</p>&#13;
<p class="indent">The first 16 bytes in memory have the addresses <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, and <code>f</code>. Using the notation</p>&#13;
<pre class="pre"><span class="codeitalic1">&lt;address&gt;</span> : <span class="codeitalic1">&lt;content&gt;</span></pre>&#13;
<p class="noindent">we can show the contents of each of the first 16 bytes of memory, as in <a href="ch02.xhtml#ch2tab3">Table 2-3</a> (the contents here are arbitrary).</p>&#13;
<p class="tabcap" id="ch2tab3"><strong>Table 2-3:</strong> Example Contents of the First 16 Bytes of Memory</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Address</strong></th>&#13;
<th class="tab_th"><strong>Content</strong></th>&#13;
<th class="tab_th"><strong>Address</strong></th>&#13;
<th class="tab_th"><strong>Content</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0x00000000</code></td>&#13;
<td class="bg1"><code>0x6a</code></td>&#13;
<td class="bg1"><code>0x00000008</code></td>&#13;
<td class="bg1"><code>0xf0</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x00000001</code></td>&#13;
<td class="bg"><code>0xf0</code></td>&#13;
<td class="bg"><code>0x00000009</code></td>&#13;
<td class="bg"><code>0x02</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x00000002</code></td>&#13;
<td class="bg1"><code>0x5e</code></td>&#13;
<td class="bg1"><code>0x0000000a</code></td>&#13;
<td class="bg1"><code>0x33</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x00000003</code></td>&#13;
<td class="bg"><code>0x00</code></td>&#13;
<td class="bg"><code>0x0000000b</code></td>&#13;
<td class="bg"><code>0x3c</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x00000004</code></td>&#13;
<td class="bg1"><code>0xff</code></td>&#13;
<td class="bg1"><code>0x0000000c</code></td>&#13;
<td class="bg1"><code>0xc3</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x00000005</code></td>&#13;
<td class="bg"><code>0x51</code></td>&#13;
<td class="bg"><code>0x0000000d</code></td>&#13;
<td class="bg"><code>0x3c</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x00000006</code></td>&#13;
<td class="bg1"><code>0xcf</code></td>&#13;
<td class="bg1"><code>0x0000000e</code></td>&#13;
<td class="bg1"><code>0x55</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x00000007</code></td>&#13;
<td class="bg"><code>0x18</code></td>&#13;
<td class="bg"><code>0x0000000f</code></td>&#13;
<td class="bg"><code>0xaa</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The content of each byte is represented by two hexadecimal digits, which specify the exact state of the byte’s 8 bits.</p>&#13;
<p class="indent">But what can the state of the byte’s 8 bits tell us? There are two issues that a programmer needs to consider when storing data in memory:</p>&#13;
<p class="noindenta"><strong>How many bits are needed to store the data?</strong></p>&#13;
<p class="noindent2">To answer this question, we need to know how many different values are allowed for the particular data item. Look at the number of different values we can represent in <a href="ch02.xhtml#ch2tab1">Table 2-1</a> (4 bits) and <a href="ch02.xhtml#ch2tab2">Table 2-2</a> (3 bits). We can represent up to 2<em><sup>n</sup></em> different values in <em>n</em> bits. Notice, too, that we might not use all the possible bit patterns we have within an allocated space.</p>&#13;
<p class="noindenta"><strong>What is the code for storing the data?</strong></p>&#13;
<p class="noindent2">Most of the data we deal with in everyday life is not expressed in terms of zeros and ones. To store it in computer memory, the programmer must decide how to encode the data in zeros and ones.</p>&#13;
<p class="indenta">In the rest of this chapter, you’ll see how we can store characters and unsigned integers in memory using the state of the bits in one or more bytes.</p>&#13;
<span epub:type="pagebreak" id="page_19"/>&#13;
<h4 class="h4" id="ch02lev2sec8"><em><strong>Characters</strong></em></h4>&#13;
<p class="noindent">When you’re programming, you will almost always be manipulating text strings, which are arrays of characters. The first program you ever wrote was probably a “Hello, World!” program. If you wrote it in C, you used a statement like this:</p>&#13;
<pre class="pre">printf("Hello, World!\n");</pre>&#13;
<p class="noindent">Or, in C++:</p>&#13;
<pre class="pre">cout &lt; "Hello, World!" &lt; endl;</pre>&#13;
<p class="indent">When translating either of these statements into machine code, the compiler must do two things:</p>&#13;
<ul>&#13;
<li class="noindent">Store each of the characters in a location in memory where the control unit can access them.</li>&#13;
<li class="noindent">Generate the machine instructions to write the characters on the screen.</li>&#13;
</ul>&#13;
<p class="indent">We’ll start by considering how a single character is stored in memory.</p>&#13;
<h5 class="h5" id="ch02lev3sec1"><strong>Encoding Characters</strong></h5>&#13;
<p class="noindent">The most common standard for encoding characters for computer storage is <em>Unicode UTF-8</em>. It uses 1 to 4 bytes for storing a number called a <em>code point</em>, which represents a character. A Unicode code point is written as U+<em>h</em>, where <em>h</em> is four to six hexadecimal digits. The operating system and display hardware associate one or more code points with a <em>glyph</em>, which is what we see on the screen or on paper. For example, U+0041 is the code point for the Latin capital letter <em>A</em>, which has the glyph A in the font used for this book.</p>&#13;
<p class="indent">UTF-8 is backward compatible with an older standard, the <em>American Standard Code for Information Interchange</em>, or <em>ASCII</em> (pronounced “ask-ee”). ASCII uses 7 bits to specify each code point in a 128-character set, which contains the English alphabet (uppercase and lowercase), numerals, special characters, and control characters. In all of our programming in this book, we will use only the characters from the ASCII subset of UTF-8, U+0000 to U+007F.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2tab4">Table 2-4</a> shows the Unicode code points for the characters used to represent hexadecimal numbers and the corresponding 8-bit patterns that are stored in memory in our programming environment. You will have a chance to put this table to use later in the book, when you learn how to convert from the character representation of an integer to its binary representation. For now, notice that while the numeric characters are organized in a contiguous bit pattern sequence, there is a gap between them and the alphabetic characters.</p>&#13;
<span epub:type="pagebreak" id="page_20"/>&#13;
<p class="tabcap" id="ch2tab4"><strong>Table 2-4:</strong> Some UTF-8 Code Points for Hexadecimal Characters</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Code point</strong></th>&#13;
<th class="tab_th"><strong>Character description</strong></th>&#13;
<th class="tab_th"><strong>Character glyph</strong></th>&#13;
<th class="tab_th"><strong>Bit pattern</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">U+0030</td>&#13;
<td class="bg1">Digit zero</td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1"><code>0x30</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0031</td>&#13;
<td class="bg">Digit one</td>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg"><code>0x31</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0032</td>&#13;
<td class="bg1">Digit two</td>&#13;
<td class="bg1"><code>2</code></td>&#13;
<td class="bg1"><code>0x32</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0033</td>&#13;
<td class="bg">Digit three</td>&#13;
<td class="bg"><code>3</code></td>&#13;
<td class="bg"><code>0x33</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0034</td>&#13;
<td class="bg1">Digit four</td>&#13;
<td class="bg1"><code>4</code></td>&#13;
<td class="bg1"><code>0x34</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0035</td>&#13;
<td class="bg">Digit five</td>&#13;
<td class="bg"><code>5</code></td>&#13;
<td class="bg"><code>0x35</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0036</td>&#13;
<td class="bg1">Digit six</td>&#13;
<td class="bg1"><code>6</code></td>&#13;
<td class="bg1"><code>0x36</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0037</td>&#13;
<td class="bg">Digit seven</td>&#13;
<td class="bg"><code>7</code></td>&#13;
<td class="bg"><code>0x37</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0038</td>&#13;
<td class="bg1">Digit eight</td>&#13;
<td class="bg1"><code>8</code></td>&#13;
<td class="bg1"><code>0x38</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0039</td>&#13;
<td class="bg">Digit nine</td>&#13;
<td class="bg"><code>9</code></td>&#13;
<td class="bg"><code>0x39</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0061</td>&#13;
<td class="bg1">Latin small letter a</td>&#13;
<td class="bg1"><code>a</code></td>&#13;
<td class="bg1"><code>0x61</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0062</td>&#13;
<td class="bg">Latin small letter b</td>&#13;
<td class="bg"><code>b</code></td>&#13;
<td class="bg"><code>0x62</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0063</td>&#13;
<td class="bg1">Latin small letter c</td>&#13;
<td class="bg1"><code>c</code></td>&#13;
<td class="bg1"><code>0x63</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0064</td>&#13;
<td class="bg">Latin small letter d</td>&#13;
<td class="bg"><code>d</code></td>&#13;
<td class="bg"><code>0x64</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">U+0065</td>&#13;
<td class="bg1">Latin small letter e</td>&#13;
<td class="bg1"><code>e</code></td>&#13;
<td class="bg1"><code>0x65</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">U+0066</td>&#13;
<td class="bg">Latin small letter f</td>&#13;
<td class="bg"><code>f</code></td>&#13;
<td class="bg"><code>0x66</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although the hexadecimal numerical portion is the same as the bit pattern for the code points U+0000 to U+007F, this does not necessarily hold true for other characters. For example, U+00B5 is the code point for the micro sign, which is stored in memory as the 16-bit pattern <code>0xc2b5</code> and has the glyph <em>µ</em> in the font used for this book.</p>&#13;
<p class="indent">UTF-8 uses 1 byte per character to store code points U+0000 to U+007F. Bits 6 and 5 in the byte (recall that bits are numbered from right to left, starting with 0) specify the four groups of characters, shown in <a href="ch02.xhtml#ch2tab5">Table 2-5</a>. The special characters are mostly punctuation. For example, the space character is U+0020 and the semicolon character (;) is U+003B.</p>&#13;
<p class="tabcap" id="ch2tab5"><strong>Table 2-5:</strong> The Character Groups in Code Points U+0000 to U+007F</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Bit 6</strong></th>&#13;
<th class="tab_th"><strong>Bit 5</strong></th>&#13;
<th class="tab_th"><strong>Type of character</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1">Control</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0</code></td>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg">Numeric and special</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>1</code></td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1">Uppercase alphabetic and special</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg">Lowercase alphabetic and special</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can generate a table of the code points that coincide with ASCII characters by typing the command <span class="codestrong">man ascii</span> in a Linux terminal window. (You may need to install the <code>ascii</code> program on your computer.) It is quite large and not the sort of thing you would want to memorize, but it can be helpful to understand roughly how it’s organized.</p>&#13;
<span epub:type="pagebreak" id="page_21"/>&#13;
<p class="indent">You can learn more about Unicode at <em><a href="https://www.unicode.org/releases/">https://www.unicode.org/releases/</a></em>. For a more informal discussion of how Unicode came to be, I recommend Joel Spolsky’s “The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)” at <em><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/</a></em>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch2exe12">2.12     Many people use uppercase for the alphabetic hexadecimal characters. Every programming language I know about accepts either case. Redo <a href="ch02.xhtml#ch2tab4">Table 2-4</a> using the bit patterns for the uppercase hexadecimal characters.</p>&#13;
<p class="box-list1" id="ch2exe13">2.13     Create an ASCII table for the lowercase alphabetic characters.</p>&#13;
<p class="box-list1" id="ch2exe14">2.14     Create an ASCII table for the uppercase alphabetic characters.</p>&#13;
<p class="box-list1" id="ch2exe15">2.15     Create an ASCII table for the punctuation marks.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch02lev3sec2"><strong>Storing a Text String</strong></h5>&#13;
<p class="noindent">Getting back to <code>Hello, World!\n</code>, the compiler stores this text string as a constant array of characters. To specify the extent of this array, a C-style string uses the code point U+0000 (ASCII <code>NUL</code>) at the end of the string as a <em>sentinel</em> value, which is a unique value that indicates the end of a sequence of characters. Thus, the compiler must allocate 15 bytes for this string: 13 for <code>Hello, World!</code>, 1 for the newline <code>\n</code>, and 1 for the <code>NUL</code>. <a href="ch02.xhtml#ch2tab6">Table 2-6</a> shows how this text string would be stored starting at location <code>0x4004a1</code> in memory.</p>&#13;
<p class="tabcap" id="ch2tab6"><strong>Table 2-6:</strong> <code>Hello, World!\n</code> Stored in Memory</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Address</strong></th>&#13;
<th class="tab_th"><strong>Content</strong></th>&#13;
<th class="tab_th"><strong>Address</strong></th>&#13;
<th class="tab_th"><strong>Content</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0x4004a1</code></td>&#13;
<td class="bg1"><code>0x48</code></td>&#13;
<td class="bg1"><code>0x4004a9</code></td>&#13;
<td class="bg1"><code>0x6f</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x4004a2</code></td>&#13;
<td class="bg"><code>0x65</code></td>&#13;
<td class="bg"><code>0x4004aa</code></td>&#13;
<td class="bg"><code>0x72</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x4004a3</code></td>&#13;
<td class="bg1"><code>0x6c</code></td>&#13;
<td class="bg1"><code>0x4004ab</code></td>&#13;
<td class="bg1"><code>0x6c</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x4004a4</code></td>&#13;
<td class="bg"><code>0x6c</code></td>&#13;
<td class="bg"><code>0x4004ac</code></td>&#13;
<td class="bg"><code>0x64</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x4004a5</code></td>&#13;
<td class="bg1"><code>0x6f</code></td>&#13;
<td class="bg1"><code>0x4004ad</code></td>&#13;
<td class="bg1"><code>0x21</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x4004a6</code></td>&#13;
<td class="bg"><code>0x2c</code></td>&#13;
<td class="bg"><code>0x4004ae</code></td>&#13;
<td class="bg"><code>0x0a</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x4004a7</code></td>&#13;
<td class="bg1"><code>0x20</code></td>&#13;
<td class="bg1"><code>0x4004af</code></td>&#13;
<td class="bg1"><code>0x00</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x4004a8</code></td>&#13;
<td class="bg"><code>0x57</code></td>&#13;
<td class="bg">—</td>&#13;
<td class="bg">—</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">C uses U+000A (ASCII <code>LF</code>) as a newline character (at address <code>0x4004ae</code> in this example), even though the C syntax requires that the programmer write two characters, <code>\n</code>. The text string ends with the <code>NUL</code> character at <code>0x4004af</code>.</p>&#13;
<p class="indent">In Pascal, another programming language, the length of a string is specified by the first byte in the string, which is taken to be an 8-bit unsigned integer. (This is the reason for the 256-character limit on text strings in Pascal.) <span epub:type="pagebreak" id="page_22"/>The C++ string class has additional features, but the actual text string is stored as a C-style text string within the C++ string instance.</p>&#13;
<h4 class="h4" id="ch02lev2sec9"><em><strong>Unsigned Integers</strong></em></h4>&#13;
<p class="noindent">Since an unsigned integer can be expressed in any radix, probably the most obvious way to store it is to use the binary number system. If we number the bits in a byte from right to left, then the lowest-order bit would be stored in bit 0, the next in bit 1, and so forth. For example, the integer 123<sub>10</sub> = <code>7b</code><sub>16</sub>, so the state of the byte where it is stored would be <code>01111011</code><sub>2</sub>. Using only a single byte restricts the range of unsigned integers to be from 0 to 255<sub>10</sub>, since <code>ff</code><sub>16</sub> = 255<sub>10</sub>. The default size for an unsigned integer in our programming environment is 4 bytes, which allows for a range of 0 to 4,294,967,295<sub>10</sub>.</p>&#13;
<p class="indent">One limitation of using the binary number system is that you need to convert a decimal number from a character string to the binary number system before performing arithmetic operations on it. For example, the decimal number 123 would be stored in character string format as the four bytes <code>0x31</code>, <code>0x32</code>, <code>0x33</code>, and <code>0x00</code>, while in unsigned integer format, it would be stored as the 4-byte binary number <code>0x0000007b</code>. At the other end, binary numbers need to be converted to their decimal character representations for most real-world display purposes.</p>&#13;
<p class="indent"><em>Binary coded decimal (BCD)</em> is another code for storing integers. It uses 4 bits for each decimal digit, as shown in <a href="ch02.xhtml#ch2tab7">Table 2-7</a>.</p>&#13;
<p class="tabcap" id="ch2tab7"><strong>Table 2-7:</strong> Binary Coded Decimal</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Decimal digit</strong></th>&#13;
<th class="tab_th"><strong>BCD code</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1"><code>0000</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg"><code>0001</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1"><code>0010</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">3</td>&#13;
<td class="bg"><code>0011</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">4</td>&#13;
<td class="bg1"><code>0100</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">5</td>&#13;
<td class="bg"><code>0101</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">6</td>&#13;
<td class="bg1"><code>0110</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">7</td>&#13;
<td class="bg"><code>0111</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">8</td>&#13;
<td class="bg1"><code>1000</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">9</td>&#13;
<td class="bg"><code>1001</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, in a 16-bit storage location, the decimal number 1,234 would be stored in BCD as <code>0001 0010 0011 0100</code> (in the binary number system, it would be <code>0000 0100 1101 0010</code>).</p>&#13;
<p class="indent">With only 10 of the possible 16 combinations being used, six bit patterns are wasted. This means that a 16-bit storage location has a range of 0 to 9,999 for values if we use BCD, compared to a range of 0 to 65,535 if we use binary. This is a less efficient use of memory. On the other hand, the conversions between a character format and an integer format are simpler with BCD, as you will learn in <a href="ch16.xhtml">Chapter 16</a>.</p>&#13;
<span epub:type="pagebreak" id="page_23"/>&#13;
<p class="indent">BCD is important in specialized systems that deal primarily with numerical business data, because they tend to print numbers more often than they perform mathematical operations on them. COBOL, a programming language intended for business applications, supports a packed BCD format where two digits (in BCD code) are stored in each 8-bit byte. Here, the <em>last</em> (4-bit) digit is used to store the sign of the number, as shown in <a href="ch02.xhtml#ch2tab8">Table 2-8</a>. The specific codes used depend upon the implementation.</p>&#13;
<p class="tabcap" id="ch2tab8"><strong>Table 2-8:</strong> Example Sign Codes for Packed BCD Format</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Sign</strong></th>&#13;
<th class="tab_th"><strong>Sign code</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">+</td>&#13;
<td class="bg1"><code>1010</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">–</td>&#13;
<td class="bg"><code>1011</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">+</td>&#13;
<td class="bg1"><code>1100</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">–</td>&#13;
<td class="bg"><code>1101</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">+</td>&#13;
<td class="bg1"><code>1110</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Unsigned</td>&#13;
<td class="bg"><code>1111</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, <code>0001 0010 0011 1010</code> represents +123, <code>0001 0010 0011 1011</code> represents –123, and <code>0001 0010 0011 1111</code> represents 123.</p>&#13;
<p class="indent">Next, we’ll explore some of these concepts using the C programming language. If you’re new to C, this discussion will provide an introduction to the language.</p>&#13;
<h3 class="h3" id="ch02lev1sec4"><strong>Exploring Data Formats with C</strong></h3>&#13;
<p class="noindent">In this section, we’ll write our first programs with the C programming language. These particular programs illustrate the differences between how numbers are stored in memory and how we humans read them. C allows us to get close enough to the hardware to understand the core concepts, while taking care of many of the low-level details. You shouldn’t find the simple C programs in this book too difficult, especially if you already know how to program in another language.</p>&#13;
<p class="indent">If you learned how to program in a higher-level language, such as C++, Java, or Python, you probably learned object-oriented programming. C doesn’t support the object-oriented paradigm; it is a <em>procedural</em> programming language. C programs are divided into <em>functions</em>, where a function is a named group of programming statements. Other programming languages also use the terms <em>procedure</em> and <em>subprogram</em>, with some minor distinctions between them depending on the language.</p>&#13;
<h4 class="h4" id="ch02lev2sec10"><em><strong>Using C and C++ I/O Libraries</strong></em></h4>&#13;
<p class="noindent">Most high-level programming languages include a standard library that can be thought of as part of the language. A <em>standard library</em> contains functions and data structures that can be used in the language for doing common <span epub:type="pagebreak" id="page_24"/>things such as terminal I/O (writing to the screen and reading from the keyboard). C includes the <em>C standard library</em> and C++ includes the <em>C++ standard library</em>.</p>&#13;
<p class="indent">C programmers use functions in the <code>stdio</code> library for terminal I/O, while C++ programmers use functions in the <code>iostream</code> library. For example, the C code sequence for reading an integer from the keyboard, adding 100 to it, and writing the result to the screen looks like this:</p>&#13;
<pre class="pre">int x;&#13;
scanf("%i", &amp;x);&#13;
x += 100;&#13;
printf("%i", x);</pre>&#13;
<p class="noindent">The C++ code sequence looks something like this:</p>&#13;
<pre class="pre">int x;&#13;
cin &lt;&lt; x;&#13;
x +=100;&#13;
cout &lt;&lt; x;</pre>&#13;
<p class="indent">In both examples, the code reads characters (each as a separate <code>char</code>) from the keyboard and converts the <code>char</code> sequence into the corresponding <code>int</code> format. Then, it adds 100 to the <code>int</code> before converting the result into a <code>char</code> sequence and displaying it on the screen. The C or C++ I/O library functions in the previous code snippets do the necessary conversions between <code>char</code> sequences and the <code>int</code> storage format.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig1">Figure 2-1</a> shows the relationship between a C application program, the I/O libraries, and the operating system.</p>&#13;
<div class="image"><img id="ch2fig1" src="../images/pg52_Image_17.jpg" alt="Image" width="250" height="321"/></div>&#13;
<p class="figcap"><em>Figure 2-1: The relationship of I/O libraries to the application and the operating system</em></p>&#13;
<p class="indent">When reading from the keyboard, the <code>scanf</code> library function first calls the <code>read</code> <em>system call</em> function, a function in the operating system, to read <span epub:type="pagebreak" id="page_25"/>characters from the keyboard. The input on the keyboard is in the form of a string of characters, each of the <code>char</code> data type. The <code>scanf</code> library function performs the conversion of this string to the <code>int</code> data type for the application program. The <code>printf</code> library function converts from the <code>int</code> data type to the corresponding string of characters in the <code>char</code> data type and calls the <code>write</code> system call function to write each character to the screen.</p>&#13;
<p class="indent">In <a href="ch02.xhtml#ch2fig1">Figure 2-1</a>, an application program can call the <code>read</code> and <code>write</code> functions directly to transfer characters. We’ll explore this in <a href="ch16.xhtml">Chapter 16</a>, where we’ll write our own conversion functions. Although the C/C++ library functions do a much better job of this than we will, the exercise of doing it yourself will give you a better understanding of how data is stored in memory and manipulated by software.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Even if you’re familiar with the GNU</em> <span class="codeitalic">make</span> <em>program, it’s worth learning how to use it to build your programs. It may seem like overkill at this point, but it’s much easier to learn with simple programs. The manual is available in several formats at</em> <a href="https://www.gnu.org/software/make/manual/">https://www.gnu.org/software/make/manual/</a><em>, and my comments about using it are available on my website at</em> <a href="https://rgplantz.github.io">https://rgplantz.github.io</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec11"><em><strong>Writing and Executing Your First C Program</strong></em></h4>&#13;
<p class="noindent">Most programming books start with a simple program that just prints “Hello, World!” to a computer screen, but we’ll start with a program that reads a hexadecimal value, both as an unsigned integer and as a text string (<a href="ch02.xhtml#ch2list1">Listing 2-1</a>).</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>int_and_string.c</em></p>&#13;
</div>&#13;
<pre class="pre"><span class="ent">➊</span> // Read and display an integer and a text string.&#13;
&#13;
<span class="ent">➋</span> #include &lt;stdio.h&gt;&#13;
&#13;
   int main(void)&#13;
   {&#13;
    <span class="ent">➌</span> unsigned int an_int;&#13;
       char a_string[10];&#13;
&#13;
    <span class="ent">➍</span> printf("Enter a number in hexadecimal: ");&#13;
    <span class="ent">➎</span> scanf("%x", &amp;an_int);&#13;
       printf("Enter it again: ");&#13;
    <span class="ent">❻</span> scanf("%s", a_string);&#13;
    <span class="ent">❼</span> printf("The integer is %u and the string is %s\n", an_int, a_string);&#13;
&#13;
    <span class="ent">❽</span> return 0;&#13;
   }</pre>&#13;
<p class="list" id="ch2list1"><em>Listing 2-1: A program showing the difference between an integer and a text string</em></p>&#13;
<p class="indent">We start our code with some documentation that gives a brief description of what the program does <span class="ent">❶</span>. When writing your own source files, you <span epub:type="pagebreak" id="page_26"/>should also include your name and the date they were written as part of the documentation (I’ve omitted them in the example programs in this book to save space). All text following two slash characters, <code>//</code>, on a line is a comment. C also allows us to start a multiple-line comment using <code>/*</code> and end it using <code>*/</code>. Comments are for the human reader and have no effect on the program itself.</p>&#13;
<p class="indent">The first operation that actually affects the program is the inclusion of a <em>header file</em>, <em>stdio.h</em> <span class="ent">❷</span>, using the <code>#include</code> directive. As you will learn, the C compiler needs to know the type of each data item that is passed to or from a function. A header file is used to provide a <em>prototype statement</em> for each function, which specifies these data types. The <em>stdio.h</em> header file defines the interface to many of the functions in the C standard library, which tells the compiler what to do when calls to any of these functions are encountered in our source code. The <em>stdio.h</em> header file is already installed on your computer in a location the compiler knows.</p>&#13;
<p class="indent">The remaining code in this listing is the definition of a C <code>main</code> function. All C programs are made up of functions, which have this general format:</p>&#13;
<pre class="pre"><span class="codeitalic1">return-data-type function-name</span>(<span class="codeitalic1">parameter-list</span>)&#13;
{&#13;
    <span class="codeitalic1">function-body</span>&#13;
}</pre>&#13;
<p class="indent">When a C program is executed, the operating system first sets up either a <em>hosted environment</em> or a <em>freestanding environment</em>, which sets up the resources on your computer to run the program. The hosted environment includes access to the functions in the C standard library, while the freestanding environment does not. Most of the programs in this book run in the hosted environment. I’ll show you how to use the freestanding environment in “Supervisor Calls” on <a href="ch21.xhtml#ch21lev1sec5">page 474</a> in <a href="ch21.xhtml">Chapter 21</a>.</p>&#13;
<p class="indent">In the C hosted environment, program execution starts with the <code>main</code> function, meaning that the program you write must include a function whose function name is <code>main</code>. The <code>main</code> function can call other functions, which in turn can call other functions. But program control normally ends up back in the <code>main</code> function, which then returns to the C hosted environment.</p>&#13;
<p class="indent">When a function is called in C, the calling function can include a list of <em>arguments</em> in the call as inputs to the called function. These inputs serve as <em>parameters</em> in the computation performed by the called function. For example, in <a href="ch02.xhtml#ch2list1">Listing 2-1</a>, when the program first starts, the <code>main</code> function calls the <code>printf</code> function with one argument, a text string <span class="ent">❹</span>. The <code>printf</code> function uses the text string to determine what to display on the screen. We’ll look closely at how arguments are passed to functions and how they’re used as parameters in the function in <a href="ch14.xhtml">Chapter 14</a>. The <code>main</code> function in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> does not need any data from the C hosted environment; we show this in its definition by using <code>void</code> for the parameter list.</p>&#13;
<p class="indent">Upon completing execution, a function normally returns to the calling function. The called function can pass a data item to the calling function when returning. A <code>main</code> function should return a single integer to the C <span epub:type="pagebreak" id="page_27"/>hosted environment, indicating whether the program detected any errors in its execution. Thus, the <span class="codeitalic">return-data-type</span> for <code>main</code> is <code>int</code>. The <code>main</code> function in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> returns the integer 0 to the C hosted environment, which passes this value to the operating system.</p>&#13;
<p class="indent">In <a href="ch02.xhtml#ch2list1">Listing 2-1</a>, we define two variables in the <code>main</code> function at the beginning of the function body: an unsigned integer named <code>an_int</code> and a text string named <code>a_string</code> <span class="ent">❸</span>. Most modern programming languages allow us to introduce new variables anywhere in the code, but C requires that they be listed at the beginning of the function. (There are some exceptions to this rule, but they are beyond the scope of this book.) Think of it as listing the ingredients for a recipe before giving the instructions on how to use them. We <em>define</em> a variable by introducing its name and specifying its data type. The <code>[10]</code> notation tells the compiler to allocate an array of 10 <code>char</code>s for the <code>a_string</code> variable, which will allow us to store a C-style text string up to nine characters long. (The 10th <code>char</code> would be the terminating <code>NUL</code> character.) We’ll look at arrays in detail in <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="indent">The program uses the <code>printf</code> function from the C standard library to display text on the screen. The first argument in the call to <code>printf</code> is a <em>format string</em>, which is a text string made up of ordinary characters (except <code>%</code>) to display on the screen.</p>&#13;
<p class="indent">The simplest format string for <code>printf</code> is just the text you want printed, without any variables. If you want to print the values of variables, the format string acts as a template of the text you want printed. The place in the text string where you want the value of a variable to be printed is marked with a <em>conversion specifier</em>. Each conversion specifier begins with the <code>%</code> character, and the names of the variables are listed after the format string in the same order that their respective conversion specifiers appear in the template <span class="ent">❼</span>.</p>&#13;
<p class="indent">The <code>%</code> character that begins a conversion specifier is immediately followed by one or more conversion code characters to tell <code>printf</code> how to display the value of the variable. <a href="ch02.xhtml#ch2tab9">Table 2-9</a> shows some common conversion specifiers for <code>printf</code> and <code>scanf</code> format strings.</p>&#13;
<p class="tabcap" id="ch2tab9"><strong>Table 2-9:</strong> Some Common Conversion Specifiers</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:55%"/>&#13;
<col style="width:45%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Conversion specifier</strong></th>&#13;
<th class="tab_th"><strong>Representation</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>%u</code></td>&#13;
<td class="bg1">Unsigned decimal integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>%d</code> or <code>%i</code></td>&#13;
<td class="bg">Signed decimal integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>%f</code></td>&#13;
<td class="bg1">Float</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>%x</code></td>&#13;
<td class="bg">Hexadecimal</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>%s</code></td>&#13;
<td class="bg1">Text string</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The conversion specifiers can include other characters that specify properties, such as the field width of the display, whether the value is left-or right-justified within the field, and more. I won’t go into additional detail here; read man <a href="ch01.xhtml#page_3">page 3</a> for <code>printf</code> to learn more (enter the <span class="codestrong">man 3 printf</span> command to view the man page).</p>&#13;
<span epub:type="pagebreak" id="page_28"/>&#13;
<p class="indent">The first argument in the call to the C standard library function <code>scanf</code> is also a format string. We use the same conversion specifiers in the format string to tell the <code>scanf</code> function how to interpret the characters typed on the keyboard <span class="ent">❺</span>. We tell <code>scanf</code> where to store the input integer by using the <em>address of</em> operator on the variable name, <code>&amp;an_int</code>. When passing the name of an array to a function, C sends the address of the array, so we don’t use the <code>&amp;</code> operator when calling <code>scanf</code> to read a text string from the keyboard <span class="ent">❻</span>.</p>&#13;
<p class="indent">Any other character included in the format string for <code>scanf</code> besides these conversion specifiers must be matched exactly by the keyboard input. For example, the format string</p>&#13;
<pre class="pre">scanf("1 %i and 2 %i", &amp;one_int, &amp;two_int);</pre>&#13;
<p class="noindent">requires an input like</p>&#13;
<pre class="pre"><span class="codestrong1">1 123 and 2 456</span></pre>&#13;
<p class="noindent">which would read the integers 123 and 456 from the keyboard. You can read man <a href="ch01.xhtml#page_3">page 3</a> for <code>scanf</code> to learn more (enter the <span class="codestrong">man 3 scanf</span> command).</p>&#13;
<p class="indent">Finally, the <code>main</code> function returns 0 to the C hosted environment, which passes this value to the operating system. The value 0 tells the operating system that everything went smoothly <span class="ent">❽</span>.</p>&#13;
<p class="indent">Compiling and running the program in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> on my computer gave the following output:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -Wall -o int_and_string int_and_string.c</span>&#13;
$ <span class="codestrong1">./int_and_string</span>&#13;
Enter a hexadecimal value: <span class="codestrong1">123abc</span>&#13;
Enter it again: <span class="codestrong1">123abc</span>&#13;
The integer is 1194684 and the string is 123abc&#13;
$</pre>&#13;
<p class="indent">The program in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> demonstrates an important concept: hexadecimal is used as a human convenience for stating bit patterns. A number is not inherently binary, decimal, or hexadecimal; it’s simply a value. And a specific value can be expressed equivalently in each of these three number bases. For that matter, it can be expressed equivalently in <em>any</em> number base (2, 16, 285, and so forth), but since a computer consists of binary switches, it makes sense to think of numerical values stored in a computer in terms of the binary number base.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch2exe16">2.16     Write a hexadecimal-to-decimal converter program in C. Your program will allow a user to enter a number in hexadecimal and will then print the decimal equivalent. The output should look like this: <code>0x7b = 123</code>.</p>&#13;
<span epub:type="pagebreak" id="page_29"/>&#13;
<p class="box-list1" id="ch2exe17">2.17     Write a decimal-to-hexadecimal converter program in C. Your program will allow a user to enter a number in decimal and will then print the hexadecimal equivalent. The output should look like this: <code>123 = 0x7b</code>.</p>&#13;
<p class="box-list1" id="ch2exe18">2.18     Change <code>%u</code> to <code>%i</code> in the last <code>printf</code> statement in the program in <a href="ch02.xhtml#ch2list1">Listing 2-1</a>. What does the program print if you enter <code>ffffffff</code>?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec5"><strong>Examining Memory with a Debugger</strong></h3>&#13;
<p class="noindent">Now that we’ve started writing programs, you’ll need to learn how to use the GNU debugger, <code>gdb</code>. A <em>debugger</em> is a program that allows you to run your program while you observe and control its behavior. When you use a debugger, it’s a little like you’re a puppeteer and your program is a carefully controlled puppet. Your main instrument of control is the <em>breakpoint</em>; when you set a breakpoint and your program reaches it while running, the program will pause and return control to the debugger. When control is with the debugger, you can look at the values stored in your program’s variables, which can help you figure out where any bugs are.</p>&#13;
<p class="indent">If all this seems premature—our programs so far are simple and don’t seem to require debugging—I promise that it’s much better to learn how to use a debugger on a simple example than on a complicated program that does not work. <code>gdb</code> is also a valuable tool for learning the material in this book, even when you write bug-free programs. In the following <code>gdb</code> session dialog, I’ll show you how to determine where a variable is stored in memory and how to see what is stored there, both in decimal and in hexadecimal. You will see how to use <code>gdb</code> on a live program to illustrate the concepts discussed on the previous pages.</p>&#13;
<p class="indent">You’ll see more in <a href="ch09.xhtml">Chapters 9</a> and <a href="ch10.xhtml">10</a>, but the <code>gdb</code> commands listed here should be enough to get you started:</p>&#13;
<p class="noindentin"><span class="codestrong">b</span> <span class="codestrongitalic">source_filename</span><span class="codestrong">:</span><span class="codestrongitalic">line_number</span>   Set a breakpoint at the specified <span class="codeitalic">line_number</span> in the source file, <span class="codeitalic">source_filename</span>. The code will stop running at the breakpoint, when <span class="codeitalic">line_number</span> is encountered, and return control to <code>gdb</code>, allowing you to test various elements of the code.</p>&#13;
<p class="noindentin"><span class="codestrong">c</span>   Continue program execution from the current location.</p>&#13;
<p class="noindentin"><span class="codestrong">h</span> <span class="codestrongitalic">command</span>   Get help on how to use <span class="codeitalic">command</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">i r</span>   Show the contents of the registers (<em>info registers</em>). (You’ll learn about CPU registers in <a href="ch09.xhtml">Chapter 9</a>.)</p>&#13;
<p class="noindentin"><span class="codestrong">l</span> <span class="codestrongitalic">line_number</span>   List 10 lines of the source code, centered at the specified <span class="codeitalic">line_number</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">print</span> <span class="codestrongitalic">expression</span>   Evaluate <span class="codeitalic">expression</span> and print the value.</p>&#13;
<span epub:type="pagebreak" id="page_30"/>&#13;
<p class="noindentin"><span class="codestrong">printf "</span><span class="codestrongitalic">format</span><span class="codestrong">",</span> <span class="codestrongitalic">var1</span><span class="codestrong">,</span> <span class="codestrongitalic">var2</span><span class="codestrong">, ...,</span> <span class="codestrongitalic">varn</span>   Display the values of <span class="codeitalic">var1</span><code>,</code> <span class="codeitalic">var2</span><code>, ...,</code> <span class="codeitalic">varn</span> in a given format. The <code>"</code><span class="codeitalic">format</span> <code>"</code> string follows the same rules as for <code>printf</code> in the C standard library.</p>&#13;
<p class="noindentin"><span class="codestrong">r</span>   Run a program that has been loaded under the control of <code>gdb</code>.</p>&#13;
<p class="noindentin"><span class="codestrong">x/</span><span class="codestrongitalic">nfs memory_address</span>   Display (examine) <span class="codeitalic">n</span> values in memory in format <span class="codeitalic">f</span> of size <span class="codeitalic">s</span> starting at <span class="codeitalic">memory_address</span>.</p>&#13;
<h4 class="h4" id="ch02lev2sec12"><em><strong>Using Your Debugger</strong></em></h4>&#13;
<p class="noindent">Let’s walk through the program in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> using <code>gdb</code> to explore some of the concepts covered thus far. Follow along on your computer as you read this; it’s much easier to understand <code>gdb</code> when you’re using it. Note that the addresses you see on your computer will probably be different than those in this example.</p>&#13;
<p class="indent">I’ll start by compiling the program using the <code>gcc</code> command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -g -Wall -o int_and_string int_and_string.c</span></pre>&#13;
<p class="indent">The <code>-g</code> option tells the compiler to include debugger information in the executable program. The <code>-Wall</code> option tells the compiler to issue warnings about things in your code that are correct C code but still might not be what you intended to write. For example, it will warn you about declaring a variable in your function that is never used, which could mean you’ve forgotten something.</p>&#13;
<p class="indent">The <code>-o</code> option specifies the name of the output file, which is the executable program.</p>&#13;
<p class="indent">Having compiled the program, I can run it under the control of <code>gdb</code> using this command:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gdb ./int_and_string</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
Reading symbols from ./int_and_string...&#13;
(gdb) <span class="codestrong1">l</span>&#13;
1       // Read and display an integer and a text string.&#13;
2&#13;
3       #include &lt;stdio.h&gt;&#13;
4&#13;
5       int main(void)&#13;
6       {&#13;
7           unsigned int an_int;&#13;
8           char a_string[10];&#13;
9&#13;
10          printf("Enter a number in hexadecimal: ");&#13;
(gdb)&#13;
11          scanf("%x", &amp;an_int);&#13;
12          printf("Enter it again: ");&#13;
13          scanf("%s", a_string);&#13;
14          <span epub:type="pagebreak" id="page_31"/>&#13;
15          printf("The integer is %u and the string is %s\n", an_int, a_string);&#13;
16&#13;
17          return 0;&#13;
18      }&#13;
(gdb)</pre>&#13;
<p class="indent">The <code>gdb</code> startup message, which I’ve removed from the previous output to save space, contains information about your debugger and refers you to its usage documentation.</p>&#13;
<p class="indent">The <code>l</code> command lists 10 lines of source code and then returns control to the <code>gdb</code> program, as shown by the <code>(gdb)</code> prompt. Press <small>ENTER</small> to repeat the previous command, and <code>l</code> displays the next (up to) 10 lines.</p>&#13;
<p class="indent">A breakpoint is used to stop the program and return control to the debugger. I like to set breakpoints where a function is about to call another function so I can examine the values in the argument variables before they are passed to the called function. This <code>main</code> function calls <code>printf</code> on line 15, so I set a breakpoint there. Since I’m already looking at the source code where I want to set a breakpoint, I don’t need to specify the filename:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">b 15</span>&#13;
Breakpoint 1 at 0x80c: file int_and_string.c, line 15.</pre>&#13;
<p class="indent">If <code>gdb</code> ever gets to this statement while executing the program, it will pause <em>before the statement is executed</em> and return control to the debugger.</p>&#13;
<p class="indent">Having set my breakpoint, I run the program:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/bob/progs/chapter_02/int_and_string/int_and_string&#13;
Enter a hexadecimal value: <span class="codestrong1">123abc</span>&#13;
Enter it again: <span class="codestrong1">123abc</span>&#13;
&#13;
Breakpoint 1, main () at int_and_string.c:15&#13;
15   printf("The integer is %u and the string is %s\n", an_int, a_string);</pre>&#13;
<p class="indent">The <code>r</code> command starts executing the program from the beginning. When the program reaches the breakpoint, control returns to <code>gdb</code>, which displays the next program statement that is ready to be executed. Before continuing execution, I display the contents of the two variables that are being passed to the <code>printf</code> function:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print an_int</span>&#13;
$1 = 1194684&#13;
(gdb) <span class="codestrong1">print a_string</span>&#13;
$2 = "123abc\000\000\000"</pre>&#13;
<p class="indent">We can use the <code>print</code> command to display the value currently stored in a variable. <code>gdb</code> knows the data type of each variable from the source code. It displays <code>int</code> variables in decimal. When displaying <code>char</code> variables, <code>gdb</code> will do its best to display the character glyph corresponding to the code point value. When there is no corresponding character glyph, <code>gdb</code> shows the code <span epub:type="pagebreak" id="page_32"/>point as a <code>\</code> followed by three <em>octal</em> digits (see <a href="ch02.xhtml#ch2tab2">Table 2-2</a>). For example, there is no character glyph for <code>NUL</code>, so <code>gdb</code> shows <code>\000</code> at the end of the text string I entered.</p>&#13;
<p class="indent">The <code>printf</code> command can format the displayed values. The formatting string is the same as for the <code>printf</code> function in the C standard library:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">printf "an_int = %u = %#x\n", an_int, an_int</span>&#13;
an_int = 1194684 = 0x123abc&#13;
(gdb) <span class="codestrong1">printf "a_string = %s\n", a_string</span>&#13;
a_string = 123abc</pre>&#13;
<p class="indent"><code>gdb</code> provides another command, <code>x</code>, for examining the content of memory (that is, the actual bit patterns) directly. Its help message is brief, but it tells you everything you need to know:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">help x</span>&#13;
Examine memory: x/FMT ADDRESS.&#13;
ADDRESS is an expression for the memory address to examine.&#13;
FMT is a repeat count followed by a format letter and a size letter.&#13;
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),&#13;
 t(binary), f(float), a(address), i(instruction), c(char) and s(string).&#13;
Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).&#13;
The specified number of objects of the specified size are printed&#13;
according to the format.&#13;
Defaults for format and size letters are those previously used.&#13;
Default count is 1. Default address is following last thing printed&#13;
with this command or "print".</pre>&#13;
<p class="indent">The <code>x</code> command needs the address of the area of memory to show. We can use the <code>print</code> command to find the address of a variable:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print &amp;an_int</span>&#13;
$3 = (unsigned int *) 0x7fffffef7c</pre>&#13;
<p class="indent">We can use the <code>x</code> command to display the content of <code>an_int</code> in three different ways—one decimal word (<code>1dw</code>), one hexadecimal word (<code>1xw</code>), and four hexadecimal bytes (<code>4xb</code>)—as follows:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">x/1dw 0x7fffffef7c</span>&#13;
0x7fffffef7c: 1194684 &#13;
(gdb) <span class="codestrong1">x/1xw 0x7fffffef7c</span>&#13;
0x7fffffef7c: 0x00123abc&#13;
(gdb) <span class="codestrong1">x/4xb 0x7fffffef7c</span>&#13;
0x7fffffef7c: <span class="ent">❶</span> 0xbc  0x3a     0x12     0x00</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The size of a</em> word <em>depends upon the computer environment you are using. In our environment, it’s 4 bytes.</em></p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_33"/>&#13;
<p class="indent">The display of these four bytes may look out of order to you. The first byte <span class="ent">❶</span> is located at the address shown on the left of the row. The next byte in the row is at the subsequent address, <code>0x7fffffef7d</code>. So, this row displays each of the bytes stored at the memory addresses <code>0x7fffffef7c</code>, <code>0x7fffffef7d</code>, <code>0x7fffffef7e</code>, and <code>0x7fffffef7f</code>, reading from left to right, that make up the variable <code>an_int</code>. When displaying these same four bytes separately, the least significant byte appears <em>first</em> in memory. This is called <em>little-endian</em> storage order; I’ll explain further after this tour of <code>gdb</code>.</p>&#13;
<p class="indent">We can also display the content of the <code>a_string</code> variable by first getting its address:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print &amp;a_string</span>&#13;
$4 = (char (*)[10]) 0x7fffffef70</pre>&#13;
<p class="indent">Next, we’ll look at the content of <code>a_string</code> in two ways, as 10 characters (<code>10c</code>) and as 10 hexadecimal bytes (<code>10xb</code>):</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">x/10c 0x7fffffef70</span>&#13;
0x7fffffef70:   49 '1'  50 '2'  51 '3'  97 'a'  98 'b'  99 'c'  0 '\000'  0 '\000'&#13;
0x7fffffef78:   0 '\000'  0 '\000'&#13;
(gdb) <span class="codestrong1">x/10xb 0x7fffffef70</span>&#13;
0x7fffffef70:   0x31    0x32    0x33    0x61    0x62    0x63    0x00    0x00&#13;
0x7fffffef78:   0x00    0x00</pre>&#13;
<p class="indent">The character display shows the code point in decimal and the character glyph for each character. The hexadecimal byte display shows only the code point in hexadecimal for each byte. Both displays show the <code>NUL</code> character that marks the end of the six-character string we entered. Since we asked for a 10-byte display, the remaining 3 bytes have random values not related to our text string, often called <em>garbage values</em>.</p>&#13;
<p class="indent">Finally, I continue execution of the program and then quit <code>gdb</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
The integer is 1194684 and the string is 123abc&#13;
[Inferior 1 (process 2289) exited normally]&#13;
(gdb) <span class="codestrong1">q</span>&#13;
$</pre>&#13;
<h4 class="h4" id="ch02lev2sec13"><em><strong>Understanding Byte Storage Order in Memory</strong></em></h4>&#13;
<p class="noindent">The difference between the full 4-byte display and the 1-byte display of the integer value at <code>0x7fffffef7c</code> in memory illustrates a concept known as <em>endianness</em>, or byte storage order. We usually read numbers from left to right. The digits to the left have more significance (count for more) than the digits to the right.</p>&#13;
<span epub:type="pagebreak" id="page_34"/>&#13;
<h5 class="h5" id="ch02lev3sec3"><strong>Little-Endian</strong></h5>&#13;
<p class="noindent">Data is stored in memory with the <em>least</em> significant byte in a multiple-byte value in the lowest-numbered address. That is, the “littlest” byte (counts the least) comes first in memory.</p>&#13;
<p class="indent">When we examine memory one byte at a time, each byte is displayed in numerically ascending addresses:</p>&#13;
<pre class="pre">0x7fffffef7c: 0xbc&#13;
0x7fffffef7d: 0x3a&#13;
0x7fffffef7e: 0x12&#13;
0x7fffffef7f: 0x00</pre>&#13;
<p class="indent">At first glance, the value appears to be stored backward, because the least significant (“little end”) byte of the value is stored first in memory. When we command <code>gdb</code> to display the entire 4-byte value, it knows that ours is a little-endian environment, and it rearranges the display of the bytes in the proper order:</p>&#13;
<pre class="pre">0x7fffffef7c: 0x00123abc</pre>&#13;
<h5 class="h5" id="ch02lev3sec4"><strong>Big-Endian</strong></h5>&#13;
<p class="noindent">Data is stored in memory with the <em>most</em> significant byte in a multiple-byte value in the lowest-numbered address. That is, the “biggest” byte (counts the most) comes first in memory.</p>&#13;
<p class="indent">If we ran the previous program on a big-endian computer, such as one using the PowerPC architecture, we would see the following (assuming the variable is located at the same address):</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">x/1xw 0x7fffffef7c</span>&#13;
0x7ffffff2ec: 0x00123abc&#13;
(gdb) <span class="codestrong1">x/4xb 0x7fffffef7c</span>   <span class="codeitalic1">[BIG-ENDIAN COMPUTER, NOT OURS!]</span>&#13;
0x7ffffff2ec: 0x00 0x12 0x3a 0xbc</pre>&#13;
<p class="indent">That is, the 4 bytes in a big-endian computer would be stored as:</p>&#13;
<pre class="pre">0x7fffffef7c: 0x00&#13;
0x7fffffef7d: 0x12&#13;
0x7fffffef7e: 0x3a&#13;
0x7fffffef7f: 0xbc</pre>&#13;
<p class="indent">Again, <code>gdb</code> would know that this is a big-endian computer and so would display the full 4-byte value in the proper order.</p>&#13;
<p class="indent">In the vast majority of programming situations, endianness is not an issue. However, you need to know about it because it can be confusing when examining memory in the debugger. Endianness is also an issue when different computers communicate with each other. For example, <em>Transport Control Protocol/Internet Protocol (TCP/IP)</em> is defined to be big-endian, sometimes called <em>network byte order</em>. The instructions in the AArch64 architecture <span epub:type="pagebreak" id="page_35"/>are stored in little-endian order. The data can be stored in either order, but the default in our environment is little-endian, and the operating system reorders the bytes for internet communication. You also need to know about byte order if you’re writing communications software for an operating system itself or for an embedded system that may not have an operating system.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch2exe19">2.19     Enter the program in <a href="ch02.xhtml#ch2list1">Listing 2-1</a>. Follow through the program with <code>gdb</code>. Using the numbers you get, explain where the variables <code>an_int</code> and <code>a_string</code> are stored in memory and what is stored in each location.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec6"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Bits</strong>   A computer is a collection of on/off switches that we can represent with bits.</p>&#13;
<p class="noindentin"><strong>Hexadecimal</strong>   This is a number system based on 16. Each hexadecimal digit, <code>0</code> to <code>f</code>, represents 4 bits.</p>&#13;
<p class="noindentin"><strong>Byte</strong>   This is a group of 8 bits. The bit pattern can be expressed as two hexadecimal digits.</p>&#13;
<p class="noindentin"><strong>Converting between decimal and binary</strong>   The two number systems are mathematically equivalent.</p>&#13;
<p class="noindentin"><strong>Memory addressing</strong>   Bytes in memory are numbered (addressed) sequentially. The byte’s address is usually expressed in hexadecimal.</p>&#13;
<p class="noindentin"><strong>Endianness</strong>   An integer that is more than 1 byte can be stored with the highest-order byte in the lowest byte address (big-endian) or with the lowest-order byte in the lowest byte address (little-endian). Our environment is little-endian.</p>&#13;
<p class="noindentin"><strong>UTF-8 encoding</strong>   This is a code for storing characters in memory.</p>&#13;
<p class="noindentin"><strong>String</strong>   A C-style string is an array of characters terminated by the <code>NUL</code> character.</p>&#13;
<p class="noindentin"><span class="codestrong">printf</span>   This C library function is used to write formatted data on the screen.</p>&#13;
<p class="noindentin"><span class="codestrong">scanf</span>   This C library function is used to read formatted data from the keyboard.</p>&#13;
<p class="noindentin"><strong>Debugging</strong>   The <code>gdb</code> debugger can be used to see how the variables change at each step in the execution of a program.</p>&#13;
<p class="indenta">In the next chapter, you’ll learn about addition and subtraction in the binary number system for both unsigned and signed integers. This will illuminate some of the potential errors inherent in using a fixed number of bits to represent numerical values.<span epub:type="pagebreak" id="page_36"/></p>&#13;
</div>
</div>
</body></html>