["```\n\n\t\t\tpush memory or constant operand\n```", "```\n\n\t\t\tpush 10  ; Pushes the constant 10 onto the stack\npush mem ; Pushes the contents of memory location mem\n```", "```\n\n\t\t\tpop memory location\n```", "```\n\n\t\t\tpush a\npush b\nadd\n```", "```\n\n\t\t\tpush c\npush d\nsub\n```", "```\nadd\n```", "```\n\n\t\t\tLDA constant or memory ; Load accumulator register\nSTA memory             ; Store accumulator register\nADD constant or memory ; Add operand to accumulator\nSUB constant or memory ; Subtract operand from accumulator\n```", "```\n\n\t\t\tpush y\npush z\nadd\npop x\n```", "```\n\n\t\t\tlda y\nadd z\nsta x\n```", "```\n\n\t\t\t// Note: Assume x is held in EBX, y is held in ECX,\n// and z is held in EDX:\n\nmov( ecx, ebx );\nadd( edx, ebx );\n```", "```\n\n\t\t\tvar = var2;\nvar = constant;\nvar = op var2;\nvar = var op var2;\nvar = var2 op var3;\n```", "```\n\n\t\t\tadd source1, source2, dest\n```", "```\nadd r0, r1, r2   ; computes r2 := r0 + r1\n```", "```\nvar = var2 op var3;\n```", "```\nvar = var op var2;\n```", "```\nadd r0, r1, r0  ; computes r0 := r0 + r1\n```", "```\nadd( ebx, eax );  ; computes eax := eax + ebx;\n```", "```\nvar1 = var2 + var3;\n```", "```\n\n\t\t\tmov( var2, eax );\nadd( var3, eax );  //Result (var1) is in EAX.\n```", "```\n\n\t\t\t// complex = ( a + b ) * ( c - d ) - e/f;\n\ntemp1 = a + b;\ntemp2 = c - d;\ntemp1 = temp1 * temp2;\ntemp2 = e / f;\ncomplex = temp1 - temp2;\n```", "```\nchar bigArray[ 16777216 ]; // 16 MB of storage\n```", "```\nchar bigArray[ 16*1024*1024 ]; // 16 MB of storage\n```", "```\n\n\t\t\t#include <stdio.h>\nint main(int argc, char **argv)\n{\n      int i = 16 * 1024 * 1024;\n      printf( \"%d\\n\", i);\n       return 0;\n}\n\n// Assembly output for sequence above (optimizations turned off!)\n\n        mov     DWORD PTR i$[rsp], 16777216             ; 01000000H\n\n        mov     edx, DWORD PTR i$[rsp]\n        lea     rcx, OFFSET FLAT:$SG7883\n        call    printf\n```", "```\n\n\t\t\tpublic class Welcome\n{\n      public static void main( String[] args )\n      {\n            int i = 16 * 1024 * 1024;\n            System.out.println( i );\n      }\n}\n\n// JBC generated by the compiler:\n\njavap -c Welcome\nCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n\n   4:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   ldc #2; //int 16777216\n   2:   istore_1\n\n        ; //Field java/lang/System.out:Ljava/io/PrintStream;\n   3:   getstatic   #3\n\n   6:   iload_1\n\n        ; //Method java/io/PrintStream.println:(I)V\n   7:   invokevirtual   #4   10:  return\n\n}\n```", "```\n\n\t\t\timport Foundation\n\nvar i:Int = 16*1024*1024\nprint( \"i=\\(i)\" )\n\n// code produced by\n// \"xcrun -sdk macosx\n//       swiftc -O -emit-assembly main.swift -o result.asm\"\n\n       movq    $16777216, _$S6result1iSivp(%rip)\n```", "```\n\n\t\t\t// original code:\n\n    variable = 1234;\n    result = f( variable );\n\n// code after constant propagation optimization\n\n    variable = 1234;\n    result = f( 1234 );\n```", "```\n\n\t\t\t#include <stdio.h>\nstatic int rtn3( void )\n{\n    return 3;\n}\nint main( void )\n{\n    printf( \"%d\", rtn3() + 2 );\n    return( 0 );\n}\n```", "```\n\n\t\t\t.LC0:\n        .string \"%d\"\n        .text\n        .p2align 2,,3\n.globl main\n        .type   main,@function\nmain:\n        ; Build main's activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $8, %esp\n        andl    $-16, %esp\n        subl    $8, %esp\n\n        ; Print the result of \"rtn3()+5\":\n\n        pushl   $5      ; Via constant propagation/folding!\n        pushl   $.LC0\n        call    printf\n        xorl    %eax, %eax\n        leave\n        ret\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint f(int a)\n{\n      return a + 1;\n}\n\nint main(int argc, char **argv)\n{\n      int i = 16 * 1024 * 1024;\n      int j = f(i);\n      printf( \"%d\\n\", j);\n}\n\n// Assembly language output for the above code:\n\nmain    PROC                                            ; COMDAT\n\n$LN6:\n        sub     rsp, 40                                 ; 00000028H\n\n        mov     edx, 16777217                           ; 01000001H\n        lea     rcx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@\n        call    printf\n\n        xor     eax, eax\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\tpublic class Welcome\n{\n      public static int f( int a ) { return a+1;}\n      public static void main( String[] args )\n      {\n            int i = 16 * 1024 * 1024;\n            int j = f(i);\n            int k = i+1;\n            System.out.println( j );\n            System.out.println( k );\n       }\n}\n\n// JBC emitted for this Java source code:\n\njavap -c Welcome\nCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n   4:   return\n\npublic static int f(int);\n  Code:\n   0:   iload_0\n   1:   iconst_1\n   2:   iadd\n   3:   ireturn\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   ldc #2; //int 16777216\n   2:   istore_1\n   3:   iload_1\n   4:   invokestatic    #3; //Method f:(I)I\n   7:   istore_2\n   8:   iload_1\n   9:   iconst_1\n   10:  iadd\n   11:  istore_3\n\n        ; //Field java/lang/System.out:Ljava/io/PrintStream;\n   12:  getstatic   #4\n   15:  iload_2\n\n        ; //Method java/io/PrintStream.println:(I)V\n   16:  invokevirtual   #5\n\n        ; //Field java/lang/System.out:Ljava/io/PrintStream;\n   19:  getstatic   #4\n   22:  iload_3\n\n        ; //Method java/io/PrintStream.println:(I)V\n   23:  invokevirtual   #5\n   26:  return\n\n}\n```", "```\n\n\t\t\timport Foundation\n\nfunc f( _ a:Int ) -> Int\n{\n    return a + 1\n}\nlet i:Int = 16*1024*1024\nlet j = f(i)\nprint( \"i=\\(i), j=\\(j)\" )\n\n// Assembly output via the command:\n// xcrun -sdk macosx swiftc -O -emit-assembly main.swift -o result.asm\n\n    movq    $16777216, _$S6result1iSivp(%rip)\n    movq    $16777217, _$S6result1jSivp(%rip)\n    .\n    .   // Lots of code that has nothing to do with the Swift source\n    .\n    movl    $16777216, %edi\n    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5\n    .\n    .\n    .\n    movl    $16777217, %edi\n    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5\n```", "```\n\n\t\t\tstatic int rtn3( void )\n{\n    return 3;\n}\n\nint main( void )\n{\n    int i = rtn3() + 2;\n\n    // Note that this program\n    // never again uses the value of i.\n\n    return( 0 );\n}\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .text\n        .p2align 2,,3\n.globl main\n        .type   main,@function\nmain:\n        ; Build main's activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $8, %esp\n        andl    $-16, %esp\n\n        ; Notice that there is no\n        ; assignment to i here.\n\n        ; Return 0 as main's function result.\n\n        xorl    %eax, %eax\n        leave\n        ret\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .text\n        .type   rtn3,@function\nrtn3:\n        pushl   %ebp\n        movl    %esp, %ebp\n        movl    $3, %eax\n        leave\n        ret\n.Lfe1:\n        .size   rtn3,.Lfe1-rtn3\n.globl main\n        .type   main,@function\nmain:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $8, %esp\n        andl    $-16, %esp\n        movl    $0, %eax\n        subl    %eax, %esp\n\n        ; Note the call and computation:\n\n        call    rtn3\n        addl    $2, %eax\n        movl    %eax, -4(%ebp)\n\n        ; Return 0 as the function result.\n\n        movl    $0, %eax\n        leave\n        ret\n```", "```\n\n\t\t\t; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1\n\ninclude listing.inc\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC  main\n; Function compile flags: /Ogtpy\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n_TEXT   SEGMENT\nmain    PROC\n\n        xor     eax, eax\n\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n_TEXT   SEGMENT\nrtn3    PROC\n\n        mov     eax, 3\n\n        ret     0\nrtn3    ENDP\n_TEXT   ENDS\nEND\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static int rtn3() { return 3;}\n    public static void main( String[] args )\n    {\n        int i = rtn3();\n    }\n}\n\n// JBC output:\n\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n   4:   return\n\npublic static int rtn3();\n  Code:\n   0:   iconst_3\n   1:   ireturn\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   invokestatic    #2; //Method rtn3:()I\n   3:   istore_1\n   4:   return\n}\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static int rtn3() { return 3;}\n    public static void main( String[] args )\n    {\n        if( false )\n        {   int i = rtn3();\n        }\n    }\n}\n\n// Here's the output bytecode:\n\nCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n   4:   return\n\npublic static int rtn3();\n  Code:\n   0:   iconst_3\n   1:   ireturn\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   return\n}\n```", "```\n\n\t\t\timport Foundation\n\nfunc rtn3() -> Int\n{\n    return 3\n}\nlet i:Int = rtn3()\n// Assembly language output:\n\n_main:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movq    $3, _$S6result1iSivp(%rip)\n    xorl    %eax, %eax\n    popq    %rbp\n    retq\n\n    .private_extern _$S6result4rtn3SiyF\n    .globl  _$S6result4rtn3SiyF\n    .p2align    4, 0x90\n_$S6result4rtn3SiyF:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    $3, %eax\n    popq    %rbp\n    retq\n```", "```\n\n\t\t\timport Foundation\n\nfunc rtn3() -> Int\n{\n    return 3\n}\nif false\n{\n    let i:Int = rtn3()\n}\n\n// Assembly output\n\n_main:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    xorl    %eax, %eax\n    popq    %rbp\n    retq\n\n    .private_extern _$S6result4rtn3SiyF\n    .globl  _$S6result4rtn3SiyF\n    .p2align    4, 0x90\n_$S6result4rtn3SiyF:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    $3, %eax\n    popq    %rbp\n    retq\n```", "```\n\n\t\t\tcomplex := ( a + b ) * ( c - d ) - ( e div f );\nlessSo  := ( a + b ) - ( e div f );\nquotient := e div f;\n```", "```\n\n\t\t\ttemp1 := a + b;\ntemp2 := c - d;\ntemp3 := e div f;\ncomplex := temp1 * temp2;\ncomplex := complex - temp3;\nlessSo := temp1 - temp3;\nquotient := temp3;\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i, j, k, m, n;\nstatic int expr1, expr2, expr3;\n\nextern int someFunc( void );\n\nint main( void )\n{\n    // The following is a trick to\n    // confuse the optimizer. When we call\n    // an external function, the optimizer\n    // knows nothing about the value this\n    // function returns, so it cannot optimize\n    // the values away. This is done to demonstrate\n    // the optimizations that this example is\n    // trying to show (that is, the compiler\n    // would normally optimize away everything\n    // and we wouldn't see the code the optimizer\n    // would produce in a real-world example without\n    // the following trick).\n\n    i = someFunc();\n    j = someFunc();\n    k = someFunc();\n    m = someFunc();\n    n = someFunc();\n\n    expr1 = (i+j) * (k*m+n);\n    expr2 = (i+j);\n    expr3 = (k*m+n);\n\n    printf( \"%d %d %d\", expr1, expr2, expr3 );\n    return( 0 );\n}\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .section        .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n        .string \"%d %d %d\"\n        .text\n        .p2align 2,,3\n.globl main\n        .type   main,@function\nmain:\n        ; Build the activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $8, %esp\n        andl    $-16, %esp\n\n        ; Initialize i, j, k, m, and n:\n\n        call    someFunc\n        movl    %eax, i\n        call    someFunc\n        movl    %eax, j\n        call    someFunc\n        movl    %eax, k\n        call    someFunc\n        movl    %eax, m\n        call    someFunc ;n's value is in EAX.\n\n        ; Compute EDX = k*m+n\n        ; and ECX = i+j\n        movl    m, %edx\n        movl    j, %ecx\n        imull   k, %edx\n        addl    %eax, %edx\n        addl    i, %ecx\n\n        ; EDX is expr3, so push it\n        ; on the stack for printf\n\n        pushl   %edx\n\n        ; Save away n's value:\n\n        movl    %eax, n\n        movl    %ecx, %eax\n\n        ; ECX is expr2, so push it onto\n        ; the stack for printf:\n\n        pushl   %ecx\n\n        ; expr1 is the product of the\n        ; two subexpressions (currently\n        ; held in EDX and EAX), so compute\n        ; their product and push the result\n        ; for printf.\n\n        imull   %edx, %eax\n        pushl   %eax\n\n        ; Push the address of the format string\n        ; for printf:\n\n        pushl   $.LC0\n\n        ; Save the variable's values and then\n        ; call printf to print the values\n\n        movl    %eax, expr1\n        movl    %ecx, expr2\n        movl    %edx, expr3\n        call    printf\n\n        ; Return 0 as the main function's result:\n\n        xorl    %eax, %eax\n        leave\n        ret\n```", "```\n\n\t\t\t_TEXT   SEGMENT\nmain    PROC\n\n$LN4:\n        sub     rsp, 40                                 ; 00000028H\n\n        call    someFunc\n        mov     DWORD PTR i, eax\n\n        call    someFunc\n        mov     DWORD PTR j, eax\n\n        call    someFunc\n        mov     DWORD PTR k, eax\n\n        call    someFunc\n        mov     DWORD PTR m, eax\n\n        call    someFunc\n\n        mov     r9d, DWORD PTR m\n\n        lea     rcx, OFFSET FLAT:$SG7892\n        imul    r9d, DWORD PTR k\n        mov     r8d, DWORD PTR j\n        add     r8d, DWORD PTR i\n        mov     edx, r8d\n        mov     DWORD PTR n, eax\n        mov     DWORD PTR expr2, r8d\n        add     r9d, eax\n        imul    edx, r9d\n        mov     DWORD PTR expr3, r9d\n        mov     DWORD PTR expr1, edx\n        call    printf\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i, j, k, m, n;\nstatic int expr1, expr2, expr3;\nstatic int ijExpr, kmnExpr;\n\nextern int someFunc( void );\n\nint main( void )\n{\n    // The following is a trick to\n    // confuse the optimizer. By calling\n    // an external function, the optimizer\n    // knows nothing about the value this\n    // function returns, so it cannot optimize\n    // the values away because of constant propagation.\n\n    i = someFunc();\n    j = someFunc();\n    k = someFunc();\n    m = someFunc();\n    n = someFunc();\n\n    ijExpr = i+j;\n    kmnExpr = (k*m+n);\n    expr1 = ijExpr * kmnExpr;\n    expr2 = ijExpr;\n    expr3 = kmnExpr;\n\n    printf( \"%d %d %d\", expr1, expr2, expr3 );\n    return( 0 );\n}\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static int someFunc() { return 1;}\n    public static void main( String[] args )\n    {\n        int i = someFunc();\n        int j = someFunc();\n        int k = someFunc();\n        int m = someFunc();\n        int n = someFunc();\n        int expr1 = (i + j) * (k*m + n);\n        int expr2 = (i + j);\n        int expr3 = (k*m + n);\n    }\n}\n\n// JBC output\n\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n   4:   return\n\npublic static int someFunc();\n  Code:\n   0:   iconst_1\n   1:   ireturn\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   invokestatic    #2; //Method someFunc:()I\n   3:   istore_1\n   4:   invokestatic    #2; //Method someFunc:()I\n   7:   istore_2\n   8:   invokestatic    #2; //Method someFunc:()I\n   11:  istore_3\n   12:  invokestatic    #2; //Method someFunc:()I\n   15:  istore  4\n   17:  invokestatic    #2; //Method someFunc:()I\n   20:  istore  5\n; iexpr1 = (i + j) * (k*m + n);\n   22:  iload_1\n   23:  iload_2\n   24:  iadd\n   25:  iload_3\n   26:  iload   4\n   28:  imul\n   29:  iload   5\n   31:  iadd\n   32:  imul\n   33:  istore  6\n; iexpr2 = (i+j)\n   35:  iload_1\n   36:  iload_2\n   37:  iadd\n   38:  istore  7\n; iexpr3 = (k*m + n)\n   40:  iload_3\n   41:  iload   4\n   43:  imul\n   44:  iload   5\n   46:  iadd\n   47:  istore  8\n   49:  return\n}\n```", "```\n\n\t\t\timport Foundation\n\nfunc someFunc() -> UInt32\n{\n    return arc4random_uniform(100)\n}\nlet i = someFunc()\nlet j = someFunc()\nlet k = someFunc()\nlet m = someFunc()\nlet n = someFunc()\n\nlet expr1 = (i+j) * (k*m+n)\nlet expr2 = (i+j)\nlet expr3 = (k*m+n)\nprint( \"\\(expr1), \\(expr2), \\(expr3)\" )\n\n// Assembly output for the above expressions:\n\n; Code for the function calls:\n\n    movl    $0x64, %edi\n    callq   arc4random_uniform\n    movl    %eax, %ebx  ; EBX = i\n    movl    %ebx, _$S6result1is6UInt32Vvp(%rip)\n    callq   _arc4random\n    movl    %eax, %r12d ; R12d = j\n    movl    %r12d, _$S6result1js6UInt32Vvp(%rip)\n    callq   _arc4random\n    movl    %eax, %r14d ; R14d = k\n    movl    %r14d, _$S6result1ks6UInt32Vvp(%rip)\n    callq   _arc4random\n    movl    %eax, %r15d ; R15d = m\n    movl    %r15d, _$S6result1ms6UInt32Vvp(%rip)\n    callq   _arc4random\n    movl    %eax, %esi  ; ESI = n\n    movl    %esi, _$S6result1ns6UInt32Vvp(%rip)\n\n; Code for the expressions:\n\n    addl    %r12d, %ebx ; R12d = i + j (which is expr2)\n    jb  LBB0_11         ; Branch if overflow occurs\n\n    movl    %r14d, %eax ;\n    mull    %r15d\n    movl    %eax, %ecx  ; ECX = k*m\n    jo  LBB0_12         ; Bail if overflow\n    addl    %esi, %ecx  ; ECX = k*m + n (which is expr3)\n    jb  LBB0_13         ; Bail if overflow\n\n    movl    %ebx, %eax\n    mull    %ecx        ; expr1 = (i+j) * (k*m+n)\n    jo  LBB0_14         ; Bail if overflow\n    movl    %eax, _$S6result5expr1s6UInt32Vvp(%rip)\n    movl    %ebx, _$S6result5expr2s6UInt32Vvp(%rip)\n    movl    %ecx, _$S6result5expr3s6UInt32Vvp(%rip)\n```", "```\n\n\t\t\t#include <stdio.h>\n\nunsigned i, j, k, m, n;\n\nextern unsigned someFunc( void );\nextern void preventOptimization( unsigned arg1, ... );\n\nint main( void )\n{\n    // The following is a trick to\n    // confuse the optimizer. By calling\n    // an external function, the optimizer\n    // knows nothing about the value this\n    // function returns, so it cannot optimize\n    // the values away.\n\n    i = someFunc();\n    j = i * 2;\n    k = i % 32;\n    m = i / 4;\n    n = i * 8;\n\n    // The following call to \"preventOptimization\" is done\n    // to trick the compiler into believing the above results\n    // are used somewhere (GCC will eliminate all the code\n    // above if you don't actually use the computed result,\n    // and that would defeat the purpose of this example).\n\n    preventOptimization( i,j,k,m,n);\n    return( 0 );\n}\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .text\n        .p2align 2,,3\n.globl main\n        .type   main,@function\nmain:\n        ; Build main's activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        pushl   %esi\n        pushl   %ebx\n        andl    $-16, %esp\n\n        ; Get i's value into EAX:\n\n        call    someFunc\n\n        ; compute i*8 using the scaled-\n        ; indexed addressing mode and\n        ; the LEA instruction (leave\n        ; n's value in EDX):\n\n        leal    0(,%eax,8), %edx\n\n        ; Adjust stack for call to\n        ; preventOptimization:\n\n        subl    $12, %esp\n\n        movl    %eax, %ecx      ; ECX = i\n        pushl   %edx            ; Push n for call\n        movl    %eax, %ebx      ; Save i in k\n        shrl    $2, %ecx        ; ECX = i/4 (m)\n        pushl   %ecx            ; Push m for call\n\n        andl    $31, %ebx       ; EBX = i % 32\n        leal    (%eax,%eax), %esi ;j=i*2\n        pushl   %ebx            ; Push k for call\n        pushl   %esi            ; Push j for call\n        pushl   %eax            ; Push i for call\n        movl    %eax, i         ; Save values in memory\n        movl    %esi, j         ; variables.\n        movl    %ebx, k\n        movl    %ecx, m\n        movl    %edx, n\n        call    preventOptimization\n\n        ; Clean up the stack and return\n        ; 0 as main's result:\n\n        leal    -8(%ebp), %esp\n        popl    %ebx\n        xorl    %eax, %eax\n        popl    %esi\n        leave\n        ret\n.Lfe1:\n        .size   main,.Lfe1-main\n        .comm   i,4,4\n        .comm   j,4,4\n        .comm   k,4,4\n        .comm   m,4,4\n        .comm   n,4,4\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint i, j, k, m, n;\n\nextern int someFunc( void );\nextern void preventOptimization( int arg1, ... );\n\nint main( void )\n{\n    // The following is a trick to\n    // confuse the optimizer. By calling\n    // an external function, the optimizer\n    // knows nothing about the value this\n    // function returns, so it cannot optimize\n    // the values away. That is, this prevents\n    // constant propagation from computing all\n    // the following values at compile time.\n\n    i = someFunc();\n    j = i * 2;\n    k = i % 32;\n    m = i / 4;\n    n = i * 8;\n\n    // The following call to \"preventOptimization\"\n    // prevents dead code elimination of all the\n    // preceding statements.\n\n    preventOptimization( i,j,k,m,n);\n    return( 0 );\n}\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .text\n        .p2align 2,,3\n        .globl main\n        .type   main,@function\nmain:\n        ; Build main's activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        pushl   %esi\n        pushl   %ebx\n        andl    $-16, %esp\n\n        ; Call someFunc to get i's value:\n\n        call    someFunc\n        leal    (%eax,%eax), %esi ; j = i * 2\n        testl   %eax, %eax        ; Test i's sign\n        movl    %eax, %ecx\n        movl    %eax, i\n        movl    %esi, j\n        js      .L4\n\n; Here's the code we execute if i is non-negative:\n\n.L2:\n        andl    $-32, %eax       ; MOD operation\n        movl    %ecx, %ebx\n        subl    %eax, %ebx\n        testl   %ecx, %ecx       ; Test i's sign\n        movl    %ebx, k\n        movl    %ecx, %eax\n        js      .L5\n.L3:\n        subl    $12, %esp\n        movl    %eax, %edx\n        leal    0(,%ecx,8), %eax ; i*8\n        pushl   %eax\n        sarl    $2, %edx         ; Signed div by 4\n        pushl   %edx\n        pushl   %ebx\n        pushl   %esi\n        pushl   %ecx\n        movl    %eax, n\n        movl    %edx, m\n        call    preventOptimization\n        leal    -8(%ebp), %esp\n        popl    %ebx\n        xorl    %eax, %eax\n        popl    %esi\n        leave\n        ret\n        .p2align 2,,3\n\n; For signed division by 4,\n; using a sarl operation, we need\n; to add 3 to i's value if i was\n; negative.\n\n.L5:\n        leal    3(%ecx), %eax\n        jmp     .L3\n        .p2align 2,,3\n\n; For signed % operation, we need to\n; first add 31 to i's value if it was\n; negative to begin with:\n\n.L4:\n        leal    31(%eax), %eax\n        jmp     .L2\n```", "```\n\n\t\t\tfor i := 0 to 15 do begin\n\n    j := i * 2;\n    vector[ j ] := j;\n    vector[ j+1 ] := j + 1;\n\nend;\n```", "```\n\n\t\t\tij := 0;  {ij is the combination of i and j from\n           the previous code}\nwhile( ij < 32 ) do begin\n\n    vector[ ij ] := ij;\n    vector[ ij+1 ] := ij + 1;\n    ij := ij + 2;\n\nend;\n```", "```\n\n\t\t\textern unsigned vector[32];\n\nextern void someFunc( unsigned v[] );\nextern void preventOptimization( int arg1, ... );\n\nint main( void )\n{\n\n    unsigned i, j;\n\n    //  \"Initialize\" vector (or, at least,\n    //  make the compiler believe this is\n    //  what's going on):\n\n    someFunc( vector );\n\n    // For loop to demonstrate induction:\n\n    for( i=0; i<16; ++i )\n    {\n        j = i * 2;\n        vector[ j ] = j;\n        vector[ j+1 ] = j+1;\n    }\n\n    // The following prevents dead code elimination\n    // of the former calculations:\n\n    preventOptimization( vector[0], vector[15] );\n    return( 0 );\n}\n```", "```\n\n\t\t\t_main   PROC\n\n        push    OFFSET _vector\n        call    _someFunc\n        add     esp, 4\n        xor     edx, edx\n\n        xor     eax, eax\n$LL4@main:\n\n        lea     ecx, DWORD PTR [edx+1]      ; ECX = j+1\n        mov     DWORD PTR _vector[eax], edx ; EDX = j\n        mov     DWORD PTR _vector[eax+4], ecx\n\n; Each time through the loop, bump j up by 2 (i*2)\n\n        add     edx, 2\n\n; Add 8 to index into vector, as we are filling two elements\n; on each loop.\n\n        add     eax, 8\n\n; Repeat until we reach the end of the array.\n\n        cmp     eax, 128                                ; 00000080H\n        jb      SHORT $LL4@main\n\n        push    DWORD PTR _vector+60\n        push    DWORD PTR _vector\n        call    _preventOptimization\n        add     esp, 8\n\n        xor     eax, eax\n\n        ret     0\n_main   ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static void main( String[] args )\n    {\n          int[] vector = new int[32];\n          int j;\n          for (int i = 0; i<16; ++i)\n          {\n            j = i * 2;\n            vector[j] = j;\n            vector[j + 1] = j + 1;\n          }\n    }\n}\n\n// JBC:\n\nCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n\n        ; //Method java/lang/Object.\"<init>\":()V\n   1:   invokespecial   #1\n   4:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n; Create vector array:\n\n   0:   bipush  16\n   2:   newarray int\n   4:   astore_1\n\n; i = 0   -- for( int i=0;...;...)\n   5:   iconst_0\n   6:   istore_3\n\n; If i >= 16, exit loop  -- for(...;i<16;...)\n\n   7:   iload_3\n   8:   bipush  16\n   10:  if_icmpge   35\n\n; j = i * 2\n\n   13:  iload_3\n   14:  iconst_2\n   15:  imul\n   16:  istore_2\n\n; vector[j] = j\n\n   17:  aload_1\n   18:  iload_2\n   19:  iload_2\n   20:  iastore\n\n; vector[j+1] = j + 1\n\n   21:  aload_1\n   22:  iload_2\n   23:  iconst_1\n   24:  iadd\n   25:  iload_2\n   26:  iconst_1\n   27:  iadd\n   28:  iastore\n\n; Next iteration of loop -- for(...;...; ++i )\n\n   29:  iinc    3, 1\n   32:  goto    7\n\n; exit program here.\n\n   35:  return\n}\n```", "```\n\n\t\t\tfor ( j = 0; j < 32; j = j + 2 )\n{\n    vector[j] = j;\n    vector[j + 1] = j + 1;\n}\n  Code:\n; Create array:\n\n   0:   bipush  16\n   2:   newarray int\n   4:   astore_1\n\n; for( int j = 0;...;...)\n\n   5:   iconst_0\n   6:   istore_2\n\n; if j >= 32, bail -- for(...;j<32;...)\n\n   7:   iload_2\n   8:   bipush  32\n   10:  if_icmpge   32\n\n; vector[j] = j\n\n   13:  aload_1\n   14:  iload_2\n   15:  iload_2\n   16:  iastore\n\n; vector[j + 1] = j + 1\n\n   17:  aload_1\n   18:  iload_2\n   19:  iconst_1\n   20:  iadd\n   21:  iload_2\n   22:  iconst_1\n   23:  iadd\n   24:  iastore\n\n; j += 2  -- for(...;...; j += 2 )\n\n   25:  iload_2\n   26:  iconst_2\n   27:  iadd\n   28:  istore_2\n   29:  goto    7\n\n   32:  return\n```", "```\n\n\t\t\ti = 5\nfor j = 1 to 10\n    k = i*2\nnext j\n```", "```\n\n\t\t\ti = 5\nk = i * 2\nfor j = 1 to 10\nnext j\nrem At this point, k will contain the same\nrem value as in the previous example\n```", "```\n\n\t\t\textern unsigned someFunc( void );\nextern void preventOptimization( unsigned arg1, ... );\n\nint main( void )\n{\n    unsigned i, j, k, m;\n\n    k = someFunc();\n    m = k;\n    for( i = 0; i < k; ++i )\n    {\n        j = k + 2;    // Loop-invariant calculation\n        m += j + i;\n    }\n    preventOptimization( m, j, k, i );\n    return( 0 );\n}\n```", "```\n\n\t\t\t_main   PROC NEAR ; COMDAT\n; File t.c\n; Line 5\n        push    ecx\n        push    esi\n; Line 8\n        call    _someFunc\n; Line 10\n        xor     ecx, ecx  ; i = 0\n        test    eax, eax  ; see if k == 0\n        mov     edx, eax  ; m = k\n        jbe     SHORT $L108\n        push    edi\n\n; Line 12\n; Compute j = k + 2, but only execute this\n; once (code was moved out of the loop):\n\n        lea     esi, DWORD PTR [eax+2] ; j = k + 2\n\n; Here's the loop the above code was moved\n; out of:\n\n$L99:\n; Line 13\n        ; m(edi) = j(esi) + i(ecx)\n\n        lea     edi, DWORD PTR [esi+ecx]\n        add     edx, edi\n\n        ; ++i\n        inc     ecx\n\n        ; While i < k, repeat:\n\n        cmp     ecx, eax\n        jb      SHORT $L99\n\n        pop     edi\n; Line 15\n;\n; This is the code after the loop body:\n\n        push    ecx\n        push    eax\n        push    esi\n        push    edx\n        call    _preventOptimization\n        add     esp, 16                                 ; 00000010H\n; Line 16\n        xor     eax, eax\n        pop     esi\n; Line 17\n        pop     ecx\n        ret     0\n$L108:\n; Line 10\n        mov     esi, DWORD PTR _j$[esp+8]\n; Line 15\n        push    ecx\n        push    eax\n        push    esi\n        push    edx\n        call    _preventOptimization\n        add     esp, 16                                 ; 00000010H\n; Line 16\n        xor     eax, eax\n        pop     esi\n; Line 17\n        pop     ecx\n        ret     0\n_main   ENDP\n```", "```\ni = i + *pi++ + (j = 2) * --k\n```", "```\n\n\t\t\tvar\n   k:integer;\n   m:integer;\n   n:integer;\n\nfunction hasSideEffect( i:integer; var j:integer ):integer;\nbegin\n\n    k := k + 1;\n    hasSideEffect := i + j;\n    j := i;\n\nend;\n        .\n        .\n        .\n    m := hasSideEffect( 5, n );\n```", "```\ni := f(x) + g(x);\n```", "```\n\n\t\t\t{ Conversion #1 for \"i := f(x) + g(x);\" }\n\n    temp1 := f(x);\n    temp2 := g(x);\n    i := temp1 + temp2;\n\n{ Conversion #2 for \"i := f(x) + g(x);\" }\n\n    temp1 := g(x);\n    temp2 := f(x);\n    i := temp2 + temp1;\n```", "```\n\n\t\t\t    j := f(x) - g(x) * h(x);\n\n{ Conversion #1 for this expression: }\n\n    temp1 := f(x);\n    temp2 := g(x);\n    temp3 := h(x);\n    temp4 := temp2 * temp3\n    j := temp1 - temp4;\n\n{ Conversion #2 for this expression: }\n\n    temp2 := g(x);\n    temp3 := h(x);\n    temp1 := f(x);\n    temp4 := temp2 * temp3\n    j := temp1 - temp4;\n\n{ Conversion #3 for this expression: }\n\n    temp3 := h(x);\n    temp1 := f(x);\n    temp2 := g(x);\n    temp4 := temp2 * temp3\n    j := temp1 - temp4;\n```", "```\n\n\t\t\ti := f(x);\nwriteln( \"x=\", x );\n```", "```\nn := f(x) + g(x) - n;\n```", "```\n\n\t\t\tfunction incN:integer;\nbegin\n    incN := n;\n    n := n + 1;\nend;\n        .\n        .\n        .\n    n := 2;\n    writeln( incN + n*2 );\n```", "```\ni := f(x) + g(x);\n```", "```\ntemp1 := f(x);\ntemp2 := g(x);\ni := temp1 + temp2;\n```", "```\nexpression1, expression2                 (comma operator in an expression)\nexpression1 && expression2               (logical AND operator)\nexpression1 || expression2               (logical OR operator)\nexpression1 ? expression2 : expression3  (conditional expression operator)\n```", "```\n\n\t\t\tint array[6] = {0, 0, 0, 0, 0, 0};\nint i;\n    .\n    .\n    .\ni = 0;\narray[i] = i++;\n```", "```\n\n\t\t\t      array[0] = i++;\n-or-\n      array[1] = i++;\n```", "```\n\n\t\t\tarray [i] = i; //<-semicolon marks a sequence point.\n++i;\n```", "```\n\n\t\t\t++i;               //<-semicolon marks a sequence point.\narray[ i ] = i-1;\n```", "```\n\n\t\t\tj=i++;           //<-semicolon marks a sequence point.\narray[ i ] = j;\n```", "```\n\n\t\t\t{ Statement with an undefined result in Pascal }\n\n    i := f(x) + g(x);\n\n{ Corresponding statement with well-defined semantics }\n\n    temp1 := f(x);\n    temp2 := g(x);\n    i := temp1 + temp2;\n\n{ Another version, also with well-defined but different semantics }\n\n    temp1 := g(x);\n    temp2 := f(x);\n    i := temp2 + temp1;\n```", "```\n\n\t\t\tj = i++;\nk = m*n + 2;\n```", "```\n\n\t\t\t// Code fragment #1:\n\n    i = j + k;\n    m = ++k;\n\n// Code fragment #2:\n\n    i = j + k;\n    m = ++n;\n```", "```\n\n\t\t\tX / Y * Z\nZ * X / Y\n```", "```\n\n\t\t\t(X / Y) * Z\nZ * (X / Y)\n```", "```\n\n\t\t\tA = X / Y;\nB = Z\nC = A * B\nD = B * A\n```", "```\n\n\t\t\t    X / Y * Z\n=   5 / 2 * 3\n=   2 * 3\n=   6\n\n    Z * X / Y\n=   3 * 5 / 2\n=   15 / 2\n=   7\n```", "```\n\n\t\t\tA = B && C;\nD = E || F;\n```", "```\n\n\t\t\tA = B;\nif( A )\n{\n    A = C;\n}\n\nD = E;\nif( !D )\n{\n    D = F;\n}\n```", "```\n\n\t\t\tif( ptr != NULL && *ptr != '\\0' )\n{\n    << process current character pointed at by ptr >>\n}\n```", "```\n*++ptr && *++ptr && *++ptr && *++ptr && *++ptr && *++ptr && *++ptr && *++ptr;\n```", "```\n\n\t\t\t// Complex expression:\n\nif( (a < f(x)) && (b != g(y)) || predicate( a + b ))\n{\n    <<stmts to execute if this expression is true>>\n}\n\n// Translation to a form that uses complete Boolean evaluation:\n\ntemp1 = a < f(x);\ntemp2 = b != g(y);\ntemp3 = predicate( a + b );\nif( temp1 && temp2 || temp3 )\n{\n    <<stmts to execute if this expression is true>>\n}\n```", "```\n\n\t\t\tif( ((a < f(x)) and (b <> g(y))) or predicate( a + b )) then begin\n\n    <<stmts to execute if the expression is true>>\n\nend; (*if*)\n```", "```\n\n\t\t\tboolResult := a < f(x);\nif( boolResult ) then\n    boolResult := b <> g(y);\n\nif( not boolResult ) then\n    boolResult := predicate( a+b );\n if( boolResult ) then begin\n\n    <<stmts to execute if the if's expression is true>>\n\nend; (*if*)\n```", "```\n\n\t\t\t// Complex expression:\n\n //  if( (a < f(x)) && (b != g(y)) || predicate( a+b ))\n //  {\n //      <<stmts to execute if the if's expression is true>>\n //  }\n //\n // Translation to a form that uses complete\n //  Boolean evaluation:\n //\n //  temp1 = a < f(x);\n //  temp2 = b != g(y);\n //  temp3 = predicate( a + b );\n //  if( temp1 && temp2 || temp3 )\n //  {\n //      <<stmts to execute if the expression evaluates true>>\n //  }\n //\n //\n// Translation into 80x86 assembly language code,\n // assuming all variables and return results are\n // unsigned 32-bit integers:\n\n     f(x);            // Assume f returns its result in EAX\n     cmp( a, eax );   // Compare a with f(x)'s return result.\n     setb( bl );      // bl = a < f(x)\n     g(y);            // Assume g returns its result in EAX\n     cmp( b, eax );   // Compare b with g(y)'s return result\n     setne( bh );     // bh = b != g(y)\n     mov( a, eax );   // Compute a + b to pass along to the\n     add( b, eax );   // predicate function.\n     predicate( eax );// al holds predicate's result (0/1)\n     and( bh, bl );   // bl = temp1 && temp2\n     or( bl, al );    // al = (temp1 && temp2) || temp3\n     jz skipStmts;    // 0 if false, not 0 if true.\n\n       <<stmts to execute if the condition is true>>\n\nskipStmts:\n```", "```\n\n\t\t\t    //  if( (a < f(x)) && (b != g(y)) || predicate( a+b ))\n    //  {\n    //      <<stmts to execute if the if's expression evaluates true>>\n    //  }\n\n        f(x);\n        cmp( a, eax );\n        jnb TryOR;          // If a is not less than f(x), try the OR clause\n        g(y);\n        cmp( b, eax );\n        jne DoStmts         // If b is not equal g(y) (and a < f(x)), then do the body.\n\nTryOR:\n        mov( a, eax );\n        add( b, eax );\n        predicate( eax );\n        test( eax, eax );   // EAX = 0?\n        jz SkipStmts;\n\nDoStmts:\n        <<stmts to execute if the condition is true>>\nSkipStmts:\n```", "```\n\n\t\t\t    //  if( predicate( a + b ) || (a < f(x)) && (b != g(y)))\n    //  {\n    //      <<stmts to execute if the expression evaluates true>>\n    //  }\n\n        mov( a, eax );\n        add( b, eax );\n        predicate( eax );\n        test( eax, eax );   // EAX = true (not zero)?\n        jnz DoStmts;\n\n        f(x);\n        cmp( a, eax );\n        jnb SkipStmts;      // If a >= f(x), try the OR clause\n        g(y);\n        cmp( b, eax );\n        je SkipStmts;       // If b != g(y) then do the body.\n\nDoStmts:\n        <<stmts to execute if the condition is true>>\nSkipStmts:\n```", "```\n\n\t\t\ta < f(x) && b != g(y)\nb != g(y) && a < f(x)\n```", "```\nexpr1 && expr2\nexpr3 || expr4\n```"]