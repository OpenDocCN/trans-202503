<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch17"><span epub:type="pagebreak" id="page_161"/><strong>17  STM32 FPB Glitch</strong></h2>&#13;
<p class="noindent">There are many brilliant attacks to be found in Obermaier, Schink, and Moczek (2020), but my favorite is an escape from RDP Level 1 of the STM32F103 and also one of its clones, the APM32F103 from Geehy. This one involves a lot of moving parts, so gather ’round and pay attention!</p>&#13;
<p class="indent">First, recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that RDP Level 1 disables flash memory when a JTAG debugger is attached, but that the connection is allowed and all SRAM is available to the debugger. Resetting the chip will disconnect the debugger and reconnect flash memory, but it does not erase SRAM.</p>&#13;
<p class="indent">Second, the STM32 chips can boot from SRAM, ROM, or flash memory depending upon the values sampled on the BOOT0 and BOOT1 pins at startup. Flash has full access to memory, and ROM contains a bootloader with its own software implementation of the access restrictions, but when booting from SRAM, the code has the same restrictions as when JTAG is attached. Namely, flash memory is inaccessible. This restriction applies when booting from SRAM, but not when executing SRAM after booting from ROM or flash memory.</p>&#13;
<p class="indent">As it’s sometimes desirable to make small patches to flash memory without rewriting the memory, the STM32’s Cortex M3 core supports a flash patch and breakpoint unit (FPB). This unit is also handy when making changes to mask ROM, which can be patched even though it, of course, cannot be rewritten in place. <a href="ch17.xhtml#ch17fig2">Figure 17.2</a> shows the registers of this unit, and note that the pointers begin with <span class="literal">E</span>, so this peripheral comes from the Cortex M3 core and is not unique to the STM32.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_162"/><img id="ch17fig1" src="../images/f0162-01.jpg" alt="Image" width="578" height="702"/></div>&#13;
<p class="figcap">Figure 17.1: Simplified STM32F103 Memory Map</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_163"/><img id="ch17fig2" src="../images/f0163-01.jpg" alt="Image" width="745" height="752"/></div>&#13;
<p class="figcap">Figure 17.2: Cortex M3 Flash Patch and Breakpoint (FPB) Unit</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_164"/>So Obermaier wrote a bit of two-stage shellcode that is loaded as a bootable image into SRAM. The first stage can’t read flash memory because of the access restrictions, but it can reconfigure the FPB device to patch the Reset vector at <span class="literal">0x00000004</span> to point to the second stage. The boot pins are then changed to select flash memory as the boot source, and a supply voltage glitch is timed with a reset as a trigger.</p>&#13;
<p class="indent">The reset restores access to flash memory, and if the glitch succeeds at the right moment, the FPB’s patch of the Reset vector is not cleared by the reset sequence. This causes execution to return immediately to the second stage of the shellcode in SRAM. This stage can then freely export all the contents of memory.</p>&#13;
<p class="indent">In terms of portability, I’ve already pointed out that the FPB unit comes from ARM and not from ST Micro. This same unit is used in other exploits in this book, found in <a href="app03.xhtml#app03_4">Chapters C.4</a> and <a href="app03.xhtml#app03_5">C.5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_165"/><img id="ch17fig3" src="../images/f0165-01.jpg" alt="Image" width="777" height="902"/></div>&#13;
<p class="figcap">Figure 17.3: Geehy APM32F103, an STM32 Clone<span epub:type="pagebreak" id="page_166"/></p>&#13;
</div>
</div>
</body></html>