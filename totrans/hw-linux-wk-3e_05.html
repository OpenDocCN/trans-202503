<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="117" id="Page_117"/>5</span><br/>
<span class="ChapterTitle">How the Linux Kernel Boots</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">You now know the physical and logical structure of a Linux system, what the kernel is, and how to work with processes. This chapter will teach you how the kernel starts, or <em>boots</em>. In other words, you’ll learn how the kernel moves into memory and what it does up to the point where the first user process starts. </p>
<p>A simplified view of the boot process looks like this: </p>
<ol class="decimal">
<li value="1">The machine’s BIOS or boot firmware loads and runs a boot loader.</li>
<li value="2">The boot loader finds the kernel image on disk, loads it into memory, and starts it. </li>
<li value="3">The kernel initializes the devices and its drivers. </li>
<li value="4">The kernel mounts the root filesystem. </li>
<li value="5">The kernel starts a program called <em>init</em> with a process ID of 1. This point is the <em>user space start</em>.</li>
<li value="6"><span epub:type="pagebreak" title="118" id="Page_118"/>init sets the rest of the system processes in motion. </li>
<li value="7">At some point, init starts a process allowing you to log in, usually at the end or near the end of the boot sequence.</li>
</ol>
<p>This chapter covers the first couple of stages, focusing on the boot loaders and kernel. <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> continues with the user space start by detailing <em>systemd</em>, the most widespread version of init on Linux systems.</p>
<p>Being able to identify each stage of the boot process will prove invaluable to you in fixing boot problems and understanding the system as a whole. However, the default behavior in many Linux distributions often makes it difficult, if not impossible, to identify the first few boot stages as they proceed, so you’ll probably be able to get a good look only after they’ve completed and you log in.</p>
<h2 id="h1-500402c05-0001">	5.1	Startup Messages</h2>
<p class="BodyFirst">Traditional Unix systems produce many diagnostic messages upon boot that tell you about the boot process. The messages come first from the kernel and then from processes and initialization procedures that init starts. However, these messages aren’t pretty or consistent, and in some cases they aren’t even very informative. In addition, hardware improvements have caused the kernel to start much faster than before; the messages flash by so quickly, it can be difficult to see what’s happening. As a result, most current Linux distributions do their best to hide boot diagnostics with splash screens and other forms of filler to distract you while the system starts.</p>
<p>The best way to view the kernel’s boot and runtime diagnostic messages is to retrieve the journal for the kernel with the <code>journalctl</code> command. Running <code>journalctl -k</code> displays the messages from the current boot, but you can view previous boots with the <code>-b</code> option. We’ll cover the journal in more detail in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<p>If you don’t have systemd, you can check for a logfile such as <em>/var/log/kern.log</em> or run the <code>dmesg</code> command to view the messages in the <em>kernel ring buffer</em>.</p>
<p>Here’s a sample of what you can expect to see from the <code>journalctl -k</code> command:</p>
<pre><code>microcode: microcode updated early to revision 0xd6, date = 2019-10-03
Linux version 4.15.0-112-generic (buildd@lcy01-amd64-027) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 (Ubuntu 4.15.0-112.113-generic 4.15.18)
Command line: BOOT_IMAGE=/boot/vmlinuz-4.15.0-112-generic root=UUID=17f12d53-c3d7-4ab3-943e-a0a72366c9fa ro quiet splash vt.handoff=1
KERNEL supported cpus:
--<var>snip</var>--
scsi 2:0:0:0: Direct-Access     ATA      KINGSTON SM2280S 01.R PQ: 0 ANSI: 5
sd 2:0:0:0: Attached scsi generic sg0 type 0
sd 2:0:0:0: [sda] 468862128 512-byte logical blocks: (240 GB/224 GiB)
<span epub:type="pagebreak" title="119" id="Page_119"/>sd 2:0:0:0: [sda] Write Protect is off
sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
 sda: sda1 sda2 &lt; sda5 &gt;
sd 2:0:0:0: [sda] Attached SCSI disk
--<var>snip</var>--</code></pre>
<p>After the kernel has started, the user-space startup procedure often generates messages. These messages will likely be more difficult to view and review because on most systems you won’t find them in a single logfile. Startup scripts are designed to send messages to the console that are erased after the boot process finishes. However, this isn’t a problem on Linux systems because systemd captures diagnostic messages from startup and runtime that would normally go to the console.</p>
<h2 id="h1-500402c05-0002">	5.2	Kernel Initialization and Boot Options</h2>
<p class="BodyFirst">Upon startup, the Linux kernel initializes in this general order:</p>
<ol class="decimal">
<li value="1">CPU inspection</li>
<li value="2">Memory inspection</li>
<li value="3">Device bus discovery</li>
<li value="4">Device discovery</li>
<li value="5">Auxiliary kernel subsystem setup (networking and the like)</li>
<li value="6">Root filesystem mount</li>
<li value="7">User space start</li>
</ol>
<p>The first two steps aren’t too remarkable, but when the kernel gets to devices, the question of dependencies arises. For example, the disk device drivers may depend on bus support and SCSI subsystem support, as you saw in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Then, later in the initialization process, the kernel must mount a root filesystem before starting init. </p>
<p> In general, you won’t have to worry about the dependencies, except that some necessary components may be loadable kernel modules rather than part of the main kernel. Some machines may need to load these kernel modules before the true root filesystem is mounted. We’ll cover this problem and its initial RAM filesystem (initrd) workaround solutions in <span class="xref" itemid="xref_target_Section 6.7">Section 6.7</span>.</p>
<p>The kernel emits certain kinds of messages indicating that it’s getting ready to start its first user process:</p>
<pre><code>Freeing unused kernel memory: 2408K
Write protecting the kernel read-only data: 20480k
Freeing unused kernel memory: 2008K
Freeing unused kernel memory: 1892K</code></pre>
<p><span epub:type="pagebreak" title="120" id="Page_120"/>Here, not only is the kernel cleaning up some unused memory, but it’s also protecting its own data. Then, if you’re running a new enough kernel, you’ll see the kernel start the first user-space process as init:</p>
<pre><code>Run /init as init process
   with arguments:
    --<var>snip</var>--</code></pre>
<p>Later on, you should be able to see the root filesystem being mounted and systemd starting up, sending a few messages of its own to the kernel log:</p>
<pre><code>EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
systemd[1]: systemd 237 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD -IDN2 +IDN -PCRE2 default-hierarchy=hybrid)
systemd[1]: Detected architecture x86-64.
systemd[1]: Set hostname to &lt;duplex&gt;.</code></pre>
<p>At this point, you definitely know that user space has started.</p>
<h2 id="h1-500402c05-0003">	5.3	Kernel Parameters</h2>
<p class="BodyFirst">When the Linux kernel starts, it receives a set of text-based <em>kernel parameters</em> containing a few additional system details. The parameters specify many different types of behavior, such as the amount of diagnostic output the kernel should produce and device driver–specific options.</p>
<p>You can view the parameters passed to your system’s currently running kernel by looking at the <em>/proc/cmdline</em> file:</p>
<pre><code>$ <b>cat /proc/cmdline</b>
BOOT_IMAGE=/boot/vmlinuz-4.15.0-43-generic root=UUID=17f12d53-c3d7-4ab3-943e-a0a72366c9fa ro quiet splash vt.handoff=1</code></pre>
<p>The parameters are either simple one-word flags, such as <code>ro</code> and <code>quiet</code>, or <var>key</var><code>=</code><var>value</var> pairs, such as <code>vt.handoff=1</code>. Many of the parameters are unimportant, such as the <code>splash</code> flag for displaying a splash screen, but one that is critical is the <code>root</code> parameter. This is the location of the root filesystem; without it, the kernel cannot properly perform the user space start.</p>
<p>The root filesystem can be specified as a device file, as in this example:</p>
<pre><code>root=/dev/sda1</code></pre>
<p>On most contemporary systems, there are two alternatives that are more common. First, you might see a logical volume such as this:</p>
<pre><code>root=/dev/mapper/my-system-root</code></pre>
<p>You may also see a UUID (see <span class="xref" itemid="xref_target_Section 4.2.4">Section 4.2.4</span>):</p>
<pre><code>root=UUID=17f12d53-c3d7-4ab3-943e-a0a72366c9fa</code></pre>
<p><span epub:type="pagebreak" title="121" id="Page_121"/>Both of these are preferable because they do not depend on a specific kernel device mapping.</p>
<p>The <code>ro</code> parameter instructs the kernel to mount the root filesystem in read-only mode upon user space start. This is normal; read-only mode ensures that <code>fsck</code> can check the root filesystem safely before trying to do anything serious. After the check, the bootup process remounts the root filesystem in read-write mode.</p>
<p>Upon encountering a parameter that it doesn’t understand, the Linux kernel saves that parameter. The kernel later passes the parameter to init when performing the user space start. For example, if you add <code>-s</code> to the kernel parameters, the kernel passes the <code>-s</code> to the init program to indicate that it should start in single-user mode.</p>
<p>If you’re interested in the basic boot parameters, the bootparam(7) manual page gives an overview. If you’re looking for something very specific, you can check out <em>kernel-params.txt</em>, a reference file that comes with the Linux kernel.</p>
<p>With these basics covered, you should feel free to skip ahead to <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> to learn the specifics of user space start, the initial RAM disk, and the init program that the kernel runs as its first process. The remainder of this chapter details how the kernel loads into memory and starts, including how it gets its parameters.</p>
<h2 id="h1-500402c05-0004">	5.4	Boot Loaders</h2>
<p class="BodyFirst">At the start of the boot process, before the kernel and init start, a <em>boot loader</em> program starts the kernel. The boot loader’s job sounds simple: it loads the kernel into memory from somewhere on a disk and then starts the kernel with a set of kernel parameters. However, this job is more complicated than it appears. To understand why, consider the questions that the boot loader must answer:</p>
<ul>
<li>Where is the kernel?</li>
<li>What kernel parameters should be passed to the kernel when it starts?</li>
</ul>
<p>The answers are (typically) that the kernel and its parameters are usually somewhere on the root filesystem. It may sound like the kernel parameters should be easy to find, but remember that the kernel itself is not yet running, and it’s the kernel that usually traverses a filesystem to find the necessary files. Worse, the kernel device drivers normally used to access the disk are also unavailable. Think of this as a kind of “chicken or egg” problem. It can get even more complicated than this, but for now, let’s see how a boot loader overcomes the obstacles of the drivers and the filesystem.</p>
<p>A boot loader does need a driver to access the disk, but it’s not the same one that the kernel uses. On PCs, boot loaders use the traditional <em>Basic Input/Output System (BIOS)</em> or the newer <em>Unified Extensible Firmware Interface (UEFI)</em> to access disks. (<em>Extensible Firmware Interface</em>, or <em>EFI</em>, and UEFI will be discussed in more detail in <span class="xref" itemid="xref_target_Section 5.8.2">Section 5.8.2</span>.) Contemporary disk hardware includes <span epub:type="pagebreak" title="122" id="Page_122"/>firmware allowing the BIOS or UEFI to access attached storage hardware via <em>Logical Block Addressing (LBA)</em>. LBA is a universal, simple way to access data from any disk, but its performance is poor. This isn’t a problem, though, because boot loaders are often the only programs that must use this mode for disk access; after starting, the kernel has access to its own high-performance drivers.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	To determine if your system uses a BIOS or UEFI, run <var class="bold">efibootmgr</var>. If you get a list of boot targets, your system has UEFI. If instead you’re told that EFI variables aren’t supported, your system uses a BIOS. Alternatively, you can check to see that <em>/sys/firmware/</em><em>efi</em> exists; if so, your system uses UEFI.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Once access to the disk’s raw data has been resolved, the boot loader must do the work of locating the desired data on the filesystem. Most common boot loaders can read partition tables and have built-in support for read-only access to filesystems. Thus, they can find and read the files that they need to get the kernel into memory. This capability makes it far easier to dynamically configure and enhance the boot loader. Linux boot loaders have not always had this capability; without it, configuring the boot loader was more difficult.</p>
<p>In general, there’s been a pattern of the kernel adding new features (especially in storage technology), followed by boot loaders adding separate, simplified versions of those features to compensate.</p>
<h3 id="h2-500402c05-0001">5.4.1	Boot Loader Tasks</h3>
<p class="BodyFirst">A Linux boot loader’s core functionality includes the ability to do the following:</p>
<ul>
<li>Select from multiple kernels.</li>
<li>Switch between sets of kernel parameters.</li>
<li>Allow the user to manually override and edit kernel image names and parameters (for example, to enter single-user mode).</li>
<li>Provide support for booting other operating systems.</li>
</ul>
<p>Boot loaders have become considerably more advanced since the inception of the Linux kernel, with features such as command-line history and menu systems, but a basic need has always been flexibility in kernel image and parameter selection. (One surprising phenomenon is that some needs have actually diminished. For example, because you can perform an emergency or recovery boot from a USB storage device, you rarely have to worry about manually entering kernel parameters or going into single-user mode.) Current boot loaders offer more power than ever, which can be particularly handy if you’re building custom kernels or just want to tweak parameters.</p>
<h3 id="h2-500402c05-0002"><span epub:type="pagebreak" title="123" id="Page_123"/>5.4.2	Boot Loader Overview</h3>
<p class="BodyFirst">Here are the main boot loaders that you may encounter:</p>
<ol class="none">
<li><b>GRUB</b> A near-universal standard on Linux systems, with BIOS/MBR and UEFI versions.</li>
<li><b>LILO</b> One of the first Linux boot loaders. ELILO is a UEFI version.</li>
<li><b>SYSLINUX</b> Can be configured to run from many different kinds of filesystems.</li>
<li><b>LOADLIN</b> Boots a kernel from MS-DOS.</li>
<li><b>systemd-boot </b>A simple UEFI boot manager.</li>
<li><b>coreboot</b> (formerly LinuxBIOS) A high-performance replacement for the PC BIOS that can include a kernel.</li>
<li><b>Linux Kernel EFISTUB</b> A kernel plug-in for loading the kernel directly from a EFI/UEFI System Partition (ESP).</li>
<li><b>efilinux</b> A UEFI boot loader intended to serve as a model and reference for other UEFI boot loaders.</li>
</ol>
<p>This book deals almost exclusively with GRUB. The rationale behind using other boot loaders is that they’re simpler to configure than GRUB, they’re faster, or they provide some other special-purpose functionality.</p>
<p>You can learn a lot about a boot loader by getting to a boot prompt where you can enter a kernel name and parameters. To do this, you need to know how to get to a boot prompt or menu. Unfortunately, this can sometimes be difficult to figure out because Linux distributions heavily customize boot loader behavior and appearance. It’s usually impossible to tell just by watching the boot process which boot loader the distribution uses. </p>
<p>The next sections tell you how to get to a boot prompt in order to enter a kernel name and parameters. Once you’re comfortable with that, you’ll see how to configure and install a boot loader. </p>
<h2 id="h1-500402c05-0005">	5.5	GRUB Introduction</h2>
<p class="BodyFirst">GRUB stands for <em>Grand Unified Boot Loader</em>. We’ll cover GRUB 2, but there’s also an older version called GRUB Legacy that’s no longer in active use. </p>
<p>One of GRUB’s most important capabilities is filesystem navigation that allows for easy kernel image and configuration selection. One of the best ways to see this in action and to learn about GRUB in general is to look at its menu. The interface is easy to navigate, but there’s a good chance that you’ve never seen it. </p>
<p>To access the GRUB menu, press and hold <span class="KeyCaps">shift</span> when your BIOS startup screen first appears, or <span class="KeyCaps">esc</span> if your system has UEFI. Otherwise, the boot loader configuration may not pause before loading the kernel. <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a> shows the GRUB menu. </p>
<span epub:type="pagebreak" title="124" id="Page_124"/><figure>
<img src="image_fi/500402c05/f05001.png" alt="f05001"/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: GRUB menu</p></figcaption></figure>
<p>Try the following to explore the boot loader:</p>
<ol class="decimal">
<li value="1">Reboot or power on your Linux system.</li>
<li value="2">Hold down <span class="KeyCaps">shift</span> during the BIOS self-test or <span class="KeyCaps">esc</span> at the firmware splash screen to get the GRUB menu. (Sometimes these screens are not visible, so you have to guess when to press the button.)</li>
<li value="3">Press e to view the boot loader configuration commands for the default boot option. You should see something like <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a> (you might have to scroll down to see all of the details).
<figure>
<img src="image_fi/500402c05/f05002.png" alt="f05002"/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: GRUB configuration editor</p></figcaption></figure>
</li>
</ol>
<p><span epub:type="pagebreak" title="125" id="Page_125"/>This screen tells us that for this configuration, the root is set with a UUID, the kernel image is <em>/boot/vmlinuz-4.15.0-45-generic</em>, and the kernel parameters include <code>ro</code>, <code>quiet</code>, and <code>splash</code>. The initial RAM filesystem is <em>/boot/initrd.img-4.15.0-45-generic</em>. But if you’ve never seen this sort of configuration before, you might find it somewhat confusing. Why are there multiple references to <code>root</code>, and why are they different? Why is <code>insmod</code> here? If you’ve seen this before, you might remember that it’s a Linux kernel feature normally run by udevd. </p>
<p>The double takes are warranted, because GRUB doesn’t <em>use</em> the Linux kernel (remember, its job is to <em>start</em> the kernel). The configuration you see consists wholly of features and commands internal to GRUB, which exists in its own separate world.</p>
<p>The confusion stems partly from the fact that GRUB borrows terminology from many sources. GRUB has its own “kernel” and its own <code>insmod</code> command to dynamically load GRUB modules, completely independent of the Linux kernel. Many GRUB commands are similar to Unix shell commands; there’s even an <code>ls</code> command to list files.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	There’s a GRUB module for LVM that is required to boot systems where the kernel resides on a logical volume. You might see this on your system.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>By far, the most confusion results from GRUB’s use of the word <em>root</em>. Normally, you think of root as your system’s root filesystem. In a GRUB configuration, this is a kernel parameter, located somewhere after the image name of the <code>linux</code> command.</p>
<p>Every other reference to root in the configuration is to the GRUB root, which exists only inside of GRUB. The GRUB “root” is the filesystem where GRUB searches for kernel and RAM filesystem image files. </p>
<p>In <a href="#figure5-2">Figure 5-2</a>, the GRUB root is first set to a GRUB-specific device (<code>hd0,msdos1</code>), a default value for this configuration <span class="CodeAnnotation" aria-label="annotation1">1</span>. In the next command, GRUB then searches for a particular UUID on a partition <span class="CodeAnnotation" aria-label="annotation2">2</span>. If it finds that UUID, it sets the GRUB root to that partition.</p>
<p>To wrap it up, the <code>linux</code> command’s first argument (<code>/boot/vmlinuz-</code>. . .) is the location of the Linux kernel image file <span class="CodeAnnotation" aria-label="annotation3">3</span>. GRUB loads this file from the GRUB root. The <code>initrd</code> command is similar, specifying the file for the initial RAM filesystem covered in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>You can edit this configuration inside GRUB; doing so is usually the easiest way to temporarily fix an erroneous boot. To permanently fix a boot problem, you’ll need to change the configuration (see <span class="xref" itemid="xref_target_Section 5.5.2">Section 5.5.2</span>), but for now, let’s go one step deeper and examine some GRUB internals with the command-line interface.</p>
<h3 id="h2-500402c05-0003">5.5.1	Exploring Devices and Partitions with the GRUB Command Line</h3>
<p class="BodyFirst">As you can see in <a href="#figure5-2">Figure 5-2</a>, GRUB has its own device-addressing scheme. For example, the first hard disk found is named hd0, followed by hd1, and so on. Device name assignments are subject to change, but fortunately GRUB can search all partitions for UUIDs to find the one where the kernel resides, as you just saw in <a href="#figure5-2">Figure 5-2</a> with the <code>search</code> command. </p>
<h4 id="h3-500402c05-0001"><span epub:type="pagebreak" title="126" id="Page_126"/>Listing Devices</h4>
<p class="BodyFirst">To get a feel for how GRUB refers to the devices on your system, access the GRUB command line by pressing c at the boot menu or configuration editor. You should get the GRUB prompt:</p>
<pre><code>grub&gt;</code></pre>
<p>You can enter any command here that you see in a configuration, but to get started, try a diagnostic command instead: <code>ls</code>. With no arguments, the output is a list of devices known to GRUB:</p>
<pre><code>grub&gt; <b>ls</b>
(hd0) (hd0,msdos1)</code></pre>
<p>In this case, there is one main disk device denoted by <code>(hd0)</code> and a single partition <code>(hd0,msdos1)</code>. If there were a swap partition on the disk, it would show up as well, such as <code>(hd0,msdos5)</code>. The <code>msdos</code> prefix on the partitions tells you that the disk contains an MBR partition table; it would begin with <code>gpt</code> for GPT, found on UEFI systems. (There are even deeper combinations with a third identifier, where a BSD disklabel map resides inside a partition, but you won’t normally have to worry about this unless you’re running multiple operating systems on one machine.)</p>
<p>To get more detailed information, use <code>ls -l</code>. This command can be particularly useful because it displays any UUIDs of the partition filesystems. For example:</p>
<pre><code>grub&gt; <b>ls -l</b>
Device hd0: No known filesystem detected – Sector size 512B - Total size 32009856KiB
        Partition hd0,msdos1: Filesystem type ext* – Last modification time
          2019-02-14 19:11:28 Thursday, UUID 8b92610e-1db7-4ba3-ac2f-30ee24b39ed0 - Partition start at 1024Kib - Total size 32008192KiB</code></pre>
<p>This particular disk has a Linux ext2/3/4 filesystem on the first MBR partition. Systems using a swap partition will show another partition, but you won’t be able to tell its type from the output.</p>
<h4 id="h3-500402c05-0002">File Navigation</h4>
<p class="BodyFirst">Now let’s look at GRUB’s filesystem navigation capabilities. Determine the GRUB root with the <code>echo</code> command (recall that this is where GRUB expects to find the kernel):</p>
<pre><code>grub&gt; <b>echo $root</b>
hd0,msdos1</code></pre>
<p>To use GRUB’s <code>ls</code> command to list the files and directories in that root, you can append a forward slash to the end of the partition:</p>
<pre><code>grub&gt; <b>ls (hd0,msdos1)/</b></code></pre>
<p><span epub:type="pagebreak" title="127" id="Page_127"/>Because it’s inconvenient to type the actual root partition, you can substitute the <code>root</code> variable to save yourself some time:</p>
<pre><code>grub&gt; <b>ls ($root)/</b></code></pre>
<p>The output is a short list of file and directory names on that partition’s filesystem, such as <em>etc/</em>, <em>bin/</em>, and <em>dev/</em>. This is now a completely different function of the GRUB <code>ls</code> command. Before, you were listing devices, partition tables, and perhaps some filesystem header information. Now you’re actually looking at the contents of filesystems. </p>
<p>You can take a deeper look into the files and directories on a partition in a similar manner. For example, to inspect the <em>/boot</em> directory, start with the following:</p>
<pre><code>grub&gt; <b>ls ($root)/boot</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Use the up and down arrow keys to flip through the GRUB command history and the left and right arrows to edit the current command line. The standard readline keys (<span class="KeyCaps">ctrl</span>-N, <span class="KeyCaps">ctrl</span>-P, and so on) also work.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can also view all currently set GRUB variables with the <code>set</code> command:</p>
<pre><code>grub&gt; <b>set</b>
?=0
color_highlight=black/white
color_normal=white/black
--<var>snip</var>--
prefix=(hd0,msdos1)/boot/grub
root=hd0,msdos1</code></pre>
<p>One of the most important of these variables is <code>$prefix</code>, the filesystem and directory where GRUB expects to find its configuration and auxiliary support. We’ll discuss GRUB configuration next.</p>
<p>Once you’ve finished with the GRUB command-line interface, you can press <span class="KeyCaps">esc</span> to return to the GRUB menu. Alternatively, if you’ve set all of the necessary configuration for boot (including the <code>linux</code> and possibly <code>initrd</code> variables), you can enter the <code>boot</code> command to boot that configuration. In any case, boot your system. We’re going to explore the GRUB configuration, and that’s best done when you have your full system available.</p>
<h3 id="h2-500402c05-0004">5.5.2	GRUB Configuration</h3>
<p class="BodyFirst">The GRUB configuration directory is usually <em>/boot/grub</em> or <em>/boot/grub2</em>. It contains the central configuration file, <em>grub.cfg</em>, an architecture-specific directory such as <em>i386-pc</em> containing loadable modules with a <em>.mod</em> suffix, and a few other items such as fonts and localization information. We won’t modify <em>grub.cfg</em> directly; instead, we’ll use the <code>grub-mkconfig</code> command (or <code>grub2-mkconfig</code> on Fedora). </p>
<h4 id="h3-500402c05-0003"><span epub:type="pagebreak" title="128" id="Page_128"/>Reviewing grub.cfg</h4>
<p class="BodyFirst">First, take a quick look at <em>grub.cfg</em> to see how GRUB initializes its menu and kernel options. You’ll see that the file consists of GRUB commands, which usually begin with a number of initialization steps followed by a series of menu entries for different kernel and boot configurations. The initialization isn’t complicated, but there are a lot of conditionals at the beginning that might lead you to believe otherwise. This first part just consists of a bunch of function definitions, default values, and video setup commands such as this:</p>
<pre><code>if loadfont $font ; then
  set gfxmode=auto
  load_video
  insmod gfxterm
  --<var>snip</var>--</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Many variables such as <var>$font</var> originate from a <var>load_env</var> call near the beginning of <em>grub.cfg</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Later in the configuration file, you’ll find the available boot configurations, each beginning with the <code>menuentry</code> command. You should be able to read and understand this example based on what you learned in the preceding section:</p>
<pre><code>menuentry 'Ubuntu' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-8b92610e-1db7-4ba3-ac2f-30ee24b39ed0' {
        recordfail
        load_video
        gfxmode $linux_gfx_mode
        insmod gzio
        if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
        insmod part_msdos
        insmod ext2
        set root='hd0,msdos1'
        search --no-floppy --fs-uuid --set=root 8b92610e-1db7-4ba3-ac2f-30ee24b39ed0
        linux   /boot/vmlinuz-4.15.0-45-generic root=UUID=8b92610e-1db7-4ba3-ac2f-30ee24b39ed0 ro quiet splash $vt_handoff
        initrd  /boot/initrd.img-4.15.0-45-generic
}</code></pre>
<p>Examine your <em>grub.cfg</em> file for <code>submenu</code> commands containing multiple <code>menuentry</code> commands. Many distributions use the <code>submenu</code> command for older versions of the kernel so that they don’t crowd the GRUB menu.</p>
<h4 id="h3-500402c05-0004">Generating a New Configuration File</h4>
<p class="BodyFirst">If you want to make changes to your GRUB configuration, don’t edit your <em>grub.cfg</em> file directly, because it’s automatically generated and the system occasionally overwrites it. You’ll set up your new configuration elsewhere and then run <code>grub-mkconfig</code> to generate the new configuration.</p>
<p><span epub:type="pagebreak" title="129" id="Page_129"/>To see how the configuration generation works, look at the very beginning of <em>grub.cfg</em>. There should be comment lines such as this:</p>
<pre><code>### BEGIN /etc/grub.d/00_header ###</code></pre>
<p>Upon further inspection, you’ll find that nearly every file in <em>/etc/grub.d</em> is a shell script that produces a piece of the <em>grub.cfg</em> file. The <code>grub-mkconfig</code> command itself is a shell script that runs everything in <em>/etc/grub.d</em>. Keep in mind that GRUB itself does not run these scripts at boot time; we run the scripts in user space to generate the <em>grub.cfg</em> file that GRUB runs.</p>
<p>Try it yourself as root. Don’t worry about overwriting your current configuration. This command by itself simply prints the configuration to the standard output.</p>
<pre><code># <b>grub-mkconfig</b></code></pre>
<p>What if you want to add menu entries and other commands to the GRUB configuration? The short answer is that you should put your customizations into a new <em>custom.cfg</em> file in your GRUB configuration directory (usually <em>/boot/grub/custom.cfg</em>).</p>
<p>The long answer is a little more complicated. The <em>/etc/grub.d</em> configuration directory gives you two options: <em>40_custom</em> and <em>41_custom</em>. The first, <em>40_custom</em>, is a script that you can edit yourself, but it’s the least stable; a package upgrade is likely to destroy any changes you make. The <em>41_custom</em> script is simpler; it’s just a series of commands that load <em>custom.cfg</em> when GRUB starts. If you choose this second option, your changes won’t appear when you generate your configuration file because GRUB does all of the work at boot time.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The numbers in front of the filenames affect the processing order; lower numbers come first in the configuration file.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The two options for custom configuration files aren’t particularly extensive, and there’s nothing stopping you from adding your own scripts to generate configuration data. You might see some additions specific to your particular distribution in the <em>/etc/grub.d</em> directory. For example, Ubuntu adds memory tester boot options (<code>memtest86+</code>) to the configuration.</p>
<p>To write and install a newly generated GRUB configuration file, you can write the configuration to your GRUB directory with the <code>-o</code> option to <code>grub-mkconfig</code>, like this:</p>
<pre><code># <b>grub-mkconfig -o /boot/grub/grub.cfg</b></code></pre>
<p>As usual, back up your old configuration and make sure that you’re installing to the correct directory.</p>
<p>Now we’re going to get into some of the more technical details of GRUB and boot loaders. If you’re tired of hearing about boot loaders and the kernel, skip to <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<h3 id="h2-500402c05-0005"><span epub:type="pagebreak" title="130" id="Page_130"/>5.5.3	GRUB Installation</h3>
<p class="BodyFirst">Installing GRUB is more involved than configuring it. Fortunately, you won’t normally have to worry about installation because your distribution should handle it for you. However, if you’re trying to duplicate or restore a bootable disk, or preparing your own boot sequence, you might need to install it on your own.</p>
<p>Before proceeding, read <span class="xref" itemid="xref_target_Section 5.4">Section 5.4</span> to get an idea of how PCs boot and determine whether you’re using MBR or UEFI boot. Next, build the GRUB software set and determine where your GRUB directory will be; the default is <em>/boot/grub</em>. You may not need to build GRUB if your distribution does it for you, but if you do, see <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span> for how to build software from source code. Make sure that you build the correct target: it’s different for MBR or UEFI boot (and there are even differences between 32-bit and 64-bit EFI).</p>
<h4 id="h3-500402c05-0005">Installing GRUB on Your System</h4>
<p class="BodyFirst">Installing the boot loader requires that you or an installer program determine the following:</p>
<ul>
<li>The target GRUB directory as seen by your currently running system. As just mentioned, that’s usually <em>/boot/grub</em>, but it might be different if you’re installing GRUB on another disk for use on another system.</li>
<li>The current device of the GRUB target disk.</li>
<li>For UEFI booting, the current mount point of the EFI system partition (usually <em>/boot/efi</em>).</li>
</ul>
<p>Remember that GRUB is a modular system, but in order to load modules, it must read the filesystem that contains the GRUB directory. Your task is to construct a version of GRUB capable of reading that filesystem so that it can load the rest of its configuration (<em>grub.cfg</em>) and any required modules. On Linux, this usually means building a version of GRUB with its <em>ext2.mod</em> module (and possibly <em>lvm.mod</em>) preloaded. Once you have this version, all you need to do is place it on the bootable part of the disk and place the rest of the required files into <em>/boot/grub</em>.</p>
<p>Fortunately, GRUB comes with a utility called <code>grub-install</code> (not to be confused with <code>install-grub</code>, which you might find on some older systems), which performs most of the work of installing the GRUB files and configuration for you. For example, if your current disk is at <em>/dev/sda</em> and you want to install GRUB on that disk’s MBR with your current <em>/boot/grub </em>directory, use this command:</p>
<pre><code># <b>grub-install /dev/sda</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Incorrectly installing GRUB may break the bootup sequence on your system, so don’t take this command lightly. If you’re concerned, research how to back up your MBR with <var>dd</var>, back up any other currently installed GRUB directory, and make sure that you have an emergency bootup plan.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c05-0006"><span epub:type="pagebreak" title="131" id="Page_131"/>Installing GRUB Using MBR on an External Storage Device</h4>
<p class="BodyFirst">To install GRUB on a storage device outside the current system, you must manually specify the GRUB directory on that device as your current system now sees it. For example, say you have a target device of <em>/dev/sdc</em> and that device’s root filesystem containing <em>/boot</em> (for example, <em>/dev/sdc1</em>) is mounted on <em>/mnt</em> of your current system. This implies that when you install GRUB, your current system will see the GRUB files in <em>/mnt/boot/grub</em>. When running <code>grub-install</code>, tell it where those files should go as follows:</p>
<pre><code># <b>grub-install --boot-directory=/mnt/boot /dev/sdc</b></code></pre>
<p>On most MBR systems, <em>/boot</em> is a part of the root filesystem, but some installations put <em>/boot</em> into its own separate filesystem. Make sure that you know where your target <em>/boot</em> resides.</p>
<h4 id="h3-500402c05-0007">Installing GRUB with UEFI</h4>
<p class="BodyFirst">UEFI installation is supposed to be easier, because all you have to do is copy the boot loader into place. But you also need to “announce” the boot loader to the firmware—that is, save the loader configuration to the NVRAM—with the <code>efibootmgr</code> command. The <code>grub-install</code> command runs this if it’s available, so normally you can install GRUB on a UEFI system like this:</p>
<pre><code># <b>grub-install --efi-directory=<var class="bold">efi_dir</var> –-bootloader-id=<var class="bold">name</var></b></code></pre>
<p>Here, <var>efi_dir</var> is where the UEFI directory appears on your current system (usually <em>/boot/efi/EFI</em>, because the UEFI partition is typically mounted at <em>/boot/efi</em>) and <var>name</var> is an identifier for the boot loader.</p>
<p>Unfortunately, many problems can crop up when you’re installing a UEFI boot loader. For example, if you’re installing to a disk that will eventually end up in another system, you have to figure out how to announce that boot loader to the new system’s firmware. And there are differences in the install procedure for removable media. </p>
<p>But one of the biggest problems is UEFI secure boot.</p>
<h2 id="h1-500402c05-0006">	5.6	UEFI Secure Boot Problems</h2>
<p class="BodyFirst">One newer problem affecting Linux installations is dealing with the <em>secure boot</em> feature found on recent PCs. When active, this UEFI mechanism requires any boot loader to be digitally signed by a trusted authority in order to run. Microsoft has required hardware vendors shipping Windows 8 and later with their systems to use secure boot. The result is that if you try to install an unsigned boot loader on these systems, the firmware will reject the loader and the operating system won’t load.</p>
<p>Major Linux distributions have no problem with secure boot because they include signed boot loaders, usually based on a UEFI version of GRUB. Often there’s a small signed shim that goes between UEFI and GRUB; UEFI runs the shim, which in turn executes GRUB. Protecting against booting <span epub:type="pagebreak" title="132" id="Page_132"/>unauthorized software is an important feature if your machine is not in a trustworthy environment or needs to meet certain security requirements, so some distributions go a step further and require that the entire boot sequence (including the kernel) be signed.</p>
<p>There are some disadvantages to secure boot systems, especially for someone experimenting with building their own boot loaders. You can get around the secure boot requirement by disabling it in the UEFI settings. However, this won’t work cleanly for dual-boot systems since Windows won’t run without secure boot enabled.</p>
<h2 id="h1-500402c05-0007">	5.7	Chainloading Other Operating Systems</h2>
<p class="BodyFirst">UEFI makes it relatively easy to support loading other operating systems because you can install multiple boot loaders in the EFI partition. However, the older MBR style doesn’t support this functionality, and even if you do have UEFI, you may still have an individual partition with an MBR-style boot loader that you want to use. Instead of configuring and running a Linux kernel, GRUB can load and run a different boot loader on a specific partition on your disk; this is called <em>chainloading</em>.</p>
<p>To chainload, create a new menu entry in your GRUB configuration (using one of the methods described in the section <span class="xref" itemid="xref_target_“Generating a New Configuration File”">“Generating a New Configuration File”</span>). Here’s an example for a Windows installation on the third partition of a disk:</p>
<pre><code>menuentry "Windows" {
	insmod chain
	insmod ntfs
	set root=(hd0,3)
	chainloader +1
}</code></pre>
<p>The <code>+1</code> option tells <code>chainloader</code> to load whatever is at the first sector of a partition. You can also get it to directly load a file, by using a line like this to load the <em>io.sys</em> MS-DOS loader:</p>
<pre><code>menuentry "DOS" {
	insmod chain
	insmod fat
	set root=(hd0,3)
	chainloader /io.sys
}</code></pre>
<h2 id="h1-500402c05-0008">	5.8	Boot Loader Details</h2>
<p class="BodyFirst">Now we’ll look quickly at some boot loader internals. To understand how boot loaders like GRUB work, first we’ll survey how a PC boots when you turn it on. Because they must address the many inadequacies of traditional <span epub:type="pagebreak" title="133" id="Page_133"/>PC boot mechanisms, boot loading schemes have several variations, but there are two main ones: MBR and UEFI.</p>
<h3 id="h2-500402c05-0006">5.8.1	MBR Boot</h3>
<p class="BodyFirst">In addition to the partition information described in <span class="xref" itemid="xref_target_Section 4.1">Section 4.1</span>, the MBR includes a small area of 441 bytes that the PC BIOS loads and executes after its Power-On Self-Test (POST). Unfortunately, this space is inadequate to house almost any boot loader, so additional space is necessary, resulting in what is sometimes called a <em>multistage boot loader</em>. In this case the initial piece of code in the MBR does nothing other than load the rest of the boot loader code. The remaining pieces of the boot loader are usually stuffed into the space between the MBR and the first partition on the disk. This isn’t terribly secure because anything can overwrite the code there, but most boot loaders do it, including most GRUB installations.</p>
<p>This scheme of shoving the boot loader code after the MBR doesn’t work with a GPT-partitioned disk using the BIOS to boot because the GPT information resides in the area after the MBR. (GPT leaves the traditional MBR alone for backward compatibility.) The workaround for GPT is to create a small partition called a <em>BIOS boot partition</em> with a special UUID (<code>21686148-6449-6E6F-744E-656564454649</code>) to give the full boot loader code a place to reside. However, this isn’t a common configuration, because GPT is normally used with UEFI, not the traditional BIOS. It’s usually found only in older systems that have very large disks (greater than 2TB); these are too large for MBR.</p>
<h3 id="h2-500402c05-0007">5.8.2	UEFI Boot</h3>
<p class="BodyFirst">PC manufacturers and software companies realized that the traditional PC BIOS is severely limited, so they decided to develop a replacement called Extensible Firmware Interface (EFI), which we’ve already discussed a bit in a few places in this chapter. EFI took a while to catch on for most PCs, but today it’s the most common, especially now that Microsoft requires secure boot for Windows. The current standard is Unified EFI (UEFI), which includes features such as a built-in shell and the ability to read partition tables and navigate filesystems. The GPT partitioning scheme is part of the UEFI standard.</p>
<p>Booting is radically different on UEFI systems compared to MBR. For the most part, it’s much easier to understand. Rather than executable boot code residing outside of a filesystem, there’s always a special VFAT filesystem called the EFI System Partition (ESP), which contains a directory named <em>EFI</em>. The ESP is usually mounted on your Linux system at <em>/boot/efi</em>, so you’ll probably find most of the EFI directory structure starting at <em>/boot/efi/EFI</em>. Each boot loader has its own identifier and a corresponding subdirectory, such as <em>efi/microsoft</em>, <em>efi/apple</em>, <em>efi/ubuntu</em>, or <em>efi/grub</em>. A boot loader file has a <em>.efi</em> extension and resides in one of these subdirectories, along with other supporting files. If you go exploring, you might find files such as <em>grubx64.efi</em> (the EFI version of GRUB) and <em>shimx64.efi</em>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="134" id="Page_134"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The ESP differs from a BIOS boot partition, described in <span class="xref" itemid="xref_target_Section 5.8.1">Section 5.8.1</span>, and has a different UUID. You shouldn’t encounter a system with both.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>There’s a wrinkle, though: you can’t just put old boot loader code into the ESP, because the old code was written for the BIOS interface. Instead, you must provide a boot loader written for UEFI. For example, when using GRUB, you must install the UEFI version of GRUB rather than the BIOS version. And, as explained earlier in “Installing GRUB with UEFI,” you must announce new boot loaders to the firmware.</p>
<p>Finally, as <span class="xref" itemid="xref_target_Section 5.6">Section 5.6</span> noted, we have to contend with the “secure boot” issue.</p>
<h3 id="h2-500402c05-0008">5.8.3	How GRUB Works</h3>
<p class="BodyFirst">Let’s wrap up our discussion of GRUB by looking at how it does its work:</p>
<ol class="decimal">
<li value="1">The PC BIOS or firmware initializes the hardware and searches its boot-order storage devices for boot code.</li>
<li value="2">Upon finding the boot code, the BIOS/firmware loads and executes it. This is where GRUB begins.</li>
<li value="3">The GRUB core loads.</li>
<li value="4">The core initializes. At this point, GRUB can now access disks and filesystems. </li>
<li value="5">GRUB identifies its boot partition and loads a configuration there.</li>
<li value="6">GRUB gives the user a chance to change the configuration.</li>
<li value="7">After a timeout or user action, GRUB executes the configuration (the sequence of commands in the <em>grub.cfg</em> file, as outlined in <span class="xref" itemid="xref_target_Section 5.5.2">Section 5.5.2</span>).</li>
<li value="8">In the course of executing the configuration, GRUB may load additional code (modules) in the boot partition. Some of these modules may be preloaded.</li>
<li value="9">GRUB executes a <code>boot</code> command to load and execute the kernel as specified by the configuration’s <code>linux</code> command.</li>
</ol>
<p>Steps 3 and 4 of this sequence, where the GRUB core loads, can be complicated due to the inadequacies of traditional PC boot mechanisms. The biggest question is “Where <em>is</em> the GRUB core?” There are three basic possibilities:</p>
<ul>
<li>Partially stuffed between the MBR and the beginning of the first partition</li>
<li>In a regular partition</li>
<li>In a special boot partition: a GPT boot partition, ESP, or elsewhere</li>
</ul>
<p>In all cases except where you have an UEFI/ESP, the PC BIOS loads 512 bytes from the MBR, and that’s where GRUB starts. This little piece (derived from <em>boot.img</em> in the GRUB directory) isn’t yet the core, but it contains the start location of the core and loads the core from this point.</p>
<p><span epub:type="pagebreak" title="135" id="Page_135"/>However, if you have an ESP, the GRUB core goes there as a file. The firmware can navigate the ESP and directly execute all of GRUB or any other operating system loader located there. (You might have a shim in the ESP that goes just before GRUB to handle secure boot, but the idea is the same.)</p>
<p>Still, on most systems, this isn’t the complete picture. The boot loader might also need to load an initial RAM filesystem image into memory before loading and executing the kernel. That’s what the <code>initrd</code> configuration parameter specifies, and we’ll cover it in <span class="xref" itemid="xref_target_Section 6.7">Section 6.7</span>. But before you learn about the initial RAM filesystem, you should learn about the user space start—that’s where the next chapter begins.</p>
</section>
</body></html>