- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**EXAMINING STORAGE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查存储**'
- en: '![image](../images/00015.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00015.jpeg)'
- en: Over the next several chapters, we dive into specific Azure services and the
    pentest techniques and tools unique to each. We’ll begin with Azure Storage accounts,
    which are used by several Azure services to store everything from logs to virtual
    machine “hard disk” images. Customers also use storage accounts for document sharing
    and backups—essentially a cloud-based replacement for on-premises file servers.
    Of course, centralizing all of this data in one place makes for a tempting target
    for attackers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将深入探讨特定的 Azure 服务以及每种服务独特的渗透测试技术和工具。我们将从 Azure 存储账户开始，这些账户被多个 Azure
    服务用于存储从日志到虚拟机“硬盘”映像的所有内容。客户还使用存储账户进行文档共享和备份，基本上是本地文件服务器的云端替代方案。当然，将所有这些数据集中存储在一个地方会成为攻击者诱人的目标。
- en: Aside from the potential value of its data, a storage account is an ideal target
    for several reasons; the most important is that every storage account has two
    keys that grant full control to its data. These keys are shared by all services
    using the storage account and all account administrators. To make matters worse,
    most customers never change them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其数据潜在价值之外，存储账户出于多种原因是理想的攻击目标；其中最重要的是每个存储账户都有两个密钥，可以完全控制其数据。这些密钥被所有使用该存储账户的服务和所有账户管理员共享。更糟糕的是，大多数客户从不更改它们。
- en: 'These practices cause problems with repudiation, authorization, and remediation
    (if an attack does occur). Storage account keys also might have a user-inflicted
    weakness: because so many applications require storage access, developers often
    embed storage keys in their code or configuration files without considering the
    possible security ramifications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些做法会导致否认、授权和补救问题（如果确实发生攻击）。存储账户密钥还可能存在用户自身引发的弱点：因为许多应用程序需要存储访问权限，开发人员经常在其代码或配置文件中嵌入存储密钥，而未考虑可能的安全后果。
- en: 'In this chapter, we first discuss the different authentication methods available
    in Azure Storage. We then look at how to find these credentials in source code,
    followed by a look at each of the popular tools used to access and manage Azure
    Storage and how credentials can be stolen from them. This is important, because
    you won’t know ahead of time what utilities you’ll encounter on developer systems.
    Finally, we look at how to retrieve different forms of data from storage accounts.
    This serves two purposes: first, it demonstrates to clients that improperly secured
    cloud storage poses a significant risk of a data breach; second, the data in the
    accounts can sometimes be used to obtain additional access to an environment.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先讨论 Azure 存储中可用的不同身份验证方法。然后，我们将看看如何在源代码中找到这些凭据，接着看看每个常用工具用于访问和管理 Azure
    存储的方法以及如何从中窃取凭据。这非常重要，因为您事先不知道将在开发人员系统中遇到哪些实用程序。最后，我们将研究如何从存储账户中检索不同形式的数据。这有两个目的：首先，向客户证明未经适当保护的云存储存在重大数据泄露的风险；其次，账户中的数据有时可以用于获取对环境的额外访问权限。
- en: '**Best Practices: Storage Security**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最佳实践：存储安全**'
- en: Improperly configured cloud storage has been mentioned in over two dozen publicly
    disclosed data breaches between 2016 and 2018\. Generally, issues arise when developers
    write code that programmatically accesses a cloud storage container, and the developer
    embeds the access key in their source code and checks it in to source control.
    Since many companies use services like GitHub to host their code, the developer
    might not realize that the repository they checked the password into was publicly
    accessible. Occasionally, breaches also occur when storage accounts are configured
    to be readable by anyone, without requiring a password. Since malicious actors
    routinely scan public repositories looking for passwords and storage account URLs,
    trying to gain access, the time between a mistake and a breach can be very short.
    But even when access to a repository is limited, the number of people with access
    to the code is usually higher than the number of people who are authorized to
    have access keys. In addition, secrets and keys should never be stored in cleartext,
    even temporarily.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不当配置的云存储在2016年至2018年间已在超过二十起公开披露的数据泄露事件中被提及。通常，当开发人员编写程序化访问云存储容器的代码，并将访问密钥嵌入源代码中并提交到源代码管理系统时，会出现问题。由于许多公司使用像GitHub这样的服务来托管他们的代码，开发人员可能没有意识到他们提交密码的代码库是公开可访问的。偶尔，泄露也发生在存储账户被配置为任何人都可以读取，无需密码的情况下。由于恶意行为者定期扫描公共代码库，寻找密码和存储账户网址，试图获取访问权限，因此错误发生与泄露之间的时间可能非常短。但即使对代码库的访问是有限的，能够访问代码的人数通常也高于被授权访问密钥的人数。此外，密钥和密码绝不应以明文形式存储，即使是临时存储也不行。
- en: As an administrator, you can take several steps to protect against these issues.
    First, regularly practice “rolling” or resetting the access keys for your storage
    accounts and document any places where the keys need to be updated. This way,
    if a real incident does occur, you can begin remediation without worrying about
    breaking dependent services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员，您可以采取若干措施来防范这些问题。首先，定期进行存储账户的“滚动”或重置访问密钥，并记录需要更新密钥的地方。这样，如果发生实际事件，您可以在不担心破坏依赖服务的情况下开始修复工作。
- en: 'Next, enable encryption of data in transit and at rest for your cloud storage
    whenever possible. As of late 2017, Azure defaults to encrypting all data at rest
    in Azure Storage, using a key that is managed automatically. If desired, administrators
    can provide their own encryption key using the storage account settings in the
    Azure portal. However, although this setting protects the data on its storage
    medium, it doesn’t protect the data as it is uploaded or downloaded from the storage
    account. For this, the storage account must be configured to allow connections
    only over the HTTPS protocol. This can be done in the storage account configuration
    settings in Azure portal by enabling the “Secure transfer required” option. It
    can also be enabled via PowerShell:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尽可能启用云存储的数据传输和静态数据加密。从2017年底开始，Azure默认加密Azure存储中的所有静态数据，使用的是自动管理的密钥。如果需要，管理员可以通过Azure门户的存储账户设置提供自己的加密密钥。然而，尽管此设置保护了存储介质上的数据，但它并没有保护数据在上传或下载过程中。为此，存储账户必须配置为仅允许通过HTTPS协议连接。可以在Azure门户的存储账户配置设置中通过启用“要求安全传输”选项来实现。也可以通过PowerShell启用此功能：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To ensure that storage accounts can’t be accessed by more people than intended,
    regularly check the Access Type setting for your storage containers. It should
    be set to Private unless you intend to allow anonymous access. Additionally, you
    can use Shared Access Signature (SAS) access tokens to specify more granular permissions
    within storage accounts, including limiting access to specific time spans and
    IP ranges. For more information about these permissions, see *[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-manage-access-to-resources/](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-manage-access-to-resources/)*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保存储账户不会被超过预期的人访问，请定期检查存储容器的访问类型设置。除非您打算允许匿名访问，否则它应设置为私有。此外，您可以使用共享访问签名（SAS）访问令牌来指定存储账户内更细粒度的权限，包括限制访问的时间段和IP范围。有关这些权限的更多信息，请参阅
    *[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-manage-access-to-resources/](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-manage-access-to-resources/)*。
- en: Lastly, perform regular code reviews to look for instances of developers checking
    secrets into source code. You might even consider using a code analysis tool to
    automatically check for the presence of passwords whenever new code is checked
    in. This can be helpful not only for finding storage account keys but other credentials
    as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定期进行代码审查，查找开发人员将密钥检查到源代码中的实例。你甚至可以考虑使用代码分析工具，在每次提交新代码时自动检查是否包含密码。这不仅对查找存储帐户密钥有帮助，还能帮助发现其他凭据。
- en: '**Accessing Storage Accounts**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问存储帐户**'
- en: Azure Storage can be accessed through storage account keys, user credentials,
    and *Shared Access Signature (SAS)* tokens, which are URLs with embedded access
    keys that usually provide access to a limited subset of files and may have other
    restrictions. Each type of credential has a different purpose, and some are more
    useful to a penetration tester than others. Let’s examine each of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过存储帐户密钥、用户凭据和*共享访问签名（SAS）*令牌访问 Azure 存储，这些令牌是带有嵌入式访问密钥的 URL，通常提供对文件子集的访问权限，并可能有其他限制。每种凭据类型有不同的用途，有些对渗透测试人员比其他类型更有用。让我们逐一检查这些凭据。
- en: '***Storage Account Keys***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***存储帐户密钥***'
- en: Using storage account keys, paired with the name of a storage account, is the
    most desired and frequently used method of attack because they grant full access
    to the entire storage account without the need for 2FA. Storage accounts have
    only two keys—a primary and secondary—and all storage account users share these
    keys. These keys don’t expire on their own, but they can be rolled. Unlike passwords,
    which can be chosen by a user, storage keys are automatically generated 64-byte
    values represented in base64 encoding, which makes them easy to identify in source
    code or configuration files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储帐户密钥和存储帐户名称是最理想且最常用的攻击方法，因为它们允许完全访问整个存储帐户，而无需2FA。存储帐户只有两个密钥——一个主密钥和一个次密钥——所有存储帐户用户共享这些密钥。这些密钥不会自动过期，但可以被更新。与可以由用户选择的密码不同，存储密钥是自动生成的64字节值，以
    base64 编码表示，这使它们在源代码或配置文件中容易被识别。
- en: Storage keys are also supported by every Azure Storage utility and storage-related
    API, making them highly versatile. Additionally, they are the most common credential
    used by developers and are changed infrequently, so the chances of obtaining valid
    keys are good.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存储密钥也受到每个 Azure 存储工具和与存储相关的 API 的支持，因此它们非常通用。此外，它们是开发人员最常使用的凭据，并且不经常更改，因此获取有效密钥的机会较大。
- en: '***User Credentials***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户凭据***'
- en: Obtaining user credentials is the next-best way in. Although role-based permissions
    could limit a user account’s ability to perform certain actions against a storage
    account, in practice, permissions this granular are rarely implemented. The biggest
    downside to relying on these credentials is the potential for encountering 2FA.
    If a user’s account has 2FA enabled, it’s impossible to impersonate them without
    using one of the methods discussed in “[Encountering Two-Factor Authentication](part0011.html#lev38)”
    on [page 26](part0011.html#page_26). Those methods add additional complexity to
    an attack and decrease the odds of success. An additional hurdle when employing
    user credentials is the lack of tool support. Many of the Azure Storage utilities
    we’ll look at later in this chapter only accept storage keys, so you may have
    to log in to the Azure portal with the user credentials and copy the storage keys
    to use them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户凭据是下一个最佳的访问方式。尽管基于角色的权限可以限制用户帐户对存储帐户执行某些操作的能力，但实际上，这种细粒度的权限很少被实施。依赖这些凭据的最大缺点是可能遇到双因素认证（2FA）。如果用户帐户启用了2FA，那么在没有使用在“[遇到双因素认证](part0011.html#lev38)”中讨论过的某些方法的情况下，无法冒充该用户。这些方法增加了攻击的复杂性，降低了成功的概率。在使用用户凭据时，另一个障碍是工具的支持缺乏。我们将在本章后面讨论的许多
    Azure 存储工具仅接受存储密钥，因此您可能需要使用用户凭据登录到 Azure 门户并复制存储密钥以供使用。
- en: '***SAS Tokens***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SAS 令牌***'
- en: SAS tokens are keys that grant only certain rights to a subset of objects in
    a storage account. For example, SAS tokens are used to enable the “share a file”
    options in OneDrive, SharePoint Online, Office 365, Dropbox, and similar services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SAS 令牌是仅授予对存储帐户中某些对象的访问权限的密钥。例如，SAS 令牌用于启用 OneDrive、SharePoint Online、Office
    365、Dropbox 和类似服务中的“共享文件”选项。
- en: 'Azure SAS tokens are formatted as URLs that point to Azure Storage and contain
    a long string of parameters and a unique SHA256-hashed, base64-encoded key that
    looks something like this: *[https://storagerm.blob.core.windows.net/container/file.txt?st=2017-04-09T01%3A00%3A00Z&se=2017-04-20T01%3A00%3A00Z&sp=r&sip=127.0.0.1-127.0.0.100&sig=7%2BwycBOdzx8IS4zhMcKNw7AHvnZlYwk8wXIqNtLEu4s%3D](https://storagerm.blob.core.windows.net/container/file.txt?st=2017-04-09T01%3A00%3A00Z&se=2017-04-20T01%3A00%3A00Z&sp=r&sip=127.0.0.1-127.0.0.100&sig=7%2BwycBOdzx8IS4zhMcKNw7AHvnZlYwk8wXIqNtLEu4s%3D)*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SAS 令牌格式为指向 Azure 存储的 URL，其中包含一长串参数和一个独特的 SHA256 哈希值，经过 base64 编码，类似这样：
    *[https://storagerm.blob.core.windows.net/container/file.txt?st=2017-04-09T01%3A00%3A00Z&se=2017-04-20T01%3A00%3A00Z&sp=r&sip=127.0.0.1-127.0.0.100&sig=7%2BwycBOdzx8IS4zhMcKNw7AHvnZlYwk8wXIqNtLEu4s%3D](https://storagerm.blob.core.windows.net/container/file.txt?st=2017-04-09T01%3A00%3A00Z&se=2017-04-20T01%3A00%3A00Z&sp=r&sip=127.0.0.1-127.0.0.100&sig=7%2BwycBOdzx8IS4zhMcKNw7AHvnZlYwk8wXIqNtLEu4s%3D)*。
- en: Penetration testers may find SAS tokens not particularly useful, not only because
    they are usually scoped to a subset of files but also because they may have assigned
    permissions (via the SP parameter) such as read-only. SAS tokens can also be designated
    to work only from a specific IP address or range (via the SIP parameter), so even
    if you get a SAS token, it might only work from the machine for which it was originally
    created. SAS tokens might also have designated start and end times (via the ST
    and SE parameters, respectively) that limit a token’s lifetime to that period.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员可能会发现 SAS 令牌并不特别有用，不仅因为它们通常只对一小部分文件有效，还因为它们可能已分配了某些权限（通过 SP 参数），例如只读。SAS
    令牌也可以指定只能从特定的 IP 地址或范围（通过 SIP 参数）使用，因此即使你得到了一个 SAS 令牌，它也可能只对原本创建它的机器有效。SAS 令牌还可能有指定的开始和结束时间（通过
    ST 和 SE 参数，分别限制令牌的有效期）。
- en: As if all this wasn’t discouraging enough, most Azure tools don’t support SAS
    tokens. This means you’ll likely be limited to using them through a web browser.
    What’s more, if you somehow find a cache of these tokens, it will take some time
    to go through them sequentially, thus using up valuable testing hours. That said,
    if the prior two credential types aren’t available, a usable SAS token is better
    than no access at all.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些还不够让你灰心丧气，大多数 Azure 工具并不支持 SAS 令牌。这意味着你可能只能通过 web 浏览器使用它们。而且，如果你偶然找到这些令牌的缓存，逐一查看它们将需要一些时间，从而浪费宝贵的测试时间。话虽如此，如果前两种凭证类型不可用，能够使用
    SAS 令牌总比完全没有访问权限要好。
- en: '**DEFENDER’S TIP**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御者提示**'
- en: Microsoft provides detailed guidance on choosing the correct storage authentication
    options, common pitfalls, possible mitigations, and ways to recover from a compromised
    credential at *[https://docs.microsoft.com/en-us/azure/storage/storage-security-guide](https://docs.microsoft.com/en-us/azure/storage/storage-security-guide)*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了关于选择正确存储身份验证选项、常见陷阱、可能的缓解措施以及如何从泄露凭证中恢复的详细指南，详细内容可见于 *[https://docs.microsoft.com/en-us/azure/storage/storage-security-guide](https://docs.microsoft.com/en-us/azure/storage/storage-security-guide)*。
- en: '**Where to Find Storage Credentials**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找存储凭证的位置**'
- en: 'Now that you know the types of credentials to look for, let’s examine the most
    common places where they can be found: source code and storage management utilities.
    For source code sleuthing, you’ll need access to either a developer’s machine
    or their source code control system. To get keys out of storage utilities, you’ll
    need to find where these tools are installed; typically, this is on developer
    workstations. With access to these systems, you can begin hunting for keys.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了需要查找哪些类型的凭证，我们来看看它们可能最常见的几个存放位置：源代码和存储管理工具。对于源代码侦查，你需要访问开发人员的机器或他们的源代码控制系统。要从存储工具中提取密钥，你需要找到这些工具安装的位置；通常这些工具安装在开发人员的工作站上。有了对这些系统的访问权限，你就可以开始寻找密钥。
- en: '***Finding Keys in Source Code***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在源代码中查找密钥***'
- en: The most straightforward way to find storage keys is in the source code of applications
    that use Azure Storage—usually in configuration files used to build everything
    from an Azure website to custom business applications that use the cloud to store
    data. You have several ways to quickly locate storage keys in source code, but
    the method you should choose depends on the type of code you find.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查找存储密钥的最直接方法是通过使用 Azure 存储的应用程序的源代码—通常是在用于构建从 Azure 网站到自定义商业应用程序的配置文件中，这些应用程序使用云来存储数据。你有多种方法可以快速定位源代码中的存储密钥，但应选择的方式取决于你所找到的代码类型。
- en: Microsoft provides libraries for .NET (C# and Visual Basic) and Java to make
    it easier to access storage and other Azure features. Fortunately, the name of
    functions used to authenticate to Azure Storage are consistent across these libraries.
    Search for instances of the *StorageCredentials* class, and you’ll likely find
    where any application uses storage keys. If that doesn’t work, try searching for
    the library’s full name, such as *Microsoft.WindowsAzure.Storage.Auth* in .NET
    or *com.microsoft.azure.storage.StorageCredentials* in Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 为 .NET（C# 和 Visual Basic）以及 Java 提供了库，使得访问存储和其他 Azure 功能更加简便。幸运的是，这些库中用于验证
    Azure 存储的函数名称是一致的。搜索 *StorageCredentials* 类的实例，你很可能会找到任何应用程序使用存储密钥的地方。如果这不起作用，可以尝试搜索库的完整名称，比如在
    .NET 中是 *Microsoft.WindowsAzure.Storage.Auth*，在 Java 中是 *com.microsoft.azure.storage.StorageCredentials*。
- en: If you suspect that a certain storage instance may use SAS tokens, search code
    repositories for *.core.windows.net*, the domain used in all SAS token URLs. (The
    base64 signature in SAS tokens should make them easy to distinguish from any other
    *windows.net* domain references.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑某个存储实例可能使用了 SAS 令牌，可以在代码仓库中搜索 *.core.windows.net*，这是所有 SAS 令牌 URL 中使用的域名。（SAS
    令牌中的 base64 签名应该使它们与任何其他 *windows.net* 域名引用易于区分。）
- en: Many code bases place storage account keys into configuration files, especially
    when coupled with ASP.NET and Azure websites. ASP.NET and Azure websites use files
    named *web.config*, whereas other websites often use *app.config* files. Storage
    account keys in config files are often labeled *StorageAccountKey*, *StorageServiceKeys*,
    or *StorageConnectionString* (the name used in some Microsoft documentation sample
    code).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码库将存储账户密钥放入配置文件中，尤其是在与 ASP.NET 和 Azure 网站结合使用时。ASP.NET 和 Azure 网站使用名为 *web.config*
    的文件，而其他网站则通常使用 *app.config* 文件。配置文件中的存储账户密钥通常标记为 *StorageAccountKey*、*StorageServiceKeys*
    或 *StorageConnectionString*（这是某些 Microsoft 文档示例代码中使用的名称）。
- en: You can identify Azure Storage use within JavaScript files by scanning for *azure-storage.common.js*.
    If you find this script reference in code, also look for *AzureStorage.createBlobService*;
    you’ll need it in order to authenticate to Azure. (The JavaScript library allows
    the use of both storage keys and SAS tokens, but greatly encourages the use of
    highly restricted SAS tokens because users can view JavaScript code.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过扫描 *azure-storage.common.js* 来识别 JavaScript 文件中的 Azure 存储使用。如果你在代码中找到这个脚本引用，还需要查找
    *AzureStorage.createBlobService*；你需要它来进行 Azure 身份验证。（JavaScript 库允许使用存储密钥和 SAS
    令牌，但强烈鼓励使用高度限制的 SAS 令牌，因为用户可以查看 JavaScript 代码。）
- en: '***Obtaining Keys from a Developer’s Storage Utilities***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从开发人员的存储工具中获取密钥***'
- en: If you can’t find storage keys in source code, you may be able to recover them
    from tools that the developers used to transfer files to Azure. To find these
    keys, you first need to access a developer’s workstation and then look for Azure
    Storage management applications. Once you have access, check the application to
    see if it exposes saved keys in its user interface or if it saves the keys in
    an insecure manner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在源代码中找到存储密钥，你可以尝试从开发人员用来传输文件到 Azure 的工具中恢复这些密钥。要找到这些密钥，首先需要访问开发人员的工作站，然后查找
    Azure 存储管理应用程序。一旦访问成功，检查该应用程序是否在其用户界面中暴露了已保存的密钥，或者是否以不安全的方式保存了密钥。
- en: In this section, we look at the tools most commonly used to manage storage accounts
    to see if they’re susceptible to this attack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看最常用的存储账户管理工具，看看它们是否容易受到此类攻击。
- en: '**DEFENDER’S TIP**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**防御者提示**'
- en: Notice in the following discussion that only Microsoft Azure Storage Explorer
    makes key recovery difficult for an attacker. If you must use a tool to manage
    Azure Storage and if you have cached credentials on your system, Microsoft Azure
    Storage Explorer is the safest choice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论中，请注意，只有 Microsoft Azure Storage Explorer 使得攻击者恢复密钥变得困难。如果你必须使用工具来管理
    Azure 存储，并且系统中缓存了凭据，Microsoft Azure Storage Explorer 是最安全的选择。
- en: '**Getting Keys from Microsoft Azure Storage Explorer**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 Microsoft Azure Storage Explorer 获取密钥**'
- en: Azure Storage Explorer is well designed, with storage key protection as an obvious
    goal. It offers no option to show a key once it’s saved in the interface, and
    the encrypted keys are stored in Windows Credential Manager, which makes recovering
    them directly impractical.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Storage Explorer 设计良好，存储密钥保护是其显而易见的目标。它没有显示密钥的选项，一旦密钥被保存在界面中，且加密的密钥被存储在
    Windows 凭据管理器中，这使得直接恢复它们变得不实际。
- en: Despite these security features, all is not lost. Because Azure Storage Explorer
    needs to decrypt the keys in order to provide them to Azure’s API when transferring
    data, you can set a breakpoint in Storage Explorer’s code on the line just after
    the keys are decrypted and then view them directly in memory with the built-in
    debugger.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些安全功能，但一切并未失去。因为 Azure Storage Explorer 需要解密密钥，以便在传输数据时将其提供给 Azure 的 API，你可以在
    Storage Explorer 的代码中设置一个断点，位置在密钥解密后的下一行，然后使用内置调试器直接在内存中查看它们。
- en: 'To perform this test, follow these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此测试，请按照以下步骤进行：
- en: Launch Azure Storage Explorer on the target engineer’s workstation.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标工程师的工作站上启动 Azure Storage Explorer。
- en: Choose **Help** ▸ **Toggle Developer Tools**. You should see the debugger interface.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**帮助** ▸ **切换开发者工具**。你应该能看到调试器界面。
- en: In the debugging window, click the **Sources** tab at the top of the screen
    and then click the vertical ellipse menu and choose **Go to file**, as shown in
    [Figure 4-1](part0013.html#ch04fig1).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试窗口中，点击屏幕顶部的**源代码**选项卡，然后点击垂直省略号菜单并选择**转到文件**，如[图 4-1](part0013.html#ch04fig1)所示。
- en: '![image](../images/00021.jpeg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/00021.jpeg)'
- en: '*Figure 4-1: The Sources view in Azure Storage Explorer*'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-1：Azure Storage Explorer 中的源代码视图*'
- en: In the file list dialog that appears, enter AzureStorageUtilities.js and click
    the first entry to load the *AzureStorageUtilities.js* file, which contains the
    logic to load the storage account keys.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的文件列表对话框中，输入 AzureStorageUtilities.js 并点击第一个条目加载 *AzureStorageUtilities.js*
    文件，该文件包含加载存储帐户密钥的逻辑。
- en: Expand the debugger window so you can read the source code; then find the function
    `loadStorageAccounts(host, key)`, which is shown in [Listing 4-1](part0013.html#ch04list1).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开调试器窗口，以便查看源代码；然后找到 `loadStorageAccounts(host, key)` 函数，该函数显示在[清单 4-1](part0013.html#ch04list1)中。
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-1: Code snippet from Microsoft Azure Storage Explorer’s* loadStorageAccounts()
    *function*'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*清单 4-1：来自 Microsoft Azure Storage Explorer 的代码片段* loadStorageAccounts() *函数*'
- en: Set a breakpoint in this function just before the account information is returned
    to the application by clicking the line number for the line `return account;`
    on the left side of the window, as shown in [Figure 4-2](part0013.html#ch04fig2).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数中设置一个断点，位置在帐户信息返回应用程序之前，点击窗口左侧 `return account;` 行号，如[图 4-2](part0013.html#ch04fig2)所示。
- en: 'Now, to trigger the application to reload the account information so that the
    breakpoint will be hit, click **Refresh All** above the list of accounts. The
    debugger should break in and pause the application. Look for the account: Object
    variable on the right side of the window (as shown in [Figure 4-2](part0013.html#ch04fig2))
    and click the arrow next to `account` to expand it.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了触发应用程序重新加载帐户信息以便触发断点，点击帐户列表上方的**刷新所有**。调试器应该会中断并暂停应用程序。查看窗口右侧的帐户：对象变量（如[图
    4-2](part0013.html#ch04fig2)所示），点击 `account` 旁边的箭头展开它。
- en: '![image](../images/00022.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00022.jpeg)'
- en: '*Figure 4-2: Account object expanded in the debugger*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：在调试器中展开的帐户对象*'
- en: The `account` object should list the `accountKey` as well as the `accountName`
    of the first storage account registered in Azure Storage Explorer. To see if there
    are multiple accounts, press F8 to continue execution. If there are more storage
    accounts, the debugger should immediately break in again and update the account
    object with the next account details. Keep pressing F8 until you have recovered
    the connection information for each storage account.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`account` 对象应列出第一个在 Azure Storage Explorer 中注册的存储帐户的 `accountKey` 和 `accountName`。要查看是否有多个帐户，请按
    F8 继续执行。如果有更多存储帐户，调试器应立即中断并更新帐户对象，显示下一个帐户的详细信息。继续按 F8，直到你恢复了每个存储帐户的连接信息。'
- en: Once the last storage account’s details are shown, press F8 again to return
    the application to normal operation. Then remove your breakpoint by right-clicking
    in the Breakpoints list in the pane on the right and choosing **Remove All Breakpoints**.
    Finally, click **Help** ▸ **Toggle Developer Tools** to close the debugging tools
    and then exit the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一个存储帐户的详细信息显示后，再次按 F8 以恢复应用程序的正常操作。然后，在右侧窗格的断点列表中右键单击并选择**移除所有断点**来移除断点。最后，点击**帮助**
    ▸ **切换开发者工具**以关闭调试工具，然后退出应用程序。
- en: '**Getting Keys from Redgate’s Azure Explorer**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 Redgate 的 Azure Explorer 获取密钥**'
- en: 'Redgate’s Azure Explorer gives you two ways to access the keys it contains:
    a connection editor dialog and a Copy option in each account’s context menu. To
    view account keys, launch Redgate’s Azure Explorer, open the account, and then
    right-click the account to dig into its details, as shown in [Figure 4-3](part0013.html#ch04fig3).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Redgate 的 Azure Explorer 提供了两种方式来访问其中包含的密钥：连接编辑器对话框和每个帐户上下文菜单中的复制选项。要查看帐户密钥，启动
    Redgate 的 Azure Explorer，打开帐户，然后右键单击帐户以查看其详细信息，如 [图 4-3](part0013.html#ch04fig3)
    所示。
- en: '![image](../images/00023.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00023.jpeg)'
- en: '*Figure 4-3: Redgate’s storage account menu*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：Redgate 的存储帐户菜单*'
- en: The Edit Connection Details option opens a dialog like the one shown in [Figure
    4-4](part0013.html#ch04fig4), where you can update the key associated with a storage
    account. The dialog conveniently displays the current key in plaintext.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑连接详细信息选项会打开一个对话框，如 [图 4-4](part0013.html#ch04fig4) 所示，在这个对话框中你可以更新与存储帐户关联的密钥。对话框方便地以明文显示当前的密钥。
- en: '![image](../images/00024.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00024.jpeg)'
- en: '*Figure 4-4: Storage account key in Redgate’s Azure Explorer*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：Redgate 的 Azure Explorer 中的存储帐户密钥*'
- en: The Copy Connection String option is also interesting. You can use it to copy
    the key to the clipboard in SQL Connection String format, which contains the key
    itself and the account name, and also indicates whether the storage account should
    be accessed using SSL or an unencrypted connection. Use this option to grab all
    required connection information for an account and then paste it into a small
    document. Repeat this for each listed account.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 复制连接字符串选项也很有趣。你可以用它将密钥以 SQL 连接字符串格式复制到剪贴板，连接字符串中包含密钥本身和帐户名称，还可以指示是否应使用 SSL 或未加密的连接访问存储帐户。使用此选项抓取帐户所需的所有连接信息，然后将其粘贴到一个小文档中。对每个列出的帐户重复此操作。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because Redgate encrypts storage keys in Azure Explorer’s settings file* %UserProfile%\AppData\Local\Red
    Gate\Azure Explorer\Settings.xml*, you will need to be able to run Azure Explorer
    to recover the keys; you can’t simply take the XML file.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为 Redgate 在 Azure Explorer 的设置文件 %UserProfile%\AppData\Local\Red Gate\Azure
    Explorer\Settings.xml 中加密了存储密钥*，你需要能够运行 Azure Explorer 来恢复密钥；你不能仅仅拿到 XML 文件。*'
- en: '**Getting Keys from ClumsyLeaf’s CloudXplorer**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 ClumsyLeaf 的 CloudXplorer 获取密钥**'
- en: 'ClumsyLeaf Software makes three products for interacting with cloud-based storage:
    CloudXplorer, TableXplorer, and AzureXplorer. All of these tools allow you to
    manage not just Azure Storage but also storage offerings from other providers,
    such as Amazon and Google.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ClumsyLeaf 软件公司开发了三款用于与云存储交互的产品：CloudXplorer、TableXplorer 和 AzureXplorer。所有这些工具不仅可以管理
    Azure 存储，还可以管理其他提供商的存储服务，如亚马逊和谷歌。
- en: CloudXplorer interacts with files and blob storage, whereas TableXplorer provides
    a SQL-like interface for tabular cloud storage. AzureXplorer is a Visual Studio
    plug-in to make interacting with cloud content easier during development.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CloudXplorer 处理文件和 Blob 存储，而 TableXplorer 为表格型云存储提供类似 SQL 的接口。AzureXplorer 是一个
    Visual Studio 插件，旨在简化开发过程中与云内容的交互。
- en: You can view and edit stored keys in CloudXplorer by right-clicking a storage
    account in the left pane and choosing **Properties**, as shown in [Figure 4-5](part0013.html#ch04fig5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在左侧窗格中右键单击存储帐户并选择 **属性** 来查看和编辑 CloudXplorer 中存储的密钥，如 [图 4-5](part0013.html#ch04fig5)
    所示。
- en: '![image](../images/00025.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00025.jpeg)'
- en: '*Figure 4-5: Storage account context menu in CloudXplorer*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：CloudXplorer 中的存储帐户上下文菜单*'
- en: The Account window (see [Figure 4-6](part0013.html#ch04fig6)) shows which Azure
    instance is being used and whether SSL is enabled, and should allow you to copy
    both the name and key of the storage account.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 账户窗口（参见 [图 4-6](part0013.html#ch04fig6)）显示当前使用的是哪个 Azure 实例，是否启用了 SSL，并且应该允许你复制存储帐户的名称和密钥。
- en: '![image](../images/00026.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00026.jpeg)'
- en: '*Figure 4-6: Account information in CloudXplorer*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：CloudXplorer 中的帐户信息*'
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*CloudXplorer’s Configuration* ▸ *Export option exports all of the storage
    account connection details, but they’re encrypted. You’re not likely to find that
    very useful.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*CloudXplorer 的配置* ▸ *导出选项会导出所有存储帐户连接的详细信息，但它们是加密的。你可能会发现这不太有用。*'
- en: Like Redgate, ClumsyLeaf also encrypts its account information within an XML
    file. You’ll find it at *%AppData%\ClumsyLeaf Software\CloudXplorer\accounts.xml*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redgate 一样，ClumsyLeaf 也将其帐户信息加密存储在 XML 文件中。你可以在 *%AppData%\ClumsyLeaf Software\CloudXplorer\accounts.xml*
    找到它。
- en: '**Getting Keys from ClumsyLeaf’s TableXplorer**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 ClumsyLeaf 的 TableXplorer 获取密钥**'
- en: To use TableXplorer to view storage accounts, click **Manage Accounts**, as
    shown in [Figure 4-7](part0013.html#ch04fig7), to open the Manage Accounts window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 TableXplorer 查看存储账户，点击**管理账户**，如[图 4-7](part0013.html#ch04fig7)所示，打开管理账户窗口。
- en: '![image](../images/00027.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00027.jpeg)'
- en: '*Figure 4-7: The Manage Accounts button in TableXplorer*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：TableXplorer 中的管理账户按钮*'
- en: The Manage Accounts window should display each account, as shown in [Figure
    4-8](part0013.html#ch04fig8). Azure Storage accounts are marked with a Windows
    logo and Amazon accounts with an orange cube. Click the name of an account and
    choose **Edit**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 管理账户窗口应显示每个账户，如[图 4-8](part0013.html#ch04fig8)所示。Azure 存储账户标有 Windows 标志，而 Amazon
    账户则标有橙色立方体。点击一个账户的名称并选择**编辑**。
- en: '![image](../images/00028.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/00028.jpeg)'
- en: '*Figure 4-8: Account list in TableXplorer*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：TableXplorer 中的账户列表*'
- en: The Edit window will look just like the CloudXplorer window shown earlier in
    [Figure 4-6](part0013.html#ch04fig6). Also, like CloudXplorer, TableXplorer encrypts
    the keys in its configuration file, which is located at *%AppData%\ClumsyLeaf
    Software\TableXplorer\accounts.xml*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑窗口将与之前在[图 4-6](part0013.html#ch04fig6)中显示的 CloudXplorer 窗口相同。此外，像 CloudXplorer
    一样，TableXplorer 会加密其配置文件中的密钥，该文件位于*%AppData%\ClumsyLeaf Software\TableXplorer\accounts.xml*。
- en: '**Getting Keys from Azure Storage Explorer 6**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 Azure Storage Explorer 6 获取密钥**'
- en: Azure Storage Explorer 6 is probably the oldest tool on this list. Although
    it’s no longer maintained, it was the standard for years, and you’ll probably
    find it on many developer systems for years to come.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Storage Explorer 6 可能是这个列表中最古老的工具。尽管它不再维护，但它曾是标准工具多年，你可能会在许多开发者的系统中找到它，未来几年也可能继续使用。
- en: 'To view storage account settings through Azure Storage Explorer 6, follow these
    steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Azure Storage Explorer 6 查看存储账户设置，请按照以下步骤操作：
- en: Launch the application and choose an account from the drop-down list.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并从下拉列表中选择一个账户。
- en: Select the account and then choose **Storage Account** ▸ **View Connection String**,
    as shown in [Figure 4-9](part0013.html#ch04fig9).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择账户后，点击**存储账户** ▸ **查看连接字符串**，如[图 4-9](part0013.html#ch04fig9)所示。
- en: '![image](../images/00029.jpeg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/00029.jpeg)'
- en: '*Figure 4-9: The Storage Account menu in Azure Storage Explorer 6*'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-9：Azure Storage Explorer 6 中的存储账户菜单*'
- en: You should see a pop-up message box appear, displaying the SQL Connection String–formatted
    account key, as shown in [Figure 4-10](part0013.html#ch04fig10). Click **OK**
    to copy the value to the clipboard.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到一个弹出消息框，显示格式化的 SQL 连接字符串账户密钥，如[图 4-10](part0013.html#ch04fig10)所示。点击**确定**将值复制到剪贴板。
- en: '![image](../images/00030.jpeg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/00030.jpeg)'
- en: '*Figure 4-10: Storage account connection string in Azure Storage Explorer 6*'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-10：Azure Storage Explorer 6 中的存储账户连接字符串*'
- en: Prior to version 6 of Azure Storage Explorer, unencrypted credentials were stored
    in *%AppData%\AzureStorageExplorer\AzureStorageExplorer.config*, making this a
    valuable file to look for any time you suspect a machine has been used to manage
    storage accounts. Beginning with version 6, these settings were encrypted and
    moved to *%AppData%\Neudesic\AzureStorageExplorer\<Version>\AzureStorageExplorer6.dt1*.
    However, because Azure Storage Explorer is open source and because the same encryption
    key is used in every installation, it’s very easy to find the encryption key it
    uses to “protect” these files online, as well as the encryption and decryption
    code. Of course, it’s easier to recover storage keys from the GUI, but it’s helpful
    to have another option if you can’t launch applications on the system you’re targeting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Storage Explorer 6 版本之前，未加密的凭据存储在*%AppData%\AzureStorageExplorer\AzureStorageExplorer.config*中，因此每当你怀疑某台机器被用来管理存储账户时，这个文件是一个值得查找的文件。从版本
    6 开始，这些设置被加密并移动到*%AppData%\Neudesic\AzureStorageExplorer\<Version>\AzureStorageExplorer6.dt1*。然而，由于
    Azure Storage Explorer 是开源的，并且每次安装使用相同的加密密钥，所以非常容易在网上找到它用来“保护”这些文件的加密密钥，以及加密和解密代码。当然，从
    GUI 恢复存储密钥更容易，但如果你无法在目标系统上启动应用程序，那么有其他选项也会很有帮助。
- en: '**Accessing Storage Types**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问存储类型**'
- en: Once you have access to a storage account, it’s time to find out what kind of
    data you can obtain. First, you’ll need to determine which storage mechanisms
    each account uses (blob, table, queue, and/or file), bearing in mind that a single
    account can use more than one mechanism. Be sure to check each account for each
    storage type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你访问了存储账户，就该了解可以获取何种类型的数据了。首先，你需要确定每个账户使用了哪种存储机制（Blob、表、队列和/或文件），并记住一个账户可以使用多个存储机制。务必检查每个账户的每种存储类型。
- en: '***Identifying the Storage Mechanisms in Use***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别正在使用的存储机制***'
- en: Although you can check for storage account content using the Azure portal, a
    penetration tester could face a couple of challenges with that method. First,
    an account may have only a management certificate, which won’t provide direct
    portal access. Second, the Azure portal doesn’t display a summary of each storage
    type in one view; you have to click each account, click to view any blobs in that
    account, and then click the button for files, and so on. This process takes a
    while when subscriptions contain numerous storage accounts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用 Azure 门户检查存储账户的内容，但渗透测试者在使用这种方法时可能会面临一些挑战。首先，账户可能只有一个管理证书，这将无法提供直接的门户访问权限。其次，Azure
    门户不会在一个视图中显示每种存储类型的摘要；你需要点击每个账户，点击查看该账户中的任何 Blob，然后点击查看文件的按钮，依此类推。当订阅中包含大量存储账户时，这个过程需要花费一些时间。
- en: The best way to identify the storage types in use is with PowerShell. For example,
    the PowerShell script shown in [Listing 4-2](part0013.html#ch04list2) will enumerate
    all storage accounts in a subscription, check each storage mechanism for content,
    and then display a summary of anything it finds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 识别正在使用的存储类型最好的方法是使用 PowerShell。例如，下面的 PowerShell 脚本在[列表 4-2](part0013.html#ch04list2)中显示，将枚举订阅中的所有存储账户，检查每种存储机制的内容，然后显示它找到的任何内容的摘要。
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-2: Listing storage account usage via PowerShell*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：通过 PowerShell 列出存储账户使用情况*'
- en: 'This script is split into two parts: the first part searches ASM storage accounts,
    and the second searches ARM.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本分为两部分：第一部分搜索 ASM 存储账户，第二部分搜索 ARM。
- en: We begin by getting a list of all ASM storage accounts in the subscription ➊.
    For each account, we obtain the key ➋ and then create a *context* for that storage
    account ➌—a PowerShell object that contains both the name and key of the storage
    account. We can use this context when accessing a storage account in the future.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取订阅中所有 ASM 存储账户的列表 ➊。对于每个账户，我们获取密钥 ➋ 然后为该存储账户创建一个 *上下文* ➌——一个包含存储账户名称和密钥的
    PowerShell 对象。以后访问存储账户时，我们可以使用这个上下文。
- en: Next, the script begins examining the different storage types, as discussed
    in the following sections, before repeating the process for ARM storage accounts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本开始检查不同的存储类型，如后续章节所讨论的内容，然后对 ARM 存储账户重复该过程。
- en: '***Accessing Blobs***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问 Blob***'
- en: 'A blob is the most basic form of storage in Azure: it’s an unstructured collection
    of bits that applications can use without restriction. Blobs are most commonly
    used to store virtual hard disk files for Azure virtual machines.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Blob 是 Azure 中最基本的存储形式：它是一个无结构的比特集合，应用程序可以自由使用。Blob 最常用于存储 Azure 虚拟机的虚拟硬盘文件。
- en: 'You’ll find three kinds of blobs in Azure: *page*, *append*, and *block*. As
    a pentester, it can be helpful to know the primary usage for each blob type so
    you can make an educated guess about the contents of a given blob without necessarily
    having to download it. In my assessments, I’ve found it can be enormously frustrating
    to download a multi-gigabyte file over several hours, only to discover it isn’t
    what I expected.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，你会发现三种类型的 Blob：*页面 Blob*、*追加 Blob* 和 *块 Blob*。作为渗透测试者，了解每种 Blob 类型的主要用途可能会很有帮助，这样你可以在不必下载的情况下，对给定的
    Blob 内容做出合理的猜测。在我的评估中，我发现下载一个数十 GB 的文件需要几个小时，而最终发现它并不是我预期的内容，这种情况令人非常沮丧。
- en: '*Page blobs* are made up of sets of bytes, referred to as *pages*. Each page
    is 512 bytes, and a page blob itself can be up to 1TB in size. The total size
    must be set when the blob is created, which means there is a strong chance a page
    blob file will be quite large, but only a small fraction of it will be data—the
    rest will likely be empty. Because page blobs are very efficient at random reads/writes,
    they are the blob type used for hard disk images.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*页面 Blob* 由一组字节组成，称为 *页*。每个页的大小为 512 字节，页面 Blob 本身的最大大小可以达到 1TB。总大小必须在创建 Blob
    时设置，这意味着页面 Blob 文件可能会非常大，但其中只有一小部分是数据，其余部分可能是空的。由于页面 Blob 在随机读写操作时非常高效，因此它们是用于硬盘映像的
    Blob 类型。'
- en: '*Append blobs* are optimized for adding new data, but changes are prohibited
    to existing data within the blob. They can be up to 195GB in size and are ideal
    for log files. Log files may be interesting if you are trying to identify additional
    user accounts, IP addresses, or servers that could be related to your assessment;
    however, if you are just hoping to modify logs to erase your tracks, append blobs
    won’t let you do so.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Block blobs* are the default type. They consist of one or more blocks of bytes
    that can vary in size up to 100MB. Up to 50,000 blocks can be placed in a single
    blob, and block blobs can grow as needed. This is used for all other types of
    unstructured data.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure requires users to place all blobs in a *container*, which is like a file
    directory, except that it can’t be nested. In other words, a container can hold
    blobs, but not other containers. Each storage account can have an unlimited number
    of containers, and each container can have any number of blobs within it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The script in [Listing 4-2](part0013.html#ch04list2) obtains a list of all blob
    containers at ➍ with the `Get-AzureStorageContainer` cmdlet and then prints a
    table for each container using `Get-AzureStorageBlob`, with one line per blob
    ➎. The table includes the blob’s name, size, data type, and the date it was last
    changed, as shown in [Listing 4-3](part0013.html#ch04list3). Look through this
    list for files that sound useful, ignoring any *.status* files and most logs,
    and focusing instead on documents, source code, and configuration files. Once
    you have a list of interesting files, use one of the Azure Storage management
    tools to begin collecting the files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00031.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Listing 4-3: Output from blob commands*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'To view a blob’s content, Microsoft Azure Storage Explorer is probably the
    best option for a penetration tester. It’s free, properly exposes all types of
    blobs, and supports opening both ASM and ARM storage. Perhaps most importantly,
    it allows access to storage accounts using a variety of sign-in options, including
    the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Shared Access Signature token
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage account key in SQL Connection String format
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage account name and key
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username and password of a user with access to the subscription
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password login feature is especially nice because it will populate
    the application with the storage accounts for every subscription the user can
    access. You can also add more than one user account so that you can view files
    for every compromised account simultaneously.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: With all the storage accounts added to Microsoft Azure Storage Explorer, expand
    the blob storage section under the desired storage accounts; then browse the list
    of containers, select a file of interest, and click the **Download** button to
    pull down a copy, as shown in [Figure 4-11](part0013.html#ch04fig11).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00032.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: Downloading blobs from Microsoft Azure Storage Explorer*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve retrieved the files, be sure to check them for additional credentials.
    I’ve found a surprising number of secrets stored in Azure Storage. This makes
    it a fantastic place to gain access to additional systems or services, moving
    deeper into the target’s environment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Azure Storage blobs aren’t an ideal place to store unencrypted secrets. Because
    of the broad access and repudiation that access keys provide, secrets should be
    kept elsewhere—or at the very least encrypted with a key not kept in a storage
    account. Azure Key Vault, although not completely immune from attack, as I’ll
    discuss in [Chapter 7](part0016.html#ch07), is a far better choice for secret
    storage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Tables***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tables provide storage of tabular data in Azure. They are great for keeping
    semi-structured data like web service logs or website content databases, and they
    are good alternatives to a resource-intensive, costlier database solution like
    SQL Server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-2](part0013.html#ch04list2) calls the `Get-AzureStorageTable` cmdlet
    ➏, which will return all the table names in the provided storage context, as shown
    in [Listing 4-4](part0013.html#ch04list4). You can also use the only other cmdlet
    for Azure tables, `Get-AzureStorageTableStoredAccessPolicy`, which displays any
    special permissions for a table. I rarely find access policies in use, so I typically
    skip it. With such limited PowerShell options, you need to use a stand-alone tool
    to access a table’s data.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-4: Output from* Get-AzureStorageTable *command*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right tool is easy because there aren’t many options. The primary
    ones are Microsoft Azure Storage Explorer and ClumsyLeaf’s TableXplorer. In this
    case, I prefer TableXplorer, even though it’s not freeware, because it’s very
    quick, has options for exporting data, and provides a query option, shown in [Figure
    4-12](part0013.html#ch04fig12), that uses normal SQL syntax. This last feature
    makes identifying data incredibly easy for anyone with a SQL background. Microsoft
    Azure Storage Explorer also has a query capability, but it doesn’t work with SQL
    syntax and is slower than TableXplorer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In TableXplorer, you might find a number of tables, with names starting with
    `$Metrics`, that don’t appear when using PowerShell. Azure automatically generates
    and uses these tables to store details about the storage account in which they
    reside. The dollar sign (`$`) at the beginning of the name marks them as hidden,
    so PowerShell doesn’t enumerate them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00033.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Using TableXplorer to query Azure Storage tables with SQL syntax*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Data in these metrics tables track things like the total number of blobs being
    stored and any transactions that have billing implications, such as the addition
    or removal of data. These files typically have little value to an attacker, unless
    they want to look for log entries that show activity they performed against the
    storage account. Unfortunately, you can’t remove these entries because the metrics
    tables are read-only.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Queues***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Azure Storage queues provide a place to line up transactions and process them
    sequentially as resources become available. Mainly software developers use queues;
    after all, few people other than developers need to worry about processing data
    in order.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'From a penetration testing perspective, I used to find queues boring. They
    usually sit empty, waiting for a flood of work to come in, and are drained shortly
    thereafter when the tasks are all handled. I changed my opinion, though, when
    I saw the most beautiful, yet horrifying use of queues imaginable: a queue to
    send unsigned commands to a server for execution. Many security researchers will
    spend weeks or even months trying to find vulnerable software and develop *remote
    code execution* exploits—getting a process on a different computer to run code
    under the attacker’s control. Here, it wasn’t a vulnerability but rather an intentional
    feature!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Although that particular instance is an extreme case, queues actually lend themselves
    to this kind of behavior if a developer isn’t careful. Developers generally use
    them as an input into some custom application, like an order fulfillment system.
    The application’s developer might expect that the queue only contains work items
    from another trusted system they own, such as the order page on their website,
    so the developer neglects to put in proper validation on the work item’s fields.
    That means an attacker can inject their own custom messages into the queue, and
    the service that processes them might not confirm that the data in those messages
    makes sense. If these fields happen to contain the price of items for sale, the
    bank account where payments should be sent, or what system commands the computer
    processing the request should run, then the attacker has found a very high-priority
    bug.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If you use a queue to transport confidential data or to send commands that must
    come from a verified source, you should use asymmetric cryptography to encrypt
    or sign the messages before they are placed in the queue. Then, the receiver can
    decrypt the message or validate its signature to ensure it is authentic and hasn’t
    been tampered with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Queues are often used as a backend service that developers typically use to
    facilitate communication between applications, so they have good API support and
    interacting with them is limited without writing custom applications. PowerShell
    only has two relevant cmdlets to display queue information. One is `Get-AzureStorageQueue`,
    which I use in the script in [Listing 4-2](part0013.html#ch04list2) ➐ to enumerate
    the queues and their current message count, as shown in [Listing 4-5](part0013.html#ch04list5).
    The second is `Get-AzureStorageQueueStoredAccessPolicy`, which is used for viewing
    SAS token permissions and restrictions, which are rarely used. Note that there
    are no cmdlets to create or view items in the queue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-5: Output from* Get-AzureStorageQueue *command*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To actually see and insert messages into a queue, you must, once again, turn
    to Microsoft Azure Storage Explorer. From its interface, select a storage account,
    expand the Queues list below that account, and then select a queue. This will
    open a view that shows all currently queued messages, and it allows you to view
    the contents of a message or insert a new message. I suggest examining any existing
    messages to get a sense of what valid messages look like before trying to insert
    your own. If the queue is empty, try to find the source code for the application
    that processes the messages to see what it’s expecting.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '*Azure queues, like queue data structures in other programming languages, have
    two functions related to viewing a message. You can use* PeekMessage *to view
    the next message in the queue without changing or removing it. On the other hand,*
    GetMessage *actually takes the item from the queue and hides it from any other
    program that’s using the queue. If you’re just using Microsoft Azure Storage Explorer,
    you don’t have to worry about this, but if you develop a custom application to
    snoop on queues, calling* GetMessage *might prevent Azure from processing a legitimate
    request (from the queue). So be sure you fully understand these APIs before using
    them!*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Files***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The latest addition to Azure Storage’s offerings, called Azure Files, is a cloud-based
    SMB file share service. It allows users to create shared directories and fill
    them with files, just like in an on-premises file server. This is useful for migrating
    legacy applications that depend on SMB shares to Azure. Azure Files allows connections
    from clients that support the SMB 2.1 or SMB 3.0 protocol.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'While Azure Files is designed to be a drop-in replacement for an existing enterprise
    file server, it does have some limitations. First, any clients connecting to it
    must be able to reach the service on the native SMB port: TCP 445\. This might
    not sound like a big deal, but some corporate networks block TCP 445 traffic in
    both directions, because file shares are normally considered an internal resource.
    However, the biggest difference from a traditional Windows file server is the
    lack of user accounts and permissions.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: On a normal SMB share, a user can assign Read, Change, and Full Control permissions
    to any number of users or groups. Additionally, a user can specify file system–level
    permissions on files within these shares to further restrict access.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Files is different. By design, its shares have only one user and it isn’t
    configurable. The share’s user is `AZURE\`Name_of_Storage_Account, and the password
    is the primary key for that storage account, once again highlighting the importance
    of protecting storage account keys from unauthorized access. So to get full access
    to an Azure Files share named myshare within a storage account named mysa, you
    would run the following from a Windows command line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '*Connections from remote machines to Azure Files is limited to Windows hosts
    that support SMB 3.0 because Linux, and Windows versions prior to Windows 8, don’t
    support encrypted SMB connections. Linux and older Windows versions can connect
    to Azure Files, but only if they are virtual machines running within Azure and
    are in the same Azure region.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: To enumerate the shares, use the `Get-AzureStorageShare` cmdlet shown in [Listing
    4-2](part0013.html#ch04list2) at ➑. For each share, you can use the cmdlet `Get-AzureStorageFile`
    to see a list of files within that share. At ➒ in [Listing 4-2](part0013.html#ch04list2),
    I piped the output of `Get-AzureStorageFile` to the format-table command—with
    some rather ugly parameters—to display each file on one line and to include the
    name of the file with its size in bytes. Because the file size is buried in the
    properties of each file object (and is called “Length”), you need to display it
    using PowerShell’s hash table syntax. The `-auto` switch adjusts the column widths
    of the table automatically. The resulting output is shown in [Listing 4-6](part0013.html#ch04list6).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-6: Output from file commands*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Aside from using PowerShell and the built-in SMB connectivity of Windows, you
    can also view Azure Files through Microsoft Azure Storage Explorer (see [Figure
    4-13](part0013.html#ch04fig13)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00034.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: Accessing Azure Files using Microsoft Azure Storage Explorer*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure Storage Explorer doesn’t provide any more functionality than
    PowerShell and the Windows SMB client in tandem, but it does get around the TCP
    445 firewall issue by using Azure’s APIs for access instead of connecting directly
    through SMB. It also has a handy button labeled **Connect VM** that will automatically
    create and display the properly formatted `net use` SMB command so you can connect
    to the share using Windows.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed some design limitations in the authentication
    design of Azure Storage as well as the different types of credentials an attacker
    can use to access Azure Storage: storage account keys, usernames and passwords,
    and Shared Access Signatures. Next, we examined places where attackers often find
    credentials, such as source code, configuration files, and stored within a number
    of storage management tools. Then, we discussed the different types of storage
    available in Azure, including blobs, tables, queues, and files, and how an attacker
    can access each of them. Using this information, you can retrieve all of the data
    from a target’s storage account, which often includes documents, log files, hard
    disk images, and source code.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll take a look at the biggest user of Azure Storage:
    Azure Virtual Machines.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
