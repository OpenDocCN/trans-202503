- en: '**21'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**21'
- en: WRITING APPLICATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写应用程序**'
- en: '*For a bunch of hairless apes, we’ve actually managed to invent some pretty
    incredible things.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于一群没有毛发的猿人，我们实际上已经发明了一些相当了不起的东西。*'
- en: —Ernest Cline*, Ready Player One
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Ernest Cline*,《玩家一号》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: This chapter contains a potpourri of important topics that will add to your
    practical understanding of C++ by teaching you the basics of building real-world
    applications. It begins with a discussion of program support built into C++ that
    allows you to interact with the application life cycle. Next, you’ll learn about
    Boost ProgramOptions, an excellent library for developing console applications.
    It contains facilities to accept input from users without your having to reinvent
    the wheel. Additionally, you’ll learn some special topics about the preprocessor
    and compiler that you’ll likely come across when building an application whose
    source exceeds a single file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了一些重要的主题，通过教授构建真实世界应用程序的基础知识，帮助你更好地理解C++的实际应用。首先讨论C++内置的程序支持，允许你与应用生命周期进行交互。接着，你将学习Boost
    ProgramOptions，这是一个非常优秀的开发控制台应用程序的库，它提供了接受用户输入的功能，省去了你重新发明轮子的麻烦。此外，你还将学习一些关于预处理器和编译器的特殊主题，这些内容你在构建源代码超过一个文件的应用程序时，可能会遇到。
- en: '**Program Support**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**程序支持**'
- en: 'Sometimes your programs need to interact with your operating environment’s
    application life cycle. This section covers three major categories of such interactions:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的程序需要与操作环境的应用生命周期进行交互。本节涵盖了三类主要的交互：
- en: Handling program termination and cleanup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序终止和清理
- en: Communicating with the environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境的通信
- en: Managing operating system signals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理操作系统信号
- en: To help illustrate the various facilities in this section, you’ll use [Listing
    21-1](ch21.xhtml#ch21ex01) as a framework. It uses a spruced up analog to the
    `Tracer` class from [Listing 4-5](ch04.xhtml#ch04ex05) in [Chapter 4](ch04.xhtml#ch04)
    to help track which objects get cleaned up in various program termination scenarios.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明本节中的各种功能，你将使用[清单21-1](ch21.xhtml#ch21ex01)作为框架。它使用了一个改进版的类模拟，类比于[清单4-5](ch04.xhtml#ch04ex05)中的`Tracer`类，来自[第4章](ch04.xhtml#ch04)，帮助跟踪在各种程序终止场景中哪些对象被清理。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 21-1: A framework for investigating program termination and cleanup
    facilities*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单21-1：一个用于调查程序终止和清理功能的框架*'
- en: First, you declare a `Tracer` class that accepts an arbitrary `std::string`
    tag and reports to stdout when the `Tracer` object is constructed and destructed
    ➊. Next, you declare a `Tracer` with static storage duration ➋. The `run` function
    reports when the program has entered and exited it ➌. In the middle is a single
    comment that you’ll replace with other code in the sections that follow. Within
    `main`, you make an announcement ➍; initialize `Tracer` objects with local ➎,
    thread-local ➏, and dynamic ➐ storage duration; and invoke `run` ➑. Then you delete
    the dynamic Tracer object ➒ and announce that you’re about to return from `main`
    ➓.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明了一个`Tracer`类，它接受一个任意的`std::string`标签，并在`Tracer`对象构造和析构时向stdout报告 ➊。接着，你声明了一个具有静态存储持续时间的`Tracer`
    ➋。`run`函数报告程序进入和退出时的情况 ➌。中间部分是一个单独的注释，你将在后续的部分中用其他代码替换。在`main`中，你进行一次声明 ➍；初始化具有局部
    ➎、线程局部 ➏ 和动态 ➐ 存储持续时间的`Tracer`对象；并调用`run` ➑。然后，你删除动态的`Tracer`对象 ➒，并宣布即将从`main`返回
    ➓。
- en: '**WARNING**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*If any of the [Listing 21-1](ch21.xhtml#ch21ex01) output is surprising, please
    review “An Object’s Storage Duration” on [page 89](ch04.xhtml#page_89) before
    proceeding!*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果[清单21-1](ch21.xhtml#ch21ex01)中的输出让你感到惊讶，请在继续之前复习一下[第89页](ch04.xhtml#page_89)中的“对象的存储持续时间”！*'
- en: '***Handling Program Termination and Cleanup***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理程序终止和清理***'
- en: 'The `<cstdlib>` header contains several functions for managing program termination
    and resource cleanup. There are two broad categories of program termination functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cstdlib>`头文件包含了若干用于管理程序终止和资源清理的函数。程序终止函数可以分为两个大类：'
- en: Those that cause program termination
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些导致程序终止的交互
- en: Those that register a callback when termination is about to happen
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册回调函数，当程序终止即将发生时
- en: '**Termination Callback with std::atexit**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用std::atexit的终止回调**'
- en: To register a function to be called when normal program termination occurs,
    you use the `std::atexit` function. You can register multiple functions, and they’ll
    be called in reverse order from their registration. The callback functions take
    no arguments and return `void`. If `std::atexit` registers a function successfully,
    it will return a non-zero value; otherwise, it returns zero.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册一个在程序正常终止时调用的函数，你可以使用`std::atexit`函数。你可以注册多个函数，它们将按注册的逆序被调用。回调函数不接受任何参数，并且返回`void`。如果`std::atexit`成功注册了一个函数，它将返回一个非零值；否则，返回零。
- en: '[Listing 21-2](ch21.xhtml#ch21ex02) illustrates that you can register an `atexit`
    callback and it will be called at the expected moment.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-2](ch21.xhtml#ch21ex02)展示了你可以注册一个`atexit`回调，并且它将在预期的时刻被调用。'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 21-2: Registering an `atexit` callback*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 21-2：注册一个`atexit`回调*'
- en: Within `run`, you announce that you’re about to register a callback ➊, you do
    it ➋, and then you announce that you’re about to return from `run` ➌. In the output,
    you can plainly see that the callback occurs after you’ve returned from `main`
    and all the non-static objects have destructed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run`中，你宣布即将注册一个回调 ➊，你注册了一个 ➋，然后你宣布即将从`run`返回 ➌。在输出中，你可以清楚地看到回调发生在你从`main`返回后，并且所有非静态对象都已销毁。
- en: 'There are two important admonitions when programming a callback function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编写回调函数时，有两个重要的注意事项：
- en: You must not throw an uncaught exception from the callback function. Doing so
    will cause `std::terminate` to get invoked.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能从回调函数中抛出未捕获的异常。这样会导致调用`std::terminate`。
- en: You need to be very careful interacting with non-static objects in your program.
    The `atexit` callback functions execute after `main` returns, so all local, thread
    local, and dynamic objects will be destroyed at that point unless you take special
    care to keep them alive.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要非常小心与程序中的非静态对象交互。`atexit`回调函数在`main`返回后执行，因此除非特别小心保持它们的存活，否则所有局部、线程局部和动态对象将在此时被销毁。
- en: '**WARNING**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*You can register at least 32 functions with std::atexit, although the exact
    limit is implementation defined.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用std::atexit注册至少32个函数，尽管确切的限制由实现定义。*'
- en: '**Exiting with std::exit**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 std::exit 退出**'
- en: 'Throughout the book, you’ve been terminating programs by returning from `main`.
    In some circumstances, such as in multithreaded programs, you might want to exit
    the program gracefully in some other way, although you should avoid introducing
    the associated complications. You can use the `std::exit` function, which accepts
    a single `int` corresponding to the program’s exit code. It will perform the following
    cleanup steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你一直通过从`main`返回来终止程序。在某些情况下，比如多线程程序中，你可能希望以其他方式优雅地退出程序，尽管你应该避免引入相关的复杂性。你可以使用`std::exit`函数，它接受一个整数`int`作为程序的退出代码。它将执行以下清理步骤：
- en: Thread-local objects associated with the current thread and static objects get
    destroyed. Any `atexit` callback functions get called.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与当前线程关联的线程局部对象和静态对象将被销毁。任何`atexit`回调函数将被调用。
- en: All of stdin, stdout, and stderr get flushed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的stdin、stdout和stderr都会被刷新。
- en: Any temporary files get removed.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何临时文件都会被删除。
- en: The program reports the given status code to the operating environment, which
    resumes control.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序会将给定的状态码报告给操作环境，之后操作环境会恢复控制。
- en: '[Listing 21-3](ch21.xhtml#ch21ex03) illustrates the behavior of `std::exit`
    by registering an `atexit` callback and invoking `exit` from within `run`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-3](ch21.xhtml#ch21ex03)通过注册一个`atexit`回调并在`run`内部调用`exit`，展示了`std::exit`的行为。'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 21-3: Invoking `std::exit`*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 21-3：调用`std::exit`*'
- en: 'Within `run`, you announce that you’re registering a callback ➊, you register
    one with `atexit` ➋, you announce that you’ve completed registering ➌, and you
    invoke `exit` with argument zero ➍. Compare the program output from [Listing 21-3](ch21.xhtml#ch21ex03)
    to the output from [Listing 21-2](ch21.xhtml#ch21ex02). Notice that the following
    lines don’t appear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run`中，你宣布正在注册一个回调 ➊，你通过`atexit`注册了一个回调 ➋，你宣布完成注册 ➌，然后你使用零作为参数调用`exit` ➍。将[示例
    21-3](ch21.xhtml#ch21ex03)的程序输出与[示例 21-2](ch21.xhtml#ch21ex02)的输出进行比较。请注意，以下几行没有出现：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: According to the rules for `std::exit`, local variables on the call stack don’t
    get cleaned up. And of course, because the program never returns to `main` from
    `run`, `delete` never gets called. Ouch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`std::exit`的规则，调用栈上的局部变量不会被清理。当然，因为程序从`run`中没有返回到`main`，所以`delete`也不会被调用。哎呀。
- en: 'This example highlights an important consideration: you shouldn’t use `std::exit`
    to handle normal program execution. It’s mentioned here for completeness, because
    you might see it in earlier C++ code.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了一个重要的考虑因素：你不应该使用`std::exit`来处理正常的程序执行。这里提到它是为了完整性，因为你可能会在早期的C++代码中看到它。
- en: '**NOTE**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `<cstdlib>` header also includes a `std::quick_exit`, which invokes callbacks
    that you register with `std::at_quick_exit`, which has a similar interface to
    `std::atexit`. The main difference is that `at_quick_exit` callbacks won’t execute
    unless you explicitly invoke `quick_exit`, whereas `atexit` callbacks will always
    execute when the program is about to exit.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*`<cstdlib>`头文件还包括一个`std::quick_exit`，它会调用你用`std::at_quick_exit`注册的回调，`std::at_quick_exit`的接口类似于`std::atexit`。主要的区别在于，`at_quick_exit`回调不会执行，除非你显式地调用`quick_exit`，而`atexit`回调在程序即将退出时总会执行。*'
- en: '**std::abort**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**std::abort**'
- en: To end a program, you also have a nuclear option by using `std::abort`. This
    function accepts a single integer-valued status code and immediately returns it
    to the operating environment. No object destructors get called and no `std::atexit`
    callbacks get invoked. [Listing 21-4](ch21.xhtml#ch21ex04) illustrates how to
    use `std::abort`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束一个程序，你也可以使用`std::abort`来实现这一目标。这个函数接受一个整数值的状态码，并立即将其返回给操作环境。没有对象的析构函数被调用，也没有`std::atexit`回调被触发。[清单
    21-4](ch21.xhtml#ch21ex04)展示了如何使用`std::abort`。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 21-4: Calling `std::abort`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-4：调用`std::abort`*'
- en: Within `run`, you again announce that you’re registering a callback ➊, you register
    one with `atexit` and you announce that you’ve completed registering ➌. This time,
    you invoke `abort` instead ➍. Notice that no output prints after you announce
    that you’ve completed callback registration ➊. The program doesn’t clean up any
    objects, and your `atexit` callback doesn’t get called.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run`中，你再次声明你正在注册一个回调 ➊，你用`atexit`注册一个回调并宣布注册完成 ➌。这一次，你改为调用`abort` ➍。注意，在宣布完成回调注册
    ➊ 后，没有输出打印出来。程序没有清理任何对象，且你的`atexit`回调没有被调用。
- en: As you might imagine, there aren’t too many canonical uses for `std::abort`.
    The main one you’re likely to encounter is the default behavior of `std::terminate`,
    which gets called when two exceptions are in flight at once.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你想象的那样，`std::abort`并没有太多典型的使用场景。你最可能遇到的一个场景是`std::terminate`的默认行为，当同时有两个异常发生时，它会被调用。
- en: '***Communicating with the Environment***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与环境的通信***'
- en: Sometimes, you might want to spawn another process. For example, Google’s Chrome
    Browser launches many processes to service a single browser session. This builds
    in some security and robustness by piggybacking the operating system’s process
    model. Web apps and plug-ins, for example, run in separate processes, so if they
    crash, the entire browser doesn’t crash. Also, by running the browser’s rendering
    engine in a separate process, any security vulnerabilities become more difficult
    to exploit because Google locks down that process’s permissions in what is known
    as a sandboxed environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望启动另一个进程。例如，Google的Chrome浏览器会启动多个进程来服务一个浏览器会话。这通过依赖操作系统的进程模型来增强一些安全性和鲁棒性。例如，Web应用和插件通常会运行在独立的进程中，这样如果它们崩溃，整个浏览器就不会崩溃。此外，通过将浏览器的渲染引擎运行在一个独立的进程中，任何安全漏洞也变得更难被利用，因为Google将该进程的权限限制在所谓的沙盒环境中。
- en: '**std::system**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**std::system**'
- en: You can launch a separate process with the `std::system` function in the `<cstdlib>`
    header, which accepts a C-style string corresponding to the command you want to
    execute and returns an `int` corresponding to the return code from the command.
    The actual behavior depends on the operating environment. For example, the function
    will call *cmd.exe* on a Windows machine and */bin/sh* on a Linux machine. This
    function blocks while the command is still executing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用位于`<cstdlib>`头文件中的`std::system`函数来启动一个独立的进程，它接受一个C风格的字符串作为要执行的命令，并返回一个`int`，对应于命令的返回码。实际行为依赖于操作环境。例如，在Windows机器上，该函数会调用*cmd.exe*，而在Linux机器上会调用*/bin/sh*。该函数在命令执行时会阻塞。
- en: '[Listing 21-5](ch21.xhtml#ch21ex05) illustrates how to use `std::system` to
    ping a remote host. (You’ll need to update the contents of `command` to a relevant
    command for your operating system if you’re not using a Unix-like operating system.)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 21-5](ch21.xhtml#ch21ex05)展示了如何使用`std::system`来ping一个远程主机。（如果你不是使用类似Unix的操作系统，你需要将`command`的内容更新为适合你操作系统的命令。）'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 21-5: Using `std::system` to invoke the `ping` utility (Output is
    from macOS Mojave version 10.14.)*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-5：使用 `std::system` 调用 `ping` 工具（输出来自 macOS Mojave 版本 10.14。）*'
- en: First, you initialize a `string` called `command` containing `ping -c 4 google.com`
    ➊. You then invoke `std::system` by passing the contents of `command` ➋. This
    causes the operating system to invoke the `ping` command with the argument `-c
    4`, which specifies four pings, and the address `google.com`. Then you print a
    status message reporting the return value from `std::system` ➌.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个名为 `command` 的 `string`，其内容为 `ping -c 4 google.com` ➊。然后，你通过传递 `command`
    的内容来调用 `std::system` ➋。这将导致操作系统调用 `ping` 命令并传递参数 `-c 4`（指定发送四次 ping）和地址 `google.com`。接着，你打印一个状态信息，报告
    `std::system` 的返回值 ➌。
- en: '**std::getenv**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**std::getenv**'
- en: Operating environments usually have *environment variables*, which users and
    developers can set to help programs find important information that the programs
    need to run. The `<cstdlib>` header contains the `std::getenv` function, which
    accepts a C-style string corresponding to the name of the environment variable
    you want to look up, and it returns a C-style string with the contents of the
    corresponding variable. If no such variable is found, the function returns `nullptr`
    instead.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 操作环境通常具有 *环境变量*，用户和开发人员可以设置这些变量，以帮助程序查找运行所需的重要信息。`<cstdlib>` 头文件包含了 `std::getenv`
    函数，它接受一个 C 风格字符串作为参数，表示你想查找的环境变量的名称，并返回一个 C 风格字符串，包含对应变量的内容。如果未找到该变量，函数将返回 `nullptr`。
- en: '[Listing 21-6](ch21.xhtml#ch21ex06) illustrates how to use `std::getenv` to
    obtain the *path variable*, which contains a list of directories containing important
    executable files.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 21-6](ch21.xhtml#ch21ex06) 说明了如何使用 `std::getenv` 获取 *路径变量*，该变量包含了包含重要可执行文件的目录列表。'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 21-6: Using `std::getenv` to retrieve the path variable (Output is
    from macOS Mojave version 10.14.)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-6：使用 `std::getenv` 获取路径变量（输出来自 macOS Mojave 版本 10.14。）*'
- en: First, you initialize a `string` called `variable_name` containing `PATH` ➊.
    Next, you store the result of invoking `std::getenv` with `PATH` into a string
    called `result` ➋. Then you print the results to stdout ➌.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个名为 `variable_name` 的 `string`，其内容为 `PATH` ➊。接下来，你将调用 `std::getenv`
    获取 `PATH` 的结果，并将其存储在一个名为 `result` 的字符串中 ➋。然后，你将结果打印到标准输出 ➌。
- en: '***Managing Operating System Signals***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作系统信号管理***'
- en: 'Operating system signals are asynchronous notifications sent to processes that
    notify the program that an event occurred. The `<csignal>` header contains six
    macro constants that represent different signals from the operating system to
    the program (these signals are operating system agnostic):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统信号是异步通知，发送给进程，通知程序发生了某个事件。`<csignal>` 头文件包含了六个宏常量，代表操作系统发送给程序的不同信号（这些信号与操作系统无关）：
- en: '`SIGTERM` represents a termination request.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM` 表示终止请求。'
- en: '`SIGSEGV` represents invalid memory access.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGSEGV` 表示无效的内存访问。'
- en: '`SIGINT` represents an external interrupt, such as a keyboard interrupt.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT` 表示外部中断，例如键盘中断。'
- en: '`SIGILL` represents an invalid program image.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGILL` 表示无效的程序镜像。'
- en: '`SIGABRT` represents an abnormal termination condition, such as `std::abort`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGABRT` 表示异常终止条件，例如 `std::abort`。'
- en: '`SIGFPE` represents a floating-point error, such as division by zero.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGFPE` 表示浮点错误，例如除以零。'
- en: To register a handler for one of these signals, you use the `std::signal` function
    in the `<csignal>` header. It accepts a single `int` value corresponding to one
    of the listed signal macros as its first argument. Its second argument is a function
    pointer (not a function object!) to a function that accepts an `int` corresponding
    to the signal macro and returning `void`. This function must have C linkage (although
    most implementations also permit C++ linkage). You’ll learn about C linkage later
    in the chapter. For now, simply prepend `extern "C"` to your function definition.
    Notice that, due to the asynchronous nature of the interrupts, any accesses to
    a global, mutable state must be synchronized.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这些信号注册处理程序，你可以使用 `<csignal>` 头文件中的 `std::signal` 函数。它接受一个 `int` 类型的参数，表示信号宏列表中的一个信号。第二个参数是一个函数指针（而不是函数对象！），指向一个接受
    `int` 类型信号宏并返回 `void` 的函数。这个函数必须使用 C 链接（尽管大多数实现也允许 C++ 链接）。你将在本章后面学习 C 链接。现在，只需在你的函数定义前加上
    `extern "C"`。请注意，由于中断的异步性质，任何对全局可变状态的访问都必须进行同步。
- en: '[Listing 21-7](ch21.xhtml#ch21ex07) contains a program that waits for a keyboard
    interrupt.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 21-7](ch21.xhtml#ch21ex07) 包含一个等待键盘中断的程序。'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 21-7: Registering for keyboard interrupts with `std::signal`*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-7：使用 `std::signal` 注册键盘中断*'
- en: You first declare an `atomic_bool` called `interrupted` that stores whether
    the program has received a keyboard interrupt ➊ (it has static storage duration
    because you cannot use function objects with `std::signal` and therefore must
    use a non-member function to handle the callback). Next, you declare a callback
    handler that accepts an `int` called `signal`, prints its value to stdout ➋, and
    sets `interrupted` to true ➌.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先声明一个名为 `interrupted` 的 `atomic_bool`，用于存储程序是否收到键盘中断 ➊（它具有静态存储期，因为你不能在 `std::signal`
    中使用函数对象，因此必须使用非成员函数来处理回调）。接下来，你声明一个回调处理程序，接受一个名为 `signal` 的 `int`，将其值打印到标准输出 ➋，并将
    `interrupted` 设置为 true ➌。
- en: Within `main`, you set the signal handler for the `SIGINT` interrupt code to
    `handler` ➍. Within a loop, you wait for the program to get interrupted ➎ by printing
    a message ➏ and sleeping for a second ➐. Once the program has been interrupted,
    you print a message and return from `main` ➐.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你将 `SIGINT` 中断代码的信号处理程序设置为 `handler` ➍。在循环中，你通过打印消息 ➏ 并休眠一秒 ➐ 来等待程序被中断
    ➎。程序一旦被中断，你将打印消息并从 `main` 返回 ➐。
- en: '**NOTE**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Typically, you can cause a keyboard interrupt on modern operating systems
    by pressing CTRL-C.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，你可以通过按 CTRL-C 来引发现代操作系统中的键盘中断。*'
- en: '**Boost ProgramOptions**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost ProgramOptions**'
- en: 'Most console applications accept command line parameters. As you learned in
    “The Three `main` Overloads” on [page 272](ch09.xhtml#page_272), you can define
    `main` to accept the parameters `argc` and `argv`, which the operating environment
    will populate with the number of arguments and argument contents, respectively.
    You can always parse these manually and modify your program’s behavior accordingly,
    but there’s a better way: the Boost ProgramOptions library is an essential ingredient
    for writing console applications.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数控制台应用程序接受命令行参数。正如你在《三种 `main` 重载》一节中学到的，在[第272页](ch09.xhtml#page_272)，你可以定义
    `main` 来接受参数 `argc` 和 `argv`，操作环境会分别用参数的数量和内容来填充它们。你总是可以手动解析这些参数并相应地修改程序的行为，但有一个更好的方法：Boost
    ProgramOptions 库是编写控制台应用程序的重要组成部分。
- en: '**NOTE**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the Boost ProgramOptions classes presented in this section are available
    in the `<boost/program_options.hpp>` header.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节中介绍的所有 Boost ProgramOptions 类都可以在 `<boost/program_options.hpp>` 头文件中找到。*'
- en: 'You might be tempted to write your own argument-parsing code, but ProgramOptions
    is a smarter choice for four reasons:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想编写自己的参数解析代码，但 ProgramOptions 是一个更明智的选择，原因有四个：
- en: '**It’s far more convenient.** Once you learn the succinct, declarative syntax
    of ProgramOptions, you can easily describe fairly complicated console interfaces
    in a few lines of code.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它更加方便。** 一旦你学会了 ProgramOptions 的简洁声明式语法，你可以轻松地用几行代码描述相当复杂的控制台接口。'
- en: '**It handles errors effortlessly.** When the user misuses your program, ProgramOptions
    tells the user how they misused the program without any additional effort on your
    part.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它轻松处理错误。** 当用户错误使用你的程序时，ProgramOptions 会告诉用户如何错误使用程序，而无需你做额外的工作。'
- en: '**It automatically generates a help prompt.** Based on your declarative markup,
    ProgramOptions creates nicely formatted, easy to employ documentation on your
    behalf.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它自动生成帮助提示。** 根据你的声明式标记，ProgramOptions 会为你创建格式良好、易于使用的文档。'
- en: '**It grows beyond the command line.** If you want to draw configuration from
    config files or environment variables, it’s easy to transition from command line
    arguments.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它超越了命令行。** 如果你想从配置文件或环境变量中获取配置，转换命令行参数非常简单。'
- en: 'ProgramOptions comprises three parts:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ProgramOptions 包含三个部分：
- en: '**The options description** allows you to specify the allowed options.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选项描述** 允许你指定允许的选项。'
- en: '**The parsers component** extracts option names and values from the command
    line, config files, and environment variables.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析器组件** 从命令行、配置文件和环境变量中提取选项名称和值。'
- en: '**The storage component** provides you with the interface to access typed options.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储组件** 提供了访问已类型化选项的接口。'
- en: In the subsections that follow, you’ll learn about each of these parts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，你将学习这些部分的内容。
- en: '***The Options Description***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选项描述***'
- en: 'Three main classes comprise the options description component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选项描述组件由三个主要类组成：
- en: '`boost::program_options::option_description` describes a single option.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::program_options::option_description` 描述一个单一选项。'
- en: '`boost::program_options::value_semantic` knows the desired type of a single
    option.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::program_options::value_semantic`知道单个选项的期望类型。'
- en: '`boost::program_options::options_description` is a container for multiple objects
    of type `option_description`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::program_options::options_description`是一个容器，包含多个`option_description`类型的对象。'
- en: You construct an `options_description` to, unsurprisingly, specify a description
    for the program’s options. Optionally, you can include a single string argument
    in the constructor that describes your program. This will print in the description
    if you include it, but it will have no functional impact. Next, you use its `add_options`
    method, which returns a special kind of object of type `boost::program_options::options_description_easy_init`.
    This class has a special `operator()` that accepts at least two arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个`options_description`来指定程序选项的描述。可选地，你可以在构造函数中包含一个单独的字符串参数，描述你的程序。如果你包含它，它会在描述中打印出来，但不会对功能产生任何影响。接下来，你使用它的`add_options`方法，这会返回一个特殊类型的对象`boost::program_options::options_description_easy_init`。这个类有一个特殊的`operator()`，接受至少两个参数。
- en: The first argument is the name of the option you want to add. ProgramOptions
    is very smart, so you can provide a long name and a short name separated by a
    comma. For example, if you had an option called `threads`, ProgramOptions would
    bind the parameter `--threads` from the command line to this option. If instead
    you named the option `threads,t`, ProgramOptions would bind either `--threads`
    or `-t` to your option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是你想要添加的选项的名称。ProgramOptions非常智能，因此你可以提供一个长名称和一个短名称，用逗号分隔。例如，如果你有一个名为`threads`的选项，ProgramOptions会将命令行中的`--threads`参数绑定到这个选项。如果你将选项命名为`threads,t`，ProgramOptions会将`--threads`或`-t`绑定到你的选项。
- en: The second argument is the description of the option. You can employ a `value_semantic`,
    a C-style string description, or both. Because `options_description_easy_init`
    returns a reference to itself from `operator()`, you can chain these calls together
    to form a succinct representation of your program’s options. Typically, you don’t
    create `value_semantic` objects directly. Instead, you use the convenience template
    function `boost::program_options::value` to generate them. It accepts a single
    template parameter corresponding to the desired type of the option. The resulting
    pointer points to an object that has code to parse text input (from the command
    line, for example) into the desired type. To specify an option of `int` type,
    for example, you would invoke `value<int>()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是选项的描述。你可以使用`value_semantic`、C风格字符串描述或两者的组合。因为`options_description_easy_init`从`operator()`返回对自身的引用，你可以将这些调用链式连接起来，形成程序选项的简洁表示。通常，你不会直接创建`value_semantic`对象，而是使用便捷的模板函数`boost::program_options::value`来生成它们。它接受一个单一的模板参数，对应于选项的期望类型。生成的指针指向一个具有将文本输入（例如来自命令行的输入）解析为期望类型的代码的对象。例如，要指定一个`int`类型的选项，你会调用`value<int>()`。
- en: 'The resulting pointed-to object will have several methods that allow you to
    specify additional information about the option. For example, you can employ the
    `default_value` method to set the option’s default value. To specify that an option
    of `int` type should default to 42, you would use the following construction:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果指向的对象将具有多个方法，允许你指定选项的附加信息。例如，你可以使用`default_value`方法来设置选项的默认值。例如，要指定一个`int`类型的选项默认值为42，你可以使用以下结构：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another common pattern is an option that can take multiple tokens. Such options
    are allowed to have spaces between elements, and they’ll be parsed into a single
    string. To allow this, simply use the `multitoken` method. For example, to specify
    that an option can take multiple `std::string` values, you would use the following
    construction:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的模式是可以接受多个标记的选项。这样的选项允许元素之间有空格，并且它们会被解析为一个单一的字符串。为了实现这一点，只需使用`multitoken`方法。例如，要指定一个选项可以接受多个`std::string`值，你可以使用以下结构：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If instead you want to allow multiple instances of the same option, you can
    specify a `std::vector` as a value, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望允许同一个选项的多个实例，你可以指定一个`std::vector`作为值，如下所示：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you have a Boolean option, you’ll use the convenience function `boost::program_options::bool_switch`,
    which accepts a pointer to a `bool`. If a user includes the corresponding option,
    the function will set the pointed-to `bool` to true. For example, the following
    construction will set a `bool` called `flag` to `true` if the corresponding option
    is included:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `options_description` class supports `operator<<`, so you can create a nicely
    formatted help dialog without any additional effort. [Listing 21-8](ch21.xhtml#ch21ex08)
    illustrates how to use ProgramOptions to create a `program_options` object for
    a sample program called *mgrep*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 21-8: Using Boost ProgramOptions to generate a nicely formatted help
    dialog*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you initialize an `options_description` object using a custom usage
    string ➊. Next, you invoke `add_options` and begin adding options: a Boolean flag
    indicating whether to display a help dialog ➋, an `int` indicating how many threads
    to use ➌, another Boolean flag indicating whether to search subdirectories in
    a `recursive` manner ➍, a `std::string` indicating which `pattern` to search for
    within files ➎, and a list of `std::string` values corresponding to the `paths`
    to search ➏. You then write the `description` to stdout ➐.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that your yet to be implemented mgrep program will always require a
    `pattern` and a `paths` argument. You could convert these into *positional**arguments*,
    which as their name implies will assign arguments based on their position. To
    do this, you employ the `boost::program_options::positional_options_description`
    class, which doesn’t take any constructor arguments. You use the `add` method,
    which takes two arguments: a C-style string corresponding to the option you want
    to convert to positional and an `int` corresponding to the number of arguments
    you want to bind to it. You can invoke `add` multiple times to add multiple positional
    arguments. But the order matters. Positional arguments will bind from left to
    right, so your first `add` invocation applies to the left positional arguments.
    For the last positional option, you can use the number `-1` to tell ProgramOptions
    to bind all remaining elements to the corresponding option.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 21-9](ch21.xhtml#ch21ex09) provides a snippet that you could append
    into `main` in [Listing 21-7](ch21.xhtml#ch21ex07) to add the positional arguments.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 21-9: Adding positional arguments to [Listing 21-8](ch21.xhtml#ch21ex08)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: You initialize a `positional_options_description` without any constructor arguments
    ➊. Next, you invoke `add` and pass the arguments `pattern` and `1`, which will
    bind the first positional option to the *pattern* option ➋. You invoke `add` again,
    this time passing the arguments `path` and `-1` ➌, which will bind the remaining
    positional options to the *path* option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '***Parsing Options***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve declared how your program accepts options, you can parse user
    input. It’s possible to take configuration from environment variables, configuration
    files, and the command line. For brevity, this section only discusses the last.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经声明了程序如何接受选项，你可以解析用户输入。可以从环境变量、配置文件和命令行获取配置。为了简洁起见，本节只讨论最后一种情况。
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For information on how to obtain configuration from environment variables
    and configuration files, refer to the Boost ProgramOptions documentation, especially
    the tutorial.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关如何从环境变量和配置文件获取配置信息，请参考 Boost ProgramOptions 文档，特别是教程部分。*'
- en: 'To parse command line input, you use the `boost::program_options::command_line_parser`
    class, which accepts two constructor parameters arguments: an `int` corresponding
    to *argc*, the number of arguments on the command line, and a `char**` corresponding
    to *argv*, the value (or content) of the arguments on the command line. This class
    offers several important methods that you’ll use to declare how the parser should
    interpret user input.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析命令行输入，你使用 `boost::program_options::command_line_parser` 类，该类接受两个构造函数参数：一个
    `int` 类型的参数对应于 *argc*，即命令行上的参数个数，另一个 `char**` 类型的参数对应于 *argv*，即命令行上参数的值（或内容）。该类提供了多个重要方法，你将使用这些方法来声明解析器如何解释用户输入。
- en: First, you’ll invoke its `options` method, which takes a single argument corresponding
    to your `options_description`. Next, you’ll use the positional method, which takes
    a single argument corresponding to your `positional_options_description`. Finally,
    you’ll invoke `run` without any arguments. This causes the parser to parse the
    command line input and return a `parsed_options` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将调用其 `options` 方法，该方法接受一个对应于你的 `options_description` 的参数。接下来，你将使用 `positional`
    方法，该方法接受一个对应于你的 `positional_options_description` 的参数。最后，你将调用 `run` 方法，而不传递任何参数。这会导致解析器解析命令行输入并返回一个
    `parsed_options` 对象。
- en: '[Listing 21-10](ch21.xhtml#ch21ex10) provides a snippet that you could append
    into `main` after [Listing 21-8](ch21.xhtml#ch21ex08) to incorporate a `command_line_parser`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 21-10](ch21.xhtml#ch21ex10) 提供了一段代码，你可以将其追加到 `main` 中，放在 [清单 21-8](ch21.xhtml#ch21ex08)
    之后，用于集成一个 `command_line_parser`。'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 21-10: Adding the `command_line_parser` to [Listing 21-8](ch21.xhtml#ch21ex08)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-10：将 `command_line_parser` 添加到 [清单 21-8](ch21.xhtml#ch21ex08)*'
- en: You initialize a `command_line_parser` called `parser` by passing in the arguments
    from `main` ➊. Next, you pass the `options_description` object to the `options`
    method ➋ and the `positional_options_description` to the `positional` method ➌.
    Then you invoke the `run` method to produce your `parsed_options` object ➍.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传递 `main` 中的参数 ➊ 来初始化一个名为 `parser` 的 `command_line_parser`。接着，你将 `options_description`
    对象传递给 `options` 方法 ➋，并将 `positional_options_description` 传递给 `positional` 方法 ➌。然后你调用
    `run` 方法生成 `parsed_options` 对象 ➍。
- en: '**WARNING**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*If the user passes input that doesn’t parse, for example, because they provide
    an option that isn’t part of your description, the parser will throw an exception
    that inherits from `std::exception`.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果用户传入无法解析的输入，例如提供了不在你的描述中的选项，解析器将抛出一个继承自 `std::exception` 的异常。*'
- en: '***Storing and Accessing Options***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***存储和访问选项***'
- en: You store program options into a `boost::program_options::variables_map` class,
    which takes no arguments in its constructor. To place your parsed options into
    a `variables_map`, you use the `boost::program_options::store` method, which takes
    a `parsed_options` object as its first argument and a `variables_map` object as
    its second argument. Then you call the `boost::program_options::notify` method,
    which takes a single `variables_map` argument. At this point, your `variables_map`
    contains all the options your user has specified.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你将程序选项存储到 `boost::program_options::variables_map` 类中，该类的构造函数不接受任何参数。为了将解析后的选项放入
    `variables_map`，你使用 `boost::program_options::store` 方法，该方法的第一个参数是一个 `parsed_options`
    对象，第二个参数是一个 `variables_map` 对象。然后你调用 `boost::program_options::notify` 方法，该方法接受一个
    `variables_map` 对象作为参数。此时，你的 `variables_map` 包含了用户指定的所有选项。
- en: '[Listing 21-11](ch21.xhtml#ch21ex11) provides a snippet that you could append
    into `main` after [Listing 21-10](ch21.xhtml#ch21ex10) to parse results into a
    `variables_map`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 21-11](ch21.xhtml#ch21ex11) 提供了一段代码，你可以将其追加到 `main` 中，放在 [清单 21-10](ch21.xhtml#ch21ex10)
    之后，用于将结果解析为 `variables_map`。'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 21-11: Storing results into a `variables_map`*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 21-11：将结果存储到 `variables_map` 中*'
- en: You first declare a `variables_map` ➊. Next, you pass your `parsed_result` from
    [Listing 21-10](ch21.xhtml#ch21ex10) and your newly declared `variables_map` to
    `store` ➋. Then you call `notify` on your `variables_map` ➌.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The `variables_map` class is an associative container that is essentially similar
    to a `std::map<std::string, boost::any>`. To extract an element, you use `operator[]`
    by passing the option name as the key. The result is a `boost::any`, so you’ll
    need to convert it to the correct type using its `as` method. (You learned about
    `boost::any` in “`any`” on [page 378](ch12.xhtml#page_378).) It’s crucial to check
    for any options that might be empty by using the `empty` method. If you fail to
    do so and you cast the `any` anyway, you’ll get a runtime error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 21-12](ch21.xhtml#ch21ex12) illustrates how you can retrieve values
    from a `variables_map`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 21-12: Retrieving values from a `variables_map`*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Because you use the `bool_switch` value for the `help` and `recursive` options,
    you simply use those Boolean values directly to determine whether the user has
    requested either ➊➋. Because `threads` has a default value, you don’t need to
    make sure that it’s empty, so you can extract its value using as`<int>` directly
    ➌. For those options without defaults, such as `pattern`, you first check for
    `empty` ➍. If those options aren’t empty, you can extract their values using `as<std::string>`
    ➎. You do the same for `path` ➏, which allows you extract the user-provided collection
    with `as<std::vector<std::string>>` ➐.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '***Putting It All Together***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you have all the requisite knowledge to assemble a ProgramOptions-based
    application. [Listing 21-13](ch21.xhtml#ch21ex13) illustrates one way to stitch
    the previous listings together.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 21-13: A complete command line parameter-parsing application using
    the previous listings*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The first departure from the previous listings is that you wrap the call to
    run on your parser using a `try`-`catch` block to mitigate erroneous input provided
    by the user ➊. If they do provide erroneous input, you simply catch the exception,
    print the error to stderr, and `return`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Once you declare your program options and store them, as in [Listings 21-8](ch21.xhtml#ch21ex08)
    to [21-12](ch21.xhtml#ch21ex12), you first check whether the user has requested
    a help prompt ➋. If so, you simply print the usage and exit, because there’s no
    need to perform any further checking. Next, you perform some error checking to
    make sure the user has provided a pattern ➌ and at least one path ➍. If not, you
    print an error along with the program’s correct usage and exit; otherwise, you
    can continue writing your program ➎.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 21-14](ch21.xhtml#ch21ex14) shows various outputs from your program,
    which is compiled into the binary mgrep.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 21-14: Various invocations and outputs from the program in [Listing
    21-13](ch21.xhtml#ch21ex13)*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three invocations return errors for different reasons: you haven’t
    provided a pattern ➊, you haven’t provided a path ➋, or you provided an unrecognized
    option ➌.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In the next invocation, you get the friendly help dialog because you provided
    the `--help` option ➍. The final three invocations parse correctly because all
    contain a pattern and at least one path. The first contains no options ➎, the
    second uses the longhand option syntax ➏, and the third uses the shorthand option
    syntax ➐.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Special Topics in Compilation**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explains several important preprocessor features that will help
    you understand the double-inclusion problem, which is described in the following
    subsection, and how to solve it. You’ll learn about different options for optimizing
    your code by using compiler flags. Additionally, you’ll learn how to allow your
    linker to interoperate with C using a special language keyword.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***Revisiting the Preprocessor***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The preprocessor is a program that applies simple transformations to source
    code before compilation. You give instructions to the preprocessor using preprocessor
    directives. All preprocessor directives begin with a hash mark (`#`). Recall from
    “The Compiler Tool Chain,” on [page 5](ch01.xhtml#page_5) that `#include` is a
    preprocessor directive that tells the preprocessor to copy and paste the contents
    of the corresponding header directly into the source code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor also supports other directives. The most common is the *macro*,
    which is a fragment of code that’s been given a name. Whenever you use that name
    within C++ code, the preprocessor replaces that name with the contents of the
    macro.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The two different kinds of macros are object-like and function-like. You declare
    an object-like macro using the following syntax:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where NAME is the name of the macro and `CODE` is the code to replace that name.
    For example, [Listing 21-15](ch21.xhtml#ch21ex15) illustrates how to define a
    string literal to a macro.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 21-15: A C++ program with an object-like macro*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You define the macro `MESSAGE` to correspond with the code `"LOL"` ➊. Next,
    you use the `MESSAGE` macro as the format string to `printf` ➋. After the preprocessor
    has completed work on [Listing 21-15](ch21.xhtml#ch21ex15), it appears as [Listing
    21-16](ch21.xhtml#ch21ex16) to the compiler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 21-16: The result of preprocessing [Listing 21-15](ch21.xhtml#ch21ex15)*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor is nothing more than a copy-and-paste tool here. The macro
    disappears, and you’re left with a simple program that prints `LOL` to the console.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to inspect the work that the preprocessor does, compilers usually
    have a flag that will limit compilation to just the preprocessing step. This will
    cause the compiler to emit the preprocessed source file corresponding to each
    translation unit. On GCC, Clang, and MSVC, for example, you can use the `-E` flag.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'A function-like macro is just like an object-like macro except it can take
    a list of parameters after its identifier:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can use these PARAMETERS within the CODE, allowing the user to customize
    the macro’s behavior. [Listing 21-17](ch21.xhtml#ch21ex17) contains the function-like
    macro `SAY_LOL_WITH`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 21-17: A C++ program with a function-like macro*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The `SAY_LOL_WITH` macro accepts a single parameter named `fn` ➊. The preprocessor
    pastes the macro into the expression `fn("LOL")`. When it evaluates `SAY_LOL_WITH`,
    the preprocessor pastes `printf` into the expression ➋, yielding a translation
    unit just like [Listing 21-16](ch21.xhtml#ch21ex16).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional Compilation**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The preprocessor also offers *conditional compilation*, a facility that provides
    basic `if`-`else` logic. Several flavors of conditional compilation are available,
    but the one you’re likely to encounter is illustrated in [Listing 21-18](ch21.xhtml#ch21ex18).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 21-18: A C++ program with a conditional compilation*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: If `MY_MACRO` isn’t defined at the point where the preprocessor evaluates `#ifndef`
    ➊, [Listing 21-18](ch21.xhtml#ch21ex18) reduces to the code represented by `//
    Segment 1` ➋. If `MY_MACRO` is `#defined`, [Listing 21-18](ch21.xhtml#ch21ex18)
    evaluates to the code represented by `// Segment 2` ➌. The `#else` is optional.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Double Inclusion**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Aside from using `#include`, you should use the preprocessor as little as possible.
    The preprocessor is extremely primitive and will cause difficult-to-debug errors
    if you lean on it too heavily. This is evident with `#include`, which is a simple
    copy-and-paste command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Because you can define a symbol only once (a rule appropriately called the *one-definition
    rule*), you must ensure that your headers don’t attempt to redefine symbols. The
    easiest way to make this mistake is by including the same header twice, which
    is called the *double-inclusion problem*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to avoid the double-inclusion problem is to use conditional compilation
    to make an *include guard*. The include guard detects whether a header has been
    included before. If it has, it uses conditional compilation to empty the header.
    [Listing 21-19](ch21.xhtml#ch21ex19) illustrates how to put include guards around
    a header.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 21-19: A `step_function.h` updated with include guards*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The first time that the preprocessor includes `step_function.h` in a source
    file, the macro `STEP_FUNCTION_H` won’t be defined, so `#ifndef` ➊ yields the
    code up to `#endif`. Within this code, you `#define` the `STEP_FUNCTION_H` macro
    ➋. This ensures that if the preprocessor includes `step_function.h` again, `#ifndef
    STEP_FUNCTION_H` will evaluate to false and no code will get generated.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Include guards are so ubiquitous that most modern tool chains support the `#pragma
    once` special syntax. If one of the supporting preprocessors sees this line, it
    will behave as if the header has include guards. This eliminates quite a bit of
    ceremony. Using this construct, you could refactor [Listing 21-19](ch21.xhtml#ch21ex19)
    into [Listing 21-20](ch21.xhtml#ch21ex20).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 21-20: A `step_function.h` updated with `#pragma once`*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: All you’ve done here is start the header with `#pragma once` ➊, which is the
    preferred method. As a general rule, start every header with `#pragma once`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '***Compiler Optimization***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern compilers can perform sophisticated transformations on code to increase
    runtime performance and reduce binary size. These transformations are called *optimizations*,
    and they entail some cost to programmers. Optimization necessarily increases compilation
    time. Additionally, optimized code is often harder to debug than non-optimized
    code, because the optimizer usually eliminates and reorders instructions. In short,
    you usually want to turn off optimizations while you’re programming, but turn
    them on during testing and in production. Accordingly, compilers typically provide
    several optimization options. [Table 21-1](ch21.xhtml#ch21tab01) describes one
    such example—the optimization options available in GCC 8.3, although these flags
    are fairly ubiquitous across the major compilers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 21-1:** GCC 8.3 Optimization Options'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `-O0 (default)` | Reduces compilation time by turning off optimizations.
    Yields a good debugging experience but suboptimal runtime performance. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `-O` or `-O1` | Performs the majority of available optimizations, but omits
    those that can take a lot of (compile) time. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `-O2` | Performs all optimizations at `-O1`, plus nearly all optimizations
    that don’t substantially increase binary size. Compilation might take much longer
    than with `-O1`. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `-O3` | Performs all optimizations at `-O2`, plus many optimizations that
    can substantially increase binary size. Again, this increases compilation time
    over `-O1` and `-O2`. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `-Os` | Optimizes similarly to `-O2` but with a priority for decreasing binary
    size. You can think of this (loosely) as a foil to `-O3`, which is willing to
    increase binary size in exchange for performance. Any `-O2` optimizations that
    don’t increase binary size are performed. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `-Ofast` | Enables all `-O3` optimizations, plus some dangerous optimizations
    that might violate standards compliance. Caveat emptor. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `-Og` | Enables optimizations that don’t degrade the debugging experience.
    Provides a good balance of reasonable optimizations, fast compilation, and ease
    of debugging. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: As a general rule, use `-O2` for your production binary unless you have a good
    reason to change it. For debugging, use `-Og`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '***Linking with C***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can allow C code to incorporate functions and variables from your programs
    using *language linkage*. Language linkage instructs the compiler to generate
    symbols with a specific format friendly to another target language. For example,
    to allow a C program to use your functions, you simply add the `extern "C"` language
    linkage to your code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `sum.h` header in [Listing 21-21](ch21.xhtml#ch21ex21), which generates
    a C-compatible symbol for `sum`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 21-21: A header that makes the `sum` function available to C linkers*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the compiler will generate objects that the C linker can use. To use this
    function within C code, you simply declare the `sum` function per usual:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then instruct your C linker to include the C++ object file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*According to the C++ Standard,* pragma *is a method to provide additional
    information to the compiler beyond what is embedded in the source code. This information
    is implementation defined, so the compiler isn’t required to use the information
    specified by the pragma in any way.* Pragma *is the Greek root for “a fact.”*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also interoperate the opposite way: use C compiler output within your
    C++ programs by giving the linker the C compiler-generated object file.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a C compiler generated a function equivalent to `sum`. You could compile
    using the `sum.h` header, and the linker would have no problem consuming the object
    file, thanks to language linkage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If you have many externed functions, you can use braces `{}`, as [Listing 21-22](ch21.xhtml#ch21ex22)
    illustrates.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 21-22: A refactoring of [Listing 21-21](ch21.xhtml#ch21ex21) containing
    multiple functions with the `extern` modifier.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The `sum_int` and `sum_double` functions will have C language linkage.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also interoperate between C++ and Python with Boost Python. See the
    Boost documentation for details.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you first learned about program support features that allow
    you to interact with the application life cycle. Next, you explored Boost ProgramOptions,
    which allows you to accept input from users easily using a declarative syntax.
    Then you examined some selected topics in compilation that will be helpful as
    you expand your C++ application development horizons.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**21-1.** Add graceful keyboard interrupt handling to the asynchronous upper-casing
    echo server in [Listing 20-12](ch21.xhtml#ch21ex12). Add a kill switch with static
    storage duration that the session objects and acceptors check before queueing
    more asynchronous I/O.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**21-2.** Add program options to the asynchronous HTTP client in [Listing 20-10](ch20.xhtml#ch20ex10).
    It should accept options for the host (like *[www.nostarch.com](http://www.nostarch.com)*)
    and one or more resources (like */index.htm*). It should create a separate request
    for each resource.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**21-3.** Add another option to your program in exercise 21-2 that accepts
    a directory where you’ll write all the HTTP responses. Derive a filename from
    each host/resource combination.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**21-3.** 在第 21-2 题的程序中添加一个选项，接受一个目录，在该目录下写入所有 HTTP 响应。从每个主机/资源组合中派生出文件名。'
- en: '**21-4.** Implement the mgrep program. It should incorporate many of the libraries
    you’ve learned about in [Part II](part02.xhtml#part02). Investigate the Boyer-Moore
    search algorithm in Boost Algorithm (in the `<boost/algorithm/searching/boyer_moore.hpp>`
    header). Use std::async to launch tasks and determine a way to coordinate work
    between them.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**21-4.** 实现 mgrep 程序。它应该包含你在[第二部分](part02.xhtml#part02)中学到的许多库。研究 Boost 算法中的
    Boyer-Moore 查找算法（在 `<boost/algorithm/searching/boyer_moore.hpp>` 头文件中）。使用 std::async
    启动任务，并确定一种方法来协调任务之间的工作。'
- en: '**FURTHER READING**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++ 库*，第二版，作者：Boris Schäling（XML Press，2014）'
- en: '*API Design for C++* by Martin Reddy (Morgan Kaufmann, 2011)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ API 设计*，作者：Martin Reddy（Morgan Kaufmann，2011）'
