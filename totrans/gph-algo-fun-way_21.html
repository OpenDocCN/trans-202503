<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">GRAPH COLORING</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><i>Graph coloring</i> is a conceptually simple but computationally complex problem with a range of real-world applications. At its core, it consists of assigning a color to each node in an undirected graph such that no pair of nodes sharing an edge have the same color. Variations of this problem include minimizing the number of colors used or finding an assignment using only a fixed number of colors.</p>&#13;
<p class="TX">We can easily visualize the importance of the graph-coloring problem in terms of a map of Europe. We need to assign each country a color such that no two adjacent countries have the same color. If we use green for both France and Belgium, viewers may not be able to see the border. Beyond maps, the constraints enforced by the graph-coloring problem lend themselves to a range of real-world optimization tasks.</p>&#13;
<p class="TX">This chapter begins by formally defining the graph-coloring problem and discussing real-world use cases in more depth. We then examine <span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>several approaches to solving the task and discuss why the problem of using a fixed number of colors (or minimizing the number used) is surprisingly difficult.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-224"/><samp class="SANS_Futura_Std_Bold_B_11">The Graph-Coloring Problem</samp></h3>&#13;
<p class="TNI1">The <i>graph-coloring problem</i> consists of assigning colors to each of the |<i>V</i> | nodes in an undirected graph such that no two nodes sharing an edge have the same color. Formally, we can define the problem as follows:</p>&#13;
<p class="EXO">Given a graph, defined by a set of nodes <i>V</i> and edges <i>E</i>, and a set of colors <i>C</i>, find an assignment of nodes to colors such that for any two nodes <i>u</i> <span class="symbol">∈</span><i>V</i> and <i>v</i> <span class="symbol">∈</span><i>V</i> connected by an edge, (<i>u</i>, <i>v</i>) <span class="symbol">∈</span> <i>E</i>, then <i>color</i>(<i>u</i>) ≠ <i>color</i>(<i>v</i>).</p>&#13;
<p class="BodyContinued">We can define the <i>minimum graph-coloring problem</i> as finding the minimum number of colors such that a graph has a valid graph coloring.</p>&#13;
<p class="TX">In this chapter, we use the graph node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> field to store the color for that node. Colors will be represented by integers starting at 1, with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> indicating an unassigned node (<samp class="SANS_TheSansMonoCd_W5Regular_11">node.label</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).</p>&#13;
<p class="TX"><a href="#list16-1">Listing 16-1</a> defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">is_graph_coloring_valid()</samp> function that checks whether a graph has a valid coloring. This checker both provides a good overview of the mechanics of the graph-coloring problem and is also a helpful utility function for testing.</p>&#13;
<span id="list16-1"/>&#13;
<pre><code>def is_graph_coloring_valid(g: Graph) -&gt; bool: &#13;
    for node in g.nodes:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if node.label is None:&#13;
            return False&#13;
        for edge in node.get_edge_list():&#13;
            neighbor: Node = g.nodes[edge.to_node]&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if neighbor.label == node.label:&#13;
                return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Checking whether a graph’s coloring is valid</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each node in the graph, first checking whether the node has any color assigned <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If not, the graph’s coloring is incomplete and thus invalid. If the node does have a color, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each of the node’s neighbors and check whether the two nodes share a color <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If two neighbors share a color, the coloring is invalid, and the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If the code makes it through every neighbor for every node without finding a match, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
<p class="TX">We represent different node colors in the illustrations in this chapter using hashing arranged in different orientations, as shown in <a href="#fig16-1">Figure 16-1</a>.</p>&#13;
<figure class="IMG"><img id="fig16-1" class="img40" src="../images/f16001.jpg" alt="A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4), (2, 4), and (3, 4). Node 0 has vertical hashing and is labeled with the color 1, while its neighbor node 1 has horizontal hashing and is labeled with the color 2." width="497" height="329"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: A graph with a valid assignment of colors</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For the figures in this chapter, we’ll note the color number outside each node and number the colors starting from 1.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-225"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">We can use the graph-coloring formulation to model a range of real-world problems, including coloring maps, making seating arrangements at conferences, assigning parking spaces, and protecting valuable treasure within a labyrinth.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-226"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring Maps</samp></h4>&#13;
<p class="TNI1">The classic use case for graph coloring stems from the daily needs of cartographers and map publishers throughout the world. To distinguish areas on a map, different regions must be shaded with different colors. For a map of New England like that shown in <a href="#fig16-2">Figure 16-2</a>, we might choose to color Connecticut in green and Rhode Island in orange.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>&#13;
<figure class="IMG"><img id="fig16-2" class="img80" src="../images/f16002.jpg" alt="A map showing the six states in New England with a graph overlaid. The node MA has neighbors CT, RI, VT, and NH." width="1215" height="1623"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: A map of New England and the overlaid graph representation</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can translate the map-coloring problem into a graph-coloring problem by creating a node for each region and adding edges between any two regions that share a border. In <a href="#fig16-2">Figure 16-2</a>, the Rhode Island node has edges to the nodes for both Connecticut and Massachusetts. The cartographer’s goal then becomes finding a valid graph coloring.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-227"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing Seating Arrangements</samp></h4>&#13;
<p class="TNI1">The annual convention of Coffee-Drinking Data Structure Enthusiasts is a joyous but surprisingly political affair. Deep divergences exist within the community in terms of preferences for both coffee and data structures, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>including rivalries between the light and dark roast camps, over 30 different groups of loudly declared favorite data structures, and the inevitable fighting over programming languages that finds a way into any discussion about computer science. Not all differences in preference lead to an argument, but the ones that do result in hours of pedantic shouting. Every year the organizers face the daunting task of assigning tables at the opening banquet such that there will be no loud feuds.</p>&#13;
<p class="TX">The organizers have long used this gathering as an opportunity to test new graph-coloring algorithms. Modeling each attendee as a node and a strong difference in opinion as an edge, the Conference Chair for Banquet Seating tries to find an assignment of attendees to tables such that no two people at the same table have a strong disagreement. The nodes’ colors are the table assignments.</p>&#13;
<p class="TX">In the simplest case, the organizer could break up the tables into the smallest coherent factions. They might assign a table for the sole espresso-drinking, Fortran-writing hash table fan in attendance. This is equivalent to assigning the node a completely unique color. However, this approach is needlessly wasteful, resulting in almost as many tables as attendees. The aforementioned hash table fan gets along quite well with espresso and dark roast coffee drinkers, users of Fortran or Cobol, and aficionados of most data structures. The Conference Chair’s goal is to minimize the number of tables (graph colors) while ensuring that no shouting matches ensue.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-228"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Parking Spaces</samp></h4>&#13;
<p class="TNI1">The Data Structures and Coffee bookstore sees a consistent stream of customers throughout the day. To meet demand, the owners decide to bring on more staff. After extensive interviews, the owners hire six employees. They draw up a schedule with those new hires working set shifts throughout the day as shown in <a href="#fig16-3">Figure 16-3(a)</a>. One question remains, however: How many parking spaces should they set aside for staff?</p>&#13;
<figure class="IMG"><img id="fig16-3" class="img100" src="../images/f16003.jpg" alt="(A) shows a chart with size bars spanning different horizontal ranges. (b) shows a graph with six nodes with edges connecting nodes whose bars overlap." width="1351" height="558"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: Employee work times (a) and the corresponding graph of parking conflicts (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>Using their data structures expertise, the owners quickly reduce the question to a graph-coloring problem. As shown in <a href="#fig16-3">Figure 16-3(b)</a>, each employee becomes a node in the graph with edges between any two employees whose schedules overlap and thus will need parking spaces at the same time. For example, the schedule of employee 1 overlaps with that of employees 2, 3, and 5. However, it does not overlap with employees 0 or 4, which means that employee 1 could share a parking space with either of the latter two employees. If the owners can find a graph coloring containing at most <i>C</i> colors, then they can safely reserve at most <i>C</i> parking spaces.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-229"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Magical Labyrinths</samp></h4>&#13;
<p class="TNI1">An evil wizard decides to construct a magical labyrinth to protect their most prized possession, a horn that plays their favorite song. Seeking to protect the Horn of Beautiful Music from relentless adventurers, the wizard fills their labyrinth with an assortment of traps and monsters.</p>&#13;
<p class="TX">The wizard quickly runs into a problem, however. Due to the large number of passageways (edges), many of the rooms (nodes) connect. They do not want to be seen as lazy by having the same monsters in two adjacent rooms. Skill in labyrinth creation is a reputational necessity; even the most junior adventurers lose respect for architects who fill room after room with the same challenges. Yet the wizard is looking to keep costs down by bulk-ordering monsters. They need to determine the smallest number of monsters (colors) they can use such that no two adjacent rooms contain the same monster.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-230"/><samp class="SANS_Futura_Std_Bold_B_11">Graph-Coloring Algorithms</samp></h3>&#13;
<p class="TNI1">Computer scientists and mathematicians have developed a range of algorithms to solve graph-coloring problems. However, each solution comes with trade-offs. Some algorithms use heuristics that find solutions but might require too many colors; others are expensive on large graphs.</p>&#13;
<p class="TX">Graph coloring is an <i>NP-hard problem</i>, which informally means that there is no known algorithm whose worst-case running time scales as polynomial with respect to the size of the data. There is literally an exponential number of states to consider: |<i>V</i> |<i><sup>C</sup></i> states for a problem with |<i>V</i> | nodes and <i>C</i> colors. Yet it is not all bad news. While this problem is constrained by its behavior in worst-case scenarios, many of the algorithms perform well in practice and can be applied to numerous everyday problems.</p>&#13;
<p class="TX">The algorithms in this section search for valid graph colorings. If they find one, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to indicate their success and set the color assignments in the nodes’ <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> field, rather than returning the assignments in a separate data structure. The algorithms return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if they are unable to find a valid set of assignments.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>&#13;
<h4 class="H2" id="sec8"><span id="h-231"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive Search</samp></h4>&#13;
<p class="TNI1">An <i>exhaustive search</i> through all possible node-to-color assignments is a comprehensive approach that is guaranteed to find a valid graph coloring if one exists:</p>&#13;
<pre><code>def graph_color_brute_force(g: Graph, num_colors: int) -&gt; bool: &#13;
    options: list = [i for i in range(1, num_colors + 1)]&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for counter in itertools.product(options, repeat=g.num_nodes):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> for n in range(g.num_nodes):&#13;
            g.nodes[n].label = counter[n]&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if is_graph_coloring_valid(g):&#13;
            return True&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> for n in range(g.num_nodes):&#13;
        g.nodes[n].label = None&#13;
    return False&#13;
</code></pre>&#13;
<p class="TX">The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">product</samp> function of Python’s itertools package to enumerate every possible combination of color assignments <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Initially, every value of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is assigned to the first color (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). During each iteration, the counter changes.</p>&#13;
<p class="TX">In each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the code copies the assignments into the node labels <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and checks whether they are valid <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If so, it immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to indicate it has found a solution. Otherwise, the loop continues forward to the next combination. If the code does not find a successful combination, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Before doing so, it resets all the node’s label assignments to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> because there is no valid coloring <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Of course, the cost of an exhaustive search can be prohibitively expensive as the size of the graph grows. If the graph has |<i>V</i> | nodes and uses <i>C</i> colors, we could end up testing |<i>V</i> |<i><sup>C</sup></i> assignments before either finding a valid one or determining that no <i>C</i>-color assignment will work. <a href="#fig16-4">Figure 16-4</a> shows the first six iterations of an exhaustive search with three colors on the five-node graph from <a href="#fig16-1">Figure 16-1</a>. The search starts with all nodes the same color, as shown in <a href="#fig16-4">Figure 16-4(a)</a>, and moves through the assignments.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>&#13;
<figure class="IMG"><img id="fig16-4" class="img100" src="../images/f16004.jpg" alt="A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4), (2, 4), and (3, 4). (A) shows the five-node graph where all nodes have vertical hashing and are labeled with color = 1 for assignments of [1, 1, 1, 1, 1]. (B) shows the same graph with node 0 now with horizontal hashing and labeled with color = 2 for assignments of [2, 1, 1, 1, 1]. (C) shows assignments of [1, 2, 1, 1, 1]. (D) shows assignments of [2, 2, 1, 1, 1]. (E) shows assignments of [1, 1, 2, 1, 1]. (F) shows assignments of [2, 1, 2, 1, 1]." width="1686" height="833"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: The first six iterations of an exhaustive search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As shown in <a href="#fig16-4">Figure 16-4</a>, exhaustive search can waste a significant amount of time checking one obvious bad state after another. It provides simplicity and completeness at the cost of efficiency. Unless our graph has no edges, it’s clearly not possible for all the nodes to share the same color. Imagine the frustration of a human using this approach as they are forced to test yet another combination they know won’t work because there is a clear conflict somewhere else in the graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-232"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking Search</samp></h4>&#13;
<p class="TNI1">We can also implement the iterator-based exhaustive search from the previous section using a <i>recursive backtracking search</i>. Unlike the depth-first searches used in earlier chapters, especially <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, this backtracking search does not explore individual nodes through their neighbors. Instead, the search state is the set of color assignments itself. We recursively explore all possible assignments of colors to nodes, backtracking when the solution is infeasible. Each state in our search corresponds to a partial assignment of colors to nodes, as shown in <a href="#fig16-5">Figure 16-5</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>&#13;
<figure class="IMG"><img id="fig16-5" class="img100" src="../images/f16005.jpg" alt="A tree of options. The root level shows five blank spaces. The next level contains nodes filling the first entry with 1, 2, 3. The second level shows the first three nodes with the first entry set to 1 and the second entry set to 1, 2, and 3, respectively." width="1176" height="1020"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: A backtracking search branching out over different assignments</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can first model the same search space as the iterator-based exhaustive search, using a depth-first search without any pruning (we’ll improve on this approach shortly). This search progresses to an adjacent state by assigning a color to the next unassigned node, as shown in <a href="#list16-2">Listing 16-2</a>.</p>&#13;
<span id="list16-2"/>&#13;
<pre><code>def graph_color_dfs(g: Graph, num_colors: int, index: int=0) -&gt; bool: &#13;
    if index == g.num_nodes:&#13;
        return is_graph_coloring_valid(g)&#13;
&#13;
    for color in range(1, num_colors + 1):&#13;
        g.nodes[index].label = color&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if graph_color_dfs(g, num_colors, index + 1):&#13;
            return True&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> g.nodes[index].label = None&#13;
    return False&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: A recursive exhaustive search of color assignments</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_dfs()</samp> code uses a recursive search to assign each color to each node. It starts with the base case, checking whether all nodes have been assigned and, if so, whether the assignment is valid. If there are more nodes to assign, then the code iterates through all possible colors for the current node. For each color, the code then continues the recursive search on the next node (by index). It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if the assignment leads to a valid solution <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If the search has not found a valid assignment, it resets the current node’s color to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and backtracks by returning <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>The backtracking search implementation in <a href="#list16-2">Listing 16-2</a> is only an alternative implementation of the iterator-based exhaustive search. It doesn’t improve efficiency. <a href="#fig16-6">Figure 16-6</a> shows how the search will iterate through the same first dead end as did the exhaustive search in <a href="#fig16-4">Figure 16-4</a>. After it progresses all the way to the dead end in <a href="#fig16-6">Figure 16-6(e)</a>, the algorithm backtracks and tries a new assignment for node 4, as shown in <a href="#fig16-6">Figure 16-6(f)</a>.</p>&#13;
<figure class="IMG"><img id="fig16-6" class="img80" src="../images/f16006.jpg" alt="A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4), (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with color = 1. (B) shows the same graph with node 0 labeled with color = 1 and node 1 labeled with color = 1. (C) shows assignments [1, 1, 1, None, None]. (D) shows the assignments [1, 1, 1, 1, None]. (E) shows the assignments [1, 1, 1, 1, 1]. (F) shows the assignments [1, 1, 1, 1, 2]." width="1134" height="1338"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: The first six steps of the backtracking search coloring on a graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, we can modify this search to greatly improve efficiency by <i>pruning</i> early and exploring only valid paths. Before assigning a color to a node, we can check whether that assignment produces a conflict. If so, we can skip not only that assignment but also all later recursions from it, as shown in <a href="#fig16-7">Figure 16-7</a>, where we skip the entire subtree of possibilities stemming from assigning color = 1 to both nodes 0 and 1. Instead, once we have assigned color = 1 to node 0, we consider only colors 2 and 3 for the adjacent node 1.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>&#13;
<figure class="IMG"><img id="fig16-7" class="img100" src="../images/f16007.jpg" alt="A tree where each node shows the five-node graph with some of the colors filled in. The root has no nodes colored. Its children consist of graphs with colors 1, 2, and 3, respectively. The tree node where both nodes 0 and 1 are assigned color 1 is grayed out and the branch is crossed out." width="1663" height="1216"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: The first few steps of a backtracking search with pruning for graph coloring</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code for <i>backtracking search with pruning</i> requires a small change. Before assigning a color to a node, we check whether any neighbors already have that assignment. This simple check prevents us from progressing down deep dead ends:</p>&#13;
<pre><code>def graph_color_dfs_pruning(g: Graph, num_colors: int, index: int=0) -&gt; bool: &#13;
    if index == g.num_nodes:&#13;
        return True&#13;
&#13;
    for color in range(1, num_colors + 1):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> is_usable: bool = True&#13;
        for edge in g.nodes[index].get_edge_list():&#13;
            if g.nodes[edge.to_node].label == color:&#13;
                is_usable = False&#13;
&#13;
        if is_usable:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> g.nodes[index].label = color&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if graph_color_dfs_pruning(g, num_colors, index + 1):&#13;
                return True&#13;
            g.nodes[index].label = None&#13;
&#13;
    return False&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>The code again starts with the base case, checking whether all nodes have been assigned and, if so, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The code does not need to check for the validity of the current assignment, because it will do that before assigning each color.</p>&#13;
<p class="TX">If there are more nodes to explore (assign), then the code iterates through all the possible colors for the current node. It first checks whether any neighboring node uses this color and, if so, marks it as unusable for the current node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If the color is usable, the code continues with the recursive exploration, assigning the color to the node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and recursively proceeding to the next node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. As with the approach in <a href="#list16-2">Listing 16-2</a>, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if it finds a valid assignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if it is forced to backtrack.</p>&#13;
<p class="TX"><a href="#fig16-8">Figure 16-8</a> shows a backtracking search with pruning on an example graph with five nodes and <i>C</i> = 3.</p>&#13;
<p class="TX">During its first few steps, the search progresses through assigning valid colors to node 0 in <a href="#fig16-8">Figure 16-8(a)</a>, node 1 in <a href="#fig16-8">Figure 16-8(b)</a>, node 2 in <a href="#fig16-8">Figure 16-8(c)</a>, and node 3 in <a href="#fig16-8">Figure 16-8(d)</a>. When it reaches node 4, it realizes it is at a dead end: none of the three potential colors can be assigned to this node. The search backtracks to where it assigned node 3, but this doesn’t help because at that point, node 3 had only one possible valid assignment. The search backtracks again and tries a different assignment for node 2 in <a href="#fig16-8">Figure 16-8(e)</a>. When the search hits its next dead end in <a href="#fig16-8">Figure 16-8(f)</a>, it backtracks all the way to where it assigned node 1 and tries a new color there, as shown in <a href="#fig16-8">Figure 16-8(g)</a>. With the new node 1 assignment, the search can find assignments for the remaining nodes without trouble.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>&#13;
<figure class="IMG"><img id="fig16-8" class="img80" src="../images/f16008.jpg" alt="The figure has 10 subfigures, each showing a different coloring or partial coloring of the graph. The graph has edges (0, 3), (1, 2), (1, 4), (2, 3), (2, 4), and (3, 4)." width="1486" height="2245"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: Ten steps of a backtracking search graph-coloring algorithm with pruning</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>Backtracking search with pruning is like a methodical conference planner with a good eraser. They start by making initial table assignments one by one. For each assignment, they check whether there is a known conflict at the table. If so, they skip that assignment and avoid wasted effort—there is no point in searching for the rest of a solution if they already know it will result in a screaming match over the merits of B-trees versus red-black trees. This validity check only helps so much, however. The planner still reaches dead ends where the current person has no valid table. An ardent LISP programmer will have nowhere to go if every table already has at least one Python aficionado. The conference planner takes out their trusty eraser, sighs deeply, and starts backtracking to an earlier point where they could have made a different assignment.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-233"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp></h4>&#13;
<p class="TNI1">Beyond these exact but computationally expensive solutions, we can consider heuristic approaches. The <i>greedy approach</i> to graph coloring considers one node at a time, picking the first color that does not violate any constraints with the already assigned neighbors. Unlike the exhaustive algorithms described in this section, we define this greedy search without respect to a maximum number of colors. While it will always find some solution, the search’s greedy nature means it will not always use the smallest possible number of colors.</p>&#13;
<p class="TX">The code for the greedy search approach starts with a helper function that finds the first valid color for a node by determining which colors are used by its neighbors, then choosing the first color not in that set, as shown in <a href="#list16-3">Listing 16-3</a>.</p>&#13;
<span id="list16-3"/>&#13;
<pre><code>def first_unused_color(g: Graph, node_index: int) -&gt; int: &#13;
    used_colors: set = set()&#13;
    for edge in g.nodes[node_index].get_edge_list():&#13;
        neighbor: Node = g.nodes[edge.to_node]&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if neighbor.label is not None:&#13;
            used_colors.add(neighbor.label)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> color: int = 1&#13;
    while color in used_colors:&#13;
        color = color + 1&#13;
    return color&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Finding a valid color assignment for a node</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> function collects the colors seen in the neighboring nodes in a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>, which allows it to easily insert new colors and check whether a color has already been used. The code then iterates through all the node’s neighbors. For each neighbor, it adds that node’s color to the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp> set. It skips unassigned nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor.label</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>) because they do not provide a conflict <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. The code finishes by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to find the first color that does not occur in the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp> set <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. While this is not terribly efficient, the loop will always find <i>some</i> color that could be used.</p>&#13;
<p class="TX">Given the helper function, this greedy search can be implemented in a single loop:</p>&#13;
<pre><code>def graph_color_greedy(g: Graph) -&gt; bool: &#13;
    for idx in range(g.num_nodes):&#13;
        g.nodes[idx].label = first_unused_color(g, idx)&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_greedy()</samp> function iterates through all nodes using the index variable <samp class="SANS_TheSansMonoCd_W5Regular_11">idx</samp>. For each node, it calls the helper function from <a href="#list16-3">Listing 16-3</a> to find the first color that does not conflict with an assigned neighbor. For consistency with other algorithms in this chapter, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to indicate that it has found a valid coloring.</p>&#13;
<p class="TX">We can visualize the greedy algorithm through the eyes of the Conference Chair for Banquet Seating at the data structure convention. The organizer iterates through the list of attendees one by one, assigning each to a table before moving on to the next. For each attendee, they review the list of available tables and check whether a conflict would arise with any of the attendees already assigned there. This is equivalent to checking whether the current attendee (node) has a conflict (shares an edge) with any of the table’s other occupants (already assigned nodes). If so, the organizer moves on to the next table on the list. If they run out of tables, they sigh, mumble unkind words about the absurdity of programming language fights, and add a new table to the floor.</p>&#13;
<p class="TX"><a href="#fig16-9">Figure 16-9</a> illustrates this greedy search. During the first iteration in <a href="#fig16-9">Figure 16-9(a)</a>, the code assigns a color to node 0. In <a href="#fig16-9">Figure 16-9(b)</a>, it then considers node 1. Since that node shares an edge with node 0, the search cannot reuse color = 1. Instead, it assigns node 1 to color = 2. When it considers node 2 in <a href="#fig16-9">Figure 16-9(c)</a>, the only assigned neighbor has color = 2, so the search can assign node 2 color = 1. This search continues until it has assigned all nodes a color, as shown in <a href="#fig16-9">Figure 16-9(e)</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>&#13;
<figure class="IMG"><img id="fig16-9" class="img100" src="../images/f16009.jpg" alt="A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4), (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with color = 1. (B) shows the same graph with node 0 labeled with color = 1 and node 1 labeled with color = 2. (C) shows the assignments [1, 2, 1, None, None]. (D) shows the assignments [1, 2, 1, 2, None]. (E) shows the assignments [1, 2, 1, 2, 3]." width="1675" height="829"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: The five steps of a greedy coloring algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Given enough colors, the greedy algorithm will find a valid coloring for the graph. However, this assignment is not guaranteed to use the fewest colors. Instead, the order in which the nodes are assigned has a significant impact on how many colors the greedy algorithm will require. Consider <a href="#fig16-10">Figure 16-10</a>, which shows two valid ways of coloring the same graph.</p>&#13;
<figure class="IMG"><img id="fig16-10" class="img80" src="../images/f16010.jpg" alt="Both subfigures show graphs with five nodes and edges (0, 3), (1, 2), (1, 4), (2, 3), (2, 4), and (3, 4). (A) shows the graph with assignments [1, 1, 2, 3, 4]. (B) shows the graph with assignments [1, 3, 2, 3, 1]. " width="1080" height="568"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: A graph where the greedy coloring approach finds a solution with four colors (a) while there exists a solution with only three (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig16-10">Figure 16-10(a)</a> shows the graph coloring produced by the greedy algorithm. Because the search assigns the same color to nodes 0 and 1, it must use a fourth color on node 4. In contrast, depth-first search with pruning would find an optimal coloring requiring only three colors, as shown in <a href="#fig16-10">Figure 16-10(b)</a>. The trade-off is speed versus optimality. While the greedy <span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>search will occasionally use more than the minimum number of colors, its lack of backtracking makes it faster.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-234"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Node Removal</samp></h4>&#13;
<p class="TNI1">Another heuristic algorithm worth discussing is the <i>removal algorithm</i> proposed by a team of scientists at IBM to find nonconflicting assignments of variables to CPU registers in a compiler. This algorithm works by iteratively simplifying the problem if possible. As with the example of assigning parking spaces, the paper’s authors defined register assignment as a graph-coloring problem that uses nodes to represent variables, edges to capture which variables were in use at the same time, and colors to represent each of the CPU’s registers. The number of colors is fixed at <i>C</i> by the chip’s architecture. The algorithm’s goal is to determine whether it can find a graph coloring that uses <i>C</i> or fewer colors.</p>&#13;
<p class="TX">As discussed in their paper “Register Allocation via Coloring” by George Chaitin et al., the IBM team proposed a multistep approach to register allocation that includes a node removal algorithm for generating the color assignments. This algorithm relies on the insight that if a node has fewer than <i>C</i> edges, we can trivially assign it a color after we have assigned colors to its neighbors. We simply review its neighbors’ colors and use any color that doesn’t occur among those nodes, reusing our <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> function from <a href="#list16-3">Listing 16-3</a>. Therefore, we can initially ignore a node with fewer than <i>C</i> edges and focus on the more difficult cases: nodes with <i>C</i> or more neighbors. In fact, we can go one step further and temporarily remove any node with fewer than <i>C</i> edges from the graph, along with its edges, while we deal with the remaining nodes. We then re-add that node when it is time to assign its color.</p>&#13;
<p class="TX">Based on this insight, the algorithm iteratively checks the nodes in the current graph and removes any that have <i>C</i> or fewer edges, along with those edges. It adds these nodes to a stack to revisit once it has dealt with the more difficult cases. As it removes nodes and edges, new nodes will drop below the <i>C</i> neighbor threshold and can be removed as well. It knows that it will be able to easily find a color for those nodes using <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> when it returns to them after assigning colors to the neighbors.</p>&#13;
<p class="TX">If the algorithm can remove every node from the graph, we know it has a valid coloring with <i>C</i> colors. If the search tracks what it removes in a stack, it can pop items from the stack to reverse the operations and reassemble the graph, using it to effectively re-add the nodes to the graph and assign colors along the way.</p>&#13;
<p class="TX">The code for the removal algorithm uses this two-phase approach:</p>&#13;
<pre><code>def graph_color_removal(g: Graph, num_colors: int) -&gt; bool: &#13;
    removed: list = [False] * g.num_nodes&#13;
    node_stack: list = []&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> g2 = g.make_copy()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>&#13;
&#13;
    removed_one: bool = True&#13;
    while removed_one:&#13;
        removed_one = False&#13;
        for node in g2.nodes:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if not removed[node.index] and node.num_edges() &lt; num_colors:&#13;
                node_stack.append(node.index)&#13;
&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> all_edges: list = node.get_sorted_edge_list()&#13;
                for edge in all_edges:&#13;
                    g2.remove_edge(edge.from_node, edge.to_node)&#13;
&#13;
                removed[node.index] = True&#13;
                removed_one = True&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if len(node_stack) &lt; g.num_nodes:&#13;
        return False&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> while len(node_stack) &gt; 0:&#13;
        current: int = node_stack.pop()&#13;
        g.nodes[current].label = first_unused_color(g, current)&#13;
&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The code starts by creating multiple helper data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp> array stores a Boolean for each node, allowing the code to quickly check whether a node is still in the graph. The list <samp class="SANS_TheSansMonoCd_W5Regular_11">node_stack</samp> stores information about the nodes removed from the graph and the order in which they were removed. The code also makes a copy of the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>), allowing it to remove edges without modifying the original graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The code then enters a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that continues as long as the function has removed at least one node in the previous iteration (as tracked by the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">removed_one</samp>). Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, the code iterates through each node in the graph, checking whether that node has already been removed and how many neighbors it has <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If the node has not been removed and has fewer than <i>C</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>) neighbors, the code adds the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">node _stack</samp>, removes all its edges <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>, and marks the node as removed. Technically, the code removes only the edges from the graph; the nodes’ removals are captured through the <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp> array. This allows us to stably iterate over the graph’s nodes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop and doesn’t impact the accuracy of the algorithm.</p>&#13;
<p class="TX">If the code does not manage to remove all the nodes from the graph and add them to the stack, it has failed in finding a valid color assignment <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. In this case, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If there is a valid assignment, the code assigns the colors one at a time <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>. As it pops each node from the stack, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> from <a href="#list16-3">Listing 16-3</a> to choose a valid color. Since the node had fewer than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp> neighbors when it was added to the stack, it now must have fewer than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp> neighbors that have been assigned a color. Thus <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> will choose a valid color in the range [1, <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>].</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>We can picture the removal algorithm in the context of our conference planner by employing the key phrase “I’ll just deal with this attendee later.” Any time the conference planner sees an attendee with fewer than <i>C</i> conflicts, they dismissively say, “This person isn’t going to be a problem. I can find a table for them. I’ll just deal with them after I’ve handled the difficult attendees.” Outsiders might see this as procrastination, but graph-coloring enthusiasts recognize it as a key algorithmic insight.</p>&#13;
<p class="TX"><a href="#fig16-11">Figures 16-11</a> shows the first phase of this code’s operation for <i>C</i> = 3. In this stage, the nodes are removed one at a time. During the first iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, three nodes are removed. Node 2 has fewer than <i>C</i> neighbors and is added to the stack in <a href="#fig16-11">Figure 16-11(b)</a>. Node 3 is removed next in <a href="#fig16-11">Figure 16-11(c)</a>. At this point, node 4 has fewer than <i>C</i> neighbors and can also be removed, as shown in <a href="#fig16-11">Figure 16-11(d)</a>.</p>&#13;
<figure class="IMG"><img id="fig16-11" class="img100" src="../images/f16011.jpg" alt="(A) shows the five-node graph with edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4), (2, 4), and (3, 4). Each subsequent subfigure shows the graph with one additional node removed and the corresponding number added to the stack. (B) has node 2 removed. (C) has node 3 removed. (D) has node 4 removed. (E) has node 0 removed. (F) has no nodes remaining." width="1485" height="1321"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-11: The first phase of the removal graph-coloring algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The algorithm has now passed through each node in the graph one time. Since it has removed at least one node during this iteration, it restarts from node 0 and checks again. In <a href="#fig16-11">Figure 16-11(e)</a> it removes node 0, which has only one remaining neighbor. Finally, it removes node 1 in <a href="#fig16-11">Figure 16-11(f)</a>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>The second phase of the algorithm, shown in <a href="#fig16-12">Figure 16-12</a>, labels and “re-adds” the nodes. The algorithm starts by popping node 1 from the stack and assigning it color 1, as shown in <a href="#fig16-12">Figure 16-12(a)</a>. In <a href="#fig16-12">Figure 16-12(b)</a>, the algorithm pops node 0 from the stack and assigns node 0 the first color that does not conflict with a neighbor. This process continues for nodes 4, 3, and 2 in <a href="#fig16-12">Figures 16-12(c)</a>, <a href="#fig16-12">16-12(d)</a>, and <a href="#fig16-12">16-12(e)</a>, respectively.</p>&#13;
<figure class="IMG"><img id="fig16-12" class="img100" src="../images/f16012.jpg" alt="Each subfigure shows the graph with one additional node re-added and colored. (A) shows node 1 with color 1. (B) Adds Node 0 with color 2. (C) adds node 4 with color 3. (D) adds node 3 with color 1. (E) adds node 2 with color 2.&gt;" width="1634" height="1341"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-12: The second phase of the removal graph-coloring algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Unfortunately, this heuristic approach is not sufficient to solve every graph. A graph coloring can sometimes use fewer than <i>C</i> colors despite a cluster of interconnected nodes with at least <i>C</i> edges. In <a href="#fig16-13">Figure 16-13</a>, for example, the removal algorithm would fail for <i>C</i> = 3 despite a valid coloring with only two colors. Since every node has three neighbors, the removal algorithm cannot remove any. It is stuck.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>&#13;
<figure class="IMG"><img id="fig16-13" class="img30" src="../images/f16013.jpg" alt="A bipartite graph with six nodes and nine edges." width="335" height="458"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-13: An example graph for which the removal algorithm fails</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Yet it is obvious that we could create a valid assignment for the graph in <a href="#fig16-13">Figure 16-13</a> with only two colors. We could assign all nodes on the left a color of 1 and all nodes on the right a color of 2. Because the edges connect only left nodes to right nodes, there would be no conflicts. In fact, we could solve this particular case with the bipartite labeling algorithm from <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-235"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">The problem of finding an assignment of graph nodes to colors has a range of real-world use cases, from planning out magical labyrinths to assigning parking spaces. What makes this problem interesting is that there is no known algorithm that efficiently solves every case. Instead, we need to rely on either exhaustive searches or heuristics. This has led to the development of a variety of approaches aimed at providing good performance under different real-world conditions.</p>&#13;
<p class="TX">In the next chapter we examine similar assignment problems that do not have a known efficient solution. We look at a range of different branching searches based on the backtracking depth-first search from this chapter, as well as considering a variety of heuristics and the use of randomized algorithms to find solutions.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>