<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 1: How Web Applications Work</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_15" title="15"/>1</span><br/>
<span class="ChapterTitle">How Web Applications Work</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Before you can hack APIs, you must understand the technologies that support them. In this chapter, I will cover everything you need to know about web applications, including the fundamental aspects of HyperText Transfer Protocol (HTTP), authentication and authorization, and common web server databases. Because web APIs are powered by these technologies, understanding these basics will prepare you for using and hacking APIs.</p>
<h2 id="h1-502444c01-0001">Web App Basics</h2>
<p class="BodyFirst">Web applications function based on the client/server model: your web browser, the client, generates requests for resources and sends these to computers called web servers. In turn, these web servers send resources to <span epub:type="pagebreak" id="Page_16" title="16"/>the clients over a network. The term <em>web application</em> refers to software that is running on a web server, such as Wikipedia, LinkedIn, Twitter, Gmail, GitHub, and Reddit.</p>
<p>In particular, web applications are designed for end-user interactivity. Whereas websites are typically read-only and provide one-way communication from the web server to the client, web applications allow communications to flow in both directions, from server to client and from client to server. Reddit, for example, is a web app that acts as a newsfeed of information flowing around the internet. If it were merely a website, visitors would be spoon-fed whatever content the organization behind the site provided. Instead, Reddit allows users to interact with the information on the site by posting, upvoting, downvoting, commenting, sharing, reporting bad posts, and customizing their newsfeeds with subreddits they want to see. These features differentiate Reddit from a static website.</p>
<p>For an end user to begin using a web application, a conversation must take place between the web browser and a web server. The end user initiates this conversation by entering a URL into their browser address bar. In this section, we’ll discuss what happens next.</p>
<h3 id="h2-502444c01-0001">The URL</h3>
<p class="BodyFirst">You probably already know that the <em>uniform resource locator (URL)</em> is the address used to locate unique resources on the internet. This URL consists of several components that you’ll find helpful to understand when crafting API requests in later chapters. All URLs include the protocol used, the hostname, the port, the path, and any query parameters:</p>
<blockquote class="review">
<p class="Blockquote">Protocol://hostname[:port number]/[path]/[?query][parameters]</p></blockquote>
<p><em>Protocols </em>are the sets of rules computers use to communicate. The primary protocols used within the URL are HTTP/HTTPS for web pages and FTP for file transfers.</p>
<p>The <em>port</em>, a number that specifies a communication channel, is only included if the host does not automatically resolve the request to the proper port. Typically, HTTP communications take place over port 80. HTTPS, the encrypted version of HTTP, uses port 443, and FTP uses port 21. To access a web app that is hosted on a nonstandard port, you can include the port number in the URL, like so: <em>https://www.example.com:8443</em>. (Ports 8080 and 8443 are common alternatives for HTTP and HTTPS, respectively.)</p>
<p>The file directory <em>path</em> on the web server points to the location of the web pages and files specified in the URL. The path used in a URL is the same as a filepath used to locate files on a computer.</p>
<p>The <em>query</em> is an optional part of the URL used to perform functionality such as searching, filtering, and translating the language of the requested information. The web application provider may also use the query strings to track certain information such as the URL that referred you to the web page, your session ID, or your email. It starts with a question mark and contains a string that the server is programmed to process. Finally, the <em>query parameters</em> are the values that describe what should be done with the given query. For example, the query parameter <code>lang=en</code> following the query <code>page?</code> <span epub:type="pagebreak" id="Page_17" title="17"/>might indicate to the web server that it should provide the requested page in English. These parameters consist of another string to be processed by the web server. A query can contain multiple parameters separated by an ampersand (<code>&amp;</code>).</p>
<p>To make this information more concrete, consider the URL <a class="LinkURL" href="https://twitter.com/search?q=hacking&amp;src=typed_query">https://twitter.com/search?q=hacking&amp;src=typed_query</a>. In this example, the protocol is <em>https</em>, the hostname is <em>twitter.com</em>, the path is <em>search</em>, the query is <em>?q </em>(which stands for query), the query parameter is <em>hacking</em>, and<em> src=typed_query </em>is a tracking parameter. This URL is automatically built whenever you click the search bar in the Twitter web app, type in the search term “hacking,” and press <span class="KeyCaps">enter</span>. The browser is programmed to form the URL in a way that will be understood by the Twitter web server, and it collects some tracking information in the form of the <code>src</code> parameter. The web server will receive the request for hacking content and respond with hacking-related information.</p>
<h3 id="h2-502444c01-0002">HTTP Requests</h3>
<p class="BodyFirst">When an end user navigates to a URL using a web browser, the browser automatically generates an HTTP <em>request</em> for a resource. This resource is the information being requested—typically the files that make up a web page. The request is routed across the internet or network to the web server, where it is initially processed. If the request is properly formed, the web server passes the request to the web application.</p>
<p><a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a> shows the components of an HTTP request sent when authenticating to <em>twitter.com</em>.</p>
<pre><code>POST<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> /sessions<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> HTTP/1.1<span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
Host: twitter.com<span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 444
Cookie: _personalization_id=GA1.2.1451399206.1606701545; dnt=1;

username_or_email%5D=hAPI_hacker&amp;<span aria-label="annotation5" class="CodeAnnotationCode">❺</span>password%5D=NotMyPassword<span aria-label="annotation6" class="CodeAnnotationCode">❻</span>%21<span aria-label="annotation7" class="CodeAnnotationCode">❼</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: An HTTP request to authenticate with <em>twitter</em><em>.com</em></p>
<p>HTTP requests start with the method <span aria-label="annotation1" class="CodeAnnotation">❶</span>, the path of the requested resource <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and the protocol version <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The method, described in the “HTTP Methods” section later in this chapter, tells the server what you want to do. In this case, you use the POST method to send your login credentials to the server. The path may contain either the entire URL, the absolute path, or the relative path of a resource. In this request, the path, <em>/sessions</em>, specifies the page that handles Twitter authentication requests.</p>
<p>Requests include several <em>headers</em>, which are key-value pairs that communicate specific information between the client and the web server. Headers begin with the header’s name, followed by a colon (<code>:</code>) and then the value <span epub:type="pagebreak" id="Page_18" title="18"/>of the header. The <code>Host</code> header <span aria-label="annotation4" class="CodeAnnotation">❹</span> designates the domain host, <em>twitter.com</em>. The <code>User-Agent</code> header describes the client’s browser and operating system. The <code>Accept</code> headers describe which types of content the browser can accept from the web application in a response. Not all headers are required, and the client and server may include others not shown here, depending on the request. For example, this request includes a <code>Cookie</code> header, which is used between the client and server to establish a stateful connection (more on this later in the chapter). If you’d like to learn more about all the different headers, check out Mozilla’s developer page on headers (<a class="LinkURL" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</a>).</p>
<p>Anything below the headers is the <em>message body</em>, which is the information that the requestor is attempting to have processed by the web application. In this case, the body consists of the username <span aria-label="annotation5" class="CodeAnnotation">❺</span> and password <span aria-label="annotation6" class="CodeAnnotation">❻</span> used to authenticate to a Twitter account. Certain characters in the body are automatically encoded. For example, exclamation marks (<code>!</code>) are encoded as <code>%21</code> <span aria-label="annotation7" class="CodeAnnotation">❼</span>. Encoding characters is one way that a web application may securely handle characters that could cause problems.</p>
<h3 id="h2-502444c01-0003">HTTP Responses</h3>
<p class="BodyFirst">After a web server receives an HTTP request, it will process and respond to the request. The type of response depends on the availability of the resource, the user’s authorization to access the resource, the health of the web server, and other factors. For example, <a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> shows the response to the request in <a href="#listing1-1">Listing 1-1</a>.</p>
<pre><code>HTTP/1.1<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> 302 Found<span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
content-security-policy: default-src 'none'; connect-src 'self'
location: https://twitter.com/
pragma: no-cache
server: tsa_a
set-cookie: auth_token=8ff3f2424f8ac1c4ec635b4adb52cddf28ec18b8; Max-Age=157680000; Expires=Mon, 01 Dec 2025 16:42:40 GMT; Path=/; Domain=.twitter.com; Secure; HTTPOnly; SameSite=None

&lt;html&gt;&lt;body&gt;You are being &lt;a href="https://twitter.com/"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: An example of an HTTP response when authenticating to <em>twitter</em><em>.com</em></p>
<p>The web server first responds with the protocol version in use (in this case, HTTP/1.1 <span aria-label="annotation1" class="CodeAnnotation">❶</span>). HTTP 1.1 is currently the standard version of HTTP used. The status code and status message <span aria-label="annotation2" class="CodeAnnotation">❷</span>, discussed in more detail in the next section, are 302 Found. The 302 response code indicates that the client successfully authenticated and will be redirected to a landing page the client is authorized to access.</p>
<p>Notice that, like HTTP request headers, there are HTTP response headers. HTTP response headers often provide the browser with instructions for handling the response and security requirements. The <code>set-cookie</code> header is another indication that the authentication request was successful, because the web server has issued a cookie that includes an <code>auth_token</code>, <span epub:type="pagebreak" id="Page_19" title="19"/>which the client can use to access certain resources. The response message body will follow the empty line after the response headers. In this case, the web server has sent an HTML message indicating that the client is being redirected to a new web page.</p>
<p>The request and response I’ve shown here illustrates a common way in which a web application restricts access to its resources through the use of authentication and authorization. Web <em>authentication</em> is the process of proving your identity to a web server. Common forms of authentication include providing a password, token, or biometric information (such as a fingerprint). If a web server approves an authentication request, it will respond by providing the authenticated user <em>authorization</em> to access certain resources. In <a href="#listing1-1">Listing 1-1</a>, we saw an authentication request to a Twitter web server that sent a username and password using a POST request. The Twitter web server responded to the successful authentication request with 302 Found (in <a href="#listing1-2">Listing 1-2</a>). The session <code>auth_token</code> in the <code>set-cookie</code> header authorized access to the resources associated with the hAPI_hacker Twitter account.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	HTTP traffic is sent in cleartext, meaning it’s not hidden or encrypted in any way. Anyone who intercepted the authentication request in <a href="#listing1-1">Listing 1-1</a> could read the username and password. To protect sensitive information, HTTP protocol requests can be encrypted with Transport Layer Security (TLS) to create the HTTPS protocol.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502444c01-0004">HTTP Status Codes</h3>
<p class="BodyFirst">When a web server responds to a request, it issues a response status code, along with a response message. The response code signals how the web server has handled the request. At a high level, the response code determines if the client will be allowed or denied access to a resource. It can also indicate that a resource does not exist, there is a problem with the web server, or requesting the given resource has resulted in being redirected to another location.</p>
<p>Listings 1-3 and 1-4 illustrate the difference between a 200 response and a 404 response, respectively.</p>
<pre><code><b>HTTP/1.1 200 OK</b>
Server: tsa_a
<b>Content-length: 6552</b>

<b>&lt;!DOCTYPE html&gt;</b>
<b>&lt;html dir="ltr" lang="en"&gt;</b>
<b>[</b><b>...</b><b>]</b></code></pre>
<p class="CodeListingCaption"><a id="listing1-3">Listing 1-3</a>: An example of a 200 response</p>
<pre><code><b>HTTP/1.1 404 Not Found</b>
Server: tsa_a
<b>Content-length: 0</b></code></pre>
<p class="CodeListingCaption"><a id="listing1-4">Listing 1-4:</a> An example of a 404 response</p>
<p><span epub:type="pagebreak" id="Page_20" title="20"/>The 200 OK response will provide the client with access to the requested resource, whereas the 404 Not Found response will either provide the client with some sort of error page or a blank page, because the requested resource was not found.</p>
<p>Since web APIs primarily function using HTTP, it is important to understand the sorts of response codes you should expect to receive from a web server, as detailed in <a href="#table1-1" id="tableanchor1-1">Table 1-1</a>. For more information about individual response codes or about web technologies in general, check out Mozilla’s Web Docs (<a class="LinkURL" href="https://developer.mozilla.org/en-US/docs/Web/HTTP">https://developer.mozilla.org/en-US/docs/Web/HTTP</a>). Mozilla has provided a ton of useful information about the anatomy of web applications.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-1">Table 1-1</a>: HTTP Response Code Ranges</p></figcaption>
<table border="1" id="table-502444c01-0001">
<thead>
<tr>
<td><b>Response code</b></td>
<td><b>Response type</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>100s</td>
<td>Information-based responses</td>
<td>Responses in the 100s are typically related to some sort of processing status update regarding the request.</td>
</tr>
<tr>
<td>200s</td>
<td>Successful responses</td>
<td>Responses in the 200s indicate a successful and accepted request.</td>
</tr>
<tr>
<td>300s</td>
<td>Redirects</td>
<td>Responses in the 300s are notifications of redirection. This is common to see for a request that automatically redirects you to the index/home page or when you request a page from port 80 HTTP to port 443 for HTTPS.</td>
</tr>
<tr>
<td>400s</td>
<td>Client errors</td>
<td>Responses in the 400s indicate that something has gone wrong from the client perspective. This is often the type of response you will receive if you have requested a page that does not exist, if there is a timeout in the response, or when you are forbidden from viewing the page.</td>
</tr>
<tr>
<td>500s</td>
<td>Server errors</td>
<td>Responses in the 500s are indications that something has gone wrong with the server. These include internal server errors, unavailable services, and unrecognized request methods.</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-502444c01-0005">HTTP Methods</h3>
<p class="BodyFirst">HTTP <em>methods</em> request information from a web server. Also known as HTTP verbs, the HTTP methods include GET, PUT, POST, HEAD, PATCH, OPTIONS, TRACE, and DELETE.</p>
<p>GET and POST are the two most commonly used request methods. The GET request is used to obtain resources from a web server, and the POST request is used to submit data to a web server. <a href="#table1-2" id="tableanchor1-2">Table 1-2</a> provides more in-depth information about each of the HTTP request methods.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-2">Table 1-2</a>: HTTP Methods<span epub:type="pagebreak" id="Page_21" title="21"/></p></figcaption>
<table border="1" id="table-502444c01-0002">
<thead>
<tr>
<td><b>Method</b></td>
<td><b>Purpose</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>GET requests attempt to gather resources from the web server. This could be any resource, including a web page, user data, a video, an address, and so on. If the request is successful, the server will provide the resource; otherwise, the server will provide a response explaining why it was unable to get the requested resource.</td>
</tr>
<tr>
<td>POST</td>
<td>POST requests submit data contained in the body of the request to a web server. This could include client records, requests to transfer money from one account to another, and status updates, for example. If a client submits the same POST request multiple times, the server will create multiple results.</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT requests instruct the web server to store submitted data under the requested URL. PUT is primarily used to send a resource to a web server. If a server accepts a PUT request, it will add the resource or completely replace the existing resource. If a PUT request is successful, a new URL should be created. If the same PUT request is submitted again, the results should remain the same.</td>
</tr>
<tr>
<td>HEAD</td>
<td>HEAD requests are similar to GET requests, except they request the HTTP headers only, excluding the message body. This request is a quick way to obtain information about server status and to see if a given URL works.</td>
</tr>
<tr>
<td>PATCH</td>
<td>PATCH requests are used to partially update resources with the submitted data. PATCH requests are likely only available if an HTTP response includes the <code>Accept-Patch</code> header.</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>OPTIONS requests are a way for the client to identify all the request methods allowed from a given web server. If the web server responds to an OPTIONS request, it should respond with all allowed request options.</td>
</tr>
<tr>
<td>TRACE</td>
<td>TRACE requests are primarily used for debugging input sent from the client to the server. TRACE asks the server to echo back the client’s original request, which could reveal that a mechanism is altering the client’s request before it is processed by the server.</td>
</tr>
<tr>
<td>CONNECT</td>
<td>CONNECT requests initiate a two-way network connection. When allowed, this request would create a proxy tunnel between the browser and web server.</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE requests ask that the server remove a given resource.</td>
</tr>
</tbody>
</table>
</figure>
<p>Some methods are <em>idempotent</em>, which means they can be used to send the same request multiple times without changing the state of a resource on a web server. For example, if you perform the operation of turning on a light, then the light turns on. When the switch is already on and you try to flip the switch on again, it remains on—nothing changes. GET, HEAD, PUT, OPTIONS, and DELETE are idempotent.</p>
<p>On the other hand, <em>non-idempotent</em> methods can dynamically change the results of a resource on a server. Non-idempotent methods include POST, PATCH, and CONNECT. POST is the most commonly used method for changing web server resources. POST is used to create new resources on a web server, so if a POST request is submitted 10 times, there will be 10 new resources on the web server. By contrast, if an idempotent method like PUT, typically used to update a resource, is requested 10 times, a single resource will be overwritten 10 times.</p>
<p><span epub:type="pagebreak" id="Page_22" title="22"/>DELETE is also idempotent, because if the request to delete a resource was sent 10 times, the resource would be deleted only once. The subsequent times, nothing would happen. Web APIs will typically only use POST, GET, PUT, DELETE, with POST as non-idempotent methods.</p>
<h3 id="h2-502444c01-0006">Stateful and Stateless HTTP</h3>
<p class="BodyFirst">HTTP is a <em>stateless</em> protocol, meaning the server doesn’t keep track of information between requests. However, for users to have a persistent and consistent experience with a web application, the web server needs to remember something about the HTTP session with that client. For example, if a user is logged in to their account and adds several items to the shopping cart, the web application needs to keep track of the state of the end user’s cart. Otherwise, every time the user navigated to a different web page, the cart would empty again.</p>
<p>A <em>stateful connection</em> allows the server to track the client’s actions, profile, images, preferences, and so on. Stateful connections use small text files, called <em>cookies</em>, to store information on the client side. Cookies may store site-specific settings, security settings, and authentication-related information. Meanwhile, the server often stores information on itself, in a cache, or on backend databases. To continue their sessions, browsers include the stored cookies in requests to the server, and when hacking web applications, an attacker can impersonate an end user by stealing or forging their cookies.</p>
<p>Maintaining a stateful connection with a server has scaling limitations. When a state is maintained between a client and a server, that relationship exists only between the specific browser and the server used when the state was created. If a user switches from, say, using a browser on one computer to using the browser on their mobile device, the client would need to reauthenticate and create a new state with the server. Also, stateful connections require the client to continuously send requests to the server. Challenges start to arise when many clients are maintaining state with the same server. The server can only handle as many stateful connections as allowed by its computing resources. This is much more readily solved by stateless applications.</p>
<p><em>Stateless communications</em> eliminate the need for the server resources required to manage sessions. In stateless communications, the server doesn’t store session information, and every stateless request sent must contain all the information necessary for the web server to recognize that the requestor is authorized to access the given resources. These stateless requests can include a key or some form of authorization header to maintain an experience similar to that of a stateful connection. The connections do not store session data on the web app server; instead, they leverage backend databases.</p>
<p>In our shopping cart example, a stateless application could track the contents of a user’s cart by updating the database or cache based on requests that contain a certain token. The end-user experience would appear the same, but how the web server handles the request is quite a bit different. Since their appearance of state is maintained and the client issues <span epub:type="pagebreak" id="Page_23" title="23"/>everything needed in a given request, stateless apps can scale without the concern of losing information within a stateful connection. Instead, any number of servers can be used to handle requests as long as all the necessary information is included within the request and that information is accessible on the backend databases.</p>
<p>When hacking APIs, an attacker can impersonate an end user by stealing or forging their token. API communications are stateless—a topic I will explore in further detail in the next chapter.</p>
<h2 id="h1-502444c01-0002">Web Server Databases</h2>
<p class="BodyFirst">Databases allow servers to store and quickly provide resources to clients. For example, any social media platform that allows you to upload status updates, photos, and videos is definitely using databases to save all that content. The social media platform could be maintaining those databases on its own; alternatively, the databases could be provided to the platform as a service.</p>
<p>Typically, a web application will store user resources by passing the resources from frontend code to backend databases. The frontend of a web application, which is the part of a web application that a user interacts with, determines its look and feel and includes its buttons, links, videos, and fonts. Frontend code usually includes HTML, CSS, and JavaScript. In addition, the frontend could include web application frameworks like AngularJS, ReactJS, and Bootstrap, to name a few. The <em>backend</em> consists of the technologies that the frontend needs to function. It includes the server, the application, and any databases. Backend programming languages include JavaScript, Python, Ruby, Golang, PHP, Java, C#, and Perl, to name a handful.</p>
<p>In a secure web application, there should be no direct interaction between a user and the backend database. Direct access to a database would remove a layer of defense and open up the database to additional attacks. When exposing technologies to end users, a web application provider expands their potential for attack, a metric known as the <em>attack surface</em>. Limiting direct access to a database shrinks the size of the attack surface.</p>
<p>Modern web applications use either SQL (relational) databases or NoSQL (nonrelational) databases. Knowing the differences between SQL and NoSQL databases will help you later tailor your API injection attacks.</p>
<h3 id="h2-502444c01-0007">SQL</h3>
<p class="BodyFirst"><em>Structured Query Language (SQL)</em> databases are <em>relational databases</em> in which the data is organized in tables. The table’s rows, called<em> records</em>, identify the data type, such as username, email address, or privilege level. Its columns are the data’s <em>attributes</em> and could include all of the different usernames, email addresses, and privilege levels. In Tables 1-3 through 1-5, UserID, Username, Email, and Privilege are the data types. The rows are the data for the given table.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-3">Table 1-3</a>: A Relational User Table<span epub:type="pagebreak" id="Page_24" title="24"/></p></figcaption>
<table border="1" id="table-502444c01-0003">
<thead>
<tr>
<td><b>UserID</b></td>
<td><b>Username</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>111</td>
<td>hAPI_hacker</td>
</tr>
<tr>
<td>112</td>
<td>Scuttleph1sh</td>
</tr>
<tr>
<td>113</td>
<td>mysterioushadow</td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table1-4">Table 1-4</a>: A Relational Email Table</p></figcaption>
<table border="1" id="table-502444c01-0004">
<thead>
<tr>
<td><b>UserID</b></td>
<td><b>Email</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>111</td>
<td><em>hapi_hacker@email.com</em></td>
</tr>
<tr>
<td>112</td>
<td><em>scuttleph1sh@email.com</em></td>
</tr>
<tr>
<td>113</td>
<td><em>mysterioushadow@email.com</em></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table1-5">Table 1-5</a>: A Relational Privilege Table</p></figcaption>
<table border="1" id="table-502444c01-0005">
<thead>
<tr>
<td><b>UserID</b></td>
<td><b>Privilege</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>111</td>
<td>admin</td>
</tr>
<tr>
<td>112</td>
<td>partner</td>
</tr>
<tr>
<td>113</td>
<td>user</td>
</tr>
</tbody>
</table>
</figure>
<p>To retrieve data from a SQL database, an application must craft a SQL query. A typical SQL query to find the customer with the identification of 111 would look like this:</p>
<pre><code>SELECT * FROM Email WHERE UserID = 111;</code></pre>
<p>This query requests all records from the Email table that have the value 111 in the UserID column. <code>SELECT</code> is a statement used to obtain information from the database, the asterisk is a wildcard character that will select all of the columns in a table, <code>FROM</code> is used to determine which table to use, and <code>WHERE</code> is a clause that is used to filter specific results.</p>
<p>There are several varieties of SQL databases, but they are queried similarly. SQL databases include MySQL, Microsoft SQL Server, PostgreSQL, Oracle, and MariaDB, among others.</p>
<p>In later chapters, I’ll cover how to send API requests to detect injection vulnerabilities, such as SQL injection. SQL injection is a classic web application attack that has been plaguing web apps for over two decades yet remains a possible attack method in APIs.</p>
<h3 id="h2-502444c01-0008">NoSQL</h3>
<p class="BodyFirst"><em>NoSQL databases</em>, also known as distributed databases, are <em>nonrelational</em>, meaning they don’t follow the structures of relational databases. NoSQL <span epub:type="pagebreak" id="Page_25" title="25"/>databases are typically open-source tools that handle unstructured data and store data as documents. Instead of relationships, NoSQL databases store information as keys and values. Unlike SQL databases, each type of NoSQL database will have its own unique structures, modes of querying, vulnerabilities, and exploits. Here’s a sample query using MongoDB, the current market share leader for NoSQL databases:</p>
<pre><code>db.collection.find({"UserID": 111})</code></pre>
<p>In this example, <code>db.collection.find()</code> is a method used to search through a document for information about the UserID with 111 as the value. MongoDB uses several operators that might be useful to know:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>$eq</code></span></span>  Matches values that are equal to a specified value</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>$gt</code></span></span>  Matches values that are greater than a specified value</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>$lt</code></span></span>  Matches values that are less than a specified value</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>$ne</code></span></span>  Matches all values that are not equal to a specified value</li>
</ol>
<p>These operators can be used within NoSQL queries to select and filter certain information in a query. For example, we could use the previous command without knowing the exact UserID, like so:</p>
<pre><code>db.collection.find({"UserID": {$gt:110}})</code></pre>
<p>This statement would find all UserIDs greater than 110. Understanding these operators will be useful when conducting NoSQL injection attacks later in this book.</p>
<p>NoSQL databases include MongoDB, Couchbase, Cassandra, IBM Domino, Oracle NoSQL Database, Redis, and Elasticsearch, among others.</p>
<h2 id="h1-502444c01-0003">How APIs Fit into the Picture</h2>
<p class="BodyFirst">A web application can be made more powerful if it can use the power of other applications. <em>Application programming interfaces (APIs)</em> comprise a technology that facilitates communications between separate applications. In particular, <em>web</em> APIs allow for machine-to-machine communications based on HTTP, providing a common method of connecting different applications together.</p>
<p>This ability has opened up a world of opportunities for application providers, as developers no longer have to be experts in every facet of the functionality they want to provide to their end users. For example, let’s consider a ridesharing app. The app needs a map to help its drivers navigate cities, a method for processing payments, and a way for drivers and customers to communicate. Instead of specializing in each of these different functions, a developer can leverage the Google Maps API for the mapping function, the Stripe API for payment processing, and the Twilio API to access SMS messaging. The developer can combine these APIs to create a whole new application.</p>
<p><span epub:type="pagebreak" id="Page_26" title="26"/>The immediate impact of this technology is twofold. First, it streamlines the exchange of information. By using HTTP, web APIs can take advantage of the protocol’s standardized methods, status codes, and client/server relationship, allowing developers to write code that can automatically handle the data. Second, APIs allow web application providers to specialize, as they no longer need to create every aspect of their web application.</p>
<p>APIs are an incredible technology with a global impact. Yet, as you’ll see in the following chapters, they have greatly expanded the attack surface of every application using them on the internet.</p>
<h2 id="h1-502444c01-0004">Summary</h2>
<p class="BodyFirst">In this chapter we covered the fundamental aspects of web applications. If you understand the general functions of HTTP requests and responses, authentication/authorization, and databases, you will easily be able to understand web APIs, because the underlying technology of web applications is the underlying technology of web APIs. In the next chapter we will examine the anatomy of APIs.</p>
<p>This chapter is meant to equip you with just enough information to be dangerous as an API hacker, not as a developer or application architect. If you would like additional resources about web applications, I highly suggest <em>The Web Application Hackers Handbook</em> (Wiley, 2011), <em>Web Application Security</em> (O’Reilly, 2020), <em>Web Security for Developers</em> (No Starch Press, 2020), and <em>The Tangled Web</em> (No Starch Press, 2011).</p>
</section>
</body>
</html>