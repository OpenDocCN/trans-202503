- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATA STORAGE FORMATS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may be used to thinking of computers as hardware devices for storing collections
    of programs, files, and graphics. In this book, we’ll look at computers in a different
    way: as billions of two-state switches and one or more *control units*—devices
    that can both detect and change the states of the switches.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), we discussed communicating with the world outside
    the computer using input and output. In this chapter, we’ll begin exploring how
    computers encode data for storage in memory, and we’ll write some programs in
    C that explore these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Switches and Groups of Switches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whatever you’re doing on your computer—streaming a video, posting on social
    media, writing a program—it’s done by combinations of two-state switches interacting
    with each other. Each combination of switches represents a possible state the
    computer can be in. If you wanted to describe what was happening on your computer,
    you could list a combination of switches. In plain English, this would be something
    like “The first switch is on, the second one is also on, but the third is off,
    while the fourth is on.” But describing the computer this way would be difficult,
    because modern computers use billions of switches. Instead, we use a more concise,
    numeric notation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Representing Switches with Bits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re probably familiar with the *decimal system*, which uses the digits 0
    to 9 to write numbers. We want to represent switches numerically, but our switches
    have only 2 states, not 10\. Here, the *binary system*—a two-digit system that
    uses `0`s and `1`s—is useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a *binary digit*, commonly shortened to *bit*, to represent the state
    of a switch. A bit can have two values: `0`, which represents that a switch is
    “off,” and `1`, which represents that a switch is “on.” If we wanted, we could
    assign the opposite values to these digits; all that matters is that we’re consistent.
    Let’s use bits to simplify our statement about switches: we have a computer in
    which the first, second, and fourth switches are on and the third is off. In binary,
    we would represent this as `1101`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Representing Groups of Bits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even with binary, sometimes we have so many bits that the number is un-readable.
    In those cases, we use *hexadecimal digits* to specify bit patterns. The hexadecimal
    system has 16 digits, each of which can represent one group of 4 bits. [Table
    2-1](ch02.xhtml#ch2tab1) shows all 16 possible combinations of 4 bits and the
    corresponding hexadecimal digit for each combination. After using hexadecimal
    for a while, you will probably memorize this table, but if you forget it, an online
    search will quickly bring up a hexadecimal-to-binary converter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** The Hexadecimal Representation of 4 Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0000` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0001` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `0010` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `0011` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `0100` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `0101` |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `0110` |'
  prefs: []
  type: TYPE_TB
- en: '| `7` | `0111` |'
  prefs: []
  type: TYPE_TB
- en: '| `8` | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `9` | `1001` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | `1010` |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | `1011` |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | `1100` |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | `1101` |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | `1110` |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | `1111` |'
  prefs: []
  type: TYPE_TB
- en: 'Using hexadecimal, we can write `1101`, or “on, on, off, on,” with a single
    digit: `d`[16] = `1101`[2].'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When it isn’t clear from the context, I will indicate the base of a number
    in this text with a subscript. For example, 100[10] is in decimal,* 100*[16] is
    in hexadecimal, and* 100*[2] is in binary.*'
  prefs: []
  type: TYPE_NORMAL
- en: The *octal* system, based on the number 8, is less common, but you will encounter
    it occasionally. The eight octal digits span from `0` to `7`, and each digit represents
    a group of 3 bits. [Table 2-2](ch02.xhtml#ch2tab2) shows the correspondence between
    each possible group of 3 bits and its corresponding single octal digit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** The Octal Representation of 3 Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **One octal digit** | **Three binary digits (bits)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `000` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `001` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `010` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `011` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `100` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `101` |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `110` |'
  prefs: []
  type: TYPE_TB
- en: '| `7` | `111` |'
  prefs: []
  type: TYPE_TB
- en: For example, the 4-bit example we’re using, `1101`[2], would be written `15`[8]
    in octal.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Hexadecimal Digits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Hexadecimal digits are especially convenient when we need to specify the state
    of a group of, say, 16 or 32 switches. In place of each group of 4 bits, we can
    write one hexadecimal digit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A single bit is rarely useful for storing data. The smallest number of bits
    that can be accessed at a time in a computer is defined as a *byte*. In most modern
    computers, a byte consists of 8 bits, but there are exceptions to the 8-bit byte.
    For example, the CDC 6000 series of scientific mainframe computers used a 6-bit
    byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C and C++ programming languages, prefixing a number with `0x`—that’s
    a zero and a lowercase *x*—specifies that the number is expressed in hexadecimal.
    Prefixing a number with only a `0` specifies octal representation. C++ allows
    us to specify a value in binary by prefixing the number with `0b`. Although the
    `0b` notation for specifying binary is not part of standard C, our compiler, `gcc`,
    allows it. Thus, when we write C or C++ code in this book, these all mean the
    same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using a different C compiler, you may not be able to use the `0b`
    syntax to specify binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '2.1     Express the following bit patterns in hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `0100 0101 0110 0111`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `1000 1001 1010 1011`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `1111 1110 1101 1100`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `0000 0010 0101 0010`
  prefs: []
  type: TYPE_NORMAL
- en: '2.2     Express the following hexadecimal patterns in binary:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `83af`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `9001`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `aaaa`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `5555`
  prefs: []
  type: TYPE_NORMAL
- en: 2.3     How many bits are represented by each of the following?
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `ffffffff`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `7fff58b7def0`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `1111`[2]
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `1111`[16]
  prefs: []
  type: TYPE_NORMAL
- en: 2.4     How many hexadecimal digits are required to represent each of the following?
  prefs: []
  type: TYPE_NORMAL
- en: (a)     8 bits
  prefs: []
  type: TYPE_NORMAL
- en: (b)     32 bits
  prefs: []
  type: TYPE_NORMAL
- en: (c)     64 bits
  prefs: []
  type: TYPE_NORMAL
- en: (d)     10 bits
  prefs: []
  type: TYPE_NORMAL
- en: (e)     20 bits
  prefs: []
  type: TYPE_NORMAL
- en: (f)     7 bits
  prefs: []
  type: TYPE_NORMAL
- en: '**The Mathematical Equivalence of Binary and Decimal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you learned that binary digits are a natural way to
    show the states of switches within the computer. You also learned that we can
    use hexadecimal to show the state of four switches with a single character. In
    this section, I’ll show you some of the mathematical properties of the binary
    number system and how it translates to and from the more familiar decimal (base
    10) number system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting to Know Positional Notation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By convention, we use positional notation when writing numbers. *Positional
    notation* means that the value of a symbol depends on its position within a group
    of symbols. In the familiar decimal number system, we use the symbols 0, 1, .
    . . , 9 to represent numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In the number 50, the value of the symbol 5 is 50 because it’s in the *tens
    position*, and any number in that position is multiplied by 10\. In the number
    500, the value of the symbol 5 is 500 because it’s in the *hundreds position*.
    The symbol 5 is the same in any position, but its value depends on the position
    it occupies within the number.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this a step further, in the decimal number system, the integer 123 is
    taken to mean
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg41_Image_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg41_Image_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the rightmost digit, 3, is the *least significant digit* because
    its value contributes the least to the number’s total value. The leftmost digit,
    1, is the *most significant digit* because it contributes the most value.
  prefs: []
  type: TYPE_NORMAL
- en: '**ANOTHER NUMBER SYSTEM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before positional notations were invented, people used counting systems to
    keep track of numerical quantities. The *Roman numeral* system is a well-known
    example of a counting system. It uses the symbols I for 1, V for 5, X for 10,
    L for 50, and so on. To represent two things, you simply use two I’s: II. Similarly,
    XX represents 20 things.'
  prefs: []
  type: TYPE_NORMAL
- en: The two main rules of the Roman numeral system are that symbols that represent
    larger values come first, and if a symbol representing a smaller value is placed
    before a larger one, then the value of the smaller one is subtracted from the
    immediately following larger one. For example, IV represents 4 because I (1) is
    less than V (5), so it is subtracted from the value represented by V.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no symbol for zero in the Roman numeral system because the symbol
    0 isn’t needed in counting systems. In a positional system, we need a symbol to
    mark the fact that there is no value in that position, but the position still
    counts toward the value being represented: the zeros in 500 tell us that there
    are no values in the tens position or the ones position. There is just a value
    of 5 in the hundreds position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The invention of positional notations greatly simplified arithmetic and led
    to the mathematics we know today. If you need to convince yourself, divide 60
    (LX) by 3 (III) in the Roman numeral system. (Answer: XX.)'
  prefs: []
  type: TYPE_NORMAL
- en: The *base*, or *radix*, of the decimal number system—that is, the number of
    unique digits—is 10\. This means there are 10 symbols to represent the digits
    0 through 9\. Moving a digit one place to the left increases its value by a factor
    of 10\. Moving it one place to the right decreases its value by a factor of 10\.
    The positional notation generalizes to any radix *r* as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg41_Image_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where there are *n* digits in the number and each *d[i]* is a single digit with
    0 *≤ d[i]* < *r*.
  prefs: []
  type: TYPE_NORMAL
- en: This expression tells us how to determine the value of each digit in the number.
    We determine the position of each digit in the number by counting from the right,
    starting with zero. At each position, we raise the radix, *r*, to the power of
    its position and then multiply that number by the value of the digit. Adding all
    the results gives us the value represented by the number.
  prefs: []
  type: TYPE_NORMAL
- en: The radix in the binary number system is 2, so there are only two symbols for
    representing the digits. This means that *d[i]* = `0`, `1`, and we can write this
    expression as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg42_Image_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where there are *n* digits in the number and each *d[i]* = `0` or `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll convert binary numbers to and from unsigned decimals.
    *Signed* numbers can be either positive or negative, but *unsigned* numbers have
    no sign. We’ll discuss signed numbers in [Chapter 3](ch03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Binary to Unsigned Decimal***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can easily convert from binary to decimal by computing the value of 2 raised
    to the power of the position it’s in and then multiplying that by the value of
    the bit in that position. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg42_Image_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using pseudocode, the procedure for converting binary to decimal can be summarized
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At each bit position, this algorithm computes 2*^i* and then multiplies by the
    respective bit value, either `0` or `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although we’re considering only integers at this point, this algorithm does
    generalize to fractional values. Simply continue the exponents of the radix,*
    r*, on to negative values—that is,* r^(n – *1*), r^(n – *2*)*, . . . ,* r*¹,*
    r*⁰,* r^(–*1*), r^(–*2*)*, . . . This will be covered in detail in [Chapter 19](ch19.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5     Looking at the generalized equation in this section, what are the values
    of *r*, *n*, and each *d[i]* for the decimal number 29,458,254 and the hexadecimal
    number `29458254`?
  prefs: []
  type: TYPE_NORMAL
- en: '2.6     Convert the following 8-bit binary numbers to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `1010 1010`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `0101 0101`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `1111 0000`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `0000 1111`
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `1000 0000`
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `0110 0011`
  prefs: []
  type: TYPE_NORMAL
- en: (g)     `0111 1011`
  prefs: []
  type: TYPE_NORMAL
- en: (h)     `1111 1111`
  prefs: []
  type: TYPE_NORMAL
- en: '2.7     Convert the following 16-bit binary numbers to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `1010 1011 1100 1101`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `0001 0011 0011 0100`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `1111 1110 1101 1100`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `0000 0111 1101 1111`
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `1000 0000 0000 0000`
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `0000 0100 0000 0000`
  prefs: []
  type: TYPE_NORMAL
- en: (g)     `0111 1011 1010 1010`
  prefs: []
  type: TYPE_NORMAL
- en: (h)     `0011 0000 0011 1001`
  prefs: []
  type: TYPE_NORMAL
- en: '2.8     Develop an algorithm to convert hexadecimal to decimal and then convert
    the following 16-bit numbers to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `a000`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `ffff`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `0400`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `1111`
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `8888`
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `0190`
  prefs: []
  type: TYPE_NORMAL
- en: (g)     `abcd`
  prefs: []
  type: TYPE_NORMAL
- en: (h)     `5555`
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Unsigned Decimal to Binary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we want to convert an unsigned decimal integer, *N*, to binary, we set it
    equal to the previous expression for binary numbers to give the equation
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where each *d[i]* = `0` or `1`. We divide both sides of this equation by 2,
    and the exponent of each 2 term on the right side decreases by 1, giving
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *N*[1] is the integer part and the remainder, *r*[0], is `0` for even
    numbers and `1` for odd numbers. Doing a little rewriting, we have the equivalent
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the terms within the parentheses on the right side are integers. The integer
    part of both sides of an equation must be equal, and the fractional parts must
    also be equal. That is, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_13.jpg) and:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, you can see that *d*[0] = *r*[0]. Subtracting *r*[0] /2 (which equals
    *d*[0]/2) from both sides of our expanded equation gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we divide both sides by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the same reasoning as earlier, *d*[1] = *r*[1]. We can produce the binary
    representation of a number by working from right to left, repeatedly dividing
    by 2, and using the remainder as the value of the respective bit. This is summarized
    in the following algorithm, where the forward slash (`/`) is the integer division
    operator and the percent sign (`%`) is the modulo operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some programming tasks require a specific bit pattern—for example, programming
    a hardware device. In these cases, specifying a bit pattern rather than a numerical
    value is more natural. We can think of the bits in groups of four and use hexadecimal
    to specify each group. For example, if our algorithm required the use of zeros
    alternating with ones—`0101 0101 0101 0101 0101 0101 0101 0101`—we could convert
    this to the decimal value 431,655,765, or we could express it in hexadecimal as
    `0x55555555` (shown here in C/C++ syntax). Once you’ve memorized [Table 2-1](ch02.xhtml#ch2tab1),
    you’ll find it much easier to work with hexadecimal for bit patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion in these two sections has dealt only with unsigned integers.
    The representation of signed integers depends upon some architectural features
    of the CPU that we’ll discuss in [Chapter 3](ch03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '2.9     Convert the following unsigned decimal integers to their 8-bit hexadecimal
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     100
  prefs: []
  type: TYPE_NORMAL
- en: (b)     123
  prefs: []
  type: TYPE_NORMAL
- en: (c)     10
  prefs: []
  type: TYPE_NORMAL
- en: (d)     88
  prefs: []
  type: TYPE_NORMAL
- en: (e)     255
  prefs: []
  type: TYPE_NORMAL
- en: (f)     16
  prefs: []
  type: TYPE_NORMAL
- en: (g)     32
  prefs: []
  type: TYPE_NORMAL
- en: (h)     128
  prefs: []
  type: TYPE_NORMAL
- en: '2.10     Convert the following unsigned decimal integers to their 16-bit hexadecimal
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     1,024
  prefs: []
  type: TYPE_NORMAL
- en: (b)     1,000
  prefs: []
  type: TYPE_NORMAL
- en: (c)     32,768
  prefs: []
  type: TYPE_NORMAL
- en: (d)     32,767
  prefs: []
  type: TYPE_NORMAL
- en: (e)     256
  prefs: []
  type: TYPE_NORMAL
- en: (f)     65,535
  prefs: []
  type: TYPE_NORMAL
- en: (g)     4,660
  prefs: []
  type: TYPE_NORMAL
- en: (h)     43,981
  prefs: []
  type: TYPE_NORMAL
- en: 2.11     Invent a code that would allow you to store letter grades with plus
    or minus (that is, the grades A, A–, B+, B, B–, . . . , D, D–, F). How many bits
    are required for your code?
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing Data in Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have the language necessary to begin discussing how data is stored in
    computer memory. We’ll start with how memory is organized. There are two general
    kinds of memory used for storing program instructions and data in a computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random-access memory (RAM)**'
  prefs: []
  type: TYPE_NORMAL
- en: Once a bit (switch) is set to either `0` or `1`, it stays in that state until
    the control unit actively changes it or the power is turned off. The control unit
    can both read and change the state of a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The name *random-access memory* is misleading. Here, *random access* means that
    it takes the same amount of time to access any byte in the memory, not that any
    randomness is involved when reading the byte. We contrast RAM with *sequential
    access memory (SAM)*, where the amount of time it takes to access a byte depends
    on its position in some sequence. An example of SAM is magnetic tape, which is
    typically used for backups, where retrieval speed is less important. The length
    of time it takes to access a byte depends on the physical location of the byte
    stored on the tape with respect to the current position of the tape.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only memory (ROM)**'
  prefs: []
  type: TYPE_NORMAL
- en: The control unit can read the state of each bit in ROM but can’t change it.
    You can reprogram some types of ROM with specialized hardware, but the bits remain
    in the new state when the power is turned off. ROM is also called *nonvolatile
    memory (NVM)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Memory Addresses***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each byte in memory has a location, or address, much like the room number in
    an office building. The address of a specific byte never changes. That is, the
    957th byte from the beginning of memory will always be the 957th byte. However,
    the state (content) of each of the bits—`0` or `1`—in any given byte can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Computer scientists typically express the address of each byte in memory in
    hexadecimal, starting the numbering at zero. Thus, we would say that the 957th
    byte is at address `0x3bc` (= 956 in decimal).
  prefs: []
  type: TYPE_NORMAL
- en: The first 16 bytes in memory have the addresses `0`, `1`, `2`, `3`, `4`, `5`,
    `6`, `7`, `8`, `9`, `a`, `b`, `c`, `d`, `e`, and `f`. Using the notation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: we can show the contents of each of the first 16 bytes of memory, as in [Table
    2-3](ch02.xhtml#ch2tab3) (the contents here are arbitrary).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Example Contents of the First 16 Bytes of Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Content** | **Address** | **Content** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000000` | `0x6a` | `0x00000008` | `0xf0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000001` | `0xf0` | `0x00000009` | `0x02` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000002` | `0x5e` | `0x0000000a` | `0x33` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000003` | `0x00` | `0x0000000b` | `0x3c` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000004` | `0xff` | `0x0000000c` | `0xc3` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000005` | `0x51` | `0x0000000d` | `0x3c` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000006` | `0xcf` | `0x0000000e` | `0x55` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000007` | `0x18` | `0x0000000f` | `0xaa` |'
  prefs: []
  type: TYPE_TB
- en: The content of each byte is represented by two hexadecimal digits, which specify
    the exact state of the byte’s 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what can the state of the byte’s 8 bits tell us? There are two issues that
    a programmer needs to consider when storing data in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**How many bits are needed to store the data?**'
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we need to know how many different values are allowed
    for the particular data item. Look at the number of different values we can represent
    in [Table 2-1](ch02.xhtml#ch2tab1) (4 bits) and [Table 2-2](ch02.xhtml#ch2tab2)
    (3 bits). We can represent up to 2*^n* different values in *n* bits. Notice, too,
    that we might not use all the possible bit patterns we have within an allocated
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the code for storing the data?**'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the data we deal with in everyday life is not expressed in terms of
    zeros and ones. To store it in computer memory, the programmer must decide how
    to encode the data in zeros and ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, you’ll see how we can store characters and unsigned
    integers in memory using the state of the bits in one or more bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Characters***'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re programming, you will almost always be manipulating text strings,
    which are arrays of characters. The first program you ever wrote was probably
    a “Hello, World!” program. If you wrote it in C, you used a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When translating either of these statements into machine code, the compiler
    must do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Store each of the characters in a location in memory where the control unit
    can access them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate the machine instructions to write the characters on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by considering how a single character is stored in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding Characters**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The most common standard for encoding characters for computer storage is *Unicode
    UTF-8*. It uses 1 to 4 bytes for storing a number called a *code point*, which
    represents a character. A Unicode code point is written as U+*h*, where *h* is
    four to six hexadecimal digits. The operating system and display hardware associate
    one or more code points with a *glyph*, which is what we see on the screen or
    on paper. For example, U+0041 is the code point for the Latin capital letter *A*,
    which has the glyph A in the font used for this book.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is backward compatible with an older standard, the *American Standard
    Code for Information Interchange*, or *ASCII* (pronounced “ask-ee”). ASCII uses
    7 bits to specify each code point in a 128-character set, which contains the English
    alphabet (uppercase and lowercase), numerals, special characters, and control
    characters. In all of our programming in this book, we will use only the characters
    from the ASCII subset of UTF-8, U+0000 to U+007F.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-4](ch02.xhtml#ch2tab4) shows the Unicode code points for the characters
    used to represent hexadecimal numbers and the corresponding 8-bit patterns that
    are stored in memory in our programming environment. You will have a chance to
    put this table to use later in the book, when you learn how to convert from the
    character representation of an integer to its binary representation. For now,
    notice that while the numeric characters are organized in a contiguous bit pattern
    sequence, there is a gap between them and the alphabetic characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** Some UTF-8 Code Points for Hexadecimal Characters'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code point** | **Character description** | **Character glyph** | **Bit
    pattern** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| U+0030 | Digit zero | `0` | `0x30` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0031 | Digit one | `1` | `0x31` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0032 | Digit two | `2` | `0x32` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0033 | Digit three | `3` | `0x33` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0034 | Digit four | `4` | `0x34` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0035 | Digit five | `5` | `0x35` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0036 | Digit six | `6` | `0x36` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0037 | Digit seven | `7` | `0x37` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0038 | Digit eight | `8` | `0x38` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0039 | Digit nine | `9` | `0x39` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0061 | Latin small letter a | `a` | `0x61` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0062 | Latin small letter b | `b` | `0x62` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0063 | Latin small letter c | `c` | `0x63` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0064 | Latin small letter d | `d` | `0x64` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0065 | Latin small letter e | `e` | `0x65` |'
  prefs: []
  type: TYPE_TB
- en: '| U+0066 | Latin small letter f | `f` | `0x66` |'
  prefs: []
  type: TYPE_TB
- en: Although the hexadecimal numerical portion is the same as the bit pattern for
    the code points U+0000 to U+007F, this does not necessarily hold true for other
    characters. For example, U+00B5 is the code point for the micro sign, which is
    stored in memory as the 16-bit pattern `0xc2b5` and has the glyph *µ* in the font
    used for this book.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 uses 1 byte per character to store code points U+0000 to U+007F. Bits
    6 and 5 in the byte (recall that bits are numbered from right to left, starting
    with 0) specify the four groups of characters, shown in [Table 2-5](ch02.xhtml#ch2tab5).
    The special characters are mostly punctuation. For example, the space character
    is U+0020 and the semicolon character (;) is U+003B.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-5:** The Character Groups in Code Points U+0000 to U+007F'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit 6** | **Bit 5** | **Type of character** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | Control |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | Numeric and special |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | Uppercase alphabetic and special |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | Lowercase alphabetic and special |'
  prefs: []
  type: TYPE_TB
- en: You can generate a table of the code points that coincide with ASCII characters
    by typing the command man ascii in a Linux terminal window. (You may need to install
    the `ascii` program on your computer.) It is quite large and not the sort of thing
    you would want to memorize, but it can be helpful to understand roughly how it’s
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Unicode at *[https://www.unicode.org/releases/](https://www.unicode.org/releases/)*.
    For a more informal discussion of how Unicode came to be, I recommend Joel Spolsky’s
    “The Absolute Minimum Every Software Developer Absolutely, Positively Must Know
    About Unicode and Character Sets (No Excuses!)” at *[https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 2.12     Many people use uppercase for the alphabetic hexadecimal characters.
    Every programming language I know about accepts either case. Redo [Table 2-4](ch02.xhtml#ch2tab4)
    using the bit patterns for the uppercase hexadecimal characters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.13     Create an ASCII table for the lowercase alphabetic characters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.14     Create an ASCII table for the uppercase alphabetic characters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.15     Create an ASCII table for the punctuation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing a Text String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Getting back to `Hello, World!\n`, the compiler stores this text string as
    a constant array of characters. To specify the extent of this array, a C-style
    string uses the code point U+0000 (ASCII `NUL`) at the end of the string as a
    *sentinel* value, which is a unique value that indicates the end of a sequence
    of characters. Thus, the compiler must allocate 15 bytes for this string: 13 for
    `Hello, World!`, 1 for the newline `\n`, and 1 for the `NUL`. [Table 2-6](ch02.xhtml#ch2tab6)
    shows how this text string would be stored starting at location `0x4004a1` in
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-6:** `Hello, World!\n` Stored in Memory'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Content** | **Address** | **Content** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a1` | `0x48` | `0x4004a9` | `0x6f` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a2` | `0x65` | `0x4004aa` | `0x72` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a3` | `0x6c` | `0x4004ab` | `0x6c` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a4` | `0x6c` | `0x4004ac` | `0x64` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a5` | `0x6f` | `0x4004ad` | `0x21` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a6` | `0x2c` | `0x4004ae` | `0x0a` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a7` | `0x20` | `0x4004af` | `0x00` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a8` | `0x57` | — | — |'
  prefs: []
  type: TYPE_TB
- en: C uses U+000A (ASCII `LF`) as a newline character (at address `0x4004ae` in
    this example), even though the C syntax requires that the programmer write two
    characters, `\n`. The text string ends with the `NUL` character at `0x4004af`.
  prefs: []
  type: TYPE_NORMAL
- en: In Pascal, another programming language, the length of a string is specified
    by the first byte in the string, which is taken to be an 8-bit unsigned integer.
    (This is the reason for the 256-character limit on text strings in Pascal.) The
    C++ string class has additional features, but the actual text string is stored
    as a C-style text string within the C++ string instance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unsigned Integers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since an unsigned integer can be expressed in any radix, probably the most obvious
    way to store it is to use the binary number system. If we number the bits in a
    byte from right to left, then the lowest-order bit would be stored in bit 0, the
    next in bit 1, and so forth. For example, the integer 123[10] = `7b`[16], so the
    state of the byte where it is stored would be `01111011`[2]. Using only a single
    byte restricts the range of unsigned integers to be from 0 to 255[10], since `ff`[16]
    = 255[10]. The default size for an unsigned integer in our programming environment
    is 4 bytes, which allows for a range of 0 to 4,294,967,295[10].
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of using the binary number system is that you need to convert
    a decimal number from a character string to the binary number system before performing
    arithmetic operations on it. For example, the decimal number 123 would be stored
    in character string format as the four bytes `0x31`, `0x32`, `0x33`, and `0x00`,
    while in unsigned integer format, it would be stored as the 4-byte binary number
    `0x0000007b`. At the other end, binary numbers need to be converted to their decimal
    character representations for most real-world display purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary coded decimal (BCD)* is another code for storing integers. It uses
    4 bits for each decimal digit, as shown in [Table 2-7](ch02.xhtml#ch2tab7).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-7:** Binary Coded Decimal'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal digit** | **BCD code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `0000` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `0001` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `0010` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `0011` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `0100` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `0101` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `0110` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `0111` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `1001` |'
  prefs: []
  type: TYPE_TB
- en: For example, in a 16-bit storage location, the decimal number 1,234 would be
    stored in BCD as `0001 0010 0011 0100` (in the binary number system, it would
    be `0000 0100 1101 0010`).
  prefs: []
  type: TYPE_NORMAL
- en: With only 10 of the possible 16 combinations being used, six bit patterns are
    wasted. This means that a 16-bit storage location has a range of 0 to 9,999 for
    values if we use BCD, compared to a range of 0 to 65,535 if we use binary. This
    is a less efficient use of memory. On the other hand, the conversions between
    a character format and an integer format are simpler with BCD, as you will learn
    in [Chapter 16](ch16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: BCD is important in specialized systems that deal primarily with numerical business
    data, because they tend to print numbers more often than they perform mathematical
    operations on them. COBOL, a programming language intended for business applications,
    supports a packed BCD format where two digits (in BCD code) are stored in each
    8-bit byte. Here, the *last* (4-bit) digit is used to store the sign of the number,
    as shown in [Table 2-8](ch02.xhtml#ch2tab8). The specific codes used depend upon
    the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-8:** Example Sign Codes for Packed BCD Format'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sign** | **Sign code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| + | `1010` |'
  prefs: []
  type: TYPE_TB
- en: '| – | `1011` |'
  prefs: []
  type: TYPE_TB
- en: '| + | `1100` |'
  prefs: []
  type: TYPE_TB
- en: '| – | `1101` |'
  prefs: []
  type: TYPE_TB
- en: '| + | `1110` |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned | `1111` |'
  prefs: []
  type: TYPE_TB
- en: For example, `0001 0010 0011 1010` represents +123, `0001 0010 0011 1011` represents
    –123, and `0001 0010 0011 1111` represents 123.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore some of these concepts using the C programming language.
    If you’re new to C, this discussion will provide an introduction to the language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Data Formats with C**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll write our first programs with the C programming language.
    These particular programs illustrate the differences between how numbers are stored
    in memory and how we humans read them. C allows us to get close enough to the
    hardware to understand the core concepts, while taking care of many of the low-level
    details. You shouldn’t find the simple C programs in this book too difficult,
    especially if you already know how to program in another language.
  prefs: []
  type: TYPE_NORMAL
- en: If you learned how to program in a higher-level language, such as C++, Java,
    or Python, you probably learned object-oriented programming. C doesn’t support
    the object-oriented paradigm; it is a *procedural* programming language. C programs
    are divided into *functions*, where a function is a named group of programming
    statements. Other programming languages also use the terms *procedure* and *subprogram*,
    with some minor distinctions between them depending on the language.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using C and C++ I/O Libraries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most high-level programming languages include a standard library that can be
    thought of as part of the language. A *standard library* contains functions and
    data structures that can be used in the language for doing common things such
    as terminal I/O (writing to the screen and reading from the keyboard). C includes
    the *C standard library* and C++ includes the *C++ standard library*.
  prefs: []
  type: TYPE_NORMAL
- en: 'C programmers use functions in the `stdio` library for terminal I/O, while
    C++ programmers use functions in the `iostream` library. For example, the C code
    sequence for reading an integer from the keyboard, adding 100 to it, and writing
    the result to the screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ code sequence looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, the code reads characters (each as a separate `char`) from
    the keyboard and converts the `char` sequence into the corresponding `int` format.
    Then, it adds 100 to the `int` before converting the result into a `char` sequence
    and displaying it on the screen. The C or C++ I/O library functions in the previous
    code snippets do the necessary conversions between `char` sequences and the `int`
    storage format.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) shows the relationship between a C application
    program, the I/O libraries, and the operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg52_Image_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The relationship of I/O libraries to the application and the operating
    system*'
  prefs: []
  type: TYPE_NORMAL
- en: When reading from the keyboard, the `scanf` library function first calls the
    `read` *system call* function, a function in the operating system, to read characters
    from the keyboard. The input on the keyboard is in the form of a string of characters,
    each of the `char` data type. The `scanf` library function performs the conversion
    of this string to the `int` data type for the application program. The `printf`
    library function converts from the `int` data type to the corresponding string
    of characters in the `char` data type and calls the `write` system call function
    to write each character to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-1](ch02.xhtml#ch2fig1), an application program can call the `read`
    and `write` functions directly to transfer characters. We’ll explore this in [Chapter
    16](ch16.xhtml), where we’ll write our own conversion functions. Although the
    C/C++ library functions do a much better job of this than we will, the exercise
    of doing it yourself will give you a better understanding of how data is stored
    in memory and manipulated by software.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even if you’re familiar with the GNU* make *program, it’s worth learning how
    to use it to build your programs. It may seem like overkill at this point, but
    it’s much easier to learn with simple programs. The manual is available in several
    formats at* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)*,
    and my comments about using it are available on my website at* [https://rgplantz.github.io](https://rgplantz.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing and Executing Your First C Program***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most programming books start with a simple program that just prints “Hello,
    World!” to a computer screen, but we’ll start with a program that reads a hexadecimal
    value, both as an unsigned integer and as a text string ([Listing 2-1](ch02.xhtml#ch2list1)).
  prefs: []
  type: TYPE_NORMAL
- en: '*int_and_string.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: A program showing the difference between an integer and a text
    string*'
  prefs: []
  type: TYPE_NORMAL
- en: We start our code with some documentation that gives a brief description of
    what the program does ❶. When writing your own source files, you should also include
    your name and the date they were written as part of the documentation (I’ve omitted
    them in the example programs in this book to save space). All text following two
    slash characters, `//`, on a line is a comment. C also allows us to start a multiple-line
    comment using `/*` and end it using `*/`. Comments are for the human reader and
    have no effect on the program itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first operation that actually affects the program is the inclusion of a
    *header file*, *stdio.h* ❷, using the `#include` directive. As you will learn,
    the C compiler needs to know the type of each data item that is passed to or from
    a function. A header file is used to provide a *prototype statement* for each
    function, which specifies these data types. The *stdio.h* header file defines
    the interface to many of the functions in the C standard library, which tells
    the compiler what to do when calls to any of these functions are encountered in
    our source code. The *stdio.h* header file is already installed on your computer
    in a location the compiler knows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code in this listing is the definition of a C `main` function.
    All C programs are made up of functions, which have this general format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When a C program is executed, the operating system first sets up either a *hosted
    environment* or a *freestanding environment*, which sets up the resources on your
    computer to run the program. The hosted environment includes access to the functions
    in the C standard library, while the freestanding environment does not. Most of
    the programs in this book run in the hosted environment. I’ll show you how to
    use the freestanding environment in “Supervisor Calls” on [page 474](ch21.xhtml#ch21lev1sec5)
    in [Chapter 21](ch21.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In the C hosted environment, program execution starts with the `main` function,
    meaning that the program you write must include a function whose function name
    is `main`. The `main` function can call other functions, which in turn can call
    other functions. But program control normally ends up back in the `main` function,
    which then returns to the C hosted environment.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is called in C, the calling function can include a list of *arguments*
    in the call as inputs to the called function. These inputs serve as *parameters*
    in the computation performed by the called function. For example, in [Listing
    2-1](ch02.xhtml#ch2list1), when the program first starts, the `main` function
    calls the `printf` function with one argument, a text string ❹. The `printf` function
    uses the text string to determine what to display on the screen. We’ll look closely
    at how arguments are passed to functions and how they’re used as parameters in
    the function in [Chapter 14](ch14.xhtml). The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    does not need any data from the C hosted environment; we show this in its definition
    by using `void` for the parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completing execution, a function normally returns to the calling function.
    The called function can pass a data item to the calling function when returning.
    A `main` function should return a single integer to the C hosted environment,
    indicating whether the program detected any errors in its execution. Thus, the
    return-data-type for `main` is `int`. The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    returns the integer 0 to the C hosted environment, which passes this value to
    the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 2-1](ch02.xhtml#ch2list1), we define two variables in the `main`
    function at the beginning of the function body: an unsigned integer named `an_int`
    and a text string named `a_string` ❸. Most modern programming languages allow
    us to introduce new variables anywhere in the code, but C requires that they be
    listed at the beginning of the function. (There are some exceptions to this rule,
    but they are beyond the scope of this book.) Think of it as listing the ingredients
    for a recipe before giving the instructions on how to use them. We *define* a
    variable by introducing its name and specifying its data type. The `[10]` notation
    tells the compiler to allocate an array of 10 `char`s for the `a_string` variable,
    which will allow us to store a C-style text string up to nine characters long.
    (The 10th `char` would be the terminating `NUL` character.) We’ll look at arrays
    in detail in [Chapter 17](ch17.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: The program uses the `printf` function from the C standard library to display
    text on the screen. The first argument in the call to `printf` is a *format string*,
    which is a text string made up of ordinary characters (except `%`) to display
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest format string for `printf` is just the text you want printed, without
    any variables. If you want to print the values of variables, the format string
    acts as a template of the text you want printed. The place in the text string
    where you want the value of a variable to be printed is marked with a *conversion
    specifier*. Each conversion specifier begins with the `%` character, and the names
    of the variables are listed after the format string in the same order that their
    respective conversion specifiers appear in the template ❼.
  prefs: []
  type: TYPE_NORMAL
- en: The `%` character that begins a conversion specifier is immediately followed
    by one or more conversion code characters to tell `printf` how to display the
    value of the variable. [Table 2-9](ch02.xhtml#ch2tab9) shows some common conversion
    specifiers for `printf` and `scanf` format strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-9:** Some Common Conversion Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conversion specifier** | **Representation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%u` | Unsigned decimal integer |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` or `%i` | Signed decimal integer |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Float |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Hexadecimal |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Text string |'
  prefs: []
  type: TYPE_TB
- en: The conversion specifiers can include other characters that specify properties,
    such as the field width of the display, whether the value is left-or right-justified
    within the field, and more. I won’t go into additional detail here; read man [page
    3](ch01.xhtml#page_3) for `printf` to learn more (enter the man 3 printf command
    to view the man page).
  prefs: []
  type: TYPE_NORMAL
- en: The first argument in the call to the C standard library function `scanf` is
    also a format string. We use the same conversion specifiers in the format string
    to tell the `scanf` function how to interpret the characters typed on the keyboard
    ❺. We tell `scanf` where to store the input integer by using the *address of*
    operator on the variable name, `&an_int`. When passing the name of an array to
    a function, C sends the address of the array, so we don’t use the `&` operator
    when calling `scanf` to read a text string from the keyboard ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Any other character included in the format string for `scanf` besides these
    conversion specifiers must be matched exactly by the keyboard input. For example,
    the format string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: requires an input like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: which would read the integers 123 and 456 from the keyboard. You can read man
    [page 3](ch01.xhtml#page_3) for `scanf` to learn more (enter the man 3 scanf command).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `main` function returns 0 to the C hosted environment, which passes
    this value to the operating system. The value 0 tells the operating system that
    everything went smoothly ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling and running the program in [Listing 2-1](ch02.xhtml#ch2list1) on
    my computer gave the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The program in [Listing 2-1](ch02.xhtml#ch2list1) demonstrates an important
    concept: hexadecimal is used as a human convenience for stating bit patterns.
    A number is not inherently binary, decimal, or hexadecimal; it’s simply a value.
    And a specific value can be expressed equivalently in each of these three number
    bases. For that matter, it can be expressed equivalently in *any* number base
    (2, 16, 285, and so forth), but since a computer consists of binary switches,
    it makes sense to think of numerical values stored in a computer in terms of the
    binary number base.'
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '2.16     Write a hexadecimal-to-decimal converter program in C. Your program
    will allow a user to enter a number in hexadecimal and will then print the decimal
    equivalent. The output should look like this: `0x7b = 123`.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.17     Write a decimal-to-hexadecimal converter program in C. Your program
    will allow a user to enter a number in decimal and will then print the hexadecimal
    equivalent. The output should look like this: `123 = 0x7b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.18     Change `%u` to `%i` in the last `printf` statement in the program in
    [Listing 2-1](ch02.xhtml#ch2list1). What does the program print if you enter `ffffffff`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining Memory with a Debugger**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve started writing programs, you’ll need to learn how to use the
    GNU debugger, `gdb`. A *debugger* is a program that allows you to run your program
    while you observe and control its behavior. When you use a debugger, it’s a little
    like you’re a puppeteer and your program is a carefully controlled puppet. Your
    main instrument of control is the *breakpoint*; when you set a breakpoint and
    your program reaches it while running, the program will pause and return control
    to the debugger. When control is with the debugger, you can look at the values
    stored in your program’s variables, which can help you figure out where any bugs
    are.
  prefs: []
  type: TYPE_NORMAL
- en: If all this seems premature—our programs so far are simple and don’t seem to
    require debugging—I promise that it’s much better to learn how to use a debugger
    on a simple example than on a complicated program that does not work. `gdb` is
    also a valuable tool for learning the material in this book, even when you write
    bug-free programs. In the following `gdb` session dialog, I’ll show you how to
    determine where a variable is stored in memory and how to see what is stored there,
    both in decimal and in hexadecimal. You will see how to use `gdb` on a live program
    to illustrate the concepts discussed on the previous pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see more in [Chapters 9](ch09.xhtml) and [10](ch10.xhtml), but the `gdb`
    commands listed here should be enough to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: b source_filename:line_number   Set a breakpoint at the specified line_number
    in the source file, source_filename. The code will stop running at the breakpoint,
    when line_number is encountered, and return control to `gdb`, allowing you to
    test various elements of the code.
  prefs: []
  type: TYPE_NORMAL
- en: c   Continue program execution from the current location.
  prefs: []
  type: TYPE_NORMAL
- en: h command   Get help on how to use command.
  prefs: []
  type: TYPE_NORMAL
- en: i r   Show the contents of the registers (*info registers*). (You’ll learn about
    CPU registers in [Chapter 9](ch09.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: l line_number   List 10 lines of the source code, centered at the specified
    line_number.
  prefs: []
  type: TYPE_NORMAL
- en: print expression   Evaluate expression and print the value.
  prefs: []
  type: TYPE_NORMAL
- en: printf "format", var1, var2, ..., varn   Display the values of var1`,` var2`,
    ...,` varn in a given format. The `"`format `"` string follows the same rules
    as for `printf` in the C standard library.
  prefs: []
  type: TYPE_NORMAL
- en: r   Run a program that has been loaded under the control of `gdb`.
  prefs: []
  type: TYPE_NORMAL
- en: x/nfs memory_address   Display (examine) n values in memory in format f of size
    s starting at memory_address.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Your Debugger***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s walk through the program in [Listing 2-1](ch02.xhtml#ch2list1) using `gdb`
    to explore some of the concepts covered thus far. Follow along on your computer
    as you read this; it’s much easier to understand `gdb` when you’re using it. Note
    that the addresses you see on your computer will probably be different than those
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by compiling the program using the `gcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `-g` option tells the compiler to include debugger information in the executable
    program. The `-Wall` option tells the compiler to issue warnings about things
    in your code that are correct C code but still might not be what you intended
    to write. For example, it will warn you about declaring a variable in your function
    that is never used, which could mean you’ve forgotten something.
  prefs: []
  type: TYPE_NORMAL
- en: The `-o` option specifies the name of the output file, which is the executable
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having compiled the program, I can run it under the control of `gdb` using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `gdb` startup message, which I’ve removed from the previous output to save
    space, contains information about your debugger and refers you to its usage documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The `l` command lists 10 lines of source code and then returns control to the
    `gdb` program, as shown by the `(gdb)` prompt. Press ENTER to repeat the previous
    command, and `l` displays the next (up to) 10 lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'A breakpoint is used to stop the program and return control to the debugger.
    I like to set breakpoints where a function is about to call another function so
    I can examine the values in the argument variables before they are passed to the
    called function. This `main` function calls `printf` on line 15, so I set a breakpoint
    there. Since I’m already looking at the source code where I want to set a breakpoint,
    I don’t need to specify the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If `gdb` ever gets to this statement while executing the program, it will pause
    *before the statement is executed* and return control to the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having set my breakpoint, I run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `r` command starts executing the program from the beginning. When the program
    reaches the breakpoint, control returns to `gdb`, which displays the next program
    statement that is ready to be executed. Before continuing execution, I display
    the contents of the two variables that are being passed to the `printf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `print` command to display the value currently stored in a variable.
    `gdb` knows the data type of each variable from the source code. It displays `int`
    variables in decimal. When displaying `char` variables, `gdb` will do its best
    to display the character glyph corresponding to the code point value. When there
    is no corresponding character glyph, `gdb` shows the code point as a `\` followed
    by three *octal* digits (see [Table 2-2](ch02.xhtml#ch2tab2)). For example, there
    is no character glyph for `NUL`, so `gdb` shows `\000` at the end of the text
    string I entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printf` command can format the displayed values. The formatting string
    is the same as for the `printf` function in the C standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`gdb` provides another command, `x`, for examining the content of memory (that
    is, the actual bit patterns) directly. Its help message is brief, but it tells
    you everything you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `x` command needs the address of the area of memory to show. We can use
    the `print` command to find the address of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `x` command to display the content of `an_int` in three different
    ways—one decimal word (`1dw`), one hexadecimal word (`1xw`), and four hexadecimal
    bytes (`4xb`)—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The size of a* word *depends upon the computer environment you are using.
    In our environment, it’s 4 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: The display of these four bytes may look out of order to you. The first byte
    ❶ is located at the address shown on the left of the row. The next byte in the
    row is at the subsequent address, `0x7fffffef7d`. So, this row displays each of
    the bytes stored at the memory addresses `0x7fffffef7c`, `0x7fffffef7d`, `0x7fffffef7e`,
    and `0x7fffffef7f`, reading from left to right, that make up the variable `an_int`.
    When displaying these same four bytes separately, the least significant byte appears
    *first* in memory. This is called *little-endian* storage order; I’ll explain
    further after this tour of `gdb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also display the content of the `a_string` variable by first getting
    its address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll look at the content of `a_string` in two ways, as 10 characters
    (`10c`) and as 10 hexadecimal bytes (`10xb`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The character display shows the code point in decimal and the character glyph
    for each character. The hexadecimal byte display shows only the code point in
    hexadecimal for each byte. Both displays show the `NUL` character that marks the
    end of the six-character string we entered. Since we asked for a 10-byte display,
    the remaining 3 bytes have random values not related to our text string, often
    called *garbage values*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I continue execution of the program and then quit `gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '***Understanding Byte Storage Order in Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The difference between the full 4-byte display and the 1-byte display of the
    integer value at `0x7fffffef7c` in memory illustrates a concept known as *endianness*,
    or byte storage order. We usually read numbers from left to right. The digits
    to the left have more significance (count for more) than the digits to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '##### **Little-Endian**'
  prefs: []
  type: TYPE_NORMAL
- en: Data is stored in memory with the *least* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “littlest” byte (counts the
    least) comes first in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we examine memory one byte at a time, each byte is displayed in numerically
    ascending addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, the value appears to be stored backward, because the least
    significant (“little end”) byte of the value is stored first in memory. When we
    command `gdb` to display the entire 4-byte value, it knows that ours is a little-endian
    environment, and it rearranges the display of the bytes in the proper order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Big-Endian**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Data is stored in memory with the *most* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “biggest” byte (counts the
    most) comes first in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran the previous program on a big-endian computer, such as one using
    the PowerPC architecture, we would see the following (assuming the variable is
    located at the same address):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the 4 bytes in a big-endian computer would be stored as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Again, `gdb` would know that this is a big-endian computer and so would display
    the full 4-byte value in the proper order.
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of programming situations, endianness is not an issue.
    However, you need to know about it because it can be confusing when examining
    memory in the debugger. Endianness is also an issue when different computers communicate
    with each other. For example, *Transport Control Protocol/Internet Protocol (TCP/IP)*
    is defined to be big-endian, sometimes called *network byte order*. The instructions
    in the AArch64 architecture are stored in little-endian order. The data can be
    stored in either order, but the default in our environment is little-endian, and
    the operating system reorders the bytes for internet communication. You also need
    to know about byte order if you’re writing communications software for an operating
    system itself or for an embedded system that may not have an operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 2.19     Enter the program in [Listing 2-1](ch02.xhtml#ch2list1). Follow through
    the program with `gdb`. Using the numbers you get, explain where the variables
    `an_int` and `a_string` are stored in memory and what is stored in each location.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bits**   A computer is a collection of on/off switches that we can represent
    with bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   This is a number system based on 16\. Each hexadecimal digit,
    `0` to `f`, represents 4 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte**   This is a group of 8 bits. The bit pattern can be expressed as two
    hexadecimal digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting between decimal and binary**   The two number systems are mathematically
    equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory addressing**   Bytes in memory are numbered (addressed) sequentially.
    The byte’s address is usually expressed in hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endianness**   An integer that is more than 1 byte can be stored with the
    highest-order byte in the lowest byte address (big-endian) or with the lowest-order
    byte in the lowest byte address (little-endian). Our environment is little-endian.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-8 encoding**   This is a code for storing characters in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**   A C-style string is an array of characters terminated by the `NUL`
    character.'
  prefs: []
  type: TYPE_NORMAL
- en: printf   This C library function is used to write formatted data on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: scanf   This C library function is used to read formatted data from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**   The `gdb` debugger can be used to see how the variables change
    at each step in the execution of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about addition and subtraction in the binary
    number system for both unsigned and signed integers. This will illuminate some
    of the potential errors inherent in using a fixed number of bits to represent
    numerical values.
  prefs: []
  type: TYPE_NORMAL
