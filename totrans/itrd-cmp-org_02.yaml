- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: DATA STORAGE FORMATS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储格式**
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: 'You may be used to thinking of computers as hardware devices for storing collections
    of programs, files, and graphics. In this book, we’ll look at computers in a different
    way: as billions of two-state switches and one or more *control units*—devices
    that can both detect and change the states of the switches.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯于将计算机视为用于存储程序、文件和图形的硬件设备。在本书中，我们将以不同的方式看待计算机：它们是由数十亿个双态开关和一个或多个*控制单元*——这些设备能够检测并改变开关的状态。
- en: In [Chapter 1](ch01.xhtml), we discussed communicating with the world outside
    the computer using input and output. In this chapter, we’ll begin exploring how
    computers encode data for storage in memory, and we’ll write some programs in
    C that explore these concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们讨论了如何通过输入和输出与计算机外部的世界进行通信。在本章中，我们将开始探索计算机如何对数据进行编码以便存储在内存中，并且我们将编写一些C语言程序来探讨这些概念。
- en: '**Switches and Groups of Switches**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开关与开关组**'
- en: Whatever you’re doing on your computer—streaming a video, posting on social
    media, writing a program—it’s done by combinations of two-state switches interacting
    with each other. Each combination of switches represents a possible state the
    computer can be in. If you wanted to describe what was happening on your computer,
    you could list a combination of switches. In plain English, this would be something
    like “The first switch is on, the second one is also on, but the third is off,
    while the fourth is on.” But describing the computer this way would be difficult,
    because modern computers use billions of switches. Instead, we use a more concise,
    numeric notation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在计算机上做什么——播放视频、发布社交媒体动态、编写程序——都是通过双态开关之间的组合相互作用来完成的。每一种开关组合都表示计算机可能处于的一个状态。如果你想描述计算机上发生的事情，你可以列出一个开关组合。用简单的英语表达，这就像是“第一个开关打开，第二个开关也打开，但第三个开关关闭，而第四个开关打开。”但是以这种方式描述计算机是很困难的，因为现代计算机使用的是数十亿个开关。相反，我们使用一种更简洁的数字表示法。
- en: '***Representing Switches with Bits***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用位表示开关***'
- en: You’re probably familiar with the *decimal system*, which uses the digits 0
    to 9 to write numbers. We want to represent switches numerically, but our switches
    have only 2 states, not 10\. Here, the *binary system*—a two-digit system that
    uses `0`s and `1`s—is useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉*十进制系统*，它使用数字0到9来书写数字。我们希望用数字表示开关，但我们的开关只有2种状态，而不是10种。在这里，*二进制系统*——一种使用`0`和`1`的二位系统——就显得非常有用了。
- en: 'We’ll use a *binary digit*, commonly shortened to *bit*, to represent the state
    of a switch. A bit can have two values: `0`, which represents that a switch is
    “off,” and `1`, which represents that a switch is “on.” If we wanted, we could
    assign the opposite values to these digits; all that matters is that we’re consistent.
    Let’s use bits to simplify our statement about switches: we have a computer in
    which the first, second, and fourth switches are on and the third is off. In binary,
    we would represent this as `1101`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*二进制数字*，通常简称为*位*，来表示开关的状态。一个位可以有两个值：`0`，表示开关是“关闭”的，和`1`，表示开关是“打开”的。如果我们愿意，也可以将这些数字的值反过来分配；重要的是我们要保持一致。让我们使用位来简化关于开关的描述：我们有一台计算机，其中第一个、第二个和第四个开关是打开的，第三个开关是关闭的。用二进制表示就是`1101`。
- en: '***Representing Groups of Bits***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示位组***'
- en: Even with binary, sometimes we have so many bits that the number is un-readable.
    In those cases, we use *hexadecimal digits* to specify bit patterns. The hexadecimal
    system has 16 digits, each of which can represent one group of 4 bits. [Table
    2-1](ch02.xhtml#ch2tab1) shows all 16 possible combinations of 4 bits and the
    corresponding hexadecimal digit for each combination. After using hexadecimal
    for a while, you will probably memorize this table, but if you forget it, an online
    search will quickly bring up a hexadecimal-to-binary converter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是二进制，有时我们也会有很多位，导致数字变得难以阅读。在这种情况下，我们使用*十六进制数字*来表示位模式。十六进制系统有16个数字，每个数字可以表示一组4个位。[表2-1](ch02.xhtml#ch2tab1)显示了4位的所有16种可能组合及其对应的十六进制数字。使用十六进制一段时间后，你可能会记住这个表格，但如果忘记了，网上搜索一个十六进制转二进制的转换器会很方便。
- en: '**Table 2-1:** The Hexadecimal Representation of 4 Bits'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 4位的十六进制表示'
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **一个十六进制数字** | **四个二进制数字（位）** |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | `0000` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0000` |'
- en: '| `1` | `0001` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0001` |'
- en: '| `2` | `0010` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0010` |'
- en: '| `3` | `0011` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0011` |'
- en: '| `4` | `0100` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `0100` |'
- en: '| `5` | `0101` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `0101` |'
- en: '| `6` | `0110` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `0110` |'
- en: '| `7` | `0111` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `0111` |'
- en: '| `8` | `1000` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `1000` |'
- en: '| `9` | `1001` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `9` | `1001` |'
- en: '| `a` | `1010` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `1010` |'
- en: '| `b` | `1011` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `b` | `1011` |'
- en: '| `c` | `1100` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `1100` |'
- en: '| `d` | `1101` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `1101` |'
- en: '| `e` | `1110` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `e` | `1110` |'
- en: '| `f` | `1111` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `f` | `1111` |'
- en: 'Using hexadecimal, we can write `1101`, or “on, on, off, on,” with a single
    digit: `d`[16] = `1101`[2].'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制表示时，我们可以用一个数字表示`1101`，即“开，开，关，开”——`d`[16] = `1101`[2]。
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When it isn’t clear from the context, I will indicate the base of a number
    in this text with a subscript. For example, 100[10] is in decimal,* 100*[16] is
    in hexadecimal, and* 100*[2] is in binary.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*当上下文不清晰时，我会在本文中使用下标来表示数字的进制。例如，100[10]表示十进制，100*[16]表示十六进制，100*[2]表示二进制。*'
- en: The *octal* system, based on the number 8, is less common, but you will encounter
    it occasionally. The eight octal digits span from `0` to `7`, and each digit represents
    a group of 3 bits. [Table 2-2](ch02.xhtml#ch2tab2) shows the correspondence between
    each possible group of 3 bits and its corresponding single octal digit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*八进制*系统基于数字8，虽然不常见，但你偶尔会遇到它。八个八进制数字从`0`到`7`，每个数字代表一组三个比特。[表2-2](ch02.xhtml#ch2tab2)展示了每组三个比特与其对应的单个八进制数字之间的关系。'
- en: '**Table 2-2:** The Octal Representation of 3 Bits'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** 3比特的八进制表示'
- en: '| **One octal digit** | **Three binary digits (bits)** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **一个八进制数字** | **三个二进制数字（比特）** |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | `000` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `000` |'
- en: '| `1` | `001` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `001` |'
- en: '| `2` | `010` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `010` |'
- en: '| `3` | `011` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `011` |'
- en: '| `4` | `100` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `100` |'
- en: '| `5` | `101` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `101` |'
- en: '| `6` | `110` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `110` |'
- en: '| `7` | `111` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `111` |'
- en: For example, the 4-bit example we’re using, `1101`[2], would be written `15`[8]
    in octal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用的4比特示例`1101`[2]，在八进制中表示为`15`[8]。
- en: '***Using Hexadecimal Digits***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用十六进制数字***'
- en: 'Hexadecimal digits are especially convenient when we need to specify the state
    of a group of, say, 16 or 32 switches. In place of each group of 4 bits, we can
    write one hexadecimal digit. For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数字在需要指定一组开关状态时特别方便，比如16个或32个开关。每四个比特位可以用一个十六进制数字来表示。例如：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A single bit is rarely useful for storing data. The smallest number of bits
    that can be accessed at a time in a computer is defined as a *byte*. In most modern
    computers, a byte consists of 8 bits, but there are exceptions to the 8-bit byte.
    For example, the CDC 6000 series of scientific mainframe computers used a 6-bit
    byte.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单一比特位通常无法用于存储数据。计算机中一次可以访问的最小比特数被定义为*字节*。在大多数现代计算机中，一个字节由8个比特组成，但也有例外。例如，CDC
    6000系列科学主机计算机使用的是6位字节。
- en: 'In the C and C++ programming languages, prefixing a number with `0x`—that’s
    a zero and a lowercase *x*—specifies that the number is expressed in hexadecimal.
    Prefixing a number with only a `0` specifies octal representation. C++ allows
    us to specify a value in binary by prefixing the number with `0b`. Although the
    `0b` notation for specifying binary is not part of standard C, our compiler, `gcc`,
    allows it. Thus, when we write C or C++ code in this book, these all mean the
    same thing:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C和C++编程语言中，数字前加`0x`——即零和小写字母*x*——表示该数字是以十六进制表示的。若数字前仅加`0`，则表示八进制表示。C++允许通过在数字前加`0b`来指定二进制值。虽然`0b`表示二进制的语法不是C标准的一部分，但我们的编译器`gcc`支持这一语法。因此，当我们在本书中编写C或C++代码时，这些都表示相同的含义：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you’re using a different C compiler, you may not be able to use the `0b`
    syntax to specify binary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不同的C编译器，可能无法使用`0b`语法来指定二进制。
- en: '**YOUR TURN**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: '2.1     Express the following bit patterns in hexadecimal:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1     将以下比特模式转换为十六进制：
- en: (a)     `0100 0101 0110 0111`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `0100 0101 0110 0111`
- en: (b)     `1000 1001 1010 1011`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `1000 1001 1010 1011`
- en: (c)     `1111 1110 1101 1100`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 1110 1101 1100`
- en: (d)     `0000 0010 0101 0010`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 0010 0101 0010`
- en: '2.2     Express the following hexadecimal patterns in binary:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2     将以下十六进制模式转换为二进制：
- en: (a)     `83af`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `83af`
- en: (b)     `9001`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `9001`
- en: (c)     `aaaa`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `aaaa`
- en: (d)     `5555`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `5555`
- en: 2.3     How many bits are represented by each of the following?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3     以下每个表示多少比特？
- en: (a)     `ffffffff`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `ffffffff`
- en: (b)     `7fff58b7def0`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `7fff58b7def0`
- en: (c)     `1111`[2]
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111`[2]
- en: (d)     `1111`[16]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `1111`[16]
- en: 2.4     How many hexadecimal digits are required to represent each of the following?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4     以下每个需要多少个十六进制数字来表示？
- en: (a)     8 bits
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     8比特
- en: (b)     32 bits
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     32比特
- en: (c)     64 bits
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     64比特
- en: (d)     10 bits
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     10比特
- en: (e)     20 bits
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     20比特
- en: (f)     7 bits
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     7比特
- en: '**The Mathematical Equivalence of Binary and Decimal**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制与十进制的数学等价性**'
- en: In the previous section, you learned that binary digits are a natural way to
    show the states of switches within the computer. You also learned that we can
    use hexadecimal to show the state of four switches with a single character. In
    this section, I’ll show you some of the mathematical properties of the binary
    number system and how it translates to and from the more familiar decimal (base
    10) number system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了二进制数字是如何自然地表示计算机内部开关状态的。你还学到了我们可以用十六进制表示四个开关的状态，通过一个字符。在这一节中，我将向你展示二进制数系统的一些数学性质，以及它如何与我们更为熟悉的十进制（基数10）数系统互相转换。
- en: '***Getting to Know Positional Notation***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解位置符号系统***'
- en: By convention, we use positional notation when writing numbers. *Positional
    notation* means that the value of a symbol depends on its position within a group
    of symbols. In the familiar decimal number system, we use the symbols 0, 1, .
    . . , 9 to represent numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，当我们写数字时，使用位置符号系统。*位置符号系统*意味着符号的值取决于它在符号组中的位置。在我们熟悉的十进制数系统中，我们使用符号0、1、...、9来表示数字。
- en: In the number 50, the value of the symbol 5 is 50 because it’s in the *tens
    position*, and any number in that position is multiplied by 10\. In the number
    500, the value of the symbol 5 is 500 because it’s in the *hundreds position*.
    The symbol 5 is the same in any position, but its value depends on the position
    it occupies within the number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字50中，符号5的值是50，因为它位于*十位*，任何在该位置的数字都会乘以10。在数字500中，符号5的值是500，因为它位于*百位*。符号5在任何位置的值都是一样的，但其值取决于它在数字中所处的位置。
- en: Taking this a step further, in the decimal number system, the integer 123 is
    taken to mean
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步地，在十进制数系统中，整数123意味着
- en: '![Image](../images/pg41_Image_5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_5.jpg)'
- en: 'or:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![Image](../images/pg41_Image_6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_6.jpg)'
- en: In this example, the rightmost digit, 3, is the *least significant digit* because
    its value contributes the least to the number’s total value. The leftmost digit,
    1, is the *most significant digit* because it contributes the most value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，最右边的数字3是*最低有效数字*，因为它对数字总值的贡献最小。最左边的数字1是*最高有效数字*，因为它对数字总值的贡献最大。
- en: '**ANOTHER NUMBER SYSTEM**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种数字系统**'
- en: 'Before positional notations were invented, people used counting systems to
    keep track of numerical quantities. The *Roman numeral* system is a well-known
    example of a counting system. It uses the symbols I for 1, V for 5, X for 10,
    L for 50, and so on. To represent two things, you simply use two I’s: II. Similarly,
    XX represents 20 things.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置符号系统发明之前，人们使用计数系统来跟踪数量。*罗马数字*系统就是一种著名的计数系统示例。它使用符号I表示1，V表示5，X表示10，L表示50，等等。要表示两个物品，你只需用两个I：II。类似地，XX表示20个物品。
- en: The two main rules of the Roman numeral system are that symbols that represent
    larger values come first, and if a symbol representing a smaller value is placed
    before a larger one, then the value of the smaller one is subtracted from the
    immediately following larger one. For example, IV represents 4 because I (1) is
    less than V (5), so it is subtracted from the value represented by V.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字系统的两个主要规则是，表示较大值的符号排在前面；如果一个表示较小值的符号出现在较大符号之前，则较小符号的值会从紧接其后的较大符号的值中被减去。例如，IV代表4，因为I（1）小于V（5），所以从V的值中减去I的值。
- en: 'There is no symbol for zero in the Roman numeral system because the symbol
    0 isn’t needed in counting systems. In a positional system, we need a symbol to
    mark the fact that there is no value in that position, but the position still
    counts toward the value being represented: the zeros in 500 tell us that there
    are no values in the tens position or the ones position. There is just a value
    of 5 in the hundreds position.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字系统中没有零的符号，因为在计数系统中不需要符号0。在位置符号系统中，我们需要一个符号来标记该位置没有值，但该位置仍然对表示的值起作用：在500中的零告诉我们，十位和个位没有值。只有百位上有一个5的值。
- en: 'The invention of positional notations greatly simplified arithmetic and led
    to the mathematics we know today. If you need to convince yourself, divide 60
    (LX) by 3 (III) in the Roman numeral system. (Answer: XX.)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 位置符号的发明极大简化了算术运算，并导致了我们今天所知的数学。如果你需要说服自己，可以在罗马数字系统中试着将60（LX）除以3（III）。(答案：XX。)
- en: The *base*, or *radix*, of the decimal number system—that is, the number of
    unique digits—is 10\. This means there are 10 symbols to represent the digits
    0 through 9\. Moving a digit one place to the left increases its value by a factor
    of 10\. Moving it one place to the right decreases its value by a factor of 10\.
    The positional notation generalizes to any radix *r* as
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数系统的*基数*或*进制*是 10。这意味着有 10 个符号来表示数字 0 到 9。将一个数字向左移动一位会使其值增加 10 倍。将其向右移动一位会使其值减少
    10 倍。位置记数法可以推广到任何基数 *r*，即
- en: '![Image](../images/pg41_Image_7.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_7.jpg)'
- en: where there are *n* digits in the number and each *d[i]* is a single digit with
    0 *≤ d[i]* < *r*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中数字中有 *n* 位，每个 *d[i]* 是一个单独的数字，满足 0 *≤ d[i]* < *r*。
- en: This expression tells us how to determine the value of each digit in the number.
    We determine the position of each digit in the number by counting from the right,
    starting with zero. At each position, we raise the radix, *r*, to the power of
    its position and then multiply that number by the value of the digit. Adding all
    the results gives us the value represented by the number.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式告诉我们如何确定数字中每一位的值。我们通过从右边开始按顺序计数，从零开始来确定每一位的位置。在每个位置，我们将基数 *r* 提到该位置的幂次方，然后将其与该数字的值相乘。将所有结果相加，我们就得到了该数字所表示的值。
- en: The radix in the binary number system is 2, so there are only two symbols for
    representing the digits. This means that *d[i]* = `0`, `1`, and we can write this
    expression as
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数系统的进制是 2，因此只有两个符号来表示数字。这意味着 *d[i]* = `0`、`1`，我们可以将该表达式写为
- en: '![Image](../images/pg42_Image_8.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_8.jpg)'
- en: where there are *n* digits in the number and each *d[i]* = `0` or `1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中数字中有 *n* 位，每个 *d[i]* = `0` 或 `1`。
- en: In the next section, we’ll convert binary numbers to and from unsigned decimals.
    *Signed* numbers can be either positive or negative, but *unsigned* numbers have
    no sign. We’ll discuss signed numbers in [Chapter 3](ch03.xhtml).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把二进制数转换为无符号十进制数并反向转换。*有符号*数字可以是正数或负数，但*无符号*数字没有符号。我们将在[第 3 章](ch03.xhtml)中讨论有符号数字。
- en: '***Converting Binary to Unsigned Decimal***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制转换为无符号十进制***'
- en: 'You can easily convert from binary to decimal by computing the value of 2 raised
    to the power of the position it’s in and then multiplying that by the value of
    the bit in that position. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算 2 的位置次方，然后将其与该位置上的位值相乘，轻松地将二进制转换为十进制。例如：
- en: '![Image](../images/pg42_Image_9.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_9.jpg)'
- en: 'Using pseudocode, the procedure for converting binary to decimal can be summarized
    as:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪代码，二进制转换为十进制的过程可以总结为：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At each bit position, this algorithm computes 2*^i* and then multiplies by the
    respective bit value, either `0` or `1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个位位置，算法计算 2*^i* 并将其与相应的位值（`0` 或 `1`）相乘。
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although we’re considering only integers at this point, this algorithm does
    generalize to fractional values. Simply continue the exponents of the radix,*
    r*, on to negative values—that is,* r^(n – *1*), r^(n – *2*)*, . . . ,* r*¹,*
    r*⁰,* r^(–*1*), r^(–*2*)*, . . . This will be covered in detail in [Chapter 19](ch19.xhtml).*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管我们此时只考虑整数，但该算法确实可以推广到小数值。只需将进制 *r* 的指数继续扩展到负值——即 *r^(n – *1*)*，*r^(n – *2*)*，...，*r¹*，*r⁰*，*r^(–*1*)*，*r^(–*2*)*，...
    这将在[第 19 章](ch19.xhtml)中详细讨论。*'
- en: '**YOUR TURN**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 2.5     Looking at the generalized equation in this section, what are the values
    of *r*, *n*, and each *d[i]* for the decimal number 29,458,254 and the hexadecimal
    number `29458254`?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2.5     查看本节中的广义方程，十进制数 29,458,254 和十六进制数 `29458254` 的 *r*、*n* 和每个 *d[i]* 的值是什么？
- en: '2.6     Convert the following 8-bit binary numbers to decimal:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 2.6     将以下 8 位二进制数转换为十进制：
- en: (a)     `1010 1010`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1010 1010`
- en: (b)     `0101 0101`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `0101 0101`
- en: (c)     `1111 0000`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 0000`
- en: (d)     `0000 1111`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 1111`
- en: (e)     `1000 0000`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `1000 0000`
- en: (f)     `0110 0011`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `0110 0011`
- en: (g)     `0111 1011`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     `0111 1011`
- en: (h)     `1111 1111`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     `1111 1111`
- en: '2.7     Convert the following 16-bit binary numbers to decimal:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 2.7     将以下 16 位二进制数转换为十进制：
- en: (a)     `1010 1011 1100 1101`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1010 1011 1100 1101`
- en: (b)     `0001 0011 0011 0100`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `0001 0011 0011 0100`
- en: (c)     `1111 1110 1101 1100`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 1110 1101 1100`
- en: (d)     `0000 0111 1101 1111`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 0111 1101 1111`
- en: (e)     `1000 0000 0000 0000`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `1000 0000 0000 0000`
- en: (f)     `0000 0100 0000 0000`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `0000 0100 0000 0000`
- en: (g)     `0111 1011 1010 1010`
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     `0111 1011 1010 1010`
- en: (h)     `0011 0000 0011 1001`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     `0011 0000 0011 1001`
- en: '2.8     Develop an algorithm to convert hexadecimal to decimal and then convert
    the following 16-bit numbers to decimal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `a000`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `ffff`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `0400`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `1111`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `8888`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `0190`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: (g)     `abcd`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: (h)     `5555`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Unsigned Decimal to Binary***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we want to convert an unsigned decimal integer, *N*, to binary, we set it
    equal to the previous expression for binary numbers to give the equation
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: where each *d[i]* = `0` or `1`. We divide both sides of this equation by 2,
    and the exponent of each 2 term on the right side decreases by 1, giving
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'where *N*[1] is the integer part and the remainder, *r*[0], is `0` for even
    numbers and `1` for odd numbers. Doing a little rewriting, we have the equivalent
    equation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: All the terms within the parentheses on the right side are integers. The integer
    part of both sides of an equation must be equal, and the fractional parts must
    also be equal. That is, we have
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg43_Image_13.jpg) and:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'Thus, you can see that *d*[0] = *r*[0]. Subtracting *r*[0] /2 (which equals
    *d*[0]/2) from both sides of our expanded equation gives us:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Again, we divide both sides by 2:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg44_Image_16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Using the same reasoning as earlier, *d*[1] = *r*[1]. We can produce the binary
    representation of a number by working from right to left, repeatedly dividing
    by 2, and using the remainder as the value of the respective bit. This is summarized
    in the following algorithm, where the forward slash (`/`) is the integer division
    operator and the percent sign (`%`) is the modulo operator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some programming tasks require a specific bit pattern—for example, programming
    a hardware device. In these cases, specifying a bit pattern rather than a numerical
    value is more natural. We can think of the bits in groups of four and use hexadecimal
    to specify each group. For example, if our algorithm required the use of zeros
    alternating with ones—`0101 0101 0101 0101 0101 0101 0101 0101`—we could convert
    this to the decimal value 431,655,765, or we could express it in hexadecimal as
    `0x55555555` (shown here in C/C++ syntax). Once you’ve memorized [Table 2-1](ch02.xhtml#ch2tab1),
    you’ll find it much easier to work with hexadecimal for bit patterns.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The discussion in these two sections has dealt only with unsigned integers.
    The representation of signed integers depends upon some architectural features
    of the CPU that we’ll discuss in [Chapter 3](ch03.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '2.9     Convert the following unsigned decimal integers to their 8-bit hexadecimal
    representation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: (a)     100
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: (b)     123
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: (c)     10
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: (d)     88
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: (e)     255
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: (f)     16
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: (g)     32
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: (h)     128
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '2.10     Convert the following unsigned decimal integers to their 16-bit hexadecimal
    representation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: (a)     1,024
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: (b)     1,000
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: (c)     32,768
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: (d)     32,767
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     32,767
- en: (e)     256
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     256
- en: (f)     65,535
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     65,535
- en: (g)     4,660
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     4,660
- en: (h)     43,981
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     43,981
- en: 2.11     Invent a code that would allow you to store letter grades with plus
    or minus (that is, the grades A, A–, B+, B, B–, . . . , D, D–, F). How many bits
    are required for your code?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 2.11     发明一种代码，允许你存储带有加号或减号的字母成绩（即成绩A、A–、B+、B、B–、. . . 、D、D–、F）。你的代码需要多少位？
- en: '**Storing Data in Memory**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据存储在内存中**'
- en: 'We now have the language necessary to begin discussing how data is stored in
    computer memory. We’ll start with how memory is organized. There are two general
    kinds of memory used for storing program instructions and data in a computer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了开始讨论数据如何存储在计算机内存中的语言。我们将从内存是如何组织的开始。计算机中用于存储程序指令和数据的内存一般有两种类型：
- en: '**Random-access memory (RAM)**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机存取内存 (RAM)**'
- en: Once a bit (switch) is set to either `0` or `1`, it stays in that state until
    the control unit actively changes it or the power is turned off. The control unit
    can both read and change the state of a bit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个位（开关）被设置为`0`或`1`，它将保持该状态，直到控制单元主动改变它或电源被切断。控制单元既可以读取位的状态，也可以改变位的状态。
- en: The name *random-access memory* is misleading. Here, *random access* means that
    it takes the same amount of time to access any byte in the memory, not that any
    randomness is involved when reading the byte. We contrast RAM with *sequential
    access memory (SAM)*, where the amount of time it takes to access a byte depends
    on its position in some sequence. An example of SAM is magnetic tape, which is
    typically used for backups, where retrieval speed is less important. The length
    of time it takes to access a byte depends on the physical location of the byte
    stored on the tape with respect to the current position of the tape.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机存取内存*这个名称是误导性的。在这里，*随机存取*意味着访问内存中的任何字节所需的时间相同，而不是在读取字节时涉及任何随机性。我们将RAM与*顺序访问内存
    (SAM)*进行对比，后者访问字节所需的时间取决于其在某个序列中的位置。SAM的一个例子是磁带，通常用于备份，在那里检索速度并不那么重要。访问字节所需的时间取决于存储在磁带上的字节的物理位置与当前磁带位置的关系。'
- en: '**Read-only memory (ROM)**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读内存 (ROM)**'
- en: The control unit can read the state of each bit in ROM but can’t change it.
    You can reprogram some types of ROM with specialized hardware, but the bits remain
    in the new state when the power is turned off. ROM is also called *nonvolatile
    memory (NVM)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元可以读取ROM中每个位的状态，但不能改变它。你可以通过专用硬件重新编程某些类型的ROM，但当电源关闭时，位将保持在新的状态。ROM也被称为*非易失性内存
    (NVM)*。
- en: '***Memory Addresses***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存地址***'
- en: Each byte in memory has a location, or address, much like the room number in
    an office building. The address of a specific byte never changes. That is, the
    957th byte from the beginning of memory will always be the 957th byte. However,
    the state (content) of each of the bits—`0` or `1`—in any given byte can be changed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的每个字节都有一个位置或地址，类似于办公大楼中的房间号。特定字节的地址是固定不变的。也就是说，从内存开始的第957个字节将始终是第957个字节。然而，任何给定字节中每个位的状态（`0`
    或 `1`）是可以改变的。
- en: Computer scientists typically express the address of each byte in memory in
    hexadecimal, starting the numbering at zero. Thus, we would say that the 957th
    byte is at address `0x3bc` (= 956 in decimal).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家通常使用十六进制表示内存中每个字节的地址，编号从零开始。因此，我们可以说第957个字节的地址是`0x3bc`（即十进制的956）。
- en: The first 16 bytes in memory have the addresses `0`, `1`, `2`, `3`, `4`, `5`,
    `6`, `7`, `8`, `9`, `a`, `b`, `c`, `d`, `e`, and `f`. Using the notation
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的前16个字节的地址是`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`a`、`b`、`c`、`d`、`e`和`f`。使用这种表示法
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: we can show the contents of each of the first 16 bytes of memory, as in [Table
    2-3](ch02.xhtml#ch2tab3) (the contents here are arbitrary).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以展示内存中前16个字节的内容，如[表2-3](ch02.xhtml#ch2tab3)所示（这里的内容是任意的）。
- en: '**Table 2-3:** Example Contents of the First 16 Bytes of Memory'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-3：** 内存前16个字节的示例内容'
- en: '| **Address** | **Content** | **Address** | **Content** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **内容** | **地址** | **内容** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x00000000` | `0x6a` | `0x00000008` | `0xf0` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000000` | `0x6a` | `0x00000008` | `0xf0` |'
- en: '| `0x00000001` | `0xf0` | `0x00000009` | `0x02` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000001` | `0xf0` | `0x00000009` | `0x02` |'
- en: '| `0x00000002` | `0x5e` | `0x0000000a` | `0x33` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000002` | `0x5e` | `0x0000000a` | `0x33` |'
- en: '| `0x00000003` | `0x00` | `0x0000000b` | `0x3c` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000003` | `0x00` | `0x0000000b` | `0x3c` |'
- en: '| `0x00000004` | `0xff` | `0x0000000c` | `0xc3` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000004` | `0xff` | `0x0000000c` | `0xc3` |'
- en: '| `0x00000005` | `0x51` | `0x0000000d` | `0x3c` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000005` | `0x51` | `0x0000000d` | `0x3c` |'
- en: '| `0x00000006` | `0xcf` | `0x0000000e` | `0x55` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000006` | `0xcf` | `0x0000000e` | `0x55` |'
- en: '| `0x00000007` | `0x18` | `0x0000000f` | `0xaa` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000007` | `0x18` | `0x0000000f` | `0xaa` |'
- en: The content of each byte is represented by two hexadecimal digits, which specify
    the exact state of the byte’s 8 bits.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字节的内容由两个十六进制数字表示，这些数字指定字节的 8 位的精确状态。
- en: 'But what can the state of the byte’s 8 bits tell us? There are two issues that
    a programmer needs to consider when storing data in memory:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，字节的 8 位状态能告诉我们什么呢？程序员在将数据存储到内存时，需要考虑两个问题：
- en: '**How many bits are needed to store the data?**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储数据需要多少位？**'
- en: To answer this question, we need to know how many different values are allowed
    for the particular data item. Look at the number of different values we can represent
    in [Table 2-1](ch02.xhtml#ch2tab1) (4 bits) and [Table 2-2](ch02.xhtml#ch2tab2)
    (3 bits). We can represent up to 2*^n* different values in *n* bits. Notice, too,
    that we might not use all the possible bit patterns we have within an allocated
    space.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们需要知道该数据项允许多少种不同的值。请查看[表 2-1](ch02.xhtml#ch2tab1)（4 位）和[表 2-2](ch02.xhtml#ch2tab2)（3
    位）中可以表示的不同值的数量。我们可以用 *n* 位表示最多 2*^n* 种不同的值。还要注意的是，我们可能并不会使用在分配空间内所有可能的位模式。
- en: '**What is the code for storing the data?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储数据的代码是什么？**'
- en: Most of the data we deal with in everyday life is not expressed in terms of
    zeros and ones. To store it in computer memory, the programmer must decide how
    to encode the data in zeros and ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常生活中处理的大多数数据不是以零和一的形式表示的。为了将其存储在计算机内存中，程序员必须决定如何将数据编码成零和一。
- en: In the rest of this chapter, you’ll see how we can store characters and unsigned
    integers in memory using the state of the bits in one or more bytes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将看到我们如何利用一个或多个字节中位的状态将字符和无符号整数存储到内存中。
- en: '#### ***Characters***'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***字符***'
- en: 'When you’re programming, you will almost always be manipulating text strings,
    which are arrays of characters. The first program you ever wrote was probably
    a “Hello, World!” program. If you wrote it in C, you used a statement like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编程时，几乎总是在操作文本字符串，这些字符串是字符数组。你写的第一个程序可能是一个“Hello, World!”程序。如果你用 C 语言写的，可能会使用类似这样的语句：
- en: '[PRE5]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, in C++:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 C++ 中：
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When translating either of these statements into machine code, the compiler
    must do two things:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这些语句翻译成机器代码时，编译器必须做两件事：
- en: Store each of the characters in a location in memory where the control unit
    can access them.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个字符存储在内存中的一个位置，以便控制单元可以访问它们。
- en: Generate the machine instructions to write the characters on the screen.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成机器指令将字符写到屏幕上。
- en: We’ll start by considering how a single character is stored in memory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从考虑如何在内存中存储一个单独的字符开始。
- en: '**Encoding Characters**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编码字符**'
- en: The most common standard for encoding characters for computer storage is *Unicode
    UTF-8*. It uses 1 to 4 bytes for storing a number called a *code point*, which
    represents a character. A Unicode code point is written as U+*h*, where *h* is
    four to six hexadecimal digits. The operating system and display hardware associate
    one or more code points with a *glyph*, which is what we see on the screen or
    on paper. For example, U+0041 is the code point for the Latin capital letter *A*,
    which has the glyph A in the font used for this book.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算机存储字符编码的最常见标准是 *Unicode UTF-8*。它使用 1 到 4 个字节来存储一个称为 *代码点* 的数字，该数字表示一个字符。一个
    Unicode 代码点写作 U+*h*，其中 *h* 是四到六个十六进制数字。操作系统和显示硬件将一个或多个代码点与一个 *字形* 关联，字形就是我们在屏幕上或纸上看到的内容。例如，U+0041
    是拉丁大写字母 *A* 的代码点，而在本书使用的字体中，它对应的字形是 A。
- en: UTF-8 is backward compatible with an older standard, the *American Standard
    Code for Information Interchange*, or *ASCII* (pronounced “ask-ee”). ASCII uses
    7 bits to specify each code point in a 128-character set, which contains the English
    alphabet (uppercase and lowercase), numerals, special characters, and control
    characters. In all of our programming in this book, we will use only the characters
    from the ASCII subset of UTF-8, U+0000 to U+007F.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 向后兼容一个较旧的标准，即 *美国信息交换标准代码*，或 *ASCII*（发音为“ask-ee”）。ASCII 使用 7 位来指定一个包含
    128 个字符的字符集中的每个代码点，该字符集包括英语字母（大写和小写）、数字、特殊字符和控制字符。在本书的所有编程中，我们只会使用 UTF-8 的 ASCII
    子集中的字符，U+0000 到 U+007F。
- en: '[Table 2-4](ch02.xhtml#ch2tab4) shows the Unicode code points for the characters
    used to represent hexadecimal numbers and the corresponding 8-bit patterns that
    are stored in memory in our programming environment. You will have a chance to
    put this table to use later in the book, when you learn how to convert from the
    character representation of an integer to its binary representation. For now,
    notice that while the numeric characters are organized in a contiguous bit pattern
    sequence, there is a gap between them and the alphabetic characters.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](ch02.xhtml#ch2tab4) 展示了用于表示十六进制数字的字符的 Unicode 代码点，以及在我们的编程环境中存储这些字符的对应
    8 位模式。稍后在本书中，你将有机会使用这个表格，当你学习如何从整数的字符表示转换为其二进制表示时。目前，注意到虽然数字字符是按照连续的位模式顺序组织的，但它们与字母字符之间有一个间隙。'
- en: '**Table 2-4:** Some UTF-8 Code Points for Hexadecimal Characters'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-4：** 一些十六进制字符的 UTF-8 代码点'
- en: '| **Code point** | **Character description** | **Character glyph** | **Bit
    pattern** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **代码点** | **字符描述** | **字符字形** | **位模式** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| U+0030 | Digit zero | `0` | `0x30` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| U+0030 | 数字零 | `0` | `0x30` |'
- en: '| U+0031 | Digit one | `1` | `0x31` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| U+0031 | 数字一 | `1` | `0x31` |'
- en: '| U+0032 | Digit two | `2` | `0x32` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| U+0032 | 数字二 | `2` | `0x32` |'
- en: '| U+0033 | Digit three | `3` | `0x33` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| U+0033 | 数字三 | `3` | `0x33` |'
- en: '| U+0034 | Digit four | `4` | `0x34` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| U+0034 | 数字四 | `4` | `0x34` |'
- en: '| U+0035 | Digit five | `5` | `0x35` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| U+0035 | 数字五 | `5` | `0x35` |'
- en: '| U+0036 | Digit six | `6` | `0x36` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| U+0036 | 数字六 | `6` | `0x36` |'
- en: '| U+0037 | Digit seven | `7` | `0x37` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| U+0037 | 数字七 | `7` | `0x37` |'
- en: '| U+0038 | Digit eight | `8` | `0x38` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| U+0038 | 数字八 | `8` | `0x38` |'
- en: '| U+0039 | Digit nine | `9` | `0x39` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| U+0039 | 数字九 | `9` | `0x39` |'
- en: '| U+0061 | Latin small letter a | `a` | `0x61` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| U+0061 | 拉丁小写字母 a | `a` | `0x61` |'
- en: '| U+0062 | Latin small letter b | `b` | `0x62` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| U+0062 | 拉丁小写字母 b | `b` | `0x62` |'
- en: '| U+0063 | Latin small letter c | `c` | `0x63` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| U+0063 | 拉丁小写字母 c | `c` | `0x63` |'
- en: '| U+0064 | Latin small letter d | `d` | `0x64` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| U+0064 | 拉丁小写字母 d | `d` | `0x64` |'
- en: '| U+0065 | Latin small letter e | `e` | `0x65` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| U+0065 | 拉丁小写字母 e | `e` | `0x65` |'
- en: '| U+0066 | Latin small letter f | `f` | `0x66` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| U+0066 | 拉丁小写字母 f | `f` | `0x66` |'
- en: Although the hexadecimal numerical portion is the same as the bit pattern for
    the code points U+0000 to U+007F, this does not necessarily hold true for other
    characters. For example, U+00B5 is the code point for the micro sign, which is
    stored in memory as the 16-bit pattern `0xc2b5` and has the glyph *µ* in the font
    used for this book.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管十六进制数值部分与代码点 U+0000 到 U+007F 的位模式相同，但这并不一定适用于其他字符。例如，U+00B5 是微符号的代码点，它在内存中以
    16 位模式 `0xc2b5` 存储，并且在本书中使用的字体显示为字形 *µ*。
- en: UTF-8 uses 1 byte per character to store code points U+0000 to U+007F. Bits
    6 and 5 in the byte (recall that bits are numbered from right to left, starting
    with 0) specify the four groups of characters, shown in [Table 2-5](ch02.xhtml#ch2tab5).
    The special characters are mostly punctuation. For example, the space character
    is U+0020 and the semicolon character (;) is U+003B.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 使用每个字符 1 字节来存储代码点 U+0000 到 U+007F。字节中的位 6 和位 5（记住，位从右到左编号，从 0 开始）指定了四个字符组，如
    [表 2-5](ch02.xhtml#ch2tab5) 所示。特殊字符大多是标点符号。例如，空格字符是 U+0020，分号字符（;）是 U+003B。
- en: '**Table 2-5:** The Character Groups in Code Points U+0000 to U+007F'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-5：** 字符组在代码点 U+0000 到 U+007F 中的分布'
- en: '| **Bit 6** | **Bit 5** | **Type of character** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **位 6** | **位 5** | **字符类型** |'
- en: '| --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | `0` | Control |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | 控制字符 |'
- en: '| `0` | `1` | Numeric and special |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | 数字字符和特殊字符 |'
- en: '| `1` | `0` | Uppercase alphabetic and special |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | 大写字母和特殊字符 |'
- en: '| `1` | `1` | Lowercase alphabetic and special |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | 小写字母和特殊字符 |'
- en: You can generate a table of the code points that coincide with ASCII characters
    by typing the command man ascii in a Linux terminal window. (You may need to install
    the `ascii` program on your computer.) It is quite large and not the sort of thing
    you would want to memorize, but it can be helpful to understand roughly how it’s
    organized.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Linux 终端窗口中输入命令 `man ascii` 来生成与 ASCII 字符对应的代码点表。 (你可能需要在计算机上安装 `ascii`
    程序。) 这个表非常庞大，不适合记忆，但它有助于大致了解其组织结构。
- en: You can learn more about Unicode at *[https://www.unicode.org/releases/](https://www.unicode.org/releases/)*.
    For a more informal discussion of how Unicode came to be, I recommend Joel Spolsky’s
    “The Absolute Minimum Every Software Developer Absolutely, Positively Must Know
    About Unicode and Character Sets (No Excuses!)” at *[https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 2.12     Many people use uppercase for the alphabetic hexadecimal characters.
    Every programming language I know about accepts either case. Redo [Table 2-4](ch02.xhtml#ch2tab4)
    using the bit patterns for the uppercase hexadecimal characters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 2.13     Create an ASCII table for the lowercase alphabetic characters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 2.14     Create an ASCII table for the uppercase alphabetic characters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 2.15     Create an ASCII table for the punctuation marks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing a Text String**'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Getting back to `Hello, World!\n`, the compiler stores this text string as
    a constant array of characters. To specify the extent of this array, a C-style
    string uses the code point U+0000 (ASCII `NUL`) at the end of the string as a
    *sentinel* value, which is a unique value that indicates the end of a sequence
    of characters. Thus, the compiler must allocate 15 bytes for this string: 13 for
    `Hello, World!`, 1 for the newline `\n`, and 1 for the `NUL`. [Table 2-6](ch02.xhtml#ch2tab6)
    shows how this text string would be stored starting at location `0x4004a1` in
    memory.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-6:** `Hello, World!\n` Stored in Memory'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Content** | **Address** | **Content** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a1` | `0x48` | `0x4004a9` | `0x6f` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a2` | `0x65` | `0x4004aa` | `0x72` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a3` | `0x6c` | `0x4004ab` | `0x6c` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a4` | `0x6c` | `0x4004ac` | `0x64` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a5` | `0x6f` | `0x4004ad` | `0x21` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a6` | `0x2c` | `0x4004ae` | `0x0a` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a7` | `0x20` | `0x4004af` | `0x00` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `0x4004a8` | `0x57` | — | — |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: C uses U+000A (ASCII `LF`) as a newline character (at address `0x4004ae` in
    this example), even though the C syntax requires that the programmer write two
    characters, `\n`. The text string ends with the `NUL` character at `0x4004af`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In Pascal, another programming language, the length of a string is specified
    by the first byte in the string, which is taken to be an 8-bit unsigned integer.
    (This is the reason for the 256-character limit on text strings in Pascal.) The
    C++ string class has additional features, but the actual text string is stored
    as a C-style text string within the C++ string instance.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '***Unsigned Integers***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since an unsigned integer can be expressed in any radix, probably the most obvious
    way to store it is to use the binary number system. If we number the bits in a
    byte from right to left, then the lowest-order bit would be stored in bit 0, the
    next in bit 1, and so forth. For example, the integer 123[10] = `7b`[16], so the
    state of the byte where it is stored would be `01111011`[2]. Using only a single
    byte restricts the range of unsigned integers to be from 0 to 255[10], since `ff`[16]
    = 255[10]. The default size for an unsigned integer in our programming environment
    is 4 bytes, which allows for a range of 0 to 4,294,967,295[10].
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of using the binary number system is that you need to convert
    a decimal number from a character string to the binary number system before performing
    arithmetic operations on it. For example, the decimal number 123 would be stored
    in character string format as the four bytes `0x31`, `0x32`, `0x33`, and `0x00`,
    while in unsigned integer format, it would be stored as the 4-byte binary number
    `0x0000007b`. At the other end, binary numbers need to be converted to their decimal
    character representations for most real-world display purposes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary coded decimal (BCD)* is another code for storing integers. It uses
    4 bits for each decimal digit, as shown in [Table 2-7](ch02.xhtml#ch2tab7).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-7:** Binary Coded Decimal'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal digit** | **BCD code** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| 0 | `0000` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| 1 | `0001` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| 2 | `0010` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| 3 | `0011` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| 4 | `0100` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| 5 | `0101` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| 6 | `0110` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| 7 | `0111` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| 8 | `1000` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| 9 | `1001` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: For example, in a 16-bit storage location, the decimal number 1,234 would be
    stored in BCD as `0001 0010 0011 0100` (in the binary number system, it would
    be `0000 0100 1101 0010`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: With only 10 of the possible 16 combinations being used, six bit patterns are
    wasted. This means that a 16-bit storage location has a range of 0 to 9,999 for
    values if we use BCD, compared to a range of 0 to 65,535 if we use binary. This
    is a less efficient use of memory. On the other hand, the conversions between
    a character format and an integer format are simpler with BCD, as you will learn
    in [Chapter 16](ch16.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: BCD is important in specialized systems that deal primarily with numerical business
    data, because they tend to print numbers more often than they perform mathematical
    operations on them. COBOL, a programming language intended for business applications,
    supports a packed BCD format where two digits (in BCD code) are stored in each
    8-bit byte. Here, the *last* (4-bit) digit is used to store the sign of the number,
    as shown in [Table 2-8](ch02.xhtml#ch2tab8). The specific codes used depend upon
    the implementation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-8:** Example Sign Codes for Packed BCD Format'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sign** | **Sign code** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| + | `1010` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| – | `1011` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| + | `1100` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| – | `1101` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| + | `1110` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| Unsigned | `1111` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: For example, `0001 0010 0011 1010` represents +123, `0001 0010 0011 1011` represents
    –123, and `0001 0010 0011 1111` represents 123.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore some of these concepts using the C programming language.
    If you’re new to C, this discussion will provide an introduction to the language.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Data Formats with C**'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll write our first programs with the C programming language.
    These particular programs illustrate the differences between how numbers are stored
    in memory and how we humans read them. C allows us to get close enough to the
    hardware to understand the core concepts, while taking care of many of the low-level
    details. You shouldn’t find the simple C programs in this book too difficult,
    especially if you already know how to program in another language.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: If you learned how to program in a higher-level language, such as C++, Java,
    or Python, you probably learned object-oriented programming. C doesn’t support
    the object-oriented paradigm; it is a *procedural* programming language. C programs
    are divided into *functions*, where a function is a named group of programming
    statements. Other programming languages also use the terms *procedure* and *subprogram*,
    with some minor distinctions between them depending on the language.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '***Using C and C++ I/O Libraries***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most high-level programming languages include a standard library that can be
    thought of as part of the language. A *standard library* contains functions and
    data structures that can be used in the language for doing common things such
    as terminal I/O (writing to the screen and reading from the keyboard). C includes
    the *C standard library* and C++ includes the *C++ standard library*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'C programmers use functions in the `stdio` library for terminal I/O, while
    C++ programmers use functions in the `iostream` library. For example, the C code
    sequence for reading an integer from the keyboard, adding 100 to it, and writing
    the result to the screen looks like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The C++ code sequence looks something like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In both examples, the code reads characters (each as a separate `char`) from
    the keyboard and converts the `char` sequence into the corresponding `int` format.
    Then, it adds 100 to the `int` before converting the result into a `char` sequence
    and displaying it on the screen. The C or C++ I/O library functions in the previous
    code snippets do the necessary conversions between `char` sequences and the `int`
    storage format.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) shows the relationship between a C application
    program, the I/O libraries, and the operating system.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg52_Image_17.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The relationship of I/O libraries to the application and the operating
    system*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: When reading from the keyboard, the `scanf` library function first calls the
    `read` *system call* function, a function in the operating system, to read characters
    from the keyboard. The input on the keyboard is in the form of a string of characters,
    each of the `char` data type. The `scanf` library function performs the conversion
    of this string to the `int` data type for the application program. The `printf`
    library function converts from the `int` data type to the corresponding string
    of characters in the `char` data type and calls the `write` system call function
    to write each character to the screen.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当从键盘读取时，`scanf`库函数首先调用`read` *系统调用* 函数，这是操作系统中的一个函数，用于从键盘读取字符。键盘上的输入是一个字符串，每个字符都是`char`数据类型。`scanf`库函数将这个字符串转换为应用程序所需的`int`数据类型。`printf`库函数则将`int`数据类型转换为对应的字符串，并调用`write`系统调用函数将每个字符写入屏幕。
- en: In [Figure 2-1](ch02.xhtml#ch2fig1), an application program can call the `read`
    and `write` functions directly to transfer characters. We’ll explore this in [Chapter
    16](ch16.xhtml), where we’ll write our own conversion functions. Although the
    C/C++ library functions do a much better job of this than we will, the exercise
    of doing it yourself will give you a better understanding of how data is stored
    in memory and manipulated by software.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-1](ch02.xhtml#ch2fig1)中，一个应用程序可以直接调用`read`和`write`函数来传输字符。我们将在[第16章](ch16.xhtml)中深入探讨这一点，届时我们将编写自己的转换函数。尽管C/C++库函数在这方面做得比我们好得多，但亲自实现这个功能将帮助你更好地理解数据是如何存储在内存中并被软件操作的。
- en: '**NOTE**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if you’re familiar with the GNU* make *program, it’s worth learning how
    to use it to build your programs. It may seem like overkill at this point, but
    it’s much easier to learn with simple programs. The manual is available in several
    formats at* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)*,
    and my comments about using it are available on my website at* [https://rgplantz.github.io](https://rgplantz.github.io).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使你熟悉GNU* make *程序，学习如何使用它来构建你的程序也是值得的。此时可能看起来有点多余，但对于简单的程序来说，学习起来更容易。手册可以通过几种格式在*
    [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
    *获取，我对使用它的评论可以在我的网站上找到，网址是* [https://rgplantz.github.io](https://rgplantz.github.io)。'
- en: '***Writing and Executing Your First C Program***'
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写和执行你的第一个C程序***'
- en: Most programming books start with a simple program that just prints “Hello,
    World!” to a computer screen, but we’ll start with a program that reads a hexadecimal
    value, both as an unsigned integer and as a text string ([Listing 2-1](ch02.xhtml#ch2list1)).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程书籍从一个简单的程序开始，这个程序仅仅是将“Hello, World!”打印到计算机屏幕上，但我们将从一个程序开始，它读取一个十六进制值，既作为无符号整数，也作为文本字符串（[示例2-1](ch02.xhtml#ch2list1)）。
- en: '*int_and_string.c*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_and_string.c*'
- en: '[PRE9]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-1: A program showing the difference between an integer and a text
    string*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例2-1：显示整数和文本字符串之间差异的程序*'
- en: We start our code with some documentation that gives a brief description of
    what the program does ❶. When writing your own source files, you should also include
    your name and the date they were written as part of the documentation (I’ve omitted
    them in the example programs in this book to save space). All text following two
    slash characters, `//`, on a line is a comment. C also allows us to start a multiple-line
    comment using `/*` and end it using `*/`. Comments are for the human reader and
    have no effect on the program itself.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些文档开始我们的代码，这些文档简要描述了程序的功能❶。当编写自己的源文件时，您也应当在文档中包括您的名字和编写日期（在本书的示例程序中为了节省空间，我省略了这些内容）。在一行中，紧跟两个斜杠字符`//`后的所有文本都是注释。C语言还允许我们使用`/*`开始一个多行注释，并用`*/`结束它。注释是给人类读者看的，对程序本身没有任何影响。
- en: The first operation that actually affects the program is the inclusion of a
    *header file*, *stdio.h* ❷, using the `#include` directive. As you will learn,
    the C compiler needs to know the type of each data item that is passed to or from
    a function. A header file is used to provide a *prototype statement* for each
    function, which specifies these data types. The *stdio.h* header file defines
    the interface to many of the functions in the C standard library, which tells
    the compiler what to do when calls to any of these functions are encountered in
    our source code. The *stdio.h* header file is already installed on your computer
    in a location the compiler knows.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实际影响程序的第一个操作是使用 `#include` 指令包含*头文件*，即 *stdio.h* ❷。正如你将要学习的，C 编译器需要知道传递给或从函数返回的每个数据项的类型。头文件用于提供每个函数的*原型声明*，以指定这些数据类型。*stdio.h*
    头文件定义了 C 标准库中许多函数的接口，告诉编译器在我们的源代码中遇到这些函数的调用时该怎么做。*stdio.h* 头文件已经安装在你的计算机上，存放在编译器知道的位置。
- en: 'The remaining code in this listing is the definition of a C `main` function.
    All C programs are made up of functions, which have this general format:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本清单中的其余代码是 C `main` 函数的定义。所有 C 程序都由函数组成，这些函数具有以下一般格式：
- en: '[PRE10]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When a C program is executed, the operating system first sets up either a *hosted
    environment* or a *freestanding environment*, which sets up the resources on your
    computer to run the program. The hosted environment includes access to the functions
    in the C standard library, while the freestanding environment does not. Most of
    the programs in this book run in the hosted environment. I’ll show you how to
    use the freestanding environment in “Supervisor Calls” on [page 474](ch21.xhtml#ch21lev1sec5)
    in [Chapter 21](ch21.xhtml).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 C 程序被执行时，操作系统首先设置一个*托管环境*或*独立环境*，这会为你的计算机配置资源以运行该程序。托管环境包括对 C 标准库中函数的访问，而独立环境则不包括。书中大部分程序运行在托管环境中。关于如何在[第21章](ch21.xhtml)的“管理调用”部分使用独立环境，我会在[第474页](ch21.xhtml#ch21lev1sec5)进行说明。
- en: In the C hosted environment, program execution starts with the `main` function,
    meaning that the program you write must include a function whose function name
    is `main`. The `main` function can call other functions, which in turn can call
    other functions. But program control normally ends up back in the `main` function,
    which then returns to the C hosted environment.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 托管环境中，程序的执行从 `main` 函数开始，这意味着你编写的程序必须包含一个名为 `main` 的函数。`main` 函数可以调用其他函数，而这些函数又可以调用其他函数。但是，程序控制通常会最终回到
    `main` 函数，然后返回到 C 托管环境。
- en: When a function is called in C, the calling function can include a list of *arguments*
    in the call as inputs to the called function. These inputs serve as *parameters*
    in the computation performed by the called function. For example, in [Listing
    2-1](ch02.xhtml#ch2list1), when the program first starts, the `main` function
    calls the `printf` function with one argument, a text string ❹. The `printf` function
    uses the text string to determine what to display on the screen. We’ll look closely
    at how arguments are passed to functions and how they’re used as parameters in
    the function in [Chapter 14](ch14.xhtml). The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    does not need any data from the C hosted environment; we show this in its definition
    by using `void` for the parameter list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C 中调用一个函数时，调用函数可以在调用中包含一个*参数*列表，作为输入传递给被调用的函数。这些输入作为被调用函数中执行计算的*参数*。例如，在[清单
    2-1](ch02.xhtml#ch2list1)中，当程序首次启动时，`main` 函数调用了 `printf` 函数，并传递了一个参数，即文本字符串 ❹。`printf`
    函数使用这个文本字符串来确定屏幕上显示的内容。在[第14章](ch14.xhtml)中，我们将仔细查看参数如何传递给函数，以及它们如何作为参数在函数中使用。[清单
    2-1](ch02.xhtml#ch2list1)中的 `main` 函数不需要来自 C 托管环境的数据；我们通过在其定义中使用 `void` 作为参数列表来表示这一点。
- en: Upon completing execution, a function normally returns to the calling function.
    The called function can pass a data item to the calling function when returning.
    A `main` function should return a single integer to the C hosted environment,
    indicating whether the program detected any errors in its execution. Thus, the
    return-data-type for `main` is `int`. The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    returns the integer 0 to the C hosted environment, which passes this value to
    the operating system.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 2-1](ch02.xhtml#ch2list1), we define two variables in the `main`
    function at the beginning of the function body: an unsigned integer named `an_int`
    and a text string named `a_string` ❸. Most modern programming languages allow
    us to introduce new variables anywhere in the code, but C requires that they be
    listed at the beginning of the function. (There are some exceptions to this rule,
    but they are beyond the scope of this book.) Think of it as listing the ingredients
    for a recipe before giving the instructions on how to use them. We *define* a
    variable by introducing its name and specifying its data type. The `[10]` notation
    tells the compiler to allocate an array of 10 `char`s for the `a_string` variable,
    which will allow us to store a C-style text string up to nine characters long.
    (The 10th `char` would be the terminating `NUL` character.) We’ll look at arrays
    in detail in [Chapter 17](ch17.xhtml).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The program uses the `printf` function from the C standard library to display
    text on the screen. The first argument in the call to `printf` is a *format string*,
    which is a text string made up of ordinary characters (except `%`) to display
    on the screen.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The simplest format string for `printf` is just the text you want printed, without
    any variables. If you want to print the values of variables, the format string
    acts as a template of the text you want printed. The place in the text string
    where you want the value of a variable to be printed is marked with a *conversion
    specifier*. Each conversion specifier begins with the `%` character, and the names
    of the variables are listed after the format string in the same order that their
    respective conversion specifiers appear in the template ❼.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The `%` character that begins a conversion specifier is immediately followed
    by one or more conversion code characters to tell `printf` how to display the
    value of the variable. [Table 2-9](ch02.xhtml#ch2tab9) shows some common conversion
    specifiers for `printf` and `scanf` format strings.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-9:** Some Common Conversion Specifiers'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conversion specifier** | **Representation** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| `%u` | Unsigned decimal integer |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `%d` or `%i` | Signed decimal integer |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Float |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Hexadecimal |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Text string |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: The conversion specifiers can include other characters that specify properties,
    such as the field width of the display, whether the value is left-or right-justified
    within the field, and more. I won’t go into additional detail here; read man [page
    3](ch01.xhtml#page_3) for `printf` to learn more (enter the man 3 printf command
    to view the man page).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The first argument in the call to the C standard library function `scanf` is
    also a format string. We use the same conversion specifiers in the format string
    to tell the `scanf` function how to interpret the characters typed on the keyboard
    ❺. We tell `scanf` where to store the input integer by using the *address of*
    operator on the variable name, `&an_int`. When passing the name of an array to
    a function, C sends the address of the array, so we don’t use the `&` operator
    when calling `scanf` to read a text string from the keyboard ❻.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Any other character included in the format string for `scanf` besides these
    conversion specifiers must be matched exactly by the keyboard input. For example,
    the format string
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: requires an input like
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which would read the integers 123 and 456 from the keyboard. You can read man
    [page 3](ch01.xhtml#page_3) for `scanf` to learn more (enter the man 3 scanf command).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `main` function returns 0 to the C hosted environment, which passes
    this value to the operating system. The value 0 tells the operating system that
    everything went smoothly ❽.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling and running the program in [Listing 2-1](ch02.xhtml#ch2list1) on
    my computer gave the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The program in [Listing 2-1](ch02.xhtml#ch2list1) demonstrates an important
    concept: hexadecimal is used as a human convenience for stating bit patterns.
    A number is not inherently binary, decimal, or hexadecimal; it’s simply a value.
    And a specific value can be expressed equivalently in each of these three number
    bases. For that matter, it can be expressed equivalently in *any* number base
    (2, 16, 285, and so forth), but since a computer consists of binary switches,
    it makes sense to think of numerical values stored in a computer in terms of the
    binary number base.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '2.16     Write a hexadecimal-to-decimal converter program in C. Your program
    will allow a user to enter a number in hexadecimal and will then print the decimal
    equivalent. The output should look like this: `0x7b = 123`.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '2.17     Write a decimal-to-hexadecimal converter program in C. Your program
    will allow a user to enter a number in decimal and will then print the hexadecimal
    equivalent. The output should look like this: `123 = 0x7b`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 2.18     Change `%u` to `%i` in the last `printf` statement in the program in
    [Listing 2-1](ch02.xhtml#ch2list1). What does the program print if you enter `ffffffff`?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining Memory with a Debugger**'
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve started writing programs, you’ll need to learn how to use the
    GNU debugger, `gdb`. A *debugger* is a program that allows you to run your program
    while you observe and control its behavior. When you use a debugger, it’s a little
    like you’re a puppeteer and your program is a carefully controlled puppet. Your
    main instrument of control is the *breakpoint*; when you set a breakpoint and
    your program reaches it while running, the program will pause and return control
    to the debugger. When control is with the debugger, you can look at the values
    stored in your program’s variables, which can help you figure out where any bugs
    are.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: If all this seems premature—our programs so far are simple and don’t seem to
    require debugging—I promise that it’s much better to learn how to use a debugger
    on a simple example than on a complicated program that does not work. `gdb` is
    also a valuable tool for learning the material in this book, even when you write
    bug-free programs. In the following `gdb` session dialog, I’ll show you how to
    determine where a variable is stored in memory and how to see what is stored there,
    both in decimal and in hexadecimal. You will see how to use `gdb` on a live program
    to illustrate the concepts discussed on the previous pages.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see more in [Chapters 9](ch09.xhtml) and [10](ch10.xhtml), but the `gdb`
    commands listed here should be enough to get you started:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: b source_filename:line_number   Set a breakpoint at the specified line_number
    in the source file, source_filename. The code will stop running at the breakpoint,
    when line_number is encountered, and return control to `gdb`, allowing you to
    test various elements of the code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: c   Continue program execution from the current location.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: h command   Get help on how to use command.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: i r   Show the contents of the registers (*info registers*). (You’ll learn about
    CPU registers in [Chapter 9](ch09.xhtml).)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: l line_number   List 10 lines of the source code, centered at the specified
    line_number.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: print expression   Evaluate expression and print the value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: printf "format", var1, var2, ..., varn   Display the values of var1`,` var2`,
    ...,` varn in a given format. The `"`format `"` string follows the same rules
    as for `printf` in the C standard library.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: r   Run a program that has been loaded under the control of `gdb`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: x/nfs memory_address   Display (examine) n values in memory in format f of size
    s starting at memory_address.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Your Debugger***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s walk through the program in [Listing 2-1](ch02.xhtml#ch2list1) using `gdb`
    to explore some of the concepts covered thus far. Follow along on your computer
    as you read this; it’s much easier to understand `gdb` when you’re using it. Note
    that the addresses you see on your computer will probably be different than those
    in this example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by compiling the program using the `gcc` command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-g` option tells the compiler to include debugger information in the executable
    program. The `-Wall` option tells the compiler to issue warnings about things
    in your code that are correct C code but still might not be what you intended
    to write. For example, it will warn you about declaring a variable in your function
    that is never used, which could mean you’ve forgotten something.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The `-o` option specifies the name of the output file, which is the executable
    program.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Having compiled the program, I can run it under the control of `gdb` using
    this command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `gdb` startup message, which I’ve removed from the previous output to save
    space, contains information about your debugger and refers you to its usage documentation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The `l` command lists 10 lines of source code and then returns control to the
    `gdb` program, as shown by the `(gdb)` prompt. Press ENTER to repeat the previous
    command, and `l` displays the next (up to) 10 lines.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'A breakpoint is used to stop the program and return control to the debugger.
    I like to set breakpoints where a function is about to call another function so
    I can examine the values in the argument variables before they are passed to the
    called function. This `main` function calls `printf` on line 15, so I set a breakpoint
    there. Since I’m already looking at the source code where I want to set a breakpoint,
    I don’t need to specify the filename:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If `gdb` ever gets to this statement while executing the program, it will pause
    *before the statement is executed* and return control to the debugger.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Having set my breakpoint, I run the program:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `r` command starts executing the program from the beginning. When the program
    reaches the breakpoint, control returns to `gdb`, which displays the next program
    statement that is ready to be executed. Before continuing execution, I display
    the contents of the two variables that are being passed to the `printf` function:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use the `print` command to display the value currently stored in a variable.
    `gdb` knows the data type of each variable from the source code. It displays `int`
    variables in decimal. When displaying `char` variables, `gdb` will do its best
    to display the character glyph corresponding to the code point value. When there
    is no corresponding character glyph, `gdb` shows the code point as a `\` followed
    by three *octal* digits (see [Table 2-2](ch02.xhtml#ch2tab2)). For example, there
    is no character glyph for `NUL`, so `gdb` shows `\000` at the end of the text
    string I entered.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printf` command can format the displayed values. The formatting string
    is the same as for the `printf` function in the C standard library:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`gdb` provides another command, `x`, for examining the content of memory (that
    is, the actual bit patterns) directly. Its help message is brief, but it tells
    you everything you need to know:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `x` command needs the address of the area of memory to show. We can use
    the `print` command to find the address of a variable:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the `x` command to display the content of `an_int` in three different
    ways—one decimal word (`1dw`), one hexadecimal word (`1xw`), and four hexadecimal
    bytes (`4xb`)—as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**NOTE**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '*The size of a* word *depends upon the computer environment you are using.
    In our environment, it’s 4 bytes.*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The display of these four bytes may look out of order to you. The first byte
    ❶ is located at the address shown on the left of the row. The next byte in the
    row is at the subsequent address, `0x7fffffef7d`. So, this row displays each of
    the bytes stored at the memory addresses `0x7fffffef7c`, `0x7fffffef7d`, `0x7fffffef7e`,
    and `0x7fffffef7f`, reading from left to right, that make up the variable `an_int`.
    When displaying these same four bytes separately, the least significant byte appears
    *first* in memory. This is called *little-endian* storage order; I’ll explain
    further after this tour of `gdb`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also display the content of the `a_string` variable by first getting
    its address:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we’ll look at the content of `a_string` in two ways, as 10 characters
    (`10c`) and as 10 hexadecimal bytes (`10xb`):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The character display shows the code point in decimal and the character glyph
    for each character. The hexadecimal byte display shows only the code point in
    hexadecimal for each byte. Both displays show the `NUL` character that marks the
    end of the six-character string we entered. Since we asked for a 10-byte display,
    the remaining 3 bytes have random values not related to our text string, often
    called *garbage values*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I continue execution of the program and then quit `gdb`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***Understanding Byte Storage Order in Memory***'
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The difference between the full 4-byte display and the 1-byte display of the
    integer value at `0x7fffffef7c` in memory illustrates a concept known as *endianness*,
    or byte storage order. We usually read numbers from left to right. The digits
    to the left have more significance (count for more) than the digits to the right.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '##### **Little-Endian**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Data is stored in memory with the *least* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “littlest” byte (counts the
    least) comes first in memory.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'When we examine memory one byte at a time, each byte is displayed in numerically
    ascending addresses:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At first glance, the value appears to be stored backward, because the least
    significant (“little end”) byte of the value is stored first in memory. When we
    command `gdb` to display the entire 4-byte value, it knows that ours is a little-endian
    environment, and it rearranges the display of the bytes in the proper order:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Big-Endian**'
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Data is stored in memory with the *most* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “biggest” byte (counts the
    most) comes first in memory.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran the previous program on a big-endian computer, such as one using
    the PowerPC architecture, we would see the following (assuming the variable is
    located at the same address):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That is, the 4 bytes in a big-endian computer would be stored as:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, `gdb` would know that this is a big-endian computer and so would display
    the full 4-byte value in the proper order.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of programming situations, endianness is not an issue.
    However, you need to know about it because it can be confusing when examining
    memory in the debugger. Endianness is also an issue when different computers communicate
    with each other. For example, *Transport Control Protocol/Internet Protocol (TCP/IP)*
    is defined to be big-endian, sometimes called *network byte order*. The instructions
    in the AArch64 architecture are stored in little-endian order. The data can be
    stored in either order, but the default in our environment is little-endian, and
    the operating system reorders the bytes for internet communication. You also need
    to know about byte order if you’re writing communications software for an operating
    system itself or for an embedded system that may not have an operating system.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 2.19     Enter the program in [Listing 2-1](ch02.xhtml#ch2list1). Follow through
    the program with `gdb`. Using the numbers you get, explain where the variables
    `an_int` and `a_string` are stored in memory and what is stored in each location.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bits**   A computer is a collection of on/off switches that we can represent
    with bits.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   This is a number system based on 16\. Each hexadecimal digit,
    `0` to `f`, represents 4 bits.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte**   This is a group of 8 bits. The bit pattern can be expressed as two
    hexadecimal digits.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting between decimal and binary**   The two number systems are mathematically
    equivalent.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory addressing**   Bytes in memory are numbered (addressed) sequentially.
    The byte’s address is usually expressed in hexadecimal.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '**Endianness**   An integer that is more than 1 byte can be stored with the
    highest-order byte in the lowest byte address (big-endian) or with the lowest-order
    byte in the lowest byte address (little-endian). Our environment is little-endian.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-8 encoding**   This is a code for storing characters in memory.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '**String**   A C-style string is an array of characters terminated by the `NUL`
    character.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: printf   This C library function is used to write formatted data on the screen.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: scanf   This C library function is used to read formatted data from the keyboard.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**   The `gdb` debugger can be used to see how the variables change
    at each step in the execution of a program.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about addition and subtraction in the binary
    number system for both unsigned and signed integers. This will illuminate some
    of the potential errors inherent in using a fixed number of bits to represent
    numerical values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
