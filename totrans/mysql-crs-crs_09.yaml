- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing Values
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses comparing values in MySQL. You’ll practice checking whether
    values are equal, whether one value is greater or less than another value, and
    whether a value falls within a specific range or matches a pattern. You’ll also
    learn how to check that at least one condition in your queries is met.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values can be useful in a variety of scenarios. For example, you might
    want to check that an employee worked 40 or more hours, that a flight’s status
    is not canceled, or that the average temperature of a vacation destination is
    between 70 and 95 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use MySQL’s comparison operators, shown in [Table 7-1](#table7-1), to
    compare values in your queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: MySQL Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol or keyword(s)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Equal |'
  prefs: []
  type: TYPE_TB
- en: '| `!=, <>` | Not equal |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `is null` | A null value |'
  prefs: []
  type: TYPE_TB
- en: '| `is not null` | A non-null value |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Matches a value in a list |'
  prefs: []
  type: TYPE_TB
- en: '| `not in` | Doesn’t match a value in a list |'
  prefs: []
  type: TYPE_TB
- en: '| `between` | Within a range |'
  prefs: []
  type: TYPE_TB
- en: '| `not between` | Not within a range |'
  prefs: []
  type: TYPE_TB
- en: '| `like` | Matches a pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `not like` | Does not match a pattern |'
  prefs: []
  type: TYPE_TB
- en: These operators let you compare values in a database to other values. You can
    choose to select data if it meets the criteria you define using these comparison
    operators. Let’s discuss them in depth, using various databases as examples.
  prefs: []
  type: TYPE_NORMAL
- en: Equal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The equal operator, introduced in [Chapter 5](c05.xhtml), lets you check that
    values are equal to each other to achieve specific results. For example, here
    you use `=` with the `wine` database table from [Chapter 6](c06.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This query selects all countries from the `country` table that have a `country_id`
    equal to `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following query, you’re using `=` with a string, rather than a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This query selects all wines from the `wine_type` table with the name Merlot—that
    is, a `wine_type_name` equal to `Merlot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query is similar to what you saw in [Chapter 5](c05.xhtml) when
    you were learning how to join two tables. Here you’re using `=` to compare values
    that come from two tables with a common column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This query joins all equal values from the `region` and `country` tables’ `country_id`
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each of these examples, the `=` syntax checks that the value on the left
    of the operator is the same as the value on the right of it. You can also use
    `=` with a subquery that returns one row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `=` in this way, you’re checking for rows in the outer query where the
    `country_id` column in the `region` table matches the results of an entire subquery.
  prefs: []
  type: TYPE_NORMAL
- en: Not Equal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not equal is expressed by the `<>` or `!=` symbols, where the `<` symbol is
    *less than* and the `>` symbol is *greater than* (so `<>` means less than or greater
    than), and the `!` symbol means *not* (so `!=` means not equal). The `!=` and
    `<>` operators do the same thing, so it doesn’t matter which syntax you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The not equal operator is useful for excluding certain data from the results
    of your queries. For example, maybe you’re a banjo player looking for fellow musicians
    to start a band. Since you play banjo, you can eliminate it from the list of instruments
    you want to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve used the `not equal` operator on the `musical_instrument` table
    to exclude the banjo from the list of instruments returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you’re planning a wedding and you have a prior commitment on February 11,
    2024, so you need to exclude that date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ve excluded 2/11/2024 from a list of potential wedding dates in your
    `possible_wedding_date` table.
  prefs: []
  type: TYPE_NORMAL
- en: Greater Than
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The greater than operator checks that the value on the left is greater than
    the value on the right. It is expressed using the `>` symbol. Say you’re looking
    for jobs that have a `salary` greater than $100,000 and a `start_date` after 1/20/2024\.
    You can select jobs that match these requirements from the `job` table using the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this query, only the jobs that meet both conditions will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Greater Than or Equal To
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Greater than or equal to is expressed using the `>=` symbol. For example, you
    can edit your previous query to select all jobs where the `salary` is $100,000
    or higher and that have a `start_date` of 1/20/2024 or later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `>` and `>=` is that `>=` includes the value listed in
    its results. In the previous examples, a job with a `salary` of *exactly* $100,000
    will be returned by `>=` but not by `>`.
  prefs: []
  type: TYPE_NORMAL
- en: Less Than
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Less than is expressed using the `<` symbol. For example, to view all games
    starting before 10 PM, you can perform the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In MySQL, time is expressed in military format, which operates on a 24-hour
    clock.
  prefs: []
  type: TYPE_NORMAL
- en: Less Than or Equal To
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Less than or equal to* is expressed using the `<=` symbol. You can expand
    the previous query to select all rows where the `game_time` is 10 PM or earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the `game_time` is exactly 22:00 (10 PM), a row will be returned when you
    use `<=` but not when you use `<`.
  prefs: []
  type: TYPE_NORMAL
- en: is null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As discussed in Chapters 2 and 3, `null` is a special value indicating that
    data is not applicable or not available. The `is null` syntax allows you to specify
    that you want only null values to be returned from a table. For example, say you
    want to query the `employee` table to see a list of employees who have not retired
    or set a retirement date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now only rows with a `retirement_date` of `null` are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s only possible to check null values with the `is null` comparison operator.
    For example, using `= null` won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even though there are null values in the table, this syntax won’t return any
    rows. In this scenario, MySQL doesn’t throw an error, so you might not realize
    that the wrong data is being returned.
  prefs: []
  type: TYPE_NORMAL
- en: is not null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use `is not null` to check for values that are *not* null. Try reversing
    the logic of the previous example to check for employees who have retired or set
    a retirement date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the query returns rows with a `retirement_date` that is not `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `is null`, you have to use the `is not null` syntax for this type of
    query. Using other syntax, like `!= null` or `<> null`, will not produce the correct
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you saw earlier with `= null`, MySQL won’t return any rows when you try to
    use the `!= null` syntax, and won’t alert you with an error.
  prefs: []
  type: TYPE_NORMAL
- en: in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `in` keyword to specify a list of multiple values you want
    your query to return. For example, let’s revisit the `wine` database to return
    specific wines from the `wine_type` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will return rows where the `wine_type_name` is Chardonnay or Riesling.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `in` with a subquery to select a list of wine types that are
    in another table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instead of providing a hardcoded list of wine types to return in your results,
    here you’re selecting all of the wine types from the `cheap_wine` table.
  prefs: []
  type: TYPE_NORMAL
- en: not in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To reverse the previous example’s logic and exclude certain wine types, you
    can use `not in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This returns all rows where the `wine_type_name` is not Chardonnay or Riesling.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select wines that are not from the `cheap_wine` table, you can use `not
    in` within a subquery as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This query excludes wine types from the `cheap_wine` table.
  prefs: []
  type: TYPE_NORMAL
- en: between
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `between` operator to check that a value is within a specified
    range. For example, to list the millennials in a `customer` table, search for
    people who were born between 1981 and 1996:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `between` keyword is *inclusive*. This means it checks for every `birthyear`
    within the range, *including* the years 1981 and 1996.
  prefs: []
  type: TYPE_NORMAL
- en: not between
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check that a value is not within a range by using the `not` `between`
    operator. Use the same table from the previous example to find customers who are
    *not* millennials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `not between` operator returns the opposite list of customers that `between`
    did, and is *exclusive*. Customers born in 1981 or 1996 will be *excluded* by
    this query since they are part of the `between 1981 and 1996` group.
  prefs: []
  type: TYPE_NORMAL
- en: like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `like` operator allows you to check if a string matches some pattern. For
    example, you can use `like` to find books from No Starch Press by checking if
    a book’s ISBN contains the No Starch publisher code, 59327.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the pattern to match, you use one of two wildcard characters with
    the `like` operator: percent (`%`) or underscore (`_`).'
  prefs: []
  type: TYPE_NORMAL
- en: The % Character
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The percent wildcard character matches any number of characters. For example,
    to return a list of billionaires whose last name starts with the letter *M*, you
    can use the `%` wildcard character along with `like`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Your query will find billionaires whose last name starts with an *M* followed
    by zero or more other characters. This means that `like ''M%''` would match only
    the letter *M* with no characters after it, or *M* followed by a few characters,
    like `Musk`, or *M* followed by many characters, like `Melnichenko`. The results
    of your query might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use two `%` characters to find a character located anywhere in the
    string, whether at the beginning, in the middle, or at the end. For example, the
    following query looks for billionaires whose last names contain the letter *e*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The results might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While the syntax `last_name like '%e%'` is handy, it can cause your query to
    run slower than normal. That’s because when you use the `%` wildcard at the beginning
    of a search pattern, MySQL can’t take advantage of any indexes on the `last_name`
    column. (Remember, indexes help MySQL optimize your queries; for a refresher,
    see the section “Indexes” in [Chapter 2](c02.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: The _ Character
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The underscore wildcard character matches any character. For example, say you
    need to find a contact and you can’t remember if her name was Jan or Jen. You
    might write a query to select names that start with *J*, followed by the wildcard
    character, followed by *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you use the underscore wildcard to return a list of three-letter terms
    that end in *at*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The results might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: not like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `not like` operator can be used to find strings that do *not* match some
    pattern. It also uses the `%` and `_` wildcard characters. For example, to reverse
    your logic for the `like` example, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are words in the `three_letter_term` table that do not end in *at*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can find billionaires whose last names do not start with the
    letter *M* using this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The results might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `exists` operator checks to see if a subquery returns at least one row.
    Here you go back to the `customer` table in the `not between` example and use
    `exists` to see whether the table has at least one millennial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are millennials in the `customer` table, so your result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If there had been no customers born between 1981 and 1996, your query wouldn’t
    have returned any rows, and the text `There is at least one millennial in this
    table` would not have been shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see the same query written using `select 1` instead of `select *`
    in the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this query, it doesn’t matter if you select `*` or `1` because you’re looking
    for at least one customer that matches your description. All you really care about
    is that the inner query returned *something*.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](c04.xhtml), you learned that booleans can have one of two values:
    `true` or `false`. You can use special syntax, `is true` or `is false`, to return
    only results with one value or the other. In this example, you return a list of
    employed bachelors in the `bachelor` table by using the `is true` syntax in the
    `employed_flag` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This query causes MySQL to return only rows for bachelors who are employed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check bachelors whose `employed_flag` value is set to `false`, use `is false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now MySQL returns only rows for bachelors who are unemployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the value of boolean columns in other ways as well. These lines
    are all equivalent ways of checking for `true` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines are all equivalent ways to check for `false` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, a value of `1` is equivalent to `true` and a value of `0`
    is equivalent to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: or Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use MySQL’s `or` keyword to check that at least one of two conditions
    has been met.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this table called `applicant`, which contains information about job
    applicants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `associates_degree_flag` and `bachelors_degree_flag` columns are booleans,
    where `0` represents `false` and `1` represents `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following query, you select from the `applicant` table to get a list
    of qualified applicants for a job that requires a bachelor’s degree *or* two or
    more years of experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Say you need to write a query with both the `and` (both conditions must be met)
    and `or` (either condition must be met) keywords. In this case, you can use parentheses
    to group your conditions so that MySQL will return the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how using parentheses can be beneficial. Here you create another
    query with the `applicant` table for a new job that requires applicants to have
    two or more years’ experience *and* either an associate’s degree *or* a bachelor’s
    degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of this query are not what you expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Bill doesn’t have two or more years’ experience, so why did he appear in your
    result set?
  prefs: []
  type: TYPE_NORMAL
- en: 'The query uses both an `and` and an `or`. The `and` has a higher *operator
    precedence* than the `or`, which means `and` gets evaluated before `or`. This
    caused your query to find applicants that met at least one of the following two
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Two or more years’ experience *and* an associate’s degree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*or*'
  prefs: []
  type: TYPE_NORMAL
- en: A bachelor’s degree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s not what you intended when you wrote the query. You can correct the
    problem by using parentheses to group your conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the query finds applicants that meet these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Two or more years’ experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*and*'
  prefs: []
  type: TYPE_NORMAL
- en: An associate’s degree *or* a bachelor’s degree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your results should now be in line with your expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned various ways to compare values in MySQL through
    comparison operators, such as checking whether values are equal, null, or within
    a range, or if they match a pattern. You also learned how to check that at least
    one condition is met in your queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll take a look at using MySQL’s built-in functions,
    including those that deal with mathematics, dates, and strings. You’ll also learn
    about aggregate functions and how to use them for groups of values.
  prefs: []
  type: TYPE_NORMAL
