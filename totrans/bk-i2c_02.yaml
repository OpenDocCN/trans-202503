- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I²C Low-Level Hardware
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The I²C bus is a worldwide standard for communication between integrated circuits
    (ICs) on printed circuit boards (PCBs) and across multiple PCBs within a system.
    According to NXP Semiconductors, I²C is in use on more than 1,000 different ICs
    made by more than 50 different manufacturers. Without question, I²C is one of
    the more popular inter-IC data communication schemes available (Serial Peripheral
    Interface [SPI] being another).
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of the I²C bus increased with the introduction of hobbyist-level
    single-board computers (SBCs) such as the Arduino and Raspberry Pi that include
    I²C support. Today, tens of thousands of programmers have learned the basics of
    the I²C bus because they wanted to interface some device to an Arduino- or Pi-class
    system. Because of the vast amount of open source library code available, it is
    possible to use and program devices on the I²C bus without really understanding
    its low-level signal protocols. However, to truly make the most of a design employing
    I²C peripherals, you need to understand those protocols, both hardware and software.
    This chapter introduces the low-level hardware aspects of the I²C, which you’ll
    need to understand before learning about the signal protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 I²C Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before buses such as the I²C bus, different components of a computer system
    communicated with one another using traditional CPU-style buses. These buses typically
    used 8 to 32 data lines and some number of address signals. Connecting a single
    8-bit parallel I/O device to a CPU required a fair amount of PCB space to hold
    all the signal traces. Of course, adding additional I/O increased signal, space,
    and noise accordingly. In addition to space, those lines also increased the amount
    of noise that system engineers had to deal with in their designs.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C bus was invented to alleviate these problems. With the I²C bus, a single
    pair of signal lines (PCB traces) can connect a wide variety of different I/O
    peripherals to a CPU. This reduces cost and eliminates many problems when building
    complex (embedded) computer systems (see the text box “Advantages of the I²C Bus”
    for more information).
  prefs: []
  type: TYPE_NORMAL
- en: 'I²C devices are divided into two general categories: controller devices (formerly
    known as masters) and peripheral devices (formerly slaves). A *controller device*,
    as its name suggests, controls the communication between the controller and the
    peripheral device. The *peripheral device* does not initiate any communication
    on its own and relies on the controller to manage the communication process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The I²C protocol is a synchronous serial communication using two signal lines:
    *SCL*, which stands for “serial clock,” and *SDA*, which stands for “serial data.”
    The controller drives the clock line. When the peripheral is sending data to the
    controller, it puts the data bits on the data line; when the peripheral is receiving
    data, the controller places the serial data bits on the data line. Except for
    one special case—clock stretching, discussed later in this chapter—the peripheral
    never controls the clock line.'
  prefs: []
  type: TYPE_NORMAL
- en: A typical system has a single controller and one or more peripheral devices.
    Each peripheral device has an address unique to a given I²C bus, which the controller
    uses to differentiate multiple peripherals on the same bus. In theory, a single
    I²C bus supports up to 127 or even 1,024 different peripheral devices, though
    practical matters limit the number of peripheral devices to a much smaller number.
  prefs: []
  type: TYPE_NORMAL
- en: Although a typical system has only a single controller, the I²C bus supports
    multiple controllers on the same bus. This allows multiple controllers to share
    a common set of peripheral devices. A given system can also support multiple I²C
    buses, so peripheral devices with the same address, which cannot be used together
    on the same I²C bus, can still be deployed in a given system.
  prefs: []
  type: TYPE_NORMAL
- en: The controller-peripheral relationship is fundamental to the I²C protocol. While,
    in theory, it is possible for a single IC to behave either as a controller or
    as a peripheral and even switch between these two functions in a given system,
    such activity is rare; in general, a device functions either as a peripheral or
    as a controller within a system.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Open-Drain (Open-Collector) Logic and Four-Wire Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most fundamental electrical aspects of the I²C bus is that it is
    based on an open-drain (or open-collector) logic system. That is, a device connected
    to the I²C bus does not *drive* the signal lines high or low; instead, it can
    only *pull* these lines low using an open-drain (FET) connection. Pullup resistors
    that connect the signal lines on the I²C bus to a power supply pull the two bus
    lines, SDA and SCL, high by default. This design allows multiple controllers and
    peripherals to control the data and clock lines without running into problems
    associated with connecting multiple output pins to the same signal line.
  prefs: []
  type: TYPE_NORMAL
- en: To place a logic 1 on one of the lines, a device puts its open-drain (or open-collector,
    if using bipolar devices) into the high-impedance state. This allows the default
    logic 1 to appear on the line, placed there by the pullup resistor. To place a
    logic 0 on one of the lines, the device activates its open-drain device, which
    shorts the line to ground.
  prefs: []
  type: TYPE_NORMAL
- en: Most I²C devices provide open-drain signals to connect to the I²C bus, so you
    don’t need to have any additional hardware to interface such devices to the bus.
    However, it is also possible to connect arbitrary logic devices to the I²C bus
    by routing them through a bipolar transistor (open-collector), JFET, MOSFET, or
    other open-drain device to control the electrical access to the I²C bus. The following
    subsection provides an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SDA and SCL lines, by definition, are bidirectional on the controller device
    and are often bidirectional on peripheral devices. Certain single-board computers
    or CPUs might not support digital I/O pins that can operate in a bidirectional
    mode—that is, they can be programmed only as an input pin or an output pin. To
    resolve this, some system designers implement I²C in *four-wire mode*. In four-wire
    mode the I²C bus still has two wires, but the controller uses two wires to implement
    each of the signals: two output pins and two input pins. [Figure 1-1](#figure1-1)
    diagrams this four-wire controller connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c01/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Four-wire controller connection'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent electrical conflicts (connecting two outputs together), the output
    pins drive the base of a transistor (gate on a FET or MOSFET), and the collector
    (drain) connects to the appropriate bus line. Then the controller CPU can simultaneously
    read the data on the bus lines using the input pins while writing data on the
    output pins with no electrical conflict and without support for bidirectional
    I/O pins.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 I²C Signal Levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the I²C was designed in the early 1980s, 5 V logic was the prevalent design
    technology, so the original I²C assumed the use of 5-V logic signals. However,
    as the I²C bus is based on open-drain connections, the high voltage level is completely
    determined by the power supply that the pullup resistors connect to when designing
    the system. As computer systems started using 3.3 V or even down to 1.8 V, system
    designers began hooking up those pullup resistors to power supplies other than
    5 V.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the I²C bus, as long as the controllers and peripherals
    can handle and properly work with the voltage levels appearing on the bus, any
    voltage *should* work fine. In reality, however, some voltages may cause problems.
    For this reason, recent I²C standards state that the voltage on the bus must be
    at least 2 V (so 1.8-V logic won’t work). They also specify that a logic high
    is defined as greater than 70 percent of the power supply voltage and a logic
    low is defined as less than 30 percent of the power supply voltage. Today, generic
    I²C devices almost always expect 5-V or 3.3-V logic.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 Level Shifting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens if you want to mix 3.3-V and 5-V I²C devices on the same bus? Sending
    a 3.3-V signal into a 5-V device probably won’t damage it, but the device may
    not interpret 3.3 V as a logic 1, because the standard calls for a logic 1 are
    equal to 3.5 V on a 5-V system (70 percent of 5 V is 3.5 V). Sending a 5-V signal
    into a 3.3-V device is far worse; often, this will destroy the device. Clearly,
    you should avoid this situation at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: When mixing 3.3-V and 5-V (or other different voltage range) devices on the
    same I²C bus, you must use *voltage translation*, or *level shifting*, to convert
    the actual voltage on the bus to something that is compatible with the device(s).
    NXP Semiconductors provides a technical note describing how to do this using discrete
    MOSFETs (see “For More Information” at the end of this chapter). Another solution
    is to purchase a commercial-off-the-shelf (COTS) part such as the Adafruit, four-channel,
    I²C-safe, bidirectional logic level converter (BSS138). The Adafruit BSS138 device
    provides a bridge between two I²C buses operating at 3.3 V and 5 V—or, if you
    need a larger voltage range, it’s rated down to 1.8 V and up to 10 V. As I’m writing
    this, these Adafruit devices cost about $4 each (US) and support two independent
    I²C bus level shifters (the I²C bus requires two level shifters, one for the SDA
    line and one for the SCL line).
  prefs: []
  type: TYPE_NORMAL
- en: A third option is to level-shift with the TCA9548A I²C multiplexer device. This
    IC will split the I²C bus into eight separately controlled I²C buses. Each independent
    bus can have its own pullup resistor to an independent power supply (for example,
    3.3 V or 5 V). Therefore, you can put the 3.3-V devices on one bus and the 5-V
    devices into another. The incoming bus (from the CPU to the TCA9548A) can be either
    voltage. See Chapter 12 for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Choosing Pullup Resistor Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing resistor sizes for the SDA and SCL pullup resistors requires a bit
    of thought. While I won’t go into the heavy math behind this choice, keep in mind
    that pullup resistors should be somewhere in the range of 1 kΩ to about 20 kΩ
    based on the supply voltage and bus capacitance. The higher the bus capacitance
    (in particular, the longer your I²C bus lines are), the lower the resistor should
    be. The minimum value is generally determined by the power supply voltage. For
    3.3-V systems, you can go to slightly below 1 kΩ, if you have to. For 5-V systems,
    1.5 kΩ is probably as low as you should go.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, most systems start out with 4.7-kΩ pullups and go down from there
    if necessary. Note that if you are using commonly available COTS parts, such as
    breakout boards from Adafruit, SparkFun, or Seeed Studio, the boards often have
    pullup resistors already installed. If you attach two or more of these devices
    to your system, you have to compute the final resistance using a parallel resistance
    calculation (1/*R* = 1/*R*[1] + 1/*R*[2] + . . . + 1/*R*[*n*]). This means if
    you install two boards, each with a 4.7-kΩ pullup, you’ve actually got 2.35-kΩ
    pullups on the two lines. If you add too many of these boards on the same bus,
    you can wind up with pullup values below the minimum suggested resistances.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Bus Capacitance and Pullup Resistor Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The speed of the I²C bus, which I’ll discuss further in the next section, is
    largely determined by the value of the pullup resistors (*R*[*p*]) and the bus
    capacitance (*C*[*p*]). Although the system designer has direct control over the
    value of the pullup resistors, bus capacitance is mostly a function of two things:
    input capacitance of the devices connected to the bus, and the length of the bus
    itself. Capacitance increases with bus length, as does resistance, though only
    by a small and generally insignificant amount. Why do these two parameters affect
    bus speed?'
  prefs: []
  type: TYPE_NORMAL
- en: From electronics theory you know that the product of resistance and capacitance
    is time. In particular, 1 Ω × 1 farad = 1 second. When a device pulls one of the
    bus lines low or releases a bus line so that the pullup resistor returns the signal
    high, the bus capacitance and resistance affect the amount of time it takes for
    the signal to rise or fall. If this time exceeds a certain value, the I²C bus
    will not be able to operate at its full rated speed.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C standard limits bus capacitance to 400 pF (*picofarads*, each of which
    is one trillionth of a farad). A typical pullup resistor on the I²C bus is between
    1 kΩ and 10 kΩ. This produces rise times in the range of 0.4 μsec (*microseconds*)
    to 4 μsec. If the I²C bus is operating at 100 kHz (that is, a 10-μsec period),
    a 10-kΩ pullup (4-μsec rise time) will likely not work out well. The solution
    is to reduce the capacitance or the resistance.
  prefs: []
  type: TYPE_NORMAL
- en: The primary way to reduce bus capacitance is to keep the bus as short as possible.
    Longer bus lines dramatically increase the bus capacitance. You can also reduce
    bus capacitance by putting fewer I²C devices on the bus. If you must put a fixed
    number of devices on the bus, you can reduce the number of devices on a given
    bus by using two separate buses.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, another solution to reducing the rise time is to reduce the value
    of the pullup resistor. Using a 4.7-kΩ resistor rather than a 10-kΩ resistor,
    for example, cuts the rise time by about one half.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.1 What If the Bus Capacitance Is Too High?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reducing bus capacitance can be a difficult process. Shortening the I²C bus
    length is the primary approach. You can also use better cabling if the I²C signals
    are transmitted across wires, or you can reduce the number of devices on the bus
    (for example, move half the devices to a second I²C bus).
  prefs: []
  type: TYPE_NORMAL
- en: 'If these solutions are impossible or insufficient, reduce the bus speed. If
    you’re running at 400 kHz, drop down to 100 kHz; if you’re already at 100 kHz,
    drop down to 50 kHz, and so on. If this doesn’t solve the problem, a major circuit
    redesign may be necessary. Another solution to consider at this point is a differential
    bus driver like the SparkFun QwiicBus Kit: [https://www.sparkfun.com/products/17250](https://www.sparkfun.com/products/17250).'
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 I²C Bus Speeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed, the I²C bus has two signal lines: serial data and serial clock.
    Controllers transmit data to and from peripherals on the SDA line. The SCL line
    controls the speed at which this serial data transfer takes place. The frequency
    of the signal on the SCL line controls how fast data moves between the controller
    and peripheral devices. The I²C bus standard defines the following data transfer
    rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard mode*: 100-kHz SCL frequency, transferring data between devices at
    100 kbit/sec'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fast mode*: 400-kHz SCL frequency, transferring data between the controller
    and peripherals at 400 kbit/sec'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fast mode plus*: 1-MHz SCL frequency, transferring data between the controller
    and peripherals at 1 Mbit/sec'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*High-speed mode*: Up to 3.4-MHz SCL frequency, transferring data between the
    controller and peripherals at up to 3.4 Mbit/sec'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ultra-fast mode*: 5-MHz SCL frequency, though data transmission is unidirectional
    only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, the upper bound on the I²C bus frequency is largely determined
    by the bus capacitance pullup resistors on the bus. However, there generally isn’t
    a lower bound on the frequency. Indeed, many peripheral devices will actually
    freeze data transmission using *clock stretching* (see section 1.9, “Clock Stretching,”
    later in this chapter) to provide the peripheral time to process data coming from
    the controller, which effectively reduces the clock speed and average data transmission
    speed. Furthermore, there is no requirement that the controller device place a
    100-kHz signal (or whatever frequency) on the SCL line. It could run SCL at 50
    kHz or any other frequency less than the usual clock speed, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: The SCL signal is *not* a free-running clock. The I²C controller explicitly
    toggles this line when it shifts a bit onto the SDA line. When the controller
    is not transmitting or receiving data on the SDA line, the controller leaves the
    SCL line programmed high. The I²C bus frequency, therefore, is the SCL frequency
    during data transactions on the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the main limitation on the I²C bus speed is that you have to run the
    bus at the speed of the slowest devices on the bus. If there is a 100-kbit/sec
    peripheral on the bus, you must run the bus at 100 kHz, even when communicating
    with 400-kbit/sec (or faster) peripherals on the same bus. Because most I²C-compatible
    ICs are 100- or 400-kbit/sec devices, systems rarely run the I²C bus above 400
    kHz except for some very special hardware-specific cases. Typically, if you want
    to run above 400 kHz, you switch to the SPI bus.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Multicontroller I²C Bus Clock Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I²C bus optionally supports multiple controllers on the same bus, which
    is known as a *multicontroller* *configuration*. In such cases the SCL frequencies
    of the two controllers must match, and they must both support multicontroller
    operation. However, running at the same frequency is not a sufficient condition
    for a multicontroller environment; their clocks must also be synchronized. Two
    controllers operate asynchronously with respect to one other. That is, if the
    bus is currently not being used by either controller, both controllers could decide
    to use the bus at the same time. However, it’s unlikely that both controllers
    will decide to activate their SCL lines at exactly the same instant. The I²C protocol
    requires the two controllers’ clock signals to rise and fall at roughly the same
    time to maintain appropriate timing. To achieve this, the I²C protocol introduces
    a clock synchronization operation that delays the start of one of the signals
    so they rise and fall approximately together after the synchronization operation.
  prefs: []
  type: TYPE_NORMAL
- en: Clock synchronization relies on a feature of an open-drain bus known as *wired-AND
    operation* that simulates a logical-AND circuit without additional hardware. The
    (two-input) logical-AND function produces a true result if and only if its two
    inputs are true. If either or both are false, the logical-AND function produces
    a false result. If you consider two open-drain devices connected to the SCL line,
    the result is equivalent to a logical-AND circuit. If both devices are programmed
    with a 1, so their outputs are in a high-impedance state, the pullup resistor
    on the SCL line pulls the bus high. If either or both devices are programmed such
    that the open-drain output is active, this pulls the SCL line to Gnd, resulting
    in a 0 on the SCL line.
  prefs: []
  type: TYPE_NORMAL
- en: Clock synchronization uses the wired-AND capabilities of the bus to synchronize
    the two clocks between controllers competing for the bus. The first controller
    to pull the SCL line low begins counting off its low period, approximately one
    half of the clock period. Sometime later (still within the low period), the second
    controller pulls the SCL line low. When the first controller reaches the end of
    its low period, it releases the SCL line. However, as the second controller is
    still pulling the SCL line low, it remains low. Later, when the second controller
    releases the SCL line, it goes high since both controllers have released the SCL
    line, as shown in [Figure 1-2](#figure1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c01/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: SCL driven low by multiple controllers'
  prefs: []
  type: TYPE_NORMAL
- en: The first controller should note that the SCL line has not gone high and will
    delay counting off a one-half clock period (with SCL high, its *high period*)
    until it notices that the SCL line has actually gone high, as shown in [Figure
    1-3](#figure1-3). Then both controllers will start counting off the high period
    with the SCL line high. The first to count off the one-half clock period will
    pull the SCL line low; the second should follow shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c01/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: SCL clock synchronization by multiple controllers'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the clocks should be fairly synchronized, with the low SCL period
    being the longest of the two controllers and the high SCL period being the shortest
    of the two. The two controllers will have similar, but not perfectly identical,
    timing for their clock periods.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Multicontroller I²C Bus Arbitration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although synchronizing clocks is a necessary condition to allow multicontroller
    access to the I²C bus, it is not a sufficient condition. Even if two controllers
    have synchronized clocks, they could both be writing different data to the SDA
    line; that would corrupt the data on the bus and yield unreliable results. *Arbitration*
    is the process by which two (or more) controllers decide who can actually control
    the bus.
  prefs: []
  type: TYPE_NORMAL
- en: Before grabbing the I²C bus for its own use, a controller first checks to see
    if the bus is already in use. It does this by looking at the SDA and SCL lines
    for more than one half of a clock period and verifying that both signals remain
    high during this time. If so, it emits an I²C bus *start sequence* (see Chapter
    2) and begins transmitting data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is no guarantee that the bus is actually free after this sequence,
    because a second controller could have started this same process at almost the
    same time. Therefore, the data the two controllers are placing on the bus could
    be in conflict. To detect this problem, the I²C bus arbitration system takes advantage
    of the wired-AND operation of the bus. If both devices write a 1 to the SDA line
    or both devices write a 0 to SDA, this line will correctly reflect the data signals
    being written by both controllers. However, if one controller writes a 0 while
    the other writes a 1, the controller writing the 0 will “win the war” on the SDA
    line—that is, the SDA line will be pulled low. To handle bus arbitration, the
    two controllers always look at the data they write on the SDA line to verify it
    contains what they’ve written. If a controller writes a value to the bus and then
    reads back a different value, then the two controllers have lost the arbitration
    and must stop controlling the bus.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the controllers are checking the data on the SDA line, they
    are also looking at the information appearing on the SCL line to synchronize the
    clocks while arbitrating for the bus.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 Clock Stretching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clock signals are always generated by controller devices on the I²C bus. Controllers
    expect peripheral devices to operate properly at whatever clock frequency the
    controller signals on the SCL line. If the peripheral is incapable of operating
    at that frequency, the controller must be reprogrammed to talk to the peripheral
    at a lower clock speed.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see in the next chapter, data communication on the I²C bus consists
    of a string of 8-bit bytes transmitted to a peripheral with the peripheral acknowledging
    each byte, using an *acknowledge bit*. When transmitting the acknowledge bit back
    to the controller, the peripheral has the option of holding the clock line inactive
    for an arbitrary period of time. As noted in a couple of earlier sections, this
    is known as *clock stretching* (see sections 1.6 and 1.1, “I²C Bus Speeds” and
    “I²C Overview,” respectively). It effectively pauses the controller while the
    peripheral deals with the data that was transmitted to it (that is, clock stretching
    adds wait states to the I²C clock).
  prefs: []
  type: TYPE_NORMAL
- en: As with arbitration and clock synchronization, clock stretching takes advantage
    of the wired-AND operation of the I²C bus. If the peripheral is pulling the SCL
    line low when the controller sets it high, the SCL line remains low. The controller
    looks for this behavior and pauses data and clock output until the peripheral
    releases the SCL line.
  prefs: []
  type: TYPE_NORMAL
- en: Clock stretching is an optional feature of the I²C protocol, meaning controllers
    don’t have to support this feature. Obviously, if a peripheral uses clock stretching,
    that device will be incompatible with controllers that don’t support this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Cross Talk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another problem that can befall I²C communications is cross talk. If you run
    the SDA and SCL lines in parallel, especially over a long distance, signal changes
    on one line can affect the other. The SCL line affecting the SDA line is the most
    common problem. To reduce the problem of cross talk, the simple solution is to
    run a ground trace between the SCL and SDA lines on a PCB. Likewise, on a ribbon
    cable, running a ground line—or better yet, a power and a ground line—between
    the SDA and SCL conductors can reduce the incidence of cross talk.
  prefs: []
  type: TYPE_NORMAL
- en: Although cross talk between the SCL and SDA lines represents the most common
    cross talk problems on the I²C bus, keep in mind that other signals can also induce
    noise on these two signal lines. When laying out PCBs, try to keep other high-frequency
    or high-current lines away from the SDA and SCL traces. Following good PCB design
    rules can really help. Likewise, when running I²C signals or ribbon cables (or
    other wiring), interleaving a ground wire between the SDA and SCL signals can
    reduce noise in the system.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to the cross talk problem is to use differential line drivers on
    the I²C. SparkFun provides the QwiicBus Kit to solve cross talk and other issues
    with bus length. See “For More Information.”
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned that the I²C bus solves several problems that
    designers of early embedded systems encountered when adding I/O to their designs.
    The two-wire (serial data and clock) interface reduces PCB size, noise, and design
    effort. The I²C bus features the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Open-drain (open-collector) bus signals allowing multiple controllers and bidirectional
    communication on a single data line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 100-kHz, 400-kHz, 1-MHz, 3.4 MHz, and 5-MHz bus speeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 V to 5 V operation (via pullup resistors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bus arbitration and clock stretching to resolve timing issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide variety of I²C peripheral ICs that can be connected to any I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
