- en: '**3 Oscillation**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3 振荡**'
- en: '*Trigonometry is a sine of the times.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*三角学是时代的象征。*'
- en: —Anonymous
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —匿名
- en: '![Image](../images/pg157_Image_217.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg157_Image_217.jpg)'
- en: '***Gala* by Bridget Riley, 1974; acrylic on canvas, 159.7 × 159.7 cm**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '***Gala* by Bridget Riley, 1974; 丙烯画布，159.7 × 159.7 cm**'
- en: Bridget Riley, a celebrated British artist, was a driving force behind the Op
    Art movement of the 1960s. Her work features geometric patterns that challenge
    the viewer’s perceptions and evoke feelings of movement or vibration. Her 1974
    piece *Gala* showcases a series of curvilinear forms that ripple across the canvas,
    evoking the natural rhythm of the sine wave.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 布里奇特·赖利（Bridget Riley），一位著名的英国艺术家，是 1960 年代光学艺术（Op Art）运动的推动力之一。她的作品以几何图案为特色，挑战观众的感知，并唤起运动或震动的感觉。她1974年的作品《Gala》展示了一系列曲线形态，像波纹一样在画布上扩散，唤起了正弦波的自然节奏。
- en: 'In [Chapters 1](ch01.xhtml#ch01) and [2](ch02.xhtml#ch02), I carefully worked
    out an object-oriented structure to animate a shape in a p5.js canvas, using a
    vector to represent position, velocity, and acceleration driven by forces in the
    environment. I could move straight from here into topics such as particle systems,
    steering forces, group behaviors, and more. However, doing so would mean skipping
    a fundamental aspect of motion in the natural world: **oscillation**, or the back-and-forth
    movement of an object around a central point or position.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.xhtml#ch01)和[第二章](ch02.xhtml#ch02)中，我仔细制定了一个面向对象的结构，用于在 p5.js 画布中动画化形状，使用一个向量来表示位置、速度和加速度，这些都由环境中的力驱动。从这里我可以直接进入粒子系统、引导力、群体行为等主题。然而，若这样做就意味着跳过了自然界运动的一个基本方面：**振荡**，即物体围绕一个中心点或位置的往返运动。
- en: To model oscillation, you need to understand a little bit about **trigonometry**,
    the mathematics of triangles. Learning some trig will give you new tools to generate
    patterns and create new motion behaviors in a p5.js sketch. You’ll learn to harness
    angular velocity and acceleration to spin objects as they move. You’ll be able
    to use the sine and cosine functions to model nice ease-in, ease-out wave patterns.
    You’ll also learn to calculate the more complex forces at play in situations that
    involve angles, such as a pendulum swinging or a box sliding down an incline.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟振荡，你需要了解一些**三角学**，即三角形的数学。学习一些三角学将为你提供生成图案和创建新的运动行为的工具。在 p5.js 草图中，你将学会利用角速度和加速度来旋转物体，同时物体在移动。你将能够使用正弦和余弦函数来模拟平滑的加速、减速波动模式。你还将学会计算涉及角度的更复杂的力，例如钟摆的摆动或箱子沿斜面下滑的情况。
- en: I’ll start with the basics of working with angles in p5.js, then cover several
    aspects of trigonometry. In the end, I’ll connect trigonometry with what you learned
    about forces in [Chapter 2](ch02.xhtml#ch02). This chapter’s content will pave
    the way for more sophisticated examples that require trig later in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从在 p5.js 中使用角度的基础知识开始，然后介绍三角学的几个方面。最后，我会将三角学与在[第二章](ch02.xhtml#ch02)中学到的关于力的内容联系起来。本章的内容将为书中后续需要使用三角学的更复杂示例铺路。
- en: '**Angles**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**角度**'
- en: Before going any further, I need to make sure you understand how the concept
    of an **angle** fits into creative coding in p5.js. If you have experience with
    p5.js, you’ve undoubtedly encountered this issue while using the `rotate()` function
    to rotate and spin objects. You’re most likely to be familiar with the concept
    of an angle as measured in **degrees** (see [Figure 3.1](ch03.xhtml#ch3fig1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我需要确保你理解**角度**这一概念是如何融入到 p5.js 创意编码中的。如果你有使用 p5.js 的经验，在使用`rotate()`函数来旋转和旋转物体时，你无疑已经遇到过这个问题。你很可能熟悉角度作为**度数**的概念（见[图
    3.1](ch03.xhtml#ch3fig1)）。
- en: '![Image](../images/pg158_Image_218.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg158_Image_218.jpg)'
- en: 'Figure 3.1: Angles measured in degrees'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：以度数为单位的角度
- en: A full rotation goes from 0 to 360 degrees, and 90 degrees (a right angle) is
    one-fourth of 360, shown in [Figure 3.1](ch03.xhtml#ch3fig1) as two perpendicular
    lines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的旋转从 0 度到 360 度，而 90 度（直角）是 360 的四分之一，如[图 3.1](ch03.xhtml#ch3fig1)所示，图中有两条垂直线。
- en: Angles are commonly used in computer graphics to specify a rotation for a shape.
    For example, the square in [Figure 3.2](ch03.xhtml#ch3fig2) is rotated 45 degrees
    around its center.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 角度在计算机图形学中常用于指定形状的旋转。例如，[图 3.2](ch03.xhtml#ch3fig2)中的正方形绕其中心旋转了 45 度。
- en: '![Image](../images/pg159_Image_219.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg159_Image_219.jpg)'
- en: 'Figure 3.2: A square rotated by 45 degrees'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：旋转了 45 度的正方形
- en: The catch is that, by default, p5.js measures angles not in degrees but in **radians**.
    This alternative unit of measurement is defined by the ratio of the length of
    the arc of a circle (a segment of the circle’s circumference) to the radius of
    that circle. One radian is the angle at which that ratio equals 1 (see [Figure
    3.3](ch03.xhtml#ch3fig3)). A full circle (360 degrees) is equivalent to 2π radians,
    180 degrees is equivalent to π radians, and 90 degrees is equivalent to π/2 radians.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，默认情况下，p5.js测量角度时使用的是弧度而不是**度数**。这个替代的计量单位由圆的弧长（圆周的一部分）与圆的半径的比值定义。一个弧度是当这个比值等于1时的角度（见[图3.3](ch03.xhtml#ch3fig3)）。一个完整的圆（360度）相当于2π弧度，180度相当于π弧度，90度相当于π/2弧度。
- en: '![Image](../images/pg159_Image_220.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg159_Image_220.jpg)'
- en: 'Figure 3.3: The arc length for an angle of 1 radian is equal to the radius.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：1弧度角的弧长等于半径。
- en: 'The formula to convert from degrees to radians is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从度数转换为弧度的公式如下：
- en: '![Image](../images/pg159_Image_221.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg159_Image_221.jpg)'
- en: 'Thankfully, if you prefer to think of angles in degrees, you can call `angleMode(DEGREES)`,
    or you can use the convenience function `radians()` to convert values from degrees
    to radians. The constants `PI`, `TWO_PI`, and `HALF_PI` are also available (equivalent
    to 180, 360, and 90 degrees, respectively). For example, here are two ways in
    p5.js to rotate a shape by 60 degrees:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 令人庆幸的是，如果你更倾向于以度数表示角度，你可以调用`angleMode(DEGREES)`，或者使用便捷函数`radians()`将度数转换为弧度。常量`PI`、`TWO_PI`和`HALF_PI`也可以使用（分别等同于180度、360度和90度）。例如，在p5.js中，以下是旋转一个形状60度的两种方式：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Image](../images/zoom.jpg) **What Is Pi?**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **什么是π？**'
- en: The mathematical constant **pi** (or the Greek letter π) is a real number defined
    as the ratio of a circle’s circumference (the distance around the outside of the
    circle) to its diameter (a straight line that passes through the circle’s center).
    It’s equal to approximately 3.14159 and can be accessed in p5.js with the built-in
    `PI` variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数学常数**π**（或希腊字母π）是一个实数，定义为圆的周长（圆周的外侧距离）与直径（通过圆心的直线段）的比值。它大约等于3.14159，并且可以通过p5.js中的内建`PI`变量访问。
- en: While degrees can be useful, for the purposes of this book, I’ll be working
    with radians because they’re the standard unit of measurement across many programming
    languages and graphics environments. If they’re new to you, this is a good opportunity
    to practice! Additionally, if you aren’t familiar with the way rotation is implemented
    in p5.js, I recommend watching my Coding Train video series on transformations
    in p5.js (*[https://thecodingtrain.com/transformations](https://thecodingtrain.com/transformations)*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然度数可能很有用，但在本书中，我将使用弧度，因为它们是许多编程语言和图形环境中的标准计量单位。如果它们对你来说是新的，这是一个很好的练习机会！此外，如果你不熟悉p5.js中旋转的实现方式，我建议观看我关于p5.js变换的Coding
    Train视频系列（*[https://thecodingtrain.com/transformations](https://thecodingtrain.com/transformations)*）。
- en: '![Image](../images/pencil.jpg) **Exercise 3.1**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习3.1**'
- en: Rotate a baton-like object around its center by using `translate()` and `rotate()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`translate()`和`rotate()`围绕物体的中心旋转一个类似指挥棒的物体。
- en: '![Image](../images/pg160_Image_222.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg160_Image_222.jpg)'
- en: '**Angular Motion**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**角动量**'
- en: Another term for rotation is **angular motion**—that is, motion about an angle.
    Just as linear motion can be described in terms of velocity—the rate at which
    an object’s position changes over time—angular motion can be described in terms
    of **angular velocity**—the rate at which an object’s angle changes over time.
    By extension, **angular acceleration** describes changes in an object’s angular
    velocity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的另一个术语是**角动量**——即围绕一个角度的运动。正如线性运动可以用速度来描述——即物体位置随时间变化的速率——角动量可以用**角速度**来描述——即物体角度随时间变化的速率。通过扩展，**角加速度**描述物体的角速度变化。
- en: Luckily, you already have all the math you need to understand angular motion.
    Remember the stuff I dedicated almost all of [Chapters 1](ch01.xhtml#ch01) and
    [2](ch02.xhtml#ch02) to explaining?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经具备了理解角动量所需的所有数学知识。记得我在[第一章](ch01.xhtml#ch01)和[第二章](ch02.xhtml#ch02)中几乎全部讲解的内容吗？
- en: '![Image](../images/pg161_Image_223.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg161_Image_223.jpg)'
- en: 'You can apply exactly the same logic to a rotating object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将相同的逻辑应用于旋转物体：
- en: angular velocity = angular velocity + angular acceleration
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 角速度 = 角速度 + 角加速度
- en: angle = angle + angular velocity
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 角度 = 角度 + 角速度
- en: In fact, these angular motion formulas are simpler than their linear motion
    equivalents since the angle here is a *scalar* quantity (a single number), not
    a vector! This is because in 2D space, there’s one axis of rotation; in 3D space,
    the angle would become a vector. (Note that in most contexts, these formulas would
    include a multiplication by the change in time, referred to as *delta time*. I’m
    assuming a delta time of 1 that corresponds to one frame of animation in p5.js.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这些角运动的公式比线性运动的公式更简单，因为这里的角度是一个*标量*量（单一数值），而不是向量！这是因为在二维空间中，只有一个旋转轴；在三维空间中，角度会变成一个向量。（请注意，在大多数情况下，这些公式会包括时间变化的乘法，通常称为*增量时间*。我假设增量时间为1，对应于p5.js中的一帧动画。）
- en: 'Using the answer from [Exercise 3.1](ch03.xhtml#ch3exe1), let’s say you wanted
    to rotate a baton in p5.js by a certain angle. Originally, the code might have
    read as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[练习 3.1](ch03.xhtml#ch3exe1)中的答案，假设你想要在p5.js中让指挥棒旋转一定角度。最初，代码可能是这样的：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding in the principles of angular motion, I can instead write the following
    example (the solution to [Exercise 3.1](ch03.xhtml#ch3exe1)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 融入角运动的原理后，我可以改写以下示例（这是[练习 3.1](ch03.xhtml#ch3exe1)的解决方案）。
- en: '![Image](../images/pg161_Image_224.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg161_Image_224.jpg)'
- en: Instead of incrementing `angle` by a fixed amount to steadily rotate the baton,
    for every frame I add `angleAcceleration` to `angleVelocity`, then add `angleVelocity`
    to `angle`. As a result, the baton starts with no rotation and then spins faster
    and faster as the angular velocity accelerates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不像通过固定增量逐步旋转指挥棒，我在每一帧中将`angleAcceleration`加到`angleVelocity`，然后将`angleVelocity`加到`angle`。结果是，指挥棒一开始没有旋转，随着角速度加速，旋转越来越快。
- en: '![Image](../images/pencil.jpg) **Exercise 3.2**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.2**'
- en: Add an interaction to the spinning baton. How can you control the acceleration
    with the mouse? Can you introduce the idea of drag, decreasing the angular velocity
    over time so the baton eventually comes to rest?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 给旋转的指挥棒添加互动。如何通过鼠标控制加速度？你能引入拖拽的概念，通过减少角速度来让指挥棒最终停下来吗？
- en: 'The logical next step is to incorporate this idea of angular motion into the
    `Mover` class. First, I need to add some variables to the class’s constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的下一步是将这个角运动的概念融入到`Mover`类中。首先，我需要在类的构造函数中添加一些变量：
- en: '![Image](../images/pg162_Image_226.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg162_Image_226.jpg)'
- en: 'Then, in `update()`, the mover’s position and angle are updated according to
    the algorithm I just demonstrated:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`update()`中，根据我刚刚演示的算法更新移动者的位置和角度：
- en: '![Image](../images/pg163_Image_228.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg163_Image_228.jpg)'
- en: Of course, for any of this to matter, I also need to rotate the object when
    drawing it in the `show()` method. (I’ll add a line from the center to the edge
    of the circle so that rotation is visible. You could also draw the object as a
    shape other than a circle.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些要生效，我还需要在`show()`方法中绘制物体时进行旋转。（我会在圆心到圆边添加一条线，使旋转可见。你也可以将物体绘制成除圆形以外的其他形状。）
- en: '![Image](../images/pg163_Image_229.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg163_Image_229.jpg)'
- en: 'At this point, if you were to actually go ahead and create a `Mover` object,
    you wouldn’t see it behave any differently. This is because the angular acceleration
    is initialized to zero ( `this.angleAcceleration = 0;` ). For the object to rotate,
    it needs a nonzero acceleration! Certainly, one option is to hardcode a number
    in the constructor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你真的创建了一个`Mover`对象，你不会看到它有任何不同的表现。这是因为角加速度被初始化为零（`this.angleAcceleration
    = 0;`）。为了让物体旋转，它需要一个非零的加速度！当然，一种选择是在构造函数中硬编码一个数字：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can produce a more interesting result, however, by dynamically assigning
    an angular acceleration in the `update()` method according to forces in the environment.
    This could be my cue to start researching the physics of angular acceleration
    based on the concepts of torque (*[https://en.wikipedia.org/wiki/Torque](https://en.wikipedia.org/wiki/Torque)*)
    and moment of inertia (*[https://en.wikipedia.org/wiki/Moment_of_inertia](https://en.wikipedia.org/wiki/Moment_of_inertia)*),
    but at this stage, that level of simulation would be a bit of a rabbit hole. (I’ll
    cover modeling angular acceleration with a pendulum in more detail in “The Pendulum”
    on [page 154](ch03.xhtml#ch00lev1sec39), as well as look at how third-party physics
    libraries realistically model rotational motion in [Chapter 6](ch06.xhtml#ch06).)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过在`update()`方法中根据环境中的力动态地分配角加速度，从而得到更有趣的结果。这可能是我开始研究基于力矩（*[https://en.wikipedia.org/wiki/Torque](https://en.wikipedia.org/wiki/Torque)*)和转动惯量（*[https://en.wikipedia.org/wiki/Moment_of_inertia](https://en.wikipedia.org/wiki/Moment_of_inertia)*）的角加速度物理学的信号，但在这个阶段，这种模拟的复杂度可能会有些“无底洞”。（我将在《摆锤》章节中更详细地介绍如何使用摆锤建模角加速度，见[第154页](ch03.xhtml#ch00lev1sec39)，并在[第6章](ch06.xhtml#ch06)中讨论第三方物理库如何真实地模拟旋转运动。）
- en: 'Instead, a quick-and-dirty solution that yields creative results will suffice.
    A reasonable approach is to calculate angular acceleration as a function of the
    object’s linear acceleration, its rate of change of velocity along a path vector,
    as opposed to its rotation. Here’s an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个快速且粗糙的解决方案，能够产生创造性结果，就足够了。一个合理的做法是将角加速度计算为物体的线性加速度的函数，即沿路径向量的速度变化率，而不是它的旋转。下面是一个例子：
- en: '![Image](../images/pg164_Image_230.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg164_Image_230.jpg)'
- en: 'Yes, this is arbitrary, but it does do *something*. If the object is accelerating
    to the right, its angular rotation accelerates in a clockwise direction; acceleration
    to the left results in a counterclockwise rotation. Of course, it’s important
    to think about scale in this case. The value of the acceleration vector’s `x`
    component might be too large, causing the object to spin in a way that looks ridiculous
    or unrealistic. You might even notice a visual illusion called the *wagon wheel
    effect*: an object appears to be rotating more slowly or even in the opposite
    direction because of the large changes between each frame of animation.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个是任意的，但它确实能*产生一些效果*。如果物体向右加速，它的角旋转会朝顺时针方向加速；向左加速会导致逆时针旋转。当然，在这种情况下，考虑比例是非常重要的。加速度向量的`x`分量可能过大，导致物体旋转看起来非常荒谬或不现实。你甚至可能会注意到一种视觉错觉，叫做*马车轮效应*：由于每一帧动画之间的变化较大，物体看起来旋转得更慢，甚至是朝相反方向旋转。
- en: Dividing the `x` component by a value, or perhaps constraining the angular velocity
    to a reasonable range, could really help. Here’s the entire `update()` function
    with these tweaks added.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`分量除以一个值，或者将角速度限制在一个合理的范围内，可能真的会有所帮助。以下是整个`update()`函数，已添加这些调整。
- en: '![Image](../images/pg164_Image_231.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg164_Image_231.jpg)'
- en: Notice that I’ve used multiple strategies to keep the object from spinning out
    of control. First, I divide `acceleration.x` by `10` before assigning it to `angleAcceleration`.
    Then, for good measure, I also use `constrain()` to confine `angleVelocity` to
    the range `(–0.1, 0.1)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用了多种策略来防止物体旋转失控。首先，我将`acceleration.x`除以`10`，然后再赋值给`angleAcceleration`。接着，为了确保安全，我还使用了`constrain()`将`angleVelocity`限制在`(-0.1,
    0.1)`范围内。
- en: '![Image](../images/pencil.jpg) **Exercise 3.3**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.3**'
- en: 'Step 1: Create a simulation of objects being shot out of a cannon. Each object
    should experience a sudden force when shot (just once) as well as gravity (always
    present).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步：创建一个物体从大炮中发射的模拟。每个物体在发射时应该经历一次突然的力（仅一次），以及重力（始终存在）。
- en: 'Step 2: Add rotation to the object to model its spin as it’s shot from the
    cannon. How realistic can you make it look?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：给物体添加旋转，模拟它从大炮中发射时的旋转。你能让它看起来有多真实？
- en: '**Trigonometry Functions**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**三角函数**'
- en: I think I’m ready to reveal the secret of trigonometry. I’ve discussed angles,
    I’ve spun a baton. Now it’s time for . . . wait for it . . . *sohcahtoa*. Yes,
    *sohcahtoa*! This seemingly nonsensical word is actually the foundation for much
    of computer graphics work. A basic understanding of trigonometry is essential
    if you want to calculate angles, figure out distances between points, and work
    with circles, arcs, or lines. And *sohcahtoa* is a mnemonic device (albeit a somewhat
    absurd one) for remembering the meanings of the trigonometric functions sine,
    cosine, and tangent. It references the sides of a right triangle, as shown in
    [Figure 3.4](ch03.xhtml#ch3fig4).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我准备好揭示三角学的秘密了。我已经讨论过角度，已经转过棒子。现在是时候...等等... *sohcahtoa* 了。是的，*sohcahtoa*！这个看似毫无意义的词实际上是计算机图形学工作的重要基础。基本理解三角学是计算角度、测量点之间距离，以及处理圆形、弧线或直线的关键。如果你想要计算角度，弄清楚点之间的距离，或者处理圆、弧线或直线，三角学是必不可少的。而
    *sohcahtoa* 是一个记忆法（尽管有些荒谬）用来记住三角函数正弦、余弦和正切的含义。它指的是直角三角形的各边，如[图 3.4](ch03.xhtml#ch3fig4)所示。
- en: '![Image](../images/pg166_Image_233.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg166_Image_233.jpg)'
- en: 'Figure 3.4: A right triangle showing the sides as adjacent, opposite, and hypotenuse'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：一个直角三角形，展示了邻边、对边和斜边
- en: 'Take one of the non-right angles in the triangle. The *adjacent* side is the
    one touching that angle, the *opposite* side is the one not touching that angle,
    and the *hypotenuse* is the side opposite the right angle. *Sohcahtoa* tells you
    how to calculate the angle’s trigonometric functions in terms of the lengths of
    these sides:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 取三角形中的一个非直角。*邻边* 是与该角相接的那条边，*对边* 是不与该角相接的那条边，*斜边* 是与直角相对的那条边。*Sohcahtoa* 告诉你如何根据这些边的长度来计算角度的三角函数：
- en: '**soh:** **s**ine(angle) = **o**pposite/**h**ypotenuse'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**soh:** **s**ine(角度) = **o**pposite/**h**ypotenuse'
- en: '**cah:** **c**osine(angle) = **a**djacent/**h**ypotenuse'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cah:** **c**osine(角度) = **a**djacent/**h**ypotenuse'
- en: '**toa:** **t**angent(angle) = **o**pposite/**a**djacent'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**toa:** **t**angent(角度) = **o**pposite/**a**djacent'
- en: Take a look at [Figure 3.4](ch03.xhtml#ch3fig4) again. You don’t need to memorize
    it, but see if you feel comfortable with it. Try redrawing it yourself. Next,
    let’s look at it in a slightly different way (see [Figure 3.5](ch03.xhtml#ch3fig5)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下[图 3.4](ch03.xhtml#ch3fig4)。你不需要背诵它，但可以看看自己是否感觉舒适。试着自己重新画一遍。接下来，让我们以稍微不同的方式来看它（见[图
    3.5](ch03.xhtml#ch3fig5)）。
- en: '![Image](../images/pg166_Image_234.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg166_Image_234.jpg)'
- en: 'Figure 3.5: A vector ![Image](../images/pg81_Image_71.jpg) with components
    *x*, *y*, and *angle*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：一个向量 ![Image](../images/pg81_Image_71.jpg)，包含分量 *x*、*y* 和 *角度*
- en: See how a right triangle is created from the vector ![Image](../images/pg81_Image_73.jpg)?
    The vector arrow is the hypotenuse, and the components of the vector (*x* and
    *y*) are the sides of the triangle. The angle is an additional means for specifying
    the vector’s direction (or *heading*). Viewed in this way, the trigonometric functions
    establish a relationship between the components of a vector and its direction
    + magnitude. As such, trigonometry will prove very useful throughout this book.
    To illustrate this, let’s look at an example that requires the tangent function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看看一个直角三角形是如何从这个向量 ![Image](../images/pg81_Image_73.jpg)中生成的？向量箭头是斜边，向量的分量（*x*
    和 *y*）是三角形的两条边。角度是确定向量方向（或 *航向*）的附加手段。以这种方式来看，三角函数建立了向量的分量与其方向 + 大小之间的关系。因此，三角学将在本书中非常有用。为了说明这一点，我们来看看一个需要用到正切函数的例子。
- en: '**Pointing in the Direction of Movement**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指向运动的方向**'
- en: Think all the way back to [Example 1.10](ch01.xhtml#ch1ex10), which featured
    a `Mover` object accelerating toward the mouse ([Figure 3.6](ch03.xhtml#ch3fig6)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想回[例子 1.10](ch01.xhtml#ch1ex10)，那是一个`Mover`对象朝鼠标加速的例子（[图 3.6](ch03.xhtml#ch3fig6)）。
- en: '![Image](../images/pg167_Image_235.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg167_Image_235.jpg)'
- en: 'Figure 3.6: A mover accelerating toward the mouse (from [Example 1.10](ch01.xhtml#ch1ex10))'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：一个朝鼠标加速的移动物体（来自[例子 1.10](ch01.xhtml#ch1ex10)）
- en: You might notice that almost all the shapes I’ve been drawing so far have been
    circles. This is convenient for several reasons, one of which is that using circles
    allows me to avoid the question of rotation. Rotate a circle and, well, it looks
    exactly the same. Nevertheless, there comes a time in all motion programmers’
    lives when they want to move something around onscreen that isn’t shaped like
    a circle. Perhaps it’s an ant, or a car, or a spaceship. To look realistic, that
    object should point in its direction of movement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，到目前为止我画的大部分形状都是圆形的。这是很方便的，原因有几个，其中之一就是使用圆形可以避免旋转的问题。旋转一个圆形，嗯，它看起来完全一样。然而，所有运动程序员的生活中总会有那么一刻，他们想要在屏幕上移动一些不是圆形的物体。也许是蚂蚁，或者是汽车，或者是飞船。为了看起来更真实，这个物体应该指向它的运动方向。
- en: When I say “point in its direction of movement,” what I really mean is “rotate
    according to its velocity vector.” Velocity is a vector, with an x- and y-component,
    but to rotate in p5.js, you need one number, an angle. Let’s look at the trigonometry
    diagram once more, this time focused on an object’s velocity vector ([Figure 3.7](ch03.xhtml#ch3fig7)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“指向它的运动方向”时，我的意思是“根据它的速度向量进行旋转。”速度是一个向量，具有 x 和 y 分量，但要在 p5.js 中进行旋转，你只需要一个数字，一个角度。让我们再看一遍三角函数图，这次聚焦在物体的速度向量上（见图
    [3.7](ch03.xhtml#ch3fig7)）。
- en: '![Image](../images/pg167_Image_236.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg167_Image_236.jpg)'
- en: 'Figure 3.7: The tangent of a velocity vector’s angle is *y* divided by *x*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：速度向量的角度的正切是 *y* 除以 *x*。
- en: 'The vector’s x- and y-components are related to its angle through the tangent
    function. Using the *toa* in *sohcahtoa*, I can write the relationship as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的 x 和 y 分量与其角度通过正切函数相关联。使用 *toa* 在 *sohcahtoa* 中，我可以将关系写为：
- en: '![Image](../images/pg167_Image_237.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg167_Image_237.jpg)'
- en: The problem here is that while I know the x- and y-components of the velocity
    vector, I don’t know the angle of its direction. I have to solve for that angle.
    This is where another function known as the *inverse tangent*, or *arctangent*
    (*arctan* or *atan*, for short), comes in. (There are also *inverse sine* and
    *inverse cosine* functions, called *arcsine* and *arccosine*, respectively.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，虽然我知道速度向量的 x 和 y 分量，但我不知道它的方向角度。我必须求解这个角度。这就是另一个函数——*反正切*，或称为 *反正切函数*（简称
    *arctan* 或 *atan*）派上用场的地方。（还有 *反正弦* 和 *反余弦* 函数，分别称为 *arcsine* 和 *arccosine*。）
- en: 'If the tangent of value *a* equals value *b*, then the inverse tangent of *b*
    equals *a*. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a* 的正切值等于 *b*，那么 *b* 的反正切值等于 *a*。例如：
- en: '| If | tan(*a*) = *b* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 如果 | tan(*a*) = *b* |'
- en: '| then | *a* = arctan(*b*) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 然后 | *a* = arctan(*b*) |'
- en: 'See how one is the inverse of the other? This allows me to solve for the vector’s
    angle:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一个是另一个的反向吗？这使我能够求解向量的角度：
- en: '| If | ![Image](../images/pg168_Image_238.jpg) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 如果 | ![Image](../images/pg168_Image_238.jpg) |'
- en: '| then | ![Image](../images/pg168_Image_239.jpg) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 然后 | ![Image](../images/pg168_Image_239.jpg) |'
- en: 'Now that I have the formula, let’s see where it should go in the `Mover` class’s
    `show()` method to make the mover (now drawn as a rectangle) point in its direction
    of motion. Note that in p5.js, the function for inverse tangent is `atan()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经有了公式，让我们看看它应该放在哪里，在 `Mover` 类的 `show()` 方法中，以便让运动物体（现在绘制为一个矩形）指向它的运动方向。请注意，在
    p5.js 中，反正切函数是 `atan()`：
- en: '![Image](../images/pg168_Image_240.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg168_Image_240.jpg)'
- en: This code is pretty darn close and almost works. There’s a big problem, though.
    Consider the two velocity vectors depicted in [Figure 3.8](ch03.xhtml#ch3fig8).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常接近，几乎可以正常工作。不过，存在一个大问题。考虑图 [3.8](ch03.xhtml#ch3fig8) 中展示的两个速度向量。
- en: '![Image](../images/pg169_Image_241.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg169_Image_241.jpg)'
- en: 'Figure 3.8: The vectors ![Image](../images/pg169_Image_242.jpg) and ![Image](../images/pg169_Image_243.jpg)
    with components (4, –3) and (–4, 3) point in opposite directions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：这两个向量 ![Image](../images/pg169_Image_242.jpg) 和 ![Image](../images/pg169_Image_243.jpg)，它们的分量分别是
    (4, –3) 和 (–4, 3)，指向相反的方向。
- en: 'Though superficially similar, the two vectors point in quite different directions—opposite
    directions, in fact! In spite of this, look at what happens if I apply the inverse
    tangent formula to solve for the angle of each vector:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上看起来相似，但这两个向量指向的方向完全不同——实际上是相反的方向！尽管如此，看看如果我应用反正切公式来求解每个向量的角度，会发生什么：
- en: '![Image](../images/pg169_Image_244.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg169_Image_244.jpg)'
- en: I get the same angle! That can’t be right, though, since the vectors are pointing
    in opposite directions. It turns out this is a pretty common problem in computer
    graphics. I could use `atan()` along with conditional statements to account for
    positive/negative scenarios, but p5.js (along with most programming environments)
    has a helpful function called `atan2()` that resolves the issue for me.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了相同的角度！不过，这样不对，因为这些向量指向的方向是相反的。事实证明，这是计算机图形学中一个相当常见的问题。我本可以使用`atan()`结合条件语句来处理正负情况，但
    p5.js（以及大多数编程环境）有一个很有用的函数叫做`atan2()`，它可以为我解决这个问题。
- en: '![Image](../images/pg169_Image_245.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg169_Image_245.jpg)'
- en: 'To simplify this even further, the `p5.Vector` class provides a method called
    `heading()`, which takes care of calling `atan2()` and returns the 2D direction
    angle, in radians, for any `p5.Vector`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化，`p5.Vector` 类提供了一个名为 `heading()` 的方法，该方法负责调用 `atan2()` 并返回任何 `p5.Vector`
    的二维方向角，以弧度表示：
- en: '![Image](../images/pg170_Image_246.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg170_Image_246.jpg)'
- en: With `heading()`, it turns out you don’t actually need to implement the trigonometry
    functions in your code, but understanding how they’re all working is still helpful.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `heading()` 后，实际上你并不需要在代码中实现三角学函数，但理解它们是如何工作的仍然是有帮助的。
- en: '![Image](../images/pencil.jpg) **Exercise 3.4**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.4**'
- en: 'Create a simulation of a vehicle that you can drive around the screen by using
    the arrow keys: the left arrow accelerates the car to the left, and the right
    arrow accelerates to the right. The car should point in the direction in which
    it’s currently moving.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以通过箭头键控制移动的车辆模拟：左箭头加速车辆向左，右箭头加速车辆向右。车辆应该朝着当前移动的方向指向。
- en: '**Polar vs. Cartesian Coordinates**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**极坐标与笛卡尔坐标**'
- en: Anytime you draw a shape in p5.js, you have to specify a pixel position, a set
    of x- and y-coordinates. These are known as **Cartesian coordinates**, named for
    René Descartes, the French mathematician who developed the ideas behind Cartesian
    space.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在 p5.js 中绘制形状时，你都需要指定一个像素位置，即一组x和y坐标。这些被称为**笛卡尔坐标**，得名于法国数学家勒内·笛卡尔，他发展了笛卡尔空间的相关思想。
- en: Another useful coordinate system, known as **polar coordinates**, describes
    a point in space as a distance from the origin (like the radius of a circle) and
    an angle of rotation around the origin (usually called *θ*, the Greek letter theta).
    Thinking in terms of vectors, a Cartesian coordinate describes a vector’s x- and
    y-components, whereas a polar coordinate describes a vector’s magnitude (length)
    and direction (angle).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的坐标系，称为**极坐标系**，通过描述空间中一个点到原点的距离（如圆的半径）和围绕原点旋转的角度（通常叫做*θ*，希腊字母θ）来定义一个点的位置。从向量的角度来看，笛卡尔坐标描述了一个向量的x和y分量，而极坐标描述了一个向量的大小（长度）和方向（角度）。
- en: When working in p5.js, you may find it more convenient to think in polar coordinates,
    especially when creating sketches that involve rotational or circular movements.
    However, p5.js’s drawing functions understand only (*x*, *y*) Cartesian coordinates.
    Happily for you, trigonometry holds the key to converting back and forth between
    polar and Cartesian (see [Figure 3.9](ch03.xhtml#ch3fig9)). This allows you to
    design with whatever coordinate system you have in mind, while always drawing
    using Cartesian coordinates.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 p5.js 中工作时，你可能会发现思考极坐标更为方便，特别是在创建涉及旋转或圆形运动的图形时。然而，p5.js 的绘图函数只理解（*x*，*y*）笛卡尔坐标。幸运的是，三角学为你提供了从极坐标和笛卡尔坐标之间相互转换的关键（见[图
    3.9](ch03.xhtml#ch3fig9)）。这使得你可以根据自己的需求设计坐标系，同时始终使用笛卡尔坐标进行绘图。
- en: '![Image](../images/pg171_Image_247.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg171_Image_247.jpg)'
- en: 'Figure 3.9: The Greek letter *θ* (theta) is often used to denote an angle.
    Since a polar coordinate is conventionally referred to as (*r*, *θ*), I’ll use
    `theta` as a variable name when referring to an angle in p5.js.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：希腊字母 *θ*（theta）通常用来表示角度。由于极坐标通常表示为（*r*，*θ*），因此在提到 p5.js 中的角度时，我将使用 `theta`
    作为变量名。
- en: 'For example, given a polar coordinate with a radius of 75 pixels and an angle
    (*θ*) of 45 degrees (or π/4 radians), the Cartesian *x* and *y* can be computed
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个半径为75像素，角度为45度（或π/4弧度）的极坐标，可以按以下方式计算笛卡尔坐标的 *x* 和 *y*：
- en: cos(*θ*) = *x/r* ⇒ *x = r* × cos(*θ*)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: cos(*θ*) = *x/r* ⇒ *x = r* × cos(*θ*)
- en: sin(*θ*) = *y/r* ⇒ *y = r* × sin(*θ*)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: sin(*θ*) = *y/r* ⇒ *y = r* × sin(*θ*)
- en: 'The functions for sine and cosine in p5.js are `sin()` and `cos()`, respectively.
    Each takes one argument, a number representing an angle in radians. These formulas
    can thus be coded as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 p5.js 中，正弦和余弦的函数分别是 `sin()` 和 `cos()`。每个函数接受一个参数，表示一个以弧度为单位的角度。因此，这些公式可以像下面这样编码：
- en: '![Image](../images/pg171_Image_248.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg171_Image_248.jpg)'
- en: 'This type of conversion can be useful in certain applications. For instance,
    moving a shape along a circular path using Cartesian coordinates isn’t so easy.
    However, with polar coordinates, it’s simple: just increment the angle! Here’s
    how it’s done with global `r` and `theta` variables.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的转换在某些应用中可能非常有用。例如，使用笛卡尔坐标系移动一个形状沿圆形路径并不容易。然而，使用极坐标就简单多了：只需增加角度即可！以下是使用全局
    `r` 和 `theta` 变量来实现的方式。
- en: '![Image](../images/pg172_Image_249.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg172_Image_249.jpg)'
- en: 'Polar-to-Cartesian conversion is common enough that p5.js includes a handy
    function to take care of it for you. It’s included as a static method of the `p5.Vector`
    class called `fromAngle()`. It takes an angle in radians and creates a unit vector
    in Cartesian space that points in the direction specified by the angle. Here’s
    how that would look in [Example 3.4](ch03.xhtml#ch3ex4):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 极坐标到笛卡尔坐标的转换已经足够常见，以至于 p5.js 提供了一个便捷的函数来处理这个问题。它作为 `p5.Vector` 类的一个静态方法 `fromAngle()`
    被包含进来。它接受一个弧度表示的角度，并在笛卡尔空间中创建一个单位向量，指向由该角度指定的方向。这就是 [示例 3.4](ch03.xhtml#ch3ex4)
    中的实现：
- en: '![Image](../images/pg173_Image_250.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg173_Image_250.jpg)'
- en: Are you amazed yet? I’ve demonstrated some pretty great uses of tangent (for
    finding the angle of a vector) and sine and cosine (for converting from polar
    to Cartesian coordinates). I could stop right here and be satisfied. But I’m not
    going to. This is only the beginning. As I’ll show you next, what sine and cosine
    can do for you goes beyond mathematical formulas and right triangles.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经惊讶了吗？我展示了一些切线（用于找出向量的角度）以及正弦和余弦（用于从极坐标转换为笛卡尔坐标系）的非常棒的应用。我可以在这里停下来并感到满足。但我不会这么做。这仅仅是个开始。正如我接下来将展示的，正弦和余弦能够为你做的远不止数学公式和直角三角形。
- en: '![Image](../images/pencil.jpg) **Exercise 3.5**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.5**'
- en: Using [Example 3.4](ch03.xhtml#ch3ex4) as a basis, draw a spiral path. Start
    in the center and move outward. Note that this can be done by changing only one
    line of code and adding one line of code!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以 [示例 3.4](ch03.xhtml#ch3ex4) 为基础，绘制一个螺旋路径。从中心开始，向外移动。请注意，这只需更改一行代码并添加一行代码！
- en: '![Image](../images/pg173_Image_251.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg173_Image_251.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 3.6**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.6**'
- en: 'Simulate the spaceship in the game *Asteroids*. In case you aren’t familiar
    with *Asteroids*, here’s a brief description: A spaceship (represented as a triangle)
    floats in 2D space. The left arrow key turns the spaceship counterclockwise; the
    right arrow key turns it clockwise. The Z key applies a thrust force in the direction
    the spaceship is pointing.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟游戏 *Asteroids* 中的飞船。如果你不熟悉 *Asteroids*，这里有一个简短的介绍：飞船（表示为一个三角形）漂浮在二维空间中。左箭头键将飞船逆时针旋转；右箭头键将其顺时针旋转。Z
    键在飞船指向的方向上施加推力。
- en: '![Image](../images/pg174_Image_252.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg174_Image_252.jpg)'
- en: '**Properties of Oscillation**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**振荡的性质**'
- en: Take a look at the graph of the sine function in [Figure 3.10](ch03.xhtml#ch3fig10),
    where *y* = sin(*x*).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [图 3.10](ch03.xhtml#ch3fig10) 中的正弦函数图，其中 *y* = sin(*x*)。
- en: '![Image](../images/pg174_Image_253.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg174_Image_253.jpg)'
- en: 'Figure 3.10: A graph of *y* = sin(*x*)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：*y* = sin(*x*) 的图像
- en: The output of the sine function is a smooth curve alternating between –1 and
    1, also known as a **sine wave**. This behavior, a periodic movement between two
    points, is the **oscillation** I mentioned at the start of the chapter. Plucking
    a guitar string, swinging a pendulum, bouncing on a pogo stick—all are examples
    of oscillating motion that can be modeled using the sine function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦函数的输出是一个平滑的曲线，在 -1 和 1 之间交替变化，也称为 **正弦波**。这种行为是周期性地在两个点之间运动，这就是我在章节开始时提到的
    **振荡**。拨动吉他弦、摆动钟摆、在弹跳棒上跳跃——这些都是可以通过正弦函数模拟的振荡运动的例子。
- en: 'In a p5.js sketch, you can simulate oscillation by assigning the output of
    the sine function to an object’s position. I’ll begin with a basic scenario: I
    want a circle to oscillate between the left side and the right side of a canvas
    ([Figure 3.11](ch03.xhtml#ch3fig11)).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 p5.js 草图中，你可以通过将正弦函数的输出赋值给一个物体的位置来模拟振荡。我将从一个基本的场景开始：我希望一个圆在画布的左侧和右侧之间振荡（[图
    3.11](ch03.xhtml#ch3fig11)）。
- en: '![Image](../images/pg175_Image_254.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg175_Image_254.jpg)'
- en: 'Figure 3.11: An oscillating circle'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：一个振荡的圆形
- en: This pattern of oscillating back and forth around a central point is known as
    **simple harmonic motion** (or, to be fancier, the periodic sinusoidal oscillation
    of an object). The code to achieve it is remarkably simple, but before I get into
    it, I’d like to introduce some of the key terminology related to oscillation (and
    waves).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种围绕中心点来回振荡的模式被称为**简谐运动**（或者，准确一点，物体的周期性正弦振荡）。实现这一点的代码非常简单，但在进入之前，我想介绍一些与振荡（和波动）相关的关键术语。
- en: 'When a moving object exhibits simple harmonic motion, its position (in this
    case, the x-position) can be expressed as a function of time, with the following
    two elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个物体表现出简谐运动时，它的位置（在此情况下是 x 位置）可以表示为时间的函数，包含以下两个要素：
- en: '**Amplitude:** The distance from the center of motion to either extreme'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**振幅：** 从运动中心到任一极端的距离'
- en: '**Period:** The duration (time) for one complete cycle of motion'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期：** 完整运动周期所需的时间'
- en: To understand these terms, look again at the graph of the sine function in [Figure
    3.10](ch03.xhtml#ch3fig10). The curve never rises above 1 or below –1 along the
    y-axis, so the sine function has an amplitude of 1\. Meanwhile, the wave pattern
    of the curve repeats every 2π units along the x-axis, so the sine function’s period
    is 2π. (By convention, the units here are radians, since the input value to the
    sine function is customarily an angle measured in radians.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些术语，请再看一眼[图 3.10](ch03.xhtml#ch3fig10)中的正弦函数图。曲线在 y 轴上从不超过 1 或低于 -1，因此正弦函数的振幅为
    1。同时，曲线的波形在 x 轴上每 2π 单位重复一次，因此正弦函数的周期为 2π。（按照惯例，这里的单位是弧度，因为正弦函数的输入值通常是以弧度衡量的角度。）
- en: So much for the amplitude and period of an abstract sine function, but what
    are amplitude and period in the p5.js world of an oscillating circle? Well, amplitude
    can be measured rather easily in pixels. For example, if the canvas is 200 pixels
    wide, I might choose to oscillate around the center of the canvas, going between
    100 pixels right of center and 100 pixels left of center. In other words, the
    amplitude is 100 pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是抽象正弦函数的振幅和周期，那么在 p5.js 中，一个振荡圆的振幅和周期是什么呢？嗯，振幅可以相对容易地用像素来衡量。例如，如果画布的宽度是 200
    像素，我可能会选择围绕画布中心进行振荡，从中心向右 100 像素到向左 100 像素。换句话说，振幅是 100 像素。
- en: '![Image](../images/pg176_Image_255.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_255.jpg)'
- en: 'The period is the amount of time for one complete cycle of an oscillation.
    However, in a p5.js sketch, what does *time* really mean? In theory, I could say
    I want the circle to oscillate every three seconds, then come up with an elaborate
    algorithm for moving the object according to real-world time, using `millis()`
    to track the passage of milliseconds. For what I’m trying to accomplish here,
    however, real-world time isn’t necessary. The more useful measure of time in p5.js
    is the number of **frames** that have elapsed, available through the built-in
    `frameCount` variable. Do I want the oscillating motion to repeat every 30 frames?
    Every 50 frames? For now, how about a period of 120 frames:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 周期是完成一个振荡周期所需的时间。然而，在 p5.js 草图中，*时间*到底意味着什么呢？理论上，我可以说我希望圆形每三秒振荡一次，然后根据现实世界的时间设计一个复杂的算法来移动物体，使用
    `millis()` 来跟踪毫秒的流逝。然而，对于我在这里要完成的任务，现实世界的时间并不必要。在 p5.js 中，更有用的时间衡量方式是已过去的**帧数**，这可以通过内置的
    `frameCount` 变量获得。我希望振荡运动每 30 帧重复一次？每 50 帧重复一次？目前，假设周期为 120 帧：
- en: '![Image](../images/pg176_Image_256.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_256.jpg)'
- en: 'Once I have the amplitude and period, it’s time to write a formula to calculate
    the circle’s x-position as a function of time (the current frame count):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我有了振幅和周期，就该写一个公式来计算圆的 x 位置，作为时间（当前帧数）的函数：
- en: '![Image](../images/pg176_Image_257.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_257.jpg)'
- en: 'Think about what’s going here. First, whatever value the `sin()` function returns
    is multiplied by `amplitude`. As you saw in [Figure 3.10](ch03.xhtml#ch3fig10),
    the output of the sine function oscillates between –1 and 1\. Multiplying that
    value by my chosen amplitude—call it *a*—gives me the desired result: a value
    that oscillates between –*a* and *a*. (This is also a place where you could use
    p5.js’s `map()` function to map the output of `sin()` to a custom range.)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这里发生了什么。首先，无论`sin()`函数返回什么值，都将乘以`amplitude`。正如你在[图3.10](ch03.xhtml#ch3fig10)中看到的，正弦函数的输出在–1和1之间振荡。将这个值乘以我选择的振幅——我们称之为*a*——就得到了所需的结果：一个在–*a*和*a*之间振荡的值。（这里也是你可以使用p5.js的`map()`函数，将`sin()`的输出映射到自定义范围的地方。）
- en: 'Now, think about what’s inside the `sin()` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想一想`sin()`函数内部发生了什么：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What’s going on here? Start with what you know. I’ve explained that sine has
    a period of 2π, meaning it will start at 0 and repeat at 2π, 4π, 6π, and so on.
    If my desired period of oscillation is 120 frames, I want the circle to be in
    the same position when `frameCount` is at 120 frames, 240 frames, 360 frames,
    and so on. Here, `frameCount` is the only value changing over time; it starts
    at 0 and counts upward. Let’s take a look at what the formula yields as `frameCount`
    increases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？从你已知的开始。我已经解释过，正弦的周期是2π，这意味着它将在0处开始，并在2π、4π、6π等位置重复。如果我希望振荡的周期为120帧，那么当`frameCount`达到120帧、240帧、360帧等时，圆形应处于相同位置。在这里，`frameCount`是唯一随着时间变化的值；它从0开始并递增。让我们看看当`frameCount`增加时公式会产生什么结果。
- en: '|  `frameCount`  | `frameCount / period` | `TWO_PI * frameCount / period` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  `frameCount`  | `frameCount / period` | `TWO_PI * frameCount / period` |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 60 | 0.5 | π |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 60 | 0.5 | π |'
- en: '| 120 | 1 | 2π |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 120 | 1 | 2π |'
- en: '| 240 | 2 | 4π |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 240 | 2 | 4π |'
- en: '| . . . | . . . | . . . |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| . . . | . . . | . . . |'
- en: Dividing `frameCount` by `period` tells me the number of cycles that have been
    completed. (Is the wave halfway through the first cycle? Have two cycles completed?)
    Multiplying that number by `TWO_PI`, I get the desired result, an appropriate
    input to the `sin()` function, since `TWO_PI` is the value required for sine (or
    cosine) to complete one full cycle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将`frameCount`除以`period`可以告诉我已完成的周期数。（波形是否已完成第一个周期的一半？是否已完成两个周期？）将这个数值乘以`TWO_PI`，我就得到了所需的结果，适合输入到`sin()`函数中，因为`TWO_PI`是正弦（或余弦）函数完成一个完整周期所需的值。
- en: Putting it together, here’s an example that oscillates the `x` position of a
    circle with an amplitude of 100 pixels and a period of 120 frames.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们结合起来，下面是一个示例，它通过振荡`x`坐标，产生一个振幅为100像素、周期为120帧的圆形运动。
- en: '![Image](../images/pg177_Image_258.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg177_Image_258.jpg)'
- en: Before moving on, I would be remiss not to mention **frequency**, the number
    of cycles of an oscillation per time unit. Frequency is the inverse of the period—that
    is, 1 divided by the period. For example, if the period is 120 frames, only 1/120th
    of a cycle is completed in 1 frame, and so the frequency is 1/120\. In [Example
    3.5](ch03.xhtml#ch3ex5), I chose to define the rate of oscillation in terms of
    the period, and therefore I didn’t need a variable for frequency. Sometimes, however,
    thinking in terms of frequency rather than period is more useful.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我不得不提一下**频率**，即每单位时间内振荡的周期数。频率是周期的倒数——也就是说，1除以周期。例如，如果周期是120帧，那么在1帧中完成的是周期的1/120，因此频率是1/120。在[示例3.5](ch03.xhtml#ch3ex5)中，我选择了通过周期来定义振荡速率，因此不需要为频率定义变量。然而，有时候，考虑频率而不是周期更有帮助。
- en: '![Image](../images/pencil.jpg) **Exercise 3.7**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.7**'
- en: Using the sine function, create a simulation of a weight (sometimes referred
    to as a *bob*) that hangs from a spring from the top of the window. Use the `map()`
    function to calculate the vertical position of the bob. In “Spring Forces” on
    [page 147](ch03.xhtml#ch00lev1sec38), I’ll demonstrate how to create this same
    simulation by modeling the forces of a spring according to Hooke’s law.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正弦函数，创建一个挂在窗口顶部的弹簧上的物体（有时称为*摆锤*）的模拟。使用`map()`函数计算摆锤的垂直位置。在[第147页](ch03.xhtml#ch00lev1sec38)的《弹簧力》一节中，我将展示如何根据胡克定律创建这种模拟。
- en: '**Oscillation with Angular Velocity**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**角速度振荡**'
- en: 'An understanding of oscillation, amplitude, and period (or frequency) can be
    essential in the course of simulating real-world behaviors. However, there’s a
    slightly easier way to implement the simple harmonic motion from [Example 3.5](ch03.xhtml#ch3ex5),
    one that achieves the same result with fewer variables. Take one more look at
    the oscillation formula:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 理解振动、振幅和周期（或频率）在模拟现实世界行为时可能至关重要。然而，有一种稍微简单的方法来实现[示例3.5](ch03.xhtml#ch3ex5)中的简谐运动，这种方法通过更少的变量达成相同的结果。再看看振动公式：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now I’ll rewrite it in a slightly different way:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将以稍微不同的方式重写它：
- en: '[PRE5]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you care about precisely defining the period of oscillation in terms of frames
    of animation, you might need the formula as I first wrote it. If you don’t care
    about the exact period, however—for example, if you’ll be choosing it randomly—all
    you really need inside the `sin()` function is a value that increments slowly
    enough for the object’s motion to appear smooth from one frame to the next. Every
    time this value ticks past a multiple of 2π, the object will have completed one
    cycle of oscillation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心精确定义振荡周期（以动画帧为单位），你可能需要我最初写的公式。然而，如果你不关心准确的周期——例如，如果你将随机选择它——那么你真正需要的只是`sin()`函数内部的一个值，该值增加得足够慢，以便物体的运动在每一帧之间看起来是平滑的。每当这个值越过2π的倍数时，物体就完成了一个振荡周期。
- en: This technique mirrors what I did with Perlin noise in [Chapter 0](ch00.xhtml#ch00).
    In that case, I incremented an offset variable (which I called `t` or `xoff`)
    to sample various outputs from the `noise()` function, creating a smooth transition
    of values. Now, I’m going to increment a value (I’ll call it `angle`) that’s fed
    into the `sin()` function. The difference is that the output from `sin()` is a
    smoothly repeating sine wave, without any randomness.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与我在[第0章](ch00.xhtml#ch00)中使用Perlin噪声时做的类似。在那种情况下，我增加了一个偏移量变量（我称它为`t`或`xoff`）来从`noise()`函数中采样不同的输出，创建平滑的值过渡。现在，我将增加一个值（我称它为`angle`），并将其输入到`sin()`函数中。不同之处在于，`sin()`的输出是平滑重复的正弦波，没有任何随机性。
- en: 'You might be wondering why I refer to the incrementing value as `angle`, given
    that the object has no visible rotation. The term *angle* is used because the
    value is passed into the `sin()` function, and angles are the traditional inputs
    to trigonometric functions. With this in mind, I can reintroduce the concept of
    angular velocity (and acceleration) to rewrite the example to calculate the `x`
    position in terms of a changing angle. I’ll assume these global variables:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我把增量值称为`angle`，因为物体没有明显的旋转。之所以使用*角度*这个术语，是因为这个值被传递到`sin()`函数中，而角度是三角函数的传统输入值。考虑到这一点，我可以重新引入角速度（和加速度）的概念，将示例重写为根据变化的角度计算`x`位置。我假设这些全局变量：
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I can then write this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以写出如下代码：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here `angle` is my “value that increments slowly,” and the amount it slowly
    increments by is `angleVelocity`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`angle`是我“缓慢增加的值”，它缓慢增加的量是`angleVelocity`。
- en: '![Image](../images/pg179_Image_260.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg179_Image_260.jpg)'
- en: 'Just because I’m not referencing the period directly doesn’t mean that I’ve
    eliminated the concept. After all, the greater the angular velocity, the faster
    the circle will oscillate (and therefore the shorter the period). In fact, the
    period is the number of frames it takes for `angle` to increment by 2π. Since
    the amount `angle` increments is controlled by the angular velocity, I can calculate
    the period as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为我没有直接引用周期，并不意味着我已经消除了这个概念。毕竟，角速度越大，圆形的振动越快（因此周期越短）。事实上，周期是`angle`增量达到2π所需的帧数。由于`angle`的增量由角速度控制，我可以通过以下方式计算周期：
- en: period = 2π/angular velocity
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: period = 2π/角速度
- en: To illustrate the power of thinking of oscillation in terms of angular velocity,
    I’ll expand the example a bit more by creating an `Oscillator` class whose objects
    can oscillate independently along both the x-axis (as before) *and* the y-axis.
    The class will need two angles, two angular velocities, and two amplitudes (one
    for each axis).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明将振动视为角速度的强大力量，我将通过创建一个`Oscillator`类来进一步扩展示例，其对象可以沿x轴（如前所述）*和* y轴独立振荡。该类需要两个角度、两个角速度和两个振幅（每个轴一个）。
- en: This is a perfect opportunity to use `createVector()` to package each pair of
    values together! Unlike previous vectors, the values in these vectors won’t be
    sets of Cartesian coordinates. Nevertheless, the `p5.Vector` class provides a
    convenient way to manage pairs of values—in this case, pairs of angles (and their
    associated velocities, accelerations, and so on).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个绝佳的机会，可以使用`createVector()`将每对值打包在一起！与之前的向量不同，这些向量中的值将不再是笛卡尔坐标集。然而，`p5.Vector`类提供了一种方便的方式来管理值对——在这种情况下，是一对对的角度（以及它们的相关速度、加速度等）。
- en: '![Image](../images/pg181_Image_262.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg181_Image_262.jpg)'
- en: To better understand the `Oscillator` class, it might be helpful to focus on
    the movement of a single oscillator in the animation. First, observe its horizontal
    movement. You’ll notice that it oscillates regularly back and forth along the
    x-axis. Switching your focus to its vertical movement, you’ll see it oscillating
    up and down along the y-axis. Each oscillator has its own distinct rhythm, given
    the random initialization of its angle, angular velocity, and amplitude.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`Oscillator`类，集中注意力观察动画中单个振荡器的运动可能会很有帮助。首先，观察其水平运动。你会注意到它沿x轴规律地前后振荡。将注意力转向其垂直运动，你会看到它沿y轴上下振荡。每个振荡器都有自己独特的节奏，因为它的角度、角速度和振幅是随机初始化的。
- en: The key is to recognize that the `x` and `y` properties of the `p5.Vector` objects
    `this.angle`, `this.angleVelocity`, and `this.amplitude` aren’t tied to spatial
    vectors anymore. Instead, they’re used to store the respective properties for
    two separate oscillations (one along the x-axis, one along the y-axis). Ultimately,
    these oscillations are manifested spatially when `x` and `y` are calculated in
    the `show()` method, mapping the oscillations onto the positions of the object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于认识到`p5.Vector`对象`this.angle`、`this.angleVelocity`和`this.amplitude`的`x`和`y`属性不再与空间向量相关联。相反，它们用于存储两个独立振荡的相应属性（一个沿x轴，另一个沿y轴）。最终，当`x`和`y`在`show()`方法中计算时，这些振荡在空间上得以体现，将振荡映射到物体的位置上。
- en: '![Image](../images/pencil.jpg) **Exercise 3.8**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习3.8**'
- en: Try initializing each `Oscillator` object with velocities and amplitudes that
    aren’t random to create some sort of regular pattern. Can you make the oscillators
    appear to be the legs of an insect-like creature?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用非随机的速度和振幅初始化每个`Oscillator`对象，以创建某种规律性的图案。你能让振荡器看起来像昆虫的腿吗？
- en: '![Image](../images/pencil.jpg) **Exercise 3.9**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习3.9**'
- en: Incorporate angular acceleration into the `Oscillator` object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将角加速度加入到`Oscillator`对象中。
- en: '**Waves**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**波动**'
- en: Imagine a single circle oscillating up and down according to the sine function.
    This is the equivalent of simulating a single point along the x-axis of a wave.
    With a little panache and a `for` loop, you can animate the entire wave by placing
    a series of oscillating circles next to one another ([Figure 3.12](ch03.xhtml#ch3fig12)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个单独的圆圈根据正弦函数上下振荡。这相当于模拟波的x轴上的一个点。稍微加点花样，配合一个`for`循环，你可以通过将一系列振荡圆圈排成一行来动画化整个波形（见[图3.12](ch03.xhtml#ch3fig12)）。
- en: '![Image](../images/pg182_Image_263.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg182_Image_263.jpg)'
- en: 'Figure 3.12: Animating the sine wave with oscillating circles'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：通过振荡圆圈来动画化正弦波
- en: You could use this wavy pattern to design the body or appendages of a creature,
    or to simulate a soft surface (such as water). Let’s dive into how the code for
    this sketch works.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种波动图案来设计生物的身体或附肢，或者模拟一个柔软的表面（如水面）。让我们深入了解这个草图代码的工作原理。
- en: Here, the same concepts of amplitude (the wave’s height) and period (the wave’s
    duration) come into play. However, when drawing the entire wave, the term *period*
    shifts its meaning from representing time to describing the width (in pixels)
    of a full wave cycle. The term for the spatial period (as opposed to the temporal
    period) of a wave is **wavelength**—the distance a wave travels to complete one
    full oscillation cycle. And just as with the previous oscillation example, you
    have the choice of computing the wave pattern according to a precise wavelength
    or by arbitrarily incrementing the angle value (*delta angle*) for each spot on
    the wave.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，振幅（波的高度）和周期（波的持续时间）这两个概念同样适用。然而，当绘制整个波时，术语*周期*的含义发生了变化，它不再表示时间，而是描述一个完整波动周期的宽度（以像素为单位）。波的空间周期（与时间周期相对）称为**波长**——即波完成一个完整振荡周期所经过的距离。就像前面振荡的例子一样，你可以选择根据精确的波长来计算波形，或者通过为波上的每个点随意递增角度值（*delta
    angle*）来进行计算。
- en: 'I’ll go with the simpler case, incrementing the angle. I know I need three
    variables: an angle, a delta angle (analogous to the previous angular velocity),
    and an amplitude:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我将选择更简单的情况，递增角度。我知道我需要三个变量：角度、增量角度（类似于之前的角速度），和振幅：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then I’m going to loop through all the `x` values for each point on the wave.
    For now, I’ll put 24 pixels between adjacent `x` values. For each `x`, I’ll follow
    these three steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将循环遍历波上每个点的`x`值。目前，我将相邻的`x`值之间间隔24像素。对于每个`x`，我将执行以下三个步骤：
- en: Calculate the y-position according to amplitude and the sine of the angle.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据振幅和角度的正弦值计算y坐标。
- en: Draw a circle at the (*x*, *y*) position.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在(*x*, *y*)位置画一个圆。
- en: Increment the angle by the delta angle.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`deltaAngle`递增角度。
- en: The following example translates these steps into code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将这些步骤转化为代码。
- en: '![Image](../images/pg183_Image_264.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg183_Image_264.jpg)'
- en: What happens if you try different values for `deltaAngle`? [Figure 3.13](ch03.xhtml#ch3fig13)
    shows some options.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试不同的`deltaAngle`值会发生什么呢？[图 3.13](ch03.xhtml#ch3fig13)展示了几种选择。
- en: '![Image](../images/pg184_Image_266.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg184_Image_266.jpg)'
- en: 'Figure 3.13: Three sine waves with varying `deltaAngle` values (0.05, 0.2,
    and 0.6 from left to right)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：三个不同`deltaAngle`值的正弦波（从左到右分别是0.05，0.2和0.6）
- en: Although I’m not precisely calculating the wavelength, you can see that the
    greater the change in angle, the shorter the wavelength. It’s also worth noting
    that as the wavelength decreases, it becomes more difficult to make out the wave
    since the vertical distance between the individual points increases.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我没有精确计算波长，但你可以看到，角度变化越大，波长越短。还值得注意的是，随着波长的减小，波变得越来越难以辨认，因为各个点之间的垂直距离增加了。
- en: Notice that everything in [Example 3.8](ch03.xhtml#ch3ex8) happens inside `setup()`,
    so the result is static. The wave never changes or undulates. Adding motion is
    a bit tricky. Your first instinct might be to say, “Hey, no problem, I’ll just
    put the `for` loop inside the `draw()` function and let `angle` continue incrementing
    from one cycle to the next.”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[示例 3.8](ch03.xhtml#ch3ex8)中的所有内容都发生在`setup()`内部，因此结果是静态的。波动永远不会改变或起伏。添加运动会有点棘手。你第一反应可能是说：“嘿，没问题，我只需将`for`循环放入`draw()`函数中，让`angle`从一个周期递增到下一个。”
- en: That’s a nice thought, but it doesn’t work. If you try it out, the result will
    appear extremely erratic and glitchy. To understand why, look back at [Example
    3.8](ch03.xhtml#ch3ex8). The right edge of the wave doesn’t match the height of
    the left edge, so where the wave ends in one cycle of `draw()` can’t be where
    it starts in the next. Instead, you need a variable dedicated entirely to tracking
    the starting `angle` value in each frame of the animation. This variable (which
    I’ll call `startAngle`) increments at its own pace, controlling how much the wave
    progresses from one frame to the next.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的想法，但它行不通。如果你尝试一下，结果会显得极为不稳定和故障频发。要理解为什么，回顾一下[示例 3.8](ch03.xhtml#ch3ex8)。波的右边缘与左边缘的高度不匹配，因此波在一次`draw()`循环中的结束位置不能是下一个循环的起始位置。相反，你需要一个专门用于追踪每一帧动画中起始`angle`值的变量。这个变量（我将其称为`startAngle`）按自己的节奏递增，控制波从一帧到下一帧的进展。
- en: '![Image](../images/pg185_Image_267.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg185_Image_267.jpg)'
- en: In this code example, the increment of `startAngle` is hardcoded to be `0.02`,
    but you may want to consider reusing `deltaAngle` or creating a second variable
    instead. By reusing `deltaAngle`, the spatial progression of the wave would be
    tied to the temporal one, possibly creating a more synchronized movement. Introducing
    a separate variable, perhaps called `startAngleVelocity`, would allow independent
    control of the speed of the wave. The term *velocity* is appropriate here since
    the start angle is changing over time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`startAngle`的增量被硬编码为`0.02`，但你可能想考虑重用`deltaAngle`或创建一个第二个变量。通过重用`deltaAngle`，波形的空间进展将与时间进展紧密关联，可能会创造出更同步的运动。如果引入一个单独的变量，或许叫做`startAngleVelocity`，则可以独立控制波形的速度。这里使用*速度*一词是合适的，因为起始角度是随着时间变化的。
- en: '![Image](../images/pencil.jpg) **Exercise 3.10**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.10**'
- en: Try using the Perlin noise function instead of sine or cosine to set the `y`
    values in [Example 3.9](ch03.xhtml#ch3ex9).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Perlin噪声函数代替正弦或余弦函数来设置[示例 3.9](ch03.xhtml#ch3ex9)中的`y`值。
- en: '![Image](../images/pencil.jpg) **Exercise 3.11**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.11**'
- en: Encapsulate the wave-generating code into a `Wave` class, and create a sketch
    that displays two waves (with different amplitudes/periods), as shown in the following
    image. Try moving beyond plain circles and lines to visualize the wave in a more
    creative way. What about connecting the points by using `beginShape()`, `endShape()`,
    and `vertex()`?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将波形生成代码封装到一个`Wave`类中，并创建一个显示两个波形（具有不同振幅/周期）的草图，如下图所示。尝试超越简单的圆形和线条，以更具创意的方式可视化波形。如何通过使用`beginShape()`、`endShape()`和`vertex()`连接这些点呢？
- en: '![Image](../images/pg186_Image_268.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg186_Image_268.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 3.12**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.12**'
- en: To create more complex waves, you can add multiple waves together. Calculate
    the height (or `y`) values for several waves and add those values together to
    get a single `y` value. The result is a new wave that incorporates the characteristics
    of each individual wave.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更复杂的波形，你可以将多个波形叠加在一起。计算多个波形的高度（或`y`）值，并将这些值加在一起，得到一个单一的`y`值。结果是一个新的波形，它融合了每个单独波形的特征。
- en: '![Image](../images/pg186_Image_269.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg186_Image_269.jpg)'
- en: '**Spring Forces**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**弹簧力**'
- en: Exploring the mathematics of triangles and waves has been lovely, but perhaps
    you’re starting to miss Newton’s laws of motion and vectors. After all, the core
    of this book is about simulating the physics of moving bodies. In “Properties
    of Oscillation” on [page 134](ch03.xhtml#ch00lev1sec35), I modeled simple harmonic
    motion by mapping a sine wave to a range of pixels on a canvas. [Exercise 3.7](ch03.xhtml#ch3exe7)
    asked you to use this technique to create a simulation of a bob hanging from a
    spring with the `sin()` function. That kind of quick-and-dirty, one-line-of-code
    solution won’t do, however, if what you really want is a bob hanging from a spring
    that responds to other forces in the environment (wind, gravity, and so on). To
    achieve a simulation like that, you need to model the force of the spring by using
    vectors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 探索三角形和波的数学非常有趣，但也许你开始怀念牛顿的运动定律和向量了。毕竟，本书的核心内容是模拟运动物体的物理。在《振荡性质》一章中（见[第134页](ch03.xhtml#ch00lev1sec35)），我通过将正弦波映射到画布上的像素范围来模拟简谐运动。[练习
    3.7](ch03.xhtml#ch3exe7)要求你使用这种技术来创建一个由`sin()`函数驱动的悬挂在弹簧上的摆。然而，如果你真正想要的是一个响应环境中其他力（如风力、重力等）的弹簧摆，单靠这种快速简洁的代码解决方案就不够了。要实现这样的模拟，你需要使用向量来模拟弹簧的力。
- en: '![Image](../images/pg187_Image_270.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg187_Image_270.jpg)'
- en: 'Figure 3.14: A spring with an anchor and bob'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：带有锚点和摆的弹簧
- en: I’ll consider a spring to be a connection between a movable bob (or weight)
    and a fixed anchor point (see [Figure 3.14](ch03.xhtml#ch3fig14)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我将弹簧视为一个连接可移动的摆（或重物）和固定的锚点之间的连接（见[图 3.14](ch03.xhtml#ch3fig14)）。
- en: 'The force of the spring is a vector calculated according to Hooke’s law, named
    for Robert Hooke, a British physicist who developed the formula in 1660\. Hooke
    originally stated the law in Latin: “*Ut tensio, sic vis*,” or “As the extension,
    so the force.” Think of it this way:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧的力是根据胡克定律计算的，这一定律以英国物理学家罗伯特·胡克的名字命名，他于1660年提出了这个公式。胡克最初用拉丁语表述了这个定律：“*Ut tensio,
    sic vis*”，意思是“伸长多少，力就有多少”。可以这样理解：
- en: '![Image](../images/pg187_Image_271.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg187_Image_271.jpg)'
- en: 'Figure 3.15: A spring’s extension (*x*) is the difference between its current
    length and its rest length.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：弹簧的伸长（*x*）是其当前长度与静止长度之间的差值。
- en: The force of the spring is directly proportional to the extension of the spring.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧的力与弹簧的伸长量成正比。
- en: 'The extension is a measure of how much the spring has been stretched or compressed:
    as shown in [Figure 3.15](ch03.xhtml#ch3fig15), it’s the difference between the
    current length of the spring and the spring’s resting length (its equilibrium
    state). Hooke’s law therefore says that if you pull on the bob a lot, the spring’s
    force will be strong, whereas if you pull on the bob a little, the force will
    be weak.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 伸长量是衡量弹簧被拉伸或压缩的程度：如[图3.15](ch03.xhtml#ch3fig15)所示，它是弹簧当前长度与静止长度（其平衡状态）之间的差值。因此，胡克定律表明，如果你用力拉动摆锤，弹簧的力会很强，而如果拉动摆锤的力较小，弹簧的力就会较弱。
- en: 'Mathematically, the law is stated as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，这一定律可以表述如下：
- en: '*F[spring]* = −*kx*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[spring]* = −*kx*'
- en: Here *k* is the *spring constant*. Its value scales the force, setting how elastic
    or rigid the spring is. Meanwhile, *x* is the extension, the current length minus
    the rest length.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*k*是*弹簧常数*。它的值决定了力的大小，设置了弹簧的弹性或刚性。同时，*x*是伸长量，即当前长度减去静止长度。
- en: 'Now remember, force is a vector, so you need to calculate both magnitude and
    direction. For the code, I’ll start with the following three variables—two vectors
    for the anchor and bob positions, and one rest length:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住，力是一个向量，所以你需要计算其大小和方向。对于代码，我将从以下三个变量开始——两个表示锚点和摆锤位置的向量，以及一个静止长度：
- en: '![Image](../images/pg188_Image_272.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg188_Image_272.jpg)'
- en: 'I’ll then use Hooke’s law to calculate the magnitude of the force. For that,
    I need `k` and `x`. Calculating `k` is easy; it’s just a constant, so I’ll make
    something up:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将使用胡克定律来计算力的大小。为此，我需要`k`和`x`。计算`k`很简单，它只是一个常数，所以我将虚构一个值：
- en: '[PRE9]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finding `x` is perhaps a bit more difficult. I need to know the difference between
    the current length and the rest length. The rest length is defined as the variable
    `restLength`. What’s the current length? The distance between the anchor and the
    bob. And how can I calculate that distance? How about the magnitude of a vector
    that points from the anchor to the bob? (Note that this is exactly the same process
    I employed to find the distance between objects for the purposes of calculating
    gravitational attraction in [Chapter 2](ch02.xhtml#ch02).)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 求解`x`或许有些困难。我需要知道当前长度和静止长度之间的差异。静止长度被定义为变量`restLength`。当前长度是多少？是锚点和摆锤之间的距离。那么我该如何计算这个距离呢？如何通过从锚点到摆锤的向量大小来计算呢？（请注意，这与我在[第2章](ch02.xhtml#ch02)中用来计算物体之间的引力的过程完全相同。）
- en: '![Image](../images/pg188_Image_273.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg188_Image_273.jpg)'
- en: Now that I’ve sorted out the elements necessary for the magnitude of the force
    (–*kx*), I need to figure out the direction, a unit vector pointing in the direction
    of the force. The good news is that I already have this vector. Right? Just a
    moment ago I asked the question, “How can I calculate that distance?” and I answered,
    “How about the magnitude of a vector that points from the anchor to the bob?”
    Well, that vector describes the direction of the force!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经整理出了计算力的大小（–*kx*）所需的元素，接下来我需要搞清楚方向，即指向力方向的单位向量。好消息是，我已经有了这个向量。对吧？就在刚才，我问过一个问题，“如何计算那个距离？”然后我回答，“如何通过从锚点到摆锤的向量大小来计算？”嗯，那个向量描述了力的方向！
- en: '[Figure 3.16](ch03.xhtml#ch3fig16) shows that if you stretch the spring beyond
    its rest length, a force should pull it back toward the anchor. And if the spring
    shrinks below its rest length, the force should push it away from the anchor.
    The Hooke’s law formula accounts for this reversal of direction with the –1.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.16](ch03.xhtml#ch3fig16)显示，如果你将弹簧拉伸到超过其静止长度，就会有一个力将其拉回锚点。如果弹簧收缩到低于其静止长度，就会有一个力将其推离锚点。胡克定律公式通过–1来考虑这种方向的反转。'
- en: '![Image](../images/pg189_Image_274.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg189_Image_274.jpg)'
- en: 'Figure 3.16: The spring force points in the opposite direction of the displacement.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：弹簧的力指向位移的相反方向。
- en: 'All I need to do now is set the magnitude of the vector used for the distance
    calculation. Let’s take a look at the code and rename that vector variable `force`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我所需要做的就是设置用于计算距离的向量的大小。让我们来看一下代码，并将该向量变量重命名为`force`：
- en: '![Image](../images/pg189_Image_275.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg189_Image_275.jpg)'
- en: 'Now that I have the algorithm for computing the spring force, the question
    remains: What OOP structure should I use? This is one of those situations that
    has no one correct answer. Several possibilities exist, and the one I choose depends
    on my goals and personal coding style.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经有了计算弹簧力的算法，问题依然存在：我应该使用什么OOP结构？这是那种没有唯一正确答案的情况。存在多种可能性，我选择的方案取决于我的目标和个人编码风格。
- en: 'Since I’ve been working all along with a `Mover` class, I’ll stick with this
    same framework. I’ll think of the `Mover` class as the spring’s bob. The bob needs
    `position`, `velocity`, and `acceleration` vectors to move about the canvas. Perfect—I
    have those already! And perhaps the bob experiences a gravity force via the `applyForce()`
    method. This leaves just one more step, applying the spring force:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我一直在使用`Mover`类，所以我将继续使用这个框架。我会把`Mover`类看作是弹簧的摆锤。摆锤需要`position`、`velocity`和`acceleration`向量来在画布上移动。完美——我已经有了这些！而且也许摆锤通过`applyForce()`方法经历了一个重力力。这只剩下最后一步了，施加弹簧力：
- en: '![Image](../images/pg189_Image_276.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg189_Image_276.jpg)'
- en: One option would be to write all the spring-force code in the main `draw()`
    loop. But thinking ahead to when you might have multiple bob and spring connections,
    it would be wise to create an additional class, a `Spring` class. As shown in
    [Figure 3.17](ch03.xhtml#ch3fig17), the `Bob` class keeps track of the bob’s movements;
    the `Spring` class keeps track of the spring’s anchor position and its rest length,
    and calculates the spring force on the bob.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是将所有弹簧力的代码写在主`draw()`循环中。但考虑到未来可能有多个摆锤和弹簧连接，明智的做法是创建一个额外的类，`Spring`类。正如[图3.17](ch03.xhtml#ch3fig17)所示，`Bob`类跟踪摆锤的运动；`Spring`类跟踪弹簧的锚点位置及其静止长度，并计算施加在摆锤上的弹簧力。
- en: '![Image](../images/pg190_Image_278.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg190_Image_278.jpg)'
- en: 'Figure 3.17: The `Spring` class has anchor and rest length; the `Bob` class
    has position, velocity, and acceleration.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17：`Spring`类有锚点和静止长度；`Bob`类有位置、速度和加速度。
- en: 'This allows me to write a lovely sketch as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我能够写出如下漂亮的草图：
- en: '![Image](../images/pg190_Image_279.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg190_Image_279.jpg)'
- en: 'Think about how this compares to my first stab at gravitational attraction
    in [Example 2.6](ch02.xhtml#ch2ex6), when I had separate `Mover` and `Attractor`
    classes. There, I wrote something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这和我在[示例2.6](ch02.xhtml#ch2ex6)中第一次尝试重力吸引的情况有何异同，那时我有单独的`Mover`和`Attractor`类。在那里，我写了类似这样的代码：
- en: '[PRE10]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The analogous situation with a spring might have been as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧的类似情况可能如下所示：
- en: '[PRE11]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead, in this example I have the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这个示例中，我有以下内容：
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What gives? Why don’t I need to call `applyForce()` on the bob? The answer,
    of course, is that I *do* need to call `applyForce()` on the bob. It’s just that
    instead of doing it in `draw()`, I’m demonstrating that a perfectly reasonable
    (and sometimes preferable) alternative is to ask the `connect()` method to call
    `applyForce()` on the bob internally:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？为什么我不需要在摆锤上调用`applyForce()`？答案当然是，我*确实*需要在摆锤上调用`applyForce()`。只不过，我不是在`draw()`中调用它，而是展示了一个完全合理（有时更可取）的替代方案，那就是让`connect()`方法在内部调用`applyForce()`：
- en: '![Image](../images/pg191_Image_281.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg191_Image_281.jpg)'
- en: Why do it one way with the `Attractor` class and another way with the `Spring`
    class? When I first discussed forces, showing all the forces being applied in
    the `draw()` loop was a clearer way to help you learn about force accumulation.
    Now that you’re more comfortable, perhaps it’s simpler to embed some of the details
    inside the objects themselves.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在`Attractor`类中用一种方式，而在`Spring`类中用另一种方式？当我第一次讨论力时，在`draw()`循环中显示所有施加的力是一种更清晰的方式，帮助你了解力的累积。现在你已经更熟悉了，或许将一些细节嵌入到对象内部更简单一些。
- en: Let’s take a look at the rest of the elements in the `Spring` class.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Spring`类中的其他元素。
- en: '![Image](../images/pg192_Image_282.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg192_Image_282.jpg)'
- en: 'The complete code for this example is available on the book’s website and incorporates
    two additional features: (1) the `Bob` class includes methods for mouse interactivity,
    allowing you to drag the bob around the window, and (2) the `Spring` class includes
    a method to constrain the connection’s length between a minimum and a maximum
    value.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在本书的网站上找到，并加入了两个附加功能：（1）`Bob`类包括鼠标交互方法，允许你在窗口中拖动摆锤，（2）`Spring`类包括一个方法，用于将连接的长度限制在最小值和最大值之间。
- en: '![Image](../images/pencil.jpg) **Exercise 3.13**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.13**'
- en: 'Before running to see the example online, take a look at this `constrainLength`
    method and see if you can fill in the blanks:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在去在线查看示例之前，先看一下这个`constrainLength`方法，看看你是否能填补其中的空白：
- en: '![Image](../images/pg193_Image_284.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg193_Image_284.jpg)'
- en: '![Image](../images/pencil.jpg) **Exercise 3.14**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.14**'
- en: Create a system of multiple bobs and spring connections. How about connecting
    a bob to another bob with no fixed anchor?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含多个钟摆球和弹簧连接的系统。怎么样，把一个钟摆球连接到另一个没有固定锚点的钟摆球上？
- en: '**The Pendulum**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**钟摆**'
- en: You might have noticed that in [Example 3.10](ch03.xhtml#ch3ex10)’s spring code,
    I never once used sine or cosine. Before you write off all this trigonometry stuff
    as a tangent, however, allow me to show an example of how it all fits together.
    Imagine a bob hanging from an anchor connected by a spring with a fully rigid
    connection that can be neither compressed nor extended. This idealized scenario
    describes a pendulum and provides an excellent opportunity to practice combining
    all that you’ve learned about forces and trigonometry.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在[示例 3.10](ch03.xhtml#ch3ex10)的弹簧代码中，我从未使用过正弦或余弦。然而，在你把所有这些三角学内容当作旁枝末节时，请允许我展示一个例子，说明这一切是如何结合在一起的。想象一个吊坠从一个锚点悬挂，锚点通过弹簧与其相连，且连接是完全刚性的，既不能压缩也不能伸展。这个理想化的情景描述了一个钟摆，并提供了一个绝佳的机会，让你练习将所学的力学和三角学知识结合起来。
- en: '![Image](../images/pg194_Image_285.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg194_Image_285.jpg)'
- en: 'Figure 3.18: A pendulum with a pivot, arm, and bob'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：一个带有支点、摆臂和钟摆球的钟摆
- en: 'A **pendulum** is a bob suspended by an arm from a pivot (previously called
    the *anchor* in the spring). When the pendulum is at rest, it hangs straight down,
    as in [Figure 3.18](ch03.xhtml#ch3fig18). If you lift up the pendulum at an angle
    from its resting state and then release it, however, it starts to swing back and
    forth, tracing the shape of an arc. A real-world pendulum would live in a 3D space,
    but I’m going to look at a simpler scenario: a pendulum in the 2D space of a p5.js
    canvas. [Figure 3.19](ch03.xhtml#ch3fig19) shows the pendulum in a nonresting
    position and adds the forces at play: gravity and tension.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**钟摆**是一个通过摆臂悬挂在支点上的钟摆球（在弹簧中曾被称为*锚点*）。当钟摆静止时，它会垂直向下悬挂，如[图 3.18](ch03.xhtml#ch3fig18)所示。然而，如果你将钟摆从静止状态抬起到一个角度，然后释放它，它就会开始来回摆动，划出一个弧形轨迹。现实中的钟摆会生活在三维空间中，但我将研究一个更简单的情景：一个位于p5.js画布二维空间中的钟摆。[图
    3.19](ch03.xhtml#ch3fig19)显示了一个非静止位置的钟摆，并添加了作用力：重力和张力。
- en: When the pendulum swings, its arm and bob are essentially rotating around the
    fixed point of the pivot. If no arm connected the bob and the pivot, the bob would
    simply fall to the ground under the influence of gravity. Obviously, that isn’t
    what happens. Instead, the fixed length of the arm creates the second force—tension.
    However, I’m not going to work with this scenario according to these forces, at
    least not in the way I approached the spring scenario.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当钟摆摆动时，它的摆臂和钟摆球基本上是绕着固定的支点旋转的。如果没有摆臂连接钟摆球和支点，钟摆球会在重力的作用下直接掉到地面上。显然，这并不是发生的事情。相反，摆臂的固定长度产生了第二个力——张力。然而，我不会按照这些力来处理这个情景，至少不像我处理弹簧情景那样。
- en: 'Instead of using *linear* acceleration and velocity, I’m going to describe
    the motion of the pendulum in terms of *angular* acceleration and *angular* velocity,
    which refer to the change of the arm’s angle *θ* relative to the pendulum’s resting
    position. I should first warn you, especially if you’re a seasoned physicist,
    that I’m going to conveniently ignore several important concepts here: conservation
    of energy, momentum, centripetal force, and more. This isn’t intended to be a
    comprehensive description of pendulum physics. My goal is to offer you an opportunity
    to practice your new skills in trigonometry and further explore the relationship
    between forces and angles through a concrete example.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我将不使用*线性*加速度和速度，而是用*角加速度*和*角速度*来描述钟摆的运动，这指的是摆臂相对于钟摆静止位置的角度*θ*的变化。我应该先警告你，尤其是如果你是一个经验丰富的物理学家，我将方便地忽略几个重要的概念：能量守恒、动量、向心力等等。这并不是对钟摆物理的全面描述。我的目标是给你一个机会，练习你新学的三角学技巧，并通过一个具体的例子进一步探索力和角度之间的关系。
- en: '![Image](../images/pg195_Image_286.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg195_Image_286.jpg)'
- en: 'Figure 3.19: A pendulum showing *θ* as the angle relative to its resting position'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19：一个钟摆，显示*θ*为相对于其静止位置的角度
- en: To calculate the pendulum’s angular acceleration, I’m going to use Newton’s
    second law of motion but with a little trigonometric twist. Take a look at [Figure
    3.19](ch03.xhtml#ch3fig19) and tilt your head so that the pendulum’s arm becomes
    the vertical axis. The force of gravity suddenly points askew, a little to the
    left—it’s at an angle with respect to your tilted head. If this is starting to
    hurt your neck, don’t worry. I’ll redraw the tilted figure and relabel the forces
    *F[g]* for gravity and *T* for tension ([Figure 3.20](ch03.xhtml#ch3fig20), left).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算摆的角加速度，我将使用牛顿第二定律，但会加上一些三角学的技巧。看看[图 3.19](ch03.xhtml#ch3fig19)，并将头倾斜，使得摆的臂变成垂直轴。重力的方向突然发生偏移，稍微向左—it’s
    at an angle with respect to your tilted head。如果这开始让你的脖子有点疼，别担心。我会重新绘制倾斜后的图形，并重新标注力*F[g]*代表重力，*T*代表张力（[图
    3.20](ch03.xhtml#ch3fig20)，左侧）。
- en: Let’s now take the force of gravity and divide its vector into x- and y-components,
    with the arm as the new y-axis. These components form a right triangle, with the
    force of gravity as the hypotenuse ([Figure 3.20](ch03.xhtml#ch3fig20), right).
    I’ll call them *F[gx]* and *F[gy]*, but what do these components mean? Well, the
    *F[gy]* component represents the force that’s opposite to *T*, the tension force.
    Remember, the tension force is what keeps the bob from falling off.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将重力分解为x轴和y轴的分量，以摆臂为新的y轴。这些分量形成一个直角三角形，重力作为斜边（[图 3.20](ch03.xhtml#ch3fig20)，右侧）。我将它们称为*F[gx]*和*F[gy]*，但这些分量是什么意思呢？嗯，*F[gy]*分量代表与*F[gy]*反向的张力力。记住，张力力就是使摆锤不会掉下来的力。
- en: The other component, *F[gx]*, is perpendicular to the arm of the pendulum, and
    it’s the force I’ve been looking for all along! It causes the pendulum to rotate.
    As the pendulum swings, the y-axis (the arm) will always be perpendicular to the
    direction of motion. Therefore, I can ignore the tension and *F[gy]* forces and
    focus on *F[gx]*, which is the **net force** in the direction of motion. And because
    this force is part of a right triangle, I can calculate it with . . . you guessed
    it, trigonometry!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个分量*F[gx]*垂直于摆臂，它正是我一直在寻找的力！它使摆锤旋转。当摆锤摆动时，y轴（摆臂）将始终垂直于运动方向。因此，我可以忽略张力和*F[gy]*力，专注于*F[gx]*，它是沿运动方向的**合力**。而且，因为这个力是直角三角形的一部分，所以我可以用……你猜对了，三角学来计算它！
- en: '![Image](../images/pg196_Image_287.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg196_Image_287.jpg)'
- en: 'Figure 3.20: On the left, the pendulum is drawn rotated so that the arm is
    the y-axis. The right shows *F[g]* zoomed in and divided into components *F[gx]*
    and *F[gy]*.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20：左侧是摆的图形被旋转，使得摆臂为y轴。右侧显示了*F[g]*的放大图，并将其分解为*F[gx]*和*F[gy]*的分量。
- en: 'The key here is that the top angle of the right triangle is the same as the
    angle *θ* between the pendulum’s arm and its resting position. Just as I demonstrated
    in the discussion of polar coordinates, the sine and cosine functions allow me
    to separate out the components of the gravity force (the hypotenuse) according
    to this angle. For *F[gx]*, I need to use sine:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，右三角形的顶角与摆的臂和其静止位置之间的角度*θ*相同。正如我在讨论极坐标时所示，正弦和余弦函数允许我根据这个角度将重力的分量（斜边）分解出来。对于*F[gx]*，我需要使用正弦：
- en: '*sin(θ*) = *F[gx]* / *F[g]*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*sin(θ*) = *F[gx]* / *F[g]*'
- en: 'Solving for *F[gx]*, I get this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 解出*F[gx]*，我得到了这个结果：
- en: '*F[gx]* = *F[g]* × sin(*θ*)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[gx]* = *F[g]* × sin(*θ*)'
- en: I’ll now rename this force *F[p]* for *force of the pendulum*. In [Figure 3.21](ch03.xhtml#ch3fig21),
    I’ve restored the diagram to its original orientation and relabeled the components.
    I’ve also moved the starting point of *F[p]* from the bottom of the right triangle
    to the bob’s center, to clarify how this force moves the bob.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将这个力重新命名为*F[p]*，代表*摆的力*。在[图 3.21](ch03.xhtml#ch3fig21)中，我已将图形恢复到原始方向并重新标注了分量。我还将*F[p]*的起点从右三角形的底部移到摆锤的中心，以便更清楚地表示这个力如何使摆锤运动。
- en: 'There it is. The net force of the pendulum that causes the rotation is calculated
    as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。导致摆锤旋转的合力计算如下：
- en: '*F[p]* = *F[g]* × sin(*θ*)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[p]* = *F[g]* × sin(*θ*)'
- en: '![Image](../images/pg197_Image_288.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg197_Image_288.jpg)'
- en: 'Figure 3.21: *F[gx]* is now labeled *F[p]*, the net force in the direction
    of motion.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21：*F[gx]*现在被标为*F[p]*，是沿运动方向的合力。
- en: 'Lest you forget, however, my goal is to determine the angular acceleration
    of the pendulum. Once I have that, I’ll be able to apply the rules of motion to
    find a new angle *θ* for each frame of the animation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，免得你忘记，我的目标是确定摆的角加速度。一旦我得到了这个，我就能应用运动规则，为每一帧动画找到新的角度*θ*：
- en: angular velocity = angular velocity + angular acceleration
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: angle = angle + angular velocity
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that Newton’s second law establishes a relationship between
    force and acceleration—namely, *F* = *M* × *A*, or *A* = *F / M*. So if the force
    of the pendulum is equal to the force of gravity times the sine of the angle,
    then I have this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: pendulum angular acceleration = acceleration due to gravity × sin(*θ*)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good time for a reminder that the context here is creative coding
    and not pure physics. Yes, the acceleration due to gravity on Earth is 9.8 meters
    per second squared. But this number isn’t relevant in our world of pixels. Instead,
    I’ll use an arbitrary constant (called `gravity`) as a variable that scales the
    acceleration (incidentally, angular acceleration is usually written as *α* so
    as to distinguish it from linear acceleration *A*):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '*α* = gravity × sin(*θ*)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Before I put everything together, there’s another detail I neglected to mention.
    Or really, lots of little details. Think about the pendulum arm for a moment.
    Is it a metal rod? A string? A rubber band? How is it attached to the pivot point?
    How long is it? What’s its mass? Is it a windy day? I could continue to ask a
    lot of questions that would affect the simulation. I choose to live, however,
    in a fantasy world, one where the pendulum’s arm is an idealized rod that never
    bends and where the mass of the bob is concentrated in a single, infinitesimally
    small point.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Even though I prefer not to worry myself with all these questions, a critical
    piece is still missing, related to the calculation of angular acceleration. To
    keep the derivation of the pendulum’s angular acceleration simple, I assumed that
    the length of the pendulum’s arm is 1\. In reality, however, the length of the
    pendulum’s arm affects the acceleration of the pendulum because of the concepts
    of torque and moment of inertia.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**Torque** (or τ) is a measure of the rotational force acting on an object.
    In the case of a pendulum, torque is proportional to both the mass of the bob
    and the length of the arm (*M* × *r*). The **moment of inertia** (or *I*) of a
    pendulum is a measure of the amount of difficulty in rotating the pendulum around
    the pivot point. It’s proportional to the mass of the bob and the *square* of
    the length of the arm (*Mr*²).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Remember Newton’s second law, *F* = *M* × *A*? Well, it has a rotational counterpart,
    *τ* = *I* × *α*. By rearranging the equation to solve for the angular acceleration
    *α*, I get *α* = *τ* /*I*. Simplifying further, this becomes *Mr*/*Mr*² or 1/*r*.
    The angular acceleration doesn’t depend on the pendulum’s mass!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just like Galileo’s Leaning Tower of Pisa experiment demonstrating
    linear acceleration, where different objects fell at the same rate, regardless
    of their mass. Here, once again, the mass of a bob doesn’t influence its angular
    acceleration—only the length of its arm does. Thus, the final formula becomes
    this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg198_Image_289.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Amazing! In the end, the formula is so simple that you might be wondering why
    I bothered going through the explanation at all. I mean, learning is great, but
    I could have easily just said, “Hey, the angular acceleration of a pendulum is
    a constant times the sine of the angle divided by the length of the arm.” That
    would be missing the point. The purpose of this book isn’t to learn how pendulums
    swing or gravity works. The point is to think creatively about how shapes can
    move around a screen in a computationally based graphics system. The pendulum
    is just a case study. If you can understand the approach to programming a pendulum,
    you can apply the same techniques to other scenarios, no matter how you choose
    to design your p5.js canvas world.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I’m not finished yet. I may be happy with my simple, elegant formula for
    angular acceleration, but I still have to apply it in code. This is an excellent
    opportunity to practice some OOP skills and create a `Pendulum` class. First,
    think about all the properties of a pendulum that I’ve mentioned:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Arm length
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angle
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular velocity
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular acceleration
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Pendulum` class needs all these properties too:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg199_Image_290.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Next, I need to write an `update()` method to update the pendulum’s angle according
    to the formula:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg199_Image_291.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: Note that the acceleration calculation now includes a multiplication by –1\.
    When the pendulum is to the right of its resting position, the angle is positive,
    and so the sine of the angle is also positive. However, gravity should pull the
    bob back toward the resting position. Conversely, when the pendulum is to the
    left of its resting position, the angle is negative, and so its sine is negative
    too. In this case, the pulling force should be positive. Multiplying by –1 is
    necessary in both scenarios.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Next, I need a `show()` method to draw the pendulum on the canvas. But where
    exactly should I draw it? How do I calculate the x- and y-coordinates (Cartesian!)
    for both the pendulum’s pivot point (let’s call it `pivot`) and bob position (let’s
    call it `bob`)? This may be getting a little tiresome, but the answer, yet again,
    is trigonometry, as shown in [Figure 3.22](ch03.xhtml#ch3fig22).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg200_Image_292.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: The bob position relative to the pivot in polar and Cartesian
    coordinates'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I’ll need to add a `this.pivot` property to the constructor to specify
    where to draw the pendulum on the canvas:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I know the bob should be a set distance away from the pivot, as determined
    by the arm length. That’s my variable `r`, which I’ll set now:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I also know the bob’s current angle relative to the pivot: it’s stored in the
    variable `angle`. Between the arm length and the angle, what I have is a polar
    coordinate for the bob: (*r*, *θ*). What I really need is a Cartesian coordinate,
    but luckily I already know how to use sine and cosine to convert from polar to
    Cartesian. And so:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that I’m using `sin(this.angle)` for the *x* value and `cos(this.angle)`
    for the *y*. This is the opposite of what I showed you in “Polar vs. Cartesian
    Coordinates” on [page 130](ch03.xhtml#ch00lev1sec34). The reason is that I’m now
    looking for the top angle of a right triangle pointing down, as depicted in [Figure
    3.21](ch03.xhtml#ch3fig21). This angle lives between the y-axis and the hypotenuse,
    instead of between the x-axis and the hypotenuse, as you saw earlier in [Figure
    3.9](ch03.xhtml#ch3fig9).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the value of `this.bob` is assuming that the pivot is at point (0,
    0). To get the bob’s position relative to wherever the pivot *actually* happens
    to be, I can just add `pivot` to the `bob` vector:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now all that remains is the little matter of drawing a line and a circle (you
    should be more creative, of course):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, a real-world pendulum is going to experience a certain amount of friction
    (at the pivot point) and air resistance. As it stands, the pendulum would swing
    forever with the given code. To make it more realistic, I can slow the pendulum
    with a damping trick. I say *trick* because rather than model the resistance forces
    with some degree of accuracy (as I did in [Chapter 2](ch02.xhtml#ch02)), I can
    achieve a similar result simply by reducing the angular velocity by an arbitrary
    amount during each cycle. The following code reduces the velocity by 1 percent
    (or multiplies it by 0.99) for each frame of animation:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Putting everything together, I have the following example (with the pendulum
    beginning at a 45-degree angle).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg201_Image_293.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: On the book’s website, this example has additional code to allow the user to
    grab the pendulum and swing it with the mouse.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 3.15**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: String together a series of pendulums so that the bob of one is the pivot point
    of another. Note that doing this may produce intriguing results but will be wildly
    inaccurate physically. Simulating an actual double pendulum requires sophisticated
    equations. You can read about them in the Wolfram Research article on double pendulums
    (*[https://scienceworld.wolfram.com/physics/DoublePendulum.html](https://scienceworld.wolfram.com/physics/DoublePendulum.html)*)
    or watch my video on coding a double pendulum (*[https://thecodingtrain.com/doublependulum](https://thecodingtrain.com/doublependulum)*).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg203_Image_296.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/pencil.jpg) **Exercise 3.16**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg204_Image_297.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: Using trigonometry, how do you calculate the magnitude of the **normal force**
    depicted here (the force perpendicular to the incline on which the sled rests)?
    You can consider the magnitude of *F*[gravity] to be a known constant. Look for
    a right triangle to help get you started. After all, the normal force is equal
    and opposite to a component of the force of gravity. If it helps to draw over
    the diagram and make more right triangles, go for it!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 3.17**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 3.17**'
- en: Create a simulation of a box sliding down an incline with friction. Note that
    the magnitude of the friction force is proportional to the normal force, as discussed
    in the previous exercise.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有摩擦力的箱子滑下斜面的模拟。请注意，摩擦力的大小与法向力成正比，如前一个练习中所讨论的那样。
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: Take one of your creatures and incorporate oscillation into its motion. You
    can use the `Oscillator` class from [Example 3.7](ch03.xhtml#ch3ex7) as a model.
    The `Oscillator` object, however, oscillates around a single point (the middle
    of the window). Try oscillating around a moving point.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 选取你其中一个生物并将振荡融入其运动中。你可以使用[示例 3.7](ch03.xhtml#ch3ex7)中的`Oscillator`类作为模型。然而，`Oscillator`对象是围绕一个固定点（窗口的中间）进行振荡的。试着围绕一个移动的点进行振荡。
- en: In other words, design a creature that moves around the screen according to
    position, velocity, and acceleration. But that creature isn’t just a static shape;
    it’s an oscillating body. Consider tying the speed of oscillation to the speed
    of motion. Think of a butterfly’s flapping wings or the legs of an insect. Can
    you make it appear as though the creature’s internal mechanics (oscillation) drive
    its locomotion? See the book’s website for an additional example combining attraction
    from [Chapter 2](ch02.xhtml#ch02) with oscillation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，设计一种根据位置、速度和加速度在屏幕上移动的生物。但这个生物不仅仅是一个静态的形状；它是一个振荡的物体。考虑将振荡的速度与运动速度联系起来。想想蝴蝶的翅膀扑动或者昆虫的腿。你能否让这个生物的内部机制（振荡）推动它的运动？参见本书网站，了解结合了来自[第二章](ch02.xhtml#ch02)的吸引力和振荡的额外示例。
- en: '![Image](../images/pg205_Image_298.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg205_Image_298.jpg)'
