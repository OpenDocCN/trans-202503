<html><head></head><body>
<h2 class="h2b" id="ch06"><span epub:type="pagebreak" id="page_115" class="calibre1"/><strong class="calibre2"><span class="big">6</span></strong><br class="calibre9"/><strong class="calibre2">INVESTIGATING NETWORKS</strong></h2>
<div class="image"><img src="../images/00015.jpeg" alt="image" class="calibre3"/></div>
<p class="noindent">Fundamentally, a cloud is a large collection of computing and digital storage resources made available for rent. This business model relies on the internet, which allows the cloud’s users to transfer data into and out of the provider’s systems, manage remote systems, and make services like websites and email servers available to end users.</p>
<p class="indent">Because connectivity is so crucial to the overall success of a cloud, Azure offers users a variety of network settings. By default, Azure makes services internet-facing so that they are accessible to anyone. However, Azure also provides other networking options, used for creating links between an internal corporate network and Azure services. Both kinds of connections are important for Azure to be able to accommodate its customers’ workloads and requirements, but it means that a misconfiguration could lead to a security disaster.</p>
<p class="indent"><span epub:type="pagebreak" id="page_116"/>In this chapter, we examine how common configuration shortcuts in firewalls can leave services vulnerable to attack. We also look at how an attacker can leverage Azure’s tunnels to compromise a corporate network.</p>
<h3 class="h1" id="lev144"><strong class="calibre2">Best Practices: Network Security</strong></h3>
<p class="noindent">One of the first lines of defense when securing resources in the cloud is proper network configuration. After all, if malicious traffic never reaches a service, the threat of an exploit occurring is minimized. Some of my common recommendations to customers include creating small, dedicated virtual networks, using Network Security Groups, and avoiding accidentally bridging your corporate network to the internet.</p>
<p class="indent">Begin by defining separate Azure virtual networks for each of the services you run in the cloud. By creating a network dedicated to just the resources needed to provide one service, you can configure the network to allow only the minimum amount of access required to make the service work. It becomes much harder to manage a network if it contains dozens of resources that are used for many different projects.</p>
<p class="indent">Next, make use of Azure Network Security Groups (NSGs), as first discussed in “<a href="part0012.html#lev76" class="calibre6">Gathering Information on Networking</a>” on <a href="part0012.html#page_56" class="calibre6">page 56</a>. Restrict traffic to virtual machines to only what is needed and disallow access to remote management services if you aren’t currently performing administrative tasks on the VM—you can always temporarily add a rule later to allow access to those ports from your IP address if you need to make changes. Also, consider modifying default rules. For example, if a service doesn’t need to make outbound connections to the internet, block them. This makes it much harder for an attacker to have malware call back to the attacker’s system if they manage to gain an initial foothold into a VM.</p>
<p class="indent">Finally, Azure offers several services that provide the ability to create a link between Azure and your company’s network, which I discuss in “<a href="part0015.html#lev149" class="calibre6">Cloud-to-Corporate Network Bridging</a>” on <a href="part0015.html#page_123" class="calibre6">page 123</a>. While these features are great for enabling Hybrid IT—where services running on-premises operate seamlessly with those in the cloud—they can also lead to an undesirable condition: if an Azure virtual network with this connectivity also hosts services that are exposed to the public internet, any breach of one of those services potentially gives an attacker a direct path back to the corporate network. For this reason, it is very important to separate those services that need corporate network access from those that need to be exposed publicly. I suggest keeping them in entirely different subscriptions, to avoid any accidental bridging. If some service needs both types of access, design it extremely carefully and spend a good deal of time threat modeling to try to determine and address all possible hazards. And of course, be sure to pentest it to validate its security!</p>
<p class="indent">Networking in Azure is a broad topic, so there are many features that might benefit your usage scenario that I can’t cover here. Fortunately, Azure network security has some of the most comprehensive documentation available. See <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/best-practices-network-security/" class="calibre6">https://docs.microsoft.com/en-us/azure/best-practices-network-security/</a></em> for <span epub:type="pagebreak" id="page_117"/>a thorough threat model and <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/security/azure-security-network-security-best-practices/" class="calibre6">https://docs.microsoft.com/en-us/azure/security/azure-security-network-security-best-practices/</a></em> for a discussion of features that can make your links more secure.</p>
<h3 class="h1" id="lev145"><strong class="calibre2">Avoiding Firewalls</strong></h3>
<p class="noindent">Azure offers firewalls for several of its services. They are most commonly used to protect virtual machines, SQL servers, and application services. In the case of VMs and SQL, the firewalls are enabled by default and are free to use with their respective services. For applications, Azure has a paid Web Application Firewall option. Understanding the features and defaults of each firewall gives a pentester a better idea of what methods are likely to work and which time-consuming scans they should avoid.</p>
<h4 class="h2" id="lev146"><strong class="calibre2"><em class="calibre10">Virtual Machine Firewalls</em></strong></h4>
<p class="noindent">Firewalls are VMs’ first—and often only—line of defense against network-based attacks. As of this writing, administrators have few options for intrusion prevention virtual appliances to protect their VMs. They also can’t create advanced routing rules to deflect certain traffic before it gets to the VM. For these reasons, administrators must take extra care when setting up the firewall.</p>
<p class="indent">Just about every operating system contains a host-based firewall, which allows the administrator of the system to configure what ports and services should be accessible from the network. However, these native firewalls have a few problems:</p>
<p class="hang"><strong class="calibre4">Complexity and inconsistency</strong> Every operating system has a different method for configuring its firewall, uses different commands, and sometimes even uses different terminology. An administrator may have experience with one type of firewall but inadvertently make a crucial mistake when setting one up in a less familiar OS.</p>
<p class="hang"><strong class="calibre4">Unplanned changes over time</strong> A host firewall configuration may start out secure, but may weaken over time without anyone realizing a change has happened. For instance, installing a new software package or update may add new exceptions to the firewall with no warning, such as a program that includes a web interface opening TCP ports 80 and 443 to inbound traffic.</p>
<p class="hang"><strong class="calibre4">Bugs</strong> Firewall software is generally very well tested, but there’s always a chance of a bug that could let a packet through unintentionally or crash the entire VM. Indeed, bugs in security software such as firewalls and antivirus are often among the most severe. This isn’t just because exploiting them could bypass the security control that the software is supposed to provide; it’s also because this software is always running, is present on just about every system, has system-level privileges, and is exposed to potentially malicious input. For example, in 2017, Google security engineers discovered a flaw in Microsoft’s antivirus scanning engine that allowed them to take control of a machine by sending a <span epub:type="pagebreak" id="page_118"/>malicious email that the antivirus scanned upon arrival—the user didn’t even have to open the email. This flaw was quickly patched, but in the same year, similar issues were also found in other vendors’ security products, and it’s likely that more are yet to be discovered.</p>
<p class="hang"><strong class="calibre4">Load</strong> Host-based firewalls analyze packets within the operating system, which means that each examined packet consumes processor cycles and memory momentarily. In the event of heavy load—and especially during a denial-of-service (DoS) attack—this additional stress can prevent the server from performing its normal work. This can even have a financial impact in the cloud, because Azure’s auto-scaling feature can be configured to automatically bring additional resources online or upgrade VMs to higher pricing tiers to deal with a temporarily increased load, and these upgrades are billed to the VM’s subscription.</p>
<p class="hang"><strong class="calibre4">Subscription vs. VM administration</strong> The administrators of the VM, which may be different from the subscription administrators, control host-based firewalls. This means an administrator could open their system up to attack, and if that VM is compromised, the attacker may then be able to use that system to attack other VMs or services in Azure that are more restricted. Consider that many corporations allow users to be local administrators of their own workstations, but few permit these same users to expose their workstations directly to the internet. Azure should be treated the same way.</p>
<p class="indentt">To address all these issues, Azure offers firewalls for VMs outside of the host-based options, in the form of endpoint rules in classic Azure Service Management (ASM) VMs and Network Security Groups (NSGs) in Azure Resource Manager (ARM) VMs. These rules are easy to configure and work regardless of the VM’s operating system—and only someone with the right level of subscription access can disable or reconfigure these firewalls.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Microsoft allows other security companies to offer</em> Next-Generation Firewalls <em class="calibre7">to customers in the Azure marketplace. These “firewalls as a service” address the issues discussed in this section, and may also provide additional unique protections, such as deep packet inspection or content filtering. Because these firewalls vary significantly by vendor, we can’t cover them here. If you encounter one during an assessment, review its features and ensure it has been configured properly to secure the customer’s services.</em></p>
</div>
<p class="indent">There are a few gaps in this otherwise solid armor, though. For administrative convenience, several default rules are applied to each new VM. These rules open different ports, depending on which operating system is used in the VM. As a penetration tester, it is important to know what ports Azure opens by default. Users generally don’t change these rules, which means the ports are open to anyone on the internet.</p>
<p class="indent">For Windows servers, Azure opens port 3389, for both TCP and UDP inbound traffic, to be used for the Remote Desktop Protocol (RDP). Additionally, inbound TCP port 5986 is open by default for Windows <span epub:type="pagebreak" id="page_119"/>Remote Management (WinRM), which, among other things, is used by PowerShell to remotely connect to the VM. On older VMs, Azure moved RDP to a random port between 49152 and 65535. Although this is no longer done for newly built classic VMs, you may still find some older VMs using this security-through-obscurity method.</p>
<p class="indent">For Linux, the port list is much smaller; only TCP port 22 inbound is open by default. This is the port used for Secure Shell (SSH), the encrypted, console-based remote management service. Depending on the chosen Linux image and user preferences, SSH may be configured to use certificate-based authentication or traditional usernames and passwords.</p>
<p class="indent">Of course, all these protocols are authenticated, so you can’t just connect to the port and have control of the VM. However, if an attacker finds a valid credential, succeeds with a dictionary or brute-force attack, or discovers an authentication bypass exploit for any of these services, then they will be able to access the system.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">To help protect against attackers that attempt to access administrative interfaces through allowed inbound connections in the firewall, you can change the firewall rules to allow connections only from specific IP addresses, such as those of your company’s network egress points. Alternatively, you could block access to those ports from the internet, and set up a hardened virtual machine with inbound RDP allowed from a limited set of IP addresses that serves as a <em class="calibre10">jump server</em>. From this jump server, you can access the administrative interfaces of all other services through a virtual network that is accessible only from within the subscription.</p>
</div>
<p class="indent">By default, all outbound traffic is allowed from Azure VMs. A subscription administrator could change this, but that’s rarely done. A penetration tester can benefit from this allow-all rule in several ways. First, if an attacker gets access to a system, there is no rule to limit the exfiltration of data. Second, tools such as Metasploit can use reverse TCP shells to connect back to an attacker’s command-and-control server to receive instructions. Finally, an attacker on the system can download tools from anywhere they desire.</p>
<h4 class="h2" id="lev147"><strong class="calibre2"><em class="calibre10">Azure SQL Firewalls</em></strong></h4>
<p class="noindent">Azure SQL servers also have their own firewalls, but unlike VM firewalls, they aren’t optional; they are on by default and no one can disable them. However, an attacker can still use a number of tricks to circumvent the firewall and directly target the SQL server.</p>
<p class="indent">First, you may recall from <a href="part0012.html#ch03" class="calibre6">Chapter 3</a> that developers sometimes add rules to SQL firewalls that allow connections from anywhere. An attacker can easily spot these rules in a database’s firewall page on the Azure portal, <span epub:type="pagebreak" id="page_120"/>because these rules allow connections from a large IP address range, such as 0.0.0.0 to 255.255.255.255. While the firewall is technically still running with such a rule in place, it’s no longer filtering any connections, so an attacker can connect to the SQL server from anywhere on the internet and try attacks like password brute-forcing attempts.</p>
<p class="indent">Second, even if an allow-all rule isn’t in place, an attacker might still be able to establish a connection. Some database servers have many authorized users who frequently connect from a variety of network locations, such as a central office, a field office, a corporate VPN, their homes, and even mobile networks at coffeehouses and airport terminals. When users can access a server from a variety of locations, the firewall rules likely contain at least a few allowed ranges; for example, a firewall might allow any connection originating from the corporate network. This means an attacker who gains access to any corporate system could then use that machine as a pivot point for attacking the SQL server. If an attacker has access to the Azure portal but doesn’t have access to a machine with a previously granted IP rule, the attacker might succeed in adding a new rule for their IP address. And because users frequently add new rules to SQL firewalls—sometimes a database has a dozen or more entries—it’s unlikely anyone would notice the addition of one more. If you add a new rule, make sure your rule name mimics other legitimate rules in order to better blend in. Also make sure that you record and account for any such modifications so that you can share a list with your client to verify that these modifications are removed at the end of your engagement. Be aware that a real attacker might take advantage of any new openings you create—a very undesirable situation.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">You should periodically review firewall rules for changes. It is a good idea to maintain a list of rules required for all services that rely on the SQL server; this way, you can delete any extra rules that creep in over time. For example, if a deleted rule was being used for developer workstations, when a developer reconnects they can easily add it again from either the Azure portal or SQL Server Management Studio. Without occasional cleanup, old rules tend to build up, thus increasing server exposure and making it hard to detect rogue rule additions. You can automate illegitimate-rule detection with Azure PowerShell’s <span class="literal1">Get-AzureSqlDatabaseServerFirewallRule</span> cmdlet.</p>
</div>
<p class="indent">One final possible weakness is that SQL firewall rules are configured at the server level, not per database. So, if a server has 20 databases, each used by different teams, one rule set is applied to all of them. Therefore, an attacker might be able to compromise a workstation that a team with poor security hygiene uses to access an unimportant Azure SQL database; then, the attacker can use that same system to target a more interesting database that a more secure team uses.</p>
<h4 class="h2" id="lev148"><span epub:type="pagebreak" id="page_121" class="calibre1"/><strong class="calibre2"><em class="calibre10">Azure Web Application Firewalls</em></strong></h4>
<p class="noindent">A Web Application Firewall (WAF) isn’t like a traditional firewall that uses rules based on ports and IP addresses to determine if traffic should pass. Instead, a WAF sits in front of a web application and looks for malicious-looking requests. When the WAF identifies a suspicious pattern, it can either report the incident or block the traffic outright. In this way, a WAF is more like an intrusion detection system (IDS) or intrusion prevention system (IPS) than an IP firewall. WAFs have become standard enough that beginning in 2017, the popular Open Web Application Security Project (OWASP) Top 10 list of web vulnerabilities considers the absence of a WAF itself to be a security finding.</p>
<p class="indent">Keeping up with industry trends, Azure now offers a WAF that users can deploy in front of Azure websites and applications. Microsoft also allows other vendors to provide WAFs to Azure customers. The functionality of most WAFs is similar, so we’ll focus on Microsoft’s WAF, which is the most commonly used in Azure.</p>
<p class="indent">To enable Microsoft’s WAF, a customer must create an Azure Application Gateway, which is a load-balancing service that distributes HTTP and HTTPS requests among a pool of Azure servers. During the configuration phase of the Azure Application Gateway, the user has the option to also enable a WAF on the gateway. When configuring the WAF, the user can choose whether the firewall will just detect and log threats or if it will block them. The latter option increases the security of the site the WAF protects, but risks blocking valid traffic if a rule is overly broad.</p>
<p class="indent">Azure’s WAF uses rules that OWASP defines in its ModSecure Core Rule project. Site administrators can select from either OWASP 2.29 or OWASP 3.0 rule sets. Aside from removing some frequent false positives and shifting some of the rule severity scores, the biggest change in OWASP 3.0 is the addition of IP repudiation rules. These have the ability to block requests from known-malicious senders and from IP addresses associated with certain countries. A penetration tester should be aware of OWASP’s repudiation rules because a WAF might block the tester’s host under these rules, leading them to believe a server isn’t vulnerable to a given attack, when in reality, that attack would work from a different IP address, resulting in a dreaded false negative in their report.</p>
<p class="indent">The one major weakness of Azure’s WAF is its limited configurability. An administrator can manually enable or disable individual WAF rules or a class of rules, but they can’t tweak a rule to have it fit their particular scenario. So, if a rule is likely to generate a significant number of false positives, the administrator will probably disable it. Additionally, many of the rules have only vague descriptions, so the user configuring the WAF might turn off more rules than needed to get their site working. To give you a sense of the rules list, the WAF configuration page is shown in <a href="part0015.html#ch06fig1" class="calibre6">Figure 6-1</a>.</p>
<p class="indent">Penetration testers looking to bypass a WAF don’t have a definitive solution. Instead, if you suspect a customer is using a WAF that’s blocking a given attack, your best bet is to research the exploit online and see if others have <span epub:type="pagebreak" id="page_122"/>found a way to sneak past WAFs. Otherwise, try modifying the code used in the attack—maybe some minor changes will bypass the WAF rule’s pattern.</p>
<div class="image1"><a id="ch06fig1" class="calibre6"/><img src="../images/00045.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-1: Azure WAF configuration with OWASP 3.0 rules selected</em></p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">WAFs are not foolproof. Like any pattern-based security product, they are likely to miss novel attacks, and an attacker can bypass your WAF with a clever rewrite of a known exploit. Despite their vulnerabilities, WAFs do offer an additional layer of protection, which is a key part of building a more secure system.</p>
<p class="spara1">Additionally, WAFs tend to introduce human risk. Developers are often tempted to believe that a WAF will prevent any malicious behavior, so they think they can deploy code that contains security bugs with impunity. This is the equivalent of an IT professional thinking that they can skip installing security updates as long as antivirus software is installed. Clearly neither of these is true! Be sure that you stay vigilant, even when using a WAF; otherwise, the WAF may result in a <em class="calibre10">decrease</em> of your overall security.</p>
</div>
<h3 class="h1" id="lev149"><span epub:type="pagebreak" id="page_123" class="calibre1"/><strong class="calibre2">Cloud-to-Corporate Network Bridging</strong></h3>
<p class="noindent">When a company begins cloud adoption as part of its IT strategy, it can either migrate existing workloads or build new services that are designed specifically for the cloud. Transferring data between corporate systems and the cloud provider poses a challenge regardless of the choice. To address this dilemma, Microsoft offers two different types of connections between customer environments and Azure.</p>
<p class="indent">For systems being migrated from a corporate environment, Azure allows users to create a direct connection between their subscription and company network, where the Azure resources share the same IP address space as their original corporate network; this direct connection is called Azure Virtual Network. A company can achieve Azure Virtual Network connectivity with one of two different Azure services: virtual private network or ExpressRoute. We’ll discuss both of these in the next section.</p>
<p class="indent">Azure Virtual Network is very convenient for cloud migrations, but it’s overkill for some workloads. For many use cases—like for services designed to run in the cloud—a simple message delivery system may be sufficient. For example, an Azure website may be able to run entirely in the cloud but need the ability to insert a record in an on-premises database when a new order is placed. For these kinds of scenarios, Azure offers Service Bus and Logic Apps.</p>
<h4 class="h2" id="lev150"><strong class="calibre2"><em class="calibre10">Virtual Private Networks</em></strong></h4>
<p class="noindent">Virtual private network (VPN) connections are a well-established technology in the corporate IT world. Many companies use them so employees can work from home or while traveling. VPNs create an encrypted tunnel, over the internet, between the client and the VPN gateway running at the company. The VPN can tunnel either all network traffic or just the traffic destined for the office. VPNs are most commonly used between a client machine and a corporate network, and occasionally to connect two different corporate locations to each other or even to connect a tech-savvy consumer’s smartphone to their home network.</p>
<p class="indent">Azure offers several different forms of VPN connectivity:</p>
<p class="hang"><strong class="calibre4">Point-to-site</strong> A tunnel connecting individual client systems to an Azure virtual network</p>
<p class="hang"><strong class="calibre4">Site-to-site</strong> A connection between a corporate network and an Azure virtual network</p>
<p class="hang"><strong class="calibre4">Multisite</strong> Multiple corporate networks all connecting in to the same Azure virtual network</p>
<p class="hang"><strong class="calibre4">VNet-to-VNet</strong> A tunnel between two Azure virtual networks</p>
<p class="indentt">Azure provides these options so that Azure services in a subscription can communicate with other systems, networks, or subscriptions without having one or both sides of the connection exposed to the internet. This means two things for a penetration tester: First, there may be services that <span epub:type="pagebreak" id="page_124"/>are in scope for an assessment that can only be reached from a system connected to one of these VPN tunnels. Second, compromising an Azure service or subscription could provide access to a direct link back to a corporate network or service that isn’t otherwise exposed.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">WARNING</span></strong></p>
<p class="notep"><em class="calibre7">VPN connections could connect the target’s resources to a partner company’s network, which may not be in the agreed-upon scope for your assessment. Always verify that any new systems you discover are part of your assessment before proceeding.</em></p>
</div>
<p class="indent">To exploit these connections, an attacker needs to know how to identify each form of VPN connectivity and how each connection performs authentication. Determining these properties differs depending on the type of connection. Let’s examine each.</p>
<h5 class="h3" id="lev151"><strong class="calibre2">Connecting to Point-to-Site VPNs</strong></h5>
<p class="noindent">Point-to-site connectivity requires that clients use certificate-based authentication. To set up the VPN, an administrator creates a virtual network in Azure and defines a private IP address space for that network, such as 10.0.0.0/16. They then create an instance of the VPN gateway service and assign it a subnet range within the virtual network. Finally, the administrator creates a self-signed certificate that will be used as the trusted root certificate to validate client requests, and they save the public key portion of the certificate in the VPN gateway configuration.</p>
<p class="indent">To allow a client to connect, the administrator downloads the VPN client software from the Azure portal and installs it on the client machine. The administrator must also generate a new certificate using the previously generated certificate as its root authority and install the private key for this certificate into the client’s certificate store.</p>
<p class="indent">To determine if a point-to-site VPN is in use, you can either check in the subscription using the Azure portal or check on a client machine you suspect uses the VPN. Within the Azure portal, open the virtual network gateway <em class="calibre7">blade</em>—Azure’s terminology for a service’s configuration page—and see if any gateways are listed that have the Gateway Type listed as VPN. If so, click each of those gateways, then click the <strong class="calibre4">Point-to-site configuration</strong> option for each one, which should open a screen similar to <a href="part0015.html#ch06fig2" class="calibre6">Figure 6-2</a>.</p>
<p class="indent">This window shows an administrator all the information about point-to-site connections for the selected gateway: the number of active connections and total bandwidth used, the address space assigned to the VPN, the base64-encoded public key portion of the root certificate used to validate client certificates, the thumbprints of any client certificates that have been revoked, and the IP addresses of any currently connected VPN clients. As you can see, the only information about connected clients is the IP address in use. This means that if you can create an illicit connection to the VPN, an administrator wouldn’t obtain detailed information about your system.</p>
<div class="image1"><span epub:type="pagebreak" id="page_125"/><a id="ch06fig2" class="calibre6"/><img src="../images/00046.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-2: Azure VPN point-to-site configuration</em></p>
<p class="indent">On a Windows 10 client machine, you can check for the VPN by pressing <small class="calibre17">WINDOWS</small>-R and entering <span class="codestrong">ms-settings:network-vpn</span>, which should open the VPN settings screen. On earlier versions of Windows, enter <span class="codestrong">control netconnections</span> instead. Check if any VPN connections are listed; if there are, select a connection and click <strong class="calibre4">Advanced Options</strong>. An Azure VPN connection’s server address will begin with <em class="calibre7">azuregateway</em> and end in <em class="calibre7">cloudapp.net</em>, as shown in <a href="part0015.html#ch06fig3" class="calibre6">Figure 6-3</a>.</p>
<div class="image1"><a id="ch06fig3" class="calibre6"/><img src="../images/00047.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-3: Windows 10 VPN details for an Azure VPN connection</em></p>
<p class="indent">If you find a client with such a VPN connection, you can leverage that machine to launch network scans against other addresses in the virtual network range—but that may alert the system’s owner. Instead, as long as you have administrative rights to the system, I suggest taking the connection details and certificates from the client and then connecting to the VPN from any other Windows host.</p>
<p class="indent">On the client system, open the <em class="calibre7">%appdata%\Microsoft\Network\Connections\</em><em class="calibre7">Cm</em> directory. This directory should contain a <em class="calibre7">.cmp</em> file and a subdirectory, both named with the same GUID. Copy the <em class="calibre7">.cmp</em> file and all the files within the GUID subdirectory to one folder on your own computer, such as <em class="calibre7">C:\vpn</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_126"/>Next, export the public key for the VPN root certificate. To do this, open a PowerShell window and run the script in <a href="part0015.html#ch06list1" class="calibre6">Listing 6-1</a>.</p>
<pre>   $path = "$env:appdata\Microsoft\Network\Connections\Cm"<br class="calibre5"/><span class="ent">➊</span> $cmsFiles = Get-ChildItem -Path $path -Filter *.cms -Recurse<br class="calibre5"/>   foreach ($file in $cmsFiles)<br class="calibre5"/>   {<br class="calibre5"/>    <span class="ent">➋</span> $match = Select-String -pattern "CustomAuthData1=" $file<br class="calibre5"/>       $thumbprint = $match.Line.Split('=')[1].Substring(0,40)<br class="calibre5"/>       $cert = (Get-ChildItem -Path "cert:\CurrentUser\Root\$thumbprint")<br class="calibre5"/>    <span class="ent">➌</span> Export-Certificate -Cert $cert -FilePath "$thumbprint.cer"<br class="calibre5"/>   }</pre>
<p class="listing" id="ch06list1"><em class="calibre7">Listing 6-1: PowerShell script to export the root certificate(s) used by VPN connections</em></p>
<p class="indent">This script recursively checks for the <em class="calibre7">.cms</em> configuration files within the <em class="calibre7">Network\Connections</em> directory <span class="ent">➊</span>, extracts a connection’s root certificate thumbprint <span class="ent">➋</span>, and then exports that certificate to the current directory <span class="ent">➌</span>. Copy any exported certificates to your computer and import them into the <em class="calibre7">Current User\Trusted Root Certification Authorities</em> store.</p>
<p class="indent">The last thing you need from the target system is the private key for the certificate used to authenticate the VPN connection. It resides in the <em class="calibre7">Current User\Personal</em> certificate store, but it’s likely marked as non-exportable. Fortunately, Mimikatz can export these protected certificates. To extract the certificates, run Mimikatz from an administrative command prompt and then issue these commands:</p>
<pre>mimikatz # <span class="codestrong1">crypto::capi</span><br class="calibre5"/>mimikatz # <span class="codestrong1">privilege::debug</span><br class="calibre5"/>mimikatz # <span class="codestrong1">crypto::cng</span><br class="calibre5"/>mimikatz # <span class="codestrong1">crypto::certificates /store:</span><span class="codestrongitalic">my</span> <span class="codestrong1">/export</span></pre>
<p class="indent">This will export all of the user’s personal certificates to the current directory. The root certificate you exported previously will be the root of the path to the certificate used for Azure VPN authentication. Copy the exported PFX file to your system and then import it into your <em class="calibre7">Current User\Personal</em> certificate store.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">The default password for PFX files exported through Mimikatz is</em> mimikatz<em class="calibre7">.</em></p>
</div>
<p class="indent">Last, you’ll need to run a command to create the VPN connection on your own computer. Open a command prompt, navigate to the directory containing the files you copied (such as <em class="calibre7">C:\vpn</em>), and then run the command</p>
<pre>C:\vpn&gt; <span class="codestrong1">cmstp.exe</span> <span class="codestrong1">/s /su /ns</span> <span class="codestrongitalic">GUID</span><span class="codestrong1">.inf</span></pre>
<p class="noindent">where <span class="codeitalic1">GUID</span> is the name of the <em class="calibre7">.inf</em> file copied from the target system. This should add the VPN connection to your system; you should now be able to <span epub:type="pagebreak" id="page_127"/>connect to the Azure virtual network by clicking the Network icon in the notification area and then clicking the <strong class="calibre4">Connect</strong> button on the VPN in the fly-out menu shown in <a href="part0015.html#ch06fig4" class="calibre6">Figure 6-4</a>.</p>
<div class="image1"><a id="ch06fig4" class="calibre6"/><img src="../images/00048.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-4: Network fly-out with an Azure VPN connection</em></p>
<h5 class="h3" id="lev152"><strong class="calibre2">Connecting to Site-to-Site VPNs</strong></h5>
<p class="noindent">Whereas point-to-site VPNs connect a single client to a remote network, site-to-site VPNs bridge an entire network segment to a different remote network. In Azure, these connections are used to connect a portion of a corporate network to an Azure Virtual Network. Using a site-to-site VPN allows a group of servers in an on-premises datacenter to directly connect with Azure resources such as VMs without having to install VPN clients on each server. It’s a common configuration in companies that are migrating servers gradually to the cloud but that still need to reach their corporate-network counterparts.</p>
<p class="indent">To create such a connection, the corporate network must have a local network device, such as a router or VPN gateway appliance, that supports site-to-site VPNs. The administrator then configures the VPN in both the Azure portal and their local network device. They then configure each side of the connection with the public IP address of the other side, as well as the private network IP range represented behind each VPN gateway, which allows the gateway to determine if it should route traffic over the connection. To authenticate the connection, both sides are also given the same shared key.</p>
<p class="indent">Because administrators can set up the corporate network side of the VPN on a wide variety of devices, determining which device is responsible for a given connection is difficult, so it’s impractical to describe potential attacks against them. Instead, for site-to-site VPNs, focus on the Azure side of the connection.</p>
<p class="indent">If you can get administrative access to the Azure subscription, you can use PowerShell to display the details of VPN connections. The script in <a href="part0015.html#ch06list2" class="calibre6">Listing 6-2</a> will enumerate each connection and display its important details.</p>
<pre><span epub:type="pagebreak" id="page_128"/><span class="ent">➊</span> $connections = Get-AzureRmResourceGroup | `<br class="calibre5"/>       Get-AzureRmVirtualNetworkGatewayConnection<br class="calibre5"/><br class="calibre5"/>   foreach ($connection in $connections)<br class="calibre5"/>   {<br class="calibre5"/>    <span class="ent">➋</span> Get-AzureRmVirtualNetworkGatewayConnection -ResourceGroupName `<br class="calibre5"/>           $connection.ResourceGroupName -Name $connection.Name<br class="calibre5"/><br class="calibre5"/>    <span class="ent">➌</span> Get-AzureRmLocalNetworkGateway -ResourceGroupName `<br class="calibre5"/>          $connection.ResourceGroupName | `<br class="calibre5"/>          Where {$_.Id -eq ($connection.LocalNetworkGateway2.Id)}<br class="calibre5"/><br class="calibre5"/>       Write-Output "========================================================="<br class="calibre5"/>   }</pre>
<p class="listing" id="ch06list2"><em class="calibre7">Listing 6-2: PowerShell script to export the details of site-to-site VPN connections</em></p>
<p class="indent">This script will get a list of every Virtual Network gateway in every resource group in the subscription <span class="ent">➊</span>, and then it will display details about the connection <span class="ent">➋</span> and information about the remote site linked to the VPN <span class="ent">➌</span>. For each VPN connection in the subscription, here’s what the output from this script should look like:</p>
<pre><span class="ent">➊</span> Name                     : <span class="codeitalic">VPN_Name</span><br class="calibre5"/>   ResourceGroupName        : <span class="codeitalic">Resource_Group</span><br class="calibre5"/>   Location                 : centralus<br class="calibre5"/>   Id                       : /. . ./Microsoft.Network/connections/<span class="codeitalic">VPN_Name</span><br class="calibre5"/>   Etag                     : W/"<span class="codeitalic">GUID</span>"<br class="calibre5"/>   ResourceGuid             : <span class="codeitalic">GUID</span><br class="calibre5"/>   ProvisioningState        : Succeeded<br class="calibre5"/>   Tags                     :<br class="calibre5"/>   AuthorizationKey         :<br class="calibre5"/><span class="ent">➋</span> VirtualNetworkGateway1   : "/. . ./virtualNetworkGateways/<span class="codeitalic">Gateway_Name</span>"<br class="calibre5"/>   VirtualNetworkGateway2   :<br class="calibre5"/><span class="ent">➌</span> LocalNetworkGateway2     : "/. . ./localNetworkGateways/<span class="codeitalic">Remote_Network</span>"<br class="calibre5"/>   Peer                     :<br class="calibre5"/>   RoutingWeight            : 0<br class="calibre5"/><span class="ent">➍</span> SharedKey                : MySuperSecretVPNPassword!<br class="calibre5"/><span class="ent">➎</span> ConnectionStatus         : Connected<br class="calibre5"/>   EgressBytesTransferred   : 0<br class="calibre5"/>   IngressBytesTransferred  : 0<br class="calibre5"/>   TunnelConnectionStatus   : []<br class="calibre5"/><span class="ent">➏</span> GatewayIpAddress         : 203.0.113.17<br class="calibre5"/>   LocalNetworkAddressSpace : Microsoft.Azure.Commands.Network.Models.PSAddressSpace<br class="calibre5"/>   ProvisioningState        : Succeeded<br class="calibre5"/>   BgpSettings              :<br class="calibre5"/><span class="ent">➐</span> AddressSpaceText         : {<br class="calibre5"/>                                "AddressPrefixes": [<br class="calibre5"/>                                  "192.168.200.0/24"<br class="calibre5"/>                                ]<br class="calibre5"/>                              }<br class="calibre5"/>   --<span class="codeitalic">snip</span>--</pre>
<p class="indent"><span epub:type="pagebreak" id="page_129"/>The output begins with the name given to the site-to-site connection <span class="ent">➊</span>, which may tell you something about the connection’s purpose, and so might the name of the Azure VPN gateway device <span class="ent">➋</span> and the on-premises network <span class="ent">➌</span>—all of which are chosen by the user. The <code>SharedKey</code> value is the secret used to authenticate one site to the other <span class="ent">➍</span>; by obtaining the <code>SharedKey</code>, you may be able to establish your own connection to the corporate VPN gateway, depending on the configured IP ranges. <code>ConnectionStatus</code> shows whether the VPN link is currently established <span class="ent">➎</span>. Finally, <code>GatewayIpAddress</code> is the public IP endpoint for the corporate VPN gateway <span class="ent">➏</span>, and <code>AddressSpaceText</code> is the private network IP range on the client network for the VPN <span class="ent">➐</span>.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="spara">You need to take two important steps to avoid rogue connections to your site-to-site VPN. First, be sure to choose a complex shared key that an attacker can’t guess; this way, your adversary is forced to compromise either your VPN gateway device or the Azure subscription to obtain it. Second, configure your VPN settings and firewalls to only allow site-to-site connections (and the network traffic routed through them) between the IPs you expect.</p>
</div>
<h5 class="h3" id="lev153"><strong class="calibre2">Connecting to Multisite VPNs</strong></h5>
<p class="noindent">Multisite VPNs allow numerous sites to interconnect with each other, either in a mesh topology, where every branch in the VPN links to every other branch, or a hub-and-spoke design, where branches talk back to central offices. Multisite VPNs are useful for companies with many small field offices, such as banks, insurance agencies, and political campaigns.</p>
<p class="indent">Azure handles multisite VPNs by allowing each Azure VPN gateway to have multiple site-to-site connections concurrently. Therefore, all the information from the previous section also applies to multisite configurations. The script in <a href="part0015.html#ch06list2" class="calibre6">Listing 6-2</a> is designed to handle all types of VPN deployments, so you can use it for multisite VPNs too.</p>
<h5 class="h3" id="lev154"><strong class="calibre2">Connecting to VNet-to-VNet VPNs</strong></h5>
<p class="noindent">For resources running in two different Azure virtual networks that need to communicate, Microsoft offers VNet-to-VNet VPN connections. Administrators can use these VPNs to connect other virtual networks in different regions or even different subscriptions. They share almost all of the same attributes as site-to-site VPNs, except instead of a customer network device on one end of the connection, VNet-to-VNet VPNs use another Azure VPN gateway instance.</p>
<p class="indent">One option for you as a pentester is to add a VPN gateway to your own subscription and then attempt to pair it to your target’s virtual <span epub:type="pagebreak" id="page_130"/>network. This is a fairly noticeable thing to do, because the VPN connection would be clearly visible in the Azure portal, but it would provide a novel way to maintain persistent access to VMs in the subscription, until the connection was discovered. If you attempt this, do it in a sparsely used subscription because the target’s administrators would have direct access to your systems—VNet-to-VNet VPNs are bidirectional, after all.</p>
<p class="indent">For this to work, the target must already have a VPN gateway in their subscription. From this gateway, you’ll need the gateway’s name and ID (for example, <em class="calibre7">/subscriptions/Subscription_Id/resourceGroups/Resource_Group/</em><em class="calibre7">providers</em><em class="calibre7">/Microsoft.Network/virtualNetworkGateways/Gateway_Name)</em>. You can obtain both of these values with administrative access to the target subscription using this PowerShell command:</p>
<pre>PS C:\&gt; <span class="codestrong1">Get-AzureRmResourceGroup | Get-AzureRmVirtualNetworkGateway</span></pre>
<p class="indent">You’ll also need a VPN gateway in your own subscription and to possess the same values for your own gateway. With this data, you’d run these commands in your subscription:</p>
<pre>$myGateway = Get-AzureRmVirtualNetworkGateway -Name "<span class="codeitalic">Local_Gateway_Name</span>" `<br class="calibre5"/>    -ResourceGroupName "<span class="codeitalic">Local_Gateway_Resource_Group</span>"<br class="calibre5"/>$remoteGateway = New-Object Microsoft.Azure.Commands.Network.Models.PSVirtualNetworkGateway<br class="calibre5"/>$remoteGateway.Name = "<span class="codeitalic">Target_Gateway_Name</span>"<br class="calibre5"/>$remoteGateway.Id   = "<span class="codeitalic">Target_Gateway_ID</span>"<br class="calibre5"/>New-AzureRmVirtualNetworkGatewayConnection -Name "<span class="codeitalic">V2V</span>" -ResourceGroupName `<br class="calibre5"/>    $myGateway.ResourceGroupName -VirtualNetworkGateway1 $myGateway -VirtualNetworkGateway2 `<br class="calibre5"/>    $remoteGateway -Location $myGateway.Location -ConnectionType Vnet2Vnet -SharedKey "<span class="codeitalic">Key</span>"</pre>
<p class="indent">You can replace the gateway connection name (here, <span class="codeitalic1">V2V</span>) and shared key (<span class="codeitalic1">Key</span>) with any desired value. You would then run this command in the target subscription, swapping the target gateway values for your gateway’s details. At this point, the VPN connection should be established and ready for use.</p>
<h4 class="h2" id="lev155"><strong class="calibre2"><em class="calibre10">ExpressRoute</em></strong></h4>
<p class="noindent">Site-to-site VPNs work well for many customers, but they are still dependent on the underlying internet connection between a company and an Azure datacenter. This path likely requires numerous hops between different network providers, so latency and bandwidth of the link aren’t guaranteed. For some mission-critical applications, this uncertainty is unacceptable; in these cases, ExpressRoute provides a viable alternative.</p>
<p class="indent">ExpressRoute is a Microsoft service that allows customers to establish dedicated circuits between their company and Microsoft’s cloud services. These connections are built using private lines instead of the internet, have stable latencies and bandwidth, and provide a service level agreement (SLA). They are available in speeds from 50MBps to 10GBps.</p>
<p class="indent">Because these connections require specific agreements between the customer, the network provider creating the link, and Microsoft, as well <span epub:type="pagebreak" id="page_131"/>as advanced networking knowledge to configure them, you’ll typically only find these types of connections in large enterprises and institutions. Because of these requirements, you’re unlikely to be able to target the ExpressRoute connection itself; however, you may be able to leverage the connection to access systems that would otherwise be inaccessible.</p>
<p class="indent">To determine if your target is using an ExpressRoute, you can use PowerShell, if you have subscription access, like so:</p>
<pre>   PS C:\&gt; <span class="codestrong1">Get-AzureRmExpressRouteCircuit</span><br class="calibre5"/><span class="ent">➊</span> Name                             : <span class="codeitalic">Express_Route_Circut_Name</span><br class="calibre5"/>   ResourceGroupName                : <span class="codeitalic">Express_Route_Resource_Group</span><br class="calibre5"/><span class="ent">➋</span> Location                         : westus<br class="calibre5"/>   Id                               : /. . ./<span class="codeitalic">Express_Route_Circut_Name</span><br class="calibre5"/>   Etag                             : W/"<span class="codeitalic">Id</span>"<br class="calibre5"/>   ProvisioningState                : Succeeded<br class="calibre5"/><span class="ent">➌</span> Sku                              : {<br class="calibre5"/>                                        "Name": "Standard_MeteredData",<br class="calibre5"/>                                        "Tier": "Standard",<br class="calibre5"/>                                        "Family": "MeteredData"<br class="calibre5"/>                                         }<br class="calibre5"/>   CircuitProvisioningState         : Enabled<br class="calibre5"/>   ServiceProviderProvisioningState : NotProvisioned<br class="calibre5"/>   ServiceProviderNotes             :<br class="calibre5"/>   ServiceProviderProperties        : {<br class="calibre5"/>                                       <span class="ent">➍</span> "ServiceProviderName": "<span class="codeitalic">ISP</span>",<br class="calibre5"/>                                       <span class="ent">➎</span> "PeeringLocation": "Silicon Valley",<br class="calibre5"/>                                       <span class="ent">➏</span> "BandwidthInMbps": 200<br class="calibre5"/>                                         }<br class="calibre5"/><span class="ent">➐</span> ServiceKey                       : <span class="codeitalic">GUID</span><br class="calibre5"/>   Peerings                         : []</pre>
<p class="indent">This command will return all of the ExpressRoute circuits in the current subscription, including their names <span class="ent">➊</span>, datacenter region <span class="ent">➋</span>, whether the connection is billed per GB for data (metered) or is unlimited <span class="ent">➌</span>, which network provider runs the link <span class="ent">➍</span>, the link location <span class="ent">➎</span>, and the bandwidth <span class="ent">➏</span>. Additionally, a <code>ServiceKey</code> is provided that other commands use to view or change settings for the connection <span class="ent">➐</span>.</p>
<p class="indent">If you gain access to an ExpressRoute-connected system, understanding what may be accessible through the link is helpful. An ExpressRoute can route traffic, between an enterprise and Microsoft datacenters, bound for three different types of services: Azure private systems, Azure public IPs, and Microsoft public IPs.</p>
<p class="indent">Private peering is a bidirectional link between company servers and resources running in Azure that are connected to an Azure VPN (for example, virtual machines). This is the equivalent of site-to-site Azure VPN connections. So, if you compromise an Azure VM connected to an ExpressRoute network, you’ll have direct access to the enterprise network on the other end of the link, and vice versa.</p>
<p class="indent">Azure public peering is a one-way company-to-Azure link to services that Azure exposes publicly (for example, Azure Storage). For this traffic, <span epub:type="pagebreak" id="page_132"/>the company network can make requests of these services, but the services cannot initiate communication back to the company. The traffic still travels through the dedicated link.</p>
<p class="indent">Microsoft public peering is a bidirectional link for other Microsoft services that are publicly exposed, such as Office 365, Exchange Online, and Skype. Because these services were designed to be used directly from the internet, Microsoft discourages routing this traffic through an ExpressRoute and requires that customers who wish to route such traffic work with their Microsoft account representatives to enable it. As such, you’re unlikely to encounter this configuration.</p>
<p class="indent">You can determine what type of routes are enabled for a given ExpressRoute by running these PowerShell commands with the service key returned by the <code>Get-AzureRmExpressRouteCircuit</code> cmdlet:</p>
<pre>PS C:\&gt; <span class="codestrong1">Import-Module 'C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\</span><br class="calibre5"/>           <span class="codestrong1">ServiceManagement\Azure\ExpressRoute\ExpressRoute.psd1'</span><br class="calibre5"/>PS C:\&gt; <span class="codestrong1">Get-AzureBGPPeering</span> <span class="codestrong1">-AccessType Private -ServiceKey "</span><span class="codestrongitalic">Key</span><span class="codestrong1">"</span><br class="calibre5"/>PS C:\&gt; <span class="codestrong1">Get-AzureBGPPeering -AccessType Public -ServiceKey "</span><span class="codestrongitalic">Key</span><span class="codestrong1">"</span><br class="calibre5"/>PS C:\&gt; <span class="codestrong1">Get-AzureBGPPeering -AccessType Microsoft -ServiceKey "</span><span class="codestrongitalic">Key</span><span class="codestrong1">"</span></pre>
<p class="indent">The first line imports ExpressRoute PowerShell cmdlets that aren’t automatically loaded with the other cmdlets. Each <code>Get-AzureBGPPeering</code> cmdlet will return the state of the specified route—enabled or disabled—as well as the network subnet associated with the connection.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre4">DEFENDER’S TIP</strong></p>
<p class="noindent">The biggest risk with an ExpressRoute connection is that an Azure virtual machine that is connected to an ExpressRoute virtual network will be compromised and used to attack resources on the enterprise’s network. The best way to avoid this attack is to make sure that no VMs in the virtual network are assigned public IP addresses. If the VM isn’t public facing, it can only be attacked from within the subscription or from the enterprise network, which greatly reduces the risk of a breach. To make sure no such internet-to-ExpressRoute-to-enterprise bridge is created, a good practice is to place ExpressRoute connections and any resources that use them into their own subscription; that way, a public resource can’t be accidentally added to the ExpressRoute virtual network. Another option is to enable forced tunneling, which routes all traffic on a system back through the VPN connection. More information can be found at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/vpn-gateway/vpn-gateway-about-forced-tunneling/" class="calibre15">https://docs.microsoft.com/en-us/azure/vpn-gateway/vpn-gateway-about-forced-tunneling/</a></em>.</p>
</div>
<h4 class="h2" id="lev156"><span epub:type="pagebreak" id="page_133" class="calibre1"/><strong class="calibre2"><em class="calibre10">Service Bus</em></strong></h4>
<p class="noindent">The full network connectivity that VPNs and ExpressRoute offer is great for complex environments that use lots of protocols, but not every scenario calls for such a large pipe between the cloud and a corporation. For projects with a much smaller scope, Azure Service Bus may be a better solution. With Service Bus, a developer creates an endpoint in Azure that services can communicate with and then runs a small agent application on the corporate network that calls out to Azure to receive the incoming work. With this design, administrators don’t need to open any inbound ports on the corporate firewall because the connection originates from the internal network.</p>
<p class="indent">Service Bus offers two different modes of operation: <em class="calibre7">Brokered messaging</em> is a pull mechanism that caches inbound messages in Azure until the agent application calls out to pick up any pending work. <em class="calibre7">Azure Relay</em> maintains a persistent connection between Azure and the agent, so work is pushed through the pipe immediately and nothing is cached. Both of these mechanisms use the same Service Bus resource; it’s up to the developer to choose whose messages are received.</p>
<p class="indent">The messages that pass through Service Bus are completely at the discretion of the developer using the service; much like the post office, Service Bus only handles proper delivery of packets without regard for their content. Because Service Bus is so flexible, administrators must write custom code for both the message producer side of the pipe and the consuming end in order to create, then interpret and act upon, the messages. As a result, the Azure portal and Azure PowerShell cmdlets only show the administrative details of the Service Bus resources (for example, pending message count and last message received date), but not any details of the messages themselves. However, you can use an open source utility to examine the messages.</p>
<h5 class="h3" id="lev157"><strong class="calibre2">Obtaining Service Bus Administrative Details</strong></h5>
<p class="noindent">Every Service Bus instance has several properties that can be useful to a penetration tester: the name of the instance, its resource group, its URL, and its access key(s). To obtain this information, begin by opening a PowerShell command prompt, connecting to the Azure subscription, and then running the following command:</p>
<pre>   PS C:\&gt; <span class="codestrong1">Get-AzureRmServiceBusNamespace</span><br class="calibre5"/><br class="calibre5"/><span class="ent">➊</span> Name               : <span class="codeitalic">name</span><br class="calibre5"/>   Id                 : /. . ./ resourceGroups/sbrg<span class="ent">➋</span>/. . ./namespaces/<span class="codeitalic">name</span><br class="calibre5"/><span class="ent">➌</span> Location           : West US<br class="calibre5"/>   Sku                :<br class="calibre5"/>   ProvisioningState  : Succeeded<br class="calibre5"/>   Status             : Active<br class="calibre5"/>   CreatedAt          : 6/24/2019 2:02:22 PM<br class="calibre5"/>   UpdatedAt          : 6/24/2019 3:01:00 PM<br class="calibre5"/><span class="ent">➍</span> ServiceBusEndpoint : https://<span class="codeitalic">name</span>.servicebus.windows.net:443/<br class="calibre5"/>   Enabled            : True</pre>
<p class="indent"><span epub:type="pagebreak" id="page_134"/>This should display each Service Bus resource within the current subscription, including its name <span class="ent">➊</span>, resource group <span class="ent">➋</span> (nested within the <code>Id</code> field), geographic location <span class="ent">➌</span>, and URL <span class="ent">➍</span>. Each Service Bus can also have multiple access keys. Each key is associated with an <em class="calibre7">authorization rule</em>, which determines if the key can be used to send messages (a Send right), receive them (a Listen right), perform administrative actions on the queue (a Manage right), or some combination of these actions. By default, each Service Bus has a primary and secondary root key that can perform any action.</p>
<p class="indent">To view the authorization rules used for a given instance, run this command:</p>
<pre>   PS C:\&gt; <span class="codestrong1">Get-AzureRmServiceBusNamespaceAuthorizationRule</span> <br class="calibre5"/>       <span class="codestrong1">-ResourceGroup</span> <span class="codestrongitalic">resource_group</span> <span class="codestrong1">-NamespaceName</span> <span class="codestrongitalic">name</span><br class="calibre5"/><br class="calibre5"/>   Id       : /. . ./namespaces/<span class="codeitalic">name</span>/AuthorizationRules/RootManageSharedAccessKey<br class="calibre5"/>   Type     : Microsoft.ServiceBus/Namespaces/AuthorizationRules<br class="calibre5"/><span class="ent">➊</span> Name     : RootManageSharedAccessKey<br class="calibre5"/>   Location :<br class="calibre5"/>   Tags     :<br class="calibre5"/><span class="ent">➋</span> Rights   : {Listen, Manage, Send}</pre>
<p class="indent">This should provide the name of each rule <span class="ent">➊</span> as well as what rights it grants <span class="ent">➋</span>. You can find details about the exact privileges associated with each right at <em class="calibre7"><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-sas#rights-required-for-service-bus-operations" class="calibre6">https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-sas#rights-required-for-service-bus-operations</a></em>.</p>
<p class="indent">Once you have a rule name, you can run the following command to obtain the access keys associated with that rule:</p>
<pre>PS C:\&gt; <span class="codestrong1">Get-AzureRmServiceBusNamespaceKey</span> <span class="codestrong1">-ResourceGroup</span> <span class="codestrongitalic">resource_group</span> <br class="calibre5"/>    <span class="codestrong1">-NamespaceName</span> <span class="codestrongitalic">name</span> <span class="codestrong1">-AuthorizationRuleName</span> <span class="codestrongitalic">RootManageSharedAccessKey</span><br class="calibre5"/><br class="calibre5"/>PrimaryConnectionString   : Endpoint=sb://<span class="codeitalic">name</span>.servicebus.windows.net/;<br class="calibre5"/>    SharedAccessKeyName=<span class="codeitalic">RootManageSharedAccessKey</span>;SharedAccessKey=<span class="codeitalic">Base64_Value</span><br class="calibre5"/>SecondaryConnectionString : Endpoint=sb://<span class="codeitalic">name</span>.servicebus.windows.net/;<br class="calibre5"/>    SharedAccessKeyName=<span class="codeitalic">RootManageSharedAccessKey</span>;SharedAccessKey=<span class="codeitalic">Base64_Value</span><br class="calibre5"/>PrimaryKey                : <span class="codeitalic">Base64_Value</span><br class="calibre5"/>SecondaryKey              : <span class="codeitalic">Base64_Value</span><br class="calibre5"/>KeyName                   : <span class="codeitalic">RootManageSharedAccessKey</span></pre>
<p class="indent">Using either of these keys, you should be able to interact with the Service Bus instance just as the developer’s applications would.</p>
<h5 class="h3" id="lev158"><strong class="calibre2">Interacting with Service Bus Messages</strong></h5>
<p class="noindent">Once you have an access key for a Service Bus instance, you should examine the contents of the messages going through that channel. Depending on the messages you see, you might take one of several actions:</p>
<ul class="calibre8">
<li class="noindent1">If messages contain sensitive data, such as email addresses or credit card numbers, that is a finding to report.</li>
<li class="noindent1"><span epub:type="pagebreak" id="page_135"/>For messages that seem to trigger an action, such as order processing, see if inserting a rogue message will result in an action, such as shipping goods without making a payment.</li>
<li class="noindent1">Send messages with invalid values to see if the receiving application is vulnerable to common software errors, such as remote code execution, denial of service, and SQL injection.</li>
</ul>
<p class="indent">Of course, each of these actions require a program that can interact with Service Bus. Because there aren’t any native Azure tools for this, you have two options: attempt to modify the developer’s own code, or use a separate tool. If you’ve already found the developer’s source code during the engagement (or if you have a copy of their application and you possess reverse-engineering skills), the first option might be best. This would allow you to understand exactly what kinds of messages this Service Bus processes as well as to review the receiver code to look for exploitable mistakes, such as insufficient message-validation checks. Additionally, you’d probably only need to make minor tweaks to create test messages.</p>
<p class="indent">In many cases, though, you might not find a copy of the developer’s code. In these instances, Service Bus Explorer (<em class="calibre7"><a href="https://github.com/paolosalvatori/ServiceBusExplorer/" class="calibre6">https://github.com/paolosalvatori/ServiceBusExplorer/</a></em>) is your best bet. Service Bus Explorer is a free, open source tool to examine pending messages, send test messages, and perform management tasks on Service Bus. <a href="part0015.html#ch06fig5" class="calibre6">Figure 6-5</a> shows Service Bus Explorer viewing an unretrieved brokered message from a queue.</p>
<div class="image1"><a id="ch06fig5" class="calibre6"/><img src="../images/00049.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-5: Service Bus Explorer interface</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_136"/>For particularly busy queues, Service Bus Explorer offers the Create Queue Listener option; you can access it by right-clicking the name of a queue. This opens a window that can record messages as they enter the queue, and it displays statistics about the number, size, and speed at which messages are processed. After reviewing a number of messages, you can use the Send Messages option in the same menu to test the receiver’s handling of rogue instructions.</p>
<p class="indent">One last thing to know about Service Bus Explorer is where it caches its credentials. Like the storage utilities discussed in <a href="part0013.html#ch04" class="calibre6">Chapter 4</a>, Service Bus Explorer allows users to save any of the connection strings they use. Therefore, if you find it installed on a system you compromise, check for saved credentials. These are stored in the same directory as the Service Bus Explorer application, in a file named <em class="calibre7">ServiceBusExplorer.exe.Config</em>; this is an XML file, and the credentials are located in the <code>&lt;serviceBusNamespaces&gt;</code> section.</p>
<h4 class="h2" id="lev159"><strong class="calibre2"><em class="calibre10">Logic Apps</em></strong></h4>
<p class="noindent">Logic Apps, the most recent entrant to the cross-network communication field, allow developers and code novices alike to create a trigger for an event in one of any number of Azure or third-party services that sets off a chain reaction of other events. For example, a Logic App could monitor Twitter for tweets containing a company’s name and log them to a SQL database. The same app could also email the CEO and post to the marketing team’s Slack channel.</p>
<p class="indent">Whereas Service Bus relies on the developer to decide what to do with an incoming message and write the code to take action on it, Logic Apps do all of the backend work to tie disparate services together. Users just need to create a workflow with a simple GUI.</p>
<p class="indent">As brokers between other services, Logic Apps don’t offer a large attack surface. They don’t maintain copies of the data they route, so the selected destination service decides what to do with the data. But there is one area of interest for a penetration tester: service credentials. With the ability to read from or post to everything from Adobe Creative Cloud to Zendesk, Logic Apps have the ability to cache a lot of credentials or access tokens for both Microsoft and third-party services. However, all of the credentials are write-only; once submitted, the keys can be overwritten, but they are never again revealed to the user.</p>
<p class="indent">Although this design does prevent an attacker from stealing service credentials and using them elsewhere, an attacker can still leverage them for nefarious purposes. Once a credential is stored, it’s accessible from within that particular Logic App for all actions related to that service. In other words, if a Logic App contains an action to read from Twitter, a pentester can add an action to the app to post a tweet from the same account without additional authorization, as shown in <a href="part0015.html#ch06fig6" class="calibre6">Figure 6-6</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_137"/>As a pentester, if you have access to the Logic App in Azure portal, you can modify it to perform new actions against the same services that the app already uses. I suggest doing this in the portal, because Logic Apps are designed to be created with the GUI-based editor; therefore, the PowerShell cmdlets for Logic Apps have limited capabilities.</p>
<div class="image1"><a id="ch06fig6" class="calibre6"/><img src="../images/00050.jpeg" alt="image" class="calibre3"/></div>
<p class="figcap"><em class="calibre7">Figure 6-6: Logic App Designer showing the addition of a Post a tweet action</em></p>
<h3 class="h1" id="lev160"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">In this chapter, we discussed various ways to establish and protect networks in Azure, as well as ways to leverage these technologies in a penetration test. We started with firewalls built into Azure, including those used for virtual machines, SQL servers, and web applications. Next, we looked at VPN options available in Azure, including point-to-site, site-to-site, multisite, and VNet-to-VNet, and how an attacker could attempt to infiltrate these connections. Then, we discussed ExpressRoute, a dedicated circuit technology similar to VPNs that large companies use to connect directly to Azure.</p>
<p class="indent"><span epub:type="pagebreak" id="page_138"/>Finally, we covered two technologies to connect non-Azure services to Azure: Service Bus provides a message tunnel for developers looking to receive information from the cloud, and Logic Apps are designed for nondevelopers to build workflows between Azure, other services providers, and enterprise systems. Take extra care when auditing network components; though each of these technologies includes security mechanisms, if they are improperly configured, this could lead to the compromise of an Azure virtual network, a corporate network, or accounts within third-party services.</p>
</body></html>