- en: Chapter 6. The GNU Make Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *GNU Make Standard Library (GMSL)* is a SourceForge-hosted, open source
    project that I started to capture common functions that makefile authors end up
    writing over and over again. To prevent makefile writers from reinventing the
    wheel, the GMSL implements common functions, such as reversing lists, uppercasing
    a string, or mapping a function across every element of a list.
  prefs: []
  type: TYPE_NORMAL
- en: The GMSL has list and string manipulation functions, a complete integer arithmetic
    library, and functions for data structures. Also included are GNU `make` implementations
    of associative arrays, sets, and stacks, as well as built-in debugging facilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to use the functions of the GMSL in realistic
    makefiles. In addition, you’ll see a complete reference for the different categories
    of GMSL functions. For the latest revision of the GMSL, visit *[http://gmsl.sf.net/](http://gmsl.sf.net/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the GMSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GMSL is implemented as a pair of makefiles named `gmsl` and `__gmsl`. `__gmsl`
    is imported by `gmsl`, so to include the GMSL in your makefile, just add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can do this in as many files as you want. To prevent multiple definitions
    and unintended error messages, the GMSL automatically detects if it has already
    been included.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, GNU `make` must be able to find `gmsl` and `__gmsl`. To do that,
    GNU `make` looks for makefiles in a number of places by default, including `/usr/local/include`,
    `/usr/gnu/include/`, `/usr/include`, the current directory, and any directories
    specified by the GNU `make -I` (or `--include-dirL`) command line option.
  prefs: []
  type: TYPE_NORMAL
- en: A good place to put `gmsl` and `__gmsl` is `/usr/local/include`, where they’ll
    be available to all your makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'If GNU `make` can’t find `gmsl` or `__gmsl`, you’ll get the regular GNU `make`
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The GMSL uses a little trick to make the location of `gmsl` completely flexible.
    Because `gmsl` uses `include` to find `__gmsl`, the `gmsl` makefile needs to know
    where to find `__gmsl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose that `gmsl` was stored in `/foo` and included with `include /foo/gmsl`.
    To make this work without having to modify `gmsl` to hardcode the location of
    `__gmsl`, `gmsl` figures out where it’s located using `MAKEFILE_LIST` and then
    prepends the appropriate path to the `include __gmsl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That’s a handy technique if you want your makefiles to be location independent.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a GMSL Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The functions in the GMSL are implemented as normal GNU `make` function declarations.
    For example, the function `last` (which returns the last element of a list) is
    declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is called using GNU `make`’s built-in `$(call)`. For example,
    to return the last element of the list `1 2 3`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will return `3`. `$(call)` expands the variable named in its first argument
    (in this case, `last`), setting special local variables (`$1`, `$2`, `$3`, . .
    .)to the arguments given to `$(call)` after the function name. So `$1` is `1 2
    3` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GMSL defines the Boolean values `true` and `false`, which are just variables
    and can be accessed using `$()` or `${}`: for example, `$(true)` or `${false}`.
    `false` is an empty string, and `true` is the letter `T`; these definitions correspond
    to GNU `make`’s notion of true (a non-empty string) and false (an empty string).
    You can use `true` and `false` in GNU `make`’s `$(if)` function or within a preprocessor
    `ifeq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These examples are contrived. You’d expect the `$(true)` in the `$(if)` and
    the first `$(true)` in the `ifeq` to be the return values from a function call,
    not a constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the GMSL Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GMSL includes a function that you can use to check that the version included
    is compatible with your use of the GMSL. The function `gmsl_compatible` checks
    that the version number of the included GMSL is greater than or equal to the version
    number passed as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of this writing, the current GMSL version is `v1.1.7`. To check
    that the included GMSL is at least, say, `v1.1.2`, call `gmsl_compatible` with
    a list argument containing three elements: `1 1 2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return `$(true)` because the current GMSL is `v1.1.7`, which is greater
    than `v1.1.2`. If we asked for `v2.0.0`, we’d get the response `$(false)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple way to make sure that you are using the right version of GMSL is to
    wrap the call to `gmsl_compatible` in an assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will stop the `make` process with an error if an incompatible version of
    GMSL is found.
  prefs: []
  type: TYPE_NORMAL
- en: Example Real-World GMSL Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’re set up with the GMSL, let’s look at some examples. All of these
    solve problems that real-world makefiles have to deal with, like caseinsensitive
    comparisons and searching a path for a file.
  prefs: []
  type: TYPE_NORMAL
- en: Case-Insensitive Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GMSL contains two functions that let you create a simple function to do a case-insensitive
    comparison of two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This works by lowercasing its two arguments (using the GMSL `lc` function)
    and then calling `seq` (the GMSL string equality function) to see if they are
    the same. Here’s one way to use `ifcase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here it’s used to see if the `DEBUG` variable has been set to `yes`; if it has,
    `-DDEBUG` is added to `CPPFLAGS`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Program on the Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a function definition that will search the `PATH` for an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, `$(call findpath,cat)` will search the `PATH` for the first `cat`
    program. It uses three functions from the GMSL: `first`, `map`, and `split`. It
    uses two built-in functions: `wildcard` and `addsuffix`.'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `split` breaks the `PATH` variable into a list, separating it at
    colons. Then the built-in `addsuffix` function is called, which adds `/$1` to
    each element of the `PATH`. `$1` contains the parameter to `findpath`, which is
    the name of the program we’re searching for (in this case, it was `cat`).
  prefs: []
  type: TYPE_NORMAL
- en: Then the GMSL `map` function is called to perform a built-in `wildcard` on each
    possible program filename. With no wildcard characters in the filename, `wildcard`
    will return the name of the file if it exists or an empty string. So `map` has
    the effect of finding the location (or locations) of `cat` on the `PATH` by testing
    each file in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a call to the GMSL function `first` returns the first element of the
    list that `map` returns (the list of all `cat` programs on the `PATH`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A debugging feature of GMSL is the ability to trace calls to GMSL functions.
    By setting `GMSL_TRACE` to `1`, GMSL will output each call to a GMSL function
    with its parameters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re searching for `cat` using the `findpath` function with tracing turned
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Using Assertions to Check Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, a makefile is executed specifying a goal for the build (or under
    the assumption that there’s an `all` target or similar at the start of the makefile).
    In addition, there are typically environment variables (like debug options, architecture
    settings, and so on) that affect the build. A quick way to check that these have
    been set correctly is to use GMSL assertion functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that checks that `DEBUG` has been set to `yes` or `no`, that
    `ARCH` contains the word `Linux`, that we’ve specified an output directory in
    the `OUTDIR` variable, and that that directory exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The assertion functions will generate a fatal error if their first argument
    is `$(false)` (that is, an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first assert checks that `$(OUTDIR)` has been set to something. If it has
    a non-empty value, the assertion passed; otherwise, an error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second assertion is of the form `assert_exists`, which checks to see whether
    its first argument exists in the file system. In this case, it checks to see whether
    the directory pointed to by `$(OUTDIR)` exists. It doesn’t check to see whether
    it’s a directory. We can add another assertion to do that, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This looks to see if `$(OUTDIR)` contains a dot (**`.`**). If not, `$(OUTDIR)`
    is not a directory, and the call to `wildcard` will return an empty string, causing
    the assertion to fail.
  prefs: []
  type: TYPE_NORMAL
- en: The third assertion checks that `DEBUG` is either `yes` or `no` using the GMSL
    `seq` function to check the value. Finally, we assert using `findstring` that
    `$(ARCH)` must contain the word `Linux` (with the `L` capitalized).
  prefs: []
  type: TYPE_NORMAL
- en: Is DEBUG Set to Y?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GMSL has the logical operators `and`, `or`, `xor`, `nand`, `nor`, `xnor`,
    and `not` that work with GNU `make`’s concept of truth values and the GMSL variables
    `$(true)` and `$(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use GNU `make`’s (and GMSL’s) Boolean values with both GMSL functions
    and GNU `make`’s built-in `$(if)`. The GMSL logical operators were designed for
    use with `$(if)` and the GNU `make` preprocessor `ifeq` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that a makefile has a debug option, enabled by setting the `DEBUG`
    environment variable to `Y`. Using the GMSL function `seq` (string equal) and
    the `or` operator, you can easily determine whether debugging is desired or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the GMSL has a lowercase function (`lc`), you can write this example
    without the `or`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But the logical operator `or` lets us be even more generous and accept `YES`
    as well as `Y` for the debug option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The function `debug_needed` is case insensitive too.
  prefs: []
  type: TYPE_NORMAL
- en: Is DEBUG Set to Y or N?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another possible use of the logical operators is to force the user of the makefile
    to set `DEBUG` to either `Y` or `N`, thus avoiding problems if they forget about
    the debug option. The GMSL assertion function `assert` will output a fatal error
    if its argument is not true. So we can use it to assert that `DEBUG` must be `Y`
    or `N`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The assertion generates this error if the user makes the mistake of setting
    `DEBUG` to `Oui`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Logical Operators in the Preprocessor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because GNU `make`’s preprocessor (which has `ifeq`, `ifneq`, and `ifdef` directives)
    doesn’t have any logical operations, it’s difficult to write a complex statement.
    For example, to define a section of a makefile if `DEBUG` is set to `Y` or `Yes`
    in GNU `make`, you must either duplicate a section of code (yuck!) or write a
    statement that’s hard to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This works by filtering the list `Y Yes` with the value of `$(DEBUG)`, which
    returns an empty list if `$(DEBUG)` is not `Y` or `Yes`, or returns the value
    of `$(DEBUG)` if it is. The `ifeq` then compares the resulting value with `$(DEBUG)`.
    That’s pretty ugly, hard to maintain, and contains a subtle bug. (What happens
    if `$(DEBUG)` is empty? Hint: empty is the same as `Y` or `Yes`.) Fixing the bug
    means doing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The GMSL `or` operator makes this much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is much more maintainable. It works by `or`ing two calls to `seq` and comparing
    the result with `$(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Duplicates from a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GMSL function `uniq` removes duplicates from a list. GNU `make` has a built-in
    `sort` function that sorts a list and removes duplicates; `uniq` removes duplicates
    without sorting the list (which can be handy if list order is important).
  prefs: []
  type: TYPE_NORMAL
- en: For example, `$(sort c b a a c)` will return `a b c`, whereas `$(call uniq,c
    b a a c)` returns `c b a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you need to simplify the `PATH` variable by removing duplicate entries
    while preserving the order. The `PATH` is typically a colon-separated list of
    paths (like `/usr/bin:/bin:/usr/local/bin:/bin`). Here `simple-path` is the `PATH`
    with duplicates removed and order preserved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses three GMSL functions: `uniq`, `split` (which splits a string into
    a list at a certain separator character; in this case, a colon), and `merge` (which
    merges a list into a string separating list entries with a character; in this
    case, a colon).'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Incrementing a Version Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it’s release time for a piece of software, it’s handy to have a way to
    increment the version number automatically. Suppose that a project contains a
    file called `version.c` that contains the current version number as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It would be ideal to just type `make major-release`, `make minor-release`, or
    `make dot-release` and have one of the three parts of the version number automatically
    update and the `version.c` file change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `VERSION` variable contains the contents of the `version.c` file, which
    will be something like `char * ver = "1.0.0";`. The `PARTS` variable is a list
    created by first removing all the whitespace from `VERSION` and then splitting
    on the double quotes. That splits `VERSION` into the list `char*ver= 1.0.0 ;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So `PARTS` is a list with three elements, and the second element is the current
    version number, which is extracted into `VERSION_NUMBER` and turned into a list
    of three elements: `1 0 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, variables called `MAJOR`, `MINOR`, and `DOT` are extracted from `VERSION_NUMBER`.
    If the version number in `version.c` was `1.2.3`, then `MAJOR` will be `1`, `MINOR`
    will be `2`, and `DOT` will be `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, three rules are defined for major, minor, and dot releases. These use
    some `$(eval)` trickery to use the same rule body to update the major, minor,
    or dot release number depending on which of `major-release`, `minor-release`,
    or `dot-release` was specified on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how it works, follow what happens when you do `make minor-release`
    with an existing version number of `1.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `$(eval increment_name := $(call uc,$(subst -release,,$@)))` ➊ first uses
    `$(subst)` to remove `-release` from the target name (so `minor-release` becomes
    simply `minor`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then it calls the GMSL `uc` function (which uppercases a string) to turn `minor`
    into `MINOR`. It stores that in a variable called `increment-name`. Here’s the
    tricky part: `increment-name` will be used as the name of a variable to increment
    (one of `MAJOR`, `MINOR`, or `DOT`).'
  prefs: []
  type: TYPE_NORMAL
- en: At ➋, `$(eval $(increment_name) := $(call inc,$($(increment_name))))` actually
    does that work. It uses the GMSL `inc` function to increment the value stored
    in the variable whose name is in `increment-name` (notice the `$($(increment-name))`,
    which finds the value of a variable whose name is in another variable) and then
    sets that value to the incremented value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it just creates a new `version.c` containing the new version number
    ➌. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the result of using the `-n` option when starting from version 1.0.0
    and asking for the different possible releases.
  prefs: []
  type: TYPE_NORMAL
- en: GMSL Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a complete reference for the GNU Make Standard Library version
    1.1.7 and covers GMSL logical operators; integer functions; list, string, and
    set manipulation functions; associative arrays; and named stacks. For each category
    of GMSL functions, you’ll see an introduction to the functions, followed by a
    quick reference section that lists arguments and returns. For the latest version
    of the complete reference, check the GMSL website at *[http://gmsl.sf.net/](http://gmsl.sf.net/)*.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in advanced GNU `make` programming, it’s worth studying
    the source code of the GMSL (especially the file `__gmsl`). The techniques used
    to create individual GMSL functions are often useful in other situations.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GMSL has Booleans `$(true)`, a non-empty string actually set to the single character
    `T`, and `$(false)`, an empty string. You can use the following operators with
    those variables or with functions that return those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these functions are consistent in that they always return `$(true)`
    or `$(false)`, they are lenient about accepting any non-empty string that indicates
    *true*. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This tests for the existence of either of two files, `/tmp/foo` and `/tmp/bar`,
    using `$(wildcard)` and the GMSL `or` function. Doing `$(wildcard /tmp/foo)` will
    return `/tmp/foo` if the file exists or an empty string if not. So the output
    of the `$(wildcard /tmp/foo)` can be fed directly into `or`, where `/tmp/foo`
    will be interpreted as *true* and an empty string as *false*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel more comfortable working exclusively with values like `$(true)`
    and `$(false)`, define a `make-bool` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will turn any non-empty string (after stripping off whitespace) into `$(true)`
    and leave a blank string (or one that had only whitespace in it) as `$(false)`.
    `make-bool` can be handy when whitespace might slip into values returned by functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a small GNU `make` variable that is `$(true)` if the current
    month is January:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This runs the `date` shell command, extracts the word `Jan`, and turns it into
    a truth value using `make-bool`. Using `$(filter)` like this treats the result
    of `date` as a list and then filters out any word in the list that is not `Jan`.
    This technique can be handy in other situations for extracting parts of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a generic function to discover if a list contains a word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using `contains-word`, you can redefine `january-now`.
  prefs: []
  type: TYPE_NORMAL
- en: not
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GMSL includes all the common logical operators. The simplest is the `not`
    function, which logically negates its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call not,$(true))` returns `$(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `and` function returns `$(true)` if (and only if) both its arguments are
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call and,$(true),$(false))` returns `$(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `or` function returns `$(true)` if either of its arguments is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call or,$(true),$(false))` returns `$(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: xor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `xor` function is *exclusive or*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call xor,$(true),$(false))` returns `$(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: nand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nand` is simply *not and*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call nand,$(true),$(false))` returns `$(true)` where `$(call
    and,$(true),$(false))` returns `$(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: nor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nor` is simply *not or*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call nor,$(true),$(false))` returns `$(false)` where `$(call
    or,$(true),$(false))` returns `$(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: xnor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rarely used `xnor` is *not xor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the GMSL logical functions `and` and `or` are not *short circuiting*;
    both of the arguments to those functions are expanded before performing the logical
    `and` or `or`. GNU `make` 3.81 introduced built-in `and` and `or` functions that
    are short circuiting: they evaluate their first argument and then decide whether
    it’s necessary to evaluate their second.'
  prefs: []
  type: TYPE_NORMAL
- en: Integer Arithmetic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Pushing the Envelope"), you saw how to
    perform arithmetic inside GNU `make` by representing non-negative integers as
    lists of `x`s. For example, 4 is `x x x x`. GMSL uses the same representation
    for integers and provides a wide range of functions for integer calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arithmetic library functions come in two forms: one form of each function
    takes integers as arguments, and the other form takes encoded arguments (`x`s
    created by a call to `int_encode`). For example, there are two `plus` functions:
    `plus` (called with integer arguments, returns an integer) and `int_plus` (called
    with encoded arguments, returns an encoded result).'
  prefs: []
  type: TYPE_NORMAL
- en: '`plus` will be slower than `int_plus` because its arguments and result must
    be translated between the `x` format and integers. If you’re doing a complex calculation,
    use the `int_*` forms with a single encoding of inputs and single decoding of
    the output. For simple calculations, you can use the direct forms.'
  prefs: []
  type: TYPE_NORMAL
- en: int_decode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `int_decode` function takes a number in `x`-representation and returns
    the decimal integer that it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: int_encode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_encode` is the opposite of `int_decode`: it takes a decimal integer and
    returns the `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: int_plus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_plus` adds two numbers in `x`-representation together and returns their
    sum in `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: plus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add decimal integers, use the `plus` function, which converts to and from
    `x`-representation and calls `int_plus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: int_subtract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_subtract` subtracts two numbers in `x`-representation and returns the
    difference in `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If the difference will be less than 0 (which can’t be represented), an error
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: subtract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To subtract decimal integers, use the `subtract` function, which converts to
    and from `x`-representation and calls `int_subtract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If the difference will be less than 0 (which can’t be represented), an error
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: int_multiply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_multiply` multiplies two numbers that are in `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: multiply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`multiply` will multiply two decimal integers and return their product. It
    automatically converts to and from `x`-representation and calls `int_multiply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: int_divide
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_divide` divides one number by another; both are in `x`-representation,
    as is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: divide
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `divide` function calls `int_divide` to divide two decimal integers, automatically
    converting to and from `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: int_max and int_min
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_max` and `int_min` return the maximum and minimum, respectively, of two
    numbers in `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: max and min
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The decimal integer equivalents of `int_max` and `int_min` are `max` and `min`;
    they automatically convert to and from `x`-representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: int_inc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int_inc` is a small helper function that just adds one to an `x`-representation
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: inc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `inc` function adds one to a decimal integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: int_dec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The opposite of `int_inc` is `int_dec`: it decreases a number by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: dec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dec` function decrements a decimal integer by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: int_double
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `double` and `halve` functions (and their `int_double` and `int_halve` equivalents)
    are provided for performance reasons. If you’re multiplying by two or dividing
    by two, these functions will be faster than multiplication and division.
  prefs: []
  type: TYPE_NORMAL
- en: '`int_double` will double an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: double
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`double` will double a decimal integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Internally, it converts to `x`-representation and calls `int_double`.
  prefs: []
  type: TYPE_NORMAL
- en: int_halve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can perform an integer division by two by calling `int_halve` on an `x`-representation
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: halve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, there’s `halve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is the decimal integer equivalent of `int_halve`.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Comparison Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the integer comparison functions return `$(true)` or `$(false)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These can be used with GNU `make` and GMSL functions as well as with directives
    that expect Boolean values (such as the GMSL logical operators).
  prefs: []
  type: TYPE_NORMAL
- en: 'But you are more likely to use these versions of the comparison functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: These operate on decimal integers, not the internal `x`-representation that
    GMSL uses.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Integer Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most likely, you’re not going to need to do anything advanced with GNU `make`
    arithmetic, but the miscellaneous functions detailed here do base conversions
    and generation of numeric sequences. They can, on occasion, be useful.
  prefs: []
  type: TYPE_NORMAL
- en: sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You use the `sequence` function to generate a sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call sequence,10,15)` will be the list `10 11 12 13 14 15`.
    To create a decreasing sequence, you invert the parameters to `sequence`. For
    example, `$(call sequence,15,10)` will be the list `15 14 13 12 11 10`.
  prefs: []
  type: TYPE_NORMAL
- en: dec2hex, dec2bin, and dec2oct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dec2hex`, `dec2bin`, and `dec2oct` functions perform conversion between
    decimal numbers and hexadecimal, binary, and octal forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call dec2hex,42)` will be `2a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No options are available for padding with leading zeroes. If that’s necessary,
    you can use GMSL string functions. For example, here’s a padded version of `dec2hex`
    that takes two parameters: a decimal number to be converted to hexadecimal and
    the number of digits to output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This works by defining some helper functions. First, `repeat` creates a string
    consisting of a number of copies of another string. For example, `$(call repeat,10,A)`
    will be `AAAAAAAAAA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some subtle things are happening in this definition. The `repeat` function
    calls `__repeat` with three parameters: `$1` is the string to be repeated, `$2`
    is the number of times to repeat `$1`, and `$3` has been set to a blank string
    by the trailing comma in the `$(call)` to __`repeat`. The `$0` variable contains
    the name of the current function; in `__repeat` it will be `__repeat`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__repeat` function is recursive and uses the `$2` as the recursion guard.
    The `repeat` function converts the number of desired repeats into the `x`-representation
    used by GMSL arithmetic functions and passes it to `__repeat`. For example, `$(call
    repeat,Hello,5)` turns into `$(call __repeat,Hello,x x x x x,)`, and `__repeat`
    chops an `x` off `$2` each time around until `$2` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `repeat` written, we just need a way to pad a string to some number of
    characters with a padding character. The function `pad` achieves that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Its three arguments are the character to pad with, the total width of the padded
    output in character, and the string to pad. For example, `$(call pad,0,4,2a)`
    would return `002a`. From that, a padded `dec2hex` can easily be defined. It takes
    two parameters: the first is the decimal number to convert to hexadecimal, and
    the second is the number of characters to pad to.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect, `$(call paddeddec2hex,42,8)` returns `0000002a`.
  prefs: []
  type: TYPE_NORMAL
- en: List Manipulation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In GNU `make` and GMSL terms, a list is a string of characters that has whitespace
    as separators. Both the GNU `make` built-in functions that work on lists and the
    GMSL functions treat multiple whitespaces as a single space. So the lists `1 2
    3` and `1 2 3` are the same.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll explain a few of the list manipulation functions in detail in the following
    sections. These functions are more complicated than the others in their use, and
    they’re typically available in functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Function to a List with map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re working with GNU `make` functions (either built-ins or your own),
    you’re actually programming in a simple functional language. In functional programming,
    it’s common to have a map function that applies a function to every element of
    a list. GMSL defines `map` to do exactly that. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Given a list of filenames (perhaps with paths specified) in `SRCS`, this will
    ensure that all the filenames are lowercased and then apply the `uniq` function
    to get a unique list of source files.
  prefs: []
  type: TYPE_NORMAL
- en: This uses the GMSL function `lc` to lowercase each filename in `SRCS`. You can
    use the `map` function with both built-in and user-defined functions. Here, `NORMALIZED`
    would be `src/foo.c src/submodule/bar.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use of `map` might be to get the size of every source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a `size` function that uses `$(shell)` to call `wc`, and then
    we apply it to every file in `SRCS`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `SOURCE_SIZES` might be something like `1538 1481` with one element for
    each source file.
  prefs: []
  type: TYPE_NORMAL
- en: Making a reduce Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common function in functional languages is `reduce`. `reduce` applies
    a function that takes two parameters to successive elements of a list, feeding
    the return value from the function into the next call to it. The GMSL doesn’t
    have a built-in `reduce` function, but you can easily define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summing a List of Numbers Using reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Combining `reduce` with the `plus` function, you can easily make a GNU `make`
    function that sums a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum-list` function takes a single parameter, a list of numbers, and returns
    the sum of those numbers. It passes three things to `reduce`: the name of the
    function to call for each element of the list (in this case, `plus`), the list
    of numbers, and a starting number (in this case, `0`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works. Suppose `$(call sum-list,1 2 3 4 5)` is called. The following
    sequence of calls to `plus` will be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first call uses the first element of the list and the starting number `0`.
    Each subsequent call uses the next element from the list and the last result of
    calling `plus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could combine `sum-list` with the `SOURCE_SIZES` variable to get the total
    size of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `TOTAL_SIZE` would be `3019`.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a Function Across a Pair of Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other interesting function that GMSL defines for lists is `pairmap`. It
    takes three arguments: two lists (which should be the same length) and a function.
    The function is applied to the first element of each list, the second element,
    the third element, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose `SRCS` contains a list of source files. Using the `size` function we
    defined, combined with `map`, we defined `SOURCE_SIZES`, which contains a list
    of the sizes of each source file. Using `pairmap`, we can zip the two lists together
    to output the name of each file and its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `zip` function is applied to each source filename and size in turn, and
    makes a string separating the filename and its size with a colon. Using our example
    files and sizes from this section, `SOURCES_WITH_SIZES` would be `src/foo.c:1538
    src/submodule/bar.c:1481`.
  prefs: []
  type: TYPE_NORMAL
- en: first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`first` takes in a list and returns its first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that `first` is identical to the GNU `make` function `$(firstword)`.
  prefs: []
  type: TYPE_NORMAL
- en: last
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `last` function returns the final element of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: GNU `make` 3.81 introduced `$(lastword)`, which works the same way `last` does.
  prefs: []
  type: TYPE_NORMAL
- en: rest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rest` function is almost the opposite of `first`. It returns everything
    but the first element of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: chop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove the last element of a list, use the `chop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `map` function iterates over a list (its second argument) and calls a function
    (named in its first argument) on each list element. The list of values returned
    by each call to the named function is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: pairmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pairmap` is similar to map but iterates over a pair of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The function in the first argument is called with two arguments: one element
    from each of the lists being iterated over.'
  prefs: []
  type: TYPE_NORMAL
- en: leq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `leq` list equality testing function will correctly return `$(true)` for
    lists that are identical other than having different whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: For example, `leq` considers `1 2 3` and `1 2 3` to be the same list.
  prefs: []
  type: TYPE_NORMAL
- en: lne
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`lne` is the opposite of `leq`: it returns `$(true)` when two lists are not
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To `reverse` a list can be useful (particularly because it can then be fed into
    `$(foreach)` and iterated backward).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: uniq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The built-in `$(sort)` function will deduplicate a list, but it does so at
    the same time as sorting it. The GMSL `uniq` function deduplicates a list while
    preserving the order in which elements are first found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: For example, `$(call uniq,a c b a c b)` will return `a c b`.
  prefs: []
  type: TYPE_NORMAL
- en: length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out the number of elements in a list, call `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `length` function is the same as the GNU `make $(words)` function.
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A string is a sequence of any characters, including whitespace. The string
    equality (and string inequality) function `seq` works even with strings that contain
    whitespace or consist only of whitespace. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This outputs `T` five times, indicating that each call to `seq` or `sne` returned
    `$(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: As with the list manipulation functions, I’ll cover a few of the more complicated
    functions in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting CSV Data into a GNU make List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `split` function to turn a value in CSV format into a GNU `make`
    list. For example, splitting on a comma turns a CSV line into a list from which
    individual items can be extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the variable `comma` is defined to contain a comma character so it
    can be used in the `$(call)` to the `split` function. This trick was discussed
    in [Chapter 1](ch01.html "Chapter 1. The Basics Revisited").
  prefs: []
  type: TYPE_NORMAL
- en: Making a PATH from a List of Directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `merge` function does the opposite of `split`: it makes a string from a
    list by separating the list items by some character. For example, to turn a list
    of directories into a form suitable for the `PATH` (which is usually separated
    by colons), define `list-to-path` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This outputs `/usr/bin:/usr/sbin:/usr/local/bin:/home/me/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: Translating Characters Using tr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most complicated string function is `tr`, which operates like the tr shell
    program. It transforms each character from a collection of characters into a corresponding
    character in a second list. The GMSL defines some common character classes for
    use with `tr`. For example, it defines variables called `[A-Z]` and `[a-z]` (yes,
    those are really the names) that contain the uppercase and lowercase characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `tr` to make a function that translates to leet-speak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This outputs `1 4M 4N 31173 GNU M4K3 H4X0R`.
  prefs: []
  type: TYPE_NORMAL
- en: seq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The slightly confusingly named `seq` function tests whether two strings are
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: sne
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The opposite, string inequality, is tested with `sne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: streln
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `length` function gets the length of a list; the equivalent for strings
    is `strlen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: substr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s possible to extract a substring using the `substr` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note that in GMSL, strings start from position 1, not 0.
  prefs: []
  type: TYPE_NORMAL
- en: split
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To split a string into a list, you use the `split` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the string contains spaces, the result may not be as expected.
    GNU `make`’s use of spaces as the list delimiter makes working with spaces and
    lists together very difficult. See [Chapter 4](ch04.html "Chapter 4. Pitfalls
    and Problems") for more on GNU `make`’s handling of spaces.
  prefs: []
  type: TYPE_NORMAL
- en: merge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`merge` is the opposite of `split`. It takes a list and outputs a string with
    a character between each list element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: tr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You use the `tr` function to translate individual characters, and it’s a building
    block for creating the `uc` and `lc` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: uc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`uc` performs simple uppercasing of the alphabet a-z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: lc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we have `lc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This performs simple lowercasing of the alphabet A-Z.
  prefs: []
  type: TYPE_NORMAL
- en: Set Manipulation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are represented by sorted, deduplicated lists. To create a set from a list,
    use `set_create` or start with the `empty_set` and `set_insert` individual elements.
    The empty set is defined by the variable `empty_set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a makefile could keep track of all the directories that it made
    using the marker technique discussed in [Making Directories](ch04.html#making_directories
    "Making Directories"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Updating the `make_dir` function (which creates rules to make directories) with
    a call to `set_insert` means that the variable `MADE_DIRS` will keep track of
    the set of directories created.
  prefs: []
  type: TYPE_NORMAL
- en: In a real makefile, many directories would likely be built, and using a set
    would be an easy way to discover which had been built at any point.
  prefs: []
  type: TYPE_NORMAL
- en: Note that because a set is implemented as a GNU `make` list, you can’t insert
    an item that contains a space.
  prefs: []
  type: TYPE_NORMAL
- en: set_create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You create a set by using the `set_create` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It takes a list of elements and adds them to a set. The set itself is returned.
    Note that set elements may not contain spaces.
  prefs: []
  type: TYPE_NORMAL
- en: set_insert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a set has been created using `set_create`, you can add an element to it
    using `set_insert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: set_remove
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove an element from a set, call `set_remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: It is not an error to remove an element from a set when that element was not
    present.
  prefs: []
  type: TYPE_NORMAL
- en: set_is_member
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test whether an element is a member of a set, call `set_is_member`. It returns
    a Boolean value indicating whether the element was present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: set_union
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You merge two sets together by calling the `set_union` function on the two
    sets. The merged set is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: set_intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine the elements common to two sets, use `set_intersection`. It returns
    the set of elements that were present in both sets passed in as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: set_is_subset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is sometimes useful to know if one set is a subset of another, which you
    can test by calling `set_is_subset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '`set_is_subset` returns a Boolean value indicating whether the first set is
    a subset of the second.'
  prefs: []
  type: TYPE_NORMAL
- en: set_equal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine if two sets are equal, call `set_equal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`set_equal` returns `$(true)` if the two sets have exactly the same elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Associative Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *associative array* maps a key value (a string with no spaces in it) to a
    single value (any string). Associative arrays are sometimes referred to as maps
    or even hash tables (although that’s an implementation detail, and the GMSL associative
    arrays do not use hashing).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use associative arrays as *lookup tables*. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This small makefile gets a list of all the `.c` files in the current directory
    and their sizes, and then it makes an associative array mapping from a filename
    to its size.
  prefs: []
  type: TYPE_NORMAL
- en: The `get-size` function uses `wc` to get the number of bytes in a file. The
    `C_FILES` variable contains all the `.c` files in the current directory. The `$(foreach)`
    uses the GMSL `set` function to set a mapping in an associative array called `c_files`
    between each `.c` file and its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a list of all the `.c` files found; it’s printed using the
    `keys` function to get all the keys in the associative array. The second line
    comes from looking up the length of `foo.c` using `get`.
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GMSL keeps internal track of named associative arrays, but it is not necessary
    to explicitly create them. Simply call `set` to add elements to the array, and
    the array will be created if it does not exist. Note that array keys cannot contain
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: get
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To retrieve an item from an associate array, call `get`. If the key is not present,
    `get` will return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `keys` function returns a list of all the keys present in an associative
    array. You can use this with `$(foreach)` to iterate an associative array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: defined
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test whether a key is present in an associated array, call `defined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '`defined` returns a Boolean indicating whether the key was defined or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Named Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *stack* is an ordered list of strings (with no spaces in them). In GMSL,
    stacks are stored internally, and they have names, like associative arrays do.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This small makefile uses a stack to follow a tree of directories.
  prefs: []
  type: TYPE_NORMAL
- en: traverse-tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `traverse-tree` function finds all the subdirectories of its argument (stored
    in `$1`) using the `$(wildcard)` function to find the `.` file that is always
    present in a directory. It uses the `$(patsubst)` function to strip off the trailing
    `/.` from each value returned by `$(wildcard)` to get the full directory name.
  prefs: []
  type: TYPE_NORMAL
- en: Before it traverses down into that directory, it pushes the directory found
    onto a stack called `dirs`.
  prefs: []
  type: TYPE_NORMAL
- en: dump-tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dump-tree` function `pop`s items off the `dirs` tree until there are none
    left (until the `depth` becomes `0`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-1](ch06.html#directory_structure "Example 6-1. A directory structure")
    shows a directory structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1. A directory structure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If this directory structure exists under `sources`, the makefile will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'If it’s desirable to traverse the directory tree in a depth-first fashion,
    you can use the stack functions to define `dfs`, which searches a directory tree
    and builds the `dirs` stack containing the directories in depth-first order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The `dump-tree` function hasn’t changed (it just outputs everything in the stack
    by successive calls to `pop`). But the `dfs` function is new. It uses a working
    stack called `work` to keep track of directories to visit. It first pushes the
    starting directory onto the `work` stack and then calls the `__dfs` helper.
  prefs: []
  type: TYPE_NORMAL
- en: The real work is done by `__dfs`. It pushes the current directory onto the `dirs`
    stack, pushes all the children of that directory onto the `work` stack, and then
    it recurses. Recursion stops when the `work` stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the directory structure in [Example 6-1](ch06.html#directory_structure
    "Example 6-1. A directory structure") is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: push
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Anyone who has used a stack will be familiar with pushing and popping elements.
    The GMSL stack functions are very similar. To add an element to the top of the
    stack, call `push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: pop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve the top element, call `pop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: peek
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `peek` function operates like `pop` but doesn’t remove the top stack element;
    it just returns its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: depth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, you can call `depth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '`depth` determines how many elements are present on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Function Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To reduce the number of calls to slow functions, such as `$(shell)`, a single
    memoization function is provided. For example, suppose a makefile needs to know
    the MD5 values of various files and defines a function `md5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a pretty expensive function to call (because of the time `md5sum` would
    take to execute), so it would be desirable to call it only once for each file.
    A memoized version of the `md5` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'It will call the `md5sum` function just once for each inputted filename and
    record the returned value internally so that a subsequent call to `md5once` with
    the same filename returns the MD5 value without having to run `md5sum`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This prints out the MD5 value of `/etc/passwd` twice but executes `md5sum` only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual `memoize` function is defined using the GMSL associative array functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous and Debugging Facilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-1](ch06.html#gmsl_constants "Table 6-1. GMSL Constants") shows constants
    that GMSL defines.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1. GMSL Constants
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Value | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| true | T | The Boolean value true |'
  prefs: []
  type: TYPE_TB
- en: '| false | (an empty string) | The Boolean value false |'
  prefs: []
  type: TYPE_TB
- en: '| gmsl_version | 1 1 7 | Current GMSL version number (major minor revision)
    |'
  prefs: []
  type: TYPE_TB
- en: You access these constants as normal GNU `make` variables by wrapping them in
    `$()` or `${}`.
  prefs: []
  type: TYPE_NORMAL
- en: gmsl_compatible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You know the `gmsl_compatible` function from [Checking the GMSL Version](ch06.html#checking_the_gmsl_version
    "Checking the GMSL Version"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 1](ch01.html "Chapter 1. The Basics Revisited"), you saw a recipe
    for outputting variable values using a pattern rule with target `print-%`. Because
    this is such a useful rule, GMSL defines its own `gmsl-print-%` target that you
    can use to print the value of any variable defined in a makefile that includes
    GMSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: gmsl-print-%
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gmsl-print-%` can be used to print any makefile variable, including variables
    inside GMSL. For example, `make gmsl-print-gmsl_version` would print the current
    GMSL version.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: assert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As discussed in [Makefile Assertions](ch02.html#makefile_assertions "Makefile
    Assertions"), it can be useful to have assertions in a makefile. GMSL provides
    two assertion functions: `assert` and `assert_exists`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: assert_exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To assert that an individual file or directory exists, GMSL provides the `assert_exists`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-2](ch06.html#gmsl_environment_variables "Table 6-2. GMSL Environment
    Variables") shows GMSL environment variables (or command line overrides), which
    control various bits of functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2. GMSL Environment Variables
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GMSL_NO_WARNINGS | If set, prevents GMSL from outputting warning messages.
    For example, arithmetic functions can generate underflow warnings. |'
  prefs: []
  type: TYPE_TB
- en: '| GMSL_NO_ERRORS | If set, prevents GMSL from generating fatal errors: division
    by zero or failed assertions are fatal. |'
  prefs: []
  type: TYPE_TB
- en: '| GMSL_TRACE | Enables function tracing. Calls to GMSL functions will result
    in name and arguments being traced. See [Tracing Variable Values](ch02.html#tracing_variable_values
    "Tracing Variable Values") for a discussion of makefile tracing. |'
  prefs: []
  type: TYPE_TB
- en: These environment variables can all be set in the environment or on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this makefile contains an assertion that will always fail, stopping
    the `make` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `GMSL_NO_ERRORS` prevents the assertion from stopping the `make` process.
    In that case the output of the `assert` is hidden and `make` continues normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: A few well-placed GMSL assertions in a makefile can make a big difference. By
    checking for makefile prerequisites (such as the presence of a specific file or
    that a compiler has a certain version number), a conscientious makefile writer
    can alert a user to a problem without forcing them to debug the often arcane output
    from `make`.
  prefs: []
  type: TYPE_NORMAL
