<html><head></head><body>
<h2 class="h2" id="ch05"><a id="page_61"/><strong><span class="big">5</span></strong><br/><strong>DEBUGGING WITH LLDB AND FRIENDS</strong></h2>
<p class="noindent">Debugging iOS applications is considered one of Xcode’s strong components. In addition to the useful analysis features of DTrace, Xcode has a command line debugger with a relatively approachable graphical interface. As part of Apple’s migration away from GNU utilities, the default debugger is now lldb,<sup><a href="footnote.html#fn34" id="fn_34">1</a></sup> which provides first-class support for Objective-C. Multithreaded debugging is well-supported, and you can even inspect objects from the debugger. The only downside is that you’ll have to translate your hard-won knowledge of gdb to a new environment.</p>
<p class="indent">Debugging is a vast topic, and there are multiple books on the subject.<sup><a href="footnote.html#fn35" id="fn_35">2</a></sup> This chapter covers the basics for people new to Xcode, along with tips relevant to security testing and secure development. I assume you have some familiarity with gdb and debuggers in general.</p>
<h3 class="h3" id="ch05lev1sec01"><a id="page_62"/><strong>Useful Features in lldb</strong></h3>
<p class="noindent">Xcode’s built-in debugger interface is fairly powerful. It has a command line, but you can also use the GUI to view and interact with the current thread state, annotated assembly, and object details. The GUI includes a central breakpoint browser as well, where you can view, enable, and disable breakpoints.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you’re extremely comfortable using gdb, the LLVM project has a mapping of frequently used gdb commands to their lldb equivalents; see</em> <a href="http://lldb.llvm.org/lldb-gdb.html">http://lldb.llvm.org/lldb-gdb.html</a>.</p>
</div>
<h4 class="h4" id="ch05lev2sec01"><em><strong>Working with Breakpoints</strong></em></h4>
<p class="noindent">You can set breakpoints graphically from Xcode’s lldb interface (see <a href="ch05.html#ch5fig1">Figure 5-1</a>), or you can do so from the command line. In addition to breaking when the program accesses a particular memory address or C function, you can also break on specific Objective-C methods.</p>
<div class="image"><img alt="image" src="graphics/f05-01.jpg"/></div>
<p class="figcap"><a id="ch5fig1"/><em>Figure 5-1: Xcode’s lldb interface</em></p>
<p class="indent">Here are some of the ways you can set breakpoints:</p>
<p class="programs"><span class="ent">➊</span> (lldb) breakpoint set --name myfunction --name myotherfunction<br/><span class="ent">➋</span> (lldb) breakpoint set --name "-[myClass methodCall:]"<br/><span class="ent">➌</span> (lldb) breakpoint set --selector myObjCSelector:<br/><span class="ent">➍</span> (lldb) breakpoint set --method myCPlusPlusMethod</p>
<p class="indent">The command at <span class="ent">➊</span> sets one breakpoint on multiple functions, a feature you can use to enable and disable groups of functions simultaneously. As shown at <span class="ent">➋</span>, you can also break on specific Objective-C instance and class methods—these can be also be grouped in a manner similar to <a id="page_63"/>the C function calls at <span class="ent">➊</span>. If you want to break on all calls to a particular selector/method, use the <span class="literal">--selector</span> option <span class="ent">➌</span>, which will break on any calls to a selector of this name, regardless of what class they’re implemented in. Finally, to break on specific C++ methods, simply specify <span class="literal">--method</span> instead of <span class="literal">--name</span> when defining the breakpoint, as at <span class="ent">➍</span>.</p>
<p class="indent">In practice, setting a breakpoint in lldb looks like this:</p>
<p class="programs">(lldb) breakpoint set --name main<br/>Breakpoint 2: where = StatePreservator`main + 34 at main.m:15, address = 0x00002822<br/><br/>(lldb) breakpoint set -S encodeRestorableStateWithCoder:<br/>Breakpoint 2: where = StatePreservator`-[StatePreservatorSecondViewController<br/>    encodeRestorableStateWithCoder:] + 44 at StatePreservatorSecondViewController.<br/>    m:25, address = 0x00002d5c</p>
<p class="indent">After you set a breakpoint, lldb shows the code you’re breaking on. If you like, you can make this even simpler: like gdb, lldb recognizes keywords using the shortest matching text. So <span class="literal"><em>breakpoint</em></span> can be shortened to <span class="literal"><em>break</em></span>, or even <span class="literal"><em>b</em></span>.</p>
<p class="indent">In the GUI, you can break on a particular line of code by clicking the number in the gutter to the left of the line (see <a href="ch05.html#ch5fig2">Figure 5-2</a>). Clicking again will disable the breakpoint. Alternatively, you can break on lines from the lldb CLI using the <span class="literal">--file <em>filename.m</em> --line <em>66</em></span> syntax.</p>
<div class="image"><img alt="image" src="graphics/f05-02.jpg"/></div>
<p class="figcap"><a id="ch5fig2"/><em>Figure 5-2: Setting breakpoints on specific lines with the mouse. Deactivated breakpoints are shaded a lighter gray.</em></p>
<p class="indent">When you want to create multiple breakpoints, it can be handy to use the <span class="literal">-r</span> flag at the command line to break on functions matching a particular regular expression, like so:</p>
<p class="programs">(lldb) break set -r tableView<br/>Breakpoint 1: 4 locations.<br/>(lldb) break list<br/>Current breakpoints:<br/>1: source regex = "tableView", locations = 4, resolved = 4<br/>  1.1: where = DocInteraction`-[DITableViewController tableView:<br/>     cellForRowAtIndexPath:] + 695 at DITableViewController.m:225, address = 0<br/>     x000032c7, resolved, hit count = 0<br/>  1.2: where = DocInteraction`-[DITableViewController tableView:<br/>     cellForRowAtIndexPath:] + 1202 at DITableViewController.m:245, address = 0<br/>     x000034c2, resolved, hit count = 0<br/>  1.3: where = DocInteraction`-[DITableViewController tableView:<br/>     cellForRowAtIndexPath:] + 1270 at DITableViewController.m:246, address = 0<br/>     x00003506, resolved, hit count = 0<br/>  1.4: where = DocInteraction`-[DITableViewController tableView:<br/>     cellForRowAtIndexPath:] + 1322 at DITableViewController.m:247, address = 0<br/>     x0000353a, resolved, hit count = 0</p>
<p class="indent"><a id="page_64"/>This will set a single breakpoint with a number of <em>locations</em>. Each location can be enabled and disabled, as shown here:</p>
<p class="programs">(lldb) break dis 1.4<br/>1 breakpoints disabled.<br/>(lldb) break list<br/>Current breakpoints:<br/>1: source regex = ".*imageView.*", locations = 4, resolved = 3<br/>    --<span class="codeitalic">snip</span>--<br/>  1.4: where = DocInteraction`-[DITableViewController tableView:<br/>     cellForRowAtIndexPath:] + 1322 at DITableViewController.m:247, address = 0<br/>     x0000353a, unresolved, hit count = 0 Options: disabled<br/>(lldb) break en 1.4<br/>1 breakpoints disabled.</p>
<p class="indent">Notice that enabling and disabling locations works just like a regular breakpoint; just use <span class="literal">break disable</span> and <span class="literal">break enable</span> and reference the right numeric identifier.</p>
<h4 class="h4" id="ch05lev2sec02"><em><strong>Navigating Frames and Variables</strong></em></h4>
<p class="noindent">Once you’ve arrived at a breakpoint, you can use lldb to examine the state of your program. You can do this via either the command line, as in the other lldb examples I’ve shown, or the visual lldb browser, as in <a href="ch05.html#ch5fig3">Figure 5-3</a>.</p>
<div class="image"><img alt="image" src="graphics/f05-03.jpg"/></div>
<p class="figcap"><a id="ch5fig3"/><em>Figure 5-3: Examining frame variables from the command line and the GUI</em></p>
<p class="indent"><a id="page_65"/>In addition to viewing and manipulating the variables of the current frame, you can navigate the program threads and frames of the call stack using the Debug Navigator, as shown in <a href="ch05.html#ch5fig4">Figure 5-4</a>.</p>
<div class="image"><img alt="image" src="graphics/f05-04.jpg"/></div>
<p class="figcap"><a id="ch5fig4"/><em>Figure 5-4: Using the Debug Navigator to switch frames and threads</em></p>
<p class="indent">Similar to using gdb, you can inspect the call stack of the current thread with the <span class="literal">bt</span> (short for <em>backtrace</em>) command (see <a href="ch05.html#ch5ex1">Listing 5-1</a>). Normally, you could also navigate frames using the typical <span class="literal">up</span>, <span class="literal">down</span>, and <span class="literal">frame select</span> commands. In some versions of Xcode however, a bug causes the frame to immediately revert to the frame selected in the Debug Navigator. In that case, you must switch frames manually within the Debug Navigator to inspect them individually.</p>
<p class="programs">(lldb) bt<br/>* thread #1: tid = 0x11804c, 0x00002c07 StatePreservator`-[<br/>     StatePreservatorSecondViewController encodeRestorableStateWithCoder:](self=0<br/>     x07733c30, _cmd=0x005af437, coder=0x0756faf0) + 55 at<br/>     StatePreservatorSecondViewController.m:25, queue = 'com.apple.main-thread,<br/>     stop reason = breakpoint 1.1<br/>    frame #0: 0x00002c07 StatePreservator`-[StatePreservatorSecondViewController<br/>     encodeRestorableStateWithCoder:](self=0x07733c30, _cmd=0x005af437, coder=0<br/>     x0756faf0) + 55 at StatePreservatorSecondViewController.m:25<br/>    frame #1: 0x000277e7 UIKit`-[UIApplication(StateRestoration)<br/>     _saveApplicationPreservationState:] + 1955<br/>    frame #2: 0x00027017 UIKit`-[UIApplication(StateRestoration)<br/>     _saveApplicationPreservationStateIfSupported] + 434<br/>    frame #3: 0x0001b07b UIKit`-[UIApplication _handleApplicationSuspend:eventInfo<br/>     :] + 947<br/>    frame #4: 0x00023e74 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1469<br/>    frame #5: 0x00024beb UIKit`-[UIApplication sendEvent:] + 85<br/>    frame #6: 0x00016698 UIKit`_UIApplicationHandleEvent + 9874<br/>    frame #7: 0x01beddf9 GraphicsServices`_PurpleEventCallback + 339<br/>    frame #8: 0x01bedad0 GraphicsServices`PurpleEventCallback + 46<br/>    frame #9: 0x01c07bf5 CoreFoundation`<br/>     __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 53<br/>    frame #10: 0x01c07962 CoreFoundation`__CFRunLoopDoSource1 + 146<br/>    frame #11: 0x01c38bb6 CoreFoundation`__CFRunLoopRun + 2118<br/>    frame #12: 0x01c37f44 CoreFoundation`CFRunLoopRunSpecific + 276<br/>    frame #13: 0x01c37e1b CoreFoundation`CFRunLoopRunInMode + 123<br/>    frame #14: 0x01bec7e3 GraphicsServices`GSEventRunModal + 88<br/>    frame #15: 0x01bec668 GraphicsServices`GSEventRun + 104<br/>    frame #16: 0x00013ffc UIKit`UIApplicationMain + 1211<br/>    frame #17: 0x0000267d StatePreservator`main(argc=1, argv=0xbffff13c) + 141 at<br/>     main.m:16</p>
<p class="listcap"><a id="ch5ex1"/><em>Listing 5-1: Getting the current call stack with the backtrace command</em></p>
<p class="indent"><a id="page_66"/>To examine the variables of the current frame, you can use the <span class="literal">frame variable</span> command, as shown in Listing <strong>??</strong>.</p>
<p class="programs">(lldb) frame variable<br/>(StatePreservatorSecondViewController *const) self = 0x0752d2e0<br/>(SEL) _cmd = "encodeRestorableStateWithCoder:"<br/>(NSCoder *) coder = 0x0d0234e0</p>
<p class="listcap"><a id="ch5ex2"/><em>Listing 5-2: Using the</em> <span class="literal">frame variable</span> <em>command</em></p>
<p class="indent">This will give you variable names and arguments of the local stack frame, along with their types and memory addresses. You can also use the context menu in the graphical debugger to print or edit variable contents; see <a href="ch05.html#ch5fig5">Figure 5-5</a>.</p>
<p class="indent">If you use <span class="literal">frame select</span> on its own, you can also see the program’s location in the call stack, along with the relevant surrounding lines of code, as in this example:</p>
<p class="programs">(lldb) frame select<br/>frame <span class="brown">#0: 0x00002d5c StatePreservator`-[StatePreservatorSecondViewController</span><br/>     <span class="brown">encodeRestorableStateWithCoder:](self=0x0752d2e0, _cmd=0x005af437, coder=0</span><br/>     <span class="brown">x0d0234e0) + 44 at StatePreservatorSecondViewController.m:25</span><br/>   22<br/>   23   -(<span class="rose">void</span>)<span class="violet">encodeRestorableStateWithCoder</span>:(<span class="violet1">NSCoder</span> *)coder<br/>   24   {<br/>-&gt; 25       [coder <span class="violet">encodeObject</span>:[_myTextView text] forKey:<span class="red">@"UnsavedText"</span>];<br/>   26       [<span class="rose">super</span> <span class="violet">encodeRestorableStateWithCoder</span>:coder];<br/>   27   }<br/>   28</p>
<div class="image"><a id="page_67"/><img alt="image" src="graphics/f05-05.jpg"/></div>
<p class="figcap"><a id="ch5fig5"/><em>Figure 5-5: The variable context menu, showing options for printing variable contents, setting watchpoints, and viewing memory contents</em></p>
<p class="indent">The <span class="literal">frame select</span> command also takes a numeric argument for the stack frame you want to inspect, if you’d like to look further up the call stack (see <a href="ch05.html#ch5ex3">Listing 5-3</a>).</p>
<p class="programs">(lldb) frame select 4<br/>frame <span class="brown">#4: 0x00023e74 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1469</span><br/><span class="violet1">UIKit`-[UIApplication handleEvent:withNewEvent:] + 1469:</span><br/><span class="violet1">-&gt; 0x23e74:  xorb   %cl, %cl</span><br/>   <span class="violet1">0x23e76:  jmp    0x24808</span><br/>                         <span class="violet1">; -[UIApplication handleEvent:withNewEvent:] + 3921</span><br/>   <span class="violet1">0x23e7b:  movl   16(%ebp), %ebx</span><br/>   <span class="violet1">0x23e7e:  movl   %ebx, (%esp)</span></p>
<p class="listcap"><a id="ch5ex3"/><em>Listing 5-3: Assembly shown while examining a stack frame</em></p>
<p class="indent">Note that for code outside of your current project, such as other parts of the Cocoa API, the source will usually not be available; lldb will instead show you the relevant assembly instructions.<sup><a href="footnote.html#fn36" id="fn_36">3</a></sup></p>
<p class="indent">You can also inspect the values of objects using lldb’s <span class="literal">po</span> (short for <em>print object</em>) command. For example, consider the following:</p>
<p class="programs">(lldb) po [<span class="rose">self</span> window]<br/>$2 = 0x071848d0 &lt;<span class="violet1">UIWindow: 0x71848d0; frame = (0 0; 320 480); hidden = YES; layer =</span><br/>      <span class="violet1">&lt;UIWindowLayer: 0x71849a0&gt;&gt;</span></p>
<p class="indent"><a id="page_68"/>Using <span class="literal">po</span> on your main window fetches the addresses and attributes of that window.</p>
<h4 class="h4" id="ch05lev2sec03"><em><strong>Visually Inspecting Objects</strong></em></h4>
<p class="noindent">If you’re using Xcode 5 or later, you can also hover the mouse over objects to inspect the contents, as shown in <a href="ch05.html#ch5fig6">Figure 5-6</a>. If you drill down into individual subobjects, you can either view their memory directly (<a href="ch05.html#ch5fig7">Figure 5-7</a>) by clicking the <strong>i</strong> button or use the Quick Look “eye” button to see the contents of the object represented as a fully rendered image, text, or any other data type that OS X’s Quick Look API understands (see <a href="ch05.html#ch5fig8">Figure 5-8</a>). This is, in my opinion, pretty badass.</p>
<div class="image"><img alt="image" src="graphics/f05-06.jpg"/></div>
<p class="figcap"><a id="ch5fig6"/><em>Figure 5-6: Inspecting an object while at a breakpoint</em></p>
<div class="image"><img alt="image" src="graphics/f05-07.jpg"/></div>
<p class="figcap"><a id="ch5fig7"/><em>Figure 5-7: Inspecting an object’s contents in memory</em></p>
<div class="image"><img alt="image" src="graphics/f05-08.jpg"/></div>
<p class="figcap"><a id="ch5fig8"/><em>Figure 5-8: Examining the current state of a variable with the Quick Look button. In this case, you’re looking at the</em> <span class="literal">_statusBar</span> <em>of the UIApplication delegate window, which Xcode will display as an actual image.</em></p>
<h4 class="h4" id="ch05lev2sec04"><a id="page_69"/><em><strong>Manipulating Variables and Properties</strong></em></h4>
<p class="noindent">You can do more than just view the contents of variables and objects from lldb. For example, let’s try breaking on the same line used to test the <span class="literal">frame variable</span> command back in <a href="ch05.html#ch5ex2">Listing 5-2</a>.</p>
<p class="programs">[coder <span class="violet">encodeObject</span>:[_myTextView text] forKey:<span class="red">@"UnsavedText"</span>];</p>
<p class="indent">When the debugger reaches this line, imagine you want to examine the contents of UITextView’s <em>text</em> attribute and change its value before the program continues. You can do this with the <span class="literal">expr</span> command, using traditional Objective-C syntax, as follows:</p>
<p class="programs">(lldb) po [_myTextView text]<br/>$0 = 0x08154cb0 Foo<br/>(lldb) expr (<span class="rose">void</span>)[_myTextView setText:<span class="red">@"Bar"</span>]<br/>(lldb) po [_myTextView text]<br/>$1 = 0x0806b2e0 Bar<br/>(lldb) cont</p>
<p class="indent">When execution resumes, the value of that text box in the UI should have changed. Because lldb doesn’t know the return type of a method called in this way, you have to specify the type using <span class="literal">(void)</span> with the <span class="literal">expr</span> command. Similarly, if you were calling something that returned an <span class="literal">int</span>, you’d need to explicitly cast to that type instead. For simple assignment operations, like <span class="literal">myInteger = 666</span> or similar, as opposed to method calls, simply enter <span class="literal">expr</span> and the assignment as one command.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>When using lldb from the command line in Xcode, the GUI will autocomplete object method names, giving you a brief description and their return type. See <a href="ch05.html#ch5fig9">Figure 5-9</a> for an example.</em></p>
</div>
<div class="image"><img alt="image" src="graphics/f05-09.jpg"/></div>
<p class="figcap"><a id="ch5fig9"/><em>Figure 5-9: Nifty lldb method name completion in Xcode</em></p>
<p class="indent"><a id="page_70"/>Keep in mind that you’re not limited to manipulating objects that are declared in your code. You can also manipulate framework classes.</p>
<p class="programs">(lldb) expr (<span class="rose">void</span>)[[<span class="violet1">UIPasteboard</span> <span class="violet">generalPasteboard</span><span class="violet1">] setString:</span><span class="red">@"my string"</span><span class="violet1">]</span><br/><span class="violet1">(lldb) po [[UIPasteboard</span> <span class="violet">generalPasteboard</span><span class="violet1">] string]</span><br/><span class="violet1">$5 = 0x071c6e50 my string</span></p>
<p class="indent">For this kind of interactive manipulation and interrogation, I often find it useful to set a breakpoint on <span class="literal">didReceiveMemoryWarning</span> in the application delegate because this method will be present in every application. When I want to inspect the program’s state while running it in the iOS Simulator, I select Hardware → Simulate Memory Warning. Once I’ve done my twiddling, I simply continue the application with <span class="literal">cont</span>. You can also do this from the Xcode UI with the Pause Execution button.</p>
<h4 class="h4" id="ch05lev2sec05"><em><strong>Breakpoint Actions</strong></em></h4>
<p class="noindent"><em>Breakpoint actions</em> are not well-documented but are quite useful. They allow you to create breakpoints that trigger only under certain conditions, and they can perform complex actions when these breakpoints are hit. You can set them up to automatically resume execution after performing these actions or even have them trigger only after a line is hit a certain number of times. Logging and using speech synthesis to present program information are the simplest actions you can set for a breakpoint, but you can also interrogate objects, read and manipulate variables, and so forth. Basically, breakpoint actions can do anything you can do from the lldb command line, plus a few other niceties.</p>
<p class="indent">Let’s walk through creating a breakpoint action one step at a time.</p>
<ol>
<li><p class="noindent">Create a breakpoint by clicking in the breakpoint gutter.</p></li>
<li><p class="noindent"><small>CTRL</small>-click the breakpoint and select <strong>Edit Breakpoint</strong>.</p></li>
<li><p class="noindent">Click <strong>Add Action</strong>.</p></li>
<li><p class="noindent">Check the <strong>Automatically continue after evaluating</strong> box.</p></li>
<li><p class="noindent">For the simplest type of breakpoint action, simply select the <strong>Log message</strong> action. Here, you can print simple messages, along with the breakpoint name and hit count (see <a href="ch05.html#ch5fig10">Figure 5-10</a>). You can ignore the expression option because it’s not terribly straightforward to use.</p></li>
<li><p class="noindent">After adding a simple log message, you can click the <strong>+</strong> button to add another action. This time, select <strong>Debugger Command</strong>.</p></li>
<li><p class="noindent">Here, you can enter basic lldb expressions—most commonly, using the <span class="literal">po</span> command to print the description of an object. See <a href="ch05.html#ch5fig11">Figure 5-11</a> for an example.</p>
<div class="image"><a id="page_71"/><img alt="image" src="graphics/f05-10.jpg"/></div>
<p class="figcap"><a id="ch5fig10"/><em>Figure 5-10: Using a breakpoint action to do a simple log entry. In this example, you’ll log a message, along with the number of times the breakpoint has been hit, using the</em> <span class="literal">%H</span> <em>placeholder.</em></p>
<div class="image"><img alt="image" src="graphics/f05-11.jpg"/></div>
<p class="figcap"><a id="ch5fig11"/><em>Figure 5-11: In addition to simply logging, you can execute an arbitrary lldb command. In this case, you’ll use the</em> <span class="literal">po</span> <em>command to print the description of the object returned by the</em> <span class="literal">path</span> <em>method.</em></p></li>
<li><p class="noindent"><a id="page_72"/>Optionally, add a breakpoint condition to specify when the actions you’ve defined are executed (<a href="ch05.html#ch5fig12">Figure 5-12</a>).</p>
<div class="image"><img alt="image" src="graphics/f05-12.jpg"/></div>
<p class="figcap"><a id="ch5fig12"/><em>Figure 5-12: Two actions and a breakpoint condition. For the condition, you’ll ensure that the length of the path is not zero before executing the breakpoint action, specifying the return value</em> <span class="literal">(BOOL)</span>.</p></li>
</ol>
<p class="indent">Try following these steps until you feel comfortable using breakpoint actions, and then move on to the next section for some specific ways to apply lldb in a security context.</p>
<h3 class="h3" id="ch05lev1sec02"><strong>Using lldb for Security Analysis</strong></h3>
<p class="noindent">These are all useful tricks, but how do you put them together to find new security issues or test security assertions? Let’s take a look at a couple scenarios where using the debugger can help you nail down more concrete issues.</p>
<h4 class="h4" id="ch05lev2sec06"><em><strong>Fault Injection</strong></em></h4>
<p class="noindent">Say you have an application that uses a custom binary network protocol to marshal data between the client and a remote server. This can make it difficult to intercept and modify data with an off-the-shelf proxy, but you’d like to determine whether malformed data in certain parameters could cause a program to crash. You can also manipulate data to make future testing easier.</p>
<p class="indent">Since you can change data, you might want to replace, for example, a randomly generated key with one of your choosing. You can do that from <a id="page_73"/>within the debugger, as shown in <a href="ch05.html#ch5ex4">Listing 5-4</a>. This results in data being encrypted with a known key of your choosing, rather than a potentially unprintable blob. The following example modifies the app’s crypto key before it gets saved to the Keychain so that further communication uses a different key:</p>
<p class="programs"><span class="ent">➊</span> (lldb) frame var<br/>   (Class) <span class="rose">self</span> = SimpleKeychainWrapper<br/>   (SEL) _cmd = <span class="red">"addToKeychain:forService:"</span><br/>   (<span class="violet1">NSString</span> *) identifier = 0x00005be4 <span class="red">@"com.isecpartners.CryptoKey"</span><br/>   (<span class="violet1">NSString</span> *) service = 0x00005bf4 <span class="red">@"com.isecpartners.NSCoder+Crypto"</span><br/>   (<span class="violet1">NSMutableDictionary</span> *) dictionary = 0x08b292f0 6 key/value pairs<br/>   (<span class="violet1">NSMutableData</span> *) item = 0x08b2cee0<br/>   (OSStatus) status = 1<br/><span class="ent">➋</span> (lldb) po item<br/>   &lt;9aab766a 260bb165 57675f04 fdb982d3 d73365df 5fd4b05f 3c078f7b b6484b7d&gt;<br/><span class="ent">➌</span> (lldb) po dictionary<br/>   {<br/>       acct = &lt;636f6d2e 69736563 70617274 6e657273 2e437279 70746f4b 6579&gt;;<br/>       class = genp;<br/>       gena = &lt;636f6d2e 69736563 70617274 6e657273 2e437279 70746f4b 6579&gt;;<br/>       pdmn = aku;<br/>       svce = <span class="red">"com.isecpartners.NSCoder+Crypto"</span>;<br/>       <span class="red">"v_Data"</span> = &lt;9aab766a 260bb165 57675f04 fdb982d3 d73365df 5fd4b05f 3c078f7b<br/>       b6484b7d&gt;;<br/>   }<br/><span class="ent">➍</span> (lldb) expr (<span class="rose">void</span>)[dictionary <span class="violet">setObject</span>:<span class="red">@"mykey"</span> forKey:(__bridge <span class="rose">id</span>)kSecValueData<br/>       ];<br/><span class="ent">➎</span> (lldb) po dictionary<br/>   {<br/>      acct = &lt;636f6d2e 69736563 70617274 6e657273 2e437279 70746f4b 6579&gt;;<br/>      class = genp;<br/>      gena = &lt;636f6d2e 69736563 70617274 6e657273 2e437279 70746f4b 6579&gt;;<br/>      pdmn = aku;<br/>      svce = <span class="red">"com.isecpartners.NSCoder+Crypto"</span>;<br/>      <span class="red">"v_Data"</span> = mykey;<br/>   }</p>
<p class="listcap"><a id="ch5ex4"/><em>Listing 5-4: Inspecting and changing object values in memory</em></p>
<p class="indent">At <span class="ent">➊</span>, the code prints the variables of the current frame, noting the arguments sent to the <span class="literal">addToKeychain:forService:</span> selector. The key this example is interested in is stored in the <span class="literal">item</span> argument and added to a dictionary. Inspecting these (<span class="ent">➋</span> and <span class="ent">➌</span>) reveals the value of the key. The code then alters the Keychain dictionary using the <span class="literal">expr</span> command <span class="ent">➍</span>. At <span class="ent">➎</span>, the program verifies that the new <span class="literal">NSString</span> is now the current value of the key.</p>
<h4 class="h4" id="ch05lev2sec07"><a id="page_74"/><em><strong>Tracing Data</strong></em></h4>
<p class="noindent">If you have an application that encrypts data with a master password, it may be useful to examine that data before it gets encrypted. It may not always be immediately obvious that data will hit the encryption routine by default. Consider <a href="ch05.html#ch5ex5">Listing 5-5</a>:</p>
<p class="programs"><span class="ent">➊</span> (lldb) frame variable<br/>   (CCCryptHelper *<span class="rose">const) self</span> = 0x07534b40<br/><span class="ent">➋</span> (SEL) _cmd = <span class="red">"encrypt:"</span><br/><span class="ent">➌</span> (<span class="violet1">NSString</span> *) data = 0x0000c0ec <span class="red">@"PasswordManager"</span><br/>   (<span class="violet1">NSData</span> *) encData = 0x07534b40 0 byte<br/><br/>   (lldb) frame select<br/>   frame <span class="brown">#0: 0x00006790 PasswordManager `-[CCCryptHelper encrypt:](self=0x07534b40,</span><br/>   _cmd=0x00009b1e, data=0x0000c0ec) + 48 at CCCryptHelper.m:82<br/>   80 - (<span class="violet1">NSData</span> *)encrypt:(<span class="violet1">NSString</span> *)data {<br/>   -&gt; 81 <span class="violet1">NSData</span> *encData = [<span class="rose">self</span> AES128EncryptData:[data dataUsingEncoding: <span class="violet1">NS</span><br/>       <span class="violet1">UTF8StringEncoding]</span><br/>   <span class="violet1">82</span>                                      withKey:masterPassword];</p>
<p class="listcap"><a id="ch5ex5"/><em>Listing 5-5: Examining frame variables with lldb</em></p>
<p class="indent">If you break on the <span class="literal">encrypt:</span> selector <span class="ent">➋</span>, you can examine the local variables using the <span class="literal">frame variable</span> command <span class="ent">➊</span>. Notice that the output shows both <span class="literal">data</span> and <span class="literal">encData</span>. The former <span class="ent">➌</span> is the interesting bit in this example, because that’s the data that will be encrypted and returned by the routine. This tracing technique can also be used to examine and manipulate data to be sent over the wire, before it hits the encryption routines.</p>
<h4 class="h4" id="ch05lev2sec08"><em><strong>Examining Core Frameworks</strong></em></h4>
<p class="noindent">lldb is also useful for digging in to the weird quirks of Apple’s APIs—I recommend you use it when you’re confused by an API’s behavior. For instance, when looking into <span class="literal">NSURLCache</span>, I noticed the behavior in <a href="ch05.html#ch5ex6">Listing 5-6</a>:</p>
<p class="programs">   (lldb) expr (<span class="rose">int</span>)[[<span class="violet1">NSURLCache</span> <span class="violet">sharedURLCache</span>] currentMemoryUsage]<br/>   (<span class="rose">int</span>) $0 = 158445<br/><br/>   (lldb) expr (<span class="rose">int</span>)[[<span class="violet1">NSURLCache</span> <span class="violet">sharedURLCache</span>] currentDiskUsage]<br/>   (<span class="rose">int</span>) $1 = 98304<br/><br/><span class="ent">➊</span> (lldb) expr (<span class="rose">void</span>)[[<span class="violet1">NSURLCache</span> <span class="violet">sharedURLCache</span>] removeAllCachedResponses]<br/><br/>   (lldb) expr (<span class="rose">int</span>)[[<span class="violet1">NSURLCache</span> <span class="violet">sharedURLCache</span>] currentMemoryUsage]<br/>   (<span class="rose">int</span>) $3 = 0<br/><br/>   (lldb) expr (<span class="rose">int</span>)[[<span class="violet1">NSURLCache</span> <span class="violet">sharedURLCache</span>] currentDiskUsage]<br/><span class="ent">➋</span> (<span class="rose">int</span>) $4 = 98304</p>
<p class="listcap"><a id="ch5ex6"/><em>Listing 5-6: Some curious behavior of the</em> <span class="literal">NSURLCache</span> <em>API</em></p>
<p class="indent"><a id="page_75"/>Here, even though I called the <span class="literal">removeAllCachedResponses</span> method <span class="ent">➊</span>, the current disk usage is still 98304 bytes <span class="ent">➋</span>. Alas, it appears that clearing the cache is useless. Fear not—you’ll see some solutions to this problem in <a href="ch09.html#ch09">Chapter 9</a>. In the meantime, you may want to play around with some of the internals yourself. This can help you figure out some of the workings of the iOS platform and give you deeper insight into how your application is behaving.</p>
<h3 class="h3" id="ch05lev1sec03"><strong>Closing Thoughts</strong></h3>
<p class="noindent">All of these debugging and inspection techniques can be useful when trying to debug your own application or understand a new codebase quickly. However, you may not always have access to the source code of the product you’re working with. In these cases, you’ll want to know some basic black-box testing techniques, which I will cover in <a href="ch06.html#ch06">Chapter 6</a>.<a id="page_76"/></p>
</body></html>