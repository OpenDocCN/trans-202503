<html><head></head><body>
		<section>&#13;
			<header>&#13;
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_99" title="99"/>6</span><br/><span class="ChapterTitle">Numbers, Variables, and Arithmetic</span></h1>&#13;
			</header>&#13;
			<p class="ChapterIntro">In this chapter you will</p>&#13;
			<ul>&#13;
				<li>Generate random numbers</li>&#13;
				<li>Create electronic dice</li>&#13;
				<li>Learn about binary numbers</li>&#13;
				<li>Use shift-register integrated circuits (ICs) to get more digital output pins</li>&#13;
				<li>Test your knowledge of binary numbers with a quiz</li>&#13;
				<li>Learn about arrays of variables</li>&#13;
				<li>Display numbers on seven-segment LED modules</li>&#13;
				<li>Learn how to use the modulo math function</li>&#13;
				<li>Create a digital thermometer</li>&#13;
			</ul>&#13;
			<p>&#13;
				You will learn a wide variety of useful new functions that will create more project options, including random number generation, new kinds of math functions, and variable storage in ordered lists called <em>arrays</em>. Furthermore, you will learn how to use LED display modules in numeric form to display data and simple images. Finally, we’ll combine these tools to create a game, a digital thermometer, and more.</p>&#13;
			<h2 id="h1-500587c06-0001"><span epub:type="pagebreak" id="Page_100" title="100"/>Generating Random Numbers</h2>&#13;
			<p class="BodyFirst">A program’s ability to generate random numbers can be very useful in games and effects. For example, you can use random numbers to play a dice or lottery game, create lighting effects with LEDs, or create visual or auditory effects for a quiz game with the Arduino. Unfortunately, the Arduino can’t choose a purely random number by itself. You have to help it by providing a <em>seed</em>, an arbitrary starting number used in the calculations to generate a random number.</p>&#13;
			<h3 id="h2-500587c06-0001">Using Ambient Current to Generate a Random Number</h3>&#13;
			<p class="BodyFirst">The easiest way to generate a random number with the Arduino is to write a program that reads the voltage from a free (disconnected) analog pin (for example, analog pin 0) with this line in <code>void setup()</code>:</p>&#13;
			<pre><code>  randomSeed(analogRead(0));</code></pre>&#13;
			<p>&#13;
				Even when nothing is wired to an analog input on the Arduino, static electricity in the environment creates a tiny, measurable voltage. The amount of this voltage is quite random. We can use this measure of ambient voltage as our seed to generate a random number and then allocate it to an integer variable using the <code>random(</code><var>lower, upper</var><code>)</code> function. Furthermore, we can use the parameters <var>lower</var> and <var>upper</var> to set the lower and upper limits of the range for the random number. For example, to generate a random number between 100 and 1,000, you would use the following:</p>&#13;
			<pre><code>int a = 0;&#13;
a = random(100, 1001);</code></pre>&#13;
			<p>&#13;
				We’ve used the number 1,001 rather than 1,000 because the upper limit is <em>exclusive</em>, meaning it’s not included in the range.</p>&#13;
			<p>To generate a random number between 0 and some number, you can just enter the upper limit. Here’s how you would generate a random number between 0 and 6:</p>&#13;
			<pre><code>  a = random(7);</code></pre>&#13;
			<p>&#13;
				The example sketch in <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a> would generate a random number between 0 and 1,000 and another random number between 10 and 50.</p>&#13;
			<pre><code>// Listing 6-1&#13;
int r = 0;&#13;
void setup()&#13;
{ randomSeed(analogRead(0)); Serial.begin(9600);&#13;
}&#13;
void loop()<span epub:type="pagebreak" id="Page_101" title="101"/>{ Serial.print("Random number between zero and 1000 is: "); r = random(0, 1001); Serial.println(r); Serial.print("Random number between ten and fifty is: "); r = random(10, 51); Serial.println(r); delay(1000);&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: A random number generator</p>&#13;
			<p><a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> shows the result of <a href="#listing6-1">Listing 6-1</a> in the Serial Monitor.</p>&#13;
			<figure>&#13;
				<img alt="f06001" src="image_fi/500587c06/f06001.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-1">Figure 6-1</a>: Output from <a href="#listing6-1">Listing 6-1</a></p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Now that you know how to generate random numbers, let’s put that knowledge to good use by creating an electronic die.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0002"><span>Project #15: Creating an Electronic Die</span></h2>&#13;
			<p class="BodyFirst">Our goal is to light one of six LEDs randomly to mimic the throw of a die. We’ll choose a random number between 1 and 6, then turn on the corresponding LED to indicate the result. We’ll create a function to select one of six LEDs on the Arduino randomly and to keep the LED on for a certain period of time. When the Arduino running the sketch is turned on or reset, it should show random LEDs rapidly for a specified period of time and then gradually slow the flashing until the final LED is lit. The LED matching the resulting randomly chosen number will stay on until the Arduino is reset or turned off.</p>&#13;
			<h3 id="h2-500587c06-0002">The Hardware</h3>&#13;
			<p class="BodyFirst">To build the die, we’ll need the following hardware:</p>&#13;
			<ul>&#13;
				<li>Six LEDs of any color (LED1 to LED6)</li>&#13;
				<li>&#13;
					One 560 <span class="NSSymbol">Ω</span> resistor (R1)</li>&#13;
				<li><span epub:type="pagebreak" id="Page_102" title="102"/>Various connecting wires</li>&#13;
				<li>One medium-sized breadboard</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c06-0003">The Schematic</h3>&#13;
			<p class="BodyFirst">Because only one LED will be lit at a time, a single current-limiting resistor can go between the cathodes of the LEDs and GND. <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a> shows the schematic for our die.</p>&#13;
			<figure>&#13;
				<img alt="f06002" src="image_fi/500587c06/f06002.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-2">Figure 6-2</a>: Schematic for Project 15</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c06-0004">The Sketch</h3>&#13;
			<p class="BodyFirst">Here’s the sketch for our die:</p>&#13;
			<pre><code>// Project 15 - Creating an Electronic Die&#13;
void setup()&#13;
{ randomSeed(analogRead(0));      // seed the random number generator for ( int z = 1 ; z &lt; 7 ; z++ ) // LEDs on pins 1-6 are output { pinMode(z, OUTPUT); }&#13;
}<span epub:type="pagebreak" id="Page_103" title="103"/>void randomLED(int del)&#13;
{ int r; r = random(1, 7);      // get a random number from 1 to 6 digitalWrite(r, HIGH); // output to the matching LED on digital pin 1-6 if (del &gt; 0) {<span aria-label="annotation1" class="CodeAnnotationHang">1</span>     delay(del);          // hold the LED on for the delay received }<span aria-label="annotation2" class="CodeAnnotationHang">2</span>     else if (del == 0) { do                   // delay entered was zero, hold the LED on forever {}<span aria-label="annotation3" class="CodeAnnotationHang">3</span>     while (1);  } digitalWrite(r, LOW);  // turn off the LED&#13;
}&#13;
void loop()&#13;
{ int a; // cycle the LEDs around for effect for ( a = 0 ; a &lt; 100 ; a++ )  { randomLED(50); } // slow down<span aria-label="annotation4" class="CodeAnnotationHang">4</span>   for ( a = 1 ; a &lt;= 10 ; a++ )  { randomLED(a * 100); } // and stop at the final random number and LED randomLED(0);&#13;
}</code></pre>&#13;
			<p>&#13;
				Here we use a loop in <code>void setup()</code> to activate the digital output pins. The function <code>randomLED()</code> receives an integer that is used in the <code>delay()</code> function at <span aria-label="annotation1" class="CodeAnnotation">1</span> to keep the LED turned on for the selected time. If the value of the delay received at <span aria-label="annotation2" class="CodeAnnotation">2</span> is <code>0</code>, then the function keeps the LED turned on indefinitely, because we use</p>&#13;
			<pre><code>  do {} while (1);</code></pre>&#13;
			<p class="BodyContinued">at <span aria-label="annotation3" class="CodeAnnotation">3</span>, which loops forever, because 1 is always 1.</p>&#13;
			<p>&#13;
				To “roll the die,” we reset the Arduino to restart the sketch. To gradually slow the change in the LEDs before the final value is displayed, we first display a random LED 100 times for 50 milliseconds each time. Then, at <span aria-label="annotation4" class="CodeAnnotation">4</span> we slow down the flashing by increasing the delay between LED flashes from 100 to 1,000 milliseconds, with each flash lasting 100 milliseconds. <span epub:type="pagebreak" id="Page_104" title="104"/>The purpose of this is to simulate the “slowing down” of a die before it finally settles on a value. With the last line, the Arduino displays the outcome of the roll by keeping one LED lit:</p>&#13;
			<pre><code>  randomLED(0);</code></pre>&#13;
			<h3 id="h2-500587c06-0005">Modifying the Sketch</h3>&#13;
			<p class="BodyFirst">We can tinker with this project in many ways. For example, we could add another six LEDs to roll two dice at once. Or display the result using only the built-in LED, by blinking it a number of times to indicate the result of the roll. Or use a button to roll the dice again. Use your imagination and new skills to have some fun!</p>&#13;
			<h2 id="h1-500587c06-0003">A Quick Course in Binary</h2>&#13;
			<p class="BodyFirst">Most children learn to count using the<em> </em>base-10<em> </em>system, but computers (including the Arduino) count using the binary<em> </em>number system.</p>&#13;
			<h3 id="h2-500587c06-0006">Binary Numbers</h3>&#13;
			<p class="BodyFirst"><em>Binary numbers</em> consist of only 1s and 0s—for example, 10101010. In binary, each digit from right to left represents 2 to the power of the column number in which it appears (which increases from right to left). The products in each column are then added to determine the value of the number.</p>&#13;
			<p>&#13;
				For example, consider the binary number 10101010, as shown in <a href="#table6-1" id="tableanchor6-1">Table 6-1</a>. To convert the number 10101010 in binary to base 10, we add the totals in each column as listed in the bottom row of the table:</p>&#13;
			<p class="equation">128 + 0 + 32 + 0 + 8 + 0 + 2 + 0</p>&#13;
			<p>&#13;
				The sum is 170, and therefore the binary number 10101010 equals 170 in base 10. A binary number with eight columns (or <em>bits</em>) holds 1 <em>byte</em> of data; 1 byte of data can have a numerical value between 0 and 255. The leftmost bit is referred to as the <em>most significant bit (MSB)</em>, and the rightmost is the <em>least significant bit (LSB)</em>.</p>&#13;
			<figure>&#13;
				<figcaption class="TableTitle">&#13;
					<p><a id="table6-1">Table 6-1</a>: Binary to Base-10 Number Conversion Example</p>&#13;
				</figcaption>&#13;
				<table border="1" id="table-500587c06-0001">&#13;
					<thead>&#13;
						<tr>&#13;
							<td><b>2<sup>7</sup></b></td>&#13;
							<td><b>2<sup>6</sup></b></td>&#13;
							<td><b>2<sup>5</sup></b></td>&#13;
							<td><b>2<sup>4</sup></b></td>&#13;
							<td><b>2<sup>3</sup></b></td>&#13;
							<td><b>2<sup>2</sup></b></td>&#13;
							<td><b>2<sup>1</sup></b></td>&#13;
							<td><b>2<sup>0</sup></b></td>&#13;
							<td><b> </b></td>&#13;
						</tr>&#13;
					</thead>&#13;
					<tbody>&#13;
						<tr>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>Binary</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>128</td>&#13;
							<td>64</td>&#13;
							<td>32</td>&#13;
							<td>16</td>&#13;
							<td>8</td>&#13;
							<td>4</td>&#13;
							<td>2</td>&#13;
							<td>1</td>&#13;
							<td>Base 10</td>&#13;
						</tr>&#13;
					</tbody>&#13;
				</table>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_105" title="105"/>Binary numbers are great for storing certain types of data, such as on/off patterns for LEDs, true/false settings, and the statuses of digital outputs. Binary numbers are the building blocks of all types of data in computers.</p>&#13;
			<h3 id="h2-500587c06-0007">Byte Variables</h3>&#13;
			<p class="BodyFirst">One way we can store binary numbers is by using a <em>byte variable</em>. For example, we can create the byte variable <code>outputs</code> using the following code:</p>&#13;
			<pre><code>byte outputs = B11111111;</code></pre>&#13;
			<p>&#13;
				The <code>B</code> in front of the number tells Arduino to read the number as a binary number (in this case, 11111111) instead of its base-10 equivalent of 255. <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> demonstrates this further.</p>&#13;
			<pre><code>// Listing 6-2&#13;
byte a; &#13;
void setup()&#13;
{ Serial.begin(9600);&#13;
}&#13;
void loop()&#13;
{ for ( int count = 0 ; count &lt; 256 ; count++ ) { a = count; Serial.print("Base-10 = ");<span aria-label="annotation1" class="CodeAnnotationHang">1</span>     Serial.print(a, DEC); Serial.print(" Binary = ");<span aria-label="annotation2" class="CodeAnnotationHang">2</span>     Serial.println(a, BIN); delay(1000); }&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Binary number demonstration</p>&#13;
			<p>&#13;
				We display byte variables as base-10 numbers using <code>DEC</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> or as binary numbers using <code>BIN</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> as part of the <code>Serial.print()</code> function. After uploading the sketch, you should see output in the Serial Monitor similar to that shown in <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_106" title="106"/>&#13;
				<figure>&#13;
				<img alt="f06003" src="image_fi/500587c06/f06003.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-3">Figure 6-3</a>: Output from <a href="#listing6-2">Listing 6-2</a></p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c06-0004">Increasing Digital Outputs with Shift Registers</h2>&#13;
			<p class="BodyFirst">The Arduino board has 13 digital pins that we can use as outputs—but sometimes 13 just isn’t enough. To add outputs, we can use a <em>shift register</em> and still have plenty of room left on the Arduino for outputs. A shift register is an integrated circuit (IC) with eight digital output pins that can be controlled by sending a byte of data to the IC. For our projects, we will be using the 74HC595 shift register shown in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>.</p>&#13;
			<figure>&#13;
				<img alt="f06004" src="image_fi/500587c06/f06004.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-4">Figure 6-4</a>: The 74HC595 shift register IC</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>The 74HC595 shift register has eight digital outputs that can operate like the Arduino digital output pins. The shift register itself takes up three Arduino digital output pins, so the net gain is five output pins.</p>&#13;
			<p>&#13;
				The principle behind the shift register is simple: we send 1 byte of data (8 bits) to the shift register, and it turns on or off the matching eight outputs based on the 1 byte of data. The bits representing the byte of data match the output pins in order from highest to lowest, so the leftmost bit of the data represents output pin 7 of the shift register, and the rightmost bit of the data represents output pin 0. For example, if we send <code>B10000110</code> <span epub:type="pagebreak" id="Page_107" title="107"/>to the shift register, then it will turn on outputs 1, 2, and 7 and will turn off outputs 0 and 3 to 6 until the next byte of data is received or the power is turned off.</p>&#13;
			<p>More than one shift register can be connected together to provide an extra eight digital output pins for every shift register attached to the same three Arduino pins; this makes shift registers very convenient when you want to control lots of LEDs. Let’s do that now by creating a binary number display.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0005"><span>Project #16: Creating an LED Binary Number Display</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll use eight LEDs to display binary numbers from 0 to 255. Our sketch will use a <code>for</code> loop to count from 0 to 255 and will send each value to the shift register, which will use LEDs to display the binary equivalent of each number.</p>&#13;
			<h3 id="h2-500587c06-0008">The Hardware</h3>&#13;
			<p class="BodyFirst">The following hardware is required:</p>&#13;
			<ul>&#13;
				<li>One 74HC595 shift register IC</li>&#13;
				<li>Eight LEDs (LED1 to LED8)</li>&#13;
				<li>&#13;
					Eight 560 <span class="NSSymbol">Ω</span> resistors (R1 to R8)</li>&#13;
				<li>One breadboard</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c06-0009">The Schematic</h3>&#13;
			<p class="BodyFirst"><a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a> shows the schematic symbol for the 74HC595.</p>&#13;
			<figure>&#13;
				<img alt="f06005" src="image_fi/500587c06/f06005.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-5">Figure 6-5</a>: 74HC595 schematic symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_108" title="108"/>There are 16 pins on our shift register:</p>&#13;
			<ul>&#13;
				<li>&#13;
					Pins 15 and 1 to 7 are the eight output pins that we control (labeled <em>Q0</em> to <em>Q7</em>, respectively).</li>&#13;
				<li>Q7 outputs the first bit sent to the shift register and Q0 outputs the last.</li>&#13;
				<li>Pin 8 connects to GND.</li>&#13;
				<li>&#13;
					Pin 9 is called <em>data out</em> and is used to send data to another shift register if one is present.</li>&#13;
				<li>Pin 10 is always connected to 5 V (for example, the 5 V connector on the Arduino).</li>&#13;
				<li>&#13;
					Pins 11 and 12 are called <em>clock</em> and <em>latch</em>.</li>&#13;
				<li>&#13;
					Pin 13 is called <em>output enable</em> and is usually connected to GND.</li>&#13;
				<li>Pin 14 is for incoming bit data sent from the Arduino.</li>&#13;
				<li>Pin 16 is used for power: 5 V from the Arduino.</li>&#13;
			</ul>&#13;
			<p>&#13;
				To give you a sense of the way the pins are oriented, the semicircular notch on the left end of the body of the shift register IC shown in <a href="#figure6-4">Figure 6-4</a> lies between pins 1 and 16.</p>&#13;
			<p>&#13;
				The pins are numbered sequentially around the body in a counterclockwise direction, as shown in <a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>, the schematic for our LED binary number display.</p>&#13;
			<figure>&#13;
				<img alt="f06006" src="image_fi/500587c06/f06006.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-6">Figure 6-6</a>: Schematic for Project 16</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note"><span epub:type="pagebreak" id="Page_109" title="109"/>&#13;
				<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>	Once you have finished with this example circuit, keep it assembled. We’ll use it again for the next project.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h3 id="h2-500587c06-0010">The Sketch</h3>&#13;
			<p class="BodyFirst">And now for the sketch:</p>&#13;
			<pre><code>// Project 16 – Creating an LED Binary Number Display&#13;
#define DATA  6          // digital 6 to pin 14 on the 74HC595&#13;
#define LATCH 8          // digital 8 to pin 12 on the 74HC595&#13;
#define CLOCK 10         // digital 10 to pin 11 on the 74HC595&#13;
void setup()&#13;
{ pinMode(LATCH, OUTPUT); pinMode(CLOCK, OUTPUT); pinMode(DATA, OUTPUT);&#13;
}&#13;
void loop()&#13;
{ int i; for ( i = 0; i &lt; 256; i++ ) { digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, MSBFIRST, i); digitalWrite(LATCH, HIGH); delay(200); }&#13;
}</code></pre>&#13;
			<p>&#13;
				In this sketch, we set the three pins connected to the shift register as outputs in <code>void setup()</code> and then add a loop in <code>void loop()</code> that counts from 0 to 255 and repeats. The magic lies inside the loop. When we send a byte of data (for example, 240, or <code>B11110000</code>) to the shift register in the <code>for</code> loop, three things happen:</p>&#13;
			<ul>&#13;
				<li>&#13;
					The latch pin 12 is set to <code>LOW</code> (that is, a low signal is applied to it from the Arduino digital output pin 8). This is preparation for setting output pin 12 to <code>HIGH</code>, which latches the data to the output pins after <code>shiftOut()</code> has completed its task.</li>&#13;
				<li>&#13;
					We send the byte of data (for example, <code>B11110000</code>) from Arduino digital pin 6 to the shift register and tell the <code>shiftOut()</code> function from which direction to interpret the byte of data. For example, if we selected <code>LSBFIRST</code>, then LEDs 1 to 4 would turn on and the others would turn off. If we used <code>MSBFIRST</code>, then LEDs 5 to 8 would turn on and the others would turn off.</li>&#13;
				<li>&#13;
					Finally, the latch pin 12 is set to <code>HIGH</code> (5 V is applied to it). This tells the shift register that all the bits are shifted in and ready. At this point, the shift register alters its output to match the data received.</li>&#13;
			</ul>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0006"><span><span epub:type="pagebreak" id="Page_110" title="110"/>Project #17: Making a Binary Quiz Game</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll use random numbers, the Serial Monitor, and the circuit created in Project 16 to create a binary quiz game. The Arduino will display a random binary number using the LEDs, and then you will enter the decimal version of the binary number using the Serial Monitor. The Serial Monitor will tell you whether your answer is correct, and the game will continue with a new number.</p>&#13;
			<h3 id="h2-500587c06-0011">The Algorithm</h3>&#13;
			<p class="BodyFirst">The algorithm can be divided into three functions. The <code>displayNumber()</code> function will display a binary number using the LEDs. The <code>getAnswer()</code> function will receive a number from the Serial Monitor and display it to the user. Finally, the <code>checkAnswer()</code> function will compare the user’s number to the random number generated and display the correct/incorrect status, as well as the correct answer if the guess was incorrect.</p>&#13;
			<h3 id="h2-500587c06-0012">The Sketch</h3>&#13;
			<p class="BodyFirst">The sketch generates a random number between 0 and 255, displays it in binary using the LEDs, asks the user for their answer, and then displays the result in the Serial Monitor. You’ve already seen all the functions used in the sketch, so although there’s a lot of code here, it should look familiar. We’ll dissect it with comments within the sketch and some commentary following:</p>&#13;
			<pre><code>// Project 17 - Making a Binary Quiz Game&#13;
#define DATA   6                 // connect to pin 14 on the 74HC595&#13;
#define LATCH  8                 // connect to pin 12 on the 74HC595&#13;
#define CLOCK 10                 // connect to pin 11 on the 74HC595&#13;
int number = 0;&#13;
int answer = 0;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> void setup()&#13;
{ pinMode(LATCH, OUTPUT);        // set up the 74HC595 pins pinMode(CLOCK, OUTPUT); pinMode(DATA, OUTPUT); Serial.begin(9600); randomSeed(analogRead(0));     // initialize the random number generator displayNumber(0);              // clear the LEDs&#13;
}<span aria-label="annotation2" class="CodeAnnotationHang">2</span> void displayNumber(byte a)&#13;
{ // send byte to be displayed on the LEDs digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, MSBFIRST, a);<span epub:type="pagebreak" id="Page_111" title="111"/>  digitalWrite(LATCH, HIGH);&#13;
}<span aria-label="annotation3" class="CodeAnnotationHang">3</span> void getAnswer()&#13;
{ // receive the answer from the player int z = 0; Serial.flush(); while (Serial.available() == 0) { // do nothing until something comes into the serial buffer } // one character of serial data is available, begin calculating while (Serial.available() &gt; 0) { // move any previous digit to the next column on the left; in  // other words, 1 becomes 10 while there is data in the buffer answer = answer * 10; // read the next number in the buffer and subtract the character '0'  // from it to convert it to the actual integer number z = Serial.read() - '0'; // add this digit into the accumulating value answer = answer + z; // allow a short delay for any more numbers to come into Serial.available delay(5); } Serial.print("You entered: "); Serial.println(answer);&#13;
}<span aria-label="annotation4" class="CodeAnnotationHang">4</span> void checkAnswer()&#13;
{ // check the answer from the player and show the results if (answer == number)    // Correct! { Serial.print("Correct! "); Serial.print(answer, BIN); Serial.print(" equals "); Serial.println(number); Serial.println(); } else                     // Incorrect { Serial.print("Incorrect, "); Serial.print(number, BIN); Serial.print(" equals "); Serial.println(number); Serial.println();     } answer = 0; delay(10000); // give the player time to review their answer&#13;
}<span aria-label="annotation5" class="CodeAnnotationHang">5</span> void loop()<span epub:type="pagebreak" id="Page_112" title="112"/>{ number = random(256); displayNumber(number); Serial.println("What is the binary number in base 10? "); getAnswer();   checkAnswer();&#13;
}</code></pre>&#13;
			<p>&#13;
				Let’s review how the sketch works. At <span aria-label="annotation1" class="CodeAnnotation">1</span>, <code>void setup()</code> configures the digital output pins to use the shift register, starts the Serial Monitor, and seeds the random number generator. At <span aria-label="annotation2" class="CodeAnnotation">2</span>, the custom function <code>displayNumber()</code> accepts a byte of data and sends it to the shift register, which uses LEDs to display the byte in binary form via the attached LEDs (as in Project 16). At <span aria-label="annotation3" class="CodeAnnotation">3</span>, the custom function <code>getAnswer()</code> accepts a number from the user via the Serial Monitor (as in Project 14 in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>) and displays it, as shown in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>.</p>&#13;
			<p>&#13;
				The function <code>checkAnswer()</code> at <span aria-label="annotation4" class="CodeAnnotation">4</span> compares the number entered by the player in <code>getAnswer()</code> against the random number generated by the sketch in <code>void loop()</code>. The player is then advised of a correct or incorrect answer with corresponding binary and decimal values. Finally, in the main <code>void loop()</code> at <span aria-label="annotation5" class="CodeAnnotation">5</span> from which the program runs, the Arduino generates the random binary number for the quiz, calls the matching functions to display it with hardware, and then receives and checks the player’s answer.</p>&#13;
			<p><a href="#figure6-7">Figure 6-7</a> shows the game in play in the Serial Monitor.</p>&#13;
			<figure>&#13;
				<img alt="f06007" src="image_fi/500587c06/f06007.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-7">Figure 6-7</a>: Project 17 in play</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c06-0007">Arrays</h2>&#13;
			<p class="BodyFirst">An <em>array</em> is a set of variables or values grouped together so that they can be referenced as a whole. When dealing with lots of related data, you’ll find it a good idea to use arrays to keep your data organized.</p>&#13;
			<h3 id="h2-500587c06-0013"><span epub:type="pagebreak" id="Page_113" title="113"/>Defining an Array</h3>&#13;
			<p class="BodyFirst">Each item in an array is called an <em>element</em>. For example, suppose six <code>float</code> variables contain temperatures taken over the last six hours; instead of giving them all separate names, we can define an array called <code>temperatures</code> with six elements like this:</p>&#13;
			<pre><code>float temperatures[6];</code></pre>&#13;
			<p>We can also insert values when defining the array. When we do that, we don’t need to define the array size. Here’s an example:</p>&#13;
			<pre><code>float temperatures[]={11.1, 12.2, 13.3, 14.4, 15.5, 16.6};</code></pre>&#13;
			<p>&#13;
				Notice that this time, we didn’t explicitly define the size of the array within the square brackets (<code>[]</code>); instead, its size is deduced based on the number of elements set by the values inside the curly brackets (<code>{}</code>). Note that arrays of any size can only contain one type of variable.</p>&#13;
			<h3 id="h2-500587c06-0014">Referring to Values in an Array</h3>&#13;
			<p class="BodyFirst">We count the elements in an array beginning from the left and starting from 0; the <code>temperatures[]</code> array has elements numbered 0 to 5. We can refer to individual values within an array by inserting the number of the element in the square brackets. For example, to change the first element in <code>temperatures[]</code> (currently <code>11.1</code>) to <code>12.34</code>, we would use this:</p>&#13;
			<pre><code>  temperatures[0] = 12.34;</code></pre>&#13;
			<h3 id="h2-500587c06-0015">Writing to and Reading from Arrays</h3>&#13;
			<p class="BodyFirst">In <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a>, we demonstrate writing values to and reading values from an array of five elements. The first <code>for</code> loop in the sketch writes a random number into each of the array’s elements, and the second <code>for</code> loop retrieves the elements and displays them in the Serial Monitor.</p>&#13;
			<pre><code>// Listing 6-3&#13;
void setup()&#13;
{ Serial.begin(9600); randomSeed(analogRead(0)); &#13;
}&#13;
int array[5];    // define our array of five integer elements&#13;
void loop()&#13;
{ int i; Serial.println(); for ( i = 0 ; i &lt; 5 ; i++ )   // write to the array { array[i] = random(10);      // random numbers from 0 to 9 }<span epub:type="pagebreak" id="Page_114" title="114"/>  for ( i = 0 ; i &lt; 5 ; i++ )   // display the contents of the array { Serial.print("array["); Serial.print(i); Serial.print("] contains "); Serial.println(array[i]);  } delay(5000);&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Array read/write demonstration</p>&#13;
			<p><a href="#figure6-8" id="figureanchor6-8">Figure 6-8</a> shows the output of this sketch in the Serial Monitor.</p>&#13;
			<figure>&#13;
				<img alt="f06008" src="image_fi/500587c06/f06008.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-8">Figure 6-8</a>: <a href="#listing6-3">Listing 6-3</a> in action</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Now that you know how to use with binary numbers, shift registers, and arrays, it’s time to put that knowledge to use. In our next project, we’ll wire up some digital number displays.</p>&#13;
			<h2 id="h1-500587c06-0008">Seven-Segment LED Displays</h2>&#13;
			<p class="BodyFirst">LEDs are fun, but there are limits to the kinds of data that can be displayed with individual lights. In this section, we’ll begin working with numeric digits in the form of seven-segment LED displays, as shown in <a href="#figure6-9" id="figureanchor6-9">Figure 6-9</a>.</p>&#13;
			<figure>&#13;
				<img alt="f06009" src="image_fi/500587c06/f06009.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-9">Figure 6-9</a>: Seven-segment display modules</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_115" title="115"/>These displays are perfect for displaying numbers, and that’s why you’ll find them used in digital alarm clocks, speedometers, and the like. Each module in a seven-segment LED display consists of eight LEDs. The modules are also available in different colors. To reduce the number of pins used by the display, all of the anodes or cathodes of the LEDs are connected together—these are called <em>common-anode</em> or <em>common-cathode</em> modules, respectively. Our projects will use common-cathode modules.</p>&#13;
			<p>&#13;
				The display’s LEDs are labeled <em>A</em> to <em>G</em> and <em>DP</em> (for the decimal point). There is an anode pin for each LED segment, and the cathodes are connected to one common cathode pin. The layout of seven-segment LED displays is always described as shown in <a href="#figure6-10" id="figureanchor6-10">Figure 6-10</a>, with LED segment A at the top, B to its right, and so on. So, for example, if you wanted to display the number 7, then you would apply current to segments A, B, and C.</p>&#13;
			<p>&#13;
				The pins on each LED display module can vary, depending on the manufacturer, but they always follow the basic pattern shown in <a href="#figure6-10">Figure 6-10</a>. When you use one of these modules, always get the data sheet for the module from the retailer to help save you time determining which pins are which.</p>&#13;
			<p>&#13;
				We’ll use the schematic symbol shown in <a href="#figure6-11" id="figureanchor6-11">Figure 6-11</a> for our seven-segment LED display modules.</p>&#13;
			<figure>&#13;
				<img alt="f06010" src="image_fi/500587c06/f06010.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-10">Figure 6-10</a>: LED map for a typical seven-segment display module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<figure>&#13;
				<img alt="f06011" src="image_fi/500587c06/f06011.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-11">Figure 6-11</a>: Schematic symbol for a seven-segment display module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c06-0016">Controlling the LED</h3>&#13;
			<p class="BodyFirst">We’ll control the LED display using the method discussed in Project 17, by connecting pins A through DP to the shift register outputs Q0 to Q7. Use the matrix shown in <a href="#table6-2" id="tableanchor6-2">Table 6-2</a> as a guide to help determine which segments to turn on and off to display a particular number or letter.</p>&#13;
			<p>The top row in the matrix is the shift register output pin that controls the segments on the second row. Each row below this shows the digit that can be displayed with the corresponding binary and decimal value to send to the shift register.</p>&#13;
			<figure>&#13;
				<figcaption class="TableTitle">&#13;
					<p><a id="table6-2">Table 6-2</a>: Display Segment Matrix<span epub:type="pagebreak" id="Page_116" title="116"/></p>&#13;
				</figcaption>&#13;
				<table border="1" id="table-500587c06-0002">&#13;
					<thead>&#13;
						<tr>&#13;
							<td><b>SR</b></td>&#13;
							<td><b>Q0</b></td>&#13;
							<td><b>Q1</b></td>&#13;
							<td><b>Q2</b></td>&#13;
							<td><b>Q3</b></td>&#13;
							<td><b>Q4</b></td>&#13;
							<td><b>Q5</b></td>&#13;
							<td><b>Q6</b></td>&#13;
							<td><b>Q7</b></td>&#13;
							<td><b> </b></td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>Segment</b></td>&#13;
							<td><b>A</b></td>&#13;
							<td><b>B</b></td>&#13;
							<td><b>C</b></td>&#13;
							<td><b>D</b></td>&#13;
							<td><b>E</b></td>&#13;
							<td><b>F</b></td>&#13;
							<td><b>G</b></td>&#13;
							<td><b>DP</b></td>&#13;
							<td><b>Decimal</b></td>&#13;
						</tr>&#13;
					</thead>&#13;
					<tbody>&#13;
						<tr>&#13;
							<td><b>0</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>252</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>1</b></td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>96</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>2</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>218</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>3</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>242</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>4</b></td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>102</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>5</b></td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>182</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>6</b></td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>190</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>7</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>224</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>8</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>254</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>9</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>246</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>A</b></td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>238</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>B</b></td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>62</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>C</b></td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>156</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>D</b></td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>122</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>E</b></td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>158</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td><b>F</b></td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>0</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>1</td>&#13;
							<td>0</td>&#13;
							<td>142</td>&#13;
						</tr>&#13;
					</tbody>&#13;
				</table>&#13;
			</figure>&#13;
			<p>&#13;
				For example, to display the digit 7, as shown in <a href="#figure6-12" id="figureanchor6-12">Figure 6-12</a>, we need to turn on LED segments A, B, and C, which correspond to the shift register outputs Q0, Q1, and Q2. Therefore, we will send the byte <code>B1110000</code> into the shift register (with <code>shiftOut()</code> set to <code>LSBFIRST</code>) to turn on the first three outputs that match the desired LEDs on the module.</p>&#13;
			<figure>&#13;
				<img alt="f06012" src="image_fi/500587c06/f06012.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-12">Figure 6-12</a>: Displaying the digit 7</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>In our next project, we’ll create a circuit that displays, in turn, the digits 0 through 9 and then the letters A through F. The cycle repeats with the decimal-point LED turned on.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0009"><span><span epub:type="pagebreak" id="Page_117" title="117"/>Project #18: Creating a Single-Digit Display</span></h2>&#13;
			<p class="BodyFirst">In this project we’ll assemble a circuit to use a single-digit display.</p>&#13;
			<h3 id="h2-500587c06-0017">The Hardware</h3>&#13;
			<p class="BodyFirst">The following hardware is required:</p>&#13;
			<ul>&#13;
				<li>One 74HC595 shift register IC</li>&#13;
				<li>One common-cathode seven-segment LED display</li>&#13;
				<li>One 560 Ω resistor (R1)</li>&#13;
				<li>One large breadboard</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c06-0018">The Schematic</h3>&#13;
			<p class="BodyFirst">The schematic is shown in <a href="#figure6-13" id="figureanchor6-13">Figure 6-13</a>.</p>&#13;
			<figure>&#13;
				<img alt="f06013" src="image_fi/500587c06/f06013.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-13">Figure 6-13</a>: Schematic for Project 18</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>When you’re wiring the LED module to the shift register, LED pins A through G connect to pins Q0 through Q6, respectively, and DP connects to Q7.</p>&#13;
			<h3 id="h2-500587c06-0019">The Sketch</h3>&#13;
			<p class="BodyFirst">In the sketch for Project 18, we store the decimal values (see <a href="#table6-2">Table 6-2</a>) in the <code>int digits[]</code> array. In the <code>void loop()</code>, we send these values to the shift <span epub:type="pagebreak" id="Page_118" title="118"/>register in sequential order at <span aria-label="annotation1" class="CodeAnnotation">1</span> and then repeat the process with the decimal point on by adding 1 to the value sent to the shift register at <span aria-label="annotation2" class="CodeAnnotation">2</span>:</p>&#13;
			<pre><code>// Project 18 - Creating a Single-Digit Display&#13;
#define DATA  6                       // connect to pin 14 on the 74HC595&#13;
#define LATCH 8                       // connect to pin 12 on the 74HC595&#13;
#define CLOCK 10                      // connect to pin 11 on the 74HC595&#13;
// set up the array with the segments for 0 to 9, A to F (from Table 6-2)&#13;
int digits[] = {252, 96, 218, 242, 102, 182, 190, 224, 254, 246, 238, 62, 156, 122, 158, 142};&#13;
void setup()&#13;
{ pinMode(LATCH, OUTPUT); pinMode(CLOCK, OUTPUT); pinMode(DATA, OUTPUT);&#13;
}&#13;
void loop()&#13;
{ int i; for ( i = 0 ; i &lt; 16 ; i++ )   // display digits 0-9, A-F { digitalWrite(LATCH, LOW);<span aria-label="annotation1" class="CodeAnnotationHang">1</span> shiftOut(DATA, CLOCK, LSBFIRST, digits[i]); digitalWrite(LATCH, HIGH); delay(250); } for ( i = 0 ; i &lt; 16 ; i++ )   // display digits 0-9, A-F with DP { digitalWrite(LATCH, LOW);<span aria-label="annotation2" class="CodeAnnotationHang">2</span> shiftOut(DATA, CLOCK, LSBFIRST, digits[i]+1); // +1 is to turn on the DP bit digitalWrite(LATCH, HIGH); delay(250); }&#13;
}</code></pre>&#13;
			<p>&#13;
				Seven-segment LED displays are bright and easy to read. For example, <a href="#figure6-14" id="figureanchor6-14">Figure 6-14</a> shows the result when this sketch is asked to display the digit 9 with the decimal point.</p>&#13;
			<figure>&#13;
				<img alt="f06014" src="image_fi/500587c06/f06014.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-14">Figure 6-14</a>: Digit displayed by Project 18</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c06-0020"><span epub:type="pagebreak" id="Page_119" title="119"/>Modifying the Sketch: Displaying Double Digits</h3>&#13;
			<p class="BodyFirst">To use more than one shift register to control additional digital outputs, connect pin 9 of the 74HC595 (which receives data from the Arduino) to pin 14 of the second shift register. Once you’ve made this connection, two bytes of data will be sent: the first to control the second shift register and the second to control the first shift register. Here’s an example:</p>&#13;
			<pre><code>  digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, MSBFIRST, 254); // data for second 74HC595 shiftOut(DATA, CLOCK, MSBFIRST, 254); // data for first 74HC595 digitalWrite(LATCH, HIGH);</code></pre>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0010"><span>Project #19: Controlling Two Seven-Segment LED Display Modules</span></h2>&#13;
			<p class="BodyFirst">This project will show you how to control two seven-segment LED display modules so that you can display two-digit numbers.</p>&#13;
			<h3 id="h2-500587c06-0021">The Hardware</h3>&#13;
			<p class="BodyFirst">The following hardware is required:</p>&#13;
			<ul>&#13;
				<li>Two 74HC595 shift register ICs</li>&#13;
				<li>Two common-cathode seven-segment LED displays</li>&#13;
				<li>Two 560 Ω resistors (R1 to R2)</li>&#13;
				<li>One large breadboard or two smaller units</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c06-0022">The Schematic</h3>&#13;
			<p class="BodyFirst"><a href="#figure6-15" id="figureanchor6-15">Figure 6-15</a> shows the schematic for two display modules.</p>&#13;
			<p>Note that the shift registers’ data and clock pins are connected to each other and then to the Arduino. The data line from Arduino digital pin 6 runs to shift register 1, and then a link from pin 9 of shift register 1 runs to pin 14 of shift register 2.</p>&#13;
			<p>To display a number between 0 and 99, we’ll need a more complicated sketch. If a number is less than 10, we can just send the number followed by a 0, as the right digit will display the number and the left digit will display 0. However, if the number is greater than 10, then we need to determine each of the number’s two digits and send each to the shift registers separately. To make this process easier, we’ll use the math function modulo.</p>&#13;
			<span epub:type="pagebreak" id="Page_120" title="120"/>&#13;
			<figure>&#13;
				<img alt="f06015" src="image_fi/500587c06/f06015.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure6-15">Figure 6-15</a>: Schematic for Project 19</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c06-0023">Modulo</h3>&#13;
			<p class="BodyFirst"><em>Modulo</em> is a function that returns the remainder of a division operation. For example, 10 modulo (or <em>mod</em>) 7 equals 3—in other words, the remainder of 10 divided by 7 equals 3. We use the percent sign (<code>%</code>) to represent modulo. The following example uses modulo in a sketch:</p>&#13;
			<pre><code>int a = 8;&#13;
int b = 3;&#13;
int c = a % b;</code></pre>&#13;
			<p>&#13;
				In this example, the value of <code>c</code> will be <code>2</code>. So, to determine a two-digit number’s right-hand digit, we use the modulo function<em>, </em>which returns the remainder when dividing the two numbers.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_121" title="121"/>To automate displaying a single- or double-digit number, we’ll create the function <code>displayNumber()</code> for our sketch. We use modulo as part of this function to separate the digits of a two-digit number. For example, to display the number 23, we first isolate the left-hand digit by dividing 23 by 10, yielding 2 (and a fraction that we can ignore). To isolate the right-hand digit, we perform 23 modulo 10, which equals 3:</p>&#13;
			<pre><code>// Project 19 - Controlling Two Seven-Segment LED Display Modules&#13;
// set up the array with the segments for 0 to 9, A to F (from Table 6-2)&#13;
#define DATA  6            // connect to pin 14 on the 74HC595&#13;
#define LATCH 8            // connect to pin 12 on the 74HC595&#13;
#define CLOCK 10           // connect to pin 11 on the 74HC595&#13;
void setup()&#13;
{ pinMode(LATCH, OUTPUT); pinMode(CLOCK, OUTPUT); pinMode(DATA, OUTPUT);&#13;
}&#13;
int digits[] = {252, 96, 218, 242, 102, 182, 190, 224, 254, 246, 238, 62, 156, 122, 158, 142};&#13;
void displayNumber(int n)&#13;
{ int left, right=0;<span aria-label="annotation1" class="CodeAnnotationHang">1</span>   if (n &lt; 10) { digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, LSBFIRST, digits[n]); shiftOut(DATA, CLOCK, LSBFIRST, 0);   digitalWrite(LATCH, HIGH); } else if (n &gt;= 10) {<span aria-label="annotation2" class="CodeAnnotationHang">2</span>     right = n % 10; // remainder of dividing the number to display by 10 left = n / 10;  // quotient of dividing the number to display by 10 digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, LSBFIRST, digits[right]); shiftOut(DATA, CLOCK, LSBFIRST, digits[left]);     digitalWrite(LATCH, HIGH); }&#13;
}<span aria-label="annotation3" class="CodeAnnotationHang">3</span> void loop()&#13;
{ int i; for ( i = 0 ; i &lt; 100 ; i++ ) { displayNumber(i); delay(100); }&#13;
}</code></pre>&#13;
			<p><span epub:type="pagebreak" id="Page_122" title="122"/>At <span aria-label="annotation1" class="CodeAnnotation">1</span>, the function checks whether the number to be displayed is less than 10. If so, it sends the data for the number and a blank digit to the shift registers. However, if the number is greater than 10, the function uses modulo and division at <span aria-label="annotation2" class="CodeAnnotation">2</span> to separate the digits and then sends them to the shift registers separately. Finally, in <code>void loop()</code> at <span aria-label="annotation3" class="CodeAnnotation">3</span>, we set up and call the function to display the numbers from 0 to 99.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c06-0011"><span>Project #20: Creating a Digital Thermometer</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll add the TMP36 temperature sensor we created in Project 8 in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> to the double-digit circuit constructed for Project 19 to create a digital thermometer that displays values for 0 degrees and above. The algorithm is simple: we read the voltage returned from the TMP36 (using the method from Project 12 in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>) and convert the reading to degrees Celsius.</p>&#13;
			<h3 id="h2-500587c06-0024">The Hardware</h3>&#13;
			<p class="BodyFirst">The following hardware is required:</p>&#13;
			<ul>&#13;
				<li>The double-digit circuit from Project 19</li>&#13;
				<li>One TMP36 temperature sensor</li>&#13;
			</ul>&#13;
			<p>Connect the center output lead of the TMP36 to analog pin 5, the left lead to 5 V, and the right lead to GND, and you’re ready to measure.</p>&#13;
			<h3 id="h2-500587c06-0025">The Sketch</h3>&#13;
			<p class="BodyFirst">Here is the sketch:</p>&#13;
			<pre><code>// Project 20 - Creating a Digital Thermometer&#13;
#define DATA  6             // connect to pin 14 on the 74HC595&#13;
#define LATCH 8             // connect to pin 12 on the 74HC595&#13;
#define CLOCK 10            // connect to pin 11 on the 74HC595 &#13;
int temp = 0;&#13;
float voltage = 0;&#13;
float celsius = 0;&#13;
float sensor = 0;&#13;
int digits[]={ 252, 96, 218, 242, 102, 182, 190, 224,  254, 246, 238, 62, 156, 122, 158, 142&#13;
};&#13;
void setup()&#13;
{ pinMode(LATCH, OUTPUT); pinMode(CLOCK, OUTPUT);<span epub:type="pagebreak" id="Page_123" title="123"/>  pinMode(DATA, OUTPUT);&#13;
}&#13;
void displayNumber(int n)&#13;
{ int left, right = 0; if (n &lt; 10) { digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, LSBFIRST, digits[n]); shiftOut(DATA, CLOCK, LSBFIRST, digits[0]);     digitalWrite(LATCH, HIGH); } if (n &gt;= 10) { right = n % 10; left = n / 10; digitalWrite(LATCH, LOW); shiftOut(DATA, CLOCK, LSBFIRST, digits[right]); shiftOut(DATA, CLOCK, LSBFIRST, digits[left]);     digitalWrite(LATCH, HIGH); }&#13;
}&#13;
void loop()&#13;
{ sensor = analogRead(5);       voltage = (sensor * 5000) / 1024; // convert raw sensor value to millivolts voltage = voltage - 500;          // remove voltage offset celsius = voltage / 10;           // convert millivolts to Celsius temp = int(celsius); // change the floating-point temperature to an int displayNumber(temp); delay(500);&#13;
}</code></pre>&#13;
			<p>&#13;
				As indicated, the sketch borrows code from previous projects: <code>displayNumber()</code> from Project 19 and the temperature calculations from Project 12. The <code>delay(500)</code> function in the second-to-last line of the sketch keeps the display from changing too quickly when the temperature fluctuates.</p>&#13;
			<h2 id="h1-500587c06-0012">Looking Ahead</h2>&#13;
			<p class="BodyFirst">In this chapter, you have learned a lot of fundamental skills that you’ll use over and over in your own projects. LED displays are relatively hardy, so enjoy experimenting with them. However, there is a limit to the display effects they can be used for, so in the next chapter, we make use of much more detailed display methods for text and graphics.</p>&#13;
		</section>&#13;
	</body></html>