- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building HTTP Services
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve written client code to send HTTP requests, let’s build a server
    that can process these requests and send resources to the client. The `net/http`
    package handles most of the implementation details for you, so you can focus on
    instantiating and configuring a server, creating resources, and handling each
    client request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, an HTTP server relies on several interacting components: handlers, middleware,
    and a multiplexer. When it includes all these parts, we call this server a *web
    service*. We’ll begin by looking at a simple HTTP web service and then explore
    each of its components over the course of the chapter. The big picture should
    help you understand topics that beginners often find abstract.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn more advanced uses of the `net/http` package, such as adding
    TLS support and pushing data to HTTP/2 clients. By the end, you should feel comfortable
    configuring a Go-based HTTP server, writing middleware, and responding to requests
    with handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The Anatomy of a Go HTTP Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 9-1](#figure9-1) illustrates the path a request takes in a typical
    `net/http`-based server.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09001](image_fi/500884c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Client request culminating in a server response in the handler'
  prefs: []
  type: TYPE_NORMAL
- en: First, the server’s *multiplexer* (*router*, in computer-networking parlance)
    receives the client’s request. The multiplexer determines the destination for
    the request, then passes it along to the object capable of handling it. We call
    this object a *handler*. (The multiplexer itself is a handler that routes requests
    to the most appropriate handler.) Before the handler receives the request, the
    request may pass through one or more functions called *middleware*. Middleware
    changes the handlers’ behavior or performs auxiliary tasks, such as logging, authentication,
    or access control.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](#listing9-1) creates an HTTP server that follows this basic structure.
    If you have trouble following along, don’t worry; you’ll spend the rest of the
    chapter learning how these parts work.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Instantiating a multiplexer and an HTTP server (*server_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: Requests sent to the server’s handler first pass through middleware named `http.TimeoutHandler`1,
    then to the handler returned by the `handlers.DefaultHandler` function. In this
    very simple example, you specify only a single handler for all requests instead
    of relying on a multiplexer.
  prefs: []
  type: TYPE_NORMAL
- en: The server has a few fields. The `Handler` field accepts a multiplexer or other
    object capable of handling client requests. The `Address` field should look familiar
    to you by now. In this example, you want the server to listen to port 8081 on
    IP address 127.0.0.1\. I’ll explain the `IdleTimeout` and `ReadHeaderTimeout`
    fields in the next section. Suffice it to say now, you should always define these
    two fields.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you create a new `net.Listener` bound to the server’s address 2 and
    instruct the server to `Serve`3 requests from this listener. The `Serve` method
    returns `http.ErrServerClosed` when it closes normally.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s test this server. [Listing 9-2](#listing9-2) picks up where [Listing
    9-1](#listing9-1) leaves off. It details a few test requests and their expected
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: Request test cases for the HTTP server (*server_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: First, you send a `GET` request 1, which results in a 200 OK status code. The
    response body has the `Hello, friend!` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second test case 2, you send a `POST` request with the string `<world>`
    in its body. The angle brackets are intentional, and they show an often-overlooked
    aspect of handling client input in the handler: always escape client input. You’ll
    learn about escaping client input in “Handlers” on page 193. This test case results
    in the string `Hello, &lt;world&gt;!` in the response body. The response looks
    a bit silly, but your web browser renders it as `Hello, <world>!`.'
  prefs: []
  type: TYPE_NORMAL
- en: The third test case 3 a sends a `HEAD` request to the HTTP server. The handler
    returned by the `handlers.DefaultHandler` function, which you’ll explore shortly,
    does not handle the `HEAD` method. Therefore, it returns a 405 Method Not Allowed
    status code and an empty response body.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-3](#listing9-3) continues the code in [Listing 9-2](#listing9-2)
    and runs through each test case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: Sending test requests to the HTTP server (*server_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a new request, passing the parameters from the test case 1.
    Next, you pass the request to the client’s `Do` method 2, which returns the server’s
    response. You then check the status code and read in the entire response body
    3. You should be in the habit of consistently closing the response body if the
    client did not return an error 4, even if the response body is empty or you ignore
    it entirely. Failure to do so may prevent the client from reusing the underlying
    TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: Once all tests complete, you call the server’s `Close` method 5. This causes
    its `Serve` method in [Listing 9-1](#listing9-1) to return, stopping the server.
    The `Close` method abruptly closes client connections. You’ll see an example of
    the HTTP server’s graceful shutdown support when we discuss HTTP/2 pushes later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s HTTP server supports a few other features, which we’ll explore in the following
    sections. It can proactively serve, or push, resources to clients. It also offers
    graceful shutdown support. Abruptly shutting down your web server may leave some
    clients in an awkward state if they were waiting for a response when you stopped
    the server, because those clients will never receive a response. Graceful shutdowns
    allow for all pending responses to reach each client before the server is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Clients Don’t Respect Your Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as I recommended setting the client’s time-out values, I recommend that
    you manage the various server time-out values, for the simple reason that clients
    won’t otherwise respect your server’s time. A client can take its sweet time sending
    a request to your server. Meanwhile, your server uses resources waiting to receive
    the request in its entirety. Likewise, your server is at the client’s mercy when
    it sends the response because it can send data only as fast as the client reads
    it (or can send only as much as there is TCP buffer space available). Avoid letting
    the client dictate the duration of a request-response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](#listing9-1) includes a server instance with two of its time-out
    values specified: the length of time clients can remain idle between requests
    and how long the server should wait to read a request header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although several time-out fields on the `http.Server` are available to you,
    I recommend setting only the `IdleTimeout` and `ReadHeaderTimeout` fields. The
    `IdleTimeout` field dictates how long the server will keep its side of the TCP
    socket open while waiting for the next client request when the communication uses
    keepalives. The `ReadHeaderTimeout` value determines how long the server will
    wait to finish reading the request headers. Keep in mind that this duration has
    no bearing on the time it takes to read the request body.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to enforce a time limit for reading an incoming request across all
    handlers, you could manage the request deadline by using the `ReadTimeout` field.
    If the client hasn’t sent the complete request (the headers and body) by the time
    the `ReadTimeout` duration elapses, the server ends the TCP connection. Likewise,
    you could give the client a finite duration in which to send the request and read
    the response by using the `WriteTimeout` field. The `ReadTimeout` and `WriteTimeout`
    values apply to all requests and responses because they dictate the `ReadDeadline`
    and `WriteDeadline` values of the TCP socket, as discussed in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: These blanket time-out values may be inappropriate for handlers that expect
    clients to send large files in a request body or handlers that indefinitely stream
    data to the client. In these two examples, the request or response may abruptly
    time out even if everything went ahead as expected. Instead, a good practice is
    to rely on the `ReadHeaderTimeout` value. You can separately manage the time it
    takes to read the request body and send the response using middleware or handlers.
    This gives you the greatest control over request and response durations per resource.
    You’ll learn how to manage the request-response duration by using middleware in
    “Middleware” on page 202.
  prefs: []
  type: TYPE_NORMAL
- en: Adding TLS Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP traffic is plaintext by default, but web clients and servers can use HTTP
    over an encrypted TLS connection, a combination known as *HTTPS*. Go’s HTTP server
    enables HTTP/2 support over TLS connections only, but enabling TLS is a simple
    matter. You need to modify only two lines from [Listing 9-1](#listing9-1)’s server
    implementation: the port number and the `Serve` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Technically, you don’t need to change the port number 1, but the convention
    is to serve HTTPS over port 443, or an augmentation of port 443, like 8443\. Using
    the server’s `ServeTLS` method, you instruct the server to use TLS over HTTP 2.
    The `ServeTLS` method requires the path to both a certificate and a corresponding
    private key. I recommend you check out the mkcert project at [https://github.com/FiloSottile/mkcert/](https://github.com/FiloSottile/mkcert/)
    to get a key pair. You can use mkcert to create locally trusted key pairs for
    development purposes only. For production use, you should consider using and supporting
    Let’s Encrypt at [https://letsencrypt.org/](https://letsencrypt.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client sends a request to an HTTP server, the server needs to figure
    out what to do with it. The server may need to retrieve various resources or perform
    an action, depending on what the client requests. A common design pattern is to
    specify bits of code to handle these requests, known as *handlers*. You may have
    a handler that knows how to retrieve an image and another handler that knows how
    to retrieve information from a database. We’ll discuss how the server figures
    out which handler is most apt for each request in “Multiplexers” on page 207.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, handlers are objects that implement the `http.Handler` interface. They
    read client requests and write responses. The `http.Handler` interface consists
    of a single method to receive both the response and the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Any object that implements the `http.Handler` interface may handle client requests,
    as far as the Go HTTP server is concerned. We often define handlers as functions,
    as in this common pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you wrap a function that accepts an `http.ResponseWriter` and an `http.Request`
    pointer in the `http.HandlerFunc` type, which implements the `Handler` interface.
    This results in an `http.HandlerFunc` object that calls the wrapped `func(w http.ResponseWriter,
    r *http.Request)` function when the server calls its `ServeHTTP` method. This
    handler responds to the client with the string `Hello, world!` in the response
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you ignore the number of written bytes and any potential write error.
    In the wild, writes to a client can fail for any number of reasons. It isn’t worth
    logging these errors. Instead, one option is to keep track of the write error
    frequency and have your server send you an alert should the number of errors exceed
    an appropriate threshold. You’ll learn about instrumenting your code in Chapter
    13.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with the structure of a handler, let’s have a look
    at the handler returned by the `handlers.DefaultHandler` function in [Listing
    9-4](#listing9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: The default handler implementation (*handlers/default.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: The `handlers.DefaultHandler` function returns a function converted to the `http.HandlerFunc`
    type. The `http.HandlerFunc` type implements the `http.Handler` interface. Go
    programmers commonly convert a function with the signature `func(w http.ResponseWriter,
    r *http.Request)` to the `http.HandlerFunc` type so the function implements the
    `http.Handler` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The first bit of code you see is a deferred function that drains and closes
    the request body 2. Just as it’s important for the client to drain and close the
    response body to reuse the TCP session, it’s important for the server to do the
    same with the request body. But unlike the Go HTTP client, closing the request
    body does not implicitly drain it. Granted, the `http.Server` will close the request
    body for you, but it won’t drain it. To make sure you can reuse the TCP session,
    I recommend you drain the request body at a minimum. Closing it is optional.
  prefs: []
  type: TYPE_NORMAL
- en: The handler responds differently depending on the request method 3. If the client
    sent a `GET` request, the handler writes `Hello, friend!` to the response writer.
    If the request method is a `POST`, the handler first reads the entire request
    body. If an error occurs while reading the request body, the handler uses the
    `http.Error` function 4 to succinctly write the message `Internal server error`
    to the response body and set the response status code to 500\. Otherwise, the
    handler returns a greeting using the request body contents. If the handler receives
    any other request method, it responds with a 405 Method Not Allowed status 5.
    The 405 response is technically not RFC-compliant without an Allow header showing
    which methods the handler accepts. We’ll shore up this deficiency in “Any Type
    Can Be a Handler” on page 198. Finally, the handler writes the response body.
  prefs: []
  type: TYPE_NORMAL
- en: This code could have a security vulnerability since part of the response body
    might come from the request body. A malicious client can send a request payload
    that includes JavaScript, which could run on a client’s computer. This behavior
    can lead to an XSS attack. To prevent these attacks, you must properly escape
    all client-supplied content before sending it in a response. Here, you use the
    `html/template` package to create a simple template 1 that reads `Hello, {{.}}!`,
    where `{{.}}` is a placeholder for part of your response. Templates derived from
    the `html/template` package automatically escape HTML characters when you populate
    them and write the results to the response writer 6. HTML-escaping explains the
    funky characters in [Listing 9-2](#listing9-2)’s second test case. The client’s
    browser will properly display the characters instead of interpreting them as part
    of the HTML and JavaScript in the response body. The bottom line is to always
    use the `html/template` package when writing untrusted data to a response writer.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Handlers with httptest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saying “make sure you test your code” is the developer’s equivalent of my mother
    telling me to clean my bedroom. It’s good advice, but I’d much rather continue
    hacking away than write test code. But my mother was correct, and writing test
    code now will serve me well in the future. The Go standard library architects—motivated
    by clean bedrooms, no doubt—made sure to give us the `net/http/httptest` package.
    This package makes unit-testing handlers painless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `net/http/httptest` package exports a `NewRequest` function that accepts
    an HTTP method, a target resource, and a request body `io.Reader`. It returns
    a pointer to an `http.Request` ready for use in an `http.Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unlike its `http.NewRequest` equivalent, `httptest.NewRequest` will panic instead
    of returning an error. This is preferable in tests but not in production code.
  prefs: []
  type: TYPE_NORMAL
- en: The `httptest.NewRecorder` function returns a pointer to an `httptest.ResponseRecorder`,
    which implements the `http.ResponseWriter` interface. Although the `httptest.ResponseRecorder`
    exports fields that look tempting to use (I don’t want to tempt you by mentioning
    them), I recommend you call its `Result` method instead. The `Result` method returns
    a pointer to an `http.Response` object, just like the one we used in the last
    chapter. As the method’s name implies, it waits until the handler returns before
    retrieving the `httptest.ResponseRecorder`‘s results.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in performing integration tests, the `net/http/httptest`
    package includes a test server implementation. For the purposes of this chapter,
    we’ll use `httptest.NewRequest` and `httptest.NewRecorder`.
  prefs: []
  type: TYPE_NORMAL
- en: How You Write the Response Matters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s one potential pitfall: the order in which you write to the response
    body and set the response status code matters. The client receives the response
    status code first, followed by the response body from the server. If you write
    the response body first, Go infers that the response status code is 200 OK and
    sends it along to the client before sending the response body. To see this in
    action, look at [Listing 9-5](#listing9-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: Writing the status first and the response body second for expected
    results (*handlers/pitfall_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it may seem like the first handler function generates a response
    status code of 400 Bad Request and the string `Bad request` in the response body.
    But this isn’t what happens. Calling the `ResponseWriter`’s `Write` method causes
    Go to make an implicit call to the response’s `WriteHeader` method with `http.StatusOK`
    for you. Once the response’s status code is set with an explicit or implicit call
    to `WriteHeader`, you cannot change it.
  prefs: []
  type: TYPE_NORMAL
- en: The Go authors made this design choice because they reasoned you’d need to call
    `WriteHeader` only for adverse conditions, and in that case, you should do so
    before you write anything to the response body. Remember, the server sends the
    response status code before the response body. Once the response’s status code
    is set with an explicit or implicit call to `WriteHeader`, you cannot change it
    because it’s likely on its way to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, however, you make a call to the `Write` method 1, which implicitly
    calls `WriteHeader(http.StatusOK)`. Since the status code is not yet set, the
    response code is now 200 OK. The next call to `WriteHeader`2 is effectively a
    no-op because the status code is already set. The response code 200 OK persists
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you switch the order of the calls so you set the status code 4 before
    you write to the response body 5, the response has the proper status code 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the test output to confirm that this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the test output, any writes to the response body before
    you call the `WriteHeader` method result in a 200 OK status code. The only way
    to dictate the response status code is to call the `WriteHeader` method before
    any writes to the response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can improve this code even further by using the `http.Error` function,
    which simplifies the process of writing a response status code and response body.
    For example, you could replace your handlers with this single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function sets the content type to *text/plain*, sets the status code to
    400 Bad Request, and writes the error message to the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Any Type Can Be a Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because `http.Handler` is an interface, you can use it to write powerful constructs
    for handling client requests. Let’s improve upon the default handler from [Listing
    9-4](#listing9-4) by defining a new type that implements the `http.Handler` interface
    in [Listing 9-6](#listing9-6). This type will allow you to appropriately respond
    to specific HTTP methods and will automatically implement the `OPTIONS` method
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Methods map that dynamically routes requests to the right handler
    (*handlers/methods.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: The new type, named `Methods`, is a map 1 whose key is an HTTP method and whose
    value is an `http.Handler`. It has a `ServeHTTP` method 2 to implement the `http.Handler`
    interface, so you can use `Methods` as a handler itself. The `ServeHTTP` method
    first defers a function to drain and close the request body 3, saving the map’s
    handlers from having to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServeHTTP` method looks up the request method in the map and retrieves
    the handler. To protect us from panics, the `ServeHTTP` method makes sure the
    corresponding handler is not `nil`, responding with 500 Internal Server Error
    4 if it is. Otherwise, you call the corresponding handler’s `ServeHTTP` method
    5. The `Methods` type is a multiplexer (router) since it routes requests to the
    appropriate handler.
  prefs: []
  type: TYPE_NORMAL
- en: If the request method isn’t in the map, `ServeHTTP` responds with the Allow
    header 6 and a list of supported methods in the map. All that’s left do now is
    determine whether the client explicitly requested the `OPTIONS`7 method. If so,
    the `ServeHTTP` method returns, resulting in a 200 OK response to the client.
    If not, the client receives a 405 Method Not Allowed response.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-7](#listing9-7) uses the `Methods` handler to implement a better
    default handler than the one found in [Listing 9-4](#listing9-4). The old default
    handler did not automatically add the Allow header and support the `OPTIONS` method.
    This one will, which makes your job a bit easier. All you need to determine is
    which methods your `Methods` handler should support, then implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: Default implementation of the `Methods` handler (*methods.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the handler returned by the `handlers.DefaultMethodsHandler` function supports
    the `GET`, `POST`, and `OPTIONS` methods. The `GET` method simply writes the `Hello,
    friend!` message to the response body 1. The `POST` method greets the client with
    the HTML-escaped request body contents 2. The remaining functionality to support
    the `OPTIONS` method and properly set the Allow header are inherent to the `Methods`
    type’s `ServeHTTP` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler returned by the `handlers.DefaultMethodsHandler` function is a
    drop-in replacement for the handler returned by the `handlers.DefaultHandler`
    function. You can exchange the following snippet of code from [Listing 9-1](#listing9-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'for this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: to take advantage of the added functionality provided by the `Methods` handler.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Dependencies into Handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `http.Handler` interface gives you access to the request and response objects.
    But it’s likely you’ll require access to additional functionality like a logger,
    metrics, cache, or database to handle a request. For example, you may want to
    inject a logger to record request errors or inject a database object to retrieve
    data used to create the response. The easiest way to inject an object into a handler
    is by using a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-8](#listing9-8) demonstrates how to inject a SQL database object
    into an `http.Handler`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: Injecting a dependency into a handler using a closure'
  prefs: []
  type: TYPE_NORMAL
- en: You create a function that accepts a pointer to a SQL database object 1 and
    returns a handler, then assign it to a variable named `dbHandler`. Since this
    function closes over the returned handler, you have access to the `db` variable
    in the handler’s scope 2. Instantiating the handler is as simple as calling `dbHandler`
    and passing in a pointer to a SQL database object 3.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can get a bit cumbersome if you have multiple handlers that require
    access to the same database object or your design is evolving and you’re likely
    to require access to additional objects in the future. A more extensible approach
    is to use a struct whose fields represent objects and data you want to access
    in your handler and to define your handlers as struct methods (see [Listing 9-9](#listing9-9)).
    Injecting dependencies involves adding struct fields instead of modifying a bunch
    of closure definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: Injecting dependencies into multiple handlers defined as struct
    methods'
  prefs: []
  type: TYPE_NORMAL
- en: You define a struct that contains pointers to a database object and a logger
    1. Any method you define on the handler now has access to these objects 2. If
    your handlers require access to additional resources, you simply add fields to
    the struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-10](#listing9-10) illustrates how to use the `Handlers` struct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: Initializing the `Handlers` struct and using its handlers'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming `db`1 is a pointer to a `sql.DB` object, you initialize a `Handlers`
    object and use its methods with `http.Handle`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Middleware comprises reusable functions that accept an `http.Handler` and return
    an `http.Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can use middleware to inspect the request and make decisions based on its
    content before passing it along to the next handler. Or you might use the request
    content to set headers in the response. For example, the middleware could respond
    to the client with an error if the handler requires authentication and an unauthenticated
    client sent the request. Middleware can also collect metrics, log requests, or
    control access to resources, to name a few uses. Best of all, you can reuse them
    on multiple handlers. If you find yourself writing the same handler code over
    and over, ask yourself if you can put the functionality into middleware and reuse
    it across your handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](#listing9-11) shows just a few uses of middleware, such as enforcing
    which methods the handler allows, adding headers to the response, or performing
    ancillary functions like logging.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: Example middleware function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Middleware` function uses a common pattern you first saw in [Listing 9-4](#listing9-4):
    it defines a function that accepts an `http.ResponseWriter` and a pointer to an
    `http.Request`2 and wraps it with an `http.HandlerFunc`1.'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, middleware calls the given handler 5. But in some cases that
    may not be proper, and the middleware should block the next handler and respond
    to the client itself 3. Likewise, you may want to use middleware to collect metrics,
    ensure specific headers are set on the response 4, or write to a log file 6.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](#listing9-11) is a contrived example. I don’t recommend performing
    so many tasks in a single middleware function. Instead, it’s best to follow the
    Unix philosophy and write minimalist middleware, with each function doing one
    thing very well. Ideally, you would split the middleware in [Listing 9-11](#listing9-11)
    into three middleware functions to check the request method and respond to the
    client 3, enforce response headers 4, and collect metrics 6.'
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package includes useful middleware to serve static files, redirect
    requests, and manage request time-outs. Let’s dig into their source code to see
    how you might use them. In addition to these standard library functions, check
    out the middleware at [https://go.dev/](https://go.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: Timing Out Slow Clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned earlier, it’s important not to let clients dictate the duration
    of a request-response life cycle. Malicious clients could use this leniency to
    their ends and exhaust your server’s resources, effectively denying service to
    legit clients. Yet at the same time, setting read and write time-outs server-wide
    makes it hard for the server to stream data or use different time-out durations
    for each handler.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you should manage time-outs in middleware or individual handlers. The
    `net/http` package includes a middleware function that allows you to control the
    duration of a request and response on a per-handler basis. The `http.TimeoutHandler`
    accepts an `http.Handler`, a duration, and a string to write to the response body.
    It sets an internal timer to the given duration. If the `http.Handler` does not
    return before the timer expires, the `http.TimeoutHandler` blocks the `http.Handler`
    and responds to the client with a 503 Service Unavailable status.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-12](#listing9-12) uses the `http.TimeoutHandler` to wrap an `http.Handler`
    that mimics a slow client.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: Giving clients a finite time to read the response (*middleware/timeout_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: Despite its name, `http.TimeoutHandler` is middleware that accepts an `http.Handler`
    and returns an `http.Handler`1. The wrapped `http.Handler` purposefully sleeps
    for a minute 2 to simulate a client’s taking its time to read the response, preventing
    the `http.Handler` from returning. When the handler doesn’t return within one
    second, `http.TimeoutHandler` sets the response status code to 503 Service Unavailable
    3. The test reads the entire response body 4, properly closes it, and makes sure
    the response body has the string written by the middleware 5.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Sensitive Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Middleware can also keep clients from accessing information you’d like to keep
    private. For example, the `http.FileServer` function simplifies the process of
    serving static files to clients, accepting an `http.FileSystem` interface, and
    returning an `http.Handler`. The problem is, it won’t protect against serving
    up potentially sensitive files. Any file in the target directory is fair game.
    By convention, many operating systems store configuration files or other sensitive
    information in files and directories prefixed with a period and then hide these
    dot-prefixed files and directories by default. (This is particularly true in Unix-compatible
    systems.) But the `http.FileServer` will gladly serve dot-prefixed files or traverse
    dot-prefixed directories.
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package documentation includes an example of an `http.FileSystem`
    that prevents the `http.FileServer` from serving dot-prefixed files and directories.
    [Listing 9-13](#listing9-13) takes a different approach by using middleware to
    offer the same protection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-13: Protecting any file or directory with a given prefix (*middleware/restrict_prefix.go*).'
  prefs: []
  type: TYPE_NORMAL
- en: The `RestrictPrefix` middleware 1 examines the URL path 2 to look for any elements
    that start with a given prefix. If the middleware finds an element in the URL
    path with the given prefix, it preempts the `http.Handler` and responds with a
    404 Not Found status 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-14](#listing9-14) uses the `RestrictPrefix` middleware with a series
    of test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-14: Using the `RestrictPrefix` middleware (*middleware/restrict_prefix_test.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize the server first passes the request to the `http.StripPrefix`
    middleware 1, then the `RestrictPrefix` middleware 2, and if the `RestrictPrefix`
    middleware approves the resource path, the `http.FileServer`3. The `RestrictPrefix`
    middleware evaluates the request’s resource path to determine whether the client
    is requesting a restricted path, no matter whether the path exists or not. If
    so, the `RestrictPrefix` middleware responds to the client with an error without
    ever passing the request onto the `http.FileServer`.
  prefs: []
  type: TYPE_NORMAL
- en: The static files served by this test’s `http.FileServer` exist in a directory
    named *files* in the *restrict_prefix_test.go* file’s parent directory. Files
    in the *../files* directory are in the root of the filesystem passed to the `http.FileServer`.
    For example, the *../files/sage.svg* file on the operating system’s filesystem
    is at */sage.svg* in the `http.FileSystem` passed to the `http.FileServer`. If
    a client wanted to retrieve the *sage.svg* file from the `http.FileServer`, the
    request path should be */sage.svg*.
  prefs: []
  type: TYPE_NORMAL
- en: But the URL path for each of our test cases 4 includes the */static/* prefix
    followed by the static filename. This means that the test requests *static/sage.svg*
    from the `http.FileServer`, which doesn’t exist. The test uses another bit of
    middleware from the `net/http` package to solve this path discrepancy. The `http.StripPrefix`
    middleware strips the given prefix from the URL path before passing along the
    request to the `http.Handler`, the `http.FileServer` in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you block access to sensitive files by wrapping the `http.FileServer`
    with the `RestrictPrefix` middleware to prevent the handler from serving any file
    or directory prefixed with a period. The first test case results in a 200 OK status,
    because no element in the URL path has a period prefix. The `http.StripPrefix`
    middleware removes the */static/* prefix from the test case’s URL, changing it
    from */static/sage.svg* to *sage.svg*. It then passes this path to the `http.FileServer`,
    which finds the corresponding file in its `http.FileSystem`. The `http.FileServer`
    writes the file contents to the response body.
  prefs: []
  type: TYPE_NORMAL
- en: The second test case results in a 404 Not Found status because the *.secret*
    filename has a period as its first character. The third case also results in a
    404 Not Found status due to the *.dir* element in the URL path, because your `RestrictPrefix`
    middleware considers the prefix of each segment in the path, not just the file.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach to restricting access to resources would be to block all resources
    by default and explicitly allow select resources. As an exercise, try implementing
    the inverse of the `RestrictPrefix` middleware by creating middleware that permits
    requests for only an allowed list of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One afternoon, I walked into the University of Michigan’s library, the fourth
    largest library in the United States. I was looking for a well-worn copy of Kurt
    Vonnegut’s *Cat’s Cradle* and had no idea where to start my search. I found the
    nearest librarian and asked for help finding the book. When we arrived at the
    correct location, the book was 404 Not Found.
  prefs: []
  type: TYPE_NORMAL
- en: A *multiplexer*, like the friendly librarian routing me to the proper bookshelf,
    is a general handler that routes a request to a specific handler. The `http.ServeMux`
    multiplexer is an `http.Handler` that routes an incoming request to the proper
    handler for the requested resource. By default, `http.ServeMux` responds with
    a 404 Not Found status for all incoming requests, but you can use it to register
    your own patterns and corresponding handlers. It will then compare the request’s
    URL path with its registered patterns, passing the request and response writer
    to the handler that corresponds to the longest matching pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](#listing9-1) used a multiplexer to send all requests to a single
    endpoint. [Listing 9-15](#listing9-15) introduces a slightly more complex multiplexer
    that has three endpoints. This one evaluates the requested resource and routes
    the request to the right endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-15: Registering patterns to a multiplexer and wrapping the entire
    multiplexer with middleware (*mux_test.go*).'
  prefs: []
  type: TYPE_NORMAL
- en: The test creates a new multiplexer and registers three routes using the multiplexer’s
    `HandleFunc` method 3. The first route is simply a forward slash, showing the
    default or empty URL path, and a function that sets the 204 No Content status
    in the response. This route will match all URL paths if no other route matches.
    The second is */hello*4, which writes the string `Hello friend.` to the response.
    The final path is */hello/there/*5, which writes the string `Why, hello there.`
    to the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the third route ends in a forward slash, making it a subtree, while
    the earlier route 4 did not end in a forward slash, making it an absolute path.
    This distinction tends to be a bit confusing for unaccustomed users. Go’s multiplexer
    treats absolute paths as exact matches: either the request’s URL path matches,
    or it doesn’t. By contrast, it treats subtrees as prefix matches. In other words,
    the multiplexer will look for the longest registered pattern that comes at the
    beginning of the request’s URL path. For example, */hello/there/* is a prefix
    of */hello/there/you* but not of */hello/you*.'
  prefs: []
  type: TYPE_NORMAL
- en: Go’s multiplexer can also redirect a URL path that doesn’t end in a forward
    slash, such as */hello/there*. In those cases, the `http.ServeMux` first attempts
    to find a matching absolute path. If that fails, the multiplexer appends a forward
    slash, making the path */hello/there/*, for example, and responds to the client
    with it. This new path becomes a permanent redirect. You’ll see an example of
    this in [Listing 9-16](#listing9-16).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve defined routes for the multiplexer, it’s ready to use. But
    there’s one issue with the handlers: none of them drain and close the request
    body. This isn’t a big concern in a test like this, but you should stick to best
    practices, nonetheless. If you don’t do so in a real scenario, you may cause increased
    overhead and potential memory leaks. Here, you use middleware 1 to drain and close
    the request body. In the `drainAndClose` middleware, you call the `next` handler
    first 2 and then drain and close the request body. There is no harm in draining
    and closing a previously drained and closed request body.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-16](#listing9-16) tests a series of requests against [Listing 9-15](#listing9-15)’s
    multiplexer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-16: Running through a series of test cases and verifying the response
    status code and body (*mux_test.go*).'
  prefs: []
  type: TYPE_NORMAL
- en: The first three test cases 1, including the request for the */hello/there/*
    path, match exact patterns registered with the multiplexer. But the fourth test
    case 2 is different. It doesn’t have an exact match. When the multiplexer appends
    a forward slash to it, however, it discovers that it exactly matches a registered
    pattern. Therefore, the multiplexer responds with a 301 Moved Permanently status
    and a link to the new path in the response body. The fifth test case 3 matches
    the */hello/there/* subtree and receives the `Why, hello there.` response. The
    last three test cases 4 match the default path of */* and receive the 204 No Content
    status.
  prefs: []
  type: TYPE_NORMAL
- en: Just as the test relies on middleware to drain and close the request body, it
    drains 5 and closes 6 the response body.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 Server Pushes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go HTTP server can push resources to clients over HTTP/2, a feature that
    has the potential to improve efficiency. For example, a client may request the
    home page from a web server, but the client won’t know it needs the associated
    style sheet and images to properly render the home page until it receives the
    HTML in the response. An HTTP/2 server can proactively send the style sheet and
    images along with the HTML in the response, saving the client from having to make
    subsequent calls for those resources. But server pushes have the potential for
    abuse. This section shows you how to use server pushes and then discusses cases
    when you should avoid doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Resources to the Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s retrieve the HTML page in [Listing 9-17](#listing9-17) over HTTP/1.1,
    then retrieve the same page over HTTP/2 and compare the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-17: Simple index file having links to two resources (*files/index.html*)'
  prefs: []
  type: TYPE_NORMAL
- en: This HTML file requires the browser to retrieve two more resources, a style
    sheet 1 and an SVG image 2, to properly show the entire page. [Figure 9-2](#figure9-2)
    shows Google Chrome’s request accounting for the HTML when served using HTTP/1.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09002](image_fi/500884c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Downloaded index page and associated resources over HTTP/1.1'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the *favicon.ico* file, which Chrome retrieves on its own, the browser
    made three requests to retrieve all required resources—one for the HTML file,
    one for the style sheet, and one for the SVG image. Any web browser requesting
    the *index.html* file (*localhost* in [Figure 9-2](#figure9-2)) will also request
    the *style.css* and *hiking.svg* files to properly render the *index.html* file.
    The web server could improve efficiency and proactively push these two files to
    the web browser, since it knows the web browser will inevitably request them.
    This proactive approach by the web server would save the web browser from the
    overhead of having to make two more requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](#figure9-3) shows the same retrieval using HTTP/2\. In this case,
    the server pushes the *style.css* and *hiking.svg* files.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](image_fi/500884c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: Downloaded index page with resources pushed by the server side'
  prefs: []
  type: TYPE_NORMAL
- en: The client receives all three resources after a single request to the server
    for the *index.html* file. The Initiator column in [Figure 9-3](#figure9-3) shows
    that Chrome retrieved the resources from its dedicated push cache.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a command line executable that can push resources to clients. [Listing
    9-18](#listing9-18) shows the first part of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-18: Command line arguments for the HTTP/2 server (*server.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: The server needs the path to a certificate 1 and a corresponding private key
    2 to enable TLS support and allow clients to negotiate HTTP/2 with the server.
    If either value is empty, the server will listen for plain HTTP connections. Next,
    pass the command line flag values to a `run` function 3.
  prefs: []
  type: TYPE_NORMAL
- en: The `run` function, defined in [Listing 9-19](#listing9-19), has the bulk of
    your server’s logic and ultimately runs the web server. Breaking this functionality
    into a separate function eases unit testing later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-19: Multiplexer, middleware, and handlers for the HTTP/2 server (*server.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server’s multiplexer has three routes: one for static files 1, one for
    the default route 2, and one for the */2* absolute path 7. If the `http.ResponseWriter`
    is an `http.Pusher`3, it can push resources to the client 5 without a corresponding
    request. You specify the path to the resource from the client’s perspective 4,
    not the file path on the server’s filesystem because the server treats the request
    as if the client originated it to facilitate the server push. After you’ve pushed
    the resources, you serve the response for the handler 6. If, instead, you sent
    the *index.html* file before pushing the associated resources, the client’s browser
    may send requests for the associated resources before it handles the pushes.'
  prefs: []
  type: TYPE_NORMAL
- en: Web browsers cache HTTP/2-pushed resources for the life of the connection and
    make it available across routes. Therefore, if the *index2.html* file served by
    the */2* route 7 references the same resources pushed by the default route, and
    the client first visits the default route, the client’s web browser may use the
    pushed resources when rendering the */2* route.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have one more task to complete: instantiate an HTTP server to serve your
    resources. [Listing 9-20](#listing9-20) does this by making use of the multiplexer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-20: HTTP/2-capable server implementation (*server.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives an `os.Interrupt` signal 1, it triggers a call to the
    server’s `Shutdown` method 2. Unlike the server’s `Close` method, which abruptly
    closes the server’s listener and all active connections, `Shutdown` gracefully
    shuts down the server. It instructs the server to stop listening for incoming
    connections and blocks until all client connections end. This gives the server
    the opportunity to finish sending responses before stopping the server.
  prefs: []
  type: TYPE_NORMAL
- en: If the server receives a path to both a certificate and a corresponding private
    key, the server will enable TLS support by calling its `ListenAndServeTLS` method
    3. If it cannot find or parse either the certificate or private key, this method
    returns an error. In the absence of these paths, the server uses its `ListenAndServe`
    method 4.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and test this server. As mentioned in Chapter 8, Go doesn’t include
    the support needed to test the server’s push functionality with code, but you
    can interact with this program by using your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Be Too Pushy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although HTTP/2 server pushing can improve the efficiency of your communications,
    it can do just the opposite if you aren’t careful. Remember that web browsers
    store pushed resources in a separate cache for the lifetime of the connection.
    If you’re serving resources that don’t change often, the web browser will likely
    already have them in its regular cache, so you shouldn’t push them. Once it caches
    them, the browser can use them for future requests spanning many connections.
    You probably shouldn’t push the resources in [Listing 9-19](#listing9-19), for
    instance, because they’re unlikely to change often.
  prefs: []
  type: TYPE_NORMAL
- en: My advice is to be conservative with server pushes. Use your handlers and rely
    on metrics to figure out when you should push a resource. If you do push resources,
    do so before writing the response.
  prefs: []
  type: TYPE_NORMAL
- en: What You’ve Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go’s `net/http` package includes a capable server implementation. In this chapter,
    you used its handlers, middleware, multiplexer, and HTTP/2 support to process
    client requests intelligently and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s `http.Handler` is an interface that describes an object capable of accepting
    a request and responding with a status code and payload. A special handler, known
    as a *multiplexer*, can parse a request and pass it along to the most proper handler,
    effectively functioning as a request router. *Middleware* is code that augments
    the behavior of handlers or performs auxiliary tasks. It might change the request,
    add headers to the response, collect metrics, or preempt the handler, to name
    a few use cases. Finally, Go’s server supports HTTP/2 over TLS. When it uses HTTP/2,
    the server can push resources to clients, potentially making the communication
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: By putting these features together, you can build comprehensive, useful HTTP-based
    applications with surprisingly little code.
  prefs: []
  type: TYPE_NORMAL
