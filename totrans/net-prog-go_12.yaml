- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building HTTP Services
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 HTTP 服务
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that you’ve written client code to send HTTP requests, let’s build a server
    that can process these requests and send resources to the client. The `net/http`
    package handles most of the implementation details for you, so you can focus on
    instantiating and configuring a server, creating resources, and handling each
    client request.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了发送 HTTP 请求的客户端代码，让我们构建一个能够处理这些请求并将资源发送给客户端的服务器。`net/http` 包为你处理了大多数实现细节，因此你可以专注于实例化和配置服务器、创建资源以及处理每个客户端请求。
- en: 'In Go, an HTTP server relies on several interacting components: handlers, middleware,
    and a multiplexer. When it includes all these parts, we call this server a *web
    service*. We’ll begin by looking at a simple HTTP web service and then explore
    each of its components over the course of the chapter. The big picture should
    help you understand topics that beginners often find abstract.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，一个 HTTP 服务器依赖于几个相互作用的组件：处理程序、中间件和复用器。当它包含所有这些部分时，我们将这个服务器称为 *Web 服务*。我们将从一个简单的
    HTTP Web 服务开始，然后在本章中逐步探讨每个组件。整体框架应该能帮助你理解初学者常常觉得抽象的主题。
- en: You’ll also learn more advanced uses of the `net/http` package, such as adding
    TLS support and pushing data to HTTP/2 clients. By the end, you should feel comfortable
    configuring a Go-based HTTP server, writing middleware, and responding to requests
    with handlers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习 `net/http` 包的更高级用法，例如添加 TLS 支持和将数据推送到 HTTP/2 客户端。到最后，你应该能够自如地配置基于 Go 的
    HTTP 服务器，编写中间件，并使用处理程序响应请求。
- en: The Anatomy of a Go HTTP Server
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go HTTP 服务器的结构
- en: '[Figure 9-1](#figure9-1) illustrates the path a request takes in a typical
    `net/http`-based server.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#figure9-1) 说明了请求在典型的 `net/http` 基于服务器中的路径。'
- en: '![f09001](image_fi/500884c09/f09001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/500884c09/f09001.png)'
- en: 'Figure 9-1: Client request culminating in a server response in the handler'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：客户端请求最终由处理程序响应的服务器
- en: First, the server’s *multiplexer* (*router*, in computer-networking parlance)
    receives the client’s request. The multiplexer determines the destination for
    the request, then passes it along to the object capable of handling it. We call
    this object a *handler*. (The multiplexer itself is a handler that routes requests
    to the most appropriate handler.) Before the handler receives the request, the
    request may pass through one or more functions called *middleware*. Middleware
    changes the handlers’ behavior or performs auxiliary tasks, such as logging, authentication,
    or access control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器的 *复用器*（在计算机网络术语中是 *路由器*）接收客户端的请求。复用器确定请求的目标，然后将其传递给能够处理它的对象。我们称这个对象为
    *处理程序*。（复用器本身就是一个处理程序，它将请求路由到最合适的处理程序。）在处理程序接收到请求之前，请求可能会经过一个或多个称为 *中间件* 的函数。中间件改变处理程序的行为或执行辅助任务，例如日志记录、身份验证或访问控制。
- en: '[Listing 9-1](#listing9-1) creates an HTTP server that follows this basic structure.
    If you have trouble following along, don’t worry; you’ll spend the rest of the
    chapter learning how these parts work.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-1](#listing9-1) 创建一个遵循基本结构的 HTTP 服务器。如果你在跟随过程中遇到困难，别担心；你将花费本章的其余部分来学习这些部分如何工作。'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Instantiating a multiplexer and an HTTP server (*server_test.go*)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：实例化复用器和 HTTP 服务器 (*server_test.go*)
- en: Requests sent to the server’s handler first pass through middleware named `http.TimeoutHandler`1,
    then to the handler returned by the `handlers.DefaultHandler` function. In this
    very simple example, you specify only a single handler for all requests instead
    of relying on a multiplexer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到服务器的处理程序的请求首先经过名为 `http.TimeoutHandler` 的中间件1，然后传递给由 `handlers.DefaultHandler`
    函数返回的处理程序。在这个非常简单的示例中，你为所有请求指定了一个处理程序，而不是依赖于复用器。
- en: The server has a few fields. The `Handler` field accepts a multiplexer or other
    object capable of handling client requests. The `Address` field should look familiar
    to you by now. In this example, you want the server to listen to port 8081 on
    IP address 127.0.0.1\. I’ll explain the `IdleTimeout` and `ReadHeaderTimeout`
    fields in the next section. Suffice it to say now, you should always define these
    two fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有几个字段。`Handler` 字段接受一个复用器或其他能够处理客户端请求的对象。`Address` 字段你现在应该已经很熟悉了。在这个示例中，你希望服务器监听
    IP 地址 127.0.0.1 上的端口 8081。我将在下一节中解释 `IdleTimeout` 和 `ReadHeaderTimeout` 字段。现在可以简单地说，你应该始终定义这两个字段。
- en: Finally, you create a new `net.Listener` bound to the server’s address 2 and
    instruct the server to `Serve`3 requests from this listener. The `Serve` method
    returns `http.ErrServerClosed` when it closes normally.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建一个新的`net.Listener`并将其绑定到服务器的地址2，然后指示服务器从这个监听器3处理请求。`Serve`方法在正常关闭时返回`http.ErrServerClosed`。
- en: Now let’s test this server. [Listing 9-2](#listing9-2) picks up where [Listing
    9-1](#listing9-1) leaves off. It details a few test requests and their expected
    results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来测试这个服务器。[列表9-2](#listing9-2)从[列表9-1](#listing9-1)开始，详细介绍了一些测试请求及其预期结果。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Request test cases for the HTTP server (*server_test.go*)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-2：HTTP服务器的请求测试用例（*server_test.go*）
- en: First, you send a `GET` request 1, which results in a 200 OK status code. The
    response body has the `Hello, friend!` string.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你发送了一个`GET`请求1，结果返回了一个200 OK状态码。响应体中包含字符串`Hello, friend!`。
- en: 'In the second test case 2, you send a `POST` request with the string `<world>`
    in its body. The angle brackets are intentional, and they show an often-overlooked
    aspect of handling client input in the handler: always escape client input. You’ll
    learn about escaping client input in “Handlers” on page 193. This test case results
    in the string `Hello, &lt;world&gt;!` in the response body. The response looks
    a bit silly, but your web browser renders it as `Hello, <world>!`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试用例2中，你发送了一个`POST`请求，其主体包含字符串`<world>`。尖括号是故意的，它们展示了处理客户端输入时常被忽视的一个方面：始终对客户端输入进行转义。你将在第193页的“处理器”中学习到如何转义客户端输入。这个测试用例的响应体是字符串`Hello,
    &lt;world&gt;!`。响应看起来有些傻，但你的Web浏览器会将其渲染为`Hello, <world>!`。
- en: The third test case 3 a sends a `HEAD` request to the HTTP server. The handler
    returned by the `handlers.DefaultHandler` function, which you’ll explore shortly,
    does not handle the `HEAD` method. Therefore, it returns a 405 Method Not Allowed
    status code and an empty response body.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个测试用例3a向HTTP服务器发送了一个`HEAD`请求。由`handlers.DefaultHandler`函数返回的处理器将不会处理`HEAD`方法。因此，它返回了405
    Method Not Allowed状态码和一个空的响应体。
- en: '[Listing 9-3](#listing9-3) continues the code in [Listing 9-2](#listing9-2)
    and runs through each test case.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9-3](#listing9-3)继续了[列表9-2](#listing9-2)中的代码，并逐一执行每个测试用例。'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: Sending test requests to the HTTP server (*server_test.go*)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-3：向HTTP服务器发送测试请求（*server_test.go*）
- en: First, you create a new request, passing the parameters from the test case 1.
    Next, you pass the request to the client’s `Do` method 2, which returns the server’s
    response. You then check the status code and read in the entire response body
    3. You should be in the habit of consistently closing the response body if the
    client did not return an error 4, even if the response body is empty or you ignore
    it entirely. Failure to do so may prevent the client from reusing the underlying
    TCP connection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个新的请求，将测试用例1中的参数传递进去。接着，你将请求传递给客户端的`Do`方法2，它返回服务器的响应。然后，你检查状态码并读取整个响应体3。如果客户端没有返回错误4，你应该养成始终关闭响应体的习惯，即使响应体为空或完全忽略它。不这样做可能会阻止客户端重用底层TCP连接。
- en: Once all tests complete, you call the server’s `Close` method 5. This causes
    its `Serve` method in [Listing 9-1](#listing9-1) to return, stopping the server.
    The `Close` method abruptly closes client connections. You’ll see an example of
    the HTTP server’s graceful shutdown support when we discuss HTTP/2 pushes later
    in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试完成，你调用服务器的`Close`方法5。这会导致其在[列表9-1](#listing9-1)中的`Serve`方法返回，从而停止服务器。`Close`方法会突然关闭客户端连接。稍后在本章讨论HTTP/2推送时，你将看到HTTP服务器的优雅关闭支持的示例。
- en: Go’s HTTP server supports a few other features, which we’ll explore in the following
    sections. It can proactively serve, or push, resources to clients. It also offers
    graceful shutdown support. Abruptly shutting down your web server may leave some
    clients in an awkward state if they were waiting for a response when you stopped
    the server, because those clients will never receive a response. Graceful shutdowns
    allow for all pending responses to reach each client before the server is stopped.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go的HTTP服务器支持一些其他功能，我们将在接下来的章节中探讨。它可以主动向客户端提供或推送资源。它还提供了优雅关闭的支持。突然关闭你的Web服务器可能会使一些客户端处于尴尬状态，因为如果它们在你停止服务器时正在等待响应，它们将永远收不到响应。优雅关闭允许所有待处理的响应在服务器停止前到达每个客户端。
- en: Clients Don’t Respect Your Time
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端不尊重你的时间
- en: Just as I recommended setting the client’s time-out values, I recommend that
    you manage the various server time-out values, for the simple reason that clients
    won’t otherwise respect your server’s time. A client can take its sweet time sending
    a request to your server. Meanwhile, your server uses resources waiting to receive
    the request in its entirety. Likewise, your server is at the client’s mercy when
    it sends the response because it can send data only as fast as the client reads
    it (or can send only as much as there is TCP buffer space available). Avoid letting
    the client dictate the duration of a request-response life cycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我建议设置客户端的超时值一样，我建议你管理各种服务器超时值，原因很简单，否则客户端不会尊重你的服务器时间。客户端可以慢慢地将请求发送到你的服务器。而你的服务器则在等待完整请求的过程中占用了资源。同样，当服务器发送响应时，它也处于客户端的掌控之中，因为它只能以客户端读取数据的速度发送数据（或者只能发送到TCP缓冲区可用的空间）。避免让客户端决定请求-响应生命周期的持续时间。
- en: '[Listing 9-1](#listing9-1) includes a server instance with two of its time-out
    values specified: the length of time clients can remain idle between requests
    and how long the server should wait to read a request header:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9-1](#listing9-1)包含了一个服务器实例，其中指定了两个超时值：客户端在请求之间可以保持空闲的时间以及服务器应等待多长时间来读取请求头：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although several time-out fields on the `http.Server` are available to you,
    I recommend setting only the `IdleTimeout` and `ReadHeaderTimeout` fields. The
    `IdleTimeout` field dictates how long the server will keep its side of the TCP
    socket open while waiting for the next client request when the communication uses
    keepalives. The `ReadHeaderTimeout` value determines how long the server will
    wait to finish reading the request headers. Keep in mind that this duration has
    no bearing on the time it takes to read the request body.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`http.Server`上有多个超时字段可供使用，但我建议只设置`IdleTimeout`和`ReadHeaderTimeout`字段。`IdleTimeout`字段决定了服务器在使用保活连接时，等待下一个客户端请求时TCP套接字保持打开的时间。`ReadHeaderTimeout`值决定了服务器在读取完请求头之前会等待多久。请记住，这个时间段与读取请求体所需的时间无关。
- en: If you want to enforce a time limit for reading an incoming request across all
    handlers, you could manage the request deadline by using the `ReadTimeout` field.
    If the client hasn’t sent the complete request (the headers and body) by the time
    the `ReadTimeout` duration elapses, the server ends the TCP connection. Likewise,
    you could give the client a finite duration in which to send the request and read
    the response by using the `WriteTimeout` field. The `ReadTimeout` and `WriteTimeout`
    values apply to all requests and responses because they dictate the `ReadDeadline`
    and `WriteDeadline` values of the TCP socket, as discussed in Chapter 4.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在所有处理程序中强制执行读取传入请求的时间限制，可以通过使用`ReadTimeout`字段来管理请求的截止时间。如果客户端在`ReadTimeout`持续时间内未能发送完整的请求（包括头部和正文），服务器将结束TCP连接。同样，你也可以通过使用`WriteTimeout`字段为客户端设置一个有限的时间，在此时间内发送请求并读取响应。`ReadTimeout`和`WriteTimeout`值适用于所有请求和响应，因为它们决定了TCP套接字的`ReadDeadline`和`WriteDeadline`值，正如在第4章中讨论的那样。
- en: These blanket time-out values may be inappropriate for handlers that expect
    clients to send large files in a request body or handlers that indefinitely stream
    data to the client. In these two examples, the request or response may abruptly
    time out even if everything went ahead as expected. Instead, a good practice is
    to rely on the `ReadHeaderTimeout` value. You can separately manage the time it
    takes to read the request body and send the response using middleware or handlers.
    This gives you the greatest control over request and response durations per resource.
    You’ll learn how to manage the request-response duration by using middleware in
    “Middleware” on page 202.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用的超时值可能不适用于那些期望客户端在请求体中发送大文件的处理程序，或者那些无限期地将数据流式传输到客户端的处理程序。在这两种情况下，即使一切按预期进行，请求或响应仍然可能突然超时。相反，一个好的做法是依赖`ReadHeaderTimeout`值。你可以通过中间件或处理程序单独管理读取请求体和发送响应所需的时间。这为你提供了对每个资源的请求和响应持续时间的最大控制。你将在第202页的“中间件”一节中学到如何通过中间件管理请求-响应持续时间。
- en: Adding TLS Support
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加TLS支持
- en: 'HTTP traffic is plaintext by default, but web clients and servers can use HTTP
    over an encrypted TLS connection, a combination known as *HTTPS*. Go’s HTTP server
    enables HTTP/2 support over TLS connections only, but enabling TLS is a simple
    matter. You need to modify only two lines from [Listing 9-1](#listing9-1)’s server
    implementation: the port number and the `Serve` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 流量默认是明文的，但网页客户端和服务器可以通过加密的 TLS 连接使用 HTTP，这种组合被称为*HTTPS*。Go 的 HTTP 服务器仅支持通过
    TLS 连接使用 HTTP/2，但启用 TLS 是一件简单的事。你只需要修改 [Listing 9-1](#listing9-1) 中服务器实现的两行代码：端口号和
    `Serve` 方法：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Technically, you don’t need to change the port number 1, but the convention
    is to serve HTTPS over port 443, or an augmentation of port 443, like 8443\. Using
    the server’s `ServeTLS` method, you instruct the server to use TLS over HTTP 2.
    The `ServeTLS` method requires the path to both a certificate and a corresponding
    private key. I recommend you check out the mkcert project at [https://github.com/FiloSottile/mkcert/](https://github.com/FiloSottile/mkcert/)
    to get a key pair. You can use mkcert to create locally trusted key pairs for
    development purposes only. For production use, you should consider using and supporting
    Let’s Encrypt at [https://letsencrypt.org/](https://letsencrypt.org/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你不需要更改端口号 1，但惯例是通过端口 443 提供 HTTPS 服务，或者使用端口 443 的扩展端口，如 8443。通过服务器的 `ServeTLS`
    方法，你指示服务器在 HTTP 2 上使用 TLS。`ServeTLS` 方法需要证书和相应私钥的路径。我建议你查看 mkcert 项目，网址为 [https://github.com/FiloSottile/mkcert/](https://github.com/FiloSottile/mkcert/)，以获取密钥对。你可以使用
    mkcert 仅为开发目的创建本地信任的密钥对。对于生产用途，你应该考虑使用并支持 Let’s Encrypt，网址为 [https://letsencrypt.org/](https://letsencrypt.org/)。
- en: Handlers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器
- en: When a client sends a request to an HTTP server, the server needs to figure
    out what to do with it. The server may need to retrieve various resources or perform
    an action, depending on what the client requests. A common design pattern is to
    specify bits of code to handle these requests, known as *handlers*. You may have
    a handler that knows how to retrieve an image and another handler that knows how
    to retrieve information from a database. We’ll discuss how the server figures
    out which handler is most apt for each request in “Multiplexers” on page 207.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向 HTTP 服务器发送请求时，服务器需要弄清楚如何处理该请求。根据客户端请求的内容，服务器可能需要检索各种资源或执行某个操作。一个常见的设计模式是指定一些代码来处理这些请求，这些代码称为*处理器*。你可能有一个处理器知道如何检索图片，另一个处理器知道如何从数据库中检索信息。我们将在第
    207 页的“多路复用器”一节中讨论服务器如何确定哪个处理器最适合每个请求。
- en: 'In Go, handlers are objects that implement the `http.Handler` interface. They
    read client requests and write responses. The `http.Handler` interface consists
    of a single method to receive both the response and the request:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，处理器是实现了 `http.Handler` 接口的对象。它们读取客户端请求并写入响应。`http.Handler` 接口由一个方法组成，用于接收响应和请求：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any object that implements the `http.Handler` interface may handle client requests,
    as far as the Go HTTP server is concerned. We often define handlers as functions,
    as in this common pattern:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了 `http.Handler` 接口的对象都可以处理客户端请求，就 Go HTTP 服务器而言。我们通常将处理器定义为函数，如下所示的常见模式：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you wrap a function that accepts an `http.ResponseWriter` and an `http.Request`
    pointer in the `http.HandlerFunc` type, which implements the `Handler` interface.
    This results in an `http.HandlerFunc` object that calls the wrapped `func(w http.ResponseWriter,
    r *http.Request)` function when the server calls its `ServeHTTP` method. This
    handler responds to the client with the string `Hello, world!` in the response
    body.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将一个接受 `http.ResponseWriter` 和 `http.Request` 指针的函数包装在 `http.HandlerFunc`
    类型中，该类型实现了 `Handler` 接口。这会生成一个 `http.HandlerFunc` 对象，当服务器调用其 `ServeHTTP` 方法时，会调用包装的
    `func(w http.ResponseWriter, r *http.Request)` 函数。这个处理器会在响应体中向客户端返回字符串 `Hello,
    world!`。
- en: Notice that you ignore the number of written bytes and any potential write error.
    In the wild, writes to a client can fail for any number of reasons. It isn’t worth
    logging these errors. Instead, one option is to keep track of the write error
    frequency and have your server send you an alert should the number of errors exceed
    an appropriate threshold. You’ll learn about instrumenting your code in Chapter
    13.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你忽略了写入字节数和任何潜在的写入错误。在实际应用中，写入客户端可能由于各种原因失败。记录这些错误是没有意义的。相反，一种选择是跟踪写入错误的频率，并在错误次数超过适当阈值时让服务器发送警报。你将在第
    13 章学习如何为代码添加监控功能。
- en: Now that you’re familiar with the structure of a handler, let’s have a look
    at the handler returned by the `handlers.DefaultHandler` function in [Listing
    9-4](#listing9-4).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了处理器的结构，让我们来看看`handlers.DefaultHandler`函数返回的处理器，见[清单9-4](#listing9-4)。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-4: The default handler implementation (*handlers/default.go*)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-4：默认处理器实现（*handlers/default.go*）
- en: The `handlers.DefaultHandler` function returns a function converted to the `http.HandlerFunc`
    type. The `http.HandlerFunc` type implements the `http.Handler` interface. Go
    programmers commonly convert a function with the signature `func(w http.ResponseWriter,
    r *http.Request)` to the `http.HandlerFunc` type so the function implements the
    `http.Handler` interface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers.DefaultHandler`函数返回一个转换为`http.HandlerFunc`类型的函数。`http.HandlerFunc`类型实现了`http.Handler`接口。Go程序员通常会将签名为`func(w
    http.ResponseWriter, r *http.Request)`的函数转换为`http.HandlerFunc`类型，这样该函数就实现了`http.Handler`接口。'
- en: The first bit of code you see is a deferred function that drains and closes
    the request body 2. Just as it’s important for the client to drain and close the
    response body to reuse the TCP session, it’s important for the server to do the
    same with the request body. But unlike the Go HTTP client, closing the request
    body does not implicitly drain it. Granted, the `http.Server` will close the request
    body for you, but it won’t drain it. To make sure you can reuse the TCP session,
    I recommend you drain the request body at a minimum. Closing it is optional.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的第一段代码是一个延迟函数，用于清空并关闭请求体2。就像客户端需要清空并关闭响应体以重用TCP连接一样，服务器也需要对请求体执行相同的操作。但与Go
    HTTP客户端不同，关闭请求体并不会自动清空它。虽然`http.Server`会为你关闭请求体，但它不会清空它。为了确保可以重用TCP连接，我建议至少清空请求体。关闭它是可选的。
- en: The handler responds differently depending on the request method 3. If the client
    sent a `GET` request, the handler writes `Hello, friend!` to the response writer.
    If the request method is a `POST`, the handler first reads the entire request
    body. If an error occurs while reading the request body, the handler uses the
    `http.Error` function 4 to succinctly write the message `Internal server error`
    to the response body and set the response status code to 500\. Otherwise, the
    handler returns a greeting using the request body contents. If the handler receives
    any other request method, it responds with a 405 Method Not Allowed status 5.
    The 405 response is technically not RFC-compliant without an Allow header showing
    which methods the handler accepts. We’ll shore up this deficiency in “Any Type
    Can Be a Handler” on page 198. Finally, the handler writes the response body.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该处理器根据请求方法做出不同的响应3。如果客户端发送的是`GET`请求，处理器会向响应写入`Hello, friend!`。如果请求方法是`POST`，处理器首先读取整个请求体。如果在读取请求体时发生错误，处理器会使用`http.Error`函数4简洁地将`Internal
    server error`消息写入响应体，并将响应状态码设置为500。否则，处理器会返回一个包含请求体内容的问候消息。如果处理器收到任何其他请求方法，它会以405
    Method Not Allowed状态响应5。技术上讲，405响应没有遵循RFC规范，因为没有Allow头显示处理器接受哪些方法。我们将在《任何类型都可以是处理器》中（第198页）补充这一缺陷。最后，处理器写入响应体。
- en: This code could have a security vulnerability since part of the response body
    might come from the request body. A malicious client can send a request payload
    that includes JavaScript, which could run on a client’s computer. This behavior
    can lead to an XSS attack. To prevent these attacks, you must properly escape
    all client-supplied content before sending it in a response. Here, you use the
    `html/template` package to create a simple template 1 that reads `Hello, {{.}}!`,
    where `{{.}}` is a placeholder for part of your response. Templates derived from
    the `html/template` package automatically escape HTML characters when you populate
    them and write the results to the response writer 6. HTML-escaping explains the
    funky characters in [Listing 9-2](#listing9-2)’s second test case. The client’s
    browser will properly display the characters instead of interpreting them as part
    of the HTML and JavaScript in the response body. The bottom line is to always
    use the `html/template` package when writing untrusted data to a response writer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能存在安全漏洞，因为响应体的部分内容可能来自请求体。恶意客户端可以发送一个包含 JavaScript 的请求负载，这些脚本可能会在客户端的计算机上运行。这种行为可能导致
    XSS 攻击。为了防止这些攻击，你必须在将客户端提供的内容发送到响应中之前，正确地对其进行转义。在这里，你使用 `html/template` 包创建一个简单的模板
    1，该模板读取 `Hello, {{.}}!`，其中 `{{.}}` 是响应部分内容的占位符。由 `html/template` 包衍生的模板会在你填充它们并将结果写入响应写入器时，自动对
    HTML 字符进行转义。[Listing 9-2](#listing9-2) 中第二个测试用例解释了 HTML 转义的字符。客户端的浏览器将正确显示这些字符，而不是将它们解释为响应体中的
    HTML 和 JavaScript。最重要的是，在将不可信的数据写入响应写入器时，始终使用 `html/template` 包。
- en: Test Your Handlers with httptest
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 httptest 测试你的处理程序
- en: Saying “make sure you test your code” is the developer’s equivalent of my mother
    telling me to clean my bedroom. It’s good advice, but I’d much rather continue
    hacking away than write test code. But my mother was correct, and writing test
    code now will serve me well in the future. The Go standard library architects—motivated
    by clean bedrooms, no doubt—made sure to give us the `net/http/httptest` package.
    This package makes unit-testing handlers painless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 说“确保你测试你的代码”就像是开发者的等同于我妈妈告诉我要整理我的卧室。这是个好建议，但我更愿意继续编写代码，而不是写测试代码。但我妈妈是对的，现在编写测试代码将对我未来有很大帮助。Go
    标准库的架构师们——无疑是受到整洁卧室的启发——确保给了我们 `net/http/httptest` 包。这个包让单元测试处理程序变得轻松。
- en: 'The `net/http/httptest` package exports a `NewRequest` function that accepts
    an HTTP method, a target resource, and a request body `io.Reader`. It returns
    a pointer to an `http.Request` ready for use in an `http.Handler`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http/httptest` 包导出了一个 `NewRequest` 函数，接受 HTTP 方法、目标资源和请求体 `io.Reader`。它返回一个指向
    `http.Request` 的指针，准备在 `http.Handler` 中使用：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unlike its `http.NewRequest` equivalent, `httptest.NewRequest` will panic instead
    of returning an error. This is preferable in tests but not in production code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其 `http.NewRequest` 等效方法不同，`httptest.NewRequest` 会引发 panic，而不是返回错误。这在测试中是可取的，但在生产代码中并不适用。
- en: The `httptest.NewRecorder` function returns a pointer to an `httptest.ResponseRecorder`,
    which implements the `http.ResponseWriter` interface. Although the `httptest.ResponseRecorder`
    exports fields that look tempting to use (I don’t want to tempt you by mentioning
    them), I recommend you call its `Result` method instead. The `Result` method returns
    a pointer to an `http.Response` object, just like the one we used in the last
    chapter. As the method’s name implies, it waits until the handler returns before
    retrieving the `httptest.ResponseRecorder`‘s results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptest.NewRecorder` 函数返回一个指向 `httptest.ResponseRecorder` 的指针，该类型实现了 `http.ResponseWriter`
    接口。尽管 `httptest.ResponseRecorder` 导出了看起来很诱人的字段（我不想诱惑你提到它们），但我建议你改为调用它的 `Result`
    方法。`Result` 方法返回一个指向 `http.Response` 对象的指针，就像我们在上一章中使用的那样。正如方法名所示，它会等到处理程序返回后，再获取
    `httptest.ResponseRecorder` 的结果。'
- en: If you’re interested in performing integration tests, the `net/http/httptest`
    package includes a test server implementation. For the purposes of this chapter,
    we’ll use `httptest.NewRequest` and `httptest.NewRecorder`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣进行集成测试，`net/http/httptest` 包包含了一个测试服务器的实现。为了本章的目的，我们将使用 `httptest.NewRequest`
    和 `httptest.NewRecorder`。
- en: How You Write the Response Matters
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应的编写方式很重要
- en: 'Here’s one potential pitfall: the order in which you write to the response
    body and set the response status code matters. The client receives the response
    status code first, followed by the response body from the server. If you write
    the response body first, Go infers that the response status code is 200 OK and
    sends it along to the client before sending the response body. To see this in
    action, look at [Listing 9-5](#listing9-5).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个潜在的陷阱：你向响应体写入内容和设置响应状态码的顺序非常重要。客户端首先接收到响应状态码，然后是来自服务器的响应体。如果你先写入响应体，Go
    会推断响应状态码是 200 OK，并在发送响应体之前将其发送给客户端。要查看这一点的实际效果，请查看[示例 9-5](#listing9-5)。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-5: Writing the status first and the response body second for expected
    results (*handlers/pitfall_test.go*)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5：首先写入状态码，然后写入响应体以获得预期结果（*handlers/pitfall_test.go*）
- en: At first glance, it may seem like the first handler function generates a response
    status code of 400 Bad Request and the string `Bad request` in the response body.
    But this isn’t what happens. Calling the `ResponseWriter`’s `Write` method causes
    Go to make an implicit call to the response’s `WriteHeader` method with `http.StatusOK`
    for you. Once the response’s status code is set with an explicit or implicit call
    to `WriteHeader`, you cannot change it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，可能会觉得第一个处理程序函数生成了 400 Bad Request 的响应状态码，并且在响应体中返回了字符串`Bad request`。但实际情况并非如此。调用`ResponseWriter`的`Write`方法会使
    Go 隐式地调用响应的`WriteHeader`方法，并为你设置`http.StatusOK`。一旦通过显式或隐式调用`WriteHeader`设置了响应的状态码，你就无法更改它。
- en: The Go authors made this design choice because they reasoned you’d need to call
    `WriteHeader` only for adverse conditions, and in that case, you should do so
    before you write anything to the response body. Remember, the server sends the
    response status code before the response body. Once the response’s status code
    is set with an explicit or implicit call to `WriteHeader`, you cannot change it
    because it’s likely on its way to the client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的开发者做出这个设计选择是因为他们认为你只需要在出现不良情况时调用`WriteHeader`，在这种情况下，你应该在向响应体写入任何内容之前调用它。记住，服务器在响应体之前发送响应状态码。一旦通过显式或隐式调用`WriteHeader`设置了响应的状态码，你就无法更改它，因为它很可能已经在发送给客户端的路上。
- en: In this example, however, you make a call to the `Write` method 1, which implicitly
    calls `WriteHeader(http.StatusOK)`. Since the status code is not yet set, the
    response code is now 200 OK. The next call to `WriteHeader`2 is effectively a
    no-op because the status code is already set. The response code 200 OK persists
    3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，你调用了`Write`方法1，这隐式地调用了`WriteHeader(http.StatusOK)`。由于状态码尚未设置，响应码现在是
    200 OK。接下来的`WriteHeader`调用2实际上是一个无操作，因为状态码已经设置。响应码 200 OK 会持续存在3。
- en: Now, if you switch the order of the calls so you set the status code 4 before
    you write to the response body 5, the response has the proper status code 6.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你交换调用的顺序，将状态码4设置在写入响应体5之前，响应将具有正确的状态码6。
- en: 'Let’s have a look at the test output to confirm that this is the case:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下测试输出，确认这一点：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the test output, any writes to the response body before
    you call the `WriteHeader` method result in a 200 OK status code. The only way
    to dictate the response status code is to call the `WriteHeader` method before
    any writes to the response body.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从测试输出中看到的，任何在调用`WriteHeader`方法之前写入响应体的操作都会导致 200 OK 状态码。唯一能决定响应状态码的方法是先调用`WriteHeader`方法，再进行任何响应体的写入。
- en: 'You can improve this code even further by using the `http.Error` function,
    which simplifies the process of writing a response status code and response body.
    For example, you could replace your handlers with this single line of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`http.Error`函数进一步优化这段代码，它简化了写入响应状态码和响应体的过程。例如，你可以用这一行代码替换你的处理程序：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function sets the content type to *text/plain*, sets the status code to
    400 Bad Request, and writes the error message to the response body.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将内容类型设置为*text/plain*，将状态码设置为 400 Bad Request，并将错误信息写入响应体。
- en: Any Type Can Be a Handler
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何类型都可以作为处理程序
- en: Because `http.Handler` is an interface, you can use it to write powerful constructs
    for handling client requests. Let’s improve upon the default handler from [Listing
    9-4](#listing9-4) by defining a new type that implements the `http.Handler` interface
    in [Listing 9-6](#listing9-6). This type will allow you to appropriately respond
    to specific HTTP methods and will automatically implement the `OPTIONS` method
    for you.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`http.Handler`是一个接口，你可以利用它编写强大的构造来处理客户端请求。通过在[清单 9-4](#listing9-4)的基础上定义一个实现`http.Handler`接口的新类型，我们可以改进默认的处理器，这个新类型会允许你针对特定的HTTP方法作出适当的响应，并且会自动为你实现`OPTIONS`方法。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-6: Methods map that dynamically routes requests to the right handler
    (*handlers/methods.go*)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-6：动态路由请求到正确处理器的方法映射（*handlers/methods.go*）
- en: The new type, named `Methods`, is a map 1 whose key is an HTTP method and whose
    value is an `http.Handler`. It has a `ServeHTTP` method 2 to implement the `http.Handler`
    interface, so you can use `Methods` as a handler itself. The `ServeHTTP` method
    first defers a function to drain and close the request body 3, saving the map’s
    handlers from having to do so.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 新类型`Methods`是一个映射 1，其键是HTTP方法，值是一个`http.Handler`。它有一个`ServeHTTP`方法 2 来实现`http.Handler`接口，因此你可以将`Methods`本身作为处理器。`ServeHTTP`方法首先延迟一个函数来清空并关闭请求体
    3，避免映射中的处理器需要执行此操作。
- en: The `ServeHTTP` method looks up the request method in the map and retrieves
    the handler. To protect us from panics, the `ServeHTTP` method makes sure the
    corresponding handler is not `nil`, responding with 500 Internal Server Error
    4 if it is. Otherwise, you call the corresponding handler’s `ServeHTTP` method
    5. The `Methods` type is a multiplexer (router) since it routes requests to the
    appropriate handler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeHTTP`方法在映射中查找请求方法并检索处理器。为了避免程序崩溃，`ServeHTTP`方法确保相应的处理器不为`nil`，如果是`nil`，则返回500内部服务器错误。否则，它会调用相应处理器的`ServeHTTP`方法。`Methods`类型是一个多路复用器（路由器），因为它将请求路由到适当的处理器。'
- en: If the request method isn’t in the map, `ServeHTTP` responds with the Allow
    header 6 and a list of supported methods in the map. All that’s left do now is
    determine whether the client explicitly requested the `OPTIONS`7 method. If so,
    the `ServeHTTP` method returns, resulting in a 200 OK response to the client.
    If not, the client receives a 405 Method Not Allowed response.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求方法不在映射中，`ServeHTTP`方法会响应Allow头 6 和映射中支持的所有方法列表。现在你只需要判断客户端是否明确请求了`OPTIONS`方法。如果请求了，`ServeHTTP`方法会返回，向客户端发送200
    OK响应。如果没有请求，客户端会收到405方法不允许的响应。
- en: '[Listing 9-7](#listing9-7) uses the `Methods` handler to implement a better
    default handler than the one found in [Listing 9-4](#listing9-4). The old default
    handler did not automatically add the Allow header and support the `OPTIONS` method.
    This one will, which makes your job a bit easier. All you need to determine is
    which methods your `Methods` handler should support, then implement them.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-7](#listing9-7)使用`Methods`处理器来实现一个比[清单 9-4](#listing9-4)中的默认处理器更好的处理器。旧的默认处理器没有自动添加Allow头，也没有支持`OPTIONS`方法。这个新处理器则会支持，因此它能让你的工作变得更加轻松。你只需要确定你的`Methods`处理器应该支持哪些方法，然后实现它们。'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-7: Default implementation of the `Methods` handler (*methods.go*)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-7：`Methods`处理器的默认实现（*methods.go*）
- en: Now, the handler returned by the `handlers.DefaultMethodsHandler` function supports
    the `GET`, `POST`, and `OPTIONS` methods. The `GET` method simply writes the `Hello,
    friend!` message to the response body 1. The `POST` method greets the client with
    the HTML-escaped request body contents 2. The remaining functionality to support
    the `OPTIONS` method and properly set the Allow header are inherent to the `Methods`
    type’s `ServeHTTP` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`handlers.DefaultMethodsHandler`函数返回的处理器支持`GET`、`POST`和`OPTIONS`方法。`GET`方法仅将`Hello,
    friend!`消息写入响应体 1。`POST`方法会以HTML转义的请求体内容向客户端问好 2。支持`OPTIONS`方法并正确设置Allow头的剩余功能是`Methods`类型的`ServeHTTP`方法自带的。
- en: 'The handler returned by the `handlers.DefaultMethodsHandler` function is a
    drop-in replacement for the handler returned by the `handlers.DefaultHandler`
    function. You can exchange the following snippet of code from [Listing 9-1](#listing9-1):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers.DefaultMethodsHandler`函数返回的处理器是对`handlers.DefaultHandler`函数返回的处理器的替代。你可以将[清单
    9-1](#listing9-1)中的以下代码片段替换掉：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'for this code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: to take advantage of the added functionality provided by the `Methods` handler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以利用`Methods`处理器提供的附加功能。
- en: Injecting Dependencies into Handlers
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将依赖注入到处理器中
- en: The `http.Handler` interface gives you access to the request and response objects.
    But it’s likely you’ll require access to additional functionality like a logger,
    metrics, cache, or database to handle a request. For example, you may want to
    inject a logger to record request errors or inject a database object to retrieve
    data used to create the response. The easiest way to inject an object into a handler
    is by using a closure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Handler` 接口让您可以访问请求和响应对象。但是，您可能需要访问额外的功能，比如日志记录器、指标、缓存或数据库来处理请求。例如，您可能希望注入一个日志记录器来记录请求错误，或者注入一个数据库对象来检索用于创建响应的数据。将对象注入到处理程序中的最简单方法是使用闭包。'
- en: '[Listing 9-8](#listing9-8) demonstrates how to inject a SQL database object
    into an `http.Handler`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-8](#listing9-8) 演示了如何将 SQL 数据库对象注入到 `http.Handler` 中。'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-8: Injecting a dependency into a handler using a closure'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8：使用闭包将依赖项注入到处理程序中
- en: You create a function that accepts a pointer to a SQL database object 1 and
    returns a handler, then assign it to a variable named `dbHandler`. Since this
    function closes over the returned handler, you have access to the `db` variable
    in the handler’s scope 2. Instantiating the handler is as simple as calling `dbHandler`
    and passing in a pointer to a SQL database object 3.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建一个接受 SQL 数据库对象指针 1 并返回一个处理程序的函数，然后将其分配给一个名为 `dbHandler` 的变量。由于此函数会捕获返回的处理程序，您可以在处理程序的作用域中访问
    `db` 变量 2。实例化处理程序的方式就是调用 `dbHandler` 并传入一个 SQL 数据库对象的指针 3。
- en: This approach can get a bit cumbersome if you have multiple handlers that require
    access to the same database object or your design is evolving and you’re likely
    to require access to additional objects in the future. A more extensible approach
    is to use a struct whose fields represent objects and data you want to access
    in your handler and to define your handlers as struct methods (see [Listing 9-9](#listing9-9)).
    Injecting dependencies involves adding struct fields instead of modifying a bunch
    of closure definitions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个处理程序需要访问相同的数据库对象，或者您的设计正在发展并且未来可能需要访问额外的对象，这种方法可能会有些繁琐。一种更具扩展性的方法是使用一个结构体，其字段表示您希望在处理程序中访问的对象和数据，并将您的处理程序定义为结构体方法（参见
    [示例 9-9](#listing9-9)）。注入依赖项是通过添加结构体字段，而不是修改多个闭包定义来实现的。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-9: Injecting dependencies into multiple handlers defined as struct
    methods'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9：将依赖项注入到定义为结构体方法的多个处理程序中
- en: You define a struct that contains pointers to a database object and a logger
    1. Any method you define on the handler now has access to these objects 2. If
    your handlers require access to additional resources, you simply add fields to
    the struct.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义了一个结构体，其中包含指向数据库对象和日志记录器的指针 1。您在处理程序上定义的任何方法现在都可以访问这些对象 2。如果您的处理程序需要访问其他资源，您只需向结构体中添加字段。
- en: '[Listing 9-10](#listing9-10) illustrates how to use the `Handlers` struct.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-10](#listing9-10) 演示了如何使用 `Handlers` 结构体。'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 9-10: Initializing the `Handlers` struct and using its handlers'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-10：初始化 `Handlers` 结构体并使用其处理程序
- en: Assuming `db`1 is a pointer to a `sql.DB` object, you initialize a `Handlers`
    object and use its methods with `http.Handle`, for example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `db`1 是指向 `sql.DB` 对象的指针，您初始化一个 `Handlers` 对象，并使用 `http.Handle` 调用其方法，例如。
- en: Middleware
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Middleware comprises reusable functions that accept an `http.Handler` and return
    an `http.Handler`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件由可重用的函数组成，这些函数接受一个 `http.Handler` 并返回一个 `http.Handler`：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can use middleware to inspect the request and make decisions based on its
    content before passing it along to the next handler. Or you might use the request
    content to set headers in the response. For example, the middleware could respond
    to the client with an error if the handler requires authentication and an unauthenticated
    client sent the request. Middleware can also collect metrics, log requests, or
    control access to resources, to name a few uses. Best of all, you can reuse them
    on multiple handlers. If you find yourself writing the same handler code over
    and over, ask yourself if you can put the functionality into middleware and reuse
    it across your handlers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用中间件检查请求，并根据其内容做出决策，然后将其传递给下一个处理程序。或者，您可能使用请求内容在响应中设置头信息。例如，如果处理程序需要身份验证并且未经过身份验证的客户端发送了请求，则中间件可以向客户端响应一个错误。中间件还可以收集指标、记录请求或控制对资源的访问，这只是其中的一些用法。最棒的是，您可以在多个处理程序中重用它们。如果您发现自己一遍又一遍地编写相同的处理程序代码，请问问自己是否可以将功能放入中间件并在处理程序之间重用它。
- en: '[Listing 9-11](#listing9-11) shows just a few uses of middleware, such as enforcing
    which methods the handler allows, adding headers to the response, or performing
    ancillary functions like logging.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-11](#listing9-11) 展示了中间件的一些用法，比如强制处理程序允许哪些方法、向响应中添加头部，或执行辅助功能，如日志记录。'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-11: Example middleware function'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-11：示例中间件函数
- en: 'The `Middleware` function uses a common pattern you first saw in [Listing 9-4](#listing9-4):
    it defines a function that accepts an `http.ResponseWriter` and a pointer to an
    `http.Request`2 and wraps it with an `http.HandlerFunc`1.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Middleware` 函数使用了一个常见模式，这个模式你在 [列表 9-4](#listing9-4) 中第一次看到：它定义了一个接受 `http.ResponseWriter`
    和 `http.Request` 指针的函数，并通过 `http.HandlerFunc` 进行包装。'
- en: In most cases, middleware calls the given handler 5. But in some cases that
    may not be proper, and the middleware should block the next handler and respond
    to the client itself 3. Likewise, you may want to use middleware to collect metrics,
    ensure specific headers are set on the response 4, or write to a log file 6.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，中间件调用给定的处理程序 5。但在某些情况下，这可能不合适，且中间件应该阻止下一个处理程序并自行响应客户端 3。同样，你可能希望使用中间件来收集指标，确保响应中设置了特定的头部
    4，或写入日志文件 6。
- en: '[Listing 9-11](#listing9-11) is a contrived example. I don’t recommend performing
    so many tasks in a single middleware function. Instead, it’s best to follow the
    Unix philosophy and write minimalist middleware, with each function doing one
    thing very well. Ideally, you would split the middleware in [Listing 9-11](#listing9-11)
    into three middleware functions to check the request method and respond to the
    client 3, enforce response headers 4, and collect metrics 6.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-11](#listing9-11) 是一个人为的示例。我不推荐在单个中间件函数中执行这么多任务。相反，最好遵循 Unix 的哲学，编写简洁的中间件，每个函数专注于做一件事，并做到非常好。理想情况下，你可以将
    [列表 9-11](#listing9-11) 中的中间件拆分为三个中间件函数，分别检查请求方法并响应客户端 3，强制响应头部 4，以及收集指标 6。'
- en: The `net/http` package includes useful middleware to serve static files, redirect
    requests, and manage request time-outs. Let’s dig into their source code to see
    how you might use them. In addition to these standard library functions, check
    out the middleware at [https://go.dev/](https://go.dev/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包包括用于提供静态文件、重定向请求和管理请求超时的有用中间件。让我们深入研究它们的源代码，看看你如何使用它们。除了这些标准库函数，还可以查看
    [https://go.dev/](https://go.dev/) 上的中间件。'
- en: Timing Out Slow Clients
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时慢速客户端
- en: As I mentioned earlier, it’s important not to let clients dictate the duration
    of a request-response life cycle. Malicious clients could use this leniency to
    their ends and exhaust your server’s resources, effectively denying service to
    legit clients. Yet at the same time, setting read and write time-outs server-wide
    makes it hard for the server to stream data or use different time-out durations
    for each handler.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，重要的是不要让客户端决定请求响应生命周期的持续时间。恶意客户端可能会利用这一宽松性来达到自己的目的，耗尽服务器资源，从而有效地拒绝服务合法客户端。然而，同时，设置服务器级别的读写超时会使服务器难以流式传输数据或为每个处理程序使用不同的超时时间。
- en: Instead, you should manage time-outs in middleware or individual handlers. The
    `net/http` package includes a middleware function that allows you to control the
    duration of a request and response on a per-handler basis. The `http.TimeoutHandler`
    accepts an `http.Handler`, a duration, and a string to write to the response body.
    It sets an internal timer to the given duration. If the `http.Handler` does not
    return before the timer expires, the `http.TimeoutHandler` blocks the `http.Handler`
    and responds to the client with a 503 Service Unavailable status.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该在中间件或单独的处理程序中管理超时。`net/http` 包包含一个中间件函数，允许你在每个处理程序级别控制请求和响应的持续时间。`http.TimeoutHandler`
    接受一个 `http.Handler`、一个持续时间和一个字符串，以写入响应体。它设置一个内部计时器，持续时间为给定值。如果 `http.Handler`
    在计时器到期之前没有返回，`http.TimeoutHandler` 会阻塞 `http.Handler`，并以 503 服务不可用状态响应客户端。
- en: '[Listing 9-12](#listing9-12) uses the `http.TimeoutHandler` to wrap an `http.Handler`
    that mimics a slow client.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-12](#listing9-12) 使用 `http.TimeoutHandler` 来包装一个模拟慢速客户端的 `http.Handler`。'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-12: Giving clients a finite time to read the response (*middleware/timeout_test.go*)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-12：为客户端设置有限的读取响应时间（*middleware/timeout_test.go*）
- en: Despite its name, `http.TimeoutHandler` is middleware that accepts an `http.Handler`
    and returns an `http.Handler`1. The wrapped `http.Handler` purposefully sleeps
    for a minute 2 to simulate a client’s taking its time to read the response, preventing
    the `http.Handler` from returning. When the handler doesn’t return within one
    second, `http.TimeoutHandler` sets the response status code to 503 Service Unavailable
    3. The test reads the entire response body 4, properly closes it, and makes sure
    the response body has the string written by the middleware 5.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字如此，`http.TimeoutHandler` 是一个中间件，它接受一个 `http.Handler` 并返回一个 `http.Handler`1。被包装的
    `http.Handler` 故意休眠一分钟2，以模拟客户端花时间读取响应，从而阻止 `http.Handler` 返回。当处理程序在一秒钟内没有返回时，`http.TimeoutHandler`
    会将响应状态码设置为 503 服务不可用3。测试会读取整个响应体4，正确地关闭它，并确保响应体中包含中间件写入的字符串5。
- en: Protecting Sensitive Files
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护敏感文件
- en: Middleware can also keep clients from accessing information you’d like to keep
    private. For example, the `http.FileServer` function simplifies the process of
    serving static files to clients, accepting an `http.FileSystem` interface, and
    returning an `http.Handler`. The problem is, it won’t protect against serving
    up potentially sensitive files. Any file in the target directory is fair game.
    By convention, many operating systems store configuration files or other sensitive
    information in files and directories prefixed with a period and then hide these
    dot-prefixed files and directories by default. (This is particularly true in Unix-compatible
    systems.) But the `http.FileServer` will gladly serve dot-prefixed files or traverse
    dot-prefixed directories.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件还可以防止客户端访问您希望保持私密的信息。例如，`http.FileServer` 函数简化了为客户端提供静态文件的过程，接受一个 `http.FileSystem`
    接口并返回一个 `http.Handler`。问题在于，它不会保护防止提供潜在的敏感文件。目标目录中的任何文件都是合法的。按惯例，许多操作系统将配置文件或其他敏感信息存储在以点（.）开头的文件和目录中，并默认隐藏这些以点开头的文件和目录。（在与
    Unix 兼容的系统中尤其如此。）但 `http.FileServer` 会高兴地提供以点开头的文件或遍历以点开头的目录。
- en: The `net/http` package documentation includes an example of an `http.FileSystem`
    that prevents the `http.FileServer` from serving dot-prefixed files and directories.
    [Listing 9-13](#listing9-13) takes a different approach by using middleware to
    offer the same protection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包文档中包含了一个 `http.FileSystem` 的示例，能够防止 `http.FileServer` 提供以点开头的文件和目录。[清单
    9-13](#listing9-13) 通过使用中间件提供相同的保护方式。'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-13: Protecting any file or directory with a given prefix (*middleware/restrict_prefix.go*).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-13：保护带有指定前缀的任何文件或目录 (*middleware/restrict_prefix.go*)。
- en: The `RestrictPrefix` middleware 1 examines the URL path 2 to look for any elements
    that start with a given prefix. If the middleware finds an element in the URL
    path with the given prefix, it preempts the `http.Handler` and responds with a
    404 Not Found status 3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestrictPrefix` 中间件1 会检查 URL 路径2，查找任何以给定前缀开头的元素。如果中间件在 URL 路径中找到了以给定前缀开头的元素，它会抢先响应
    `http.Handler` 并返回一个 404 未找到状态3。'
- en: '[Listing 9-14](#listing9-14) uses the `RestrictPrefix` middleware with a series
    of test cases.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-14](#listing9-14) 使用了 `RestrictPrefix` 中间件，并包含一系列测试用例。'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 9-14: Using the `RestrictPrefix` middleware (*middleware/restrict_prefix_test.go*)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：使用 `RestrictPrefix` 中间件 (*middleware/restrict_prefix_test.go*)
- en: It’s important to realize the server first passes the request to the `http.StripPrefix`
    middleware 1, then the `RestrictPrefix` middleware 2, and if the `RestrictPrefix`
    middleware approves the resource path, the `http.FileServer`3. The `RestrictPrefix`
    middleware evaluates the request’s resource path to determine whether the client
    is requesting a restricted path, no matter whether the path exists or not. If
    so, the `RestrictPrefix` middleware responds to the client with an error without
    ever passing the request onto the `http.FileServer`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，服务器首先将请求传递给 `http.StripPrefix` 中间件1，然后是 `RestrictPrefix` 中间件2，如果 `RestrictPrefix`
    中间件批准资源路径，则传递给 `http.FileServer`3。`RestrictPrefix` 中间件会评估请求的资源路径，以判断客户端是否请求了受限路径，无论该路径是否存在。如果是，`RestrictPrefix`
    中间件会回应客户端一个错误，而不会将请求传递给 `http.FileServer`。
- en: The static files served by this test’s `http.FileServer` exist in a directory
    named *files* in the *restrict_prefix_test.go* file’s parent directory. Files
    in the *../files* directory are in the root of the filesystem passed to the `http.FileServer`.
    For example, the *../files/sage.svg* file on the operating system’s filesystem
    is at */sage.svg* in the `http.FileSystem` passed to the `http.FileServer`. If
    a client wanted to retrieve the *sage.svg* file from the `http.FileServer`, the
    request path should be */sage.svg*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本测试的`http.FileServer`提供的静态文件存在于名为*files*的目录中，该目录位于*restrict_prefix_test.go*文件的父目录下。*../files*目录中的文件在传递给`http.FileServer`的文件系统根目录中。例如，操作系统文件系统中的*../files/sage.svg*文件，在传递给`http.FileServer`的`http.FileSystem`中位于*/sage.svg*路径。如果客户端希望从`http.FileServer`获取*sage.svg*文件，请求路径应为*/sage.svg*。
- en: But the URL path for each of our test cases 4 includes the */static/* prefix
    followed by the static filename. This means that the test requests *static/sage.svg*
    from the `http.FileServer`, which doesn’t exist. The test uses another bit of
    middleware from the `net/http` package to solve this path discrepancy. The `http.StripPrefix`
    middleware strips the given prefix from the URL path before passing along the
    request to the `http.Handler`, the `http.FileServer` in this test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们的每个测试用例4的URL路径都包括*/static/*前缀，后跟静态文件名。这意味着测试请求*static/sage.svg*来自`http.FileServer`，但该文件并不存在。该测试使用了`net/http`包中的另一个中间件来解决这个路径不一致问题。`http.StripPrefix`中间件在将请求传递给`http.Handler`（本测试中的`http.FileServer`）之前，先去掉URL路径中的指定前缀。
- en: Next, you block access to sensitive files by wrapping the `http.FileServer`
    with the `RestrictPrefix` middleware to prevent the handler from serving any file
    or directory prefixed with a period. The first test case results in a 200 OK status,
    because no element in the URL path has a period prefix. The `http.StripPrefix`
    middleware removes the */static/* prefix from the test case’s URL, changing it
    from */static/sage.svg* to *sage.svg*. It then passes this path to the `http.FileServer`,
    which finds the corresponding file in its `http.FileSystem`. The `http.FileServer`
    writes the file contents to the response body.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您通过将`http.FileServer`包装在`RestrictPrefix`中间件中来阻止访问敏感文件，以防止该处理程序服务任何以句点为前缀的文件或目录。第一个测试用例结果是200
    OK状态，因为URL路径中没有任何元素以句点为前缀。`http.StripPrefix`中间件从测试用例的URL中移除*/static/*前缀，将其从*/static/sage.svg*更改为*sage.svg*。然后，它将此路径传递给`http.FileServer`，该服务器在其`http.FileSystem`中找到对应的文件。`http.FileServer`将文件内容写入响应体中。
- en: The second test case results in a 404 Not Found status because the *.secret*
    filename has a period as its first character. The third case also results in a
    404 Not Found status due to the *.dir* element in the URL path, because your `RestrictPrefix`
    middleware considers the prefix of each segment in the path, not just the file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例结果是404 Not Found状态，因为*.secret*文件名的第一个字符是一个句点。第三个测试用例也导致404 Not Found状态，因为URL路径中的*.dir*元素，原因在于你的`RestrictPrefix`中间件会考虑路径中每个段的前缀，而不仅仅是文件本身。
- en: A better approach to restricting access to resources would be to block all resources
    by default and explicitly allow select resources. As an exercise, try implementing
    the inverse of the `RestrictPrefix` middleware by creating middleware that permits
    requests for only an allowed list of resources.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的限制资源访问的方法是默认阻止所有资源，并显式允许特定的资源。作为练习，尝试通过创建一个中间件来实现`RestrictPrefix`中间件的反向功能，该中间件仅允许访问一个允许的资源列表。
- en: Multiplexers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多路复用器
- en: One afternoon, I walked into the University of Michigan’s library, the fourth
    largest library in the United States. I was looking for a well-worn copy of Kurt
    Vonnegut’s *Cat’s Cradle* and had no idea where to start my search. I found the
    nearest librarian and asked for help finding the book. When we arrived at the
    correct location, the book was 404 Not Found.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一天下午，我走进了美国第四大图书馆——密歇根大学的图书馆。我正在寻找一本翻烂了的库尔特·冯内古特的*猫的摇篮*，但我不知道从哪里开始寻找。我找到最近的图书管理员，向他寻求帮助寻找这本书。当我们到达正确的位置时，书本却显示404
    Not Found。
- en: A *multiplexer*, like the friendly librarian routing me to the proper bookshelf,
    is a general handler that routes a request to a specific handler. The `http.ServeMux`
    multiplexer is an `http.Handler` that routes an incoming request to the proper
    handler for the requested resource. By default, `http.ServeMux` responds with
    a 404 Not Found status for all incoming requests, but you can use it to register
    your own patterns and corresponding handlers. It will then compare the request’s
    URL path with its registered patterns, passing the request and response writer
    to the handler that corresponds to the longest matching pattern.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*多路复用器*就像友好的图书管理员将我引导到正确的书架，它是一个通用的处理器，将请求路由到特定的处理器。`http.ServeMux`多路复用器是一个`http.Handler`，它将传入的请求路由到请求资源的正确处理器。默认情况下，`http.ServeMux`会对所有传入的请求返回404
    Not Found状态，但你可以使用它来注册你自己的模式和相应的处理器。然后它将请求的URL路径与已注册的模式进行比较，并将请求和响应写入器传递给与最长匹配模式对应的处理器。
- en: '[Listing 9-1](#listing9-1) used a multiplexer to send all requests to a single
    endpoint. [Listing 9-15](#listing9-15) introduces a slightly more complex multiplexer
    that has three endpoints. This one evaluates the requested resource and routes
    the request to the right endpoint.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-1](#listing9-1)使用多路复用器将所有请求发送到一个单一的端点。[示例 9-15](#listing9-15)介绍了一个稍微复杂一点的多路复用器，它有三个端点。这个多路复用器会评估请求的资源，并将请求路由到正确的端点。'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-15: Registering patterns to a multiplexer and wrapping the entire
    multiplexer with middleware (*mux_test.go*).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-15：将模式注册到多路复用器，并用中间件包裹整个多路复用器（*mux_test.go*）。
- en: The test creates a new multiplexer and registers three routes using the multiplexer’s
    `HandleFunc` method 3. The first route is simply a forward slash, showing the
    default or empty URL path, and a function that sets the 204 No Content status
    in the response. This route will match all URL paths if no other route matches.
    The second is */hello*4, which writes the string `Hello friend.` to the response.
    The final path is */hello/there/*5, which writes the string `Why, hello there.`
    to the response.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试创建了一个新的多路复用器，并使用该多路复用器的`HandleFunc`方法3注册了三条路由。第一条路由仅仅是一个斜杠，表示默认的或空的URL路径，并设置响应的204
    No Content状态。如果没有其他路由匹配，这条路由将匹配所有URL路径。第二条是*/hello*4，它将字符串`Hello friend.`写入响应。最后的路径是*/hello/there/*5，它将字符串`Why,
    hello there.`写入响应。
- en: 'Notice that the third route ends in a forward slash, making it a subtree, while
    the earlier route 4 did not end in a forward slash, making it an absolute path.
    This distinction tends to be a bit confusing for unaccustomed users. Go’s multiplexer
    treats absolute paths as exact matches: either the request’s URL path matches,
    or it doesn’t. By contrast, it treats subtrees as prefix matches. In other words,
    the multiplexer will look for the longest registered pattern that comes at the
    beginning of the request’s URL path. For example, */hello/there/* is a prefix
    of */hello/there/you* but not of */hello/you*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第三条路由以斜杠结尾，使其成为一个子树，而之前的路由 4 没有以斜杠结尾，使其成为绝对路径。这一区别对不习惯的用户来说可能有点混淆。Go的多路复用器将绝对路径视为精确匹配：要么请求的URL路径匹配，要么不匹配。相比之下，它将子树视为前缀匹配。换句话说，多路复用器会寻找最长的已注册模式，该模式出现在请求的URL路径的开头。例如，*/hello/there/*是*/hello/there/you*的前缀，但不是*/hello/you*的前缀。
- en: Go’s multiplexer can also redirect a URL path that doesn’t end in a forward
    slash, such as */hello/there*. In those cases, the `http.ServeMux` first attempts
    to find a matching absolute path. If that fails, the multiplexer appends a forward
    slash, making the path */hello/there/*, for example, and responds to the client
    with it. This new path becomes a permanent redirect. You’ll see an example of
    this in [Listing 9-16](#listing9-16).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go的多路复用器还可以重定向一个不以斜杠结尾的URL路径，例如*/hello/there*。在这种情况下，`http.ServeMux`首先尝试查找一个匹配的绝对路径。如果失败，多路复用器会在路径末尾添加一个斜杠，例如将路径变为*/hello/there/*，然后将其响应给客户端。这个新路径成为一个永久重定向。你将在[示例
    9-16](#listing9-16)中看到一个例子。
- en: 'Now that you’ve defined routes for the multiplexer, it’s ready to use. But
    there’s one issue with the handlers: none of them drain and close the request
    body. This isn’t a big concern in a test like this, but you should stick to best
    practices, nonetheless. If you don’t do so in a real scenario, you may cause increased
    overhead and potential memory leaks. Here, you use middleware 1 to drain and close
    the request body. In the `drainAndClose` middleware, you call the `next` handler
    first 2 and then drain and close the request body. There is no harm in draining
    and closing a previously drained and closed request body.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经为多路复用器定义了路由，它已准备好使用。但处理程序存在一个问题：它们没有清空和关闭请求体。在这样的测试中，这不是一个大问题，但您仍然应该遵循最佳实践。如果在实际场景中不这样做，可能会导致额外的开销和潜在的内存泄漏。在这里，您使用中间件
    1 来清空和关闭请求体。在 `drainAndClose` 中间件中，您首先调用 `next` 处理程序 2，然后清空并关闭请求体。清空和关闭已清空并关闭的请求体是没有害处的。
- en: '[Listing 9-16](#listing9-16) tests a series of requests against [Listing 9-15](#listing9-15)’s
    multiplexer.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-16](#listing9-16) 测试了一系列请求，针对 [清单 9-15](#listing9-15) 的多路复用器。'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 9-16: Running through a series of test cases and verifying the response
    status code and body (*mux_test.go*).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：执行一系列测试用例并验证响应状态码和响应体（*mux_test.go*）。
- en: The first three test cases 1, including the request for the */hello/there/*
    path, match exact patterns registered with the multiplexer. But the fourth test
    case 2 is different. It doesn’t have an exact match. When the multiplexer appends
    a forward slash to it, however, it discovers that it exactly matches a registered
    pattern. Therefore, the multiplexer responds with a 301 Moved Permanently status
    and a link to the new path in the response body. The fifth test case 3 matches
    the */hello/there/* subtree and receives the `Why, hello there.` response. The
    last three test cases 4 match the default path of */* and receive the 204 No Content
    status.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个测试用例 1，包括请求 */hello/there/* 路径，匹配多路复用器中注册的精确模式。但第四个测试用例 2 不同，它没有精确匹配。当多路复用器在其后添加一个斜杠时，它发现该路径与已注册的模式完全匹配。因此，多路复用器会响应
    301 永久移动状态，并在响应体中提供指向新路径的链接。第五个测试用例 3 匹配 */hello/there/* 子树，并收到 `Why, hello there.`
    的响应。最后三个测试用例 4 匹配默认路径 */*，并收到 204 无内容状态。
- en: Just as the test relies on middleware to drain and close the request body, it
    drains 5 and closes 6 the response body.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就像测试依赖中间件来清空和关闭请求体一样，它也会清空 5 并关闭 6 响应体。
- en: HTTP/2 Server Pushes
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP/2 服务器推送
- en: The Go HTTP server can push resources to clients over HTTP/2, a feature that
    has the potential to improve efficiency. For example, a client may request the
    home page from a web server, but the client won’t know it needs the associated
    style sheet and images to properly render the home page until it receives the
    HTML in the response. An HTTP/2 server can proactively send the style sheet and
    images along with the HTML in the response, saving the client from having to make
    subsequent calls for those resources. But server pushes have the potential for
    abuse. This section shows you how to use server pushes and then discusses cases
    when you should avoid doing so.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go HTTP 服务器可以通过 HTTP/2 向客户端推送资源，这是一个有潜力提高效率的特性。例如，客户端可能请求 Web 服务器的主页，但在收到 HTML
    响应之前，客户端并不知道它需要相关的样式表和图像来正确渲染主页。HTTP/2 服务器可以主动将样式表和图像与 HTML 一起发送到响应中，从而节省客户端后续请求这些资源的时间。但服务器推送具有滥用的潜力。本节将向您展示如何使用服务器推送，并讨论在何种情况下您应该避免这样做。
- en: Pushing Resources to the Client
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向客户端推送资源
- en: Let’s retrieve the HTML page in [Listing 9-17](#listing9-17) over HTTP/1.1,
    then retrieve the same page over HTTP/2 and compare the differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 HTTP/1.1 获取 [清单 9-17](#listing9-17) 中的 HTML 页面，然后通过 HTTP/2 获取相同的页面并比较其差异。
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-17: Simple index file having links to two resources (*files/index.html*)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：简单的索引文件，包含指向两个资源的链接（*files/index.html*）
- en: This HTML file requires the browser to retrieve two more resources, a style
    sheet 1 and an SVG image 2, to properly show the entire page. [Figure 9-2](#figure9-2)
    shows Google Chrome’s request accounting for the HTML when served using HTTP/1.1.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 HTML 文件需要浏览器获取两个额外的资源，一个样式表 1 和一个 SVG 图像 2，才能正确显示整个页面。[图 9-2](#figure9-2)
    显示了当使用 HTTP/1.1 服务时，Google Chrome 对 HTML 请求的统计。
- en: '![f09002](image_fi/500884c09/f09002.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/500884c09/f09002.png)'
- en: 'Figure 9-2: Downloaded index page and associated resources over HTTP/1.1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：通过 HTTP/1.1 下载的索引页面和相关资源
- en: Aside from the *favicon.ico* file, which Chrome retrieves on its own, the browser
    made three requests to retrieve all required resources—one for the HTML file,
    one for the style sheet, and one for the SVG image. Any web browser requesting
    the *index.html* file (*localhost* in [Figure 9-2](#figure9-2)) will also request
    the *style.css* and *hiking.svg* files to properly render the *index.html* file.
    The web server could improve efficiency and proactively push these two files to
    the web browser, since it knows the web browser will inevitably request them.
    This proactive approach by the web server would save the web browser from the
    overhead of having to make two more requests.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *favicon.ico* 文件（Chrome 会自动获取）外，浏览器发出了三次请求以获取所有必需的资源——一次请求 HTML 文件，一次请求样式表，一次请求
    SVG 图像。任何请求 *index.html* 文件的 web 浏览器（在 [Figure 9-2](#figure9-2) 中是 *localhost*）也会请求
    *style.css* 和 *hiking.svg* 文件，以正确渲染 *index.html* 文件。Web 服务器可以提高效率，主动将这两个文件推送到
    web 浏览器，因为它知道浏览器必定会请求它们。Web 服务器的这种主动方式可以让浏览器避免再进行两个额外的请求。
- en: '[Figure 9-3](#figure9-3) shows the same retrieval using HTTP/2\. In this case,
    the server pushes the *style.css* and *hiking.svg* files.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 9-3](#figure9-3) 显示了使用 HTTP/2 的相同检索过程。在这种情况下，服务器推送了 *style.css* 和 *hiking.svg*
    文件。'
- en: '![f09003](image_fi/500884c09/f09003.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/500884c09/f09003.png)'
- en: 'Figure 9-3: Downloaded index page with resources pushed by the server side'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9-3：下载的索引页面与服务器端推送的资源
- en: The client receives all three resources after a single request to the server
    for the *index.html* file. The Initiator column in [Figure 9-3](#figure9-3) shows
    that Chrome retrieved the resources from its dedicated push cache.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在向服务器请求 *index.html* 文件后，会接收到所有三个资源。[Figure 9-3](#figure9-3) 中的 Initiator
    列显示 Chrome 从其专用的推送缓存中检索了这些资源。
- en: Let’s write a command line executable that can push resources to clients. [Listing
    9-18](#listing9-18) shows the first part of the program.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个命令行可执行文件，可以将资源推送到客户端。[Listing 9-18](#listing9-18) 显示了程序的第一部分。
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-18: Command line arguments for the HTTP/2 server (*server.go*)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-18：HTTP/2 服务器的命令行参数（*server.go*）
- en: The server needs the path to a certificate 1 and a corresponding private key
    2 to enable TLS support and allow clients to negotiate HTTP/2 with the server.
    If either value is empty, the server will listen for plain HTTP connections. Next,
    pass the command line flag values to a `run` function 3.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要证书的路径 1 和对应的私钥 2 来启用 TLS 支持，并允许客户端与服务器协商 HTTP/2。如果其中任何一个值为空，服务器将侦听普通的 HTTP
    连接。接下来，将命令行标志的值传递给 `run` 函数 3。
- en: The `run` function, defined in [Listing 9-19](#listing9-19), has the bulk of
    your server’s logic and ultimately runs the web server. Breaking this functionality
    into a separate function eases unit testing later.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数，定义在 [Listing 9-19](#listing9-19) 中，包含了服务器的大部分逻辑，并最终启动了 web 服务器。将此功能拆分为单独的函数有助于后续的单元测试。'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 9-19: Multiplexer, middleware, and handlers for the HTTP/2 server (*server.go*)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-19：HTTP/2 服务器的多路复用器、中间件和处理器（*server.go*）
- en: 'The server’s multiplexer has three routes: one for static files 1, one for
    the default route 2, and one for the */2* absolute path 7. If the `http.ResponseWriter`
    is an `http.Pusher`3, it can push resources to the client 5 without a corresponding
    request. You specify the path to the resource from the client’s perspective 4,
    not the file path on the server’s filesystem because the server treats the request
    as if the client originated it to facilitate the server push. After you’ve pushed
    the resources, you serve the response for the handler 6. If, instead, you sent
    the *index.html* file before pushing the associated resources, the client’s browser
    may send requests for the associated resources before it handles the pushes.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的多路复用器有三个路由：一个用于静态文件 1，一个用于默认路由 2，一个用于 */2* 绝对路径 7。如果 `http.ResponseWriter`
    是 `http.Pusher`3，它可以在没有对应请求的情况下将资源推送到客户端 5。你需要从客户端的角度指定资源的路径 4，而不是服务器文件系统上的文件路径，因为服务器将请求视为客户端发起的，以便促进服务器推送。推送资源后，你为处理器提供响应
    6。如果你在推送关联资源之前先发送了 *index.html* 文件，客户端的浏览器可能会在处理推送之前，先发送请求获取关联的资源。
- en: Web browsers cache HTTP/2-pushed resources for the life of the connection and
    make it available across routes. Therefore, if the *index2.html* file served by
    the */2* route 7 references the same resources pushed by the default route, and
    the client first visits the default route, the client’s web browser may use the
    pushed resources when rendering the */2* route.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器会缓存 HTTP/2 推送的资源，直到连接结束，并且在不同的路由中可用。因此，如果*index2.html*文件由*/2*路由7提供，并且引用了默认路由推送的相同资源，而客户端首先访问默认路由，则客户端的网页浏览器可能会在渲染*/2*路由时使用推送的资源。
- en: 'You have one more task to complete: instantiate an HTTP server to serve your
    resources. [Listing 9-20](#listing9-20) does this by making use of the multiplexer.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一项任务要完成：实例化一个HTTP服务器来提供你的资源。[列表9-20](#listing9-20)通过使用多路复用器来完成此任务。
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-20: HTTP/2-capable server implementation (*server.go*)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-20：支持HTTP/2的服务器实现（*server.go*）
- en: When the server receives an `os.Interrupt` signal 1, it triggers a call to the
    server’s `Shutdown` method 2. Unlike the server’s `Close` method, which abruptly
    closes the server’s listener and all active connections, `Shutdown` gracefully
    shuts down the server. It instructs the server to stop listening for incoming
    connections and blocks until all client connections end. This gives the server
    the opportunity to finish sending responses before stopping the server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到`os.Interrupt`信号1时，它会触发对服务器`Shutdown`方法2的调用。与服务器的`Close`方法不同，`Close`方法会突然关闭服务器的监听器和所有活动连接，而`Shutdown`方法会优雅地关闭服务器。它指示服务器停止监听传入连接，并在所有客户端连接结束之前阻塞。这给了服务器在停止之前完成发送响应的机会。
- en: If the server receives a path to both a certificate and a corresponding private
    key, the server will enable TLS support by calling its `ListenAndServeTLS` method
    3. If it cannot find or parse either the certificate or private key, this method
    returns an error. In the absence of these paths, the server uses its `ListenAndServe`
    method 4.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器接收到证书和相应私钥的路径，它将通过调用`ListenAndServeTLS`方法3来启用TLS支持。如果无法找到或解析证书或私钥之一，则此方法会返回错误。如果没有这些路径，服务器将使用`ListenAndServe`方法4。
- en: Go ahead and test this server. As mentioned in Chapter 8, Go doesn’t include
    the support needed to test the server’s push functionality with code, but you
    can interact with this program by using your web browser.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以测试这个服务器了。正如第8章所提到的，Go并未包括用于通过代码测试服务器推送功能的支持，但你可以通过使用网页浏览器与该程序进行交互。
- en: Don’t Be Too Pushy
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要过于强求
- en: Although HTTP/2 server pushing can improve the efficiency of your communications,
    it can do just the opposite if you aren’t careful. Remember that web browsers
    store pushed resources in a separate cache for the lifetime of the connection.
    If you’re serving resources that don’t change often, the web browser will likely
    already have them in its regular cache, so you shouldn’t push them. Once it caches
    them, the browser can use them for future requests spanning many connections.
    You probably shouldn’t push the resources in [Listing 9-19](#listing9-19), for
    instance, because they’re unlikely to change often.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTTP/2服务器推送可以提高通信效率，但如果不小心，它可能会适得其反。请记住，网页浏览器会将推送的资源缓存到一个单独的缓存中，并保持连接期间的有效性。如果你提供的资源不经常变化，网页浏览器可能已经将它们存储在常规缓存中，所以你不应该推送它们。一旦它们被缓存，浏览器就可以在多个连接间的未来请求中使用这些资源。例如，像[列表9-19](#listing9-19)中的资源就不应该推送，因为它们不太可能经常变化。
- en: My advice is to be conservative with server pushes. Use your handlers and rely
    on metrics to figure out when you should push a resource. If you do push resources,
    do so before writing the response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，在服务器推送方面要保持保守。使用你的处理程序，并依靠指标来判断何时应该推送资源。如果你确实推送资源，应该在写入响应之前进行推送。
- en: What You’ve Learned
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: Go’s `net/http` package includes a capable server implementation. In this chapter,
    you used its handlers, middleware, multiplexer, and HTTP/2 support to process
    client requests intelligently and efficiently.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`net/http`包包括了一个强大的服务器实现。在本章中，你使用了它的处理程序、中间件、多路复用器以及对HTTP/2的支持，来智能高效地处理客户端请求。
- en: Go’s `http.Handler` is an interface that describes an object capable of accepting
    a request and responding with a status code and payload. A special handler, known
    as a *multiplexer*, can parse a request and pass it along to the most proper handler,
    effectively functioning as a request router. *Middleware* is code that augments
    the behavior of handlers or performs auxiliary tasks. It might change the request,
    add headers to the response, collect metrics, or preempt the handler, to name
    a few use cases. Finally, Go’s server supports HTTP/2 over TLS. When it uses HTTP/2,
    the server can push resources to clients, potentially making the communication
    more efficient.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`http.Handler`是一个接口，描述了一个能够接收请求并以状态码和有效载荷响应的对象。一种特殊的处理器，称为*多路复用器*，可以解析请求并将其传递给最合适的处理器，有效地充当请求路由器。*中间件*是增强处理器行为或执行辅助任务的代码。它可能会修改请求，向响应添加头部，收集指标，或抢先执行处理器，等等。最后，Go的服务器支持TLS上的HTTP/2。当使用HTTP/2时，服务器可以将资源推送到客户端，从而可能使通信更加高效。
- en: By putting these features together, you can build comprehensive, useful HTTP-based
    applications with surprisingly little code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些功能结合起来，你可以用出乎意料少的代码构建全面且实用的基于HTTP的应用程序。
