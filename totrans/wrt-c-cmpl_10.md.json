["```\nint foo(int param1, int param2, int param3);\n```", "```\nint foo(void);\n```", "```\nint foo(int param1, int param2, int param3) {\n    return param1 + param2 + param3;\n}\n```", "```\nint foo(int x, int y, int z);\n\nint main(void) {\n    return foo(1, 2, 3);\n}\n\nint foo(int param1, int param2, int param3);\n\n  int foo(int a, int b, int c) {\n    return a + b + c;\n}\n```", "```\nint foo(int a, int b);\n\nint main(void) {\n    int foo(int a, int b);\n    return foo(1, 2);\n}\n```", "```\nint main(void) {\n    int foo(int a, int b) {return a + b;};\n    return foo(1, 2);\n}\n```", "```\nfoo(1, 2, 3);\n```", "```\nint foo(int a, int b, int c) {\n    return bar(a + b, 2 * c);\n}\n```", "```\nint foo(int arg1, int arg2, int arg3);\n\nint main(void) {\n    return foo(1, 2, 3);\n}\n```", "```\nint main(void) {\n    return foo(1, 2, 3);\n}\n\nint foo(int arg1, int arg2, int arg3);\n```", "```\nint foo(int a, int b);\n\nint main(void) {\n    int foo = 3;\n    return foo;\n}\n```", "```\nint main(void) {\n    int a = 3;\n    if (a > 0) {\n        int a(void);\n        return a();\n    }\n    return 0;\n}\n```", "```\nint two(void) {\n    int incr(int i);\n    return incr(1);\n}\n\nint incr(int i);\n\nint main(void) {\n    return two() + incr(3);\n}\n\nint incr(int i) {\n    return i + 1;\n}\n```", "```\nint library_fun(int a, int b) {\n    return a + b;\n}\n```", "```\nint library_fun(int a, int b);\n\nint main(void) {\n    return library_fun(1, 2);\n}\n```", "```\nint main(void) {\n    int f(int x);\n    int ret = f(1);\n    if (ret) {\n        int f(int a, int b);\n        return f(0, 1);\n    }\n    return 0;\n}\n```", "```\n/usr/bin/ld: . . ./x86_64-linux-gnu/Scrt1.o: in function `_start':\n(.text+0x24): undefined reference to `main'\ncollect2: error: ld returned 1 exit status\n```", "```\ngcc -c `ASSEMBLY_FILE` -o `OUTPUT_FILE`\n```", "```\nexp = Constant(int)\n| Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n| Assignment(exp, exp)\n| Conditional(exp condition, exp, exp)\n **| FunctionCall(identifier, exp* args)**\n```", "```\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, exp? init)\n```", "```\nfunction_definition = Function(identifier name, block body)\n```", "```\nfunction_declaration = (identifier name, identifier* params, block? body)\n```", "```\nprogram = Program(function_declaration*)\n```", "```\nprogram = Program(**function_declaration***)\n**declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)**\n**variable_declaration = (identifier name, exp? init)**\n**function_declaration = (identifier name, identifier* params, block? body)**\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(**variable_declaration**) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n| Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(int)\n| Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n| Assignment(exp, exp)\n| Conditional(exp condition, exp, exp)\n **| FunctionCall(identifier, exp* args)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan |LessOrEqual\n                | GreaterThan| GreaterOrEqual\n```", "```\n<program> ::= **{<function-declaration>}**\n**<declaration> ::= <variable-declaration> | <function-declaration>**\n**<variable-declaration> ::= \"int\" <identifier> [\"=\" <exp>] \";\"**\n**<function-declaration> ::= \"int\" <identifier> \"(\" <param-list> \")\" (<block> | \";\")**\n**<param-list> ::= \"void\" | \"int\" <identifier> {\",\" \"int\" <identifier>}**\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<for-init> ::= **<variable-declaration>** | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= <int> | <identifier> | <unop> <factor> | \"(\" <exp> \")\"\n           **| <identifier> \"(\" [<argument-list>] \")\"**\n**<argument-list> ::= <exp> {\",\" <exp>}**\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nint main(void) {\n    int foo(void);\n    int foo(void);\n    return foo();\n}\n```", "```\nresolve_exp(e, identifier_map):\n    match e with\n    | `--snip--`\n    | FunctionCall(fun_name, args) ->\n        if fun_name is in identifier_map:\n            new_fun_name = identifier_map.get(fun_name).new_name\n            new_args = []\n            for arg in args:\n                new_args.append(resolve_exp(arg, identifier_map))\n            return FunctionCall(new_fun_name, new_args)\n        else:\n            fail(\"Undeclared function!\")\n```", "```\nresolve_function_declaration(decl, identifier_map):\n    if decl.name is in identifier_map:\n        prev_entry = identifier_map.get(decl.name)\n      ❶ if prev_entry.from_current_scope and (not prev_entry.has_linkage):\n            fail(\"Duplicate declaration\")\n\n  ❷ identifier_map.add(decl.name, MapEntry(\n        new_name=decl.name, from_current_scope=True, has_linkage=True\n    ))\n\n  ❸ inner_map = copy_identifier_map(identifier_map)\n    new_params = []\n    for param in decl.params:\n        new_params.append(resolve_param(param, inner_map))\n\n    new_body = null\n    if decl.body is not null:\n        new_body = resolve_block(decl.body, inner_map)\n    return (decl.name, new_params, new_body)\n```", "```\nint a;\nint foo(int a);\n```", "```\nint foo(int a, int a);\n```", "```\nint foo(int a) {\n    int a = 3;\n    return a;\n}\n```", "```\nint x = 3;\nreturn x();\n```", "```\nint foo(int a, int b);\nint foo(int a);\n```", "```\nint foo(int a, int b);\n\nint main(void) {\n    return foo(1);\n}\n```", "```\nint foo(void) {\n    return 1;\n}\n\nint foo(void) {\n    return 2;\n}\n```", "```\ntype = Int | FunType(int param_count)\n```", "```\ntypecheck_variable_declaration(decl, symbols):\n    symbols.add(decl.name, Int)\n    if decl.init is not null:\n        typecheck_exp(decl.init, symbols)\n```", "```\ntypecheck_function_declaration(decl, symbols):\n    fun_type = FunType(length(decl.params))\n    has_body = decl.body is not null\n    already_defined = False\n\n    if decl.name is in symbols:\n        old_decl = symbols.get(decl.name)\n      ❶ if old_decl.type != fun_type:\n            fail(\"Incompatible function declarations\")\n        already_defined = old_decl.defined\n      ❷ if already_defined and has_body:\n            fail(\"Function is defined more than once\")\n\n  ❸ symbols.add(decl.name, fun_type, defined=(already_defined or has_body))\n\n  ❹ if has_body:\n        for param in decl.params:\n            symbols.add(param, Int)\n        typecheck_block(decl.body)\n```", "```\nint main(void) {\n  ❶ int foo(int a);\n    return foo(1);\n}\n\n❷ int foo(int a, int b);\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n    | FunctionCall(f, args) ->\n        f_type = symbols.get(f).type\n      ❶ if f_type == Int:\n            fail(\"Variable used as function name\")\n      ❷ if f_type.param_count != length(args):\n            fail(\"Function called with the wrong number of arguments\")\n      ❸ for arg in args:\n            typecheck_exp(arg, symbols)\n    | Var(v) ->\n      ❹ if symbols.get(v).type != Int:\n            fail(\"Function name used as variable\")\n    | `--snip--`\n```", "```\nprogram = Program(**function_definition***)\nfunction_definition = Function(identifier, **identifier* params,** instruction* body)\ninstruction = Return(val)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            **| FunCall(identifier fun_name, val* args, val dst)**\nval = Constant(int) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\n`<instructions for e1>`\nv1 = `<result of e1>`\n`<instructions for e2>`\nv2 = `<result of e2>`\n`--snip--`\nresult = FunCall(fun, [v1, v2, . . .])\n```", "```\nint fun(int a, int b, int c, int d, int e, int f, int g, int h) {\n    return a + h;\n}\n\nint caller(int arg) {\n    return arg + fun(1, 2, 3, 4, 5, 6, 7, 8);\n}\n```", "```\n .globl fun\nfun:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    # copy first argument into EAX\n    movl    %edi, %eax\n    # add last argument to EAX\n    addl    24(%rbp), %eax\n    # epilogue\n    movq    %rbp, %rsp\n    popq    %rbp\n    ret\n```", "```\n # save RDI before function call \n    pushq   %rdi\n    # fix stack alignment\n    subq    $8, %rsp\n    # pass first six arguments in registers\n    movl    $1, %edi\n    movl    $2, %esi\n    movl    $3, %edx\n    movl    $4, %ecx\n    movl    $5, %r8d\n    movl    $6, %r9d\n    # pass last two arguments on the stack\n    pushq   $8\n    pushq   $7\n    # transfer control to fun\n    call    fun\n    # restore the stack and RDI\n    addq    $24, %rsp\n    popq    %rdi\n```", "```\n # save RDI before function call\n    pushq   %rdi\n```", "```\n # fix stack alignment\n    subq    $8, %rsp\n```", "```\n # pass first six arguments in registers\n    movl    $1, %edi\n    movl    $2, %esi\n    movl    $3, %edx\n    movl    $4, %ecx\n    movl    $5, %r8d\n    movl    $6, %r9d\n```", "```\n # pass last two arguments on the stack\n    pushq   $8\n    pushq   $7\n```", "```\n # transfer control to fun\n    call    fun\n```", "```\n # copy first argument into EAX\n    movl    %edi, %eax\n```", "```\n # add last argument to EAX\n    addl    24(%rbp), %eax\n```", "```\n # epilogue\n    movq    %rbp, %rsp\n    popq    %rbp\n```", "```\n # restore the stack and RDI\n    addq    $24, %rsp\n    popq    %rdi\n```", "```\nprogram = Program(**function_definition***)\nfunction_definition = Function(identifier name, instruction* instructions)\ninstruction = Mov(operand src, operand dst)\n            | Unary(unary_operator, operand)\n            | Binary(binary_operator, operand, operand)\n            | Cmp(operand, operand)\n            | Idiv(operand)\n            | Cdq\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | AllocateStack(int)\n            **| DeallocateStack(int)**\n            **| Push(operand)**\n            **| Call(identifier)**\n            | Ret\n\nunary_operator = Neg | Not\nbinary_operator = Add | Sub | Mult\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int)\ncond_code = E | NE | G | GE | L | LE\nreg = AX | **CX |** DX | **DI | SI | R8 | R9 |** R10 | R11\n```", "```\nint simple(int param) {\n    return param;\n}\n```", "```\nMov(Reg(DI), Pseudo(\"param\"))\n```", "```\nMov(Reg(DI), Pseudo(\"param\"))\nMov(Pseudo(\"param\"), Reg(AX))\nRet\n```", "```\n .globl simple\nsimple:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    subq    $16, %rsp\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %eax\n    movq    %rbp, %rsp\n    popq    %rbp\n    ret\n```", "```\nconvert_function_call(FunCall(fun_name, args, dst)):\n    arg_registers = [DI, SI, DX, CX, R8, R9]\n\n    // adjust stack alignment\n    register_args, stack_args = first 6 args, remaining args\n    if length(stack_args) is odd:\n        stack_padding = 8\n    else:\n        stack_padding = 0\n\n    if stack_padding != 0:\n        emit(AllocateStack(stack_padding))\n\n // pass args in registers\n    reg_index = 0\n    for tacky_arg in register_args:\n        r = arg_registers[reg_index]\n        assembly_arg = convert_val(tacky_arg)\n        emit(Mov(assembly_arg, Reg(r)))\n        reg_index += 1\n\n    // pass args on stack\n    for tacky_arg in reverse(stack_args):\n        assembly_arg = convert_val(tacky_arg)\n        if assembly_arg is a Reg or Imm operand:\n          ❶ emit(Push(assembly_arg))\n        else:\n          ❷ emit(Mov(assembly_arg, Reg(AX)))\n            emit(Push(Reg(AX)))\n\n    // emit call instruction\n    emit(Call(fun_name))\n\n    // adjust stack pointer\n    bytes_to_remove = 8 * length(stack_args) + stack_padding\n    if bytes_to_remove != 0:\n        emit(DeallocateStack(bytes_to_remove))\n\n    // retrieve return value\n    assembly_dst = convert_val(dst)\n    emit(Mov(Reg(AX), assembly_dst))\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name,</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">[Mov(Reg(DI), param1),\n            Mov(Reg(SI), param2),</samp> \n             <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy next four parameters from registers>,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">\n            Mov(Stack(16), param7),\n            Mov(Stack(24), param8),\n           </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining parameters from stack></samp><samp class=\"SANS_Futura_Std_Book_11\">]</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">+</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">\n         instructions)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><fix stack alignment>\n<set up arguments></samp> \n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Call(fun_name)</samp> \n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><deallocate arguments/padding></samp> \n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(Reg(AX), dst)</samp>\n```", "```\n call _foo\n```", "```\n call foo\n```", "```\n call foo@PLT\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Print out each function definition.</samp> \n<samp class=\"SANS_Futura_Std_Book_11\">On Linux, add at end of file:</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.section .note.GNU-stack,\"\",@progbits</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">addq    $</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><int></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, %rsp</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">pushq  </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">call   </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><label></samp> \n<samp class=\"SANS_Futura_Std_Heavy_B_11\">or\ncall      </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><label></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">@PLT</samp>\n```", "```\nint putchar(int c);\n\nint main(void) {\n    putchar(72);\n    putchar(101);\n    putchar(108);\n    putchar(108);\n    putchar(111);\n    putchar(44);\n    putchar(32);\n    putchar(87);\n    putchar(111);\n    putchar(114);\n    putchar(108);\n    putchar(100);\n    putchar(33);\n    putchar(10);\n}\n```", "```\n$ **./hello_world**\nHello, World!\n```"]