- en: '**23  Game Boy Via ROM**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nintendo’s Game Boy, internally known as the Dot Matrix Game (DMG), did not
    feature the CIC protection chip that we’ll discuss in [Chapter 25](ch25.xhtml#ch25).
    Instead of a lockout chip, the game cartridge is required to contain Nintendo’s
    logo.
  prefs: []
  type: TYPE_NORMAL
- en: This is enforced by a first-stage boot ROM that compares its own copy of the
    logo to one in the cartridge. If the logos match, a short animation and sound
    are presented before the ROM disables itself and jumps into the game cartridge.
    In this chapter, we’ll take the last chapter’s theory and use it to rip out the
    ROM contents and make our own disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’ve already realized that anyone can put any logo into a cartridge,
    and that the logo comparison is not a technical challenge when making an unlicensed
    game. The enforcement mechanism was not technical; rather, it was Nintendo’s legal
    counsel, who would gleefully sue the living hell out of anyone who used their
    trademark without permission. And if you, dear reader, happen to be one of Nintendo’s
    lawyers, please don’t sue me.
  prefs: []
  type: TYPE_NORMAL
- en: Neviksti (2005) describes an extraction of the ROM. I repeated this in my own
    lab to produce the ROM photograph in [Figure 23.5](ch23.xhtml#ch23fig5). Bits
    are clearly visible in surface photographs of the die, without any delayering
    or staining, making this an excellent first target.
  prefs: []
  type: TYPE_NORMAL
- en: As with any chemistry, please be careful not to get yourself hurt. The hassles
    of doing this slowly and safely are worth keeping your eyes and your fingers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0218-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.1: End of the Game Boy ROM from Neviksti (2005)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decapsulation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the ROM, we first need to sacrifice a Game Boy. The CPU is labeled `DMG-CPU
    B`, and you can find it on the board that is closer to the back of the device,
    away from the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: (ROMs of the Game Boy Color and the Super Game Boy are not clearly visible from
    the surface. See [Chapter E.4](app05.xhtml#app05_4) for a glitching attack that
    keeps the ROM visible while executing code from cartridge memory.)
  prefs: []
  type: TYPE_NORMAL
- en: Decapsulation is performed with the HNO[3] bath method from [Chapter 18](ch18.xhtml#ch18).
    Bits are surface visible, so there’s no need for the delayering procedures that
    require more dangerous chemicals. We pretty much just boil the whole QFP package
    in 65% nitric acid until the packaging falls away, then clean it in acetone and
    isopropyl alcohol for photography.
  prefs: []
  type: TYPE_NORMAL
- en: '**Photography**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ROM that we’re after is in the CPU, whose surface die photograph is shown
    in [Figure 23.2](ch23.xhtml#ch23fig2). Bits are impossible to see at that magnification,
    so see [Figure 23.3](ch23.xhtml#ch23fig3) for a closeup.
  prefs: []
  type: TYPE_NORMAL
- en: To locate the ROM, first find the memory bus, which is the horizontal nest of
    wires roughly in the middle of the chip. Starting from the western edge, follow
    the bus toward the east until it dead-ends at the eastern sea of gates. The ROM
    is the thin horizontal structure just north of that bus and just west of the sea
    of gates. At a decent magnification, the bits will pop out at you, looking almost
    like foreign writing at a distance just too far to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: The dark spots are via wires that connect layers vertically, while the bright
    spots are the absence of a via. This makes the color of the spot imply the value
    of the bit. Not all vias are bits, of course, but in [Figure 23.3](ch23.xhtml#ch23fig3)
    you should see two columns of eight bits and the first six rows. The vias in the
    longer metal lines, those that reach the power rail at the top of the image, are
    not bits and should not be extracted. To be sure that you understand what is and
    is not a bit, please take a moment to produce the ASCII art table from the photograph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0220-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.2: Nintendo DMG-01-CPU from a Game Boy'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0221-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.3: Close-up of DMG-01-CPU Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0221-01a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.4: Nintendo Logo at `0xA8` (ROM) and `0x104` (Cart).'
  prefs: []
  type: TYPE_NORMAL
- en: After locating the ROM and its bits, I photographed it as a panorama of twenty-two
    images at 50x magnification through a metallurgical microscope. These images were
    stitched together with Hugin and Panotools to form a panorama that is 9,000 pixels
    wide and 2,249 pixels tall. You can find it in reduced resolution as [Figure 23.5](ch23.xhtml#ch23fig5),
    or as a digital file.^([1](footnotes.xhtml#ch23fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit Extraction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a photograph of the chip, the next step is to extract the bits into a
    textfile.
  prefs: []
  type: TYPE_NORMAL
- en: I used Mask ROM Tool for this, drawing lines for each column and row. This ROM
    is rather small and the stitched image was quite well aligned, so I could place
    row and column lines that span the entire length of the ROM.
  prefs: []
  type: TYPE_NORMAL
- en: The software marks a bit wherever a row and column intersect, and it helpfully
    draws a histogram of the bits for me to choose a threshold color between ones
    and zeroes. Both the red and green colors channels have a clear separation between
    ones and zeroes, but I found that green had a wider gap, so that’s the best channel
    for sampling. The color I used was that of the pixel at the center of the bit;
    there was no need for more complicated sampling strategies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0223-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.5: ASCII Art of the DMG-01-CPU Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0224-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.6: Game Boy Memory Map'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit Decoding**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After extracting the physically ordered ASCII art bits in [Figure 23.5](ch23.xhtml#ch23fig5),
    the next challenge is to decode it. Let’s look at three ways to do that.
  prefs: []
  type: TYPE_NORMAL
- en: McMaster (2018) uses this chip as an example for automatically solving bit decoding
    given known plaintext. The Game Boy uses a Sharp LR35902 CPU, which is roughly
    like a Z80\. Like the Z80, LR35902 code usually sets the stack pointer in the
    very first instruction with the `0x31` opcode. McMaster therefore searches with
    his Zorrom tool for all decodings in which the first byte comes out as `0x31`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0225-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These filenames contain the decoding parameters, in which both are rotated 180
    ^°C and flipped on the X axis. Bits are inverted, and the only difference is that
    one uses the `cols-left` strategy while the other uses the `cols-downr` strategy.
  prefs: []
  type: TYPE_NORMAL
- en: He then uses the `unidasm` disassembler from MAME to examine each file’s first
    instruction. The `cols-left` variant begins with `31 11 47`, setting the stack
    pointer to `0x4711`, while the `cols-downr` variant begins with `31 fe ff`, setting
    the stack pointer to `0xfffe`. From the memory map in [Figure 23.6](ch23.xhtml#ch23fig6),
    we can see that the latter is a much more reasonable value, at the tail end of
    high RAM rather than a random address in the middle of the banked cartridge ROM.
  prefs: []
  type: TYPE_NORMAL
- en: We can also perform the same solution with GatoROM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0225-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Automated tools are great when they work, but we should always be suspicious
    of tools that we don’t understand. The `cols-downr` mode is not very complex;
    it just means that bytes are encoded in 16-bit logical columns made of two 8-bit
    physical columns. The leftmost column contains the most significant bits, and
    the first byte of the row is in the leftmost position. To get the next byte, first
    work downward and then move everything one step to the right.
  prefs: []
  type: TYPE_NORMAL
- en: The tail end of the ROM, shown in disassembly in [Figure 23.1](ch23.xhtml#ch23fig1),
    disables read access at `0x00fe` by writing 1 into the register at `0xff50` before
    continuing into cartridge memory at `0x0100`. This is why dumping the ROM is not
    as simple as building a cartridge to display it on the screen, export it through
    the link port, or beep it through the speaker.
  prefs: []
  type: TYPE_NORMAL
