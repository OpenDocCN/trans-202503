["```\ntype Person (id : Guid, name : string, age : int) =\n  member x.Id = id\n  member x.Name = name\n  member x.Age = age\n```", "```\ntype ConstructorlessClass = class end\n```", "```\nlet me = **Person(Guid.NewGuid(), \"Dave\", 33)**\n```", "```\ntype Person  ①(name : string, dob : System.DateTime) =\n② let age = (System.DateTime.Now - dob).TotalDays / 365.25\n③ do printfn \"Creating person: %s (Age: %f)\" name age\n  member x.Name = name\n  member x.DateOfBirth = dob\n  member x.Age = age\n```", "```\ntype Person (name, age) =\n  do printfn \"Creating person: %s (Age: %i)\" name age\n  member x.Name = name\n  member x.Age = age\n\nlet me = Person (\"Dave\", 33)\n```", "```\ntype Greeter **private** () =\n  static let _instance = lazy (Greeter())\n  static member Instance with get() = _instance.Force()\n  member x.SayHello() = printfn \"hello\"\n\nGreeter.Instance.SayHello()\n```", "```\ntype Person (name, age) =\n  do printfn \"Creating person: %s (Age: %i)\" name age\n  **new (name) = Person(name, 0)**\n  **new () = Person(\"\")**\n  member x.Name = name\n  member x.Age = age\n```", "```\ntype Person (name, age) =\n  do printfn \"Creating person: %s (Age: %i)\" name age\n  new (name) = Person(name, 0)\n               **then printfn \"Creating person with default age\"**\n  new () = Person(\"\")\n           **then printfn \"Creating person with default name and age\"**\n  member x.Name = name\n  member x.Age = age\n```", "```\ntype Person =\n  val _name : string\n  val _age : int\n  new (name, age) = { _name = name; _age = age }\n  new (name) = Person(name, 0)\n  new () = Person(\"\")\n  member x.Name = x._name\n  member x.Age = x._age\n```", "```\ntype Person (name, age) **as this** =\n  do printfn \"Creating person: %s (Age: %i)\" this.Name this.Age\n  member x.Name = name\n  member x.Age = age\n```", "```\ntype Person (name, age) as **``This is a bad identifier``** =\n  do\n    printfn \"Creating person: %s (Age: %i)\"\n      **``This is a bad identifier``.Name**\n      **``This is a bad identifier``.Age**\n      member x.Name = name\n      member x.Age = age\n```", "```\ntype Person () =\n  **let mutable name : string = \"\"**\n  member x.Name\n    with get() = name\n    and set(v) = name <- v\n```", "```\ntype Person () =\n  **[<DefaultValue>] val mutable n : string**\n  member x.Name\n    with get() = x.n\n    and set(v) = x.n <- v\n```", "```\n> **let p = Person()**\np.Name;;\n\nval p : Person\nval it : string = null\n```", "```\ntype Person () =\n  [<DefaultValue>] val mutable **private** n : string\n  -- *snip* --\n```", "```\ntype Person() =\n  **let mutable name = \"\"**\n  **member x.Name**\n    **with get() = name**\n    **and set(value) = name <- value**\n```", "```\nlet me = Person()\nme.Name <- \"Dave\"\n```", "```\ntype Person() =\n  let mutable name = \"\"\n  **member x.Name with get() = name**\n  **member x.Name with set(value) = name <- value**\n```", "```\ntype Person() =\n  let mutable name = \"\"\n  member x.Name\n    with **public** get() = name\n    and **internal** set(value) = name <- value\n```", "```\ntype Person(name) =\n  member x.Name with get() = name\n```", "```\ntype Person(name) =\n  member x.Name = name\n```", "```\ntype Person() =\n  **member val Name = \"\" with get, set**\n```", "```\ntype Person(name) =\n  **member val Name = name**\n```", "```\ntype Sentence(initial : string) =\n  let mutable words = initial.Split ' '\n  let mutable text = initial\n  **member x.Item**\n    **with get i = words.[i]**\n    **and set i v =**\n      **words.[i] <- v**\n      **text <- System.String.Join(\" \", words)**\n```", "```\n> let s = Sentence \"Don't forget to drink your Ovaltine\"\n**s.[1];;**\n\nval s1 : Sentence\nval it : string = \"forget\"\n```", "```\n> **s.[1] <- \"remember\";;**\nval it : unit = ()\n> **s.[1];;**\nval it : string = \"remember\"\n```", "```\ntype Sentence(initial : string) =\n  -- *snip* --\n  member x.Item with get(w, i) = words.[w].[i]\n```", "```\n> **s.[1, 0];;**\nval it : char = 'f'\n```", "```\ntype Sentence(initial : string) =\n  -- *snip* --\n  member x.Chars with get(i) = text.[i]\n```", "```\n> **s.Chars(0);;**\nval it : char = 'D'\n```", "```\ntype Person() =\n  member val Name = \"\" with get, set\n```", "```\nlet p = Person(Name = \"Dave\")\n```", "```\nopen System\n\ntype Circle(diameter : float) =\n  member x.Diameter = diameter\n  **member x.GetArea() =**\n    **let r = diameter / 2.0**\n    **System.Math.PI * (r ** 2.0)**\n```", "```\n> **let c = Circle 5.0**\n**c.GetArea();;**\n\nval c : Circle\nval it : float = 19.63495408\n```", "```\ntype Circle(diameter : float) =\n  member **private** x.GetRadius() = diameter / 2.0\n  member x.Diameter = diameter\n  member x.GetArea() = System.Math.PI * (x.GetRadius() ** 2.0)\n```", "```\ntype Circle(diameter : float) =\n  **let getRadius() = diameter / 2.0**\n  member x.Diameter = diameter\n  member x.GetArea() = System.Math.PI * (getRadius() ** 2.0)\n```", "```\nopen System\nopen System.Drawing\n\ntype ColorDistance() =\n  member x.GetEuclideanDistance(c1 : Color, c2 : Color) =\n    let getPointDistance p1 p2 = (float p1 - float p2) ** 2.0\n    [ getPointDistance c1.R c2.R\n      getPointDistance c1.G c2.G\n      getPointDistance c1.B c2.B ] |> List.sum |> Math.Sqrt\n```", "```\n> **let d = ColorDistance()**\n**d.GetEuclideanDistance(Color.White, Color.Black);;**\n\nval d : ColorDistance\nval it : float = 441.6729559\n\n> **d.GetEuclideanDistance(c2 = Color.White, c1 = Color.Snow);;**\nval it : float = 7.071067812\n```", "```\nopen System.IO\n\ntype Repository() =\n  member ① x.Commit(files, desc, branch) =\n    printfn \"Committed %i files (%s) to \\\"%s\\\"\" (List.length files) desc branch\n  member ② x.Commit(files, desc) =\n    x.Commit(files, desc,  ③\"default\")\n```", "```\nopen System.IO\n\ntype Repository() =\n  static member Commit(files, desc, ?branch) =\n    let targetBranch = defaultArg branch \"default\"\n    printfn \"Committed %i files (%s) to \\\"%s\\\"\" (List.length files) desc targetBranch\n```", "```\ntype Sentence(initial : string) =\n  let words = initial.Split ' '\n  let text = initial\n  member x.GetSlice(lower, upper) =\n    match defaultArg lower 0 with\n    | l when l >= words.Length -> Array.empty<string>\n    | l -> match defaultArg upper (words.Length - 1) with\n           | u when u >= words.Length -> words.[l..]\n           | u -> words.[l..u]\n```", "```\n> **let s = Sentence \"Don't forget to drink your Ovaltine\"**\n**s.[1..3];;**\n\nval s : Sentence\nval it : string [] = [|\"forget\"; \"to\"; \"drink\"|]\n```", "```\n> **s.[..3];;**\nval it : string [] = [|\"Don't\"; \"forget\"; \"to\"; \"drink\"|]\n```", "```\n> **s.[3..];;**\nval it : string [] = [|\"drink\"; \"your\"; \"Ovaltine\"|]\n```", "```\ntype Sentence(initial : string) =\n  -- *snip* --\n  member x.GetSlice(lower1, upper1, lower2, upper2) =\n    x.GetSlice(lower1, upper1)\n    |> Array.map\n        (fun w -> match defaultArg lower2 0 with\n                  | l when l >= w.Length -> \"\"\n                  | l -> match defaultArg upper2 (w.Length - 1) with\n                         | u when u >= w.Length -> w.[l..]\n                         | u -> w.[l..u])\n```", "```\n> **s.[1..4, ..1];;**\nval it : string [] = [|\"fo\"; \"to\"; \"dr\"; \"yo\"|]\n```", "```\n  let ticks = ref 0\n  let t = ① new System.Timers.Timer(500.0)\n  t.Elapsed.Add ② (fun ea -> printfn \"tick\"; ticks := ticks.Value + 1)\n③ t.Start()\n  while ticks.Value < 5 do ()\n  t.Dispose()\n```", "```\n  open System\n  open System.Data\n\n  let dt = new DataTable(\"person\")\n  dt.Columns.AddRange\n    [| new DataColumn(\"person_id\", typedefof<int>)\n       new DataColumn(\"first_name\", typedefof<string>)\n       new DataColumn(\"last_name\", typedefof<string>) |]\n  dt.Constraints.Add(\"pk_person\", dt.Columns.[0], true)\n\n  let 1 h1, h2 =\n2 dt.RowChanged\n    |> 3 Event.partition\n           4(fun ea ->\n              let ln = ea.Row.[\"last_name\"] :?> string\n              ln.Equals(\"Pond\", StringComparison.InvariantCultureIgnoreCase))\n\n5 h1.Add (fun _ -> printfn \"Come along, Pond\")\n6 h2.Add (fun _ -> printfn \"Row changed\")\n```", "```\n**> dt.Rows.Add(1, \"Rory\", \"Williams\") |> ignore;;**\nRow changed\nval it : unit = ()\n**> dt.Rows.Add(2, \"Amelia\", \"Pond\") |> ignore;;**\nCome along, Pond\nval it : unit = ()\n```", "```\ntype Toggle() =\n  **let toggleChangedEvent = Event<_>()**\n  let mutable isOn = false\n\n  member x.ToggleChanged = **toggleChangedEvent.Publish**\n\n  member x.Toggle() =\n    isOn <- not isOn\n    **toggleChangedEvent.Trigger (x, isOn)**\n```", "```\nlet myToggle = Toggle()\nlet onHandler, offHandler =\n  **myToggle.ToggleChanged**\n  |> **Event.map** (fun (_, isOn) -> isOn)\n  |> **Event.partition** (fun isOn -> isOn)\n\nonHandler |> **Event.add** (fun _ -> printfn \"Turned on!\")\noffHandler |> **Event.add** (fun _ -> printfn \"Turned off!\")\n```", "```\n**> myToggle.Toggle();;**\nTurned on!\nval it : unit = ()\n**> myToggle.Toggle();;**\nTurned off!\nval it : unit = ()\n```", "```\n**[<CLIEvent>]**\nmember x.ToggleChanged = toggleChangedEvent.Publish\n```", "```\n**[<Struct>]**\ntype Circle(diameter : float) =\n  member x.getRadius() = diameter / 2.0\n  member x.Diameter = diameter\n  member x.GetArea() = System.Math.PI * (x.getRadius() ** 2.0)\n```", "```\ntype BaseType() =\n  member x.SayHello name = printfn \"Hello, %s\" name\n\ntype DerivedType() =\n  inherit BaseType()\n```", "```\ntype WorkItem(summary : string, desc : string) =\n  member val Summary = summary\n  member val Description = desc\n\ntype Defect(summary, desc, severity : int) =\n  **inherit WorkItem(summary, desc)**\n  member val Severity = severity\ntype Enhancement(summary, desc, requestedBy : string) =\n  **inherit WorkItem(summary, desc)**\n  member val RequestedBy = requestedBy\n```", "```\n**> let w = Defect(\"Incompatibility detected\", \"Delete\", 1) :> WorkItem;;**\nval w : WorkItem\n```", "```\n**> let d = w :?> Defect;;**\nval d : Defect\n```", "```\n**> let e = w :?> Enhancement;;**\nSystem.InvalidCastException: Unable to cast object of type 'Defect' to type 'Enhancement'.\n   at Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric[T](Object source)\n   at <StartupCode$FSI_0007>.$FSI_0007.main@()\nStopped due to error\n```", "```\n**> let w = WorkItem(\"Take out the trash\", \"It's overflowing!\")**\n**w.ToString();;**\n\nval w : WorkItem\nval it : string = \"FSI_0002+WorkItem\"\n```", "```\ntype WorkItem(summary : string, desc : string) =\n  -- *snip* --\n  **override** x.ToString() = sprintf \"%s\" x.Summary\n```", "```\n**> let w = WorkItem(\"Take out the trash\", \"It's overflowing!\")**\n**w.ToString();;**\n\nval w : WorkItem = Take out the trash\nval it : string = \"Take out the trash\"\n```", "```\ntype Defect(summary, desc, severity : int) =\n  inherit WorkItem(summary, desc)\n  member val Severity = severity\n  **override x.ToString() = sprintf \"%s (%i)\" x.Summary x.Severity**\n```", "```\ntype Defect(summary, desc, severity : int) =\n  -- *snip* --\n  override x.ToString() =\n    sprintf \"%s (%i)\" (**base.ToString()**) x.Severity\n```", "```\ntype WorkItem(summary : string, desc : string) =\n  inherit System.Object()\n  -- *snip* --\n  override x.ToString() =\n    sprintf \"[%s] %s\" (base.ToString()) x.Summary\n```", "```\n**[<AbstractClass>]**\ntype Node(name : string, ?content : Node list) =\n  member x.Name = name\n  member x.Content = content\n```", "```\n[<AbstractClass>]\ntype AbstractBaseClass() =\n  **abstract member SomeData : string with get, set**\n```", "```\ntype BindingBackedClass() =\n  **inherit AbstractBaseClass()**\n  let mutable someData = \"\"\n  **override x.SomeData**\n    with get() = someData\n    and set(v) = someData <- v\n\ntype DictionaryBackedClass() =\n  **inherit AbstractBaseClass()**\n  let dict = System.Collections.Generic.Dictionary<string, string>()\n[<Literal>]\nlet SomeDataKey = \"SomeData\"\n**override x.SomeData**\n  with get() =\n    match dict.TryGetValue(SomeDataKey) with\n    | true, v -> v\n    | _, _ -> \"\"\n  and set(v) =\n    match System.String.IsNullOrEmpty(v) with\n    | true when dict.ContainsKey(SomeDataKey) ->\n        dict.Remove(SomeDataKey) |> ignore\n    | _ -> dict.[SomeDataKey] <- v\n```", "```\n[<AbstractClass>]\ntype Shape() =\n  **abstract member GetArea : unit -> float**\n```", "```\nopen System\n\ntype Circle(r : float) =\n  inherit Shape()\n  member val Radius = r\n  **override x.GetArea()** =\n    Math.Pow(Math.PI * r, 2.0)\n\ntype Rectangle(w : float, h : float) =\n  inherit Shape()\n  member val Width = w\n  member val Height = h\n  **override x.GetArea()** = w * h\n```", "```\nopen System\nopen System.Collections.Generic\n\ntype Node(name : string) =\n  let children = List<Node>()\n  member x.Children with get() = children.AsReadOnly()\n  **abstract member AddChild : Node -> unit**\n  **abstract member RemoveChild : Node -> unit**\n  **default x.AddChild(n) = children.Add n**\n  **default x.RemoveChild(n) = children.Remove n |> ignore**\n```", "```\ntype TerminalNode(name : string) =\n  inherit Node(name)\n  [<Literal>]\n  let notSupportedMsg = \"Cannot add or remove children\"\n  **override x.AddChild(n)** =\n    raise (NotSupportedException(notSupportedMsg))\n  **override x.RemoveChild(n)** =\n    raise (NotSupportedException(notSupportedMsg))\n```", "```\n**[<Sealed>]**\ntype NotInheritable() = class end\n```", "```\n> **type InvalidClass() =**\n     **inherit NotInheritable();;**\n\n       inherit NotInheritable();;\n       --^^^^^^^^^^^^^^^^^^^^^^^^\n\nstdin(4,3): error FS0945: Cannot inherit a sealed type\n```", "```\ntype ClassWithStaticCtor() =\n  **static let mutable staticField = 0**\n  **static do printfn \"Invoking static initializer\"**\n            **staticField <- 10**\n  do printfn \"Static Field Value: %i\" staticField\n```", "```\nmodule Logger =\n  let private log l c m = printfn \"%-5s [%s] %s\" l c m\n  let LogInfo = log \"INFO\"\n  let LogError = log \"ERROR\"\n\ntype MyService() =\n  **static let logCategory = \"MyService\"**\n  member x.DoSomething() =\n    Logger.LogInfo logCategory \"Doing something\"\n  member x.DoSomethingElse() =\n    Logger.LogError logCategory \"Doing something else\"\n```", "```\n> **let svc = MyService()**\n**svc.DoSomething()**\n**svc.DoSomethingElse();;**\nINFO [MyService] Doing something\nERROR [MyService] Doing something else\n```", "```\ntype Processor() =\n  static let mutable itemsProcessed = 0\n  **static member ItemsProcessed = itemsProcessed**\n  member x.Process() =\n    **itemsProcessed <- itemsProcessed + 1**\n    printfn \"Processing...\"\n```", "```\n> **while Processor.ItemsProcessed < 5 do (Processor()).Process();;**\nProcessing...\nProcessing...\nProcessing...\nProcessing...\nProcessing...\nval it : unit = ()\n```", "```\n[<AbstractClass>]\ntype ImageReader() =\n  abstract member Dimensions : int * int with get\n  abstract member Resolution : int * int with get\n  abstract member Content : byte array with get\n\ntype JpgImageReader(fileName : string) =\n  inherit ImageReader()\n  -- *snip* --\n\ntype GifImageReader(fileName : string) =\n  inherit ImageReader()\n  -- *snip* --\n\ntype PngImageReader(fileName : string) =\n  inherit ImageReader()\n  -- *snip* --\n```", "```\nopen System.IO\n\n[<Sealed>]\ntype ImageReaderFactory private() =\n  static member CreateReader(fileName) =\n    let fi = FileInfo(fileName)\n\n    match fi.Extension.ToUpper() with\n    | \".JPG\" -> JpgImageReader(fileName) :> ImageReader\n    | \".GIF\" -> GifImageReader(fileName) :> ImageReader\n    | \".PNG\" -> PngImageReader(fileName) :> ImageReader\n    | ext -> failwith (sprintf \"Unsupported extension: %s\" ext)\n```", "```\nImageReaderFactory.CreateReader \"MyPicture.jpg\"\nImageReaderFactory.CreateReader \"MyPicture.gif\"\nImageReaderFactory.CreateReader \"MyPicture.png\"\nImageReaderFactory.CreateReader \"MyPicture.targa\"\n```", "```\n**type Book() =**\n  let pages = List<Page>()\n  member x.Pages with get() = pages.AsReadOnly()\n  member x.AddPage(pageNumber : int, page : Page) =\n    if page.Owner = Some(x) then failwith \"Page is already part of a book\"\n    pages.Insert(pageNumber - 1, page)\n**and Page(content : string) =**\n  let mutable owner : Book option = None\n  member x.Content = content\n  member x.Owner with get() = owner\n  member internal x.Owner with set(v) = owner <- v\n  override x.ToString() = content\n```", "```\n// C#\n\nclass ImplicitExample : IDisposable\n{\n① **public void Dispose()**\n  {\n    Console.WriteLine(\"Disposing\");\n  }\n}\n\nclass ExplicitExample : IDisposable\n{\n② **void IDisposable.Dispose()**\n  {\n    Console.WriteLine(\"Disposing\");\n  }\n}\n```", "```\n  // C#\n\n  var ex1 = ①new ImplicitExample();\n② ex1.Dispose();\n\n  var ex2 = ③ new ExplicitExample();\n④ ((IDisposable)ex2).Dispose();\n```", "```\nopen System\n\ntype MyDisposable() =\n  **interface IDisposable with**\n    member x.Dispose() = printfn \"Disposing\"\n```", "```\nlet d = new MyDisposable()\n(d :> IDisposable).Dispose()\n```", "```\nopen System.Drawing\nopen System.IO\n\n**type IImageAdapter =**\n  **abstract member PixelDimensions : SizeF with get**\n  **abstract member VerticalResolution : int with get**\n  **abstract member HorizontalResolution : int with get**\n  **abstract member GetRawData : unit -> Stream**\n```", "```\ntype IMarker = **interface end**\n```", "```\ntype ITransparentImageAdapter =\n  inherit IImageAdapter\n  abstract member TransparentColor : Color with get, set\n```", "```\ntype RgbColor(r, g, b) =\n  member x.Red = r\n  member x.Green = g\n  member x.Blue = b\n  override x.ToString() = sprintf \"(%i, %i, %i)\" r g b\n```", "```\ntype RgbColor(r, g, b) =\n  -- *snip* --\n  /// Negate a color\n  **static member (~-) (r : RgbColor) =**\n    RgbColor(\n      r.Red ^^^ 0xFF,\n      r.Green ^^^ 0xFF,\n      r.Blue ^^^ 0xFF\n    )\n```", "```\n**> let yellow = RgbColor(255, 255, 0)**\n**let blue = -yellow;;**\n\nval yellow : RgbColor = (255, 255, 0)\nval blue : RgbColor = (0, 0, 255)\n```", "```\nopen System\n\ntype RgbColor(r, g, b) =\n  -- *snip* --\n  /// Add two colors\n  **static member (+) (l : RgbColor, r : RgbColor) =**\n    RgbColor(\n      Math.Min(255, l.Red + r.Red),\n      Math.Min(255, l.Green + r.Green),\n      Math.Min(255, l.Blue + r.Blue)\n    )\n  /// Subtract two colors\n  **static member (-) (l : RgbColor, r : RgbColor) =**\n    RgbColor(\n      Math.Max(0, l.Red - r.Red),\n      Math.Max(0, l.Green - r.Green),\n      Math.Max(0, l.Blue - r.Blue)\n    )\n```", "```\n**> let red = RgbColor(255, 0, 0)**\n**let green = RgbColor(0, 255, 0)**\n**let yellow = red + green;;**\n\nval red : RgbColor = (255, 0, 0)\nval green : RgbColor = (0, 255, 0)\nval yellow : RgbColor = (255, 255, 0)\n\n**> let magenta = RgbColor(255, 0, 255)**\n**let blue = magenta - red;;**\n\nval magenta : RgbColor = (255, 0, 255)\nval blue : RgbColor = (0, 0, 255)\n```", "```\ntype RgbColor(r, g, b) =\n  -- *snip* --\n  /// Blend two colors\n  **static member (+=) (l : RgbColor, r : RgbColor) =**\n    RgbColor(\n      (l.Red + r.Red) / 2,\n      (l.Green + r.Green) / 2,\n      (l.Blue + r.Blue) / 2\n    )\n```", "```\n**> let grey = yellow += blue;;**\n\nval grey : RgbColor = (127, 127, 127)\n```", "```\nopen System\nopen System.Drawing\n\n**let (+) (l : Color) (r : Color) =**\n    Color.FromArgb(\n      255, // Alpha channel\n      Math.Min(255, int <| l.R + r.R),\n      Math.Min(255, int <| l.G + r.G),\n      Math.Min(255, int <| l.B + r.B)\n    )\n```", "```\ntype IWeapon =\n  abstract Description : string with get\n  abstract Power : int with get\n\ntype Character(name : string, maxHP : int) =\n  member x.Name = name\n  member val HP = maxHP with get, set\n  member val Weapon : IWeapon option = None with get, set\n  member x.Attack(o : Character) =\n    let power = match x.Weapon with\n                | Some(w) -> w.Power\n                | None -> 1 // fists\n    o.HP <- System.Math.Max(0, o.HP - power)\n  override x.ToString() =\n    sprintf \"%s: %i/%i\" name x.HP maxHP\n```", "```\nlet witchKing = Character(\"Witch-king\", 100)\nlet frodo = Character(\"Frodo\", 50)\n```", "```\nlet forgeWeapon desc power =\n  **{ new IWeapon with**\n      **member x.Description with get() = desc**\n      **member x.Power with get() = power }**\n```", "```\n> **let morgulBlade = forgeWeapon \"Morgul-blade\" 25**\n**let sting = forgeWeapon \"Sting\" 10;;**\n\nval morgulBlade : IWeapon\nval sting : IWeapon\n```", "```\nwitchKing.Weapon <- Some(morgulBlade)\nfrodo.Weapon <- Some(sting)\n\nwitchKing.Attack frodo\n```", "```\nlet forgeWeapon desc power =\n  { new IWeapon with\n      member x.Description with get() = desc\n      member x.Power with get() = power\n    **interface System.IDisposable with**\n      **member x.Dispose() = printfn \"Disposing\"** }\n```", "```\nlet narsil = forgeWeapon \"Narsil\" 25\n```", "```\n(narsil :?> System.IDisposable).Dispose()\n```", "```\nmodule ColorExtensions =\n  open System\n  open System.Drawing\n  open System.Text.RegularExpressions\n\n  // Regular expression to parse the ARGB components from a hex string\n① let private hexPattern =\n    Regex(\"^#(?<color>[\\dA-F]{8})$\", RegexOptions.IgnoreCase ||| RegexOptions.Compiled)\n\n  // Type extension\n② type Color with\n  ③ static member FromHex(hex) =\n      match hexPattern.Match hex with\n      | matches when matches.Success ->\n        Color.FromArgb <| Convert.ToInt32(matches.Groups.[\"color\"].Value, 16)\n      | _ -> Color.Empty\n  ④ member x.ToHex() = sprintf \"#%02X%02X%02X%02X\" x.A x.R x.G x.B\n```"]