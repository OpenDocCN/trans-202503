<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><span class="big">1</span><br/>AN END USER’S PERSPECTIVE ON THE GNU AUTOTOOLS</h2>&#13;
<p class="quote"><em>I am not afraid of storms, for I am learning how to sail my ship.</em><br/>—<em>Louisa May Alcott</em>, Little Women</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">If you’re not a software developer, either by trade or by hobby, you may still have a need or desire at some point to build open source software to be installed on your computer. Perhaps you’re a graphic artist who wishes to use the latest version of GIMP, or maybe you’re a video enthusiast and you need to build a late version of FFmpeg. This chapter, therefore, may be the only one you read in this book. I hope that is not the case, because even a power user can gain so much more by striving to understand what goes on under the covers. Nevertheless, this chapter is designed for you. Here, I’ll discuss what to do with that so-called <em>tarball</em> you downloaded from that project website. I’ll use the Autoconf package to illustrate, and I’ll try to provide enough <span epub:type="pagebreak" id="page_2"/>context so that you can follow the same process for any package you download<sup><a id="ch01fn_1" href="footnote.xhtml#ch01fn1">1</a></sup> from a project website.</p>&#13;
<p class="indent">If you are a software developer, there’s a good chance the material in this chapter is too basic for you; therefore, I’d recommend skipping right to the next chapter, where we’ll jump into a more developer-centric discussion of the Autotools.</p>&#13;
<h3 class="h3" id="ch01sec1">Software Source Archives</h3>&#13;
<p class="noindent">Open source software is distributed as single-file source archives containing the source and build files necessary to build the software on your system. Linux distributions remove much of the pain for end users by prebuilding these source archives and packaging the built binaries into installation packages ending in extensions like <em>.rpm</em> (for Red Hat–based systems) and <em>.deb</em> (for Debian/Ubuntu-based systems). Installing software using your system package manager is relatively easy, but sometimes you need the latest feature set of some software and it hasn’t yet been packaged for your particular flavor of Linux. When this happens, you need to download the source archive from the project website’s download page and then build and install it yourself. Let’s begin by downloading version 2.69 of the Autoconf package:</p>&#13;
<pre>$ <span class="codestrong1">wget https://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz</span></pre>&#13;
<p class="indent">Source archive names generally follow a de facto standard format supported by the Autotools. Unless the project maintainer has gone out of their way to modify this format, the Autotools will automatically generate a source archive file named according to the following template: <em>pkgname</em>-<em>version</em>.<em>format</em>. Here, <em>pkgname</em> is the short name of the software, <em>version</em> is the version of the software, and <em>format</em> represents the archive format, or file extensions. The <em>format</em> portion may contain more than one period, depending on the way the archive was built. For instance, <em>.tar.gz</em> represents two encodings in the format—a <span class="literal">tar</span> archive that has been compressed with the <span class="literal">gzip</span> utility, as is the case with the Autoconf source archive:</p>&#13;
<pre>$ <span class="codestrong1">ls -1</span>&#13;
autoconf-2.69.tar.gz&#13;
automake-1.16.1.tar.gz&#13;
gettext-0.19.8.1.tar.gz&#13;
libtool-2.4.6.tar.gz&#13;
pkg-config-0.29.2.tar.gz&#13;
$</pre>&#13;
<h3 class="h3" id="ch01sec2"><span epub:type="pagebreak" id="page_3"/>Unpacking a Source Archive</h3>&#13;
<p class="noindent">By convention, source archives contain a single root directory as the top-level entry. You should feel safe unpacking a source archive to find only a single new directory in the current directory, named the same as the archive file minus the <em>format</em> portion. Source archives packaged using Autotools-based build systems never unpack the contents of the original top-level directory into the current directory.</p>&#13;
<p class="indent">Nevertheless, occasionally, you’ll download an archive and unpack it to find dozens of new files in the current directory. It’s therefore prudent to unpack a source archive of unknown origin into a new, empty subdirectory. You can always move it up a level if you need to. Additionally, you can see what will happen by using the <span class="literal">tar</span> utility’s <span class="literal">t</span> option (instead of <span class="literal">x</span>), which lists the contents of the archive without unpacking it. The <span class="literal">unzip</span> utility supports the <span class="literal">-l</span> option to the same effect.</p>&#13;
<p class="indent">Source archives can take many shapes, each ending in a unique file extension: <em>.zip</em>, <em>.tar</em>, <em>.tar.gz</em> (or <em>.tgz</em>), <em>.tar.bz2</em>, <em>.tar.xz</em>, <em>tar.Z</em>, and so on. The files contained in these source archives are the source code and build files used to build the software. The most common of these formats are <em>.zip</em>, <em>.tar.gz</em> (or <em>.tgz</em>), and <em>.tar.bz2</em>. Newer formats that are gaining in popularity include <em>.xz</em> (for which the latest Autotools even have native support) and <em>.zstd</em>.</p>&#13;
<p class="indent">ZIP files use compression techniques developed decades ago by Phil Katz on Microsoft DOS systems. ZIP was a proprietary multifile compressed archive format that was eventually released into the public domain. Since then, versions have been written for Microsoft Windows and Linux as well as other Unix-like operating systems. In later versions of Windows, a user can unpack a <em>.zip</em> file merely by right-clicking it in Windows Explorer and selecting an <strong>Extract</strong> menu option. The same is true of the Nautilus (Nemo on Mint’s Cinnamon desktop) file browser on Linux Gnome desktops.</p>&#13;
<p class="indent">ZIP files can be unpacked at the Linux command line using the more or less ubiquitous <span class="literal">unzip</span> program,<sup><a id="ch01fn_2" href="footnote.xhtml#ch01fn2">2</a></sup> like so:</p>&#13;
<pre>$ <span class="codestrong1">unzip some-package.zip</span></pre>&#13;
<p class="indent">ZIP files are most often intended by project maintainers to be used on Microsoft Windows systems. A much more common format used on Linux platforms is the compressed <em>.tar</em> file. The name <em>tar</em> comes from <em>tape archive</em>. The <span class="literal">tar</span> utility was originally designed to stream the contents of online storage media, such as hard disk drives, to more archival storage formats, such as magnetic tape. Because it’s not a random-access format, magnetic tape doesn’t have a hierarchical filesystem. Rather, data is written to tape in one long string of bits, with these archive files appended end to end. To find <span epub:type="pagebreak" id="page_4"/>a particular file on tape, you have to read from the beginning of the tape through to the file you’re interested in. Hence, it’s better to store fewer files on tape to reduce search time.</p>&#13;
<p class="indent">The <span class="literal">tar</span> utility was designed to convert a set of files in a hierarchical filesystem into just such a long string of bits—an archive. The <span class="literal">tar</span> utility was specifically <em>not</em> designed to compress this data in a manner that would reduce the amount of space it takes up, as there are other utilities to do that sort of thing—remember, a founding principle of Unix is that of a single responsibility per tool. In fact, a <em>.tar</em> file is usually slightly larger than the sum of the sizes of the files it contains because of the overhead of storing the hierarchy, names, and attributes of the archived files.</p>&#13;
<p class="indent">Occasionally, you’ll find a source archive that ends only in a <em>.tar</em> extension. This implies that the file is an uncompressed <em>.tar</em> archive. More often, however, you’ll see extensions such as <em>.tar.gz</em>, <em>.tgz</em>, and <em>.tar.bz2</em>. These are compressed <em>.tar</em> archives. An archive is created from the contents of a directory tree using the <span class="literal">tar</span> utility, and then the archive is compressed using the <span class="literal">gzip</span> or <span class="literal">bzip2</span> utility. A file with an extension of <em>.tar.gz</em> or <em>.tgz</em> is a <em>.tar</em> archive that has been compressed with the <span class="literal">gzip</span> utility. Technically, you can extract the contents of a <em>.tar.gz</em> file by using a pipeline of commands to first uncompress the <em>.gz</em> file with <span class="literal">gunzip</span> and then unpack the remaining <em>.tar</em> file with <span class="literal">tar</span>, in the following manner:</p>&#13;
<pre>$ <span class="codestrong1">gunzip -c autoconf-2.69.tar.gz | tar xf -</span></pre>&#13;
<p class="indent">However, the <span class="literal">tar</span> utility has evolved since it was used for creating tape data streams. Nowadays, it’s used as a general-purpose archive file management tool. It understands, based on file extensions and sometimes the initial bytes of an archive, how to execute the correct tools to uncompress a compressed <em>.tar</em> archive before unpacking the files. For example, the following command recognizes <em>autoconf-2.69.tar.gz</em> as a <em>.tar</em> archive that was subsequently compressed with the <em>gzip</em> utility:</p>&#13;
<pre>$ <span class="codestrong1">tar xf autoconf-2.69.tar.gz</span></pre>&#13;
<p class="indent">This command first executes the <span class="literal">gunzip</span> program (or the <span class="literal">gzip</span> program with the <span class="literal">-d</span> option) to uncompress the archive, and then it uses internal algorithms to convert the archive into its original multifile directory structure, complete with original timestamps and file attributes.</p>&#13;
<h3 class="h3" id="ch01sec3">Building the Software</h3>&#13;
<p class="noindent">Once you’ve unpacked the source archive, the next step usually involves examining the contents of the unpacked directory tree in an effort to determine how the software should be built and installed. A few patterns have become pervasive in the open source world, and GNU and the Autotools try to promote the use of these patterns as the default behavior of an Autotools-based project.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>First, look for a file named <em>INSTALL</em> in the root directory of the unpacked archive. This file usually contains step-by-step instructions for how to build and install the software, or it tells you how to find those instructions—perhaps via a URL reference to a project web page.</p>&#13;
<p class="indent">The <em>INSTALL</em> file for GNU packages such as Autoconf is pretty verbose. The GNU project tends to try to set an example for the rest of the open source world. Nevertheless, it does carefully outline the steps required to build the Autoconf package. I’d recommend reading a GNU project <em>INSTALL</em> file completely at least once, because it contains details about how most GNU projects are built and installed. In fact, the one bundled with the Autoconf package is actually a generic one that GNU bundles with many of its packages—which in itself is a testament to the consistency of Autotools-generated build systems. Let’s dive in and see what it tells us about building Autoconf:</p>&#13;
<pre>$ <span class="codestrong1">tar xf autoconf-2.69.tar.gz</span>&#13;
$ <span class="codestrong1">cd autoconf-2.69</span>&#13;
$ <span class="codestrong1">more INSTALL</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">The instructions indicate that you should use the <span class="literal">cd</span> command to change to the directory containing the project’s source code and then type <span class="literal">./configure</span> to configure the package for your system. However, it should be clear that if you’re reading the <em>INSTALL</em> file, you’re probably already in the directory containing <span class="literal">configure</span>.</p>&#13;
<p class="indent">Running <span class="literal">configure</span> can take a while if the package is large and complex. For the Autoconf package, it takes only a couple of seconds and spews a single page of text to the screen in the process. Let’s take a closer look at what gets displayed during a successful Autoconf configuration process:</p>&#13;
<pre>$ <span class="codestrong1">./configure</span>&#13;
checking for a BSD-compatible install... /usr/bin/install -c&#13;
checking whether build environment is sane... yes&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure: creating ./config.status&#13;
config.status: creating tests/Makefile&#13;
<span class="codeitalic1">--snip--</span>&#13;
config.status: creating bin/Makefile&#13;
config.status: executing tests/atconfig commands&#13;
$</pre>&#13;
<p class="indent">There are basically two parts to <span class="literal">configure</span>’s output. The first part contains lines that start with <span class="literal">checking</span> (though there are a few in the middle that start with <span class="literal">configure:</span>). These lines indicate the status of the features that <span class="literal">configure</span> was programmed to look for. If a feature is not found, the trailing text will be <span class="literal">no</span>. On the other hand, if the feature is found, the trailing text will sometimes be <span class="literal">yes</span> but will often be the filesystem location of the tool or feature that was discovered.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_6"/>It’s not uncommon for <span class="literal">configure</span> to fail due to missing tools or utilities, especially if this is a newly installed system or if you haven’t downloaded and built a lot of software on this system. A new user will often start posting questions to online forums at this point—or just give up.</p>&#13;
<p class="indent">It’s important to understand the contents of this section because it can help you figure out how to solve problems. Addressing a failure is often as simple as installing a compiler using your system’s package manager. For the Autoconf package, not much is required that isn’t installed by default on most Linux systems. There are a few exceptions, however. For example, here’s the output of <span class="literal">configure</span> on a system that doesn’t have M4 installed:</p>&#13;
<pre>$ <span class="codestrong1">./configure</span>&#13;
checking for a BSD-compatible install... /usr/bin/install -c&#13;
checking whether build environment is sane... yes&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for GNU M4 that supports accurate traces... configure: error: no&#13;
    acceptable m4 could be found in $PATH.&#13;
GNU M4 1.4.6 or later is required; 1.4.16 or newer is recommended.&#13;
GNU M4 1.4.15 uses a buggy replacement strstr on some systems.&#13;
Glibc 2.9 - 2.12 and GNU M4 1.4.11 - 1.4.15 have another strstr bug.&#13;
$</pre>&#13;
<p class="indent">Here, you’ll notice the last few lines show an error. The Autoconf package is a GNU software tool, and, true to form, it provides a lot of information to help you figure out what’s wrong. You need to install an M4 macro processor, and we’ll do that with our package manager. My system is a Linux Mint system, based on Ubuntu, so I’ll use the <span class="literal">apt</span> utility. If you’re using a Red Hat–based system, you may use <span class="literal">yum</span> to accomplish the same thing or just use the graphical user interface (GUI) for your system package manager from the GUI desktop. The key here is that we’re installing the m4 package:</p>&#13;
<pre>$ <span class="codestrong1">sudo apt install m4</span></pre>&#13;
<p class="indent">Now <span class="literal">configure</span> can complete successfully:</p>&#13;
<pre>   $ <span class="codestrong1">./configure</span>&#13;
   checking for a BSD-compatible install... /usr/bin/install -c&#13;
   checking whether build environment is sane... yes&#13;
   <span class="codeitalic1">--snip--</span>&#13;
<span class="ent">➊</span> configure: creating ./config.status&#13;
   config.status: creating tests/Makefile&#13;
   config.status: creating tests/atlocal&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   config.status: creating bin/Makefile&#13;
   config.status: executing tests/atconfig commands&#13;
   $</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_7"/>The second section is a set of lines beginning with <span class="literal">config.status:</span>. This section starts with the line <span class="literal">configure: creating ./config.status</span>, at <span class="ent">➊</span>. The last thing <span class="literal">configure</span> does is create another script called <em>config.status</em> and then execute this script. The lines that start with <span class="literal">config.status:</span> are actually displayed by <em>config.status</em>. The primary task of <em>config.status</em> is to generate the build system based on the findings of <span class="literal">configure</span>. The lines output by this script merely tell you the names of the files being generated.</p>&#13;
<p class="indent">You can also run <span class="literal">configure</span> from a different directory, if you wish, by using a relative path to the <span class="literal">configure</span> command. This is useful if, for example, the project source code comes to you on a CD or via a read-only NFS mount. You could, at this point, create a build directory in your home directory and, using a relative or absolute path, execute <span class="literal">configure</span> from the read-only source directory. The <span class="literal">configure</span> script will create the entire build tree for the project in the current directory, including makefiles and any other files needed to build the project with <span class="literal">make</span>.</p>&#13;
<p class="indent">Once <span class="literal">configure</span> has completed, it’s possible to run <span class="literal">make</span>. Before this point, there are no files in the directory tree named <em>Makefile</em>. Running <span class="literal">make</span> after <span class="literal">configure</span> yields the following:</p>&#13;
<pre>$ <span class="codestrong1">make</span>&#13;
make  all-recursive&#13;
make[1]: Entering directory '/.../autotools/autoconf-2.69'&#13;
Making all in bin&#13;
make[2]: Entering directory '/.../autotools/autoconf-2.69/bin'&#13;
<span class="codeitalic1">--snip--</span>&#13;
make[2]: Leaving directory '/.../autotools/autoconf-2.69/man'&#13;
make[1]: Leaving directory '/.../autotools/autoconf-2.69'&#13;
$</pre>&#13;
<p class="indent">The primary task of <span class="literal">configure</span> is to ensure that <span class="literal">make</span> will succeed, so it’s not likely that <span class="literal">make</span> will fail. If it does, the problem will probably be very specific to your system, so I can’t provide any guidelines here except to suggest a careful reading of the <span class="literal">make</span> output in order to determine what caused the failure. If you can’t discover the problem by reading the output, you can check the Autoconf mailing list archives, ask on the mailing list directly, and finally post a bug report to the Autoconf project website.</p>&#13;
<h3 class="h3" id="ch01sec4">Testing the Build</h3>&#13;
<p class="noindent">Once we’ve built the software using <span class="literal">make</span>, it would be nice to exercise any tests the project maintainers might have added to the build system to provide some level of assurance that the software will run correctly on our system.</p>&#13;
<p class="indent">When we built the software, we ran <span class="literal">make</span> without any command line arguments. This caused <span class="literal">make</span> to assume we wanted to build the <em>default target</em>, which by convention is the <span class="literal">all</span> target. Therefore, running <span class="literal">make all</span> is the same as running <span class="literal">make</span> without any arguments. However, Autotools build systems have many targets that can be directly specified on the <span class="literal">make</span> command line. The one we’re interested in at this point is the <span class="literal">check</span> target.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>Running <span class="literal">make check</span> within the source directory will build and execute any test programs that were included by the project maintainers (this takes several minutes to complete for Autoconf):</p>&#13;
<pre>$ <span class="codestrong1">make check</span>&#13;
if test -d ./.git; then \&#13;
  cd . &amp;&amp; \&#13;
  git submodule --quiet foreach test '$(git rev-parse $sha1)' \&#13;
     = '$(git merge-base origin $sha1)' \&#13;
    || { echo 'maint.mk: found non-public submodule commit' &gt;&amp;2; \&#13;
   exit 1; }; \&#13;
else \&#13;
  : ; \&#13;
fi&#13;
make  check-recursive&#13;
make[1]: Entering directory '/home/jcalcote/Downloads/autotools/autoconf-2.69'&#13;
Making check in bin&#13;
<span class="codeitalic1">--snip--</span>&#13;
/bin/bash ./testsuite&#13;
## ----------------------------- ##&#13;
## GNU Autoconf 2.69 test suite. ##&#13;
## ----------------------------- ##&#13;
Executables (autoheader, autoupdate...).&#13;
  1: Syntax of the shell scripts                     skipped (tools.at:48)&#13;
  2: Syntax of the Perl scripts                      ok&#13;
<span class="codeitalic1">--snip--</span>&#13;
501: Libtool                                         FAILED (foreign.at:61)&#13;
502: shtool                                          ok&#13;
Autoscan.&#13;
503: autoscan                                        FAILED (autoscan.at:44)&#13;
## ------------- ##&#13;
## Test results. ##&#13;
## ------------- ##&#13;
ERROR: 460 tests were run,&#13;
6 failed (4 expected failures).&#13;
43 tests were skipped.&#13;
## -------------------------- ##&#13;
## testsuite.log was created. ##&#13;
## -------------------------- ##&#13;
Please send `tests/testsuite.log' and all information you think might help:&#13;
   To: &lt;bug-autoconf@gnu.org&gt;&#13;
   Subject: [GNU Autoconf 2.69] testsuite: 501 503 failed&#13;
You may investigate any problem if you feel able to do so, in which&#13;
case the test suite provides a good starting point.    Its output may&#13;
be found below `tests/testsuite.dir'.&#13;
<span class="codeitalic1">--snip--</span>&#13;
make: *** [check] Error 2&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Your output may differ slightly in minor ways from mine. Different Linux distributions and tool versions display differently, so don’t be too concerned about minor differences. The number of tests skipped or failed may also differ from system to system due to differences in the tools installed.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>As you can see, the Autoconf package provides 503 tests; 460 of those were run and 43 were purposely skipped. Of the 460 tests that were executed, six failed, but four of those were expected failures, so we have only two problems: test 501 and test 503.</p>&#13;
<p class="indent">With only two failures out of 460, I’d personally call this a whopping success, but if you would like to dig a little deeper to see what’s causing these problems, there are two approaches you can take. The first is to go to the Autoconf mailing list archives and either search for a similar question with answers or ask the list directly; notice the request in the preceding output to send the <em>tests/testsuite.log</em> file to <em><a href="mailto:bug-autoconf@gnu.org">bug-autoconf@gnu.org</a></em>.</p>&#13;
<p class="indent">The other option requires a bit more programming skill. These tests are run by Autoconf’s <em>autotest</em> framework, which automatically creates a directory for each failed test under <em>tests/testsuite.dir</em>. Each directory found under <em>testsuite.dir</em> is named after the number of the failed test. If you look there, you’ll see six directories, including directories for the four expected failures. Each of these numbered directories contains a <span class="literal">run</span> script that will re-execute the failed test, displaying output to <span class="literal">stdout</span> rather than to a log file. This allows you to experiment with your system (perhaps by installing a different version of Libtool for test 501, for example) and then try running the test again.</p>&#13;
<p class="indent">There is also the possibility, however slight, that the project maintainers are aware of these test failures. In this case, they would likely respond to your email with a comment to this effect (or a quick search of the archives may also turn up the same answer), at which point you can simply ignore the failed tests.</p>&#13;
<h3 class="h3" id="ch01sec5">Installing the Built Software</h3>&#13;
<p class="noindent">Running <span class="literal">make</span> usually leaves built software products—executables, libraries, and data files—scattered throughout the build directory tree. Take heart, you’re almost there. The final step is installing the built software onto your system so you can use it. Thankfully, most build systems, including those managed by the Autotools, provide a mechanism for installing built software.</p>&#13;
<p class="indent">A complex build system is only useful to non-experts if it assumes a lot of basic defaults; otherwise, the poor user would be required to specify dozens of command line options for even the simplest build. The location of software installation is one such assumption; by default, the build system assumes you want to install built software into the <em>/usr/local</em> directory tree.</p>&#13;
<p class="indent">The <em>/usr/local</em> directory tree mirrors the <em>/usr</em> directory tree; it’s the standard location for software that is built locally. The <em>/usr</em> directory tree, on the other hand, is where Linux distribution packages get installed. For instance, if you installed the Autoconf package using the command <span class="literal">sudo apt-get install autoconf</span> (or <span class="literal">sudo yum install autoconf</span>), the package binaries would be installed into the <em>/usr/bin</em> directory. When you install your hand-built Autoconf binaries, they’ll go into <em>/usr/local/bin</em>, by default.</p>&#13;
<p class="indent">It’s most often the case that <em>/usr/local/bin</em> is positioned in your <span class="literal">PATH</span> environment variable before <em>/usr/bin</em>. This allows your locally built and installed programs to override the ones installed by your distribution’s package manager.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>If you wish to override this default behavior and install your software into a different location, you can use the <span class="literal">--prefix</span> option on <span class="literal">configure</span>’s command line,<sup><a id="ch01fn_3" href="footnote.xhtml#ch01fn3">3</a></sup> as shown here:</p>&#13;
<pre>$ <span class="codestrong1">./configure --prefix=$HOME</span></pre>&#13;
<p class="indent">This will cause <span class="literal">configure</span> to generate the build scripts such that executable binaries will be installed into your <span class="literal">$HOME</span><em>/bin</em> directory.<sup><a id="ch01fn_4" href="footnote.xhtml#ch01fn4">4</a></sup> If you don’t have root access on your system, this is a good compromise that will allow you to install built software without asking your system administrator for extra rights.</p>&#13;
<p class="indent">Another reason for choosing a different <span class="literal">--prefix</span> location is to allow yourself to install the software into an isolated location. You can then examine the location after installation to see exactly what got installed and where it went, relative to <span class="literal">--prefix</span>.</p>&#13;
<p class="indent">Let’s first install into a private installation location so we can see what the Autoconf project installs onto our system:</p>&#13;
<p class="imagel"><img src="../images/pg010-01.jpg" alt="Image"/></p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_11"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As with the earlier build process, the number of files and directories on your system may differ slightly from mine, based on the difference in tool availability between our systems. If you have additional documentation tools installed, for example, you may see more directories than I do, as Autoconf will build more documentation if the tools are available.</em></p>&#13;
</div>&#13;
<p class="indent">Note that I specified the installation location on <span class="literal">configure</span>’s command line using a full path—the <span class="literal">PWD</span> environment variable contains the absolute path of the current directory in the shell. It’s important to always use a full path in <span class="literal">--prefix</span>. In many cases, using a relative path will cause installation failures because the <span class="literal">--prefix</span> argument is referenced from different directories during the installation process.<sup><a id="ch01fn_5" href="footnote.xhtml#ch01fn5">5</a></sup></p>&#13;
<p class="indent">I used the <span class="literal">tree</span> command on the <em>private-install</em> directory in order to get a visual picture of what Autoconf installs.<sup><a id="ch01fn_6" href="footnote.xhtml#ch01fn6">6</a></sup> There were 61 files installed into 11 directories within <em>private-install</em>.</p>&#13;
<p class="indent">Now, let’s install Autoconf into the default location in <em>/usr/local/bin</em>:</p>&#13;
<pre>$ <span class="codestrong1">./configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">It’s important to note the use of <span class="literal">sudo</span> on this command line to run <span class="literal">make install</span> with root privileges. When you install software outside of your home directory, you’ll need higher privileges. If you set the <span class="literal">--prefix</span> directory to somewhere within your home directory, then you can omit the use of <span class="literal">sudo</span> in the command.</p>&#13;
<h3 class="h3" id="ch01sec6">Summary</h3>&#13;
<p class="noindent">At this point, you should understand what a source archive is and how to download, unpack, build, test, and install it. I hope I’ve also given you the impetus to dig further and discover more about open source build systems. Those generated by the Autotools follow common patterns so pedantically that they’re reasonably predictable. For hints on the sorts of things you can do, try running <span class="literal">./configure --help</span>.</p>&#13;
<p class="indent">There are other build systems out there. Most of them follow a reasonable set of patterns, but once in a while you’ll run into one that’s significantly different from all the rest. All open source build systems tend to follow some very fundamental, high-level concepts—the idea of a configuration <span epub:type="pagebreak" id="page_12"/>process, followed by a build step, is one such principle. However, the nature of the configuration process as well as the command used to build the software might not align very closely with what we’ve discussed here. One of the benefits of the Autotools is the consistent nature of the build systems they generate.</p>&#13;
<p class="indent">If you want to understand how all this magic works, keep reading.</p>&#13;
</body></html>