- en: '![](../images/pg70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-12.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOGICAL
    AND RELATIONAL OPERATORS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you know how to compile binary operators, you’re going to add a whole
    mess of them (plus one more unary operator). In this chapter, you’ll add three
    logical operators: NOT (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>),
    AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>), and OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>).
    You’ll also add the relational operators: <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and so on. Each of these operators tests some condition, resulting in a value
    of 1 if that condition is true and 0 if it’s false.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operators differ from the binary operators we’ve seen so far because they *short-circuit*:
    if you know the result after the first operand, you don’t evaluate the second
    operand. To support short-circuiting logic, we’ll add new instructions to TACKY
    that let us skip over blocks of code. We’ll also introduce several new instructions
    in the assembly generation pass, including conditional assembly instructions that
    let us take specific actions only if some condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a brief discussion of short-circuiting operators before moving
    on to the compiler passes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Short-Circuiting Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C standard guarantees that <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> short-circuit when
    you don’t need the second operand. For example, consider the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1 - 1) &&</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo()</samp>.
    Because the first operand’s value is 0, the whole expression will evaluate to
    0 regardless of what <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    returns, so we won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    at all. Likewise, if the first operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    is nonzero, we don’t evaluate the second operand.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t just a performance optimization; the second operand might not change
    the result of the expression, but evaluating it can have visible side effects.
    For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> function
    might perform I/O or update global variables. If your compiler doesn’t implement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    as short- circuiting operators, some compiled programs will behave incorrectly.
    (The standard defines this behavior in section 6.5.13, paragraph 4, for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operator and in section 6.5.14,
    paragraph 4, for the <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve clarified how these operators work, you’re ready to continue
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll add nine new tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!</samp> | An exclamation point,
    the logical NOT operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&&</samp> | Two ampersands,
    the logical AND operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;&#124;</samp> | Two vertical
    bars, the logical OR operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp> | Two equal signs,
    the “equal to” operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!=</samp> | An exclamation point
    followed by an equal sign, the “not equal to” operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><</samp> | The “less than” operator
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">></samp> | The “greater than”
    operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><=</samp> | The “less than or
    equal to” operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">>=</samp> | The “greater than
    or equal to” operator |'
  prefs: []
  type: TYPE_TB
- en: Your lexer should handle these the same way as the other operators you’ve added
    so far. Remember that the lexer should always choose the longest possible match
    for the next token. For example, if your input is <samp class="SANS_TheSansMonoCd_W5Regular_11"><=something</samp>,
    the next token the lexer emits should be <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll add the new operations to the AST definition. [Listing 4-1](chapter4.xhtml#list4-1)
    shows the updated definition, with these additions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The abstract syntax
    tree with comparison and logical operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to make the corresponding changes to the grammar, as shown in [Listing
    4-2](chapter4.xhtml#list4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The grammar with
    comparison and logical operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listings 4-1](chapter4.xhtml#list4-1) and [4-2](chapter4.xhtml#list4-2),
    we’ve added some new operators, but we haven’t made any other changes. Now we’re
    ready to update the parsing code. First, update <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> operator.
    It should parse <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> the same
    way it parses the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operators.
  prefs: []
  type: TYPE_NORMAL
- en: Next, update <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    to handle the new binary operators. In [Chapter 3](chapter3.xhtml), we associated
    every binary operator with a numeric precedence value. Now we’ll give the new
    operators precedence values. These operators have lower precedence than the ones
    from [Chapter 3](chapter3.xhtml), and they’re all left-associative. Among the
    new operators, <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    have the highest precedence, followed by the equality operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    operator has lower precedence than the equality operators, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    has the lowest precedence of all. The precedence values I’ve chosen are listed
    in [Table 4-1](chapter4.xhtml#tab4-1), with new operators bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Old and New Binary Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11"><</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11"><=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">></samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">>=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">==</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">!=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">&&</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">10</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">&#124;&#124;</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: These values are spaced far enough apart to leave room for the optional bitwise
    operators from [Chapter 3](chapter3.xhtml). There’s also room at the bottom of
    the scale for the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> operators we’ll add in the next
    two chapters. You don’t need to use the exact values in this table as long as
    all operators have the correct precedence relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to extend the code that converts tokens into <samp class="SANS_TheSansMonoCd_W5Regular_11">unary
    _operator</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp>
    AST nodes. For example, the function that converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    token into an <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp> node should
    also convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> token into
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> node. (The pseudocode
    in the last two chapters called separate functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>, to handle
    these conversions.)
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated your parser’s table of precedence values, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse
    _binop</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>,
    you’re done! The precedence climbing algorithm we implemented in the last chapter
    can handle the new operators without further changes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the lexer and parser are working properly, we can venture into less
    familiar territory: handling the new operators in TACKY. You can convert relational
    operators to TACKY in the same way as the binary operators you’ve already implemented.
    For example, given the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e1
    < e2</samp>, the resulting TACKY looks something like [Listing 4-3](chapter4.xhtml#list4-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Implementing the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11"><</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators this way,
    though, because they short-circuit. The code in [Listing 4-3](chapter4.xhtml#list4-3)
    always evaluates both <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>, but we need to generate
    code that sometimes skips <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>.
    To support short-circuiting operators, we’ll add an *unconditional jump* instruction,
    which lets us jump to a different point in the program. We’ll also add two *conditional
    jump* instructions, which jump only when a particular condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Jumps, Copies,
    and Comparisons to the TACKY IR</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-4](chapter4.xhtml#list4-4) shows the latest TACKY IR, including
    the new jump instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Adding comparisons,
    jumps, and labels to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction works
    just like <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> in C: it makes
    the program jump to the point labeled with some identifier, <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction associates
    an identifier with a location in the program. The snippet of TACKY in [Listing
    4-5](chapter4.xhtml#list4-5) shows how <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions work
    together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: A snippet of TACKY
    with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Jump</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program stores <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, then executes the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction, which jumps
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction.
    Next, it executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, which returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>.
    The second <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction
    ❶ won’t execute at all, because we jumped over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first conditional jump in the TACKY IR, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    jumps to the instruction indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>
    if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is 0\. If <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is anything
    other than 0, we don’t jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>;
    instead, we execute the next instruction as usual. The second conditional jump,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, does the opposite:
    we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> only if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> isn’t 0\. We don’t
    really need both of these instructions, since any behavior you can express with
    one can be expressed with the other plus a <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    instruction. But adding both lets us generate simpler TACKY for the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operations, which
    will ultimately translate into simpler, shorter assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: The other new instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    ultimately return 1 or 0, we use this instruction to copy 1 or 0 into the temporary
    variable that holds the result of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these five additional instructions, the latest TACKY IR includes the
    new relational and logical binary operators and the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Short-Circuiting
    Operators to TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use the new TACKY instructions to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators. The TACKY
    for the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e1 && e2</samp>
    should look like [Listing 4-6](chapter4.xhtml#list4-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Implementing the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">&&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>.
    If it’s 0, we short-circuit and set <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, without evaluating
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>. We accomplish this with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction;
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp> is 0, we jump straight
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>, then set
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    (I’ve written this out as <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(0, result)</samp>
    to make it more readable. I’ll take similar liberties with TACKY notation in later
    chapters.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp> isn’t 0,
    we still need to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>.
    We handle the case where <samp class="SANS_TheSansMonoCd_W5Regular_11">v2</samp>
    is 0 exactly like the case where <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp>
    is 0, by jumping to <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>. We reach
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, only if we didn’t take
    either conditional jump. That means both <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp> are nonzero, so we
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Then, we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> label to avoid
    overwriting <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave it to you to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operation to TACKY on your own. The resulting TACKY will look similar to [Listing
    4-6](chapter4.xhtml#list4-6), but it will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    instruction instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>.
    That leaves <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> and all the
    relational operations; you can convert them to TACKY in the same way as the unary
    and binary operations you added in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Labels</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Labels, like temporary variables, must be globally unique: an instruction like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump("foo")</samp> is useless if
    the label <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> shows up in
    multiple places. You can make sure they’re unique by incorporating a global counter
    into labels, like you did with variable names in [Chapter 2](chapter2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike temporary variables, labels will appear in the final assembly program,
    so they must be identifiers that the assembler considers syntactically valid.
    They should contain only letters, digits, periods, and underscores. Choose descriptive
    labels to make your assembly programs easier to read and debug. For example, you
    could use the string <samp class="SANS_TheSansMonoCd_W5Regular_11">and_false</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>
    in [Listing 4-6](chapter4.xhtml#list4-6), where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    is the current value of a global counter.
  prefs: []
  type: TYPE_NORMAL
- en: Although labels must not conflict with each other, it’s okay for them to conflict
    with temporary variable names. It’s also okay if the labels you generate here
    conflict with user-defined function names, even though both autogenerated labels
    and function names become labels in the final assembly program. We’ll mangle our
    autogenerated labels during code emission so they don’t conflict with user-defined
    identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Comparisons and Jumps in Assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting on the assembly generation pass, let’s talk through the new
    assembly instructions we’ll need. First, we’ll discuss the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction, which compares two values, and the *conditional set* instructions,
    which set a byte to 1 or 0 based on the result of a comparison. We’ll use these
    to implement relational operators like <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>.
    Next, we’ll talk about conditional and unconditional jump instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparisons and Status
    Flags</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The “condition” that all conditional instructions depend on is the state of
    the RFLAGS register. Unlike EAX, RSP, and the other registers we’ve seen so far,
    we usually can’t directly set RFLAGS. Instead, the CPU updates RFLAGS automatically
    every time it issues an instruction. As the name suggests, each bit in this register
    is a flag that reports some fact about the last instruction or the status of the
    CPU. Different instructions update different flags: the <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instructions update all the flags we’ll talk about in this section, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction doesn’t update
    any of them. We can ignore the effects of other instructions for now. Whenever
    I refer to the “last instruction” or “last result” while discussing RFLAGS, I
    mean the last instruction that affects the particular flag I’m talking about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we care about three of these flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero flag (ZF)**'
  prefs: []
  type: TYPE_NORMAL
- en: ZF is set to 1 if the result of the last instruction was 0\. It’s set to 0 if
    the result of the last instruction was nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sign flag (SF)**'
  prefs: []
  type: TYPE_NORMAL
- en: SF is set to 1 if the most significant bit of the last result was 1\. It’s set
    to 0 if the most significant bit of that result was 0\. Remember that in two’s
    complement, the most significant bit of a negative number is always 1, and the
    most significant bit of a positive number is always 0\. Therefore, the sign flag
    tells us whether the result of the last instruction was positive or negative.
    (If the last result should be interpreted as an unsigned integer, it can’t be
    negative, so the sign flag is meaningless.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflow flag (OF)**'
  prefs: []
  type: TYPE_NORMAL
- en: OF is set to 1 if the last instruction resulted in a signed integer overflow,
    and 0 otherwise. An *integer overflow* occurs when the result of a signed integer
    operation can’t be represented in the number of bits available. A positive result
    overflows when it’s larger than the maximum value the type can hold. Suppose we’re
    operating on 4-bit integers. The largest signed number we can represent is 7,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp> in binary. If we
    add one to it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    instruction, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>.
    If we interpret this as an unsigned integer, its value is 8, but its value is
    –8 if we interpret it as a two’s complement signed integer. The result of the
    computation should be positive, but since it overflowed, it appears negative.
    This computation sets the overflow flag to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also encounter integer overflow in the opposite situation: when the result
    should be negative, but it’s below the smallest possible value. For example, in
    ordinary math, –8 – 1 = –9\. But if we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instruction to subtract one from the 4-bit two’s complement representation of
    –8, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, we end
    up with <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>, or 7\. The
    overflow flag is set to 1 in this case too.'
  prefs: []
  type: TYPE_NORMAL
- en: An unsigned result can also be too large or small for its type to represent,
    but I won’t refer to this as integer overflow in this book. Instead, I say the
    result *wrapped around*, which is more consistent with the terminology for unsigned
    operations in the C standard and in most discussions of x64 assembly. I draw this
    distinction because unsigned wraparound follows different rules from signed integer
    overflow in the C standard, and the CPU detects it differently. You’ll learn how
    to handle unsigned wraparound in [Part II](part2.xhtml). Like SF, OF is meaningless
    if the result is unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 4-2](chapter4.xhtml#tab4-2) and [4-3](chapter4.xhtml#tab4-3) summarize
    the cases where each kind of integer overflow is possible. [Table 4-2](chapter4.xhtml#tab4-2)
    describes the results of addition.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Integer
    Overflow and Underflow from Addition</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a + b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">Overflow
    from positive to negative</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    | <samp class="SANS_Futura_Std_Book_11">Overflow from negative to positive</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[Table 4-3](chapter4.xhtml#tab4-3) describes the results of subtraction; it’s
    just [Table 4-2](chapter4.xhtml#tab4-2) with the columns swapped, since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(-
    b)</samp> are equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Integer
    Overflow and Underflow from Subtraction</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a - b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    | <samp class="SANS_Futura_Std_Book_11">Overflow from positive to negative</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">Overflow
    from negative to positive</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp>
    computes <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>, exactly like
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction, and
    has the same impact on RFLAGS, but it discards the result instead of storing it
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This is more convenient
    when you want to subtract two numbers only in order to compare them and don’t
    want to overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s figure out the values of ZF and SF after the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    b, a</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is 0, so ZF is 1 and SF is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is a positive number, so both SF and ZF are 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is a negative number, so SF is 1 and ZF is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By issuing a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction
    and then checking ZF and SF, you can handle every comparison we’re implementing
    in this chapter. But wait! That’s not quite true, because <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow, which would flip SF. Let’s consider how that impacts
    each case:'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> can’t overflow because it’s 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is positive and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is negative.
    The correct result in this case is positive, but if it overflows, the result will
    be negative. In that case, SF will be 1, and OF will be too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is negative and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is positive.
    In this case, the correct result is negative, but the actual result will be positive.
    That means SF will be 0, but OF will be 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 4-4](chapter4.xhtml#tab4-4) gives the values of these flags in every
    case we’ve considered.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Impact
    of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    on Status Flags</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">ZF</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">OF</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">SF</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    no overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    no overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: You can tell whether <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is larger by checking
    whether SF and OF are the same. If they are, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">≥</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    Either both are 0, because we got a positive (or 0) result with no overflow, or
    both are 1, because we got a large positive result that overflowed until it became
    negative. If SF and OF are different, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp>. Either we got a negative result with no overflow, or we got a negative
    result that overflowed and became positive.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to set ZF, OF, and SF, let’s take a look at a few
    instructions that depend on those flags.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Set Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To implement a relational operator, we first set some flags using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, then set the result
    of the expression based on those flags. We perform that second step with a *conditional
    set* instruction. Each conditional set instruction takes a single register or
    memory address as an operand, which it sets to 0 or 1 based on the state of RFLAGS.
    The conditional set instructions are all identical, except that they test for
    different conditions. [Table 4-5](chapter4.xhtml#tab4-5) lists the conditional
    set instructions we need in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Conditional
    Set Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Flags</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sete</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    set</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setne</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a !=</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    not set</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setg</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp> | <samp
    class="SANS_Futura_Std_Book_11">ZF not set and SF == OF</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setge</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">≥</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">SF
    == OF</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> | <samp
    class="SANS_Futura_Std_Book_11">SF != OF</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setle</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">≤</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    set or SF != OF</samp> |'
  prefs: []
  type: TYPE_TB
- en: Unlike the other instructions we’ve seen so far, conditional set instructions
    take only 1-byte operands. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">sete
    %eax</samp> is not a valid instruction, because EAX is a 4-byte register. The
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">sete %al</samp>, however,
    is valid; this sets the AL register, the least significant byte of EAX. To conditionally
    set the whole EAX register to 0 or 1, you need to zero out EAX before you set
    AL, because the conditional set instruction won’t clear its upper bytes. For example,
    if EAX is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and you run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: then the new value in EAX is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: which is, of course, not 0\. The <samp class="SANS_TheSansMonoCd_W5Regular_11">sete</samp>
    instruction zeroed out the last byte of EAX, but not the rest of it.
  prefs: []
  type: TYPE_NORMAL
- en: If its operand is a memory address, a conditional set instruction will update
    the single byte at that address. Note that a memory address can be a 1-byte, 4-byte,
    or 8-byte operand, depending on context. In <samp class="SANS_TheSansMonoCd_W5Regular_11">sete
    -4(%rbp)</samp>, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    indicates a single byte of memory at RBP – 4; in <samp class="SANS_TheSansMonoCd_W5Regular_11">addl
    $1, -4(%rbp)</samp>, it indicates the 4 bytes of memory starting at RBP – 4.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Jump Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> assembly instruction
    takes a label as an argument and performs an unconditional jump to that label.
    Jump assembly instructions manipulate another special-purpose register, RIP, which
    always holds the address of the next instruction to execute (IP stands for *instruction
    pointer*). To execute a sequence of instructions, the CPU carries out the *fetch-execute
    cycle*:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch an instruction from the memory address in RIP and store it in a special-purpose
    *instruction register*. (This register doesn’t have a name because you can’t refer
    to it in assembly.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment RIP to point to the next instruction. Instructions in x64 aren’t all
    the same length, so the CPU has to check the length of the instruction it just
    fetched and increment RIP by that many bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the instruction in the instruction register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, following these steps executes instructions in the order they appear
    in memory. But <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> puts a
    new value in RIP, which changes what instruction the CPU executes next. The assembler
    and linker convert the label in a jump instruction into a *relative offset* that
    tells you how much to increment or decrement RIP. Consider the snippet of assembly
    in [Listing 4-7](chapter4.xhtml#list4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: A snippet of assembly
    code with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">jmp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The machine instruction for <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $0, %eax</samp> is 5 bytes long. To jump over it and execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    needs to increment RIP by an extra 5 bytes. The assembler and linker therefore
    convert <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp foo</samp> into the
    machine instruction for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>.
    Then, when the CPU executes this instruction, it:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetches the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>
    and stores it in the instruction register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increments RIP to point to the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $0, %eax</samp>.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executes <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>. This adds
    5 bytes to RIP so that it points to <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetches the instruction RIP points to, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>,
    and continues the fetch- execute cycle from there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that labels aren’t instructions: the CPU doesn’t execute them, and they
    don’t appear in the text section of the final executable (the section that contains
    machine instructions).'
  prefs: []
  type: TYPE_NORMAL
- en: A *conditional jump* takes a label as an argument but jumps to that label only
    if the condition holds. Conditional jumps look a lot like conditional set instructions;
    they depend on the same conditions, using the same flags in RFLAGS. For example,
    the assembly in [Listing 4-8](chapter4.xhtml#list4-8) returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    if the EAX and EDX registers are equal, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: A snippet of assembly
    code with a conditional jump</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the values in EAX and EDX are equal, <samp class="SANS_TheSansMonoCd_W5Regular_11">cmpl</samp>
    sets ZF to 1, so <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> jumps
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">return3</samp>. Then, the two
    instructions following <samp class="SANS_TheSansMonoCd_W5Regular_11">return3</samp>
    execute, so the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    If EAX and EDX aren’t equal, <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp>
    doesn’t perform the jump, so the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> jumps only
    if ZF is 0\. There are also jump instructions that check other conditions, but
    we don’t need them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand the new assembly instructions you’ll need, let’s extend
    the assembly AST and update each assembly generation pass. [Listing 4-9](chapter4.xhtml#list4-9)
    defines the latest assembly AST, with additions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: The assembly AST
    with comparisons and conditional instructions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since all conditional jump instructions have the same form, we represent them
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp> instruction
    and distinguish between them using different condition codes. We do the same with
    conditional set instructions. We also treat labels like instructions at this stage,
    even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> isn’t really
    an instruction since labels aren’t executed by the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions,
    we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp> assembly
    instruction. We convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We implement <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    the same way, but with <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> as the condition
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we implement all the relational operators using conditional set instructions.
    For example, the TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For all the other relational operators, replace <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    with the appropriate condition code. Remember to zero out the destination before
    the conditional set instruction, since it sets only the lowest byte. It’s safe
    to perform a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> right after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> doesn’t change RFLAGS.
    One potential wrinkle is that <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>
    needs a 1-byte operand, but <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is 4 bytes; luckily, we can account for this in the code emission pass. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a location in memory, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> sets the first byte at that
    location, which is the behavior we want. (Because x64 processors are *little-endian*,
    the first byte is the least significant, so setting that byte to 1 sets the whole
    32-bit value to 1.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is a register, we’ll use the corresponding 1-byte register name when we emit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> during code emission. Registers
    in the assembly AST are size agnostic, so for now we represent <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    the same way whether we’re using it as a 4-byte or 1-byte operand.
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">!x</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, we also implement the
    unary <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> operator with a conditional
    set instruction. We convert the TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The remaining TACKY instructions—<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>—are
    easy. A TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> becomes
    an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>.
    [Tables 4-6](chapter4.xhtml#tab4-6) and [4-7](chapter4.xhtml#tab4-7) summarize
    how to convert each new TACKY construct to assembly. Note that these tables include
    only new constructs, unlike the equivalent tables in [Chapters 2](chapter2.xhtml)
    and [3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-6](chapter4.xhtml#tab4-6) shows how to convert the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and conditional and
    unconditional jump instructions to assembly, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    instructions with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions
    with the new relational operators.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), src) Mov(Imm(0), dst)'
  prefs: []
  type: TYPE_NORMAL
- en: SetCC(E, dst)</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(relational_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(src2,
    src1) Mov(Imm(0), dst)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC(relational_operator, dst)</samp>
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump(target)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jmp(target)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), condition) JmpCC(E,
    target)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), condition) JmpCC(NE,
    target)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(identifier)</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(identifier)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[Table 4-7](chapter4.xhtml#tab4-7) gives the corresponding condition code for
    each relational operator in TACKY.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-7:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LE</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">G</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GE</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'From now on, the tables describing each chapter’s conversion from TACKY to
    assembly will show only what’s changed from the chapter before. [Appendix B](appendix-B.xhtml)
    includes two sets of tables giving the complete conversion from TACKY to assembly:
    one shows the conversion at the end of [Part I](part1.xhtml), and the other shows
    the conversion at the end of [Part II](part2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Update this pass to replace any pseudoregisters used by the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> instructions with
    stack addresses, just like you did for all the other instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the
    cmp Instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, much
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, can’t use memory
    addresses for both operands. We rewrite it in the usual way, turning
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction can’t be a constant. This sort of makes sense if you remember that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> follows the same form
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>; the second operand
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instruction can’t
    be a constant either, since that operand holds the result. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    doesn’t produce a result, the same rules apply. We rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Following the convention from the previous chapter, we use R10 to fix a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction’s first operand
    and R11 to fix its second operand.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve generated a valid assembly program, and we’re ready to emit it. Code emission
    is slightly more complicated in this chapter, for two reasons. First, we’re dealing
    with both 1-byte and 4-byte registers. We’ll print out a different name for a
    register depending on whether it appears in a conditional set instruction, which
    takes 1-byte operands, or any of the other instructions we’ve encountered so far,
    which take 4-byte operands.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is emitting labels. Some assembly labels are autogenerated
    by the compiler, while others—function names—are user-defined identifiers. Right
    now, the only function name is <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    but eventually we’ll compile programs with arbitrary function names. Because labels
    must be unique, autogenerated labels must not conflict with any function names
    that could appear in a program.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll avoid conflicts by adding a special *local label* prefix to our autogenerated
    labels. The local label prefix is <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    on Linux and <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> on macOS.
    On Linux, these labels won’t conflict with user-defined identifiers because identifiers
    in C can’t contain periods. On macOS, they won’t conflict because we prefix all
    user-defined names with underscores (so that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">_main</samp>, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Local labels are handy for another reason: they won’t confuse GDB or LLDB when
    you need to debug this code. The assembler puts most labels in the object file’s
    symbol table, but it leaves out any that start with the local label prefix. If
    your autogenerated labels were in the symbol table, GDB and LLDB would mistake
    them for function names, which would cause problems when you tried to disassemble
    a function or view a stack trace.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from those two issues, code emission is pretty straightforward. [Tables
    4-8](chapter4.xhtml#tab4-8) through [4-10](chapter4.xhtml#tab4-10) summarize the
    changes to this pass. From this point forward, the code emission tables will show
    only what’s changed from the previous chapter, much like the tables describing
    the conversion from TACKY to assembly. See [Appendix B](appendix-B.xhtml) for
    a complete overview of the code emission pass; it includes three sets of tables
    showing how this pass will look at the end of [Part I](part1.xhtml), [Part II](part2.xhtml),
    and [Part III](part3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-8](chapter4.xhtml#tab4-8) shows how to print out this chapter’s new
    assembly instructions. It uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    prefix for local labels; if you’re on macOS, use an <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    prefix without a period instead.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(operand, operand)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp(label)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC(cond_code, label)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC(cond_code, operand)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(label)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction gets
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix to indicate that
    it operates on 4-byte values. Conditional set instructions don’t take a suffix
    to indicate the operand size, because they support only 1-byte operands. Jumps
    and labels also don’t use operand size suffixes, since they don’t take operands.
    However, conditional jump and set instructions do need suffixes to indicate what
    condition they test. [Table 4-9](chapter4.xhtml#tab4-9) gives the corresponding
    suffix for each condition code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Condition Codes</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ne</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">le</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ge</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, [Table 4-10](chapter4.xhtml#tab4-10) gives the 1-byte and 4-byte aliases
    for each register. The 4-byte aliases are the same as in the previous chapter;
    the new 1-byte aliases are bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%al</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DX)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Emit the 1-byte names for registers when they appear in <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>
    and the 4-byte names anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your compiler can now handle relational and logical operators. In this chapter,
    you added conditional jumps to TACKY to support short-circuiting operators, and
    you learned about several new assembly instructions. You also learned how the
    CPU keeps track of the current instruction and records the results of comparisons.
    The new TACKY and assembly instructions you introduced in this chapter will eventually
    help you implement complex control structures like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and loops. But first, you’ll implement one of the most essential features
    of C: variables!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more in-depth discussions of undefined behavior, see these blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: “A Guide to Undefined Behavior in C and C++, Part 1” by John Regehr is a good
    overview of what undefined behavior means in the C standard and how it impacts
    compiler design (*[https://<wbr>blog<wbr>.regehr<wbr>.org<wbr>/archives<wbr>/213](https://blog.regehr.org/archives/213)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “With Undefined Behavior, Anything Is Possible” by Raph Levien explores some
    sources of undefined behavior in C and the history of how it got into the standard
    to begin with (*[https://<wbr>raphlinus<wbr>.github<wbr>.io<wbr>/programming<wbr>/rust<wbr>/2018<wbr>/08<wbr>/17<wbr>/undefined<wbr>-behavior<wbr>.html](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
