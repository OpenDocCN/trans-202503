- en: '![](../images/pg70.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg70.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-12.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-12.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOGICAL
    AND RELATIONAL OPERATORS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">逻辑与关系操作符</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'Now that you know how to compile binary operators, you’re going to add a whole
    mess of them (plus one more unary operator). In this chapter, you’ll add three
    logical operators: NOT (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>),
    AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>), and OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>).
    You’ll also add the relational operators: <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and so on. Each of these operators tests some condition, resulting in a value
    of 1 if that condition is true and 0 if it’s false.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何编译二元操作符，接下来你将添加大量的操作符（再加一个一元操作符）。在本章中，你将添加三个逻辑操作符：NOT（<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>）、AND（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>）和OR（<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>）。你还将添加关系操作符：<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>，等等。这些操作符中的每一个都会测试某个条件，如果条件为真，则返回1，否则返回0。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operators differ from the binary operators we’ve seen so far because they *short-circuit*:
    if you know the result after the first operand, you don’t evaluate the second
    operand. To support short-circuiting logic, we’ll add new instructions to TACKY
    that let us skip over blocks of code. We’ll also introduce several new instructions
    in the assembly generation pass, including conditional assembly instructions that
    let us take specific actions only if some condition is met.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>操作符与我们迄今为止看到的二元操作符不同，因为它们是*短路*操作符：如果你在评估第一个操作数后就知道结果，那么就不再评估第二个操作数。为了支持短路逻辑，我们将在TACKY中添加新的指令，允许我们跳过代码块。在汇编生成阶段，我们还将引入几条新指令，包括条件汇编指令，只有在满足特定条件时，我们才会执行相应的操作。
- en: Let’s start with a brief discussion of short-circuiting operators before moving
    on to the compiler passes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讲解编译器的处理过程之前，我们先简要讨论一下短路操作符。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Short-Circuiting Operators</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">短路操作符</samp>
- en: The C standard guarantees that <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> short-circuit when
    you don’t need the second operand. For example, consider the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1 - 1) &&</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo()</samp>.
    Because the first operand’s value is 0, the whole expression will evaluate to
    0 regardless of what <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    returns, so we won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    at all. Likewise, if the first operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    is nonzero, we don’t evaluate the second operand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C标准保证，当你不需要第二个操作数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp>会进行短路。例如，考虑表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">(1
    - 1) &&</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo()</samp>。由于第一个操作数的值是0，整个表达式将无论如何都评估为0，不管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>返回什么，因此我们根本不会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。同样，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp>的第一个操作数非零，我们就不再评估第二个操作数。
- en: This isn’t just a performance optimization; the second operand might not change
    the result of the expression, but evaluating it can have visible side effects.
    For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> function
    might perform I/O or update global variables. If your compiler doesn’t implement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    as short- circuiting operators, some compiled programs will behave incorrectly.
    (The standard defines this behavior in section 6.5.13, paragraph 4, for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operator and in section 6.5.14,
    paragraph 4, for the <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是性能优化；第二个操作数可能不会改变表达式的结果，但它的求值可能会产生可见的副作用。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    函数可能会执行 I/O 操作或更新全局变量。如果你的编译器没有实现<code><samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp></code>
    和 <code><samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp></code> 作为短路运算符，一些已编译的程序将表现异常。（标准在第
    6.5.13 节第 4 段中定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> 运算符的行为，在第
    6.5.14 节第 4 段中定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 运算符的行为。）
- en: Now that we’ve clarified how these operators work, you’re ready to continue
    coding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确了这些运算符的工作方式，你可以继续编码了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'In this chapter, you’ll add nine new tokens:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将添加九个新标记：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!</samp> | An exclamation point,
    the logical NOT operator |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!</samp> | 感叹号，逻辑非运算符 |'
- en: '| --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&&</samp> | Two ampersands,
    the logical AND operator |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&&</samp> | 两个与符号，逻辑与运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;&#124;</samp> | Two vertical
    bars, the logical OR operator |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;&#124;</samp> | 两个竖线，逻辑或运算符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp> | Two equal signs,
    the “equal to” operator |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp> | 两个等号，“等于”运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!=</samp> | An exclamation point
    followed by an equal sign, the “not equal to” operator |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!=</samp> | 感叹号后跟等号，“不等于”运算符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><</samp> | The “less than” operator
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><</samp> | “小于”运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">></samp> | The “greater than”
    operator |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">></samp> | “大于”运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><=</samp> | The “less than or
    equal to” operator |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><=</samp> | “小于或等于”运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">>=</samp> | The “greater than
    or equal to” operator |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">>=</samp> | “大于或等于”运算符 |'
- en: Your lexer should handle these the same way as the other operators you’ve added
    so far. Remember that the lexer should always choose the longest possible match
    for the next token. For example, if your input is <samp class="SANS_TheSansMonoCd_W5Regular_11"><=something</samp>,
    the next token the lexer emits should be <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的词法分析器应该像处理其他运算符一样处理这些运算符。记住，词法分析器应该始终选择下一个标记的最长匹配项。例如，如果输入是 <samp class="SANS_TheSansMonoCd_W5Regular_11"><=something</samp>，词法分析器发出的下一个标记应该是
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: Next, we’ll add the new operations to the AST definition. [Listing 4-1](chapter4.xhtml#list4-1)
    shows the updated definition, with these additions bolded.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把新操作添加到 AST 定义中。[清单 4-1](chapter4.xhtml#list4-1)展示了更新后的定义，已添加的部分用粗体标出。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The abstract syntax
    tree with comparison and logical operators</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-1：带有比较和逻辑运算符的抽象语法树</samp>
- en: We also need to make the corresponding changes to the grammar, as shown in [Listing
    4-2](chapter4.xhtml#list4-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对语法做相应的修改，详情见[清单 4-2](chapter4.xhtml#list4-2)。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The grammar with
    comparison and logical operators</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-2：带有比较和逻辑运算符的语法</samp>
- en: In [Listings 4-1](chapter4.xhtml#list4-1) and [4-2](chapter4.xhtml#list4-2),
    we’ve added some new operators, but we haven’t made any other changes. Now we’re
    ready to update the parsing code. First, update <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> operator.
    It should parse <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> the same
    way it parses the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operators.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 4-1](chapter4.xhtml#list4-1) 和 [4-2](chapter4.xhtml#list4-2) 中，我们增加了一些新运算符，但没有做其他更改。现在，我们准备更新解析代码。首先，更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> 来处理新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp> 运算符。它应该以与解析一元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 运算符相同的方式解析 <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>。
- en: Next, update <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    to handle the new binary operators. In [Chapter 3](chapter3.xhtml), we associated
    every binary operator with a numeric precedence value. Now we’ll give the new
    operators precedence values. These operators have lower precedence than the ones
    from [Chapter 3](chapter3.xhtml), and they’re all left-associative. Among the
    new operators, <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    have the highest precedence, followed by the equality operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    operator has lower precedence than the equality operators, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    has the lowest precedence of all. The precedence values I’ve chosen are listed
    in [Table 4-1](chapter4.xhtml#tab4-1), with new operators bolded.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 以处理新的二元运算符。在
    [第 3 章](chapter3.xhtml) 中，我们将每个二元运算符与一个数字优先级值进行了关联。现在，我们将为新的运算符赋予优先级值。这些运算符的优先级低于
    [第 3 章](chapter3.xhtml) 中的运算符，并且它们都是左结合的。在新的运算符中，<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> 拥有最高的优先级，其次是等式运算符，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> 运算符的优先级低于等式运算符，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    拥有最低的优先级。我选择的优先级值列在 [表 4-1](chapter4.xhtml#tab4-1) 中，新运算符以粗体显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Old and New Binary Operators</samp>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-1：</samp> <samp class="SANS_Futura_Std_Book_11">旧版和新版二元运算符的优先级值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">优先级</samp>
    |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11"><</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11"><</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11"><=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11"><=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">></samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">></samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">>=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">>=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">35</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">==</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">==</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">!=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">!=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">30</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">&&</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">10</samp>
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">&&</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">10</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">&#124;&#124;</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">&#124;&#124;</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">5</samp>
    |'
- en: These values are spaced far enough apart to leave room for the optional bitwise
    operators from [Chapter 3](chapter3.xhtml). There’s also room at the bottom of
    the scale for the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> operators we’ll add in the next
    two chapters. You don’t need to use the exact values in this table as long as
    all operators have the correct precedence relative to each other.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值间隔得足够远，可以为[第三章](chapter3.xhtml)中的可选位运算符留出空间。底部还留有足够的空间，供我们在接下来的两章中添加 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>
    运算符。只要所有运算符之间的优先级关系正确，你不需要使用表格中的精确值。
- en: You’ll also need to extend the code that converts tokens into <samp class="SANS_TheSansMonoCd_W5Regular_11">unary
    _operator</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp>
    AST nodes. For example, the function that converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    token into an <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp> node should
    also convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> token into
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> node. (The pseudocode
    in the last two chapters called separate functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>, to handle
    these conversions.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要扩展将令牌转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unary _operator</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> AST 节点的代码。例如，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 令牌转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp>
    节点的函数，应该还要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 令牌转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> 节点。（最后两章中的伪代码调用了单独的函数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>，来处理这些转换。）
- en: Once you’ve updated your parser’s table of precedence values, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse
    _binop</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>,
    you’re done! The precedence climbing algorithm we implemented in the last chapter
    can handle the new operators without further changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了解析器的优先级值表，<samp class="SANS_TheSansMonoCd_W5Regular_11">parse _binop</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>，你就完成了！我们在上一章实现的优先级提升算法可以处理新的运算符，无需进一步更改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'Now that the lexer and parser are working properly, we can venture into less
    familiar territory: handling the new operators in TACKY. You can convert relational
    operators to TACKY in the same way as the binary operators you’ve already implemented.
    For example, given the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e1
    < e2</samp>, the resulting TACKY looks something like [Listing 4-3](chapter4.xhtml#list4-3).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在词法分析器和解析器已经正常工作，我们可以进入一个不太熟悉的领域：处理 TACKY 中的新运算符。你可以像实现二元运算符一样，将关系运算符转换为 TACKY。例如，给定表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e1 < e2</samp>，生成的 TACKY 看起来像是 [清单
    4-3](chapter4.xhtml#list4-3) 中的内容。
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Implementing the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11"><</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    in TACKY</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-3：实现 TACKY 中的</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11"><</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: You can’t generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators this way,
    though, because they short-circuit. The code in [Listing 4-3](chapter4.xhtml#list4-3)
    always evaluates both <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>, but we need to generate
    code that sometimes skips <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>.
    To support short-circuiting operators, we’ll add an *unconditional jump* instruction,
    which lets us jump to a different point in the program. We’ll also add two *conditional
    jump* instructions, which jump only when a particular condition is met.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您不能通过这种方式生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 操作符，因为它们是短路操作。[列表 4-3](chapter4.xhtml#list4-3)中的代码始终会评估
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>，但我们需要生成的代码有时会跳过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>。为了支持短路操作符，我们将添加一条 *无条件跳转*
    指令，允许我们跳转到程序中的其他位置。我们还将添加两条 *条件跳转* 指令，只有在满足特定条件时才会跳转。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Jumps, Copies,
    and Comparisons to the TACKY IR</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">向 TACKY 中间表示添加跳转、复制和比较</samp>
- en: '[Listing 4-4](chapter4.xhtml#list4-4) shows the latest TACKY IR, including
    the new jump instructions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](chapter4.xhtml#list4-4) 展示了最新的 TACKY 中间表示，包含新的跳转指令。'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Adding comparisons,
    jumps, and labels to TACKY</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-4：向 TACKY 添加比较、跳转和标签</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction works
    just like <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> in C: it makes
    the program jump to the point labeled with some identifier, <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction associates
    an identifier with a location in the program. The snippet of TACKY in [Listing
    4-5](chapter4.xhtml#list4-5) shows how <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions work
    together.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">跳转</samp> 指令的工作原理与 C 语言中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> 类似：它使程序跳转到某个标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">目标</samp>
    所标记的位置。<samp class="SANS_TheSansMonoCd_W5Regular_11">标签</samp> 指令将标识符与程序中的位置关联起来。[列表
    4-5](chapter4.xhtml#list4-5) 中的 TACKY 代码片段展示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">跳转</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">标签</samp> 指令如何协同工作。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: A snippet of TACKY
    with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Jump</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-5：TACKY 的代码片段，包含一条</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">跳转</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令</samp>
- en: This program stores <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, then executes the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction, which jumps
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction.
    Next, it executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, which returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>.
    The second <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction
    ❶ won’t execute at all, because we jumped over it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    中，然后执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">跳转</samp> 指令，跳转到 <samp class="SANS_TheSansMonoCd_W5Regular_11">标签</samp>
    指令。接着，它执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">返回</samp> 指令，返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。第二条 <samp class="SANS_TheSansMonoCd_W5Regular_11">一元</samp>
    指令 ❶ 完全不会执行，因为我们跳过了它。
- en: 'The first conditional jump in the TACKY IR, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    jumps to the instruction indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>
    if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is 0\. If <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is anything
    other than 0, we don’t jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>;
    instead, we execute the next instruction as usual. The second conditional jump,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, does the opposite:
    we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> only if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> isn’t 0\. We don’t
    really need both of these instructions, since any behavior you can express with
    one can be expressed with the other plus a <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    instruction. But adding both lets us generate simpler TACKY for the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operations, which
    will ultimately translate into simpler, shorter assembly.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TACKY IR 中的第一个条件跳转指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>，当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> 的值为 0 时，跳转到由 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">target</samp> 指定的指令。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    不为 0，我们不会跳转到 <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>，而是按常规执行下一条指令。第二个条件跳转指令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> 则相反：只有当 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> 不为 0 时，我们才会跳转到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">target</samp>。我们其实并不需要这两条指令，因为你可以使用其中一条指令配合
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> 指令来实现相同的行为。但添加这两条指令可以使我们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    运算符生成更简单的 TACKY，从而最终转换为更简洁、短小的汇编代码。
- en: The other new instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    ultimately return 1 or 0, we use this instruction to copy 1 or 0 into the temporary
    variable that holds the result of the expression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新指令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 最终返回 1 或 0，我们使用此指令将
    1 或 0 复制到临时变量中，该变量保存表达式的结果。
- en: Besides these five additional instructions, the latest TACKY IR includes the
    new relational and logical binary operators and the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这五个额外的指令外，最新的 TACKY IR 还包括新的关系和逻辑二元运算符，以及一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    运算符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Short-Circuiting
    Operators to TACKY</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将短路运算符转换为 TACKY</samp>
- en: Let’s use the new TACKY instructions to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators. The TACKY
    for the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e1 && e2</samp>
    should look like [Listing 4-6](chapter4.xhtml#list4-6).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用新的 TACKY 指令来实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 运算符。对于表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">e1
    && e2</samp>，TACKY 应该如下所示 [Listing 4-6](chapter4.xhtml#list4-6)。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Implementing the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">&&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    in TACKY</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: 在 TACKY 中实现</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">&&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>'
- en: We start by evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>.
    If it’s 0, we short-circuit and set <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, without evaluating
    <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>. We accomplish this with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction;
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp> is 0, we jump straight
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>, then set
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    (I’ve written this out as <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(0, result)</samp>
    to make it more readable. I’ll take similar liberties with TACKY notation in later
    chapters.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp> isn’t 0,
    we still need to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>.
    We handle the case where <samp class="SANS_TheSansMonoCd_W5Regular_11">v2</samp>
    is 0 exactly like the case where <samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp>
    is 0, by jumping to <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>. We reach
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, only if we didn’t take
    either conditional jump. That means both <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp> are nonzero, so we
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Then, we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> label to avoid
    overwriting <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先评估<samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>。如果它是0，我们将直接跳过后续步骤，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，无需评估<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>。我们通过<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>指令实现这一点；如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v1</samp>为0，我们直接跳转到<samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令将<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。（我将其写成<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy(0, result)</samp>，以提高可读性。稍后的章节中，我会在TACKY符号表示法上做类似的处理。）如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v1</samp>不是0，我们仍然需要评估<samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>。我们处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v2</samp>为0的情况，方式与处理<samp class="SANS_TheSansMonoCd_W5Regular_11">v1</samp>为0时相同，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>跳转到<samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>。只有在没有执行任何条件跳转时，我们才会到达<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。这意味着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>都非零，因此我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。然后，我们跳过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，跳转到<samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>标签，避免覆盖<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>。
- en: I’ll leave it to you to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operation to TACKY on your own. The resulting TACKY will look similar to [Listing
    4-6](chapter4.xhtml#list4-6), but it will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    instruction instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>.
    That leaves <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> and all the
    relational operations; you can convert them to TACKY in the same way as the unary
    and binary operations you added in the previous chapters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把将 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 操作翻译成 TACKY 留给你自己完成。生成的
    TACKY 将类似于 [列表 4-6](chapter4.xhtml#list4-6)，但是它会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    指令，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>。这还剩下 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp> 和所有的关系操作符；你可以像前几章中添加的一元和二元操作符一样，将它们转化为
    TACKY。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Labels</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">生成标签</samp>
- en: 'Labels, like temporary variables, must be globally unique: an instruction like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump("foo")</samp> is useless if
    the label <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> shows up in
    multiple places. You can make sure they’re unique by incorporating a global counter
    into labels, like you did with variable names in [Chapter 2](chapter2.xhtml).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标签和临时变量一样，必须在全局范围内唯一：像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump("foo")</samp>
    这样的指令，如果标签 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> 出现在多个地方，就没有意义。你可以通过将全局计数器纳入标签中，确保它们是唯一的，就像你在
    [第 2 章](chapter2.xhtml) 中对变量名所做的那样。
- en: Unlike temporary variables, labels will appear in the final assembly program,
    so they must be identifiers that the assembler considers syntactically valid.
    They should contain only letters, digits, periods, and underscores. Choose descriptive
    labels to make your assembly programs easier to read and debug. For example, you
    could use the string <samp class="SANS_TheSansMonoCd_W5Regular_11">and_false</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>
    in [Listing 4-6](chapter4.xhtml#list4-6), where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    is the current value of a global counter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与临时变量不同，标签会出现在最终的汇编程序中，因此它们必须是汇编器认为语法上有效的标识符。它们应只包含字母、数字、点和下划线。选择描述性标签可以让你的汇编程序更易于阅读和调试。例如，你可以使用字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">and_false</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    作为 [列表 4-6](chapter4.xhtml#list4-6) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">false_label</samp>，其中
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> 是全局计数器的当前值。
- en: Although labels must not conflict with each other, it’s okay for them to conflict
    with temporary variable names. It’s also okay if the labels you generate here
    conflict with user-defined function names, even though both autogenerated labels
    and function names become labels in the final assembly program. We’ll mangle our
    autogenerated labels during code emission so they don’t conflict with user-defined
    identifiers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标签不能相互冲突，但它们与临时变量名冲突是可以的。如果你在这里生成的标签与用户定义的函数名冲突也是可以的，即使自动生成的标签和函数名都会在最终的汇编程序中变成标签。我们将在代码生成时对自动生成的标签进行处理，以避免它们与用户定义的标识符冲突。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Comparisons and Jumps in Assembly</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">汇编中的比较与跳转</samp>'
- en: Before starting on the assembly generation pass, let’s talk through the new
    assembly instructions we’ll need. First, we’ll discuss the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction, which compares two values, and the *conditional set* instructions,
    which set a byte to 1 or 0 based on the result of a comparison. We’ll use these
    to implement relational operators like <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>.
    Next, we’ll talk about conditional and unconditional jump instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始汇编生成过程之前，让我们先讲解一下我们需要的新汇编指令。首先，我们将讨论 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    指令，它用于比较两个值，以及 *条件设置* 指令，它根据比较结果将字节设置为 1 或 0。我们将使用这些指令来实现像 <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    这样的关系操作符。接下来，我们将讨论条件跳转和无条件跳转指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparisons and Status
    Flags</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">比较和状态标志</samp>
- en: 'The “condition” that all conditional instructions depend on is the state of
    the RFLAGS register. Unlike EAX, RSP, and the other registers we’ve seen so far,
    we usually can’t directly set RFLAGS. Instead, the CPU updates RFLAGS automatically
    every time it issues an instruction. As the name suggests, each bit in this register
    is a flag that reports some fact about the last instruction or the status of the
    CPU. Different instructions update different flags: the <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instructions update all the flags we’ll talk about in this section, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction doesn’t update
    any of them. We can ignore the effects of other instructions for now. Whenever
    I refer to the “last instruction” or “last result” while discussing RFLAGS, I
    mean the last instruction that affects the particular flag I’m talking about.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有条件指令依赖的“条件”是 RFLAGS 寄存器的状态。与 EAX、RSP 和我们到目前为止见过的其他寄存器不同，我们通常不能直接设置 RFLAGS。相反，CPU
    每次执行指令时会自动更新 RFLAGS。如其名称所示，这个寄存器中的每一位都是一个标志，报告有关最后一条指令或 CPU 状态的某些信息。不同的指令更新不同的标志：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 指令更新本节中我们将讨论的所有标志，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令则不更新任何标志。我们现在可以忽略其他指令的影响。在讨论
    RFLAGS 时，每当我提到“最后一条指令”或“最后结果”，我指的是影响我正在讨论的特定标志的最后一条指令。
- en: 'Right now, we care about three of these flags:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们关注这三个标志：
- en: '**Zero flag (ZF)**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**零标志 (ZF)**'
- en: ZF is set to 1 if the result of the last instruction was 0\. It’s set to 0 if
    the result of the last instruction was nonzero.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一条指令的结果为 0，则 ZF 被设置为 1；如果最后一条指令的结果为非零值，则 ZF 被设置为 0。
- en: '**Sign flag (SF)**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号标志 (SF)**'
- en: SF is set to 1 if the most significant bit of the last result was 1\. It’s set
    to 0 if the most significant bit of that result was 0\. Remember that in two’s
    complement, the most significant bit of a negative number is always 1, and the
    most significant bit of a positive number is always 0\. Therefore, the sign flag
    tells us whether the result of the last instruction was positive or negative.
    (If the last result should be interpreted as an unsigned integer, it can’t be
    negative, so the sign flag is meaningless.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后结果的最高有效位是 1，则 SF 被设置为 1；如果最高有效位是 0，则 SF 被设置为 0。记住，在二进制补码表示法中，负数的最高有效位始终是
    1，正数的最高有效位始终是 0。因此，符号标志告诉我们最后一条指令的结果是正数还是负数。（如果最后的结果应该被解释为无符号整数，那么它不能为负数，因此符号标志没有意义。）
- en: '**Overflow flag (OF)**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**溢出标志 (OF)**'
- en: OF is set to 1 if the last instruction resulted in a signed integer overflow,
    and 0 otherwise. An *integer overflow* occurs when the result of a signed integer
    operation can’t be represented in the number of bits available. A positive result
    overflows when it’s larger than the maximum value the type can hold. Suppose we’re
    operating on 4-bit integers. The largest signed number we can represent is 7,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp> in binary. If we
    add one to it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    instruction, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>.
    If we interpret this as an unsigned integer, its value is 8, but its value is
    –8 if we interpret it as a two’s complement signed integer. The result of the
    computation should be positive, but since it overflowed, it appears negative.
    This computation sets the overflow flag to 1.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一条指令导致有符号整数溢出，则 OF 被设置为 1；否则设置为 0。*整数溢出*发生在有符号整数操作的结果无法用可用的位数表示时。一个正数结果会在其值超过类型可以表示的最大值时发生溢出。假设我们正在操作
    4 位整数。我们可以表示的最大有符号数是 7，即二进制表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>。如果我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 指令将其加 1，结果是 <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>。如果我们将其解释为无符号整数，它的值是
    8；但是，如果我们将其解释为二进制补码有符号整数，它的值是 -8。计算的结果应该是正数，但由于发生了溢出，它变成了负数。这个计算将溢出标志设置为 1。
- en: 'We also encounter integer overflow in the opposite situation: when the result
    should be negative, but it’s below the smallest possible value. For example, in
    ordinary math, –8 – 1 = –9\. But if we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instruction to subtract one from the 4-bit two’s complement representation of
    –8, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, we end
    up with <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>, or 7\. The
    overflow flag is set to 1 in this case too.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会遇到与此相反的整数溢出情况：当结果应该为负数，但它小于可能的最小值。例如，在普通数学中，–8 – 1 = –9。然而，如果我们使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> 指令从–8的4位二进制补码表示中减去1，得到的是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>，结果会变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>，即7。此时，溢出标志也会被设置为1。
- en: An unsigned result can also be too large or small for its type to represent,
    but I won’t refer to this as integer overflow in this book. Instead, I say the
    result *wrapped around*, which is more consistent with the terminology for unsigned
    operations in the C standard and in most discussions of x64 assembly. I draw this
    distinction because unsigned wraparound follows different rules from signed integer
    overflow in the C standard, and the CPU detects it differently. You’ll learn how
    to handle unsigned wraparound in [Part II](part2.xhtml). Like SF, OF is meaningless
    if the result is unsigned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号结果也可能对其类型表示来说过大或过小，但在本书中我不会将其称为整数溢出。相反，我称结果为 *环绕*，这与 C标准中对无符号操作的术语以及大多数关于
    x64 汇编的讨论更一致。我做出这个区分是因为无符号环绕遵循的规则与有符号整数溢出不同，CPU 对其检测的方式也不同。你将在[第二部分](part2.xhtml)学习如何处理无符号环绕。像
    SF 一样，如果结果是无符号的，OF 是没有意义的。
- en: '[Tables 4-2](chapter4.xhtml#tab4-2) and [4-3](chapter4.xhtml#tab4-3) summarize
    the cases where each kind of integer overflow is possible. [Table 4-2](chapter4.xhtml#tab4-2)
    describes the results of addition.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](chapter4.xhtml#tab4-2) 和 [表 4-3](chapter4.xhtml#tab4-3) 总结了每种整数溢出的可能情况。[表
    4-2](chapter4.xhtml#tab4-2) 描述了加法的结果。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Integer
    Overflow and Underflow from Addition</samp>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-2：</samp> <samp class="SANS_Futura_Std_Book_11">从加法产生的整数溢出与下溢</samp>
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a + b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a + b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">Overflow
    from positive to negative</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">从正数到负数的溢出</samp>
    | <samp class="SANS_Futura_Std_Book_11">都不是</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    | <samp class="SANS_Futura_Std_Book_11">Overflow from negative to positive</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">都不是</samp>
    | <samp class="SANS_Futura_Std_Book_11">从负数到正数的溢出</samp> |'
- en: '[Table 4-3](chapter4.xhtml#tab4-3) describes the results of subtraction; it’s
    just [Table 4-2](chapter4.xhtml#tab4-2) with the columns swapped, since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(-
    b)</samp> are equivalent.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-3](chapter4.xhtml#tab4-3) 描述了减法的结果；它只是 [表 4-2](chapter4.xhtml#tab4-2)
    的列交换版本，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(-
    b)</samp> 是等价的。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Integer
    Overflow and Underflow from Subtraction</samp>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-3：</samp> <samp class="SANS_Futura_Std_Book_11">从减法产生的整数溢出与下溢</samp>
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a - b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a - b</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b
    > 0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b < 0</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    | <samp class="SANS_Futura_Std_Book_11">Overflow from positive to negative</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > 0</samp> | <samp class="SANS_Futura_Std_Book_11">都没有溢出</samp>
    | <samp class="SANS_Futura_Std_Book_11">从正数溢出到负数</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">Overflow
    from negative to positive</samp> | <samp class="SANS_Futura_Std_Book_11">Neither</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < 0</samp> | <samp class="SANS_Futura_Std_Book_11">从负数溢出到正数</samp>
    | <samp class="SANS_Futura_Std_Book_11">都没有溢出</samp> |'
- en: The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp>
    computes <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>, exactly like
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction, and
    has the same impact on RFLAGS, but it discards the result instead of storing it
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This is more convenient
    when you want to subtract two numbers only in order to compare them and don’t
    want to overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp> 计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp>，与 <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> 指令完全相同，并对
    RFLAGS 产生相同的影响，但它会丢弃结果，而不是将其存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    中。当你只想比较两个数，而不想覆盖 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 时，这种方式更为方便。
- en: 'Let’s figure out the values of ZF and SF after the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    b, a</samp>:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp> 指令后
    ZF 和 SF 的值：
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is 0, so ZF is 1 and SF is 0.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 的结果为 0，因此 ZF 为 1，SF 为 0。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is a positive number, so both SF and ZF are 0.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 是正数，因此 SF 和 ZF 都为 0。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> is a negative number, so SF is 1 and ZF is 0.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 是负数，因此 SF 为 1，ZF 为 0。
- en: 'By issuing a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction
    and then checking ZF and SF, you can handle every comparison we’re implementing
    in this chapter. But wait! That’s not quite true, because <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow, which would flip SF. Let’s consider how that impacts
    each case:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 指令，然后检查 ZF 和 SF，你可以处理本章中实现的每一个比较。但等一下！这并不完全正确，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> 可能会发生溢出，这将改变 SF 的值。让我们来看看溢出如何影响每种情况：
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> can’t overflow because it’s 0.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 的结果为 0，因此不会发生溢出。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is positive and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is negative.
    The correct result in this case is positive, but if it overflows, the result will
    be negative. In that case, SF will be 1, and OF will be too.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>，则当 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    为正数且 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 为负数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 可能会溢出。此时，正确的结果应为正数，但如果发生溢出，结果将为负数。在这种情况下，SF 将为 1，OF 也会为 1。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> could overflow when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is negative and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is positive.
    In this case, the correct result is negative, but the actual result will be positive.
    That means SF will be 0, but OF will be 1.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 4-4](chapter4.xhtml#tab4-4) gives the values of these flags in every
    case we’ve considered.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Impact
    of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    on Status Flags</samp>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">ZF</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">OF</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">SF</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    no overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a > b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    no overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">a < b</samp><samp class="SANS_Futura_Std_Medium_Oblique_I_11">,
    overflow</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: You can tell whether <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is larger by checking
    whether SF and OF are the same. If they are, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">≥</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    Either both are 0, because we got a positive (or 0) result with no overflow, or
    both are 1, because we got a large positive result that overflowed until it became
    negative. If SF and OF are different, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp>. Either we got a negative result with no overflow, or we got a negative
    result that overflowed and became positive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to set ZF, OF, and SF, let’s take a look at a few
    instructions that depend on those flags.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Set Instructions</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To implement a relational operator, we first set some flags using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, then set the result
    of the expression based on those flags. We perform that second step with a *conditional
    set* instruction. Each conditional set instruction takes a single register or
    memory address as an operand, which it sets to 0 or 1 based on the state of RFLAGS.
    The conditional set instructions are all identical, except that they test for
    different conditions. [Table 4-5](chapter4.xhtml#tab4-5) lists the conditional
    set instructions we need in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Conditional
    Set Instructions</samp>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Flags</samp> |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sete</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    set</samp> |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setne</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a !=</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    not set</samp> |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setg</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp> | <samp
    class="SANS_Futura_Std_Book_11">ZF not set and SF == OF</samp> |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setge</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">≥</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">SF
    == OF</samp> |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setl</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> | <samp
    class="SANS_Futura_Std_Book_11">SF != OF</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">setle</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    byte if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">≤</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF
    set or SF != OF</samp> |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: Unlike the other instructions we’ve seen so far, conditional set instructions
    take only 1-byte operands. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">sete
    %eax</samp> is not a valid instruction, because EAX is a 4-byte register. The
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">sete %al</samp>, however,
    is valid; this sets the AL register, the least significant byte of EAX. To conditionally
    set the whole EAX register to 0 or 1, you need to zero out EAX before you set
    AL, because the conditional set instruction won’t clear its upper bytes. For example,
    if EAX is
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and you run
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: then the new value in EAX is
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: which is, of course, not 0\. The <samp class="SANS_TheSansMonoCd_W5Regular_11">sete</samp>
    instruction zeroed out the last byte of EAX, but not the rest of it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: If its operand is a memory address, a conditional set instruction will update
    the single byte at that address. Note that a memory address can be a 1-byte, 4-byte,
    or 8-byte operand, depending on context. In <samp class="SANS_TheSansMonoCd_W5Regular_11">sete
    -4(%rbp)</samp>, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    indicates a single byte of memory at RBP – 4; in <samp class="SANS_TheSansMonoCd_W5Regular_11">addl
    $1, -4(%rbp)</samp>, it indicates the 4 bytes of memory starting at RBP – 4.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Jump Instructions</samp>
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> assembly instruction
    takes a label as an argument and performs an unconditional jump to that label.
    Jump assembly instructions manipulate another special-purpose register, RIP, which
    always holds the address of the next instruction to execute (IP stands for *instruction
    pointer*). To execute a sequence of instructions, the CPU carries out the *fetch-execute
    cycle*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Fetch an instruction from the memory address in RIP and store it in a special-purpose
    *instruction register*. (This register doesn’t have a name because you can’t refer
    to it in assembly.)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment RIP to point to the next instruction. Instructions in x64 aren’t all
    the same length, so the CPU has to check the length of the instruction it just
    fetched and increment RIP by that many bytes.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RIP 增量指向下一条指令。x64 中的指令长度并不相同，因此 CPU 必须检查它刚刚取回的指令的长度，并按该长度增加 RIP。
- en: Run the instruction in the instruction register.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指令寄存器中运行指令。
- en: Repeat.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行。
- en: Normally, following these steps executes instructions in the order they appear
    in memory. But <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> puts a
    new value in RIP, which changes what instruction the CPU executes next. The assembler
    and linker convert the label in a jump instruction into a *relative offset* that
    tells you how much to increment or decrement RIP. Consider the snippet of assembly
    in [Listing 4-7](chapter4.xhtml#list4-7).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，按照这些步骤执行指令时，它们会按照出现在内存中的顺序执行。但 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    将一个新值放入 RIP 中，这会改变 CPU 下一步执行的指令。汇编器和链接器将跳转指令中的标签转换为 *相对偏移量*，该偏移量告诉你应该如何增减 RIP。请参考
    [清单 4-7](chapter4.xhtml#list4-7) 中的汇编代码片段。
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: A snippet of assembly
    code with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">jmp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-7：包含</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">jmp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令的汇编代码片段</samp>
- en: 'The machine instruction for <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $0, %eax</samp> is 5 bytes long. To jump over it and execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    needs to increment RIP by an extra 5 bytes. The assembler and linker therefore
    convert <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp foo</samp> into the
    machine instruction for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>.
    Then, when the CPU executes this instruction, it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $0, %eax</samp> 的机器指令长度为
    5 字节。为了跳过它并执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> 指令，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> 需要额外增加 5 字节。汇编器和链接器因此将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp foo</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    5</samp> 的机器指令。然后，当 CPU 执行该指令时，它：
- en: Fetches the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>
    and stores it in the instruction register.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp> 并将其存储在指令寄存器中。
- en: Increments RIP to point to the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $0, %eax</samp>.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加 RIP，以指向下一条指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $0, %eax</samp>。
- en: Executes <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>. This adds
    5 bytes to RIP so that it points to <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 5</samp>。这会将 RIP 增加 5 字节，使其指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>。
- en: Fetches the instruction RIP points to, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>,
    and continues the fetch- execute cycle from there.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 RIP 指向的指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>，并从该位置继续取指-执行周期。
- en: 'Note that labels aren’t instructions: the CPU doesn’t execute them, and they
    don’t appear in the text section of the final executable (the section that contains
    machine instructions).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标签不是指令：CPU 不执行它们，且它们不会出现在最终可执行文件的文本区中（该部分包含机器指令）。
- en: A *conditional jump* takes a label as an argument but jumps to that label only
    if the condition holds. Conditional jumps look a lot like conditional set instructions;
    they depend on the same conditions, using the same flags in RFLAGS. For example,
    the assembly in [Listing 4-8](chapter4.xhtml#list4-8) returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    if the EAX and EDX registers are equal, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件跳转*将标签作为参数，但只有在条件满足时才跳转到该标签。条件跳转看起来与条件设置指令非常相似；它们依赖于相同的条件，使用 RFLAGS 中的相同标志。例如，[清单
    4-8](chapter4.xhtml#list4-8)中的汇编代码如果 EAX 和 EDX 寄存器相等，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，否则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。'
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: A snippet of assembly
    code with a conditional jump</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-8：包含条件跳转的汇编代码片段</samp>
- en: If the values in EAX and EDX are equal, <samp class="SANS_TheSansMonoCd_W5Regular_11">cmpl</samp>
    sets ZF to 1, so <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> jumps
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">return3</samp>. Then, the two
    instructions following <samp class="SANS_TheSansMonoCd_W5Regular_11">return3</samp>
    execute, so the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    If EAX and EDX aren’t equal, <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp>
    doesn’t perform the jump, so the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> jumps only
    if ZF is 0\. There are also jump instructions that check other conditions, but
    we don’t need them in this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand the new assembly instructions you’ll need, let’s extend
    the assembly AST and update each assembly generation pass. [Listing 4-9](chapter4.xhtml#list4-9)
    defines the latest assembly AST, with additions bolded.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: The assembly AST
    with comparisons and conditional instructions</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Since all conditional jump instructions have the same form, we represent them
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp> instruction
    and distinguish between them using different condition codes. We do the same with
    conditional set instructions. We also treat labels like instructions at this stage,
    even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> isn’t really
    an instruction since labels aren’t executed by the CPU.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: To implement the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions,
    we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp> assembly
    instruction. We convert
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'to:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We implement <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    the same way, but with <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> as the condition
    code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we implement all the relational operators using conditional set instructions.
    For example, the TACKY instruction
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'becomes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For all the other relational operators, replace <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    with the appropriate condition code. Remember to zero out the destination before
    the conditional set instruction, since it sets only the lowest byte. It’s safe
    to perform a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> right after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> doesn’t change RFLAGS.
    One potential wrinkle is that <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>
    needs a 1-byte operand, but <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is 4 bytes; luckily, we can account for this in the code emission pass. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a location in memory, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> sets the first byte at that
    location, which is the behavior we want. (Because x64 processors are *little-endian*,
    the first byte is the least significant, so setting that byte to 1 sets the whole
    32-bit value to 1.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is a register, we’ll use the corresponding 1-byte register name when we emit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> during code emission. Registers
    in the assembly AST are size agnostic, so for now we represent <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    the same way whether we’re using it as a 4-byte or 1-byte operand.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">!x</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, we also implement the
    unary <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> operator with a conditional
    set instruction. We convert the TACKY instruction
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'into:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The remaining TACKY instructions—<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>—are
    easy. A TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> becomes
    an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>.
    [Tables 4-6](chapter4.xhtml#tab4-6) and [4-7](chapter4.xhtml#tab4-7) summarize
    how to convert each new TACKY construct to assembly. Note that these tables include
    only new constructs, unlike the equivalent tables in [Chapters 2](chapter2.xhtml)
    and [3](chapter3.xhtml).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-6](chapter4.xhtml#tab4-6) shows how to convert the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, and conditional and
    unconditional jump instructions to assembly, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    instructions with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions
    with the new relational operators.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), src) Mov(Imm(0), dst)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: SetCC(E, dst)</samp> |
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(relational_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(src2,
    src1) Mov(Imm(0), dst)</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC(relational_operator, dst)</samp>
    |
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump(target)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jmp(target)</samp> |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), condition) JmpCC(E,
    target)</samp> |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Imm(0), condition) JmpCC(NE,
    target)</samp> |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(identifier)</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(identifier)</samp> |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '[Table 4-7](chapter4.xhtml#tab4-7) gives the corresponding condition code for
    each relational operator in TACKY.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-7:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp>
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LE</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">G</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GE</samp> |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: 'From now on, the tables describing each chapter’s conversion from TACKY to
    assembly will show only what’s changed from the chapter before. [Appendix B](appendix-B.xhtml)
    includes two sets of tables giving the complete conversion from TACKY to assembly:
    one shows the conversion at the end of [Part I](part1.xhtml), and the other shows
    the conversion at the end of [Part II](part2.xhtml).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Update this pass to replace any pseudoregisters used by the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp> instructions with
    stack addresses, just like you did for all the other instructions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the
    cmp Instruction</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, much
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, can’t use memory
    addresses for both operands. We rewrite it in the usual way, turning
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'into:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction can’t be a constant. This sort of makes sense if you remember that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> follows the same form
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>; the second operand
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instruction can’t
    be a constant either, since that operand holds the result. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    doesn’t produce a result, the same rules apply. We rewrite
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'as:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Following the convention from the previous chapter, we use R10 to fix a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction’s first operand
    and R11 to fix its second operand.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve generated a valid assembly program, and we’re ready to emit it. Code emission
    is slightly more complicated in this chapter, for two reasons. First, we’re dealing
    with both 1-byte and 4-byte registers. We’ll print out a different name for a
    register depending on whether it appears in a conditional set instruction, which
    takes 1-byte operands, or any of the other instructions we’ve encountered so far,
    which take 4-byte operands.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is emitting labels. Some assembly labels are autogenerated
    by the compiler, while others—function names—are user-defined identifiers. Right
    now, the only function name is <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    but eventually we’ll compile programs with arbitrary function names. Because labels
    must be unique, autogenerated labels must not conflict with any function names
    that could appear in a program.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We’ll avoid conflicts by adding a special *local label* prefix to our autogenerated
    labels. The local label prefix is <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    on Linux and <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> on macOS.
    On Linux, these labels won’t conflict with user-defined identifiers because identifiers
    in C can’t contain periods. On macOS, they won’t conflict because we prefix all
    user-defined names with underscores (so that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">_main</samp>, for example).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Local labels are handy for another reason: they won’t confuse GDB or LLDB when
    you need to debug this code. The assembler puts most labels in the object file’s
    symbol table, but it leaves out any that start with the local label prefix. If
    your autogenerated labels were in the symbol table, GDB and LLDB would mistake
    them for function names, which would cause problems when you tried to disassemble
    a function or view a stack trace.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Aside from those two issues, code emission is pretty straightforward. [Tables
    4-8](chapter4.xhtml#tab4-8) through [4-10](chapter4.xhtml#tab4-10) summarize the
    changes to this pass. From this point forward, the code emission tables will show
    only what’s changed from the previous chapter, much like the tables describing
    the conversion from TACKY to assembly. See [Appendix B](appendix-B.xhtml) for
    a complete overview of the code emission pass; it includes three sets of tables
    showing how this pass will look at the end of [Part I](part1.xhtml), [Part II](part2.xhtml),
    and [Part III](part3.xhtml).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-8](chapter4.xhtml#tab4-8) shows how to print out this chapter’s new
    assembly instructions. It uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    prefix for local labels; if you’re on macOS, use an <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    prefix without a period instead.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(operand, operand)</samp>
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp(label)</samp> |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC(cond_code, label)</samp>
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC(cond_code, operand)</samp>
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(label)</samp> |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction gets
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix to indicate that
    it operates on 4-byte values. Conditional set instructions don’t take a suffix
    to indicate the operand size, because they support only 1-byte operands. Jumps
    and labels also don’t use operand size suffixes, since they don’t take operands.
    However, conditional jump and set instructions do need suffixes to indicate what
    condition they test. [Table 4-9](chapter4.xhtml#tab4-9) gives the corresponding
    suffix for each condition code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Condition Codes</samp>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ne</samp>
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">le</samp>
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ge</samp>
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: Finally, [Table 4-10](chapter4.xhtml#tab4-10) gives the 1-byte and 4-byte aliases
    for each register. The 4-byte aliases are the same as in the previous chapter;
    the new 1-byte aliases are bolded.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%al</samp>
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DX)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp> |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dl</samp>
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp> |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10b</samp>
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp> | <samp class="SANS_Futura_Std_Book_11">4-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11b</samp>
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: Emit the 1-byte names for registers when they appear in <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>
    and the 4-byte names anywhere else.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your compiler can now handle relational and logical operators. In this chapter,
    you added conditional jumps to TACKY to support short-circuiting operators, and
    you learned about several new assembly instructions. You also learned how the
    CPU keeps track of the current instruction and records the results of comparisons.
    The new TACKY and assembly instructions you introduced in this chapter will eventually
    help you implement complex control structures like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and loops. But first, you’ll implement one of the most essential features
    of C: variables!'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more in-depth discussions of undefined behavior, see these blog posts:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: “A Guide to Undefined Behavior in C and C++, Part 1” by John Regehr is a good
    overview of what undefined behavior means in the C standard and how it impacts
    compiler design (*[https://<wbr>blog<wbr>.regehr<wbr>.org<wbr>/archives<wbr>/213](https://blog.regehr.org/archives/213)*).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “With Undefined Behavior, Anything Is Possible” by Raph Levien explores some
    sources of undefined behavior in C and the history of how it got into the standard
    to begin with (*[https://<wbr>raphlinus<wbr>.github<wbr>.io<wbr>/programming<wbr>/rust<wbr>/2018<wbr>/08<wbr>/17<wbr>/undefined<wbr>-behavior<wbr>.html](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html)*).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
