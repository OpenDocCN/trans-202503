- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TOOLS FOR ANALYZING COMPILER OUTPUT**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to write great code, you must be able to recognize the difference
    between programming language sequences that do their job more or less adequately
    and those that are great. In the context of our discussion, great code sequences
    use fewer instructions, fewer machine cycles, or less memory than mediocre code
    sequences. If you’re working in assembly language, the CPU manufacturers’ data
    sheets and a bit of experimentation are all it takes to determine which code sequences
    are great and which are not. When working with HLLs, however, you need some way
    of mapping the high-level language statements in a program to the corresponding
    machine code, so that you can determine the quality of those HLL statements. In
    this chapter, we’ll discuss how to:'
  prefs: []
  type: TYPE_NORMAL
- en: View and analyze a compiler’s machine language output so you can use that information
    to write better HLL code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tell certain compilers to produce a human-readable assembly language output
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze binary object output files using tools such as `dumpbin` and `objdump`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a disassembler to examine the machine code output a compiler produces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a debugger to analyze compiler output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare two different assembly language listings for the same HLL source file
    to determine which version is better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing compiler output is one of the principal skills you’ll need in order
    to distinguish great machine code from merely sufficient machine code. To analyze
    compiler output, you’ll need to learn a couple of things. First, you’ll need to
    learn enough assembly language programming so that you can effectively read compiler
    output.^([1](footnotes.xhtml#ch5fn1)) Second, you’ll need to learn how to tell
    a compiler (or some other tool) to produce human-readable assembly language output.
    Finally, you’ll have to learn how to correlate the assembly instructions with
    the HLL code. [Chapters 3](ch03.xhtml#ch03) and [4](ch04.xhtml#ch04) gave you
    the foundation you need to read some basic assembly code. This chapter discusses
    how to translate compiler output into a human-readable form. And the rest of this
    book deals with analyzing that assembly code so you can generate better machine
    code by wisely choosing your HLL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with some background on compiler output and things to keep in mind
    for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1 Background**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Chapter 4](ch04.xhtml#ch04) discussed, most compilers available today emit
    object code output that a linker program reads and processes in order to produce
    an executable program. Because the object code file generally consists of binary
    data that is not human-readable, many compilers also provide an option to produce
    an assembly language version of the output code. By activating this option, you
    can analyze the compiler’s output and, if necessary, refine your HLL source code
    accordingly. Indeed, with a specific compiler and a thorough knowledge of its
    optimizations, you can write HLL source code that compiles to machine code that’s
    almost as good as the best handwritten assembly language code. Although you can’t
    expect such optimizations to work with every compiler, this trick enables you
    to write good code with one compiler that will still be able to run (though possibly
    less efficiently) on other processors. This is an excellent solution for code
    that needs to run as efficiently as possible on a certain class of machines but
    still needs to run on other CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep in mind that examining compiler output may lead you to implement nonportable
    optimizations. That is, when you examine your compiler’s output you might decide
    to modify your HLL source code to produce better output; however, those optimizations
    might not carry over to a different compiler.*'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to emit assembly language output is compiler specific. Some compilers
    do so by default. GCC, for example, always emits an assembly language file (though
    it typically deletes that file after the compilation). Most compilers, however,
    must be explicitly told to produce an assembly language listing. Some compilers
    produce an assembly listing that can be run through an assembler to produce object
    code. Some compilers may only produce assembly annotation in a listing file, and
    that “assembly code” is not syntax-compatible with any existing assembler. For
    your purposes, it doesn’t matter if a real-world assembler is capable of processing
    the compiler’s assembly output; you’re only going to read that output to determine
    how to tweak the HLL code to produce better object code.
  prefs: []
  type: TYPE_NORMAL
- en: For those compilers that can produce assembly language output, the readability
    of the assembly code varies considerably. Some compilers insert the original HLL
    source code into the assembly output as comments, which makes it easy to correlate
    the assembly instructions with the HLL code. Other compilers (such as GCC) emit
    pure assembly language code; so, unless you’re well versed in the particular CPU’s
    assembly language, analyzing the output can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that may affect the readability of the compiler output is the
    optimization level you choose. If you disable all optimizations, it is often easier
    to determine which assembly instructions correspond to the HLL statements. Unfortunately,
    with the optimizations turned off, most compilers generate low-quality code. If
    the purpose of viewing assembly output from a compiler is to choose better HLL
    sequences, then you must specify the same optimization level that you will use
    for the production version of your application. You should never tweak your high-level
    code to produce better assembly code at one optimization level and then change
    the optimization level for your production code. If you do, you may wind up doing
    extra work that the optimizer would normally do for you. Worse, those manual optimizations
    could actually prevent the compiler from doing a decent job when you increase
    its optimization level.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify a higher level of optimization for a compiler, the compiler
    will often move code around in the assembly output file, eliminate code entirely,
    and do other code transformations that obfuscate the correspondence between the
    high-level code and the assembly output. Still, with a bit of practice, you can
    determine which machine instructions correspond to a given statement in the HLL
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2 Telling a Compiler to Produce Assembly Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How you tell a compiler to emit an assembly language output file is specific
    to the compiler. For that information, you’ll need to consult the documentation
    for your particular compiler. This section will look at two commonly used C/C++
    compilers: GCC and Microsoft’s Visual C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.1 Assembly Output from GNU Compilers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To emit assembly output with the GCC compiler, you specify the `-S` option
    on the command line when invoking the compiler. Here is a sample command line
    for GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When supplied to GCC, the `-S` option doesn’t actually tell the compiler to
    produce an assembly output file. GCC *always* produces an assembly output file.
    The `-S` simply tells GCC to stop all processing after it has produced an assembly
    file. GCC will produce an assembly output file whose root name is the same as
    the original C file (*t1* in these examples) with a *.s* suffix (during normal
    compilation, GCC deletes the *.s* file after assembling it).
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.2 Assembly Output from Visual C++**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Visual C++ compiler (VC++) uses the -`FA` command-line option to specify
    MASM-compatible assembly language output. The following is a typical command line
    to VC++ to tell it to produce an assembly listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**5.2.3 Example Assembly Language Output**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example of producing assembly language output from a compiler, consider
    the following C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following subsections provide the compiler output for Visual C++ and GCC
    from this code sequence in order to highlight the differences between their respective
    assembly language listings.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.3.1 Visual C++ Assembly Language Output**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compiling this file with VC++ using the command line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: produces the following (MASM) assembly language output.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The exact meaning of each assembly language statement appearing in this output
    isn’t important—yet! What’s important is seeing the difference between the syntax
    in this listing and the listings for Visual C++ and Gas that appear in the following
    sections.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**5.2.3.2 GCC Assembly Language Output (PowerPC)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Like Visual C++, GCC doesn’t insert the C source code into the assembly output
    file. In GCC’s case, it’s somewhat understandable: producing assembly output is
    something it always does (rather than something it does because of a user request).
    By not inserting the C source code into the output file, GCC can cut down compilation
    times by a small amount (because the compiler won’t have to write the C source
    code data and the assembler won’t have to read this data). Here’s the output of
    GCC for a PowerPC processor when using the command line `gcc -O1 -S t1.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output of GCC is quite sparse. Of course, as this is PowerPC
    assembly language, it’s not really practical to compare this assembly output to
    the 80x86 output from the Visual C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.3.3 GCC Assembly Language Output (80x86)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code provides the GCC compilation to x86-64 assembly code for
    the *t1.c* source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example should help demonstrate that the massive amount of code that GCC
    emitted for the PowerPC is more a function of the machine’s architecture than
    of the compiler. If you compare this to the code that other compilers emit, you’ll
    discover that it is roughly equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.3.4 GCC Assembly Language Output (ARMv7)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code provides the GCC compilation to ARMv6 assembly code for
    the *t1.c* source file as compiled on a Raspberry Pi (running 32-bit Raspian):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `@` denotes a comment in this source code; Gas ignores everything
    from the `@` to the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.3.5 Swift Assembly Language Output (x86-64)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Given a Swift source file *main.swift*, you can request an assembly language
    output file from the macOS Swift compiler using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the *result.asm* output assembly language file. Consider
    the following Swift source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this with the previous command line produces a rather long assembly
    language output file; here is the main procedure from that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Swift doesn’t generate very optimal code compared to C++. In
    fact, hundreds of additional lines of code have been omitted from this listing
    to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2.4 Assembly Output Analysis**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unless you’re well versed in assembly language programming, analyzing assembly
    output can be tricky. If you’re not an assembly language programmer, about the
    best you can do is count instructions and assume that if a compiler option (or
    reorganization of your HLL source code) produces fewer instructions, the result
    is better. In reality, this assumption isn’t always correct. Some machine instructions
    (particularly on CISC processors such as the 80x86) require substantially more
    time to execute than others. A sequence of three or more instructions on a processor
    such as the 80x86 could execute faster than a single instruction that does the
    same operation. Fortunately, a compiler is not likely to produce both of these
    sequences based on a reorganization of your high-level source code. Therefore,
    you don’t usually have to worry about such issues when examining the assembly
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some compilers will produce two different sequences if you change
    the optimization level. This is because certain optimization settings tell the
    compiler to favor shorter programs, while other optimization settings tell the
    compiler to favor faster execution. The optimization setting that favors smaller
    executable files will probably pick the single instruction over the three instructions
    that do the same work (assuming those three instructions compile into more code);
    the optimization setting that favors speed will probably pick the faster instruction
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses various C/C++ compilers in its examples, but you should remember
    that compilers for other languages also provide the ability to emit assembly code.
    You’ll have to check your compiler’s documentation to see if this is possible
    and what options you can use to produce the assembly output. Some compilers (Visual
    C++, for example) provide an integrated development environment (IDE) that you
    may use in place of a command-line tool. Even though most compilers that work
    through an IDE also work from the command line, you can usually specify assembly
    output from within an IDE as well as from the command line. Once again, see your
    compiler vendor’s documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3 Using Object Code Utilities to Analyze Compiler Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many compilers provide an option to emit assembly language rather than
    object code, a large number of compilers do not; they can only emit binary machine
    code to an object code file. Analyzing this kind of compiler output will be a
    bit more work, and it’s going to require some specialized tools. If your compiler
    emits object code files (such as PE/COFF or ELF files) to be fed into a linker,
    you can probably find an “object code dump” utility that will prove quite useful
    for analyzing the compiler’s output. For example, Microsoft provides the *dumpbin.exe*
    program, and the FSF/GNU *dumpobj* program has similar capabilities for ELF files
    under Linux and other operating systems. In the following subsections, we’ll take
    a look at using these two tools when analyzing compiler output.
  prefs: []
  type: TYPE_NORMAL
- en: One nice feature of working with object files is that they usually contain symbolic
    information. That is, in addition to binary machine code, the object file contains
    strings specifying identifier names that appear in the source file (such information
    does not normally appear in an executable file). Object code utilities can usually
    display these symbolic names within the machine instructions that reference the
    memory locations associated with these symbols. Though these object code utilities
    can’t automatically correlate the HLL source code with the machine code, having
    the symbolic information available can help you when you’re studying their output,
    because it’s much easier to read names like `JumpTable` than memory addresses
    like `$401_1000`.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1 The Microsoft dumpbin.exe Utility**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Microsoft’s `dumpbin` command-line tool allows you to examine the contents
    of a Microsoft PE/COFF file.^([2](footnotes.xhtml#ch5fn2)) You run the program
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename parameter is the name of the *.obj* file that you wish to examine,
    and the options parameter is a set of optional command-line arguments that specify
    the type of information you want to display. These options each begin with a forward
    slash (`/`). We’ll take a look at each of the possible options in a moment. First,
    here is a listing of the possible objects (obtained via the `/?` command-line
    option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Though the primary use of `dumpbin` is to look at the object code a compiler
    produces, it also displays a considerable amount of interesting information about
    a PE/COFF file. For more information on the meaning of many of the `dumpbin` command-line
    options, review “Object File Formats” on [page 71](ch04.xhtml#page_71) or “Executable
    File Formats” on [page 80](ch04.xhtml#page_80).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following subsections describe several of the possible `dumpbin` command-line
    options and provide example output for a simple “Hello World” program written
    in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**5.3.1.1 /all**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `/all` command-line option instructs `dumpbin` to display all the information
    it can except for a disassembly of the code found in the object file. The problem
    with this approach is that an *.exe* file contains all the routines from the language’s
    standard library (such as the C Standard Library) that the linker has merged into
    the application. When analyzing compiler output in order to improve your application’s
    code, wading through all this extra information about code outside your program
    can be tedious. Fortunately, there’s an easy way to pare down the unnecessary
    information—run `dumpbin` on your object (*.obj*) files rather than your executable
    (*.exe*) files. Here is the (shortened) output that `dumpbin` produces for the
    “Hello World” example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example deletes the bulk of the output from this command (to spare you
    having to read a dozen or so extra pages). Try executing the `/all` command yourself
    to see the quantity of output you get. In general, though, use this option with
    care.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.2 /disasm**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `/disasm` command-line option is the one of greatest interest to us. It
    produces a disassembled listing of the object file. As with the `/all` option,
    you shouldn’t try to disassemble an *.exe* file using `dumpbin`. The disassembled
    listing you’ll get will be quite long, and the vast majority of the code will
    probably be the listings of all the library routines your application calls. For
    example, the simple “Hello World” application generates over 5,000 lines of disassembled
    code. All but a small handful of those statements correspond to library routines.
    Wading through that amount of code will prove overwhelming to most people.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you disassemble the *hw.obj* file rather than the executable file,
    here’s the output you typically get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look closely at this disassembled code, you’ll find the major problem
    with disassembling object files rather than executable files—most addresses in
    the code are relocatable addresses, which appear as `$00000000` in the object
    code listing. As a result, you’ll probably have a hard time figuring out what
    the various assembly statements are doing. For example, in the *hw.obj*’s disassembled
    listing you see the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lea` instruction opcode is the 3-byte sequence `48 8D 0D` (which includes
    an REX opcode prefix byte). The address of the `"Hello World"` string is not `00
    00 00 00` (the 4 bytes following the opcode); instead, it is a relocatable address
    that the linker/system fills in later. If you run `dumpbin` on *hw.obj* with the
    `/all` command-line option, you’ll notice that this file has two relocation entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Offset column tells you the byte offset into the file where the relocations
    are to be applied. In the preceding disassembly, note that the `lea` instruction
    starts at offset `$d`, so the actual displacement is at offset `$10`. Similarly,
    the `call` instruction begins at offset `$14`, so the address of the actual routine
    that needs to be patched is 1 byte later, at offset `$15`. From the relocation
    information that `dumpbin` outputs, you can discern the symbols associated with
    these relocations. (`$SG4247` is an internal symbol that the C compiler generates
    for the `"Hello World"` string. And `printf` is, obviously, the name associated
    with the C `printf()` function.)
  prefs: []
  type: TYPE_NORMAL
- en: Cross-referencing every call and memory reference against the relocation list
    may seem like a pain, but at least you get symbolic names when you do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the first few lines of the disassembled code when you apply the `/disasm`
    option to the *hw.exe* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the linker has filled in the addresses (relative to the load address
    for the file) of the offset `$SG4247` and `print` labels. This may seem somewhat
    convenient; however, note that these labels (especially the `printf` label) are
    no longer present in the file. When you are reading the disassembled output, the
    absence of these labels can make it very difficult to figure out which machine
    instructions correspond to HLL statements. This is yet another reason why you
    should use object files rather than executable files when running `dumpbin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think it’s going to be a major pain to read the disassembled output
    of the `dumpbin` utility, don’t worry: for optimization purposes, you’re often
    more interested in the code differences between two versions of an HLL program
    than in figuring out what each machine instruction does. Therefore, you can easily
    determine which machine instructions are affected by a change in your code by
    running `dumpbin` on two versions of your object files (one before the change
    to the HLL code and one created afterward). For example, consider the following
    modification to the “Hello World” program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the disassembly output that `dumpbin` produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By comparing this output with the previous assembly output (either manually
    or by running one of the programs based on the Unix `diff` utility), you can see
    the effect of the change to your HLL source code on the emitted machine code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The section “Comparing Output from Two Compilations” on [page 137](ch05.xhtml#page_137)
    discusses the merits of both comparison methods (manual and `diff`-based).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.3 /headers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `/headers` option instructs `dumpbin` to display the COFF header files
    and section header files. The `/all` option also prints this information, but
    `/header` displays *only* the header information without all the other output.
    Here’s the sample output for the “Hello World” executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Review the discussion of object file formats in [Chapter 4](ch04.xhtml#ch04)
    (see “Object File Formats” on [page 71](ch04.xhtml#page_71)) to make sense of
    the information that `dumpbin` outputs when you specify the `/headers` option.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.4 /imports**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `/imports` option lists all of the dynamic-link symbols that the operating
    system must supply when the program loads into memory. This information isn’t
    particularly useful for analyzing code emitted for HLL statements, so this chapter
    won’t mention this option further.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.5 /relocations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `/relocations` option displays all the relocation objects in the file. This
    command is quite useful because it provides a list of all the symbols for the
    program and the offsets of their use in the disassembly listing. Of course, the
    `/all` option also presents this information, but `/relocations` provides just
    this information without anything else.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.6 Other dumpbin.exe Command-Line Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `dumpbin` utility supports many more command-line options beyond those this
    chapter describes. As noted earlier, you can get a list of all possible options
    by specifying `/?` on the command line when running `dumpbin`. You can also read
    more online at *[https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/](https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.2 The FSF/GNU objdump Utility**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re running the GNU toolset on your operating system (for example, under
    Linux, Mac, or BSD), then you can use the FSF/GNU `objdump` utility to examine
    the object files produced by GCC and other GNU-compliant tools. Here are the command-line
    options it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the following *m.hla* source code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is some sample output produced on the 80x86, created with the Linux command
    line `objdump -S m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These listings are only a fragment of the total code (which is why certain labels
    are absent). Nevertheless, you can see how the `objdump` utility can be useful
    for analyzing compiler output by allowing you to disassemble the object code for
    a certain code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `dumpbin`, `objdump` can display additional information beyond the machine
    code disassembly that may prove useful when you’re analyzing compiler output.
    For most purposes, however, the GCC `-S` (assembly output) option is the most
    useful. Here’s an example of a disassembly of some C code using the `objdump`
    utility. First, the original C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the Gas output (x86-64) from GCC for the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here’s the `objdump` disassembly of the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the assembly code output is somewhat easier to read than `objdump`’s
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.4 Using a Disassembler to Analyze Compiler Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although using an object code “dump” tool is one way to analyze compiler output,
    another possible solution is to run a *disassembler* on the executable file. A
    disassembler is a utility that translates binary machine code into human-readable
    assembly language statements (“human-readable” is debatable, but that’s the idea,
    anyway). As such, it’s another tool you can use to analyze compiler output.
  prefs: []
  type: TYPE_NORMAL
- en: There is a subtle, but important, difference between an object code dump utility
    (which contains a simple disassembler) and a sophisticated disassembler program.
    Object code dump utilities are automatic, but they can get easily confused if
    the object code contains tricky constructs (such as buried data in the instruction
    stream). An *automatic disassembler* is very convenient to use, requiring little
    expertise on the user’s part, but rarely disassembles the machine code correctly.
    A full-blown *interactive disassembler*, on the other hand, requires more training
    to use properly, but is capable of disassembling tricky machine code sequences
    with a little help from its user. Therefore, decent disassemblers will work in
    situations where a simplistic object code dump utility will fail. Fortunately,
    most compilers do not always emit the kind of tricky code that confuses object
    code dump utilities, so you can sometimes get by without having to learn how to
    use a full-blown disassembler program. Nevertheless, having a disassembler handy
    can be useful in situations where a simplistic approach doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Several “free” disassemblers are available. The one we’ll cover in this chapter
    is IDA7\. IDA is the freeware version of IDA Pro, a very capable and powerful
    commercial disassembler system (*[https://www.hex-rays.com/products/ida/](https://www.hex-rays.com/products/ida/)*).
  prefs: []
  type: TYPE_NORMAL
- en: When you first run IDA, it opens the window shown in [Figure 5-1](ch05.xhtml#ch5fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: IDA opening window*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **New** button and type in the name of the *.exe* or *.obj* file you
    wish to disassemble. Once you enter an executable filename, IDA brings up the
    Format dialog shown in [Figure 5-2](ch05.xhtml#ch5fig2). In this dialog, you can
    select the binary file type (for example, PE/COFF, PE64 executable file, or pure
    binary) and the options to use when disassembling the file. IDA does a good job
    of choosing reasonable default values for these options, so most of the time you’ll
    just accept the defaults unless you’re working with some weird binary files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: IDA executable file format dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, IDA will figure out the appropriate file type information for a
    standard disassembly, then do an “automatic” disassembly of the object code file.
    To produce an assembly language output file, click **OK**. Here are the first
    few lines of the disassembly of the *t1.c* file given in “Example Assembly Language
    Output” on [page 102](ch05.xhtml#page_102):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: IDA is an *interactive* disassembler. This means that it provides lots of complex
    features that you can use to guide the disassembly to produce a more reasonable
    assembly language output file. However, its “automatic” mode of operation is generally
    all you’ll need in order to examine compiler output files to assess their quality.
    For more details on IDA (freeware) or IDA Pro, see its documentation (*[https://www.hex-rays.com/products/ida/support/](https://www.hex-rays.com/products/ida/support/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**5.5 Using the Java Bytecode Disassembler to Analyze Java Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most Java compilers (particularly those from Oracle, Inc.) do not generate
    machine code directly. Instead, they generate Java bytecode (JBC), which computer
    systems then execute using a JBC interpreter. To improve performance, some Java
    interpreters run a just-in-time (JIT) compiler that translates JBC into native
    machine code during interpretation to improve performance (though the result is
    rarely as good as the machine code an optimizing compiler generates). Unfortunately,
    because the Java interpreter does this translation at runtime, it is difficult
    to analyze the machine code output from the Java compiler. It is, however, possible
    to analyze the JBC it produces. This can give you a better picture of what the
    compiler is doing with your Java code than simply guessing. Consider the following
    (relatively trivial) Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, you can compile this program (*Welcome.java*) using a command line
    of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command produces the *Welcome.class* JBC file. You can use the following
    command to disassemble this file (to the standard output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that you do not include the *.class* file extension on the command line;
    the `javap` command automatically supplies it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `javap` command produces a bytecode disassembly listing similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can find documentation for the JBC mnemonics and the `javap` Java class
    file disassembler on [Oracle.com](http://Oracle.com) (search the site for “javap”
    and “Java bytecode disassembler”). Also, the online chapters (specifically, Appendix
    D) accompanying this book discuss the Java VM bytecode assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.6 Using the IL Disassembler to Analyze Microsoft C# and Visual Basic Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft’s .NET language compilers do not directly emit native machine code.
    Instead, they emit a special IL (intermediate language) code. This is quite similar,
    in principle, to Java bytecode or UCSD p-machine code. The .NET runtime system
    will compile IL executable files and run them using a JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft C# compiler is a good example of a .NET language that works in
    this fashion. Compiling a simple C# program will produce a Microsoft *.exe* file
    that you can examine with `dumpbin`. Unfortunately, you can’t use `dumpbin` to
    look at the object code (IL or otherwise). Fortunately, Microsoft supplies a utility,
    *ildasm.exe*, that you can use to disassemble the IL byte/assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following small C# example program (*Class1.cs*, a slight tweak
    of the ubiquitous “Hello World!” program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Typing `ildasm class1.exe` from a command prompt brings up the window shown
    in [Figure 5-3](ch05.xhtml#ch5fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: IL disassembler window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the code disassembly, double-click the S icon (next to the Main entry).
    This opens a window containing the following text (comments added for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can use the IL disassembler program for any .NET language (such as Visual
    Basic and F#). See Appendix E online for details on Microsoft’s IL assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7 Using a Debugger to Analyze Compiler Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option you can use to analyze compiler output is a debugger program,
    which usually incorporates a disassembler that you can use to view machine instructions.
    Depending on the debugger you use, viewing your compiler output this way can be
    either a headache or a breeze. Typically, if you use a stand-alone debugger, you’ll
    find that it takes considerably more effort to analyze your compiler output than
    if you use a debugger built into a compiler’s IDE. This section looks at both
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7.1 Using an IDE’s Debugger**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Microsoft Visual C++ environment provides excellent tools for analyzing
    the code produced by a compilation (of course, the compiler also produces assembly
    output, but we’ll ignore that fact here). To view the output using the Visual
    Studio debugger, first compile your C/C++ program to an executable file and then
    select **Debug** ▸ **Step Into** from the Visual Studio Debug menu. When the program
    pauses execution, select **Debug** ▸ **Windows** ▸ **Disassembly** from the debug
    menu. For the *t1.c* program (see “Example Assembly Language Output” on [page
    102](ch05.xhtml#page_102)), you should see a disassembly like the following (assuming
    you’re producing 32-bit code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Of course, because Microsoft’s Visual C++ package is already capable of outputting
    an assembly language file during compilation, using the Visual Studio integrated
    debugger in this manner isn’t necessary.^([3](footnotes.xhtml#ch5fn3)) However,
    some compilers do not provide assembly output, and debugger output may be the
    easiest way to view the machine code the compiler produces. For example, Embarcadero’s
    Delphi compiler does not provide an option to produce assembly language output.
    Given the massive amount of class library code that Delphi links into an application,
    attempting to view the code for a small section of your program by using a disassembler
    would be like trying to find a needle in a haystack. A better solution is to use
    the debugger built into the Delphi environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7.2 Using a Stand-Alone Debugger**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your compiler doesn’t provide its own debugger as part of an IDE, another
    alternative is to use a separate debugger such as OllyDbg, DDD, or GDB to disassemble
    your compiler’s output. Simply load the executable file into the debugger for
    normal debugging operations.
  prefs: []
  type: TYPE_NORMAL
- en: Most debuggers that are not associated with a particular programming language
    are machine-level debuggers that disassemble the binary machine code into machine
    instructions for viewing during the debugging operation. One problem with using
    machine-level debuggers is that locating a particular section of code to disassemble
    can be difficult. Remember, when you load the entire executable file into a debugger,
    you load in all the statically linked library routines and other runtime support
    code that doesn’t normally appear in the application’s source file. Searching
    through all this extraneous code to find out how the compiler translates a particular
    sequence of statements to machine code can be time-consuming. Some serious code
    sleuthing may be necessary. Fortunately, most linkers collect all the library
    routines together and place them either at the beginning or end of the executable
    file. Therefore, that’s generally also where you’ll find the code associated with
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debuggers come in one of three different flavors: pure machine-level debuggers,
    symbolic debuggers, and source-level debuggers. Symbolic debuggers and source-level
    debuggers require executable files to contain special debugging information and,
    therefore, the compiler must specifically include this extra information.'
  prefs: []
  type: TYPE_NORMAL
- en: Pure machine-level debuggers have no access to the original source code or symbols
    in the application. A pure machine-level debugger simply disassembles the application’s
    machine code and displays the listing using literal numeric constants and machine
    addresses. Reading through such code is difficult, but if you understand how compilers
    generate code for the HLL statements (as this book will teach you), then locating
    the machine code is easier. Nevertheless, without any symbolic information to
    provide a “root point” in the code, analysis can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic debuggers use special symbol table information found in the executable
    file (or a separate debugging file, in some instances) to associate labels with
    functions and, possibly, variable names in your source file. This feature makes
    locating sections of code within the disassembly listing much easier. When symbolic
    labels identify calls to functions, it’s much easier to see the correspondence
    between the disassembled code and your original HLL source code. One thing to
    keep in mind, however, is that symbolic information is available only if the application
    was compiled with debugging mode enabled. Check your compiler’s documentation
    to determine how to activate this feature for use with your debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Source-level debuggers actually display the original source code associated
    with the file the debugger is processing. In order to see the machine code the
    compiler produced, you often have to activate a special machine-level view of
    the program. As with symbolic debuggers, your compiler must produce special executable
    files (or auxiliary files) containing debug information that a source-level debugger
    can use. Clearly, source-level debuggers are much easier to work with because
    they show the correspondence between the original HLL source code and the disassembled
    machine code.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.8 Comparing Output from Two Compilations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are an expert assembly language programmer and you’re well versed in
    compiler design, it should be pretty easy for you to determine what changes you’ll
    need to make to your HLL source code to improve the quality of the output machine
    code. However, most programmers (especially those who do not have considerable
    experience studying compiler output) can’t just read a compiler’s assembly language
    output. They have to compare the two sets of outputs (before and after a change)
    to determine which code is better. After all, not every change you make to your
    HLL source files will result in better code. Some changes will leave the machine
    code unaffected (in which case, you should use the more readable and maintainable
    version of the HLL source code). In other cases, you could actually make the output
    machine code worse. Therefore, unless you know exactly what a compiler is going
    to do when you make changes to your HLL source file, you should do a before-and-after
    comparison of the compiler’s output machine code before accepting any modifications
    you make.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.8.1 Before-and-After Comparisons with diff**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, the first reaction from any experienced software developer is, “Well,
    if we have to compare files, we’ll just use `diff`!” As it turns out, a typical
    `diff` (compute file differences) program will be useful for certain purposes,
    but it won’t be universally applicable when you’re comparing two different output
    files from a compiler. The problem with a program like `diff` is that it works
    great when there are only a few differences between two files, but it’s not so
    useful when the files are wildly different. For example, consider the following
    C program (*t.c*) and two different outputs produced by the Microsoft VC++ compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the assembly language output MSVC++ produces when using the command
    line `cl /Fa t.c` (that is, when compiling without optimization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the assembly listing we get when we compile the C program with the command
    line `cl /Ox /Fa t.c` (`/Ox` enables maximum optimization for speed in Visual
    C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It doesn’t take a very sharp eye to notice that the two assembly language output
    files are radically different. Running these two files through `diff` simply produces
    a lot of noise; the output from `diff` is more difficult to interpret than manually
    comparing the two assembly language output files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A differencing program like `diff` (or better yet, the differencing facility
    built into many advanced programming editors) works best for comparing two different
    outputs for a given HLL source file to which you’ve made a small change. In the
    current example, had we changed the statement `case 1000:` to `case 1001:`, then
    a `diff` of the resulting assembly file against the original produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As long as you’re comfortable reading `diff` output, this isn’t too bad. However,
    a better solution is to use some commercially available file comparison programs.
    Two excellent options are Beyond Compare (*[https://www.scootersoftware.com/](https://www.scootersoftware.com/)*)
    and Araxis Merge (*[https://www.araxis.com/merge/](https://www.araxis.com/merge/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, another way to compare compiler output is manually. Set two listings
    side by side (either on paper or on your monitor) and start analyzing them. In
    the current C example, if we compare the two different outputs from the C compiler
    (without optimization and with the `/Ox` optimization option), we’ll discover
    that both versions use a binary search algorithm to compare the `switch` value
    against a list of widely varying constants. The main difference between the optimized
    and unoptimized versions has to do with code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly compare two assembly listings that a compiler produces,
    you’ll need to learn how to interpret the machine language output from your compilers
    and connect certain assembly language sequences with the statements in your HLL
    code. That’s the purpose of many of the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.9 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your compiler’s manual is the first place to look when you’re trying to figure
    out how to view the machine code the compiler produces. Many compilers produce
    assembly language output as an option, and that’s the best way to view code output.
    If your compiler does not provide this option, a debugging tool built into the
    compiler’s IDE (if available) is another good choice. See the documentation for
    your IDE or compiler for details.
  prefs: []
  type: TYPE_NORMAL
- en: Tools like `objdump` and `dumpbin` are also useful for examining compiler output.
    Check the Microsoft, FSF/GNU, or Apple LLVM documentation for details on using
    these programs. If you decide to use an external debugger, such as OllyDbg or
    GDB, check out the software’s user documentation, or visit the author’s support
    web page (for example, *[http://www.ollydbg.de/](http://www.ollydbg.de/)* for
    the OllyDbg debugger).
  prefs: []
  type: TYPE_NORMAL
