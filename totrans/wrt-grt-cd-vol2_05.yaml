- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**TOOLS FOR ANALYZING COMPILER OUTPUT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析编译器输出的工具**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'In order to write great code, you must be able to recognize the difference
    between programming language sequences that do their job more or less adequately
    and those that are great. In the context of our discussion, great code sequences
    use fewer instructions, fewer machine cycles, or less memory than mediocre code
    sequences. If you’re working in assembly language, the CPU manufacturers’ data
    sheets and a bit of experimentation are all it takes to determine which code sequences
    are great and which are not. When working with HLLs, however, you need some way
    of mapping the high-level language statements in a program to the corresponding
    machine code, so that you can determine the quality of those HLL statements. In
    this chapter, we’ll discuss how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写优秀的代码，你必须能够识别编程语言序列之间的差异，即那些完成工作相对充分的序列与那些优秀的序列之间的差异。在我们讨论的背景下，优秀的代码序列比平庸的代码序列使用更少的指令、更少的机器周期或更少的内存。如果你在汇编语言中工作，CPU制造商的技术手册和一些实验就足以确定哪些代码序列是优秀的，哪些不是。然而，在使用高级语言时，你需要某种方式将程序中的高级语言语句映射到相应的机器代码，以便你能够确定这些高级语言语句的质量。在本章中，我们将讨论如何：
- en: View and analyze a compiler’s machine language output so you can use that information
    to write better HLL code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看并分析编译器的机器语言输出，以便你可以利用这些信息编写更好的高级语言代码
- en: Tell certain compilers to produce a human-readable assembly language output
    file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉某些编译器生成易于人类阅读的汇编语言输出文件
- en: Analyze binary object output files using tools such as `dumpbin` and `objdump`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dumpbin`和`objdump`等工具分析二进制目标输出文件
- en: Use a disassembler to examine the machine code output a compiler produces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反汇编器检查编译器生成的机器代码输出
- en: Use a debugger to analyze compiler output
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器分析编译器输出
- en: Compare two different assembly language listings for the same HLL source file
    to determine which version is better
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个不同的汇编语言清单，以确定哪个版本更好
- en: Analyzing compiler output is one of the principal skills you’ll need in order
    to distinguish great machine code from merely sufficient machine code. To analyze
    compiler output, you’ll need to learn a couple of things. First, you’ll need to
    learn enough assembly language programming so that you can effectively read compiler
    output.^([1](footnotes.xhtml#ch5fn1)) Second, you’ll need to learn how to tell
    a compiler (or some other tool) to produce human-readable assembly language output.
    Finally, you’ll have to learn how to correlate the assembly instructions with
    the HLL code. [Chapters 3](ch03.xhtml#ch03) and [4](ch04.xhtml#ch04) gave you
    the foundation you need to read some basic assembly code. This chapter discusses
    how to translate compiler output into a human-readable form. And the rest of this
    book deals with analyzing that assembly code so you can generate better machine
    code by wisely choosing your HLL statements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分析编译器输出是你区分优秀机器代码与仅仅足够的机器代码所需的主要技能之一。要分析编译器输出，你需要学习几件事情。首先，你需要学习足够的汇编语言编程，以便能够有效地阅读编译器输出。^([1](footnotes.xhtml#ch5fn1))
    其次，你需要学习如何告诉编译器（或其他工具）生成易于人类阅读的汇编语言输出。最后，你必须学会如何将汇编指令与高级语言代码进行关联。[第3章](ch03.xhtml#ch03)和[第4章](ch04.xhtml#ch04)为你提供了阅读基本汇编代码所需的基础。本章讨论如何将编译器输出转化为人类可读的形式。本书其余部分则讲解如何分析这些汇编代码，从而通过明智选择高级语言语句生成更好的机器代码。
- en: Let’s begin with some background on compiler output and things to keep in mind
    for optimization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些编译器输出的背景和优化时需要注意的事项开始。
- en: '**5.1 Background**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**5.1 背景**'
- en: As [Chapter 4](ch04.xhtml#ch04) discussed, most compilers available today emit
    object code output that a linker program reads and processes in order to produce
    an executable program. Because the object code file generally consists of binary
    data that is not human-readable, many compilers also provide an option to produce
    an assembly language version of the output code. By activating this option, you
    can analyze the compiler’s output and, if necessary, refine your HLL source code
    accordingly. Indeed, with a specific compiler and a thorough knowledge of its
    optimizations, you can write HLL source code that compiles to machine code that’s
    almost as good as the best handwritten assembly language code. Although you can’t
    expect such optimizations to work with every compiler, this trick enables you
    to write good code with one compiler that will still be able to run (though possibly
    less efficiently) on other processors. This is an excellent solution for code
    that needs to run as efficiently as possible on a certain class of machines but
    still needs to run on other CPUs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第4章](ch04.xhtml#ch04)所讨论的，大多数现有编译器生成目标代码输出，链接程序读取并处理这些目标代码以生成可执行程序。由于目标代码文件通常由不可读的二进制数据组成，因此许多编译器还提供生成汇编语言版本的输出代码的选项。通过启用此选项，你可以分析编译器的输出，并在必要时相应地改进HLL源代码。事实上，使用特定的编译器并对其优化有深入了解时，你可以编写出几乎与最佳手写汇编语言代码一样高效的HLL源代码，经过编译后生成的机器代码几乎达到最佳水平。尽管不能期望这种优化在每个编译器上都能有效，但这种技巧使你能够编写出优秀的代码，在一个编译器上运行良好，并且仍然能够在其他处理器上运行（尽管可能效率较低）。这对于需要在某些特定机器上尽可能高效运行的代码，同时还需要在其他CPU上运行的情况，是一个很好的解决方案。
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep in mind that examining compiler output may lead you to implement nonportable
    optimizations. That is, when you examine your compiler’s output you might decide
    to modify your HLL source code to produce better output; however, those optimizations
    might not carry over to a different compiler.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，检查编译器输出可能会导致你实现不可移植的优化。也就是说，当你检查编译器的输出时，你可能会决定修改HLL源代码以产生更好的输出；然而，这些优化可能不会在不同的编译器上生效。*'
- en: The ability to emit assembly language output is compiler specific. Some compilers
    do so by default. GCC, for example, always emits an assembly language file (though
    it typically deletes that file after the compilation). Most compilers, however,
    must be explicitly told to produce an assembly language listing. Some compilers
    produce an assembly listing that can be run through an assembler to produce object
    code. Some compilers may only produce assembly annotation in a listing file, and
    that “assembly code” is not syntax-compatible with any existing assembler. For
    your purposes, it doesn’t matter if a real-world assembler is capable of processing
    the compiler’s assembly output; you’re only going to read that output to determine
    how to tweak the HLL code to produce better object code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生成汇编语言输出的能力是编译器特有的。有些编译器默认就会这样做。例如，GCC总是生成一个汇编语言文件（尽管通常在编译后会删除该文件）。然而，大多数编译器必须显式地告诉它们生成汇编语言清单。有些编译器生成的汇编清单可以通过汇编程序处理生成目标代码。有些编译器可能只在清单文件中生成汇编注释，而该“汇编代码”与现有的任何汇编程序都不兼容。对于你的用途而言，不需要关心现实世界中的汇编程序是否能够处理编译器的汇编输出；你只需要阅读这些输出，以确定如何调整HLL代码，从而生成更好的目标代码。
- en: For those compilers that can produce assembly language output, the readability
    of the assembly code varies considerably. Some compilers insert the original HLL
    source code into the assembly output as comments, which makes it easy to correlate
    the assembly instructions with the HLL code. Other compilers (such as GCC) emit
    pure assembly language code; so, unless you’re well versed in the particular CPU’s
    assembly language, analyzing the output can be difficult.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些能够生成汇编语言输出的编译器，汇编代码的可读性差异很大。有些编译器将原始的高级语言（HLL）源代码作为注释插入到汇编输出中，这使得将汇编指令与HLL代码关联变得容易。其他编译器（如GCC）则输出纯汇编语言代码；因此，除非你对特定CPU的汇编语言非常熟悉，否则分析输出可能会很困难。
- en: Another problem that may affect the readability of the compiler output is the
    optimization level you choose. If you disable all optimizations, it is often easier
    to determine which assembly instructions correspond to the HLL statements. Unfortunately,
    with the optimizations turned off, most compilers generate low-quality code. If
    the purpose of viewing assembly output from a compiler is to choose better HLL
    sequences, then you must specify the same optimization level that you will use
    for the production version of your application. You should never tweak your high-level
    code to produce better assembly code at one optimization level and then change
    the optimization level for your production code. If you do, you may wind up doing
    extra work that the optimizer would normally do for you. Worse, those manual optimizations
    could actually prevent the compiler from doing a decent job when you increase
    its optimization level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响编译器输出可读性的问题是你选择的优化级别。如果你禁用所有优化，通常更容易确定哪些汇编指令对应于高级语言语句。不幸的是，禁用优化后，大多数编译器会生成低质量的代码。如果查看编译器汇编输出的目的是选择更好的高级语言序列，那么你必须指定与生产版本应用程序相同的优化级别。你绝不应该调整高级语言代码，以便在某一优化级别下生成更好的汇编代码，然后再为生产代码更改优化级别。如果你这样做，你可能会做一些优化器通常会为你做的额外工作。更糟糕的是，这些手动优化可能实际上会妨碍编译器在你提高优化级别时完成良好的工作。
- en: When you specify a higher level of optimization for a compiler, the compiler
    will often move code around in the assembly output file, eliminate code entirely,
    and do other code transformations that obfuscate the correspondence between the
    high-level code and the assembly output. Still, with a bit of practice, you can
    determine which machine instructions correspond to a given statement in the HLL
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为编译器指定更高的优化级别时，编译器通常会在汇编输出文件中移动代码，完全消除代码，或进行其他代码转换，这些操作使得高级语言代码与汇编输出之间的对应关系变得模糊。然而，通过一些实践，你仍然可以确定哪些机器指令对应于高级语言代码中的某个语句。
- en: '**5.2 Telling a Compiler to Produce Assembly Output**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**5.2 告诉编译器生成汇编输出**'
- en: 'How you tell a compiler to emit an assembly language output file is specific
    to the compiler. For that information, you’ll need to consult the documentation
    for your particular compiler. This section will look at two commonly used C/C++
    compilers: GCC and Microsoft’s Visual C++.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何告诉编译器生成汇编语言输出文件是特定于编译器的。有关该信息，你需要查阅特定编译器的文档。本节将讨论两个常用的 C/C++ 编译器：GCC 和微软的
    Visual C++。
- en: '**5.2.1 Assembly Output from GNU Compilers**'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**5.2.1 来自 GNU 编译器的汇编输出**'
- en: 'To emit assembly output with the GCC compiler, you specify the `-S` option
    on the command line when invoking the compiler. Here is a sample command line
    for GCC:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GCC 编译器生成汇编输出，你需要在命令行中调用编译器时指定 `-S` 选项。以下是 GCC 的示例命令行：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When supplied to GCC, the `-S` option doesn’t actually tell the compiler to
    produce an assembly output file. GCC *always* produces an assembly output file.
    The `-S` simply tells GCC to stop all processing after it has produced an assembly
    file. GCC will produce an assembly output file whose root name is the same as
    the original C file (*t1* in these examples) with a *.s* suffix (during normal
    compilation, GCC deletes the *.s* file after assembling it).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供给 GCC 时，`-S` 选项实际上并不会告诉编译器生成汇编输出文件。GCC *总是* 会生成汇编输出文件。`-S` 只是告诉 GCC 在生成汇编文件后停止所有处理。GCC
    会生成一个汇编输出文件，其根文件名与原始 C 文件相同（在这些示例中是 *t1*），并带有 *.s* 后缀（在正常编译过程中，GCC 会在汇编后删除 *.s*
    文件）。
- en: '**5.2.2 Assembly Output from Visual C++**'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**5.2.2 来自 Visual C++ 的汇编输出**'
- en: 'The Visual C++ compiler (VC++) uses the -`FA` command-line option to specify
    MASM-compatible assembly language output. The following is a typical command line
    to VC++ to tell it to produce an assembly listing:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 编译器（VC++）使用 -`FA` 命令行选项来指定与 MASM 兼容的汇编语言输出。以下是告诉 VC++ 生成汇编清单的典型命令行：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**5.2.3 Example Assembly Language Output**'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**5.2.3 示例汇编语言输出**'
- en: 'As an example of producing assembly language output from a compiler, consider
    the following C program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为生成编译器汇编语言输出的示例，考虑以下 C 程序：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following subsections provide the compiler output for Visual C++ and GCC
    from this code sequence in order to highlight the differences between their respective
    assembly language listings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节提供了来自 Visual C++ 和 GCC 的编译器输出，以突出它们各自的汇编语言清单之间的差异。
- en: '**5.2.3.1 Visual C++ Assembly Language Output**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.2.3.1 Visual C++ 汇编语言输出**'
- en: Compiling this file with VC++ using the command line
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行通过 VC++ 编译此文件
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: produces the following (MASM) assembly language output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 产生以下 (MASM) 汇编语言输出。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The exact meaning of each assembly language statement appearing in this output
    isn’t important—yet! What’s important is seeing the difference between the syntax
    in this listing and the listings for Visual C++ and Gas that appear in the following
    sections.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*此输出中每个汇编语言语句的具体含义暂时不重要——重要的是看到该列表与接下来章节中 Visual C++ 和 Gas 的语法之间的区别。*'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**5.2.3.2 GCC Assembly Language Output (PowerPC)**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.2.3.2 GCC 汇编语言输出 (PowerPC)**'
- en: 'Like Visual C++, GCC doesn’t insert the C source code into the assembly output
    file. In GCC’s case, it’s somewhat understandable: producing assembly output is
    something it always does (rather than something it does because of a user request).
    By not inserting the C source code into the output file, GCC can cut down compilation
    times by a small amount (because the compiler won’t have to write the C source
    code data and the assembler won’t have to read this data). Here’s the output of
    GCC for a PowerPC processor when using the command line `gcc -O1 -S t1.c`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Visual C++ 类似，GCC 并不会将 C 源代码插入汇编输出文件。在 GCC 的情况下，这有一定的理解空间：生成汇编输出是它总是做的事情（而不是用户请求后才做的事情）。通过不将
    C 源代码插入输出文件，GCC 可以稍微减少编译时间（因为编译器不需要写入 C 源代码数据，汇编器也不需要读取这些数据）。以下是使用命令行 `gcc -O1
    -S t1.c` 时，GCC 为 PowerPC 处理器生成的输出：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the output of GCC is quite sparse. Of course, as this is PowerPC
    assembly language, it’s not really practical to compare this assembly output to
    the 80x86 output from the Visual C++ compiler.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GCC 的输出相当简洁。当然，因为这是 PowerPC 汇编语言，与 Visual C++ 编译器的 80x86 输出进行比较并不实际。
- en: '**5.2.3.3 GCC Assembly Language Output (80x86)**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.2.3.3 GCC 汇编语言输出 (80x86)**'
- en: 'The following code provides the GCC compilation to x86-64 assembly code for
    the *t1.c* source file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了 GCC 编译到 x86-64 汇编代码的 *t1.c* 源文件：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example should help demonstrate that the massive amount of code that GCC
    emitted for the PowerPC is more a function of the machine’s architecture than
    of the compiler. If you compare this to the code that other compilers emit, you’ll
    discover that it is roughly equivalent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子应该能帮助展示，GCC 为 PowerPC 生成的大量代码更多的是机器架构的作用，而不是编译器本身的原因。如果将其与其他编译器生成的代码进行比较，你会发现它大致相当。
- en: '**5.2.3.4 GCC Assembly Language Output (ARMv7)**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.2.3.4 GCC 汇编语言输出 (ARMv7)**'
- en: 'The following code provides the GCC compilation to ARMv6 assembly code for
    the *t1.c* source file as compiled on a Raspberry Pi (running 32-bit Raspian):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了 GCC 编译到 ARMv6 汇编代码的 *t1.c* 源文件，编译环境为 Raspberry Pi（运行 32 位 Raspian）：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the `@` denotes a comment in this source code; Gas ignores everything
    from the `@` to the end of the line.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`@` 表示此源代码中的注释；Gas 会忽略从 `@` 到行末的所有内容。
- en: '**5.2.3.5 Swift Assembly Language Output (x86-64)**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.2.3.5 Swift 汇编语言输出 (x86-64)**'
- en: 'Given a Swift source file *main.swift*, you can request an assembly language
    output file from the macOS Swift compiler using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 Swift 源文件 *main.swift*，你可以使用以下命令请求来自 macOS Swift 编译器的汇编语言输出文件：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will produce the *result.asm* output assembly language file. Consider
    the following Swift source code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 *result.asm* 输出的汇编语言文件。考虑以下 Swift 源代码：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compiling this with the previous command line produces a rather long assembly
    language output file; here is the main procedure from that code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的命令行编译此文件会生成一个相当长的汇编语言输出文件；以下是该代码中的主要过程：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, Swift doesn’t generate very optimal code compared to C++. In
    fact, hundreds of additional lines of code have been omitted from this listing
    to save space.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与 C++ 相比，Swift 生成的代码并不特别优化。实际上，为了节省空间，这里省略了数百行额外的代码。
- en: '**5.2.4 Assembly Output Analysis**'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**5.2.4 汇编输出分析**'
- en: Unless you’re well versed in assembly language programming, analyzing assembly
    output can be tricky. If you’re not an assembly language programmer, about the
    best you can do is count instructions and assume that if a compiler option (or
    reorganization of your HLL source code) produces fewer instructions, the result
    is better. In reality, this assumption isn’t always correct. Some machine instructions
    (particularly on CISC processors such as the 80x86) require substantially more
    time to execute than others. A sequence of three or more instructions on a processor
    such as the 80x86 could execute faster than a single instruction that does the
    same operation. Fortunately, a compiler is not likely to produce both of these
    sequences based on a reorganization of your high-level source code. Therefore,
    you don’t usually have to worry about such issues when examining the assembly
    output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你熟练掌握汇编语言编程，否则分析汇编输出可能会很棘手。如果你不是汇编语言程序员，最好的做法是数一数指令，并假设如果某个编译器选项（或者对你的高级语言源代码进行重组）产生了更少的指令，结果应该是更好的。但实际上，这个假设并不总是正确的。一些机器指令（特别是在CISC处理器上，如80x86）执行时间比其他指令要长得多。在像80x86这样的处理器上，三条或更多指令的序列可能比执行相同操作的单条指令更快。幸运的是，编译器通常不会基于你高级源代码的重组而生成这两种序列。因此，检查汇编输出时，你通常不需要担心这些问题。
- en: Note that some compilers will produce two different sequences if you change
    the optimization level. This is because certain optimization settings tell the
    compiler to favor shorter programs, while other optimization settings tell the
    compiler to favor faster execution. The optimization setting that favors smaller
    executable files will probably pick the single instruction over the three instructions
    that do the same work (assuming those three instructions compile into more code);
    the optimization setting that favors speed will probably pick the faster instruction
    sequence.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你更改优化级别，一些编译器会生成两种不同的指令序列。这是因为某些优化设置会告诉编译器偏向于生成更短的程序，而其他优化设置则会告诉编译器偏向于生成更快的执行速度。偏向于生成更小可执行文件的优化设置可能会选择单条指令，而不是执行相同操作的三条指令（假设这三条指令编译成更多的代码）；偏向于速度的优化设置可能会选择执行速度更快的指令序列。
- en: This section uses various C/C++ compilers in its examples, but you should remember
    that compilers for other languages also provide the ability to emit assembly code.
    You’ll have to check your compiler’s documentation to see if this is possible
    and what options you can use to produce the assembly output. Some compilers (Visual
    C++, for example) provide an integrated development environment (IDE) that you
    may use in place of a command-line tool. Even though most compilers that work
    through an IDE also work from the command line, you can usually specify assembly
    output from within an IDE as well as from the command line. Once again, see your
    compiler vendor’s documentation for details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用了各种C/C++编译器作为示例，但你应当记住，其他语言的编译器也提供了生成汇编代码的功能。你需要查看编译器的文档，了解是否支持此功能，以及可以使用哪些选项生成汇编输出。一些编译器（例如Visual
    C++）提供了集成开发环境（IDE），你可以使用它替代命令行工具。尽管大多数通过IDE工作的编译器也能通过命令行工作，但你通常可以在IDE内以及通过命令行指定汇编输出。再次提醒，查看编译器厂商的文档获取详细信息。
- en: '**5.3 Using Object Code Utilities to Analyze Compiler Output**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**5.3 使用目标代码工具分析编译器输出**'
- en: Although many compilers provide an option to emit assembly language rather than
    object code, a large number of compilers do not; they can only emit binary machine
    code to an object code file. Analyzing this kind of compiler output will be a
    bit more work, and it’s going to require some specialized tools. If your compiler
    emits object code files (such as PE/COFF or ELF files) to be fed into a linker,
    you can probably find an “object code dump” utility that will prove quite useful
    for analyzing the compiler’s output. For example, Microsoft provides the *dumpbin.exe*
    program, and the FSF/GNU *dumpobj* program has similar capabilities for ELF files
    under Linux and other operating systems. In the following subsections, we’ll take
    a look at using these two tools when analyzing compiler output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多编译器提供了发出汇编语言而不是目标代码的选项，但许多编译器并不提供；它们只能将二进制机器代码输出到目标代码文件。分析这种编译器输出会稍微复杂一些，并且需要一些专用的工具。如果你的编译器生成目标代码文件（如PE/COFF或ELF文件）以供链接器使用，你可能会找到一个“目标代码转储”工具，这对分析编译器的输出非常有用。例如，微软提供了*dumpbin.exe*程序，FSF/GNU的*dumpobj*程序也具有类似的功能，用于Linux及其他操作系统下的ELF文件。在接下来的子节中，我们将了解在分析编译器输出时如何使用这两个工具。
- en: One nice feature of working with object files is that they usually contain symbolic
    information. That is, in addition to binary machine code, the object file contains
    strings specifying identifier names that appear in the source file (such information
    does not normally appear in an executable file). Object code utilities can usually
    display these symbolic names within the machine instructions that reference the
    memory locations associated with these symbols. Though these object code utilities
    can’t automatically correlate the HLL source code with the machine code, having
    the symbolic information available can help you when you’re studying their output,
    because it’s much easier to read names like `JumpTable` than memory addresses
    like `$401_1000`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目标文件的一个优点是它们通常包含符号信息。也就是说，除了二进制机器代码外，目标文件还包含指定标识符名称的字符串，这些名称出现在源文件中（这些信息通常不会出现在可执行文件中）。目标代码工具通常可以显示这些符号名称，在引用与这些符号关联的内存位置的机器指令中。尽管这些目标代码工具不能自动将高级语言源代码与机器代码相关联，但有符号信息可用时，当你研究它们的输出时会更加有帮助，因为像`JumpTable`这样的名称比像`$401_1000`这样的内存地址更容易理解。
- en: '**5.3.1 The Microsoft dumpbin.exe Utility**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**5.3.1 Microsoft dumpbin.exe工具**'
- en: 'Microsoft’s `dumpbin` command-line tool allows you to examine the contents
    of a Microsoft PE/COFF file.^([2](footnotes.xhtml#ch5fn2)) You run the program
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的`dumpbin`命令行工具允许你检查微软PE/COFF文件的内容。^([2](footnotes.xhtml#ch5fn2))你可以按照以下方式运行该程序：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The filename parameter is the name of the *.obj* file that you wish to examine,
    and the options parameter is a set of optional command-line arguments that specify
    the type of information you want to display. These options each begin with a forward
    slash (`/`). We’ll take a look at each of the possible options in a moment. First,
    here is a listing of the possible objects (obtained via the `/?` command-line
    option):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名参数是你希望检查的*.obj*文件的名称，选项参数是一组可选的命令行参数，用于指定你希望显示的信息类型。这些选项每个都以斜杠(`/`)开头。接下来我们将查看每个可能的选项。首先，这是通过`/?`命令行选项获得的可能对象的列表：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Though the primary use of `dumpbin` is to look at the object code a compiler
    produces, it also displays a considerable amount of interesting information about
    a PE/COFF file. For more information on the meaning of many of the `dumpbin` command-line
    options, review “Object File Formats” on [page 71](ch04.xhtml#page_71) or “Executable
    File Formats” on [page 80](ch04.xhtml#page_80).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`dumpbin`的主要用途是查看编译器生成的目标代码，但它也会显示关于PE/COFF文件的相当多的有趣信息。关于许多`dumpbin`命令行选项的含义，更多信息请参阅[第71页](ch04.xhtml#page_71)的“目标文件格式”或[第80页](ch04.xhtml#page_80)的“可执行文件格式”。
- en: 'The following subsections describe several of the possible `dumpbin` command-line
    options and provide example output for a simple “Hello World” program written
    in C:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子节描述了几种可能的`dumpbin`命令行选项，并为用C语言编写的简单“Hello World”程序提供了示例输出。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**5.3.1.1 /all**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.3.1.1 /all**'
- en: 'The `/all` command-line option instructs `dumpbin` to display all the information
    it can except for a disassembly of the code found in the object file. The problem
    with this approach is that an *.exe* file contains all the routines from the language’s
    standard library (such as the C Standard Library) that the linker has merged into
    the application. When analyzing compiler output in order to improve your application’s
    code, wading through all this extra information about code outside your program
    can be tedious. Fortunately, there’s an easy way to pare down the unnecessary
    information—run `dumpbin` on your object (*.obj*) files rather than your executable
    (*.exe*) files. Here is the (shortened) output that `dumpbin` produces for the
    “Hello World” example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`/all` 命令行选项指示 `dumpbin` 显示它能提供的所有信息，除了对象文件中的代码反汇编。这个方法的问题在于，*.exe* 文件包含了链接器将语言标准库（例如
    C 标准库）合并到应用程序中的所有例程。当分析编译器输出以改善应用程序的代码时，浏览这些关于程序外部代码的额外信息可能会很繁琐。幸运的是，有一个简单的方法可以减少不必要的信息——对对象文件（*.obj*）而非可执行文件（*.exe*）运行
    `dumpbin`。以下是 `dumpbin` 对“Hello World”示例产生的（简化）输出：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example deletes the bulk of the output from this command (to spare you
    having to read a dozen or so extra pages). Try executing the `/all` command yourself
    to see the quantity of output you get. In general, though, use this option with
    care.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例删除了大部分输出内容（以避免你阅读多达十几页的额外信息）。你可以尝试自己执行 `/all` 命令，看看你会得到多少输出。然而，总的来说，使用这个选项时要小心。
- en: '**5.3.1.2 /disasm**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.3.1.2 /disasm**'
- en: The `/disasm` command-line option is the one of greatest interest to us. It
    produces a disassembled listing of the object file. As with the `/all` option,
    you shouldn’t try to disassemble an *.exe* file using `dumpbin`. The disassembled
    listing you’ll get will be quite long, and the vast majority of the code will
    probably be the listings of all the library routines your application calls. For
    example, the simple “Hello World” application generates over 5,000 lines of disassembled
    code. All but a small handful of those statements correspond to library routines.
    Wading through that amount of code will prove overwhelming to most people.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`/disasm` 命令行选项是我们最感兴趣的选项。它会生成对象文件的反汇编清单。与 `/all` 选项一样，你不应该尝试使用 `dumpbin` 反汇编
    *.exe* 文件。你得到的反汇编清单可能会非常长，而且大多数代码可能只是你的应用程序调用的所有库例程的列表。例如，简单的“Hello World”应用程序会生成超过
    5000 行的反汇编代码。除了极少数语句之外，所有这些语句都对应于库例程。浏览这么多代码对大多数人来说是压倒性的。'
- en: 'However, if you disassemble the *hw.obj* file rather than the executable file,
    here’s the output you typically get:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你对 *hw.obj* 文件进行反汇编，而不是可执行文件，通常会得到以下输出：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you look closely at this disassembled code, you’ll find the major problem
    with disassembling object files rather than executable files—most addresses in
    the code are relocatable addresses, which appear as `$00000000` in the object
    code listing. As a result, you’ll probably have a hard time figuring out what
    the various assembly statements are doing. For example, in the *hw.obj*’s disassembled
    listing you see the following two statements:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看这个反汇编代码，你会发现反汇编对象文件而不是可执行文件的主要问题——代码中的大多数地址都是可重定位地址，在对象代码列表中显示为 `$00000000`。因此，你可能很难弄清楚各个汇编语句的作用。例如，在
    *hw.obj* 的反汇编清单中，你会看到以下两条语句：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `lea` instruction opcode is the 3-byte sequence `48 8D 0D` (which includes
    an REX opcode prefix byte). The address of the `"Hello World"` string is not `00
    00 00 00` (the 4 bytes following the opcode); instead, it is a relocatable address
    that the linker/system fills in later. If you run `dumpbin` on *hw.obj* with the
    `/all` command-line option, you’ll notice that this file has two relocation entries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`lea` 指令操作码是 3 字节序列 `48 8D 0D`（其中包括一个 REX 操作码前缀字节）。`"Hello World"` 字符串的地址不是
    `00 00 00 00`（操作码后面的 4 字节）；而是一个可重定位地址，链接器/系统稍后会填充这个地址。如果你在 *hw.obj* 上运行带有 `/all`
    命令行选项的 `dumpbin`，你会注意到这个文件有两个重定位条目：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Offset column tells you the byte offset into the file where the relocations
    are to be applied. In the preceding disassembly, note that the `lea` instruction
    starts at offset `$d`, so the actual displacement is at offset `$10`. Similarly,
    the `call` instruction begins at offset `$14`, so the address of the actual routine
    that needs to be patched is 1 byte later, at offset `$15`. From the relocation
    information that `dumpbin` outputs, you can discern the symbols associated with
    these relocations. (`$SG4247` is an internal symbol that the C compiler generates
    for the `"Hello World"` string. And `printf` is, obviously, the name associated
    with the C `printf()` function.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移列告诉你将在文件中应用重定位的字节偏移量。在前面的反汇编中，注意到`lea`指令从偏移量`$d`开始，因此实际的位移在偏移量`$10`处。类似地，`call`指令从偏移量`$14`开始，因此需要修补的实际例程的地址在1字节之后，位于偏移量`$15`。通过`dumpbin`输出的重定位信息，你可以辨认出与这些重定位相关的符号。(`$SG4247`是C编译器为`"Hello
    World"`字符串生成的内部符号。而`printf`显然是与C语言的`printf()`函数相关联的名称。)
- en: Cross-referencing every call and memory reference against the relocation list
    may seem like a pain, but at least you get symbolic names when you do this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用每个调用和内存引用与重定位列表可能看起来很麻烦，但至少你在这样做时会获得符号名称。
- en: 'Consider the first few lines of the disassembled code when you apply the `/disasm`
    option to the *hw.exe* file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在对*hw.exe*文件应用`/disasm`选项时，反汇编代码的前几行：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the linker has filled in the addresses (relative to the load address
    for the file) of the offset `$SG4247` and `print` labels. This may seem somewhat
    convenient; however, note that these labels (especially the `printf` label) are
    no longer present in the file. When you are reading the disassembled output, the
    absence of these labels can make it very difficult to figure out which machine
    instructions correspond to HLL statements. This is yet another reason why you
    should use object files rather than executable files when running `dumpbin`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，链接器已经填充了偏移量`$SG4247`和`print`标签的地址（相对于文件的加载地址）。这看起来可能有点方便；然而，注意到这些标签（特别是`printf`标签）不再出现在文件中。当你阅读反汇编输出时，缺少这些标签可能会使得很难搞清楚哪些机器指令对应HLL语句。这是你在运行`dumpbin`时应该使用目标文件而非可执行文件的又一个原因。
- en: 'If you think it’s going to be a major pain to read the disassembled output
    of the `dumpbin` utility, don’t worry: for optimization purposes, you’re often
    more interested in the code differences between two versions of an HLL program
    than in figuring out what each machine instruction does. Therefore, you can easily
    determine which machine instructions are affected by a change in your code by
    running `dumpbin` on two versions of your object files (one before the change
    to the HLL code and one created afterward). For example, consider the following
    modification to the “Hello World” program:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得阅读`dumpbin`工具的反汇编输出会非常麻烦，不必担心：为了优化目的，你通常更关注的是HLL程序两个版本之间的代码差异，而不是搞清楚每条机器指令的作用。因此，你可以通过对两个版本的目标文件（一个是在HLL代码更改之前，另一个是在更改之后生成的）运行`dumpbin`，轻松确定哪些机器指令受到代码更改的影响。例如，考虑对“Hello
    World”程序的以下修改：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the disassembly output that `dumpbin` produces:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`dumpbin`生成的反汇编输出：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By comparing this output with the previous assembly output (either manually
    or by running one of the programs based on the Unix `diff` utility), you can see
    the effect of the change to your HLL source code on the emitted machine code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此输出与之前的汇编输出进行比较（无论是手动比较还是使用基于Unix的`diff`工具运行程序），你可以看到对HLL源代码的更改对生成的机器代码的影响。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The section “Comparing Output from Two Compilations” on [page 137](ch05.xhtml#page_137)
    discusses the merits of both comparison methods (manual and `diff`-based).*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*[第137页](ch05.xhtml#page_137)的“比较两个编译输出”部分讨论了两种比较方法（手动比较和基于`diff`的方法）的优缺点。*'
- en: '**5.3.1.3 /headers**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**5.3.1.3 /headers**'
- en: 'The `/headers` option instructs `dumpbin` to display the COFF header files
    and section header files. The `/all` option also prints this information, but
    `/header` displays *only* the header information without all the other output.
    Here’s the sample output for the “Hello World” executable file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`/headers`选项指示`dumpbin`显示COFF头文件和节头文件。`/all`选项也会打印这些信息，但`/header`仅显示*头部信息*，而不包括所有其他输出。以下是“Hello
    World”可执行文件的示例输出：'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Review the discussion of object file formats in [Chapter 4](ch04.xhtml#ch04)
    (see “Object File Formats” on [page 71](ch04.xhtml#page_71)) to make sense of
    the information that `dumpbin` outputs when you specify the `/headers` option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.4 /imports**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `/imports` option lists all of the dynamic-link symbols that the operating
    system must supply when the program loads into memory. This information isn’t
    particularly useful for analyzing code emitted for HLL statements, so this chapter
    won’t mention this option further.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.5 /relocations**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `/relocations` option displays all the relocation objects in the file. This
    command is quite useful because it provides a list of all the symbols for the
    program and the offsets of their use in the disassembly listing. Of course, the
    `/all` option also presents this information, but `/relocations` provides just
    this information without anything else.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.1.6 Other dumpbin.exe Command-Line Options**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `dumpbin` utility supports many more command-line options beyond those this
    chapter describes. As noted earlier, you can get a list of all possible options
    by specifying `/?` on the command line when running `dumpbin`. You can also read
    more online at *[https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/](https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019/)*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3.2 The FSF/GNU objdump Utility**'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re running the GNU toolset on your operating system (for example, under
    Linux, Mac, or BSD), then you can use the FSF/GNU `objdump` utility to examine
    the object files produced by GCC and other GNU-compliant tools. Here are the command-line
    options it supports:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Given the following *m.hla* source code fragment:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is some sample output produced on the 80x86, created with the Linux command
    line `objdump -S m`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These listings are only a fragment of the total code (which is why certain labels
    are absent). Nevertheless, you can see how the `objdump` utility can be useful
    for analyzing compiler output by allowing you to disassemble the object code for
    a certain code fragment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `dumpbin`, `objdump` can display additional information beyond the machine
    code disassembly that may prove useful when you’re analyzing compiler output.
    For most purposes, however, the GCC `-S` (assembly output) option is the most
    useful. Here’s an example of a disassembly of some C code using the `objdump`
    utility. First, the original C code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the Gas output (x86-64) from GCC for the C code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now here’s the `objdump` disassembly of the main function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the assembly code output is somewhat easier to read than `objdump`’s
    output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**5.4 Using a Disassembler to Analyze Compiler Output**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although using an object code “dump” tool is one way to analyze compiler output,
    another possible solution is to run a *disassembler* on the executable file. A
    disassembler is a utility that translates binary machine code into human-readable
    assembly language statements (“human-readable” is debatable, but that’s the idea,
    anyway). As such, it’s another tool you can use to analyze compiler output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: There is a subtle, but important, difference between an object code dump utility
    (which contains a simple disassembler) and a sophisticated disassembler program.
    Object code dump utilities are automatic, but they can get easily confused if
    the object code contains tricky constructs (such as buried data in the instruction
    stream). An *automatic disassembler* is very convenient to use, requiring little
    expertise on the user’s part, but rarely disassembles the machine code correctly.
    A full-blown *interactive disassembler*, on the other hand, requires more training
    to use properly, but is capable of disassembling tricky machine code sequences
    with a little help from its user. Therefore, decent disassemblers will work in
    situations where a simplistic object code dump utility will fail. Fortunately,
    most compilers do not always emit the kind of tricky code that confuses object
    code dump utilities, so you can sometimes get by without having to learn how to
    use a full-blown disassembler program. Nevertheless, having a disassembler handy
    can be useful in situations where a simplistic approach doesn’t work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Several “free” disassemblers are available. The one we’ll cover in this chapter
    is IDA7\. IDA is the freeware version of IDA Pro, a very capable and powerful
    commercial disassembler system (*[https://www.hex-rays.com/products/ida/](https://www.hex-rays.com/products/ida/)*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When you first run IDA, it opens the window shown in [Figure 5-1](ch05.xhtml#ch5fig1).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: IDA opening window*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Click the **New** button and type in the name of the *.exe* or *.obj* file you
    wish to disassemble. Once you enter an executable filename, IDA brings up the
    Format dialog shown in [Figure 5-2](ch05.xhtml#ch5fig2). In this dialog, you can
    select the binary file type (for example, PE/COFF, PE64 executable file, or pure
    binary) and the options to use when disassembling the file. IDA does a good job
    of choosing reasonable default values for these options, so most of the time you’ll
    just accept the defaults unless you’re working with some weird binary files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: IDA executable file format dialog*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, IDA will figure out the appropriate file type information for a
    standard disassembly, then do an “automatic” disassembly of the object code file.
    To produce an assembly language output file, click **OK**. Here are the first
    few lines of the disassembly of the *t1.c* file given in “Example Assembly Language
    Output” on [page 102](ch05.xhtml#page_102):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: IDA is an *interactive* disassembler. This means that it provides lots of complex
    features that you can use to guide the disassembly to produce a more reasonable
    assembly language output file. However, its “automatic” mode of operation is generally
    all you’ll need in order to examine compiler output files to assess their quality.
    For more details on IDA (freeware) or IDA Pro, see its documentation (*[https://www.hex-rays.com/products/ida/support/](https://www.hex-rays.com/products/ida/support/)*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**5.5 Using the Java Bytecode Disassembler to Analyze Java Output**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most Java compilers (particularly those from Oracle, Inc.) do not generate
    machine code directly. Instead, they generate Java bytecode (JBC), which computer
    systems then execute using a JBC interpreter. To improve performance, some Java
    interpreters run a just-in-time (JIT) compiler that translates JBC into native
    machine code during interpretation to improve performance (though the result is
    rarely as good as the machine code an optimizing compiler generates). Unfortunately,
    because the Java interpreter does this translation at runtime, it is difficult
    to analyze the machine code output from the Java compiler. It is, however, possible
    to analyze the JBC it produces. This can give you a better picture of what the
    compiler is doing with your Java code than simply guessing. Consider the following
    (relatively trivial) Java program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Typically, you can compile this program (*Welcome.java*) using a command line
    of the form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This command produces the *Welcome.class* JBC file. You can use the following
    command to disassemble this file (to the standard output):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that you do not include the *.class* file extension on the command line;
    the `javap` command automatically supplies it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The `javap` command produces a bytecode disassembly listing similar to the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can find documentation for the JBC mnemonics and the `javap` Java class
    file disassembler on [Oracle.com](http://Oracle.com) (search the site for “javap”
    and “Java bytecode disassembler”). Also, the online chapters (specifically, Appendix
    D) accompanying this book discuss the Java VM bytecode assembly language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**5.6 Using the IL Disassembler to Analyze Microsoft C# and Visual Basic Output**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft’s .NET language compilers do not directly emit native machine code.
    Instead, they emit a special IL (intermediate language) code. This is quite similar,
    in principle, to Java bytecode or UCSD p-machine code. The .NET runtime system
    will compile IL executable files and run them using a JIT compiler.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft C# compiler is a good example of a .NET language that works in
    this fashion. Compiling a simple C# program will produce a Microsoft *.exe* file
    that you can examine with `dumpbin`. Unfortunately, you can’t use `dumpbin` to
    look at the object code (IL or otherwise). Fortunately, Microsoft supplies a utility,
    *ildasm.exe*, that you can use to disassemble the IL byte/assembly code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following small C# example program (*Class1.cs*, a slight tweak
    of the ubiquitous “Hello World!” program):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Typing `ildasm class1.exe` from a command prompt brings up the window shown
    in [Figure 5-3](ch05.xhtml#ch5fig3).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: IL disassembler window*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the code disassembly, double-click the S icon (next to the Main entry).
    This opens a window containing the following text (comments added for clarity):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can use the IL disassembler program for any .NET language (such as Visual
    Basic and F#). See Appendix E online for details on Microsoft’s IL assembly language.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7 Using a Debugger to Analyze Compiler Output**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option you can use to analyze compiler output is a debugger program,
    which usually incorporates a disassembler that you can use to view machine instructions.
    Depending on the debugger you use, viewing your compiler output this way can be
    either a headache or a breeze. Typically, if you use a stand-alone debugger, you’ll
    find that it takes considerably more effort to analyze your compiler output than
    if you use a debugger built into a compiler’s IDE. This section looks at both
    approaches.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7.1 Using an IDE’s Debugger**'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Microsoft Visual C++ environment provides excellent tools for analyzing
    the code produced by a compilation (of course, the compiler also produces assembly
    output, but we’ll ignore that fact here). To view the output using the Visual
    Studio debugger, first compile your C/C++ program to an executable file and then
    select **Debug** ▸ **Step Into** from the Visual Studio Debug menu. When the program
    pauses execution, select **Debug** ▸ **Windows** ▸ **Disassembly** from the debug
    menu. For the *t1.c* program (see “Example Assembly Language Output” on [page
    102](ch05.xhtml#page_102)), you should see a disassembly like the following (assuming
    you’re producing 32-bit code):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Of course, because Microsoft’s Visual C++ package is already capable of outputting
    an assembly language file during compilation, using the Visual Studio integrated
    debugger in this manner isn’t necessary.^([3](footnotes.xhtml#ch5fn3)) However,
    some compilers do not provide assembly output, and debugger output may be the
    easiest way to view the machine code the compiler produces. For example, Embarcadero’s
    Delphi compiler does not provide an option to produce assembly language output.
    Given the massive amount of class library code that Delphi links into an application,
    attempting to view the code for a small section of your program by using a disassembler
    would be like trying to find a needle in a haystack. A better solution is to use
    the debugger built into the Delphi environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7.2 Using a Stand-Alone Debugger**'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your compiler doesn’t provide its own debugger as part of an IDE, another
    alternative is to use a separate debugger such as OllyDbg, DDD, or GDB to disassemble
    your compiler’s output. Simply load the executable file into the debugger for
    normal debugging operations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Most debuggers that are not associated with a particular programming language
    are machine-level debuggers that disassemble the binary machine code into machine
    instructions for viewing during the debugging operation. One problem with using
    machine-level debuggers is that locating a particular section of code to disassemble
    can be difficult. Remember, when you load the entire executable file into a debugger,
    you load in all the statically linked library routines and other runtime support
    code that doesn’t normally appear in the application’s source file. Searching
    through all this extraneous code to find out how the compiler translates a particular
    sequence of statements to machine code can be time-consuming. Some serious code
    sleuthing may be necessary. Fortunately, most linkers collect all the library
    routines together and place them either at the beginning or end of the executable
    file. Therefore, that’s generally also where you’ll find the code associated with
    your application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Debuggers come in one of three different flavors: pure machine-level debuggers,
    symbolic debuggers, and source-level debuggers. Symbolic debuggers and source-level
    debuggers require executable files to contain special debugging information and,
    therefore, the compiler must specifically include this extra information.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Pure machine-level debuggers have no access to the original source code or symbols
    in the application. A pure machine-level debugger simply disassembles the application’s
    machine code and displays the listing using literal numeric constants and machine
    addresses. Reading through such code is difficult, but if you understand how compilers
    generate code for the HLL statements (as this book will teach you), then locating
    the machine code is easier. Nevertheless, without any symbolic information to
    provide a “root point” in the code, analysis can be difficult.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic debuggers use special symbol table information found in the executable
    file (or a separate debugging file, in some instances) to associate labels with
    functions and, possibly, variable names in your source file. This feature makes
    locating sections of code within the disassembly listing much easier. When symbolic
    labels identify calls to functions, it’s much easier to see the correspondence
    between the disassembled code and your original HLL source code. One thing to
    keep in mind, however, is that symbolic information is available only if the application
    was compiled with debugging mode enabled. Check your compiler’s documentation
    to determine how to activate this feature for use with your debugger.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Source-level debuggers actually display the original source code associated
    with the file the debugger is processing. In order to see the machine code the
    compiler produced, you often have to activate a special machine-level view of
    the program. As with symbolic debuggers, your compiler must produce special executable
    files (or auxiliary files) containing debug information that a source-level debugger
    can use. Clearly, source-level debuggers are much easier to work with because
    they show the correspondence between the original HLL source code and the disassembled
    machine code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**5.8 Comparing Output from Two Compilations**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are an expert assembly language programmer and you’re well versed in
    compiler design, it should be pretty easy for you to determine what changes you’ll
    need to make to your HLL source code to improve the quality of the output machine
    code. However, most programmers (especially those who do not have considerable
    experience studying compiler output) can’t just read a compiler’s assembly language
    output. They have to compare the two sets of outputs (before and after a change)
    to determine which code is better. After all, not every change you make to your
    HLL source files will result in better code. Some changes will leave the machine
    code unaffected (in which case, you should use the more readable and maintainable
    version of the HLL source code). In other cases, you could actually make the output
    machine code worse. Therefore, unless you know exactly what a compiler is going
    to do when you make changes to your HLL source file, you should do a before-and-after
    comparison of the compiler’s output machine code before accepting any modifications
    you make.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**5.8.1 Before-and-After Comparisons with diff**'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, the first reaction from any experienced software developer is, “Well,
    if we have to compare files, we’ll just use `diff`!” As it turns out, a typical
    `diff` (compute file differences) program will be useful for certain purposes,
    but it won’t be universally applicable when you’re comparing two different output
    files from a compiler. The problem with a program like `diff` is that it works
    great when there are only a few differences between two files, but it’s not so
    useful when the files are wildly different. For example, consider the following
    C program (*t.c*) and two different outputs produced by the Microsoft VC++ compiler:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the assembly language output MSVC++ produces when using the command
    line `cl /Fa t.c` (that is, when compiling without optimization):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the assembly listing we get when we compile the C program with the command
    line `cl /Ox /Fa t.c` (`/Ox` enables maximum optimization for speed in Visual
    C++):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It doesn’t take a very sharp eye to notice that the two assembly language output
    files are radically different. Running these two files through `diff` simply produces
    a lot of noise; the output from `diff` is more difficult to interpret than manually
    comparing the two assembly language output files.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'A differencing program like `diff` (or better yet, the differencing facility
    built into many advanced programming editors) works best for comparing two different
    outputs for a given HLL source file to which you’ve made a small change. In the
    current example, had we changed the statement `case 1000:` to `case 1001:`, then
    a `diff` of the resulting assembly file against the original produces the following
    output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As long as you’re comfortable reading `diff` output, this isn’t too bad. However,
    a better solution is to use some commercially available file comparison programs.
    Two excellent options are Beyond Compare (*[https://www.scootersoftware.com/](https://www.scootersoftware.com/)*)
    and Araxis Merge (*[https://www.araxis.com/merge/](https://www.araxis.com/merge/)*).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Of course, another way to compare compiler output is manually. Set two listings
    side by side (either on paper or on your monitor) and start analyzing them. In
    the current C example, if we compare the two different outputs from the C compiler
    (without optimization and with the `/Ox` optimization option), we’ll discover
    that both versions use a binary search algorithm to compare the `switch` value
    against a list of widely varying constants. The main difference between the optimized
    and unoptimized versions has to do with code duplication.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly compare two assembly listings that a compiler produces,
    you’ll need to learn how to interpret the machine language output from your compilers
    and connect certain assembly language sequences with the statements in your HLL
    code. That’s the purpose of many of the chapters to come.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**5.9 For More Information**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your compiler’s manual is the first place to look when you’re trying to figure
    out how to view the machine code the compiler produces. Many compilers produce
    assembly language output as an option, and that’s the best way to view code output.
    If your compiler does not provide this option, a debugging tool built into the
    compiler’s IDE (if available) is another good choice. See the documentation for
    your IDE or compiler for details.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Tools like `objdump` and `dumpbin` are also useful for examining compiler output.
    Check the Microsoft, FSF/GNU, or Apple LLVM documentation for details on using
    these programs. If you decide to use an external debugger, such as OllyDbg or
    GDB, check out the software’s user documentation, or visit the author’s support
    web page (for example, *[http://www.ollydbg.de/](http://www.ollydbg.de/)* for
    the OllyDbg debugger).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
