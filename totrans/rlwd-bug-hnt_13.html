<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_129"/><strong><span class="big">13</span><br/>MEMORY VULNERABILITIES</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">Every application relies on computer memory to store and execute the application’s code. A <em>memory vulnerability</em> exploits a bug in the application’s memory management. The attack results in unintended behavior that could enable an attacker to inject and execute their own commands.</p>&#13;
<p class="indent">Memory vulnerabilities occur in programming languages where developers are responsible for applications’ memory management, such as in C and C++. Other languages, like Ruby, Python, PHP, and Java, manage memory allocation for developers, making these languages less susceptible to memory bugs.</p>&#13;
<p class="indent">Before performing any dynamic action in C or C++, a developer must ensure that the proper amount of memory is allocated for the action. For example, suppose you’re coding a dynamic banking application that allows <span epub:type="pagebreak" id="page_130"/>users to import transactions. When the application runs, you have no idea how many transactions users will import. Some could import one, and others might import a thousand. In languages without memory management, you must check the number of transactions being imported and then allocate the appropriate memory for them. When a developer doesn’t take into account how much memory they need for an application, bugs such as buffer overflows can occur.</p>&#13;
<p class="indent">Finding and exploiting memory vulnerabilities is complex, and entire books have been written on the subject. For this reason, this chapter only provides an introduction to the topic by covering just two of the many memory vulnerabilities: buffer overflows and read out of bounds vulnerabilities. If you’re interested in learning more, I recommend reading <em>Hacking: The Art of Exploitation</em> by Jon Erickson or <em>A Bug Hunter’s Diary: A Guided Tour Through the Wilds of Software Security</em> by Tobias Klein; both are available from No Starch Press.</p>&#13;
<h3 class="h3" id="ch13lev1sec1"><strong>Buffer Overflows</strong></h3>&#13;
<p class="noindent">A <em>buffer overflow</em> vulnerability is a bug where an application writes data that is too big for the memory (the <em>buffer</em>) allocated for that data. Buffer overflows lead to unpredictable program behavior at best and serious vulnerabilities at worst. When an attacker can control the overflow to execute their own code, they can potentially compromise the application or, depending on user permissions, even the server. This type of vulnerability is similar to the RCE examples in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<p class="indent">Buffer overflows usually occur when a developer forgets to check the size of the data being written to a variable. They can also occur when a developer makes a mistake calculating how much memory the data requires. Because these errors can happen any number of ways, we’ll just examine one type—a <em>length check omission</em>. In the C programming language, omitted length checks commonly involve functions that alter memory, such as <code>strcpy()</code> and <code>memcpy()</code>. But these checks can also occur when developers use memory allocation functions, such as <code>malloc()</code> or <code>calloc()</code>. The function <code>strcpy()</code> (and <code>memcpy()</code>) takes two parameters: a buffer to copy data to and the data to copy. Here’s an example in C:</p>&#13;
<pre> #include &lt;string.h&gt;<br/>&#13;
 int main()<br/>&#13;
 {<br/>&#13;
<span class="ent">➊</span> char src[16]="hello world";<br/>&#13;
<span class="ent">➋</span> char dest[16];<br/>&#13;
<span class="ent">➌</span> strcpy(dest, src);<br/>&#13;
<span class="ent">➍</span> printf("src is %s\n", src);<br/>&#13;
   printf("dest is %s\n", dest);<br/>&#13;
   return 0;<br/>&#13;
 }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>In this example, the string <code>src</code> <span class="ent">➊</span> is set to the string <code>"hello world"</code>, which is 11 characters long, including the space. This code allocates 16 bytes to <code>src</code> and <code>dest</code> <span class="ent">➋</span> (each character is 1 byte). Because each character requires 1 byte of memory and strings must end with a null byte (<code>\0</code>), the <code>"hello world"</code> string requires a total of 12 bytes, which fit within the 16-byte allocation. The <code>strcpy()</code> function then takes the string in <code>src</code> and copies it into <code>dest</code> <span class="ent">➌</span>. The <code>printf</code> statements at <span class="ent">➍</span> print the following:</p>&#13;
<pre>src is hello world<br/>&#13;
dest is hello world</pre>&#13;
<p class="indent">This code works as expected, but what if someone wanted to really emphasize that greeting? Consider this example:</p>&#13;
<pre> #include &lt;string.h&gt;<br/>&#13;
 #include &lt;stdio.h&gt;<br/>&#13;
 int main()<br/>&#13;
 {<br/>&#13;
<span class="ent">➊</span> char src[17]="hello world!!!!!";<br/>&#13;
<span class="ent">➋</span> char dest[16];<br/>&#13;
<span class="ent">➌</span> strcpy(dest, src);<br/>&#13;
   printf("src is %s\n", src);<br/>&#13;
   printf("dest is %s\n", dest);<br/>&#13;
   return 0;<br/>&#13;
 }</pre>&#13;
<p class="indent">Here, five exclamation marks are added, bringing the total character count of the string up to 16. The developer remembered that all strings must end with a null byte (<code>\0</code>) in C. They’ve allocated 17 bytes to <code>src</code> <span class="ent">➊</span> but forgot to do the same for <code>dest</code> <span class="ent">➋</span>. After compiling and running the program, the developer would see this output:</p>&#13;
<pre>src is<br/>&#13;
dest is hello world!!!!!</pre>&#13;
<p class="indent">The <code>src</code> variable is empty despite being assigned <code>'hello world!!!!!'</code>. This happens because of how C allocates <em>stack memory</em>. Stack memory addresses are assigned incrementally, so a variable defined earlier in the program will have a lower memory address than a variable defined after it. In this case, <code>src</code> is added to the memory stack, followed by <code>dest</code>. When the overflow occurs, the 17 characters for <code>'hello world!!!!!!'</code> are written to the <code>dest</code> variable, but the string’s null byte (<code>\0</code>) overflows into the first character of the <code>src</code> variable. Because null bytes denote the end of a string, <code>src</code> appears to be empty.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13fig01">Figure 13-1</a> illustrates what the stack looks like as each line of code executes from <span class="ent">➊</span> to <span class="ent">➌</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_132"/><a id="ch13fig01"/><img alt="image" src="../images/13fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-1: How memory overflows from <span class="codeitalic">dest</span> to <span class="codeitalic">src</span></em></p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13fig01">Figure 13-1</a>, <code>src</code> is added to the stack and 17 bytes are allocated to the variable, which are labeled in the figure starting from 0 <span class="ent">➊</span>. Next, <code>dest</code> is added to the stack but is only allocated 16 bytes <span class="ent">➋</span>. When <code>src</code> is copied to <code>dest</code>, the last byte that would have been stored in <code>dest</code> overflows into the first byte of <code>src</code> (byte 0) <span class="ent">➌</span>. This makes the first byte of <code>src</code> into a null byte.</p>&#13;
<p class="indent">If you added another exclamation mark to <code>src</code> and updated the length to 18, the output would look like this:</p>&#13;
<pre>src is !<br/>&#13;
dest is hello world!!!!!</pre>&#13;
<p class="indent">The <code>dest</code> variable would only hold <code>'hello world!!!!!'</code>, and the final exclamation mark and null byte would overflow into <code>src</code>. This would make <code>src</code> appear as though it only held the string <code>'!'</code>. The memory shown in <a href="ch13.xhtml#ch13fig01">Figure 13-1</a> <span class="ent">➌</span> would change to look like <a href="ch13.xhtml#ch13fig02">Figure 13-2</a>.</p>&#13;
<div class="image"><a id="ch13fig02"/><img alt="image" src="../images/13fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-2: Two characters overflow from <span class="codeitalic">dest</span> to <span class="codeitalic">src</span></em></p>&#13;
<p class="indent">But what if the developer forgot about the null byte and used the exact length of the string, as follows?</p>&#13;
<pre><span epub:type="pagebreak" id="page_133"/>#include &lt;string.h&gt;<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
int main ()<br/>&#13;
{<br/>&#13;
  char <span class="ent">➊</span>src [12]="hello world!";<br/>&#13;
  char <span class="ent">➋</span>dest[12];<br/>&#13;
  strcpy(dest, src);<br/>&#13;
  printf("src is %s\n", src);<br/>&#13;
  printf("dest is %s\n", dest);<br/>&#13;
  return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The developer counts the number of characters in the string without the null byte and allocates 12 bytes for the <code>src</code> and <code>dest</code> strings at <span class="ent">➊</span> and <span class="ent">➋</span>. The rest of the program copies the <code>src</code> string into <code>dest</code> and prints the results, as the previous programs did. Let’s say the developer runs this code on their 64-bit processor.</p>&#13;
<p class="indent">Because the null byte overflowed from <code>dest</code> in the previous examples, you might expect that <code>src</code> would become an empty string. But the program’s output would be the following:</p>&#13;
<pre>src is hello world!<br/>&#13;
dest is hello world!</pre>&#13;
<p class="indent">On modern 64-bit processors, this code would not cause unexpected behavior or a buffer overflow. The minimum memory allocation on 64-bit machines is 16 bytes (because of memory alignment design, which is beyond the scope of this book). On 32-bit systems, it’s 8 bytes. Because <code>hello world!</code> requires only 13 bytes, including the null byte, it doesn’t overflow the minimum 16 bytes allocated to the <code>dest</code> variable.</p>&#13;
<h3 class="h3" id="ch13lev1sec2"><strong>Read Out of Bounds</strong></h3>&#13;
<p class="noindent">In contrast, the <em>read out of bounds</em> vulnerability can allow attackers to read data outside a memory boundary. This vulnerability occurs when an application reads too much memory for a given variable or action. Reading out of bounds might leak sensitive information.</p>&#13;
<p class="indent">A famous read out of bounds vulnerability is the <em>OpenSSL Heartbleed bug</em>, which was disclosed in April 2014. OpenSSL is a software library that allows application servers to securely communicate over networks without fear of eavesdroppers. Through OpenSSL, applications can identify the server at the other end of the communication. Heartbleed allowed attackers to read arbitrary data during communications, such as server private keys, session data, passwords, and so on, through OpenSSL’s server identification process.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>The vulnerability makes use of OpenSSL’s heartbeat request functionality, which sends a message to a server. The server then returns the same message to the requester to verify that both servers are in communication. Heartbeat requests might include a length parameter, which is the factor that led to the vulnerability. Vulnerable versions of OpenSSL allocated memory for the server’s return message based on the length parameter sent with the request rather than the actual size of the message to be echoed back.</p>&#13;
<p class="indent">As a result, an attacker could exploit Heartbleed by sending a heartbeat request with a large length parameter. Let’s say a message was 100 bytes, and an attacker sent 1,000 bytes as the length of the message. Any vulnerable servers the attacker sent the message to would read the 100 bytes of the intended message and an additional 900 bytes of arbitrary memory. The information included in the arbitrary data depends on the vulnerable server’s running processes and memory layout at the time of the request processing.</p>&#13;
<h3 class="h3" id="ch13lev1sec3"><strong>PHP ftp_genlist() Integer Overflow</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://bugs.php.net/bug.php?id=69545/">https://bugs.php.net/bug.php?id=69545/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 28, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">Languages that manage memory for developers are not immune to memory vulnerabilities. Although PHP automatically manages memory, the language is written in C, which does require memory management. As a result, built-in PHP functions could be vulnerable to memory vulnerabilities. Such was the case when Max Spelsberg discovered a buffer overflow in PHP’s FTP extension.</p>&#13;
<p class="indent">PHP’s FTP extension reads incoming data, such as files, to track the size and number of lines received in the <code>ftp_genlist()</code> function. Variables for size and lines were initialized as unsigned integers. On a 32-bit machine, unsigned integers have a maximum memory allocation of 2<sup>32</sup> bytes (4,294,967,295 bytes or 4GB). So if an attacker sent more than 2<sup>32</sup> bytes, the buffers would overflow.</p>&#13;
<p class="indent">As part of his proof of concept, Spelsberg provided the PHP code to start an FTP server and Python code to connect to it. Once the connection was made, his Python client sent 2<sup>32</sup> + 1 bytes over the socket connection to the FTP server. The PHP FTP server crashed because Spelsberg had overridden memory, similar to what happened in the previously discussed buffer overflow example.</p>&#13;
<h4 class="h4" id="ch13lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Buffer overflows are a well-known and well-documented vulnerability type, but you can still find them in applications that manage their own memory. Even if an application you’re testing isn’t coded in C or C++, you might still <span epub:type="pagebreak" id="page_135"/>discover a buffer overflow if the application is coded in a language that is written in another language vulnerable to memory management bugs. In those cases, look for places where variable length checks have been omitted.</p>&#13;
<h3 class="h3" id="ch13lev1sec4"><strong>Python Hotshot Module</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://bugs.python.org/issue24481">http://bugs.python.org/issue24481</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> June 20, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">Like PHP, the Python programming language is traditionally written in C. In fact, sometimes it’s referred to as CPython (Python versions written in other languages, including Jython, PyPy, and so on, also exist). The Python hotshot module is a replacement for the existing Python profile module. The hotshot module describes how often and for how long various parts of a program execute. Hotshot is written in C, so it has a smaller performance impact than the existing profile module. But in June 2015, John Leitch discovered a buffer overflow in the code that allowed an attacker to copy a string from one memory location to another.</p>&#13;
<p class="indent">The vulnerable code called the method <code>memcpy()</code>, which copies a specified number of bytes of memory from one location to another. For example, the vulnerable code could have looked like the following:</p>&#13;
<pre>memcpy(self-&gt;buffer + self-&gt;index, s, len);</pre>&#13;
<p class="indent">The <code>memcpy()</code> method takes three parameters: a destination, a source, and the number of bytes to copy. In this example, those values are the variables <code>self-&gt;buffer + self-&gt;index</code> (the sum of the buffer and index lengths), <code>s</code>, and <code>len</code>, respectively.</p>&#13;
<p class="indent">The <code>self-&gt;buffer</code> destination variable would always have a fixed length. But <code>s</code>, the source variable, could be any length. This meant that when executing the copy function, <code>memcpy()</code> wouldn’t validate the size of the buffer it was writing to. An attacker could pass the function a string longer than the number of bytes allocated to copy. The string would be written to the destination and overflow, so it would continue writing past the intended buffer and into other memory.</p>&#13;
<h4 class="h4" id="ch13lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">One method of finding buffer overflows is to look for the functions <code>strcpy()</code> and <code>memcpy()</code>. If you find these functions, validate that they have proper buffer length checks. You’ll need to work backward from code that you find to confirm you can control the source and destination to overflow the allocated memory.</p>&#13;
<h3 class="h3" id="ch13lev1sec5"><span epub:type="pagebreak" id="page_136"/><strong>Libcurl Read Out of Bounds</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://curl.haxx.se/docs/adv_20141105.html">http://curl.haxx.se/docs/adv_20141105.html</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> November 5, 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $1,000</p>&#13;
<p class="noindent">Libcurl is a free, client-side URL transfer library that the cURL command line tool uses to transfer data. Symeon Paraschoudis discovered a vulnerability in the libcurl <code>curl_easy_duphandle</code> function that could have been exploited to exfiltrate sensitive data.</p>&#13;
<p class="indent">When performing a transfer with libcurl, you can pass data to send with a <code>POST</code> request using the <code>CURLOPT_POSTFIELDS</code> flag. But performing this action doesn’t guarantee the data will be preserved during the action. To ensure the data is not changed while it’s sent with the <code>POST</code> request, another flag, <code>CURLOPT_COPYPOSTFIELDS</code>, copies the data’s contents and sends the copy with the <code>POST</code> request. The memory area’s size is set through another variable named <code>CURLOPT_POSTFIELDSIZE</code>.</p>&#13;
<p class="indent">To copy the data, cURL would allocate memory. But the internal libcurl function that duplicated the data had two problems: first, copying the <code>POST</code> data incorrectly would cause libcurl to treat the <code>POST</code> data buffer as a C string. Libcurl would assume the <code>POST</code> data ended with a null byte. When the data didn’t, libcurl would continue reading the string beyond the allocated memory until it found a null byte. This could result in libcurl copying a string that was too small (if a null byte was included in the middle of the <code>POST</code> body), too large, or might crash the application. Second, after duplicating the data, libcurl didn’t update where it was supposed to read the data from. This was an issue: between the time libcurl duplicated the data and read from the data, the memory could have been cleared or reused for other purposes. If either of these events happened, the location could have contained data not mean to be sent.</p>&#13;
<h4 class="h4" id="ch13lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">The cURL tool is a very popular and stable library for transferring data over networks. Despite its popularity, it still has bugs. Any functionality involved in copying memory is a great place to begin looking for memory bugs. Like the other memory examples, read out of bounds vulnerabilities are tough to discover. But if you start by searching for commonly vulnerable functions, you’ll be more likely to find a bug.</p>&#13;
<h3 class="h3" id="ch13lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">Memory vulnerabilities can allow attackers to read leaked data or run their own code, but these vulnerabilities are difficult to find. Modern programming languages are less susceptible to memory vulnerabilities because <span epub:type="pagebreak" id="page_137"/>they handle their own memory allocation. But applications written in languages that require the developer to allocate memory are still susceptible to memory bugs. To discover memory vulnerabilities, you need knowledge of memory management, which can be complex and might even depend on hardware. If you want to search for these types of exploits, I recommend you also read other books dedicated entirely to the topic.<span epub:type="pagebreak" id="page_138"/></p>&#13;
</body></html>