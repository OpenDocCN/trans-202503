- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BLACK-BOX TESTING**'
  prefs: []
  type: TYPE_NORMAL
- en: While white-box testing is almost always the best way to security test an application,
    sometimes you simply have to do your testing without source code or insight into
    a program’s design. In these cases, you’ll need to dig a little deeper into the
    guts of iOS, especially into the realm of Objective-C and the Mach-O binary format.
  prefs: []
  type: TYPE_NORMAL
- en: Black-box testing on iOS is a rapidly moving target—it relies on the continuous
    development of jailbreaks, as well as robust third-party tools and debugging implements.
    I’ve tried to make the techniques and tools described in this chapter as future-proof
    as possible to give you a solid foundation to build on.
  prefs: []
  type: TYPE_NORMAL
- en: To effectively black-box test an iOS application, you’ll first need to get a
    jailbroken device so that you can sideload applications and install your testing
    tool chain. The details of jailbreaking change too rapidly for me to document
    here, but you can usually find current information from the iPhone Dev Team^([1](footnote.html#fn37))
    or iClarified.^([2](footnote.html#fn38))
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve jailbroken your device, launch Cydia, choose **Developer** mode,
    and then update your package list (under Changes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can load your device with some testing tools, primarily from the Cydia
    app store. These are the must-haves:'
  prefs: []
  type: TYPE_NORMAL
- en: '**odcctools** This includes otool, lipo, and other development goodies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenSSH** You’ll need this to actually access the device. Be sure to change
    the passwords of your `root` and `mobile` accounts *immediately* using the `passwd(1)`
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MobileTerminal** This will allow you to navigate the command line on the
    device itself, when necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**cURL** You’ll want this for downloading remote files over HTTP or FTP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Erica Utilities** This includes a smattering of useful utilities from Erica
    Sadun. See a detailed list at *[http://ericasadun.com/ftp/EricaUtilities/](http://ericasadun.com/ftp/EricaUtilities/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**vbindiff** This is a binary diff program to help verify changes to binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**netcat** This is your general, all-purpose network listener.'
  prefs: []
  type: TYPE_NORMAL
- en: '**rsync** You can install this for syncing whole directory trees to and from
    the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**tcpdump** You can install this for capturing network traffic dumps for analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IPA Installer Console** This will allow you to directly install *.ipa* files
    copied to the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cydia Substrate** This tool is used for hooking and modifying the behavior
    of applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how you can get these testing tools onto your device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Third-Party Apps**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on how you’ve come to possess your application files, there are a
    couple of ways to sideload them onto your device.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using a .app Directory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’ve acquired a *.app* directory, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, archive your *.app* bundle with `tar`, and use `scp` to copy the archive
    over to your test device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `ssh` to your device and untar the bundle into the */Applications* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should put the application right next to the official Apple-supplied applications.
    To get it to show up on the home screen, you’ll need to either restart the SpringBoard
    or reboot the device. To restart SpringBoard, you can use the `killall` command,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself needing to “respring” a lot, you can use a tool like CCRespring
    from Cydia, as shown in [Figure 6-1](ch06.html#ch6fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A simple respring button added to the Control Center by CCRespring*'
  prefs: []
  type: TYPE_NORMAL
- en: Tools like CCRespring add a button that you can press to restart the SpringBoard
    so you don’t have to go to the command line every time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some have reported that simply respringing the device does not cause the application
    to appear on the SpringBoard. In this case, you can either reboot or run the*
    `*uicache*` *command as the* `*mobile*` *user.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using a .ipa Package File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’ve been given (or have otherwise obtained) a *.ipa* package file, you
    can copy it to your device with `scp` and install it using the `installipa` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Decrypting Binaries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can inspect the contents of binaries, you’ll need to decrypt them.
    There are a couple of ways to do so. The simplest way is to use a prepackaged
    tool, such as Stefan Esser’s dumpdecrypted.^([3](footnote.html#fn39)) This is
    a shared library that is dynamically loaded when executing your application. You
    can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will output a decrypted version of the binary within the *tmp* directory
    of the application’s *.app* bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Because there have been many automated tools for dumping decrypted binaries,
    most of which have become unusable, it’s best to have a backup method. For a more
    robust and (ideally) future-proof way to decrypt binaries and to help you understand
    some of the inner workings of application encryption and decryption, you can use
    command line tools and lldb.^([4](footnote.html#fn40))
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a decrypted binary, you’ll follow these basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the binary to determine the location of its encrypted portion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application under lldb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dump the unencrypted segment to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the original binary for use as a donor file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the donor binary’s `cryptid` flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transplant the unencrypted segment into the donor binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s discuss this decryption process in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***Launching the debugserver on the Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you can get a memory dump, you need to get Apple’s debugserver onto the
    device. The debugserver is in *DeveloperDiskImage.dmg*, buried inside Xcode. From
    the command line, you can attach the disk image and extract the debugserver to
    a local directory, as shown in [Listing 6-1](ch06.html#ch6ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: Extracting the debugserver from the Developer Disk Image*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve copied over the debugserver, you’ll need to edit the entitlements
    of the binary. Normally, when Xcode itself uses the debugserver, it launches applications
    directly; you want to change its permissions to allow it to attach to arbitrary
    running programs on the device. First, generate a plist using the current entitlements
    of the binary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in an XML-formatted plist file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This file needs to be updated to include the `get-task-allow` and `task_for_pid-allow`
    entitlements and remove the `seatbelt-profiles` entitlement. Those updates will
    result in a plist like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the *entitlements.plist* file, you’d use it to sign the application
    (thus overwriting the existing entitlements of the binary) and copy the debugserver
    to the device, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can finally debug the application. Ensure that the program you want
    to debug is currently running on the device and then launch the debugserver to
    attach to it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example debugserver is now listening for a network connection from another
    machine running lldb. Next, on your local machine, you’d connect to the device
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the running program is now interrupted, and at this point,
    you’d be free to manipulate it with lldb on your local machine. To extract the
    decrypted program data, you’d next need to determine which part of the binary
    the encrypted segment resides in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may find that a network connection is too unstable to complete
    the memory dump successfully. If this is the case, you can use the `iproxy` command
    included with usbmuxd to act as a proxy between your USB port and a TCP port,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These commands connect to a network socket with lldb but actually go over the
    USB port.
  prefs: []
  type: TYPE_NORMAL
- en: '***Locating the Encrypted Segment***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To locate the encrypted segment, you’ll require odcctools and lldb. First,
    run `otool -l *myBinary*` and view the output in your favorite pager. You can
    do this either on the device or on your local machine. The copy included with
    OS X has a more modern version of otool that will provide cleaner output. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Mach-O binary format allows for what are called *fat* files, which can contain
    the program compiled for multiple architectures at once (this is how OS X universal
    binaries work). To make reverse engineering easier, you need to work with the
    part of the binary that will be running on your target device; in my case, I have
    an iPhone 5s as a test device, so I want the armv7s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'After determining the architecture, you have a couple of options. You could
    *thin* the binary to include only one architecture using the `lipo(1)` command
    (the `thin` flag specifies which architecture you’re interested in), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But for the purposes of this chapter, I’ll show you how to work with a fat binary.
    First, you’d use otool to determine what the base address of the *text* segment
    of the binary is—this is where the actual executable instructions will be loaded
    into memory—as in [Listing 6-2](ch06.html#ch6ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Finding the base address of the text segment*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that the text segment starts at 0x00004000\. Record this address
    because you’ll need it in a bit. The next step is to determine the beginning and
    end of the encrypted part of the binary. You can do this with otool—note that
    you’ll want to specify the `-arch armv7s` command (or whatever architecture you’re
    using) to ensure that you’re looking at the right section. The output should look
    like [Listing 6-3](ch06.html#ch6ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: otool displaying a binary’s load commands*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of interest here are `cryptoff` and `cryptsize` (`cryptid` simply
    indicates this is an encrypted binary).^([5](footnote.html#fn41)) These indicate
    the address where the encrypted segment of the application begins and the size
    of the segment, respectively. The range between those two numbers will help you
    when dumping memory. These values are in hexadecimal, though—a quick way to obtain
    the hex values is to execute the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the numbers are 0x00004000 and 0x007a0000\. Write these down,
    too. Now, back in [Listing 6-2](ch06.html#ch6ex2), it was determined that the
    text segment in the binary starts at 0x00004000\. However, the text segment probably
    won’t end up there when the program is actually run because ASLR moves portions
    of memory around at random.^([6](footnote.html#fn42)) So check to see where the
    text segment actually got loaded using lldb’s `image list` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the text segment landed at 0x000b2000\. With that address in
    hand, you’re finally ready to extract the executable part of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dumping Application Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at a bit of math to figure out the final offsets. The first step
    is to add the base address to the value of `cryptoff`; in this case, both were
    0x00004000, so the starting number would be 0x00008000\. The ending number would
    be the starting number plus the value of `cryptsize`, which is at 0x007a0000 in
    this example. These particular numbers are pretty easy to add in your head, but
    if you get offsets you can’t figure out easily, you can just use Python to calculate
    it for you, as shown in [Listing 6-4](ch06.html#ch6ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: Adding the starting number and the hexadecimal value of* `cryptsize`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now this example is seriously almost done, I promise. From here, you’d just
    plug your numbers in to the following lldb command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This won’t give you a full, working binary, of course—just a memory dump. The
    image lacks the Mach-O header metadata. To fix this, you’d need to transplant
    the memory dump into a valid binary, and to that end, you’d first make a copy
    of the original binary and use `scp` to copy it to your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you’d copy the contents of the unencrypted memory dump into the donor
    binary, replacing the encrypted segment. You can use `dd` for this, specifying
    the `seek` parameter where it should start writing your data. The `seek` parameter
    should be the value of `vmaddr` added to `cryptoff`, which is 0x8000 in this case.
    Here’s how this example’s `dd` command would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’d have to change the donor binary’s `cryptid` value to 0, indicating
    an unencrypted binary. There are several ways to do this. You can use MachOView^([7](footnote.html#fn43))
    (see [Figure 6-2](ch06.html#ch6fig2)), which provides an easy interface for examining
    and changing Mach-O binaries, or you can use a hex editor of your choice. If you’re
    using a hex editor, I find it easiest to first find the `LC_ENCRYPTION_INFO` command
    by searching for `2100 0000 1400 0000`.^([8](footnote.html#fn44)) The next 16
    numbers will be the offset and size, followed by `0100 0000`. That byte is the
    `cryptid`; change it to `0000 0000`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve disabled the `cryptid` flag, you’d need to copy the modified binary
    back to the device. With the modified binary in place, you can verify the change
    using `vbindiff`, which is available in Homebrew. Output from `vbindiff` should
    appear as shown in [Listing 6-5](ch06.html#ch6ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: The* `encrypted` *flag with MachOView*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/p0089_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Listing 6-5: Verifying the changed* `cryptid` *value with vbindiff*'
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➊ and ➋ show the `cryptid` bit (in bold) enabled and disabled,
    respectively. Now, if all has gone well, you’d be ready to start dissecting the
    binary in earnest.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Engineering from Decrypted Binaries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the rather transparent structure of the Mach-O binary format, basic
    reverse engineering on iOS is a fairly trivial task—at least once you’ve managed
    to obtain a decrypted binary. Several tools can help you understand class definitions,
    examine assembly instructions, and give details on how the binary was built. The
    most useful and easily obtainable ones are otool and class-dump. You’ll also take
    a look at Cycript and Hopper as tools for reversing particularly stubborn applications.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Binaries with otool***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: otool has long been part of the base OS X toolkit for inspecting Mach-O binaries.
    Its current incarnation supports both ARM and amd64 architectures and can optionally
    use llvm to disassemble binaries. To get a basic look at a program’s internals,
    you can use `otool -oV` to view the data segment, as shown in [Listing 6-6](ch06.html#ch6ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: otool displaying the contents of the* `__OBJC` *segment*'
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a view of class and method names, as well as information about
    ivars, provided these are implemented in Objective-C rather than straight C++.
    To view the text segment of a program, you can use `otool -tVq`. The `-q` indicates
    that you want to use llvm as the disassembler rather than otool’s built-in disassembler,
    which is noted by `-Q`. The differences in output are few, but llvm seems best
    suited for the task, given that it likely assembled the binary in the first place.
    It also provides slightly more readable output. [Listing 6-7](ch06.html#ch6ex7)
    shows some example output of `otool -tVq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: otool’s disassembly output*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you see the actual disassembly of methods, as well as some basic symbol
    information. To get a dump of all the symbols, use `otool -IV`, as shown in [Listing
    6-8](ch06.html#ch6ex8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: Inspecting symbols with otool*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Obtaining Class Information with class-dump***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The class-dump^([9](footnote.html#fn45)) tool is used to extract class information
    from Objective-C 2.0 binaries. The resulting output is essentially the equivalent
    of the header files of a given binary. This can give excellent insight into the
    design and structure of a program, making class-dump an invaluable tool for reverse
    engineering. The original class-dump by Steve Nygard runs only on OS X but recognizes
    the armv7 architecture, so you can copy files over to your desktop for analysis.
    There is also a modified version, class-dump-z,^([10](footnote.html#fn46)) that
    can run on Linux and iOS. As of this writing, class-dump appears to be more up-to-date
    and functional, so I recommend sticking with it.
  prefs: []
  type: TYPE_NORMAL
- en: You can test class-dump against any unencrypted iOS binary. The quickest way
    to get a feel for it is to copy over one of the built-in Apple apps in */Applications*
    and run class-dump on the binary, as shown in [Listing 6-9](ch06.html#ch6ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: class-dump Showing the Interface Details of MobileMail*'
  prefs: []
  type: TYPE_NORMAL
- en: Delightful, no? Once you have a decrypted binary, most Objective-C applications
    become transparent pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extracting Data from Running Programs with Cycript***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t want to go through the hassle of decrypting a binary to get information
    about its internals, you can use Cycript^([11](footnote.html#fn47)) to extract
    some of this information from a running executable. There are many tricks to interact
    with running applications using Cycript, but you’ll probably be most interested
    in using *weak_classdump.cy*^([12](footnote.html#fn48)) to approximate the functionality
    of class-dump. With the Contacts application running, you can extract class-dump
    information thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will write out header files for each class into the */tmp/contactsbundle*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in order to securely fetch things with cURL, you’ll need to install
    a CA certificate bundle on the device. If you use MacPorts and have cURL installed
    locally, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you use Homebrew and have the OpenSSL formula installed, you can use
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '***Disassembly with Hopper***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There will likely be some situations where you need to get a closer view of
    a program’s actual logic, in the absence of source code. While IDA Pro^([13](footnote.html#fn49))
    is useful for this, it’s rather expensive. I usually use Hopper^([14](footnote.html#fn50))
    for disassembling, decompiling, and making flow graphs during black-box testing.
    While assembly language and decompiling are somewhat outside the scope of this
    book, let’s take a quick look at what Hopper can show you about a program’s logic.
    Looking at a basic password manager in Hopper ([Figure 6-3](ch06.html#ch6fig3)),
    you will find a method called `storeSavedKeyFor:`, which looks promising.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The disassembly of the* `storeSavedKeyFor:` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: If you call the decompiler (the `if(b)` button) on this particular section of
    code, Hopper will generate pseudocode to give you an idea of actual program flow,
    as shown in [Figure 6-4](ch06.html#ch6fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Code generated by the decompiler*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `PearlLogger` class is being instantiated, and there’s a reference
    to the username for which the current item is being stored. `var_64` shows that
    this username is getting passed to the logging function, probably to the NSLog
    facility—this is bad, for reasons I’ll explain further in [Chapter 10](ch10.html#ch10).
    However, you can also see that the item is being stored in the Keychain with a
    restrictive protection attribute (`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`,
    further detailed in [Chapter 13](ch13.html#ch13)), which is a point in the program’s
    favor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly language and decompilation are broad areas, but Hopper gives you a
    great way to get started with reverse engineering via assembly for a fairly low
    price. If you’d like to get started developing your skills reading ARM assembly,
    check out Ray Wenderlich’s tutorial: *[http://www.raywenderlich.com/37181/ios-assembly-tutorial/](http://www.raywenderlich.com/37181/ios-assembly-tutorial/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Certificate Pinning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certificate pinning aims to prevent a rogue CA from signing a fake (but valid-looking)
    certificate for your site, with the purpose of intercepting communications between
    your network endpoint and the application. This is quite a good idea (and I’ll
    discuss how to implement it in [Chapter 7](ch07.html#ch07)), but it does of course
    make black-box testing slightly more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'My colleagues and I ran into this problem frequently enough that we wrote a
    tool to help us with it: the iOS SSL Killswitch.^([15](footnote.html#fn51)) The
    Killswitch tool hooks requests going through the URL loading system to prevent
    the validation of any SSL certificates, ensuring that you can run any black-box
    application through your proxy regardless of whether it uses certificate pinning.'
  prefs: []
  type: TYPE_NORMAL
- en: To install the Killswitch tool, copy the precompiled *.deb* file to your device
    and install it with the dpkg tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You should then find iOS SSL Killswitch in your Settings application (see [Figure
    6-5](ch06.html#ch6fig5)), where you can toggle it on and off.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Enabling the SSL Killswitch tool from within the Settings application*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hooking with Cydia Substrate**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On jailbroken devices (which you’ll be performing your black-box testing on),
    you can use Cydia Substrate^([16](footnote.html#fn52)) (formerly known as Mobile
    Substrate) to modify the behavior of the base system to give you additional information
    on your application’s activity or change application behavior. Your goals may
    be to disable certain security or validation mechanisms (like the iOS SSL Killswitch
    does) or to simply notify you when certain APIs are used, along with the arguments
    passed to them. Cydia Substrate hooks are referred to as *tweaks*.
  prefs: []
  type: TYPE_NORMAL
- en: The most user-friendly way to get started with developing Cydia Substrate tweaks
    is to use the Theos toolkit.^([17](footnote.html#fn53)) To create a new tweak,
    use the *nic.pl* script included with Theos. Note that Theos is by default oriented
    toward tweaking the behavior of the SpringBoard application in order to customize
    user interface elements. For the purposes described in this book, though, you’ll
    want to affect all applications, so you’d specify a Bundle filter of `com.apple.UIKit`.
    This filter will configure Mobile/Cydia Substrate to load your tweak in any application
    that links to the UIKit framework (that is, applications displaying a user interface)
    but not other programs like system daemons or command line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to acquire the Link Identity Editor, ldid,^([18](footnote.html#fn54))
    which Theos uses to generate the signature and entitlements for a tweak. Here’s
    how to get ldid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then clone the Theos repo and proceed to generate a tweak template,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will create a *Tweak.xm* file, with all of its contents commented out by
    default. Stubs are included for hooking either class methods or instance methods,
    with or without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest type of hook you can write is one that just logs method calls
    and arguments; here’s an example that hooks two class methods of `UIPasteboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet uses Logos^([19](footnote.html#fn55)) directives such as `%hook`
    and `%log`. Logos is a component of Theos designed to allow method-hooking code
    to be written easily. However, it is possible to write a tweak with the same functionality
    using only C instead.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to provide the full method signature as well, which you can obtain
    either from API documentation or from framework header files. Once you’ve customized
    your tweak to your satisfaction, you can build it using the Makefile provided
    by *nic.pl*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a Debian package suitable for installation onto a jailbroken device,
    you’ll also need to install the dpkg tool. You can do this either with the MacPorts^([20](footnote.html#fn56))
    `port` command or with Homebrew’s^([21](footnote.html#fn57)) `brew` command. This
    example uses `port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Running these commands should result in a package that can be installed on your
    iOS device. First, you’d use the `scp` command to copy the file over to the device
    and load it manually. After that, you could simply use `dpkg -i` from the command
    line (as shown in the following code) or set up your own Cydia repository.^([22](footnote.html#fn58))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When this finishes, you can either manage the package further with the `dpkg`
    command (removing it with `dpkg -P`) or manage it via Cydia, as shown in [Figure
    6-6](ch06.html#ch6fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Your very own tweak in the Cydia management interface*'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a tweak is installed, if you examine the system log, you’ll see the Cydia
    Substrate dynamic library being loaded upon launch of all applications. You’ll
    also see the hooked method calls being logged by the tweak. Here’s an example
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are, of course, many other things you can do with tweaks besides logging;
    see the *Tweak.xm* file of the iOS SSL Killswitch tool for an example of modifying
    method behavior, along with your own preference toggle.^([23](footnote.html#fn59))
  prefs: []
  type: TYPE_NORMAL
- en: '**Automating Hooking with Introspy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While tweaks are useful for one-off hooking scenarios, my colleagues Alban Diquet
    and Tom Daniels have used the Cydia Substrate framework to make a tool called
    Intropsy^([24](footnote.html#fn60)) that can help automate the hooking process
    for black-box testing without having to dig too deep in to the guts of iOS or
    Cydia Substratey. Introspy uses the Cydia Substrate framework directly (rather
    than via Theos) to hook security-sensitive method calls, logging their arguments
    and return values in a format that can subsequently be used to generate reports.
    To install Introspy, download the latest precompiled *.deb* package from *[https://github.com/iSECPartners/Introspy-iOS/releases/](https://github.com/iSECPartners/Introspy-iOS/releases/)*,
    copy it to your device, and enter the command `dpkg -i *filename*` on the device
    to add the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, respring the device using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Do the same for any application that you want to test, if it’s already running.
    You can now tell Introspy what applications you want to hook, along with which
    API calls you’d like to record (see [Figure 6-7](ch06.html#ch6fig7)). Once your
    testing is complete, a SQLite database file will be deposited in */var/mobile*
    if you’re testing Apple built-in or Cydia applications, or in */User/Applications/<AppID>*
    if you’re testing an application that came from the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: The Introspy settings screen. You can select which applications
    are profiled on the Apps tab.*'
  prefs: []
  type: TYPE_NORMAL
- en: To analyze this database, you’ll want to use the Introspy Analyzer,^([25](footnote.html#fn61))
    which will generate HTML reports of Introspy’s findings (see [Figure 6-8](ch06.html#ch6fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: The Introspy HTML report output, showing a list of findings that
    match the specified signatures*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you copy this database onto your test machine, you can create a report on
    the called APIs using *introspy.py*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Newer versions of Introspy also allow automatic copying and parsing of the database,
    by specifying the IP address of the device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Running Introspy will evaluate the calls against a signature database of potentially
    problematic APIs, helping you track down potential areas of interest. To cut down
    on noise, you can filter out specific API categories or signature types with the
    `--group` and `--sub-group` flags. With Introspy installed, enter `introspy.py
    --help` at the command line for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While black-box testing poses some challenges, the development community has
    gone a long way to making it feasible, and some elements of black-box testing
    will help you regardless of whether you have source code. You will now turn your
    primary attention back to white-box testing; in [Chapter 7](ch07.html#ch07), I’ll
    guide you through some of the most security-sensitive APIs in iOS, including IPC
    mechanisms, cryptographic facilities, and the myriad ways in which data can leak
    from applications unintentionally.
  prefs: []
  type: TYPE_NORMAL
