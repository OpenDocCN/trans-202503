- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**BLACK-BOX TESTING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒测试**'
- en: While white-box testing is almost always the best way to security test an application,
    sometimes you simply have to do your testing without source code or insight into
    a program’s design. In these cases, you’ll need to dig a little deeper into the
    guts of iOS, especially into the realm of Objective-C and the Mach-O binary format.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然白盒测试几乎总是进行安全测试时最好的方式，但有时候你只能在没有源代码或对程序设计的了解的情况下进行测试。在这些情况下，你需要深入了解iOS的内部，特别是Objective-C和Mach-O二进制格式的领域。
- en: Black-box testing on iOS is a rapidly moving target—it relies on the continuous
    development of jailbreaks, as well as robust third-party tools and debugging implements.
    I’ve tried to make the techniques and tools described in this chapter as future-proof
    as possible to give you a solid foundation to build on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的黑盒测试是一个快速变化的目标——它依赖于越狱的持续发展，以及强大的第三方工具和调试工具。我尽力将本章中描述的技巧和工具尽可能地做成未来-proof，以为你提供一个坚实的基础。
- en: To effectively black-box test an iOS application, you’ll first need to get a
    jailbroken device so that you can sideload applications and install your testing
    tool chain. The details of jailbreaking change too rapidly for me to document
    here, but you can usually find current information from the iPhone Dev Team^([1](footnote.html#fn37))
    or iClarified.^([2](footnote.html#fn38))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地进行iOS应用程序的黑盒测试，你首先需要获得一个越狱设备，这样你才能侧载应用程序并安装你的测试工具链。越狱的细节变化太快，我无法在这里记录，但你通常可以从iPhone
    Dev Team^([1](footnote.html#fn37))或iClarified.^([2](footnote.html#fn38))找到最新信息。
- en: Once you’ve jailbroken your device, launch Cydia, choose **Developer** mode,
    and then update your package list (under Changes).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你越狱了你的设备，启动Cydia，选择**开发者**模式，然后更新你的软件包列表（在“更改”选项卡下）。
- en: 'Now you can load your device with some testing tools, primarily from the Cydia
    app store. These are the must-haves:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在设备上加载一些测试工具，主要来自Cydia应用商店。以下是必备工具：
- en: '**odcctools** This includes otool, lipo, and other development goodies.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**odcctools** 包括otool、lipo以及其他开发工具。'
- en: '**OpenSSH** You’ll need this to actually access the device. Be sure to change
    the passwords of your `root` and `mobile` accounts *immediately* using the `passwd(1)`
    command.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSH** 你需要这个工具来实际访问设备。务必使用`passwd(1)`命令*立即*更改`root`和`mobile`账户的密码。'
- en: '**MobileTerminal** This will allow you to navigate the command line on the
    device itself, when necessary.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**MobileTerminal** 这将允许你在设备本地使用命令行，必要时使用。'
- en: '**cURL** You’ll want this for downloading remote files over HTTP or FTP.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**cURL** 你会需要这个工具来通过HTTP或FTP下载远程文件。'
- en: '**Erica Utilities** This includes a smattering of useful utilities from Erica
    Sadun. See a detailed list at *[http://ericasadun.com/ftp/EricaUtilities/](http://ericasadun.com/ftp/EricaUtilities/)*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Erica Utilities** 这个工具包包括了Erica Sadun的一些有用工具。可以在*[http://ericasadun.com/ftp/EricaUtilities/](http://ericasadun.com/ftp/EricaUtilities/)*查看详细列表。'
- en: '**vbindiff** This is a binary diff program to help verify changes to binaries.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**vbindiff** 这是一个二进制差异程序，用来验证二进制文件的变化。'
- en: '**netcat** This is your general, all-purpose network listener.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**netcat** 这是一个通用的网络监听工具。'
- en: '**rsync** You can install this for syncing whole directory trees to and from
    the device.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**rsync** 你可以安装这个工具来同步整个目录树到设备或者从设备同步。'
- en: '**tcpdump** You can install this for capturing network traffic dumps for analysis.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**tcpdump** 你可以安装这个工具来捕获网络流量数据包进行分析。'
- en: '**IPA Installer Console** This will allow you to directly install *.ipa* files
    copied to the device.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPA安装控制台** 这个工具将允许你直接安装复制到设备上的*.ipa*文件。'
- en: '**Cydia Substrate** This tool is used for hooking and modifying the behavior
    of applications.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cydia Substrate** 这个工具用于挂钩和修改应用程序的行为。'
- en: Now, let’s look at how you can get these testing tools onto your device.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何将这些测试工具安装到你的设备上。
- en: '**Installing Third-Party Apps**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装第三方应用**'
- en: Depending on how you’ve come to possess your application files, there are a
    couple of ways to sideload them onto your device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是如何获得应用程序文件的，有几种方法可以将它们侧载到你的设备上。
- en: '***Using a .app Directory***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 .app 目录***'
- en: 'If you’ve acquired a *.app* directory, you can do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你获得了一个*.app*目录，你可以进行如下操作：
- en: 'First, archive your *.app* bundle with `tar`, and use `scp` to copy the archive
    over to your test device, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用`tar`命令打包你的*.app*包，并使用`scp`将压缩包复制到你的测试设备上，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then `ssh` to your device and untar the bundle into the */Applications* directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`ssh`连接到你的设备，并将压缩包解压到*/Applications*目录：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should put the application right next to the official Apple-supplied applications.
    To get it to show up on the home screen, you’ll need to either restart the SpringBoard
    or reboot the device. To restart SpringBoard, you can use the `killall` command,
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该能将应用程序放置在与苹果官方应用程序相邻的位置。为了使其出现在主屏幕上，您需要重新启动SpringBoard或重启设备。要重启SpringBoard，您可以使用`killall`命令，像这样：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you find yourself needing to “respring” a lot, you can use a tool like CCRespring
    from Cydia, as shown in [Figure 6-1](ch06.html#ch6fig1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己经常需要“重新启动SpringBoard”，可以使用像Cydia中的CCRespring这样的工具，如[Figure 6-1](ch06.html#ch6fig1)所示。
- en: '![image](graphics/f06-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-01.jpg)'
- en: '*Figure 6-1: A simple respring button added to the Control Center by CCRespring*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-1：CCRespring在控制中心添加的简单重启按钮*'
- en: Tools like CCRespring add a button that you can press to restart the SpringBoard
    so you don’t have to go to the command line every time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像CCRespring这样的工具添加了一个按钮，您可以按下它来重新启动SpringBoard，这样您就不需要每次都去命令行了。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some have reported that simply respringing the device does not cause the application
    to appear on the SpringBoard. In this case, you can either reboot or run the*
    `*uicache*` *command as the* `*mobile*` *user.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*有些人报告说，仅仅重新启动设备并不会导致应用程序出现在SpringBoard上。在这种情况下，您可以选择重新启动设备或作为`*mobile*`用户运行`*uicache*`命令。*'
- en: '***Using a .ipa Package File***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用.ipa包文件***'
- en: 'If you’ve been given (or have otherwise obtained) a *.ipa* package file, you
    can copy it to your device with `scp` and install it using the `installipa` command,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经获得（或通过其他方式获取）一个*.ipa*包文件，您可以使用`scp`将其复制到设备中，并使用`installipa`命令进行安装，方法如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Decrypting Binaries**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解密二进制文件**'
- en: 'Before you can inspect the contents of binaries, you’ll need to decrypt them.
    There are a couple of ways to do so. The simplest way is to use a prepackaged
    tool, such as Stefan Esser’s dumpdecrypted.^([3](footnote.html#fn39)) This is
    a shared library that is dynamically loaded when executing your application. You
    can use it as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在您检查二进制文件的内容之前，您需要先解密它们。有几种方法可以实现这一点。最简单的方法是使用预打包的工具，如Stefan Esser的dumpdecrypted。^([3](footnote.html#fn39))
    这是一个共享库，在执行您的应用程序时动态加载。您可以按如下方式使用它：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will output a decrypted version of the binary within the *tmp* directory
    of the application’s *.app* bundle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个解密后的二进制文件，存放在应用程序的*.app*包的*tmp*目录中。
- en: Because there have been many automated tools for dumping decrypted binaries,
    most of which have become unusable, it’s best to have a backup method. For a more
    robust and (ideally) future-proof way to decrypt binaries and to help you understand
    some of the inner workings of application encryption and decryption, you can use
    command line tools and lldb.^([4](footnote.html#fn40))
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为已经有很多自动化工具可以用于提取解密二进制文件，其中大多数已经无法使用，最好有一个备份方法。为了更稳健和（理想情况下）更具未来兼容性地解密二进制文件，并帮助您理解一些应用加密和解密的内部工作原理，您可以使用命令行工具和lldb。^([4](footnote.html#fn40))
- en: 'To create a decrypted binary, you’ll follow these basic steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建解密后的二进制文件，您将遵循以下基本步骤：
- en: Analyze the binary to determine the location of its encrypted portion.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析二进制文件，确定其加密部分的位置。
- en: Run the application under lldb.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在lldb下运行应用程序。
- en: Dump the unencrypted segment to disk.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未加密的部分转储到磁盘。
- en: Copy the original binary for use as a donor file.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制原始二进制文件作为目标文件使用。
- en: Remove the donor binary’s `cryptid` flag.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除目标二进制文件中的`cryptid`标志。
- en: Transplant the unencrypted segment into the donor binary.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未加密的部分移植到目标二进制文件中。
- en: Let’s discuss this decryption process in more detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这个解密过程。
- en: '***Launching the debugserver on the Device***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在设备上启动debugserver***'
- en: Before you can get a memory dump, you need to get Apple’s debugserver onto the
    device. The debugserver is in *DeveloperDiskImage.dmg*, buried inside Xcode. From
    the command line, you can attach the disk image and extract the debugserver to
    a local directory, as shown in [Listing 6-1](ch06.html#ch6ex1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在您获取内存转储之前，您需要将Apple的debugserver放到设备上。debugserver位于*DeveloperDiskImage.dmg*中，深藏在Xcode内。通过命令行，您可以挂载磁盘镜像并将debugserver提取到本地目录，如[Listing
    6-1](ch06.html#ch6ex1)所示。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-1: Extracting the debugserver from the Developer Disk Image*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-1：从Developer Disk Image提取debugserver*'
- en: 'Once you’ve copied over the debugserver, you’ll need to edit the entitlements
    of the binary. Normally, when Xcode itself uses the debugserver, it launches applications
    directly; you want to change its permissions to allow it to attach to arbitrary
    running programs on the device. First, generate a plist using the current entitlements
    of the binary, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你复制了调试服务器，你需要编辑二进制文件的权限。通常，当Xcode本身使用调试服务器时，它会直接启动应用程序；你需要更改它的权限，以便它可以附加到设备上的任意运行程序。首先，使用二进制文件的当前权限生成一个plist，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should result in an XML-formatted plist file with the following contents:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个XML格式的plist文件，内容如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This file needs to be updated to include the `get-task-allow` and `task_for_pid-allow`
    entitlements and remove the `seatbelt-profiles` entitlement. Those updates will
    result in a plist like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件需要更新，以包含`get-task-allow`和`task_for_pid-allow`权限，并删除`seatbelt-profiles`权限。这些更新将导致一个像下面这样的plist：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After updating the *entitlements.plist* file, you’d use it to sign the application
    (thus overwriting the existing entitlements of the binary) and copy the debugserver
    to the device, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更新*entitlements.plist*文件后，你需要使用它来对应用进行签名（从而覆盖二进制文件的现有权限），并将调试服务器复制到设备上，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can finally debug the application. Ensure that the program you want
    to debug is currently running on the device and then launch the debugserver to
    attach to it, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你终于可以调试应用程序了。确保你想要调试的程序当前在设备上运行，然后启动调试服务器以附加到它，像这样：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example debugserver is now listening for a network connection from another
    machine running lldb. Next, on your local machine, you’d connect to the device
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调试服务器现在正在等待来自另一台运行lldb的机器的网络连接。接下来，在你的本地机器上，你可以按以下方式连接到设备：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the running program is now interrupted, and at this point,
    you’d be free to manipulate it with lldb on your local machine. To extract the
    decrypted program data, you’d next need to determine which part of the binary
    the encrypted segment resides in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，正在运行的程序被中断，此时你可以在本地机器上使用lldb对其进行操作。要提取解密后的程序数据，接下来你需要确定二进制文件中加密段所在的部分。
- en: 'Note that you may find that a network connection is too unstable to complete
    the memory dump successfully. If this is the case, you can use the `iproxy` command
    included with usbmuxd to act as a proxy between your USB port and a TCP port,
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可能会发现网络连接不稳定，无法成功完成内存转储。如果是这种情况，你可以使用`iproxy`命令（usbuxmd自带的命令）作为USB端口和TCP端口之间的代理，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These commands connect to a network socket with lldb but actually go over the
    USB port.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令连接到一个网络套接字并使用lldb，但实际上是通过USB端口进行通信的。
- en: '***Locating the Encrypted Segment***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定位加密段***'
- en: 'To locate the encrypted segment, you’ll require odcctools and lldb. First,
    run `otool -l *myBinary*` and view the output in your favorite pager. You can
    do this either on the device or on your local machine. The copy included with
    OS X has a more modern version of otool that will provide cleaner output. Here’s
    an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位加密段，你需要使用odcctools和lldb。首先，运行`otool -l *myBinary*`并在你喜欢的分页器中查看输出。你可以在设备上或者本地机器上执行此操作。OS
    X自带的版本包含一个更新的otool，可以提供更清晰的输出。以下是一个示例：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Mach-O binary format allows for what are called *fat* files, which can contain
    the program compiled for multiple architectures at once (this is how OS X universal
    binaries work). To make reverse engineering easier, you need to work with the
    part of the binary that will be running on your target device; in my case, I have
    an iPhone 5s as a test device, so I want the armv7s architecture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Mach-O二进制格式允许创建所谓的*fat*文件，这些文件可以包含针对多个架构编译的程序（这就是OS X通用二进制文件的工作方式）。为了简化逆向工程，你需要处理将在目标设备上运行的二进制部分；在我的例子中，我使用的是iPhone
    5s作为测试设备，因此我需要armv7s架构。
- en: 'After determining the architecture, you have a couple of options. You could
    *thin* the binary to include only one architecture using the `lipo(1)` command
    (the `thin` flag specifies which architecture you’re interested in), like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确定架构后，你有几个选择。你可以使用`lipo(1)`命令将二进制文件*瘦身*，仅包含一个架构（`thin`标志指定你感兴趣的架构），像这样：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But for the purposes of this chapter, I’ll show you how to work with a fat binary.
    First, you’d use otool to determine what the base address of the *text* segment
    of the binary is—this is where the actual executable instructions will be loaded
    into memory—as in [Listing 6-2](ch06.html#ch6ex2).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了本章的目的，我将展示如何处理 fat 二进制文件。首先，你需要使用 otool 来确定二进制文件中 *文本* 段的基址——这是实际的可执行指令将被加载到内存中的位置——正如在[示例
    6-2](ch06.html#ch6ex2)中所示。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-2: Finding the base address of the text segment*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-2：查找文本段的基址*'
- en: You can see here that the text segment starts at 0x00004000\. Record this address
    because you’ll need it in a bit. The next step is to determine the beginning and
    end of the encrypted part of the binary. You can do this with otool—note that
    you’ll want to specify the `-arch armv7s` command (or whatever architecture you’re
    using) to ensure that you’re looking at the right section. The output should look
    like [Listing 6-3](ch06.html#ch6ex3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到文本段从 0x00004000 开始。记下这个地址，因为稍后你会用到它。下一步是确定二进制文件加密部分的起始和结束位置。你可以通过 otool
    来完成此操作——注意你需要指定 `-arch armv7s` 命令（或者根据你使用的架构来指定），以确保你查看的是正确的部分。输出应该像[示例 6-3](ch06.html#ch6ex3)所示。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-3: otool displaying a binary’s load commands*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-3：otool 显示二进制文件的加载命令*'
- en: 'The values of interest here are `cryptoff` and `cryptsize` (`cryptid` simply
    indicates this is an encrypted binary).^([5](footnote.html#fn41)) These indicate
    the address where the encrypted segment of the application begins and the size
    of the segment, respectively. The range between those two numbers will help you
    when dumping memory. These values are in hexadecimal, though—a quick way to obtain
    the hex values is to execute the following in the Terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要关注的值是 `cryptoff` 和 `cryptsize`（`cryptid` 仅表示这是一个加密的二进制文件）。^([5](footnote.html#fn41))
    它们分别表示应用程序加密段的起始地址和段的大小。它们之间的范围将帮助你在转储内存时使用。这些值是十六进制的——获取十六进制值的一种快速方法是执行以下命令：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, the numbers are 0x00004000 and 0x007a0000\. Write these down,
    too. Now, back in [Listing 6-2](ch06.html#ch6ex2), it was determined that the
    text segment in the binary starts at 0x00004000\. However, the text segment probably
    won’t end up there when the program is actually run because ASLR moves portions
    of memory around at random.^([6](footnote.html#fn42)) So check to see where the
    text segment actually got loaded using lldb’s `image list` command, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数字是 0x00004000 和 0x007a0000。也请将这些记下来。现在，回到[示例 6-2](ch06.html#ch6ex2)，已经确定二进制文件中的文本段从
    0x00004000 开始。然而，文本段在程序实际运行时可能不会停留在这里，因为 ASLR 会随机移动内存中的某些部分。^([6](footnote.html#fn42))
    所以，请检查文本段实际加载的位置，使用 lldb 的 `image list` 命令，如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that the text segment landed at 0x000b2000\. With that address in
    hand, you’re finally ready to extract the executable part of the binary.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到文本段加载到了 0x000b2000。掌握了这个地址后，你终于可以提取二进制文件的可执行部分了。
- en: '***Dumping Application Memory***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***转储应用程序内存***'
- en: Let’s look at a bit of math to figure out the final offsets. The first step
    is to add the base address to the value of `cryptoff`; in this case, both were
    0x00004000, so the starting number would be 0x00008000\. The ending number would
    be the starting number plus the value of `cryptsize`, which is at 0x007a0000 in
    this example. These particular numbers are pretty easy to add in your head, but
    if you get offsets you can’t figure out easily, you can just use Python to calculate
    it for you, as shown in [Listing 6-4](ch06.html#ch6ex4).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看点数学运算来确定最终的偏移量。第一步是将基址与 `cryptoff` 的值相加；在这种情况下，两者都是 0x00004000，所以起始数字将是
    0x00008000。结束数字将是起始数字加上 `cryptsize` 的值，在这个例子中，`cryptsize` 位于 0x007a0000。这些数字相加起来比较简单，但如果你遇到无法轻易计算的偏移量，你可以使用
    Python 来为你计算，如[示例 6-4](ch06.html#ch6ex4)所示。
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-4: Adding the starting number and the hexadecimal value of* `cryptsize`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-4：添加起始数字和 `cryptsize` 的十六进制值*'
- en: 'Now this example is seriously almost done, I promise. From here, you’d just
    plug your numbers in to the following lldb command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这个例子真的差不多完成了，别担心。从这里，你只需要将你的数字插入以下 lldb 命令中：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This won’t give you a full, working binary, of course—just a memory dump. The
    image lacks the Mach-O header metadata. To fix this, you’d need to transplant
    the memory dump into a valid binary, and to that end, you’d first make a copy
    of the original binary and use `scp` to copy it to your development machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不会给你一个完整、可用的二进制文件——只是一个内存转储。这个映像缺少Mach-O头部的元数据。为了解决这个问题，你需要将内存转储移植到一个有效的二进制文件中，为此，你首先需要复制原始二进制文件，并使用`scp`将其复制到你的开发机上。
- en: 'Then, you’d copy the contents of the unencrypted memory dump into the donor
    binary, replacing the encrypted segment. You can use `dd` for this, specifying
    the `seek` parameter where it should start writing your data. The `seek` parameter
    should be the value of `vmaddr` added to `cryptoff`, which is 0x8000 in this case.
    Here’s how this example’s `dd` command would look:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将未加密的内存转储内容复制到捐赠二进制文件中，替换掉加密的部分。你可以使用`dd`命令来完成此操作，并指定`seek`参数来确定数据开始写入的位置。`seek`参数应该是`vmaddr`加上`cryptoff`的值，在这个例子中是0x8000。以下是这个例子中的`dd`命令：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, you’d have to change the donor binary’s `cryptid` value to 0, indicating
    an unencrypted binary. There are several ways to do this. You can use MachOView^([7](footnote.html#fn43))
    (see [Figure 6-2](ch06.html#ch6fig2)), which provides an easy interface for examining
    and changing Mach-O binaries, or you can use a hex editor of your choice. If you’re
    using a hex editor, I find it easiest to first find the `LC_ENCRYPTION_INFO` command
    by searching for `2100 0000 1400 0000`.^([8](footnote.html#fn44)) The next 16
    numbers will be the offset and size, followed by `0100 0000`. That byte is the
    `cryptid`; change it to `0000 0000`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将捐赠二进制文件的`cryptid`值更改为0，表示未加密的二进制文件。这个操作有几种方法。你可以使用MachOView^([7](footnote.html#fn43))（见[图6-2](ch06.html#ch6fig2)），它提供了一个易于使用的界面来检查和修改Mach-O二进制文件，或者你也可以使用你选择的十六进制编辑器。如果你使用十六进制编辑器，我发现最简单的方法是首先通过搜索`2100
    0000 1400 0000`来找到`LC_ENCRYPTION_INFO`命令。^([8](footnote.html#fn44)) 接下来的16个数字将是偏移量和大小，后面跟着`0100
    0000`。那个字节就是`cryptid`，将其更改为`0000 0000`。
- en: Once you’ve disabled the `cryptid` flag, you’d need to copy the modified binary
    back to the device. With the modified binary in place, you can verify the change
    using `vbindiff`, which is available in Homebrew. Output from `vbindiff` should
    appear as shown in [Listing 6-5](ch06.html#ch6ex5).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你禁用了`cryptid`标志，你需要将修改后的二进制文件复制回设备。将修改后的二进制文件放置好后，你可以使用`vbindiff`验证更改，`vbindiff`可以通过Homebrew安装。`vbindiff`的输出应该如下所示，见[清单
    6-5](ch06.html#ch6ex5)。
- en: '![image](graphics/f06-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-02.jpg)'
- en: '*Figure 6-2: The* `encrypted` *flag with MachOView*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：使用MachOView查看`encrypted`标志*'
- en: '![image](graphics/p0089_01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/p0089_01.jpg)'
- en: '*Listing 6-5: Verifying the changed* `cryptid` *value with vbindiff*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-5：使用vbindiff验证更改后的`cryptid`值*'
- en: The lines at ➊ and ➋ show the `cryptid` bit (in bold) enabled and disabled,
    respectively. Now, if all has gone well, you’d be ready to start dissecting the
    binary in earnest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ➊和➋处的行分别显示了启用和禁用的`cryptid`位（加粗显示）。现在，如果一切顺利，你就可以开始认真地解剖这个二进制文件了。
- en: '**Reverse Engineering from Decrypted Binaries**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从解密二进制文件进行逆向工程**'
- en: Because of the rather transparent structure of the Mach-O binary format, basic
    reverse engineering on iOS is a fairly trivial task—at least once you’ve managed
    to obtain a decrypted binary. Several tools can help you understand class definitions,
    examine assembly instructions, and give details on how the binary was built. The
    most useful and easily obtainable ones are otool and class-dump. You’ll also take
    a look at Cycript and Hopper as tools for reversing particularly stubborn applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mach-O二进制格式结构相对透明，在iOS上进行基本的逆向工程是一个相当简单的任务——至少在你获得解密后的二进制文件后。几种工具可以帮助你理解类定义、检查汇编指令，并提供有关二进制文件构建的详细信息。最有用且容易获得的工具是otool和class-dump。你还可以查看Cycript和Hopper，作为逆向特别顽固应用程序的工具。
- en: '***Inspecting Binaries with otool***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用otool检查二进制文件***'
- en: otool has long been part of the base OS X toolkit for inspecting Mach-O binaries.
    Its current incarnation supports both ARM and amd64 architectures and can optionally
    use llvm to disassemble binaries. To get a basic look at a program’s internals,
    you can use `otool -oV` to view the data segment, as shown in [Listing 6-6](ch06.html#ch6ex6).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: otool长期以来一直是基本OS X工具包的一部分，用于检查Mach-O二进制文件。它的当前版本支持ARM和amd64架构，并可以选择使用llvm来反汇编二进制文件。要查看程序的基本内部结构，你可以使用`otool
    -oV`命令查看数据段，如[清单6-6](ch06.html#ch6ex6)所示。
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 6-6: otool displaying the contents of the* `__OBJC` *segment*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-6：otool显示`__OBJC`段的内容*'
- en: This gives you a view of class and method names, as well as information about
    ivars, provided these are implemented in Objective-C rather than straight C++.
    To view the text segment of a program, you can use `otool -tVq`. The `-q` indicates
    that you want to use llvm as the disassembler rather than otool’s built-in disassembler,
    which is noted by `-Q`. The differences in output are few, but llvm seems best
    suited for the task, given that it likely assembled the binary in the first place.
    It also provides slightly more readable output. [Listing 6-7](ch06.html#ch6ex7)
    shows some example output of `otool -tVq`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你能够查看类名和方法名，以及 ivars 的信息，前提是这些是在 Objective-C 中实现的，而不是纯 C++。要查看程序的文本段，可以使用
    `otool -tVq`。`-q` 表示你希望使用 llvm 作为反汇编器，而不是 otool 内置的反汇编器，后者通过 `-Q` 指定。输出的差异不大，但
    llvm 看起来最适合执行此任务，因为它很可能最初就负责将二进制文件汇编起来。它还提供了稍微更易读的输出。[清单 6-7](ch06.html#ch6ex7)
    展示了 `otool -tVq` 的示例输出。
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-7: otool’s disassembly output*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-7：otool 的反汇编输出*'
- en: Here, you see the actual disassembly of methods, as well as some basic symbol
    information. To get a dump of all the symbols, use `otool -IV`, as shown in [Listing
    6-8](ch06.html#ch6ex8).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到方法的实际反汇编，以及一些基本的符号信息。要获取所有符号的转储，可以使用 `otool -IV`，如 [清单 6-8](ch06.html#ch6ex8)
    所示。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-8: Inspecting symbols with otool*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-8：使用 otool 检查符号*'
- en: '***Obtaining Class Information with class-dump***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 class-dump 获取类信息***'
- en: The class-dump^([9](footnote.html#fn45)) tool is used to extract class information
    from Objective-C 2.0 binaries. The resulting output is essentially the equivalent
    of the header files of a given binary. This can give excellent insight into the
    design and structure of a program, making class-dump an invaluable tool for reverse
    engineering. The original class-dump by Steve Nygard runs only on OS X but recognizes
    the armv7 architecture, so you can copy files over to your desktop for analysis.
    There is also a modified version, class-dump-z,^([10](footnote.html#fn46)) that
    can run on Linux and iOS. As of this writing, class-dump appears to be more up-to-date
    and functional, so I recommend sticking with it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: class-dump^([9](footnote.html#fn45)) 工具用于从 Objective-C 2.0 二进制文件中提取类信息。最终输出基本上相当于给定二进制文件的头文件。这可以为程序的设计和结构提供极好的洞察，使
    class-dump 成为逆向工程中不可或缺的工具。Steve Nygard 最初的 class-dump 仅在 OS X 上运行，但它支持 armv7 架构，因此你可以将文件复制到桌面进行分析。还有一个修改版本，class-dump-z，^([10](footnote.html#fn46))
    可以在 Linux 和 iOS 上运行。到目前为止，class-dump 似乎更新更为及时且功能更全，因此我建议继续使用它。
- en: You can test class-dump against any unencrypted iOS binary. The quickest way
    to get a feel for it is to copy over one of the built-in Apple apps in */Applications*
    and run class-dump on the binary, as shown in [Listing 6-9](ch06.html#ch6ex9).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 class-dump 测试应用于任何未加密的 iOS 二进制文件。最简单的方式是将 */Applications* 中的内建 Apple 应用复制过来，并对其二进制文件运行
    class-dump，如 [清单 6-9](ch06.html#ch6ex9) 所示。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-9: class-dump Showing the Interface Details of MobileMail*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-9：class-dump 显示 MobileMail 的接口详情*'
- en: Delightful, no? Once you have a decrypted binary, most Objective-C applications
    become transparent pretty quickly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 令人愉快，不是吗？一旦你有了已解密的二进制文件，大多数 Objective-C 应用程序都会很快变得透明。
- en: '***Extracting Data from Running Programs with Cycript***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Cycript 从运行中的程序提取数据***'
- en: 'If you don’t want to go through the hassle of decrypting a binary to get information
    about its internals, you can use Cycript^([11](footnote.html#fn47)) to extract
    some of this information from a running executable. There are many tricks to interact
    with running applications using Cycript, but you’ll probably be most interested
    in using *weak_classdump.cy*^([12](footnote.html#fn48)) to approximate the functionality
    of class-dump. With the Contacts application running, you can extract class-dump
    information thusly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想经历解密二进制文件以获取其内部信息的麻烦，可以使用 Cycript^([11](footnote.html#fn47)) 从正在运行的可执行文件中提取一些信息。使用
    Cycript 与运行中的应用程序进行交互有许多技巧，但你可能最感兴趣的是使用 *weak_classdump.cy*^([12](footnote.html#fn48))
    来模拟 class-dump 的功能。在 Contacts 应用程序运行时，你可以这样提取 class-dump 信息：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will write out header files for each class into the */tmp/contactsbundle*
    directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把每个类的头文件写入 */tmp/contactsbundle* 目录。
- en: 'Note that in order to securely fetch things with cURL, you’ll need to install
    a CA certificate bundle on the device. If you use MacPorts and have cURL installed
    locally, do this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了通过 cURL 安全地获取数据，你需要在设备上安装 CA 证书包。如果你使用 MacPorts 且本地已安装 cURL，请执行以下操作：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or if you use Homebrew and have the OpenSSL formula installed, you can use
    this command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用Homebrew并安装了OpenSSL配方，可以使用以下命令：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***Disassembly with Hopper***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Hopper进行反汇编***'
- en: There will likely be some situations where you need to get a closer view of
    a program’s actual logic, in the absence of source code. While IDA Pro^([13](footnote.html#fn49))
    is useful for this, it’s rather expensive. I usually use Hopper^([14](footnote.html#fn50))
    for disassembling, decompiling, and making flow graphs during black-box testing.
    While assembly language and decompiling are somewhat outside the scope of this
    book, let’s take a quick look at what Hopper can show you about a program’s logic.
    Looking at a basic password manager in Hopper ([Figure 6-3](ch06.html#ch6fig3)),
    you will find a method called `storeSavedKeyFor:`, which looks promising.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有源代码的情况下，可能会有一些需要更深入查看程序实际逻辑的情况。虽然IDA Pro^([13](footnote.html#fn49))对于此类情况很有用，但它的价格相当高。我通常使用Hopper^([14](footnote.html#fn50))来进行反汇编、反编译，并在黑箱测试过程中制作流程图。虽然汇编语言和反编译超出了本书的范围，但让我们快速看一下Hopper如何展示程序逻辑。查看Hopper中的一个基本密码管理器（[图6-3](ch06.html#ch6fig3)），你会发现一个名为`storeSavedKeyFor:`的方法，看起来很有前景。
- en: '![image](graphics/f06-03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-03.jpg)'
- en: '*Figure 6-3: The disassembly of the* `storeSavedKeyFor:` *function*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：`storeSavedKeyFor:`函数的反汇编*'
- en: If you call the decompiler (the `if(b)` button) on this particular section of
    code, Hopper will generate pseudocode to give you an idea of actual program flow,
    as shown in [Figure 6-4](ch06.html#ch6fig4).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这段代码中调用反编译器（`if(b)`按钮），Hopper会生成伪代码，帮助你理解程序的实际流程，如[图6-4](ch06.html#ch6fig4)所示。
- en: '![image](graphics/f06-04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-04.jpg)'
- en: '*Figure 6-4: Code generated by the decompiler*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：反编译器生成的代码*'
- en: Notice that the `PearlLogger` class is being instantiated, and there’s a reference
    to the username for which the current item is being stored. `var_64` shows that
    this username is getting passed to the logging function, probably to the NSLog
    facility—this is bad, for reasons I’ll explain further in [Chapter 10](ch10.html#ch10).
    However, you can also see that the item is being stored in the Keychain with a
    restrictive protection attribute (`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`,
    further detailed in [Chapter 13](ch13.html#ch13)), which is a point in the program’s
    favor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PearlLogger`类正在实例化，并且有一个引用当前正在存储的用户名。`var_64`显示该用户名被传递给日志功能，可能是传递给NSLog功能——这是不好的，原因我将在[第10章](ch10.html#ch10)中进一步解释。然而，你也可以看到该项正在被存储在具有限制性保护属性的钥匙串中（`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`，在[第13章](ch13.html#ch13)中有进一步详细说明），这是程序的一个优点。
- en: 'Assembly language and decompilation are broad areas, but Hopper gives you a
    great way to get started with reverse engineering via assembly for a fairly low
    price. If you’d like to get started developing your skills reading ARM assembly,
    check out Ray Wenderlich’s tutorial: *[http://www.raywenderlich.com/37181/ios-assembly-tutorial/](http://www.raywenderlich.com/37181/ios-assembly-tutorial/)*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言和反编译是广泛的领域，但Hopper为你提供了一种非常好的方式，以相对较低的价格开始通过汇编进行逆向工程。如果你想开始培养阅读ARM汇编的技能，可以查看Ray
    Wenderlich的教程：*[http://www.raywenderlich.com/37181/ios-assembly-tutorial/](http://www.raywenderlich.com/37181/ios-assembly-tutorial/)*。
- en: '**Defeating Certificate Pinning**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败证书钉扎**'
- en: Certificate pinning aims to prevent a rogue CA from signing a fake (but valid-looking)
    certificate for your site, with the purpose of intercepting communications between
    your network endpoint and the application. This is quite a good idea (and I’ll
    discuss how to implement it in [Chapter 7](ch07.html#ch07)), but it does of course
    make black-box testing slightly more difficult.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 证书钉扎旨在防止恶意的CA为你的网站签发伪造（但看起来有效）的证书，从而拦截你的网络端点和应用程序之间的通信。这是一个很好的想法（我将在[第7章](ch07.html#ch07)中讨论如何实现它），但它确实使得黑箱测试变得稍微困难一些。
- en: 'My colleagues and I ran into this problem frequently enough that we wrote a
    tool to help us with it: the iOS SSL Killswitch.^([15](footnote.html#fn51)) The
    Killswitch tool hooks requests going through the URL loading system to prevent
    the validation of any SSL certificates, ensuring that you can run any black-box
    application through your proxy regardless of whether it uses certificate pinning.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我的同事们经常遇到这个问题，以至于我们编写了一个工具来帮助我们解决它：iOS SSL Killswitch^([15](footnote.html#fn51))。Killswitch工具钩取通过URL加载系统的请求，防止验证任何SSL证书，确保你可以通过代理运行任何黑箱应用，无论它是否使用证书钉扎。
- en: To install the Killswitch tool, copy the precompiled *.deb* file to your device
    and install it with the dpkg tool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Killswitch 工具，复制预编译的 *.deb* 文件到你的设备，并使用 dpkg 工具进行安装。
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should then find iOS SSL Killswitch in your Settings application (see [Figure
    6-5](ch06.html#ch6fig5)), where you can toggle it on and off.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在设置应用中找到 iOS SSL Killswitch（参见 [图 6-5](ch06.html#ch6fig5)），在这里你可以切换开关。
- en: '![image](graphics/f06-05.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-05.jpg)'
- en: '*Figure 6-5: Enabling the SSL Killswitch tool from within the Settings application*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：从设置应用程序中启用 SSL Killswitch 工具*'
- en: '**Hooking with Cydia Substrate**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Cydia Substrate 进行 Hook**'
- en: On jailbroken devices (which you’ll be performing your black-box testing on),
    you can use Cydia Substrate^([16](footnote.html#fn52)) (formerly known as Mobile
    Substrate) to modify the behavior of the base system to give you additional information
    on your application’s activity or change application behavior. Your goals may
    be to disable certain security or validation mechanisms (like the iOS SSL Killswitch
    does) or to simply notify you when certain APIs are used, along with the arguments
    passed to them. Cydia Substrate hooks are referred to as *tweaks*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在越狱设备上（你将在这些设备上执行黑盒测试），你可以使用 Cydia Substrate^([16](footnote.html#fn52))（以前称为
    Mobile Substrate）来修改基础系统的行为，从而获取有关应用程序活动的更多信息或改变应用程序行为。你的目标可能是禁用某些安全或验证机制（就像 iOS
    SSL Killswitch 所做的那样），或者仅仅是当某些 API 被使用时通知你，并显示它们传递的参数。Cydia Substrate 钩取被称为 *tweaks*。
- en: The most user-friendly way to get started with developing Cydia Substrate tweaks
    is to use the Theos toolkit.^([17](footnote.html#fn53)) To create a new tweak,
    use the *nic.pl* script included with Theos. Note that Theos is by default oriented
    toward tweaking the behavior of the SpringBoard application in order to customize
    user interface elements. For the purposes described in this book, though, you’ll
    want to affect all applications, so you’d specify a Bundle filter of `com.apple.UIKit`.
    This filter will configure Mobile/Cydia Substrate to load your tweak in any application
    that links to the UIKit framework (that is, applications displaying a user interface)
    but not other programs like system daemons or command line tools.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 开始开发 Cydia Substrate 修改的最简便方法是使用 Theos 工具包。^([17](footnote.html#fn53)) 要创建一个新的修改，使用
    Theos 中包含的 *nic.pl* 脚本。请注意，Theos 默认是面向调整 SpringBoard 应用程序的行为，以便自定义用户界面元素。不过，鉴于本书中的目的，你将需要影响所有应用程序，因此你需要指定一个
    `com.apple.UIKit` 的 Bundle 过滤器。这个过滤器将配置 Mobile/Cydia Substrate，在任何链接到 UIKit 框架的应用程序中加载你的修改（也就是说，显示用户界面的应用程序），但不会影响像系统守护进程或命令行工具等其他程序。
- en: 'First, you need to acquire the Link Identity Editor, ldid,^([18](footnote.html#fn54))
    which Theos uses to generate the signature and entitlements for a tweak. Here’s
    how to get ldid:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取 Link Identity Editor，ldid，^([18](footnote.html#fn54)) 这是 Theos 用来生成修改的签名和授权的工具。下面是获取
    ldid 的方法：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can then clone the Theos repo and proceed to generate a tweak template,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以克隆 Theos 仓库并继续生成一个修改模板，具体步骤如下：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create a *Tweak.xm* file, with all of its contents commented out by
    default. Stubs are included for hooking either class methods or instance methods,
    with or without arguments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 *Tweak.xm* 文件，默认情况下其所有内容都被注释掉。包括了钩取类方法或实例方法的存根，可以带参数也可以不带参数。
- en: 'The simplest type of hook you can write is one that just logs method calls
    and arguments; here’s an example that hooks two class methods of `UIPasteboard`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写的最简单的 Hook 类型就是仅记录方法调用和参数；这里有一个例子，它钩取了 `UIPasteboard` 的两个类方法：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code snippet uses Logos^([19](footnote.html#fn55)) directives such as `%hook`
    and `%log`. Logos is a component of Theos designed to allow method-hooking code
    to be written easily. However, it is possible to write a tweak with the same functionality
    using only C instead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 Logos^([19](footnote.html#fn55)) 指令，如 `%hook` 和 `%log`。Logos 是 Theos
    的一个组件，旨在使方法钩取代码的编写变得简单。然而，实际上也可以仅使用 C 语言来编写具有相同功能的修改。
- en: You’ll want to provide the full method signature as well, which you can obtain
    either from API documentation or from framework header files. Once you’ve customized
    your tweak to your satisfaction, you can build it using the Makefile provided
    by *nic.pl*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要提供完整的方法签名，可以通过 API 文档或框架头文件获得。一旦你对修改进行了满意的自定义，你可以使用 *nic.pl* 提供的 Makefile
    来构建它。
- en: 'To build a Debian package suitable for installation onto a jailbroken device,
    you’ll also need to install the dpkg tool. You can do this either with the MacPorts^([20](footnote.html#fn56))
    `port` command or with Homebrew’s^([21](footnote.html#fn57)) `brew` command. This
    example uses `port`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建适合安装到越狱设备上的Debian包，你还需要安装dpkg工具。你可以通过MacPorts^([20](footnote.html#fn56))的`port`命令或Homebrew^([21](footnote.html#fn57))的`brew`命令来安装。此示例使用`port`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Running these commands should result in a package that can be installed on your
    iOS device. First, you’d use the `scp` command to copy the file over to the device
    and load it manually. After that, you could simply use `dpkg -i` from the command
    line (as shown in the following code) or set up your own Cydia repository.^([22](footnote.html#fn58))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令应该会生成一个可以安装到iOS设备上的包。首先，你可以使用`scp`命令将文件复制到设备，并手动加载它。之后，你可以直接在命令行使用`dpkg
    -i`（如下代码所示）或设置自己的Cydia仓库。^([22](footnote.html#fn58))
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When this finishes, you can either manage the package further with the `dpkg`
    command (removing it with `dpkg -P`) or manage it via Cydia, as shown in [Figure
    6-6](ch06.html#ch6fig6).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当此过程完成后，你可以通过`dpkg`命令进一步管理该包（使用`dpkg -P`删除）或通过Cydia进行管理，如[图6-6](ch06.html#ch6fig6)所示。
- en: '![image](graphics/f06-06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-06.jpg)'
- en: '*Figure 6-6: Your very own tweak in the Cydia management interface*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：你自己的插件在Cydia管理界面中的展示*'
- en: 'After a tweak is installed, if you examine the system log, you’ll see the Cydia
    Substrate dynamic library being loaded upon launch of all applications. You’ll
    also see the hooked method calls being logged by the tweak. Here’s an example
    log:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装一个插件后，如果你查看系统日志，你会看到Cydia Substrate动态库在启动所有应用时被加载。你还会看到插件记录的钩取方法调用日志。以下是一个示例日志：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are, of course, many other things you can do with tweaks besides logging;
    see the *Tweak.xm* file of the iOS SSL Killswitch tool for an example of modifying
    method behavior, along with your own preference toggle.^([23](footnote.html#fn59))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，插件除了记录之外，还有许多其他功能；参见iOS SSL Killswitch工具的*Tweak.xm*文件，了解如何修改方法行为以及如何设置自己的首选项切换。^([23](footnote.html#fn59))
- en: '**Automating Hooking with Introspy**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Introspy自动化钩取**'
- en: While tweaks are useful for one-off hooking scenarios, my colleagues Alban Diquet
    and Tom Daniels have used the Cydia Substrate framework to make a tool called
    Intropsy^([24](footnote.html#fn60)) that can help automate the hooking process
    for black-box testing without having to dig too deep in to the guts of iOS or
    Cydia Substratey. Introspy uses the Cydia Substrate framework directly (rather
    than via Theos) to hook security-sensitive method calls, logging their arguments
    and return values in a format that can subsequently be used to generate reports.
    To install Introspy, download the latest precompiled *.deb* package from *[https://github.com/iSECPartners/Introspy-iOS/releases/](https://github.com/iSECPartners/Introspy-iOS/releases/)*,
    copy it to your device, and enter the command `dpkg -i *filename*` on the device
    to add the package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然插件对于一次性钩取场景非常有用，但我的同事Alban Diquet和Tom Daniels使用Cydia Substrate框架开发了一个名为Introspy^([24](footnote.html#fn60))的工具，可以帮助自动化黑盒测试中的钩取过程，而无需深入挖掘iOS或Cydia
    Substrate的底层。Introspy直接使用Cydia Substrate框架（而不是通过Theos）来钩取安全敏感的函数调用，并记录它们的参数和返回值，之后可以用来生成报告。要安装Introspy，下载最新的预编译*.deb*包，地址为*[https://github.com/iSECPartners/Introspy-iOS/releases/](https://github.com/iSECPartners/Introspy-iOS/releases/)*，将其复制到你的设备上，并在设备上输入命令`dpkg
    -i *filename*`来添加该包。
- en: 'Once installed, respring the device using the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，使用以下命令重新启动设备：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Do the same for any application that you want to test, if it’s already running.
    You can now tell Introspy what applications you want to hook, along with which
    API calls you’d like to record (see [Figure 6-7](ch06.html#ch6fig7)). Once your
    testing is complete, a SQLite database file will be deposited in */var/mobile*
    if you’re testing Apple built-in or Cydia applications, or in */User/Applications/<AppID>*
    if you’re testing an application that came from the App Store.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何你想测试的应用程序，如果它已经在运行，进行相同的操作。现在，你可以告诉Introspy你想要钩取的应用程序，以及你希望记录的API调用（见[图6-7](ch06.html#ch6fig7)）。测试完成后，如果你正在测试Apple内建应用或Cydia应用，一个SQLite数据库文件会被保存在*/var/mobile*目录下；如果你正在测试来自App
    Store的应用，则会保存在*/User/Applications/<AppID>*目录下。
- en: '![image](graphics/f06-07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-07.jpg)'
- en: '*Figure 6-7: The Introspy settings screen. You can select which applications
    are profiled on the Apps tab.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：Introspy设置屏幕。你可以在“应用”选项卡中选择要分析的应用程序。*'
- en: To analyze this database, you’ll want to use the Introspy Analyzer,^([25](footnote.html#fn61))
    which will generate HTML reports of Introspy’s findings (see [Figure 6-8](ch06.html#ch6fig8)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 若要分析这个数据库，你需要使用Introspy分析器，^([25](footnote.html#fn61))，它将生成Introspy发现的HTML报告（见[图6-8](ch06.html#ch6fig8)）。
- en: '![image](graphics/f06-08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-08.jpg)'
- en: '*Figure 6-8: The Introspy HTML report output, showing a list of findings that
    match the specified signatures*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：Introspy HTML报告输出，显示与指定签名匹配的发现列表*'
- en: 'If you copy this database onto your test machine, you can create a report on
    the called APIs using *introspy.py*, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个数据库复制到你的测试机器上，你可以使用*introspy.py*生成关于调用的API的报告，如下所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Newer versions of Introspy also allow automatic copying and parsing of the database,
    by specifying the IP address of the device.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Introspy的新版还允许通过指定设备的IP地址，自动复制和解析数据库。
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running Introspy will evaluate the calls against a signature database of potentially
    problematic APIs, helping you track down potential areas of interest. To cut down
    on noise, you can filter out specific API categories or signature types with the
    `--group` and `--sub-group` flags. With Introspy installed, enter `introspy.py
    --help` at the command line for details.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Introspy将评估调用与潜在问题API的签名数据库，帮助你追踪潜在的关注点。为了减少噪音，你可以使用`--group`和`--sub-group`标志过滤掉特定的API类别或签名类型。安装Introspy后，在命令行中输入`introspy.py
    --help`获取详细信息。
- en: '**Closing Thoughts**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结思考**'
- en: While black-box testing poses some challenges, the development community has
    gone a long way to making it feasible, and some elements of black-box testing
    will help you regardless of whether you have source code. You will now turn your
    primary attention back to white-box testing; in [Chapter 7](ch07.html#ch07), I’ll
    guide you through some of the most security-sensitive APIs in iOS, including IPC
    mechanisms, cryptographic facilities, and the myriad ways in which data can leak
    from applications unintentionally.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管黑盒测试面临一些挑战，但开发社区已经做出了很大的努力，使其变得可行，黑盒测试的某些元素将帮助你，无论你是否拥有源代码。现在你将把主要精力重新集中在白盒测试上；在[第7章](ch07.html#ch07)，我将引导你了解iOS中一些最具安全敏感性的API，包括IPC机制、加密功能以及数据如何在应用程序中无意间泄漏的多种方式。
