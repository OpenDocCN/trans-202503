- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Cannibal Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 食人代码
- en: 'If technology advances in cycles, you might assume the best legacy modernization
    strategy is to wait a decade or two for paradigms to shift back and leapfrog over.
    If only! For all that mainframes and clouds might have in common in general, they
    have a number of significant differences in the implementation that block easy
    transitions. While the architectural philosophy of time-sharing has come back
    in vogue, other components of technology have been advancing at a different pace.
    You can divide any single product into an infinite number of elements: hardware,
    software, interfaces, protocols, and so on. Then you can add specific techniques
    within those categories. Not all cycles are in sync. The odds of a modern piece
    of technology perfectly reflecting an older piece of technology are as likely
    as finding two days where every star in the sky had the exact same position.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果技术是以周期形式发展的，你可能会认为最好的遗产现代化策略是等待十年或二十年，直到范式发生变化，再跳跃过去。要是能这样就好了！尽管大型主机和云计算在总体上可能有许多共同点，但它们在实施上有许多显著的差异，阻碍了它们之间的轻松过渡。尽管时间共享的架构理念已经重新流行，但技术的其他组成部分却在不同的节奏上进步。你可以将任何单一产品分解为无限多个元素：硬件、软件、接口、协议等。然后你可以在这些类别中添加特定的技术。不所有的周期都是同步的。现代技术与旧技术完美契合的几率，就像是找到两天每颗星星的确切位置完全相同一样。
- en: So, the takeaway from understanding that technology advances in cycles isn’t
    that upgrades are easier the longer you wait, it’s that you should avoid upgrading
    to new technology simply because it’s new.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解技术是以周期形式发展的要点不是升级等得越久就越容易，而是你应该避免仅仅因为技术是新的就去升级。
- en: Alignable Differences and User Interfaces
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可对齐差异与用户界面
- en: Without alignable differences, consumers can’t determine the value of the technology
    in which they are being asked to invest. Completely innovative technology is not
    a viable solution, because it has no reference point to help it find its market.
    We often think of technology as being streamlined and efficient with no unnecessary
    bits without a clear purpose, but in fact, many forms of technology you depend
    on have vestigial features either inherited from other older forms of technology
    or imported later to create the illusion of feature parity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可对齐的差异，消费者无法判断他们被要求投资的技术的价值。完全创新的技术不是一个可行的解决方案，因为它没有参考点来帮助它找到市场。我们常常认为技术是简洁高效的，没有任何没有明确目的的冗余部分，但事实上，许多你依赖的技术形式都包含了遗留下来的特征，这些特征要么是从其他旧技术继承而来，要么是后来引入的，以制造功能相等的假象。
- en: For example, most software engineering teams maintain 80-column widths for lines
    of code. It is easier to read short lines of code than long lines of code; that
    much is true. But why specifically 80 columns? Why not 100 columns?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数软件工程团队保持80列的代码行宽。短行代码比长行代码更容易阅读，这一点是事实。但为什么是80列呢？为什么不是100列呢？
- en: Amazingly, an 80-column width is the size of the old mainframe punch cards that
    were used to input both data and programs into the room-sized computers built
    during the 1950s and 1960s. So right now, solidly in the 21st century, programmers
    are enforcing a standard developed for machines most of them have never even seen,
    let alone programmed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 奇妙的是，80列宽度是旧时大型主机打孔卡的尺寸，这些卡片用于输入数据和程序到20世纪50年代和60年代建造的巨型计算机中。因此，现在，已经是21世纪，程序员们还在强制执行一个为他们大多数甚至未曾见过、何况是编程的机器而制定的标准。
- en: 'But, why are mainframe punch cards 80 columns wide? Punch cards used by the
    forebears of the earliest computer companies—back when they were mechanical “tabulating
    machines” used primarily for things like the census—were ad hoc and incredibly
    inefficient. They were designed to tally, not calculate, so they were modeled
    after what a railroad conductor might use for tickets, rather than for storing
    data.^([1](#c02-footnote-1)) The cards needed to be fed into machines in batches
    and then sorted and stored. To avoid having to re-invent everything, the cards
    themselves were designed to be approximately the same size as the paper currency
    of the United States at the time: 3¼ by 7⅜ inches. This meant companies could
    repurpose existing drawers, bins, and boxes to acquire necessary accessories.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么主机打孔卡是80列宽的呢？最早计算机公司使用的打孔卡——当时它们是主要用于像人口普查这样的工作，还是机械“制表机”——是临时设计的，并且极其低效。它们被设计用来进行计数，而不是计算，因此它们的设计类似于铁路乘务员用来售票的卡片，而不是用于存储数据的卡片。^([1](#c02-footnote-1))
    这些卡片需要批量输入机器，然后再进行排序和存储。为了避免重新发明一切，这些卡片本身的设计与当时美国纸币的尺寸大致相同：3¼英寸乘7⅜英寸。这意味着公司可以重新利用现有的抽屉、箱子和盒子来获取所需的配件。
- en: By the 1920s, customers were leaning on IBM to get more data storage out of
    a single card. IBM’s innovation was to change the shape of the holes themselves,
    making them more rectangular so that they could be placed closer together on the
    card.^([2](#c02-footnote-2)) That meant 80 columns of possible holes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到了1920年代，客户开始要求IBM在一张卡片上获取更多的数据存储空间。IBM的创新是改变了孔的形状，使其更接近矩形，这样它们可以更紧密地排列在卡片上。^([2](#c02-footnote-2))
    这意味着可以在卡片上放置80列孔。
- en: Now, let’s go even deeper. What about the punch card itself? Why were the first
    computers designed to take input from stiff cards with holes punched into them?
    Keyboards have existed as long as typewriters, and the first modern typewriter
    was patented by Christopher Latham Sholes, Carlos Glidden, and Samuel W. Soulé
    in 1868, nearly a century before some of these mainframes were developed. Telegraphs
    were experimenting with different types of keyboards even earlier than that. Why
    would people prefer to punch holes in a thick piece of stock paper when they could
    just type their information on a keyboard?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更深入地探讨一下。那打孔卡本身呢？为什么第一代计算机设计要从带孔的硬卡片输入数据？键盘的出现几乎和打字机一样久远，第一台现代打字机由克里斯托弗·拉瑟姆·肖尔斯、卡洛斯·格里登和塞缪尔·W·索尔于1868年获得专利，几乎比一些主机的开发早了一个世纪。电报机甚至早于此就开始实验不同类型的键盘。那么，为什么人们宁愿在一张厚纸上打孔，而不是直接在键盘上输入信息呢？
- en: The problem with keyboards, or similar input devices, is that it’s easy for
    human operators to mistype things, especially if those human operators get no
    visual confirmation that what they think they typed is actually what the machine
    received. Think about typing a password into a field on a website that hides what
    you type. One disadvantage to such password-masking fields is if you hit the wrong
    key, you might not notice until the system rejects your input. How many times
    have you mistyped a password like this? Now imagine inputting an entire message
    without being able to see what you typed. Operator error was a big concern for
    telegraphs, especially when they started to play a larger role in ferrying critical
    messages around the globe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘或类似的输入设备的问题在于，人类操作员很容易输入错误，尤其是当操作员没有任何视觉确认，无法确认他们认为输入的内容是否就是机器接收到的内容时。想象一下在一个隐藏输入内容的网页字段中输入密码。这样的密码隐藏字段的一个缺点是，如果你按错了键，可能直到系统拒绝你的输入时才会注意到。你有多少次输入错误密码？现在想象一下在没有看到自己输入内容的情况下输入一条完整的信息。操作员错误是电报系统中的一个大问题，尤其是当电报开始在全球传递重要信息时。
- en: The solution was to have a keyboard, but instead of interfacing directly with
    the telegraph, the keyboard would produce a record that could be checked for errors
    before the machine tried to send the message. Many different variations on this
    concept were developed, and the one that eventually stuck was punching holes in
    paper tape.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用键盘，但键盘并不是直接与电报接口，而是会生成一个可以在机器尝试发送信息之前检查错误的记录。基于这个概念，开发了许多不同的变体，最终被采用的是在纸带上打孔。
- en: What’s curious about the era of tabulating machines in the late 19th century
    and the era of early computers in the 20th is that they arrived at the same solution
    in different ways. The punch cards of tabulating machines were developed from
    railroad tickets, but the punch cards of telegraphs were developed from the textile
    industry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，19世纪末的打卡机时代和20世纪初期的早期计算机时代，它们以不同的方式达到了相同的解决方案。打卡机的穿孔卡片起源于铁路票，而电报的穿孔卡片则源于纺织行业。
- en: More than a century earlier, French weavers had been automating the pattern
    designs of elaborate rugs by printing out a design in the form of a series of
    punched holes on cards and feeding those cards into their looms. This allowed
    weavers to produce high-quality products much faster, with more artistry and greater
    accuracy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一百多年前，法国的织布工通过在卡片上打印出一系列穿孔图案，并将这些卡片输入织布机，自动化复杂地毯的图案设计。这使得织布工能够更快速地生产高质量的产品，具有更高的艺术性和更大的准确性。
- en: The telegraph further refined the system by introducing the concept of encoding.
    When the goal is to manipulate the threads in a giant loom to create a complex
    pattern row by row, there’s no point in over-complicating things. One hole per
    raised thread is perfectly effective.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 电报进一步改进了这一系统，引入了编码的概念。当目标是操作巨大的织布机中的线程，一行一行地创建复杂的图案时，过于复杂的设计就显得没有意义。每根提升的线对应一个孔，这就足够有效。
- en: However, when the goal is to send messages long distances, that kind of literalism
    is inefficient. Telegraph operators were already accustomed to using code to represent
    different letters, but those codes were optimized to reduce operator error. In
    Morse code, for example, the most common letters have shorter codes. This keeps
    transmission fast and minimizes the strain on the operator. Once telegraphs started
    producing a physical record that the operator could double- or triple-check before
    sending the message, the most significant gains in performance were to be had
    by optimizing the encoding for the machines themselves. Letters that were expressed
    in code length anywhere between one to five units were not easy for machines to
    deal with. Machines do far better when every letter is equal in length. The best
    codes now were ones that were a bit more complex, had a fixed length, and ultimately
    stored more data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当目标是发送远距离信息时，这种字面上的方式就显得低效。电报操作员已经习惯于使用代码来表示不同的字母，但这些代码是为了减少操作员的错误而优化的。例如，在摩尔斯电码中，最常见的字母具有较短的代码。这可以保持传输速度，并减少操作员的压力。一旦电报开始产生一份物理记录，操作员可以在发送信息之前进行二次或三次检查，那么在机器编码的优化方面，性能的最大提升便得以实现。在电码长度为1到5个单位之间的字母，机器处理起来并不容易。机器在每个字母的长度相等时表现得更好。现在最好的编码是那些稍微复杂一些的、长度固定的编码，最终能够存储更多的数据。
- en: A few different systems were developed. The first one to stick was developed
    by Emile Baudot in 1870\. The so-called Baudot code, aka International Telegraph
    Alphabet No. 1, was a 5-bit binary system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发了几种不同的系统。第一个被广泛采用的是由埃米尔·博多（Emile Baudot）在1870年开发的。这个被称为博多码的系统，也叫国际电报字母表第1号，是一个5位二进制系统。
- en: Fast-forward to the early computer age when people were developing massive room-sized
    machines that also were using binary systems. They needed a way to input data
    and instructions, but they had no visual interface. Computers wouldn’t be developed
    to work with monitors until 1964 when Bell Labs incorporated the first primitive
    visual interface into the Multics time-sharing system. We had no way of seeing
    the input the computer was receiving, so we borrowed an interface from the telegraph,
    which, in turn, was borrowing one from 18th-century French weavers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 快速推进到早期计算机时代，人们开始开发巨大的房间大小的机器，这些机器也使用二进制系统。他们需要一种输入数据和指令的方式，但当时并没有可视界面。直到1964年，贝尔实验室才将第一款原始的可视界面融入到Multics时间共享系统中，计算机才开始与显示器配合使用。我们当时没有办法看到计算机接收的输入信息，因此我们借用了电报的接口，而电报的接口又借用了18世纪法国织布工的接口。
- en: Technology is like that. It progresses in cycles, but those cycles occasionally
    collide, intersect, or conflate. We are constantly borrowing ideas we’ve seen
    elsewhere either to improve our systems or to give our users a reference point
    that will make adopting the new technology quicker and easier for them. Truly
    new systems often cannibalize the interfaces of older systems to create alignable
    differences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 技术也是如此。它按照周期发展，但这些周期偶尔会碰撞、交叉或融合。我们不断借用我们在其他地方看到的想法，要么是为了改进我们的系统，要么是为了给用户一个参考点，使得他们采纳新技术变得更快、更容易。真正的新系统通常会吞并旧系统的接口，以创造可以对齐的差异。
- en: This is why maintaining technology long term is so difficult. Although blindly
    jumping onto new things for the sake of their newness is dangerous, not keeping
    up to date is also dangerous. As technology advances, it collects more and more
    interfaces and patterns. It absorbs them from other fields, and it holds on to
    historic elements that no longer make sense. It builds assumptions around the
    most deeply buried characteristics. Keep your systems the way they are for too
    long, and you get caught trying to migrate decades of assumptions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么长期维护技术如此困难的原因。虽然盲目追求新事物因为其新颖性而具有危险性，但不与时俱进也是危险的。随着技术的进步，它积累了越来越多的接口和模式。它从其他领域吸收这些元素，并保留了那些已经不再有意义的历史成分。它围绕最深藏的特性建立假设。如果你的系统保持不变太久，你就会陷入迁移数十年假设的困境。
- en: Unix Eats the World
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix 吃掉了世界
- en: A common piece of advice for building successful software is to keep what you
    are trying to do simple. But what exactly makes one design feel simple and another
    design feel complicated? Why is a line of code 80 characters long simpler and
    easier to read? It is short, but what if I told you that user experience research
    actually puts the ideal number at 50 to 60 characters wide? This means 80 characters
    is a good 50 percent longer than what we know works best from actual testing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的建议是，构建成功软件时要保持简单。但究竟是什么让一个设计看起来简单，而另一个设计却显得复杂呢？为什么一行80个字符的代码看起来更简单、更易读？它很简短，但如果我告诉你，用户体验研究实际上把理想的字符数定在50到60个字符之间呢？这意味着80个字符比实际测试中效果最好的长度长了50%。
- en: The human machine is strongly biased toward the familiar. We perceive concepts
    and constructs we know as simpler, easier, and more efficient just because they
    are known and comfortable to us. We don’t need to be experts in a construct or
    even necessarily like it in order for familiarity to change our perception of
    it. In the 1960s, psychologist Robert Zajonc conducted a series of experiments
    documenting how even a single exposure to something increased positive feelings
    about it in later encounters. He found this effect with languages, individual
    words, and images. Later researchers have observed similar preferences in how
    financial professionals invest,^([3](#c02-footnote-3)) how academic researchers
    evaluate journals,^([4](#c02-footnote-4)) and what flavors we enjoy when we eat.^([5](#c02-footnote-5))
    In psychology, the term for this is the *mere-exposure effect*. Simply being exposed
    to a concept makes it easier for the brain to process that concept and, therefore,
    feels easier to understand for the user.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的大脑对熟悉的事物有强烈的偏见。我们把已经知道的概念和构造看作更简单、更容易、更高效，仅仅因为它们对我们来说是已知且舒适的。我们不需要成为某个构造的专家，甚至不一定要喜欢它，熟悉感就会改变我们对它的认知。20世纪60年代，心理学家罗伯特·扎扬茨进行了一系列实验，记录了即使是对某物的单次接触，也能增加我们在后续接触中的正面情绪。他在语言、单词和图像上都发现了这一效应。后来的研究者也观察到了类似的偏好，比如金融专业人士如何进行投资^([3](#c02-footnote-3))，学术研究人员如何评估期刊^([4](#c02-footnote-4))，以及我们在吃东西时喜欢什么味道^([5](#c02-footnote-5))。在心理学中，这个现象被称为*单纯接触效应*。仅仅接触某个概念，会让大脑更容易处理这个概念，因此，用户会觉得它更容易理解。
- en: Developing new technology or revitalizing an old system is, therefore, most
    likely to be effective when building on familiar concepts. Reference points create
    alignable differences that help us assess the value of something new, but those
    same reference points make the new technology feel simple and easy, lowering the
    barrier to entry and increasing the odds it will be adopted as well as the speed
    of adoption.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发新技术或振兴旧系统最有效的方式往往是建立在熟悉的概念之上。参考点创造了可以对齐的差异，帮助我们评估新事物的价值，但这些相同的参考点也使新技术显得简单易懂，降低了进入的门槛，提高了其被采纳的可能性以及采纳的速度。
- en: Consider the Linux operating system. It’s easily one of the most popular operating
    systems for web servers if not computers in general. Hundreds of variants currently
    exist that are available to install freely, and there are any number of professional
    versions. Linux was the uncontested victor to emerge from a mad race to develop
    an operating system that was both portable to many different types of computers
    and free of restrictive licenses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下 Linux 操作系统。它很可能是目前最受欢迎的网络服务器操作系统之一，甚至在计算机领域也是如此。目前有数百个版本可以自由安装，而且还有许多专业版本。Linux
    是在激烈的竞争中脱颖而出的无可争议的胜者，它的目标是开发一个既能在多种不同类型的计算机上运行，又不受限制许可证约束的操作系统。
- en: Linux is often described as the most popular version of the Unix operating system,
    except the two OSes share very little when it comes to implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 常被描述为最受欢迎的 Unix 操作系统版本，尽管这两个操作系统在实现方面几乎没有任何相似之处。
- en: The story of Linux kicks off with the breakup of Bell Systems in 1982, nearly
    a decade before its creation. A 1956 consent decree against AT&T had forbidden
    the telecom giant from “any business other than the furnishing of common carrier
    communications services.” This meant that when Bell Labs computer scientists Dennis
    Ritchie, Ken Thompson, and Rudd Canaday began developing Unix in the 1970s, no
    one was sure whether AT&T was allowed to sell it. The lawyers at AT&T decided
    to play it safe and allow it to be sold to academic and research institutions
    with a copy of its source code along with the software.^([6](#c02-footnote-6))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的故事始于 1982 年贝尔系统的解体，距其诞生将近十年。1956 年对 AT&T 的一项同意判令禁止该电信巨头从事“任何除提供公共通信服务以外的业务”。这意味着，当贝尔实验室的计算机科学家
    Dennis Ritchie、Ken Thompson 和 Rudd Canaday 在 1970 年代开始开发 Unix 时，没有人确定 AT&T 是否被允许出售它。AT&T
    的律师们决定采取保守态度，允许将其源代码和软件一同出售给学术和研究机构。^([6](#c02-footnote-6))
- en: Having the source code made it easy to port Unix to different machines as well
    as modify and debug it. People printed it out and annotated it with their own
    commentary. Unix became an easy option for teaching students how operating systems
    worked. It spread like wildfire across a wide variety of different institutions,
    including universities, museums, governmental organizations, and at least one
    all-girls private school in the early days.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有源代码使得将 Unix 移植到不同的机器上变得容易，也可以对其进行修改和调试。人们将其打印出来并附上自己的注释。Unix 成为教学中一种便捷的选择，帮助学生理解操作系统是如何工作的。它在各种不同的机构中迅速传播开来，包括大学、博物馆、政府组织，甚至早期还有一所全女子私立学校。
- en: Users began putting their modified versions of Unix on magnetic tape and making
    copies to distribute among each other. These essentially were forks and pull requests
    long before the infrastructure for such things existed. The principal motivation
    for sharing was to distribute bug fixes and patches.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户开始将他们修改过的 Unix 版本放在磁带上，并相互分发。这些本质上是“分叉”和“拉取请求”，远在这种基础设施出现之前。分享的主要动机是分发错误修复和补丁。
- en: Meanwhile, AT&T’s lawyers were trying to figure out what to do with Unix, and
    they were waffling between their original determination and a more traditional
    restrictive approach to intellectual property. Unix historian Peter Salus tells
    the story of how AT&T’s developers actively participated in the piracy of their
    own intellectual property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，AT&T 的律师们正在努力决定如何处理 Unix，并且他们在原始的决策和更为传统的知识产权限制方法之间摇摆不定。Unix 历史学家 Peter
    Salus 讲述了 AT&T 的开发者是如何积极参与盗版自己知识产权的故事。
- en: '*A large number of bug fixes was collected, and rather than issue them one
    at a time, a collection tape was put together by Ken [Thompson]. Some of the fixes
    were quite important. . . . I suspect that a significant number of the fixes were
    actually done by non-Bell people. Ken tried to send it out, but the lawyers kept
    stalling and stalling and stalling.*'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*大量的错误修复被收集起来，而不是一次性发布，每次修复都会由 Ken [Thompson] 汇总成一个修复带。一些修复非常重要……我怀疑相当一部分修复实际上是由非贝尔公司的人完成的。Ken
    尝试发布，但律师们一直拖延，拖延，再拖延。*'
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Finally, in complete disgust, someone “found” a tape on Mountain Avenue [the
    address of Bell Laboratories was 600 Mountain Avenue, Murray Hill, NJ] which had
    the fixes.*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最终，出于完全的厌恶，有人“发现”了一盘在 Mountain Avenue [贝尔实验室的地址是 600 Mountain Avenue, Murray
    Hill, NJ] 上的磁带，其中包含了这些修复。*'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When the lawyers found out about it, they called every licensee and threatened
    them with dire consequences if they didn’t destroy the tape . . . after trying
    to find out how they got the tape. I would guess that no one would actually tell
    them how they came by the tape (I didn’t). It was the first of many attempts by
    the AT&T lawyers to justify their existence and to kill UNIX.^([7](#c02-footnote-7))*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当律师们得知此事后，他们打电话给每一个许可证持有者，威胁如果不销毁录音带，他们将面临严重后果……并试图找出他们是如何得到这盘录音带的。我猜没有人会真正告诉他们是如何得到录音带的（我没有）。这是AT&T律师们为了证明自己存在价值并扼杀UNIX的第一次尝试。^([7](#c02-footnote-7))*'
- en: When the university students who studied Unix as part of their computer science
    degrees graduated and got jobs, they brought Unix with them. AT&T’s licensing
    became more restrictive with every new version, as the company tried to figure
    out what it legally could do to leverage this thriving community it had accidentally
    created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当那些在计算机科学课程中学习UNIX的大学生毕业并找到工作时，他们把UNIX带到了各自的工作岗位。随着每个新版本的推出，AT&T的许可证变得越来越严格，公司试图弄清楚它在法律上能做些什么来利用这一意外形成的繁荣社区。
- en: Then in 1982, the US Department of Justice settled its second antitrust case
    against the telecom and broke up “Ma Bell.” AT&T was suddenly free from the consent
    decree that kept it from treating Unix fully as a product, and it wasted no time
    in cracking down hard on the community that had grown over the course of a decade.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在1982年，美国司法部解决了对电信行业的第二起反垄断案件，并拆分了“Ma Bell”。AT&T突然摆脱了那项令其无法完全将UNIX视作产品的同意令，它毫不犹豫地开始严厉打压这个在十多年间逐渐壮大的社区。
- en: If you lived through similar attempts to stop sharing other forms of intellectual
    property, like music and movies, you can understand how once people became accustomed
    to having Unix as a free and modifiable operating system, they didn’t want to
    give it up and go back to the way things were before. Taking away access to Unix’s
    source code sent the community on the hunt for a replacement that was open sourced
    and ideally free.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经历过类似的尝试来阻止分享其他形式的知识产权，比如音乐和电影，你就能理解一旦人们习惯了拥有一个免费且可修改的操作系统UNIX后，他们不愿放弃它，也不愿回到以前的状态。剥夺对UNIX源代码的访问迫使社区寻找一个开源的、理想情况下免费的替代品。
- en: An early contender was a variant of Unix developed at Berkeley called Berkeley
    Software Distribution (BSD). BSD had a growing community, but it had used part
    of Unix’s source code as its base, so it was quickly bogged down in litigation.
    The heir to Unix needed to present itself as Unix-like while not including any
    intellectual property from AT&T.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个早期的竞争者是伯克利开发的UNIX变种，称为伯克利软件发行版（BSD）。BSD拥有一个日益壮大的社区，但它的基础使用了UNIX的部分源代码，因此很快陷入了诉讼之中。UNIX的继承者需要表现得像UNIX，但又不包括AT&T的任何知识产权。
- en: Enter Linux, which was developed as a pet project by computer science student
    Linus Torvalds. There was never any intention to create a full operating system
    from Linux; it was intended to be only a kernel for the specific chip architecture
    to which the creator happened to have access. The Linux operating system, therefore,
    was pieced together from a variety of software from other groups. Most of its
    Unix-like interfaces came from Richard Stallman’s GNU project, and GNU itself
    contained no Unix code by design.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 于是Linux诞生了，它是计算机科学学生Linus Torvalds作为个人项目开发的。Linux从来没有意图成为一个完整的操作系统；它只打算成为针对特定芯片架构的内核，而Torvalds恰好有该架构的访问权限。因此，Linux操作系统是由来自其他团队的各种软件拼凑而成的。它的大部分类Unix接口来自理查德·斯托尔曼的GNU项目，而GNU本身设计上并不包含任何UNIX代码。
- en: 'So in a way, Linux is a descendant of Unix that involves no code directly from
    Unix. But, why hold on to the Unix look and feel at all? Once the decision to
    start writing something completely new was made, what was the value of wrapping
    things up to look like Unix? For Stallman, the situation was clear: free software
    was a moral mission. The goal was not to build a free alternative to Unix, but
    to build a free *replacement* for Unix that would completely overtake and drive
    Unix out of business. He did not hesitate to describe the strategy of the GNU
    project in extremes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在某种意义上，Linux是UNIX的后代，但它没有直接使用UNIX的任何代码。但，为什么要坚持保持UNIX的外观和感觉呢？一旦决定开始编写一个完全新的系统，那么保持看起来像UNIX的形式有什么价值呢？对斯托尔曼来说，情况很明确：自由软件是一项道德使命。目标不是建立一个免费的UNIX替代品，而是建立一个免费的*替代品*，完全取代并淘汰UNIX。他毫不犹豫地将GNU项目的策略描述为极端：
- en: '*As the GNU Project’s reputation grew, people began offering to donate machines
    running Unix to the project. These were very useful, because the easiest way to
    develop components of GNU was to do it on a Unix system, and replace the components
    of that system one by one. But they raised an ethical issue: whether it was right
    for us to have a copy of Unix at all.*'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*随着 GNU 项目声誉的增长，人们开始主动为该项目捐赠运行 Unix 的机器。这些机器非常有用，因为开发 GNU 组件最简单的方式就是在 Unix
    系统上进行，然后逐个替换该系统的组件。但是它们也提出了一个伦理问题：我们是否应该拥有 Unix 的副本？*'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unix was (and is) proprietary software, and the GNU Project’s philosophy said
    that we should not use proprietary software. But, applying the same reasoning
    that leads to the conclusion that violence in self defense is justified, I concluded
    that it was legitimate to use a proprietary package when that was crucial for
    developing a free replacement that would help others stop using the proprietary
    package.*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Unix 是（并且仍然是）专有软件，而 GNU 项目的哲学认为我们不应该使用专有软件。但是，运用与自卫中暴力行为正当化相同的推理，我得出结论，当使用专有软件对开发一个可以帮助他人停止使用该专有软件的自由替代品至关重要时，使用专有软件是合法的。*'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*But, even if this was a justifiable evil, it was still an evil. Today we no
    longer have any copies of Unix, because we have replaced them with free operating
    systems. If we could not replace a machine’s operating system with a free one,
    we replaced the machine instead.^([8](#c02-footnote-8))*'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*但是，即使这是一个可以辩解的邪恶，它仍然是一个邪恶。今天我们不再拥有任何 Unix 的副本，因为我们已经用免费的操作系统取而代之。如果我们无法用免费的操作系统替代一台机器的操作系统，我们就换掉了那台机器。^([8](#c02-footnote-8))*'
- en: Stallman used Unix’s interfaces because he understood that if GNU’s interfaces
    matched those of established pieces of software, the users of the proprietary
    pieces of software would have a bigger incentive to switch.^([9](#c02-footnote-9))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Stallman 使用 Unix 的接口，因为他明白，如果 GNU 的接口与现有软件的接口匹配，专有软件的用户将有更大的动力去切换。^([9](#c02-footnote-9))
- en: 'Let’s go down one more level: Why did Unix have the interface it had in the
    first place? Most Unix commands are two-letter abbreviations for words that don’t
    seem to need abbreviating. The authors of *The UNIX-HATERS Handbook* attribute
    this interface to the hardware available to Unix’s creators:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再深入一层：为什么 Unix 最初有它现在这样的接口？大多数 Unix 命令是两个字母的缩写，代表那些似乎不需要缩写的词。《The UNIX-HATERS
    Handbook》的作者将这种接口归因于 Unix 创建者当时可用的硬件：
- en: '*The novice Unix user is always surprised by Unix’s choice of command names.
    No amount of training on DOS or the Mac prepares one for the majestic beauty of
    cryptic two-letter command names such as cp, rm, and ls.*'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*初学 Unix 的用户总是对 Unix 命令名称的选择感到惊讶。无论在 DOS 或 Mac 上接受多少培训，都无法为那些神秘而美丽的两个字母的命令名称如
    cp、rm 和 ls 做好准备。*'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Those of us who used early 70s I/O devices suspect the degeneracy stems from
    the speed, reliability, and, most importantly, the keyboard of the ASR-33 Teletype,
    the common input/output device in those days. Unlike today’s keyboards, where
    the distance keys travel is based on feedback principles, and the only force necessary
    is that needed to close a microswitch, keys on the Teletype (at least in memory)
    needed to travel over half an inch, and take the force necessary to run a small
    electric generator such as those found on bicycles. You could break your knuckles
    touch typing on those beasts.*'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们这些使用过70年代早期I/O设备的人怀疑，退化的根源在于 ASR-33 电传打字机的速度、可靠性，以及最重要的，它的键盘，ASR-33 是当时常见的输入输出设备。与今天的键盘不同，今天的键盘按键行程基于反馈原理，所需的力量仅仅是关闭微动开关的力量，而电传打字机上的按键（至少在记忆中）需要移动超过半英寸，并且需要足够的力量来驱动一个小型电动发电机，就像自行车上的发电机一样。你在这些怪物上打字时，手指关节可能会受伤。*'
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If Dennis and Ken had a Selectric instead of a Teletype, we’d probably be
    typing “copy” and “remove” instead of “cp” and “rm.” Proof again that technology
    limits our choices as often as it expands them.*'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果 Dennis 和 Ken 使用的是 Selectric 而不是电传打字机，我们可能会打出“copy”和“remove”，而不是“cp”和“rm”。再次证明，技术往往限制我们的选择，而不仅仅是扩展它们。*'
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*After more than two decades, what is the excuse for continuing this tradition?
    The implacable force of history, AKA existing code and books. If a vendor replaced
    rm by, say, remove, then every book describing Unix would no longer apply to its
    system, and every shell script that calls rm would also no longer apply. Such
    a vendor might as well stop implementing the POSIX standard while it was at it.*'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*经过二十多年，继续延续这一传统的理由是什么？历史的强大力量，也就是现有的代码和书籍。如果一个厂商用比如说remove替代了rm，那么每一本描述Unix的书籍将不再适用于它的系统，而每个调用rm的shell脚本也将不再适用。这样的厂商不如直接停止实现POSIX标准。*'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A century ago, fast typists were jamming their keyboards, so engineers designed
    the QWERTY keyboard to slow them down. Computer keyboards don’t jam, but we’re
    still living with QWERTY today. A century from now, the world will still be living
    with rm.^([10](#c02-footnote-10))*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一个世纪前，快速打字员正在使他们的键盘卡住，因此工程师设计了QWERTY键盘来减慢他们的速度。计算机键盘不会卡住，但我们今天仍然在使用QWERTY。一个世纪后，世界依然会在使用rm。^([10](#c02-footnote-10))*'
- en: Just as programmers are now writing lines of code that would fit on a punch
    card, they also use operating systems whose interfaces were designed to best fit
    teletype keyboards. Leveraging familiar constructs to boost adoption can create
    strange traditions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像程序员现在写的代码行适合打孔卡片一样，他们也使用那些接口设计上最适合电传打字机键盘的操作系统。利用熟悉的结构来促进技术的普及可能会创造出奇怪的传统。
- en: Inheritance Paths
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承路径
- en: If people will more quickly adopt technology that follows an already familiar
    pattern, even one they hate, it’s worth exploring how people become exposed to
    certain patterns in the first place. From the very beginning, computing has been
    a cross-functional industry. Networks of people are formed around the development
    of computers and the professions most likely to use computers to do other work.
    In the early days of computers, this meant computer users were both the computer
    scientists who built applications, developed languages, and designed architectures
    *and* the professionals such as scientists, mathematicians, and bankers. Even
    today, these groups have a tendency to silo themselves, limiting their exposure
    to interfaces created for other use cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人们更快地接受遵循已知模式的技术，即使他们讨厌这些模式，也值得探讨人们最初是如何接触到这些模式的。从一开始，计算机行业就是一个跨功能的行业。围绕计算机的开发以及最可能使用计算机来做其他工作的职业，形成了人们的网络。在计算机的早期，这意味着计算机用户既是构建应用程序、开发语言和设计架构的计算机科学家，*也是*像科学家、数学家和银行家这样的专业人士。即使在今天，这些群体仍然倾向于将自己孤立起来，限制了他们接触为其他用例创建的接口。
- en: 'Consider the following: one of the most successful early programming languages
    is COBOL, and yet modern programming languages have inherited very little of COBOL’s
    design patterns. For example, we do not section code off into divisions, nor do
    we use periods to end lines of code. Few programmers would guess that PIC is a
    variable character string. Some of COBOL’s features have reappeared in other languages,
    but very little of its syntax and interface was retained. Instead, COBOL itself
    has adopted many constructs from later languages in an effort to clean up its
    act.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下情况：最早期的成功编程语言之一是COBOL，然而现代编程语言几乎没有继承COBOL的设计模式。例如，我们不会将代码划分为不同的部分，也不会使用句点来结束代码行。很少有程序员会猜到PIC是一个可变字符字符串。COBOL的一些特性出现在其他语言中，但它的语法和接口几乎没有保留下来。相反，COBOL自己则采纳了许多后来的语言结构，试图清理它的设计。
- en: On the other hand, ALGOL60 has profoundly shaped the structure and syntax of
    virtually every modern language, but you’d struggle to find a programmer today
    who has ever even heard of it.^([11](#c02-footnote-11))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，ALGOL60深刻地影响了几乎所有现代语言的结构和语法，但今天你很难找到一个程序员曾经听说过它。^([11](#c02-footnote-11))
- en: When we examine the accomplishments of various programming languages, COBOL
    is the obvious winner. COBOL programs still shuffle millions of transactions and
    trillions of dollars from point A to point B. It’s hard to name a single thing
    of significance that was ever implemented in ALGOL60\. The language BCPL, a similarly
    influential and obscure descendent of ALGOL60, survived just long enough to become
    the grandfather of C. So how on Earth did the patterns of failed languages become
    more familiar to early computer scientists than the patterns of the first truly
    successful, cross-platform high-level programming language?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们审视各种编程语言的成就时，COBOL显然是赢家。COBOL程序至今仍然处理着数百万笔交易和数万亿美元的资金流动，从A点到B点。很难提到ALGOL60曾经实现过的任何具有重大意义的事物。与ALGOL60同样有影响力且不为人知的语言BCPL，幸存下来并成为C语言的祖先。那么，早期计算机科学家们怎么会比第一种真正成功的跨平台高级编程语言的模式更熟悉那些失败语言的模式呢？
- en: The answer is that COBOL was a language built for people who did not want to
    understand how the computer worked; they just wanted to get the job done. When
    the Committee on Data Systems Languages (CODASYL) was developing COBOL, the attitude
    among those devoted to the study and development of computers was that you should
    learn the flavor of Assembly relevant for your particular machine. Making programming
    more accessible and code human-readable was considered an anti-pattern, dumbing
    down the beauty of programming for an unworthy audience.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，COBOL是一种为那些不想理解计算机如何工作的人的需求而设计的语言；他们只是想完成工作。当数据系统语言委员会（CODASYL）在开发COBOL时，那些致力于计算机研究与开发的人认为，你应该学习适用于你特定机器的汇编语言。让编程更易于访问、让代码更具人类可读性被视为一种反模式，认为这种做法是在降低编程的美感，迎合不值得的观众。
- en: This audience, however, was made up of people who actually used computers for
    practical purposes, and many of them were largely unamused by the idea that they
    should rewrite their programs every single time they upgraded their machines.
    This group of people didn’t care about being “real programmers.” They cared about
    getting stuff done, better and faster than the competition if possible. Technical
    correctness didn’t matter. Elegance didn’t matter. Execution mattered, and anything
    that lowered the barrier to using computers to execute their goals was preferable
    to more powerful tools that were harder to learn.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些观众实际上是那些为了实际目的而使用计算机的人，他们中的许多人对每次升级机器时都必须重写程序的想法感到无聊。这个群体的人不在乎是否是“真正的程序员”。他们关心的是比竞争对手做得更好、更快。如果可能的话。技术正确性不重要，优雅不重要，执行才是关键，任何能降低使用计算机执行目标的门槛的东西，都比那些更强大但更难学习的工具更可取。
- en: 'Computer scientists during this period had opposite incentives. While COBOL
    users were judged and rewarded based on their ability to get nontechnical things
    done faster with computers, ALGOL60 users were judged and rewarded based on their
    ability to expand the functionality of what was even possible to do with the machines
    in the first place. Typically, there were two types of accomplishments in this
    space: get the machine to do something new or get the machine to do something
    more efficiently than before. For computer scientists, the programming language
    *was* the output. After it was developed, the next step was not to write programs,
    but to write papers about the language and share them with other academics for
    feedback and study.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这一时期的计算机科学家们有着相反的动机。尽管COBOL用户根据他们通过计算机更快地完成非技术性任务的能力来评判和奖励，但ALGOL60用户则根据他们扩展机器原本能做的功能的能力来评判和奖励。通常，这一领域有两种成就类型：让机器做一些新的事情，或者让机器比以前更高效地完成某些事情。对于计算机科学家来说，编程语言*本身就是*输出。开发完成后，下一步不是编写程序，而是撰写关于该语言的论文，并与其他学者分享以获取反馈和进行研究。
- en: 'Roughly three networks of people were programming computers between the 1950s
    and 1970s: scientists and mathematicians, data processors, and academics or computer
    researchers.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，从1950年代到1970年代之间，有三种人群在编程计算机：科学家和数学家、数据处理人员，以及学者或计算机研究人员。
- en: '**Scientists and mathematicians** used computers for calculations, and they
    preferred languages that reflected scientific and mathematical notation as much
    as possible. This community popularized FORTRAN.^([12](#c02-footnote-12)) When
    two math professors at Dartmouth wanted to create a language to make programming
    more accessible to students, they borrowed heavily from the syntax of FORTRAN
    II to develop BASIC. BASIC went on to spawn hundreds of variants, many of which
    are still in use today.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**科学家和数学家**用计算机进行计算，他们更倾向于使用尽可能反映科学和数学符号的语言。这个群体使得FORTRAN广为人知。当达特茅斯的两位数学教授希望创建一种更容易让学生学习的编程语言时，他们大量借鉴了FORTRAN
    II的语法，开发出了BASIC。BASIC后来衍生出了数百种变种，其中许多至今仍在使用。'
- en: '**Data processors** used computers to read data from one source and either
    run calculations or transform that data in some way before saving it to another
    source. These were the COBOL users, and that language proved so effective, it
    is still being used today.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据处理人员**使用计算机从一个源读取数据，然后进行计算或以某种方式转换数据，再保存到另一个源。这些正是COBOL的用户，而这种语言证明了它的有效性，至今仍在使用。'
- en: 'If you want proof that adoption is influenced by shared knowledge among networks
    of people and not strictly merit, consider this: the organizations that are trying
    to replace their old COBOL applications today are not migrating them to what would
    be the first choice for data processing among modern programming languages, which
    is Python, but to the language that has inherited COBOL’s market of a common language
    for businesses, which is Java.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想证明采用决策受人们网络间共享知识而非严格凭借优点的影响，考虑这一点：今天那些试图替换旧的COBOL应用程序的组织，并没有将其迁移到现代编程语言中最适合数据处理的首选语言——Python，而是迁移到继承了COBOL作为企业通用语言市场的语言——Java。
- en: The design of the language is never what’s important; it’s the people. The type
    of people who would have become COBOL programmers before are now becoming Java
    programmers, making Java the natural choice, despite that it was not designed
    to handle the use case for which COBOL was optimized.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的设计从来都不是最重要的，重要的是人群。那些原本会成为COBOL程序员的人，现在正成为Java程序员，这使得Java成为自然的选择，尽管它并不是为了处理COBOL所优化的用例而设计的。
- en: Perhaps that’s why so much COBOL remains in place, having resisted all attempts
    to eliminate it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这就是为什么COBOL仍然在许多地方存在，并且抵抗了所有试图淘汰它的努力。
- en: '**Academics and computer researchers** focused on the development of computers.
    When they finally moved off Assembly, it was onto languages specifically for documenting
    and implementing algorithms. ALGOL60 may not have been used to build many applications,
    but it was what the Association for Computing Machinery (ACM) used to describe
    algorithms in textbooks and academic sources for more than 30 years. This made
    it a powerful influence on the languages researchers later developed.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**学者和计算机研究人员**专注于计算机的发展。当他们最终从汇编语言转移时，他们转向了专门用于文档化和实现算法的语言。ALGOL60可能没有被用来构建很多应用程序，但它是计算机协会（ACM）用于在教科书和学术资源中描述算法的语言，超过了30年。这使得它对研究人员后续开发的语言产生了强大的影响。'
- en: 'The University of Cambridge developed the Cambridge Programming Language (CPL)
    based on ALGOL60\. CPL led to BCPL, which was stripped down to create B, which
    was further modified to create C. Next, C became the programming language of choice
    for this group of users, and it led to the development of a huge number of languages
    used by all kinds of programmers: Java, Go, PHP (via Perl), Ruby, Python, and
    Swift.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 剑桥大学基于ALGOL60开发了剑桥编程语言（CPL）。CPL后来发展为BCPL，BCPL被简化以创建B，进一步修改后又形成了C。接着，C成为了这一群体的首选编程语言，并促成了大量编程语言的开发，这些语言被各种各样的程序员使用：Java、Go、PHP（通过Perl）、Ruby、Python和Swift。
- en: Also popular with this group were the Lisps. Because the original Lisp was only
    a theoretical design document, to this day, waves of different implementations
    spring up quickly followed by futile attempts to standardize. During the 1960s
    and 1970s, Lisp was strongly associated with AI research and largely was relegated
    to that niche. Ironically, our own era of computing has seen much more progress
    in AI, but Lisp hardly plays a critical role. Instead, today’s Lisps are seen
    as a family of general programming languages that occasionally inject ideas and
    structures into more mainstream languages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对这一群体来说，Lisp也很受欢迎。因为最初的Lisp只是一个理论设计文档，直到今天，不同的实现层出不穷，紧随其后的是无果的标准化尝试。在1960和1970年代，Lisp与人工智能研究紧密相关，并且基本上被归类为这一领域的利基技术。具有讽刺意味的是，在我们的计算时代，人工智能取得了更多的进展，但Lisp几乎没有发挥关键作用。相反，今天的Lisp被看作是一类通用编程语言，偶尔将一些思想和结构注入到更主流的语言中。
- en: So this pivotal moment of computer science history had two groups of people
    who programmed in order to achieve some practical purpose not related to the computers
    themselves and one group that worked with computers to push the boundaries of
    what the computers themselves could do. The bulk of languages that exist retain
    the constructs that were familiar to this third group of programmers, even though
    COBOL, FORTRAN, and BASIC had a much wider community of users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，计算机科学历史上的这一关键时刻，出现了两类人群，他们编程是为了实现一些与计算机本身无关的实际目的，还有一类人群则与计算机合作，推动计算机本身能够做的事情的边界。现存的大多数编程语言保留了这些第三类程序员熟悉的构造，尽管COBOL、FORTRAN和BASIC拥有更广泛的用户群体。
- en: Overall, interfaces and ideas spread through networks of people, not based on
    merit or success. Exposure to a given configuration creates the perception that
    it’s easier and more intuitive, causing it to be passed down to more generations
    of technology. The lesson to learn here is the systems that feel familiar to people
    always provide more value than the systems that have structural elegances but
    run contrary to expectations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，接口和理念通过人际网络传播，而不是基于优点或成功。接触到某种配置会产生一种认为它更容易且更直观的感知，从而使其传递给更多代的技术。这里要学到的教训是，那些对人们来说熟悉的系统，总是比那些有结构优雅但与预期相悖的系统提供更多价值。
- en: Leveraging Interfaces When Approaching Legacy Systems
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在接近遗留系统时利用接口
- en: When I’m working on a legacy system, I always start off by evaluating the prospective
    users. Who will be maintaining this system long term? What technologies are they
    comfortable with? Who will be using this system the most? How do they expect the
    system to work?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在处理遗留系统时，我总是首先评估潜在用户。谁将长期维护这个系统？他们习惯使用哪些技术？谁将最常使用这个系统？他们期望系统如何工作？
- en: That doesn’t mean things can’t be changed or new concepts can’t be introduced.
    Particularly if the system is a couple decades old, the interfaces are probably
    tied to processes and associations that don’t make sense anymore, just like the
    way 80-character lines come from punch cards, two-character Linux commands come
    from teletype machines, and the save icon on desktop applications is a floppy
    disk. Sometimes changing interfaces to get rid of requirements that are no longer
    relevant is a good thing. Defining what the requirements of a minimum viable product
    (MVP) would be today if the system were brand new is a great thought experiment
    to run when formalizing a plan of attack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着不能改变事物或引入新概念。特别是如果系统已有几十年历史，接口可能与不再合理的过程和关联捆绑在一起，就像80字符的行源自打孔卡，两个字符的Linux命令源自电传打字机，桌面应用程序上的保存图标是软盘一样。有时候，改变接口以去除不再相关的需求是件好事。如果系统是全新的，那么定义今天一个最小可行产品（MVP）的需求是什么，是在制定攻击计划时进行思维实验的一个好方法。
- en: However, even when the result of change is net positive, changing interfaces
    is not free. Making people think adds friction and increases the odds of failure,
    even if the new interface is better and more consistent with the overall vision
    of the product.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使变化的结果是净正面的，改变接口也不是免费的。让人们思考会增加摩擦，增加失败的可能性，即使新的接口更好，更符合产品的整体愿景。
- en: Engineers tend to overestimate the value of order and neatness. The only thing
    that really matters with a computer system is its effectiveness at performing
    its practical application. Linux did not come to dominate the operating system
    world because it had been artfully designed from scratch; it scraped together
    ideas and implementations from a number of different systems and focused on adding
    value in one key place, the kernel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师往往高估了秩序和整洁的价值。计算机系统真正重要的，只有它在执行实际应用时的有效性。Linux之所以能够主导操作系统世界，并不是因为它从零开始经过精心设计；它是从多个不同系统中收集了想法和实现，集中力量在一个关键地方——内核上，创造了价值。
- en: The incentives that reward individual software engineers for their uniqueness,
    their ability to do new things, or to do old things in innovative ways are still
    present, even if the desire to publish papers in academic journals has been supplanted
    by the desire to write popular blog posts. Yet technology is more likely to be
    successful when it builds on common things. These two forces are always in tension
    with any software project, but legacy systems are particularly vulnerable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是撰写学术论文的愿望已被撰写流行博客的愿望所取代，仍然存在奖励个人软件工程师独特性、创新能力，或以创新方式完成旧事物的激励机制。然而，当技术建立在共同的事物之上时，它更有可能取得成功。这两股力量在任何软件项目中总是相互冲突，但遗留系统尤其容易受到影响。
- en: 'We know, for example, that iterating on existing solutions is more likely to
    improve software than a full rewrite. The dangers of full rewrites have been documented.
    Joel Spolsky of Fog Creek Software and Stack Overflow described them as “the single
    worst strategic mistake that any software company can make.”^([13](#c02-footnote-13))
    Chad Fowler, general manager of startups at Microsoft, describes it this way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，例如，基于现有解决方案进行迭代更可能改善软件，而不是进行完全重写。完全重写的风险已经有许多文献记录。Fog Creek Software和Stack
    Overflow的Joel Spolsky将其描述为“任何软件公司都可能犯下的最糟糕战略错误。”^([13](#c02-footnote-13)) 微软初创企业部门总经理Chad
    Fowler是这样描述的：
- en: Almost all production software is in such bad shape that it would be nearly
    useless as a guide to re-implementing itself. Now take this already bad picture,
    and extract only those products that are big, complex, and fragile enough to need
    a major rewrite, and the odds of success with this approach are significantly
    worse.^([14](#c02-footnote-14))
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎所有生产软件的状态都糟糕到几乎无法作为重新实现自身的指导。现在，拿这个已经糟糕的情况，只挑选出那些足够庞大、复杂且脆弱到需要大规模重写的产品，那么采用这种方法成功的概率就会显著降低。^([14](#c02-footnote-14))
- en: Fred Brooks coined the term *second system syndrome* in 1975 to explain the
    tendency of such full rewrites to produce bloated, inefficient, and often nonfunctioning
    software. But he attributed such problems not to the rewrites themselves, but
    to the experience of the architects overseeing the rewrite. The second system
    in second system syndrome was not the second version of an existing system, it
    was the second system the architect had produced. Brooks’s feeling was that architects
    are stricter with their first systems because they have never built software before,
    but for their second systems, they become overconfident and tack on all kinds
    of flourishes and features that ultimately overcomplicate things. By their third
    systems, they have learned their lesson.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Fred Brooks在1975年创造了*第二系统综合症*这个术语，用以解释这种完全重写所产生的臃肿、低效且常常无法正常运行的软件现象。但他将这些问题归因于监督重写的架构师的经验，而不是重写本身。第二系统综合症中的“第二系统”并不是现有系统的第二个版本，而是架构师所制作的第二个系统。Brooks的看法是，架构师在做第一个系统时因为没有做过软件，所以会更严格，但在做第二个系统时，他们过于自信，加入了各种华而不实的装饰和功能，最终使事情变得过于复杂。等到他们做第三个系统时，才会吸取教训。
- en: Unfortunately, when confronted with the troubles of existing systems, engineering
    teams tend to build the most momentum around starting from scratch. Initiatives
    to repair and restore operational excellence gradually, much the way one would
    fix up an old house, tend to have few volunteers among engineering teams. That’s
    because Zajonc’s mere-exposure effect has an upper bound. There’s a point where
    familiarity breeds contempt.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当面临现有系统的问题时，工程团队往往会产生从零开始构建的最大动力。那些旨在逐步修复和恢复运营卓越性的举措，就像修缮一座老房子一样，通常在工程团队中很少有人愿意参与。这是因为Zajonc的单纯接触效应有一个上限。到了一定程度，熟悉感会导致轻蔑。
- en: From an economic perspective, there’s a difference between risk and *ambiguity*.^([15](#c02-footnote-15))
    Risks are known and estimable threats; ambiguities are places where outcomes both
    positive and negative are unknown. The traditional school of thought tells us
    that human beings are averse to ambiguity and will avoid it as much as possible.
    However, ambiguity aversion is one of those decision-making models that test well
    in laboratories but break down when brought into the real world where decisions
    are more complex and probabilities less clearly defined. Specifically when the
    decision involves multiple attributes, a positive framing of the problem can flip
    people’s behavior from ambiguity-avoiding to ambiguity-seeking.^([16](#c02-footnote-16))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从经济学角度来看，风险和*模糊性*之间是有区别的。^([15](#c02-footnote-15)) 风险是已知且可估算的威胁；而模糊性则是那些正负结果都未知的地方。传统的思维方式告诉我们，人类对模糊性有厌恶感，会尽可能避免它。然而，模糊性回避是那些在实验室中表现良好的决策模型，但当应用到现实世界时会出现问题，因为现实中的决策更复杂，概率定义也不那么清晰。特别是当决策涉及多个属性时，问题的积极框架可以让人们从回避模糊性转向寻求模糊性。^([16](#c02-footnote-16))
- en: The incentives of individual praise aside, engineering teams tend to gravitate
    toward full rewrites because they incorrectly think of old systems as specs. They
    assume that since an old system works, all technical challenges and possible problems
    have been settled. The risks have been eliminated! They can add more features
    to the new system or make changes to the underlying architecture without worry.
    Either they do not perceive the ambiguity these changes introduce or they see
    such ambiguity positively, imagining only gains in performance and the potential
    for greater innovation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开个人赞誉的动机不谈，工程团队倾向于进行全面重写，因为他们错误地将旧系统视为规范。他们认为，既然旧系统能工作，那么所有技术挑战和潜在问题都已经解决。风险已经消除！他们可以为新系统添加更多功能，或在不担心的情况下改变底层架构。要么他们没有察觉到这些变化带来的模糊性，要么他们将这种模糊性视为积极因素，想象着性能的提升和更大创新潜力。
- en: Meanwhile, the existing system has little ambiguity left. It is what it is,
    hypothetical potential exhausted. We know that past the upper bound of mere exposure,
    once people find a characteristic they do not like, they tend to judge every characteristic
    discovered after that more negatively.^([17](#c02-footnote-17)) So programmers
    prefer full rewrites over iterating legacy systems because rewrites maintain an
    attractive level of ambiguity while the existing systems are well known and, therefore,
    boring. It’s no accident that proposals for full rewrites tend to include introducing
    some language, design pattern, or technology that is new to the engineering team.
    Very few rewrite plans take the form of redesigning the system using the same
    language or merely fixing a well-defined structural issue. The goal of full rewrites
    is to restore ambiguity and, therefore, enthusiasm. They fail because the assumption
    that the old system can be used as a spec and be trusted to have diagnosed accurately
    and eliminated every risk is wrong.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，现有系统的模糊性已所剩无几。它就是它，假设的潜力已被耗尽。我们知道，在超出仅仅接触的上限后，一旦人们发现了他们不喜欢的特性，他们往往会对之后发现的每个特性进行更负面的评判。^([17](#c02-footnote-17))
    所以程序员更喜欢进行全面重写而不是迭代旧系统，因为重写保持了吸引人的模糊性，而现有系统已经非常熟悉，因此显得乏味。提出全面重写的提案通常会引入一些对工程团队来说新的语言、设计模式或技术，这并非偶然。很少有重写计划是以使用相同语言重新设计系统或仅仅解决一个明确定义的结构问题的形式出现的。全面重写的目标是恢复模糊性，从而恢复热情。而它们失败的原因在于，假设旧系统可以作为规范，并被信任为准确诊断并消除了所有风险，这个假设是错误的。
- en: Beware Artificial Consistency
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心人为一致性
- en: In the next chapter, I’ll go into detail about how to balance these tensions
    to develop a strategy around when to reinvent and rewrite and when to leverage
    existing and familiar interfaces. But for now, the takeaway from this exploration
    of how traits are passed down should be that perception of simplicity is influenced
    by what your use case for technology exposes you to. Things seem easier when they
    are familiar. Familiarity is determined by what you are doing with technology
    and who you are doing it with.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将详细介绍如何平衡这些紧张关系，以便制定策略，决定何时重构和重写，何时利用现有的、熟悉的接口。但目前为止，从这次关于特征如何传递的探索中，我们应该得到的结论是，简洁的感知受到你在技术使用场景中所接触到的事物的影响。当事物变得熟悉时，它们看起来更容易。熟悉感是由你与技术互动的方式以及与你一起使用技术的人决定的。
- en: But familiarity has downsides as well. While working with legacy systems, you’ll
    find yourself fielding many proposals that claim to improve the system largely
    by establishing artificial consistency. *Artificial consistency* means restricting
    design patterns and solutions to a small pool that can be standardized and repeated
    throughout the entire architecture in a way that does not provide technical value.
    What’s important to understand about artificial consistency is that it focuses
    on consistency of form and classification over functionality. As an example, Node.js
    and React.js are both forms of JavaScript. These two technologies look consistent,
    but they do different things and are built upon different abstractions. The fact
    that they are both forms of JavaScript doesn’t give Node.js an edge when interacting
    with React.js over any other backend language that an engineering team might choose
    instead. An engineer’s skill in one does not necessarily translate to the other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但熟悉性也有其弊端。在处理遗留系统时，你会遇到许多提案，声称通过建立人为一致性来改善系统。*人为一致性*意味着将设计模式和解决方案限制在一个小范围内，可以在整个架构中标准化并反复使用，而这种做法并没有提供技术价值。理解人为一致性的重要点是，它关注的是形式和分类的一致性，而非功能的一致性。举个例子，Node.js
    和 React.js 都是 JavaScript 的形式。这两种技术看起来一致，但它们做的事情不同，并且构建在不同的抽象层上。它们都是 JavaScript
    的形式，并不能让 Node.js 在与 React.js 互动时比任何其他后端语言更具优势。一个工程师在其中一者上的技能，并不一定能转化到另一者上。
- en: Artificial consistency can bring value to nontechnical processes. For example,
    standardizing on one programming language makes recruiting, hiring, and, ultimately,
    sharing engineering resources much easier. But when the principal purpose of a
    modernization effort is to provide technical value, be careful not to be seduced
    by the assumption that things that look the same, or that we use the same words
    to describe, actually integrate better.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 人为一致性可以为非技术过程带来价值。例如，标准化使用一种编程语言可以让招聘、雇佣和最终共享工程资源变得更加容易。但当现代化努力的主要目的是提供技术价值时，要小心不要被这种假设迷惑：即看起来相同，或者我们用相同的词来描述的东西，实际上并不一定能更好地集成。
- en: Another place where artificial consistency comes into play is with databases.
    The top choices for databases 10 years ago are not the top choices today, so senior
    leaders sometimes will ask that legacy databases be migrated to another option
    more consistent with whatever newer systems are using. As with the previous example,
    there are legitimate nontechnical reasons to do this, such as not wanting the
    expense of supporting two different databases that essentially behave the same
    way, but the issue quickly can get out of hand when the engineering team is being
    asked to remove the key value store they’re using for a cache in favor of a relational
    database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个人为一致性发挥作用的地方是在数据库上。十年前数据库的首选不再是今天的首选，因此高层领导有时会要求将遗留数据库迁移到与新系统使用的数据库更一致的选项中。就像前面的例子一样，这样做有合理的非技术原因，比如不想承担同时支持两种基本相同数据库的费用，但当工程团队被要求移除用于缓存的键值存储，转而使用关系数据库时，问题很容易失控。
- en: Figuring out when consistency adds technical value and when it is artificial
    is one of the hardest decisions an engineering team must make. Human beings are
    pattern-matching machines. The flip side of finding familiar things easier is
    that we tend to over-optimize, giving in to artificial consistency when better
    tools are available to us.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一致性何时能带来技术价值，何时只是人为的，是工程团队必须做出的最艰难决策之一。人类是模式匹配机器。发现熟悉的事物更容易的反面是，我们往往会过度优化，屈从于人为的一致性，尽管有更好的工具可以使用。
