- en: Chapter 49. Memory Mappings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第49章. 内存映射
- en: This chapter discusses the use of the *mmap()* system call to create memory
    mappings. Memory mappings can be used for IPC, as well as a range of other purposes.
    We begin with an overview of some fundamental concepts before considering *mmap()*
    in depth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了使用 *mmap()* 系统调用来创建内存映射。内存映射可以用于进程间通信（IPC），以及其他多种用途。在深入讨论 *mmap()* 之前，我们首先介绍一些基本概念。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'The *mmap()* system call creates a new *memory mapping* in the calling process’s
    virtual address space. A mapping can be of two types:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*mmap()* 系统调用在调用进程的虚拟地址空间中创建一个新的 *内存映射*。映射可以有两种类型：'
- en: '*File mapping*: A file mapping maps a region of a file directly into the calling
    process’s virtual memory. Once a file is mapped, its contents can be accessed
    by operations on the bytes in the corresponding memory region. The pages of the
    mapping are (automatically) loaded from the file as required. This type of mapping
    is also known as a *file-based mapping* or *memory-mapped file*.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件映射*：文件映射将文件的一部分直接映射到调用进程的虚拟内存中。文件一旦被映射，其内容可以通过在相应内存区域上的字节操作来访问。映射的页会根据需要（自动）从文件加载。此类型的映射也称为
    *基于文件的映射* 或 *内存映射文件*。'
- en: '*Anonymous mapping*: An anonymous mapping doesn’t have a corresponding file.
    Instead, the pages of the mapping are initialized to 0.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*匿名映射*：匿名映射没有对应的文件。相反，映射的页被初始化为0。'
- en: Note
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another way of thinking of an anonymous mapping (and one that is close to the
    truth) is that it is a mapping of a virtual file whose contents are always initialized
    with zeros.
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种看待匿名映射的方式（这也是接近真实的理解）是，它是一个虚拟文件的映射，该文件的内容始终被初始化为零。
- en: 'The memory in one process’s mapping may be shared with mappings in other processes
    (i.e., the page-table entries of each process point to the same pages of RAM).
    This can occur in two ways:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程的映射中的内存可能与其他进程的映射共享（即，每个进程的页表项指向相同的物理内存页）。这种情况可以通过两种方式发生：
- en: When two processes map the same region of a file, they share the same pages
    of physical memory.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个进程映射同一文件的相同区域时，它们共享相同的物理内存页。
- en: A child process created by *fork()* inherits copies of its parent’s mappings,
    and these mappings refer to the same pages of physical memory as the corresponding
    mappings in the parent.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 *fork()* 创建的子进程继承父进程的映射副本，这些映射引用与父进程相应映射相同的物理内存页。
- en: 'When two or more processes share the same pages, each process can potentially
    see the changes to the page contents made by other processes, depending on whether
    the mapping is *private* or *shared*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多进程共享相同的内存页时，根据映射是 *私有* 还是 *共享*，每个进程可能会看到其他进程对该页内容所做的修改。
- en: '*Private mapping* (`MAP_PRIVATE`): Modifications to the contents of the mapping
    are not visible to other processes and, for a file mapping, are not carried through
    to the underlying file. Although the pages of a private mapping are initially
    shared in the circumstances described above, changes to the contents of the mapping
    are nevertheless private to each process. The kernel accomplishes this using the
    copy-on-write technique ([Memory Semantics of *fork()*](ch24.html#memory_semantics_of_fork_open_parenthesi
    "Memory Semantics of fork()")). This means that whenever a process attempts to
    modify the contents of a page, the kernel first creates a new, separate copy of
    that page for the process (and adjusts the process’s page tables). For this reason,
    a `MAP_PRIVATE` mapping is sometimes referred to as a *private, copy-on-write
    mapping*.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有映射* (`MAP_PRIVATE`)：对映射内容的修改对其他进程不可见，对于文件映射，这些修改不会传递到底层文件。尽管私有映射的页最初在上述情况下是共享的，但对映射内容的更改仍然对每个进程是私有的。内核通过写时复制技术实现这一点（[fork()
    的内存语义](ch24.html#memory_semantics_of_fork_open_parenthesi "Memory Semantics of
    fork()")）。这意味着，每当一个进程尝试修改页的内容时，内核会首先为该进程创建该页的一个新的独立副本（并调整该进程的页表）。因此，`MAP_PRIVATE`
    映射有时被称为 *私有的写时复制映射*。'
- en: '*Shared mapping* (`MAP_SHARED`): Modifications to the contents of the mapping
    are visible to other processes that share the same mapping and, for a file mapping,
    are carried through to the underlying file.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享映射* (`MAP_SHARED`)：对映射内容的修改对其他共享相同映射的进程可见，对于文件映射，这些修改会传递到底层文件。'
- en: The two mapping attributes described above (file versus anonymous and private
    versus shared) can be combined in four different ways, as summarized in [Table 49-1](ch49.html#purposes_of_various_types_of_memory_mapp
    "Table 49-1. Purposes of various types of memory mappings").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的两种映射属性（文件与匿名，私有与共享）可以以四种不同的方式组合，如[表49-1](ch49.html#purposes_of_various_types_of_memory_mapp
    "表49-1. 各种类型内存映射的用途")中总结。
- en: Table 49-1. Purposes of various types of memory mappings
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表49-1. 各种类型内存映射的用途
- en: '| Visibility of modifications | Mapping type |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 修改的可见性 | 映射类型 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| File | Anonymous |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 匿名 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Private** | Initializing memory from contents of file | Memory allocation
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **私有** | 从文件内容初始化内存 | 内存分配 |'
- en: '| **Shared** | Memory-mapped I/O; sharing memory between processes (IPC) |
    Sharing memory between processes (IPC) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **共享** | 内存映射I/O；进程间共享内存（IPC） | 进程间共享内存（IPC） |'
- en: 'The four different types of memory mappings are created and used as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 四种不同类型的内存映射的创建与使用如下：
- en: '*Private file mapping*: The contents of the mapping are initialized from a
    file region. Multiple processes mapping the same file initially share the same
    physical pages of memory, but the copy-on-write technique is employed, so that
    changes to the mapping by one process are invisible to other processes. The main
    use of this type of mapping is to initialize a region of memory from the contents
    of a file. Some common examples are initializing a process’s text and initialized
    data segments from the corresponding parts of a binary executable file or a shared
    library file.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有文件映射*：映射的内容是从文件区域初始化的。多个进程映射同一文件时，最初共享相同的物理内存页面，但采用写时复制技术，因此一个进程对映射的修改对其他进程是不可见的。这种映射方式的主要用途是从文件的内容初始化内存区域。一些常见的例子是从二进制可执行文件或共享库文件的相应部分初始化进程的文本段和已初始化的数据段。'
- en: '*Private anonymous mapping*: Each call to *mmap()* to create a private anonymous
    mapping yields a new mapping that is distinct from (i.e., does not share physical
    pages with) other anonymous mappings created by the same (or a different) process.
    Although a child process inherits its parent’s mappings, copy-on-write semantics
    ensure that, after the *fork()*, the parent and child don’t see changes made to
    the mapping by the other process. The primary purpose of private anonymous mappings
    is to allocate new (zero-filled) memory for a process (e.g., *malloc()* employs
    *mmap()* for this purpose when allocating large blocks of memory).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有匿名映射*：每次调用*mmap()*创建私有匿名映射时，都会产生一个新的映射，它与其他由同一进程（或不同进程）创建的匿名映射不同（即不共享物理页面）。虽然子进程会继承父进程的映射，但写时复制语义确保在*fork()*之后，父进程和子进程不会看到对映射所做的任何更改。私有匿名映射的主要用途是为进程分配新的（零填充的）内存（例如，*malloc()*在分配大块内存时使用*mmap()*来实现）。'
- en: '*Shared file mapping*: All processes mapping the same region of a file share
    the same physical pages of memory, which are initialized from a file region. Modifications
    to the contents of the mapping are carried through to the file. This type of mapping
    serves two purposes. First, it permits *memory-mapped I/O*. By this, we mean that
    a file is loaded into a region of the process’s virtual memory, and modifications
    to that memory are automatically written to the file. Thus, memory-mapped I/O
    provides an alternative to using *read()* and *write()* for performing file I/O.
    A second purpose of this type of mapping is to allow unrelated processes to share
    a region of memory in order to perform (fast) IPC in a manner similar to System
    V shared memory segments ([Chapter 48](ch48.html "Chapter 48. System V Shared
    Memory")).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享文件映射*：所有映射同一文件区域的进程共享相同的物理内存页面，这些内存页面是从文件区域初始化的。对映射内容的修改会同步到文件中。这种映射方式有两个目的。首先，它允许*内存映射I/O*。即，文件被加载到进程的虚拟内存区域中，对该内存的修改会自动写入文件。因此，内存映射I/O提供了一个替代*read()*和*write()*执行文件I/O的方式。第二个目的就是允许不相关的进程共享一块内存区域，以便进行（快速的）进程间通信（IPC），这种方式类似于System
    V共享内存段（[第48章](ch48.html "第48章. System V共享内存")）。'
- en: '*Shared anonymous mapping*: As with a private anonymous mapping, each call
    to *mmap()* to create a shared anonymous mapping creates a new, distinct mapping
    that doesn’t share pages with any other mapping. The difference is that the pages
    of the mapping are not copied-on-write. This means that when a child inherits
    the mapping after a *fork()*, the parent and child share the same pages of RAM,
    and changes made to the contents of the mapping by one process are visible to
    the other process. Shared anonymous mappings allow IPC in a manner similar to
    System V shared memory segments, but only between related processes.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享匿名映射*：与私有匿名映射一样，每次调用*mmap()*来创建共享匿名映射时，都会创建一个新的、独立的映射，不与其他映射共享页面。不同之处在于，该映射的页面不会进行写时复制。这意味着，当子进程在*fork()*之后继承映射时，父进程和子进程共享相同的RAM页面，一个进程对映射内容的修改对另一个进程可见。共享匿名映射允许类似于System
    V共享内存段的进程间通信（IPC），但仅限于相关进程之间。'
- en: We consider each of these types of mapping in more detail in the remainder of
    this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分更详细地讨论这些类型的映射。
- en: Mappings are lost when a process performs an *exec()*, but are inherited by
    the child of a *fork()*. The mapping type (`MAP_PRIVATE` or `MAP_SHARED`) is also
    inherited.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程执行*exec()*时，映射会丢失，但在*fork()*的子进程中会继承映射。映射类型（`MAP_PRIVATE`或`MAP_SHARED`）也会被继承。
- en: Information about all of a process’s mappings is visible in the Linux-specific
    `/proc/`*PID*`/maps` file, which we described in Section 48.5.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有关进程所有映射的信息可以在Linux特定的`/proc/`*PID*`/maps`文件中查看，我们在第48.5节中描述了该文件。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One further use of *mmap()* is with POSIX shared memory objects, which allow
    a region of memory to be shared between unrelated processes without having to
    create an associated disk file (as is required for a shared file mapping). We
    describe POSIX shared memory objects in [Chapter 54](ch54.html "Chapter 54. POSIX
    Shared Memory").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*mmap()*的另一个用途是与POSIX共享内存对象配合使用，它允许不同进程之间共享一块内存区域，而无需创建关联的磁盘文件（这对于共享文件映射是必需的）。我们在[第54章](ch54.html
    "第54章. POSIX共享内存")中描述了POSIX共享内存对象。'
- en: 'Creating a Mapping: *mmap()*'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建映射：*mmap()*
- en: The *mmap()* system call creates a new mapping in the calling process’s virtual
    address space.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*mmap()*系统调用在调用进程的虚拟地址空间中创建一个新的映射。'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns starting address of mapping on success, or `MAP_FAILED` on error
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回映射的起始地址，出错时返回`MAP_FAILED`
- en: The *addr* argument indicates the virtual address at which the mapping is to
    be located. If we specify *addr* as `NULL`, the kernel chooses a suitable address
    for the mapping. This is the preferred way of creating a mapping. Alternatively,
    we can specify a non-`NULL` value in *addr*, which the kernel takes as a hint
    about the address at which the mapping should be placed. In practice, the kernel
    will at the very least round the address to a nearby page boundary. In either
    case, the kernel will choose an address that doesn’t conflict with any existing
    mapping. (If the value `MAP_FIXED` is included in *flags*, then *addr* must be
    page-aligned. We describe this flag in [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*addr*参数表示映射将位于的虚拟地址。如果我们将*addr*指定为`NULL`，内核将为映射选择一个合适的地址。这是创建映射的首选方式。或者，我们可以在*addr*中指定一个非`NULL`的值，内核将把它作为映射应该放置的地址的提示。在实践中，内核至少会将地址四舍五入到附近的页面边界。在任何情况下，内核都会选择一个与现有映射不冲突的地址。（如果*flags*中包含`MAP_FIXED`，则*addr*必须是页面对齐的。我们在[MAP_FIXED标志](ch49.html#the_map_underscore_fixed_flag
    "MAP_FIXED标志")中描述了这个标志。）'
- en: On success, *mmap()* returns the starting address of the new mapping. On error,
    *mmap()* returns `MAP_FAILED`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*mmap()*返回新映射的起始地址。出错时，*mmap()*返回`MAP_FAILED`。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux (and on most other UNIX implementations), the `MAP_FAILED` constant
    equates to *((void *) -1)*. However, SUSv3 specifies this constant because the
    C standards can’t guarantee that *((void *) -1)* is distinct from a successful
    *mmap()* return value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux（以及大多数其他UNIX实现）中，`MAP_FAILED`常量等于*((void *) -1)*。然而，SUSv3指定了这个常量，因为C标准无法保证*((void
    *) -1)*与成功的*mmap()*返回值是不同的。
- en: The *length* argument specifies the size of the mapping in bytes. Although *length*
    doesn’t need to be a multiple of the system page size (as returned by *sysconf(_SC_PAGESIZE)*),
    the kernel creates mappings in units of this size, so that *length* is, in effect,
    rounded up to the next multiple of the page size.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*length* 参数指定映射的大小，以字节为单位。尽管 *length* 不需要是系统页面大小的倍数（由 *sysconf(_SC_PAGESIZE)*
    返回），但内核会以该大小为单位创建映射，因此 *length* 实际上会被向上舍入到下一个页面大小的倍数。'
- en: The *prot* argument is a bit mask specifying the protection to be placed on
    the mapping. It can be either `PROT_NONE` or a combination (ORing) of any of the
    other three flags listed in [Table 49-2](ch49.html#memory_protection_values "Table 49-2. Memory
    protection values").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*prot* 参数是一个位掩码，用于指定要对映射施加的保护。它可以是 `PROT_NONE`，或者是[表 49-2](ch49.html#memory_protection_values
    "表 49-2. 内存保护值")中列出的其他三种标志的任意组合（按位或）。'
- en: Table 49-2. Memory protection values
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 49-2. 内存保护值
- en: '| Value | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PROT_NONE` | The region may not be accessed |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_NONE` | 该区域不能被访问 |'
- en: '| `PROT_READ` | The contents of the region can be read |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_READ` | 该区域的内容可以被读取 |'
- en: '| `PROT_WRITE` | The contents of the region can be modified |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_WRITE` | 该区域的内容可以被修改 |'
- en: '| `PROT_EXEC` | The contents of the region can be executed |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_EXEC` | 该区域的内容可以被执行 |'
- en: 'The *flags* argument is a bit mask of options controlling various aspects of
    the mapping operation. Exactly one of the following values must be included in
    this mask:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数是一个位掩码，用于控制映射操作的各个方面。该掩码中必须包含以下值之一：'
- en: '`MAP_PRIVATE`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAP_PRIVATE`'
- en: Create a private mapping. Modifications to the contents of the region are not
    visible to other processes employing the same mapping, and, in the case of a file
    mapping, are not carried through to the underlying file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个私有映射。对该区域内容的修改不会对使用相同映射的其他进程可见，并且在文件映射的情况下，也不会传播到底层文件。
- en: '`MAP_SHARED`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAP_SHARED`'
- en: Create a shared mapping. Modifications to the contents of the region are visible
    to other processes mapping the same region with the `MAP_SHARED` attribute and,
    in the case of a file mapping, are carried through to the underlying file. Updates
    to the file are not guaranteed to be immediate; see the discussion of the *msync()*
    system call in Section 49.5.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个共享映射。对该区域内容的修改会对其他映射相同区域的进程可见，并且在文件映射的情况下，会传播到底层文件。对文件的更新不一定会立即生效；请参见第49.5节中关于
    *msync()* 系统调用的讨论。
- en: Aside from `MAP_PRIVATE` and `MAP_SHARED`, other flag values can optionally
    be ORed in *flags*. We discuss these flags in [Additional *mmap()* Flags](ch49.html#additional_mmap_open_parenthesis_close_p
    "Additional mmap() Flags") and [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`MAP_PRIVATE`和`MAP_SHARED`，其他标志值可以选择性地与*flags*进行按位或操作。我们在[附加的 *mmap()* 标志](ch49.html#additional_mmap_open_parenthesis_close_p
    "附加的 mmap() 标志")和[ `MAP_FIXED` 标志](ch49.html#the_map_underscore_fixed_flag "MAP_FIXED
    标志")中讨论这些标志。
- en: The remaining arguments, *fd* and *offset*, are used with file mappings (they
    are ignored for anonymous mappings). The *fd* argument is a file descriptor identifying
    the file to be mapped. The *offset* argument specifies the starting point of the
    mapping in the file, and must be a multiple of the system page size. To map the
    entire file, we would specify *offset* as 0 and *length* as the size of the file.
    We say more about file mappings in Section 49.5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其余参数 *fd* 和 *offset* 用于文件映射（对于匿名映射会被忽略）。*fd* 参数是一个文件描述符，用于标识要映射的文件。*offset*
    参数指定映射在文件中的起始位置，并且必须是系统页面大小的倍数。为了映射整个文件，我们会将 *offset* 指定为 0，将 *length* 指定为文件的大小。我们在第49.5节中详细讨论文件映射。
- en: Memory protection in more detail
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存保护的更多细节
- en: As noted above, the *mmap() prot* argument specifies the protection on a new
    memory mapping. It can contain the value `PROT_NONE`, or a mask of one of more
    of the flags `PROT_READ`, `PROT_WRITE`, and `PROT_EXEC`. If a process attempts
    to access a memory region in a way that violates the protection on the region,
    then the kernel delivers the `SIGSEGV` signal to a process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，*mmap() prot* 参数指定对新内存映射的保护。它可以包含值 `PROT_NONE`，或者是一个或多个标志 `PROT_READ`、`PROT_WRITE`
    和 `PROT_EXEC` 的按位掩码。如果一个进程尝试以违反区域保护的方式访问内存区域，内核会向该进程发送 `SIGSEGV` 信号。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although SUSv3 specifies that `SIGSEGV` should be used to signal memory protection
    violations, on some implementations, `SIGBUS` is used instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SUSv3规定应使用 `SIGSEGV` 来信号化内存保护违规，但在某些实现中，`SIGBUS` 被用来代替。
- en: One use of pages of memory marked `PROT_NONE` is as guard pages at the start
    or end of a region of memory that a process has allocated. If the process accidentally
    steps into one of the pages marked `PROT_NONE`, the kernel informs it of that
    fact by generating a `SIGSEGV` signal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`PROT_NONE`的内存页的一种用途是作为进程分配的内存区域的开始或结束的保护页。如果进程不小心访问了标记为`PROT_NONE`的页面，内核将通过生成`SIGSEGV`信号通知进程这一情况。
- en: Memory protections reside in process-private virtual memory tables. Thus, different
    processes may map the same memory region with different protections.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内存保护位于进程私有的虚拟内存表中。因此，不同的进程可以以不同的保护方式映射相同的内存区域。
- en: 'Memory protection can be changed using the *mprotect()* system call ([Changing
    Memory Protection: *mprotect()*](ch50.html#changing_memory_protection_colon_mprotec
    "Changing Memory Protection: mprotect()")).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '可以通过使用*mprotect()*系统调用来改变内存保护（[更改内存保护: *mprotect()*](ch50.html#changing_memory_protection_colon_mprotec
    "更改内存保护: mprotect()")）。'
- en: On some UNIX implementations, the actual protections placed on the pages of
    a mapping may not be exactly those specified in *prot*. In particular, limitations
    of the protection granularity of the underlying hardware (e.g., older x86-32 architectures)
    mean that, on many UNIX implementations, `PROT_READ` implies `PROT_EXEC` and vice
    versa, and on some implementations, specifying `PROT_WRITE` implies `PROT_READ`.
    However, applications should not rely on such behavior; *prot* should always specify
    exactly the memory protections that are required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些UNIX实现中，映射页上的实际保护可能与*prot*中指定的保护不完全相同。特别是，底层硬件的保护粒度限制（例如，较旧的x86-32架构）意味着在许多UNIX实现中，`PROT_READ`隐含着`PROT_EXEC`，反之亦然，在某些实现中，指定`PROT_WRITE`隐含着`PROT_READ`。然而，应用程序不应依赖这种行为；*prot*应该始终准确地指定所需的内存保护。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modern x86-32 architectures provide hardware support for marking pages tables
    as *NX* (no execute), and, since kernel 2.6.8, Linux makes use of this feature
    to properly separate `PROT_READ` and `PROT_EXEC` permissions on Linux/x86-32.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的x86-32架构提供硬件支持，用于标记页表为*NX*（不可执行），并且自内核2.6.8以来，Linux利用这一特性在Linux/x86-32上正确区分`PROT_READ`和`PROT_EXEC`权限。
- en: Alignment restrictions specified in standards for *offset* and *addr*
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准中指定的*offset*和*addr*的对齐限制
- en: 'SUSv3 specifies that the *offset* argument of *mmap()* must be page-aligned,
    and that the *addr* argument must also be page-aligned if `MAP_FIXED` is specified.
    Linux conforms to these requirements. However, it was later noted that the SUSv3
    requirements differed from earlier standards, which imposed looser requirements
    on these arguments. The consequence of the SUSv3 wording was to (unnecessarily)
    render some formerly standards-conformant implementations nonconforming. SUSv4
    returns to the looser requirement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，*mmap()*的*offset*参数必须与页面对齐，并且如果指定了`MAP_FIXED`，*addr*参数也必须与页面对齐。Linux遵循这些要求。然而，后来注意到SUSv3的要求与早期标准不同，后者对这些参数的要求更宽松。SUSv3的措辞结果是（不必要地）使一些原本符合标准的实现变得不合规。SUSv4则恢复了更宽松的要求：
- en: An implementation may require that *offset* be a multiple of the system page
    size.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可能要求*offset*是系统页面大小的倍数。
- en: If `MAP_FIXED` is specified, then an implementation may require that *addr*
    be page-aligned.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了`MAP_FIXED`，那么实现可能要求*addr*与页面对齐。
- en: If `MAP_FIXED` is specified, and *addr* is nonzero, then *addr* and *offset*
    shall have the same remainder modulo the system page size.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了`MAP_FIXED`，且*addr*非零，则*addr*和*offset*应该具有相同的余数，模系统页面大小。
- en: Note
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A similar situation arose for the *addr* argument of *mprotect()*, *msync()*,
    and *munmap()*. SUSv3 specified that this argument must be page-aligned. SUSv4
    says that an implementation may require this argument to be page-aligned.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于*mprotect()*、*msync()*和*munmap()*的*addr*参数，也出现了类似的情况。SUSv3规定该参数必须与页面对齐。SUSv4则表示，某些实现可能要求该参数与页面对齐。
- en: Example program
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 49-1](ch49.html#using_mmap_open_parenthesis_close_parent "Example 49-1. Using
    mmap() to create a private file mapping") demonstrates the use of *mmap()* to
    create a private file mapping. This program is a simple version of *cat(1)*. It
    maps the (entire) file named in its command-line argument, and then writes the
    contents of the mapping to standard output.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 49-1](ch49.html#using_mmap_open_parenthesis_close_parent "示例 49-1. 使用 mmap()
    创建私有文件映射")展示了如何使用*mmap()*来创建一个私有文件映射。这个程序是一个简单版的*cat(1)*。它映射命令行参数中指定的（整个）文件，然后将映射内容写入标准输出。'
- en: Example 49-1. Using *mmap()* to create a private file mapping
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 49-1. 使用 *mmap()* 创建私有文件映射
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Unmapping a Mapped Region: *munmap()*'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '取消映射映射区域: *munmap()*'
- en: The *munmap()* system call performs the converse of *mmap()*, removing a mapping
    from the calling process’s virtual address space.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*munmap()* 系统调用执行 *mmap()* 的反向操作，从调用进程的虚拟地址空间中移除映射。'
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *addr* argument is the starting address of the address range to be unmapped.
    It must be aligned to a page boundary. (SUSv3 specified that *addr must* be page-aligned.
    SUSv4 says that an implementation *may* require this argument to be page-aligned.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*addr* 参数是要取消映射的地址范围的起始地址。它必须与页面边界对齐。（SUSv3 指定 *addr 必须* 与页面对齐。SUSv4 说实现 *可以*
    要求此参数与页面对齐。）'
- en: The *length* argument is a nonnegative integer specifying the size (in bytes)
    of the region to be unmapped. The address range up to the next multiple of the
    system page size will be unmapped.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*length* 参数是一个非负整数，指定要取消映射的区域大小（以字节为单位）。将取消映射直到下一个系统页面大小的倍数。'
- en: 'Commonly, we unmap an entire mapping. Thus, we specify *addr* as the address
    returned by a previous call to *mmap()*, and specify the same *length* value as
    was used in the *mmap()* call. Here’s an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们取消映射整个映射。因此，我们将 *addr* 指定为之前 *mmap()* 调用返回的地址，并指定与 *mmap()* 调用中使用的相同的 *length*
    值。下面是一个例子：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, we can unmap part of a mapping, in which case the mapping either
    shrinks or is cut in two, depending on where the unmapping occurs. It is also
    possible to specify an address range spanning several mappings, in which case
    all of the mappings are unmapped.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以取消映射映射的一部分，在这种情况下，映射将缩小或根据取消映射的位置被切割成两部分。也可以指定一个跨越多个映射的地址范围，在这种情况下，所有的映射都会被取消映射。
- en: If there are no mappings in the address range specified by *addr* and *length*,
    then *munmap()* has no effect, and returns 0 (for success).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 *addr* 和 *length* 指定的地址范围内没有映射，那么 *munmap()* 将不起作用，并返回 0（表示成功）。
- en: During unmapping, the kernel removes any memory locks that the process holds
    for the specified address range. (Memory locks are established using *mlock()*
    or *mlockall()*, as described in Section 50.2.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在取消映射过程中，内核会移除进程在指定地址范围内持有的任何内存锁。（内存锁是通过 *mlock()* 或 *mlockall()* 建立的，详细说明见第
    50.2 节。）
- en: All of a process’s mappings are automatically unmapped when it terminates or
    performs an *exec()*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程终止或执行 *exec()* 时，它的所有映射会自动取消映射。
- en: 'To ensure that the contents of a shared file mapping are written to the underlying
    file, a call to *msync()* ([Synchronizing a Mapped Region: *msync()*](ch49.html#synchronizing_a_mapped_region_colon_msyn
    "Synchronizing a Mapped Region: msync()")) should be made before unmapping a mapping
    with *munmap()*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保共享文件映射的内容被写入到底层文件，在使用 *munmap()* 取消映射之前，应该调用 *msync()* ([同步映射区域: *msync()*](ch49.html#synchronizing_a_mapped_region_colon_msyn
    "同步映射区域: msync()"))。'
- en: File Mappings
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件映射
- en: 'To create a file mapping, we perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件映射，我们执行以下步骤：
- en: Obtain a descriptor for the file, typically via a call to *open()*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件描述符，通常通过调用 *open()*。
- en: Pass that file descriptor as the *fd* argument in a call to *mmap()*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该文件描述符作为 *fd* 参数传递给 *mmap()* 调用。
- en: As a result of these steps, *mmap()* maps the contents of the open file into
    the address space of the calling process. Once *mmap()* has been called, we can
    close the file descriptor without affecting the mapping. However, in some cases
    it may be useful to keep this file descriptor open—see, for example, [Example 49-1](ch49.html#using_mmap_open_parenthesis_close_parent
    "Example 49-1. Using mmap() to create a private file mapping") and also [Chapter 54](ch54.html
    "Chapter 54. POSIX Shared Memory").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些步骤，*mmap()* 将打开的文件内容映射到调用进程的地址空间中。调用了 *mmap()* 后，我们可以关闭文件描述符而不会影响映射。然而，在某些情况下，保持文件描述符打开可能是有用的——例如，参见
    [示例 49-1](ch49.html#using_mmap_open_parenthesis_close_parent "示例 49-1. 使用 mmap()
    创建私有文件映射")，以及 [第 54 章](ch54.html "第 54 章. POSIX 共享内存")。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As well as normal disk files, it is possible to use *mmap()* to map the contents
    of various real and virtual devices, such as hard disks, optical disks, and `/dev/mem`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通的磁盘文件外，还可以使用 *mmap()* 来映射各种真实和虚拟设备的内容，如硬盘、光盘以及 `/dev/mem`。
- en: The file referred to by the descriptor *fd* must have been opened with permissions
    appropriate for the values specified in *prot* and *flags*. In particular, the
    file must always be opened for reading, and, if `PROT_WRITE` and `MAP_SHARED`
    are specified in *flags*, then the file must be opened for both reading and writing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符 *fd* 所引用的文件必须已使用适当的权限打开，以便与 *prot* 和 *flags* 中指定的值匹配。特别是，文件必须始终以只读模式打开，如果在
    *flags* 中指定了 `PROT_WRITE` 和 `MAP_SHARED`，则文件必须同时以读写模式打开。
- en: The *offset* argument specifies the starting byte of the region to be mapped
    from the file, and must be a multiple of the system page size. Specifying *offset*
    as 0 causes the file to be mapped from the beginning. The *length* argument specifies
    the number of bytes to be mapped. Together, the *offset* and *length* arguments
    determine which region of the file is to be mapped into memory, as shown in [Figure 49-1](ch49.html#overview_of_memory-mapped_file
    "Figure 49-1. Overview of memory-mapped file").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*offset* 参数指定要从文件中映射的区域的起始字节，必须是系统页面大小的倍数。将 *offset* 指定为0会导致从文件开头开始映射。*length*
    参数指定要映射的字节数。*offset* 和 *length* 参数共同确定要映射到内存的文件区域，如[图49-1](ch49.html#overview_of_memory-mapped_file
    "图49-1. 内存映射文件概览")所示。'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, the pages of a file mapping are mapped in on the first access. This
    means that if changes are made to a file region after the *mmap()* call, but before
    the corresponding part (i.e., page) of the mapping is accessed, then the changes
    may be visible to the process, if the page has not otherwise already been loaded
    into memory. This behavior is implementation-dependent; portable applications
    should avoid relying on a particular kernel behavior in this scenario.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，文件映射的页面会在首次访问时被映射。这意味着，如果在 *mmap()* 调用后但在映射的相应部分（即页面）被访问之前对文件区域进行了更改，则如果该页面尚未加载到内存中，程序可能会看到这些更改。这种行为取决于实现；便携式应用程序应避免在这种情况下依赖特定的内核行为。
- en: Private File Mappings
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有文件映射
- en: 'The two most common uses of private file mappings are the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 私有文件映射的两种最常见用途如下：
- en: To allow multiple processes executing the same program or using the same shared
    library to share the same (read-only) text segment, which is mapped from the corresponding
    part of the underlying executable or library file.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许多个执行相同程序或使用相同共享库的进程共享相同的（只读）文本段，该文本段是从底层可执行文件或库文件的相应部分映射过来的。
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the executable text segment is normally protected to allow only read
    and execute access (`PROT_READ | PROT_EXEC`), it is mapped using `MAP_PRIVATE`
    rather than `MAP_SHARED`, because a debugger or a self-modifying program can modify
    the program text (after first changing the protection on the memory), and such
    changes should not be carried through to the underlying file or affect other processes.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管可执行的文本段通常受到保护，只允许读取和执行访问（`PROT_READ | PROT_EXEC`），它是使用 `MAP_PRIVATE` 而非 `MAP_SHARED`
    进行映射的，因为调试器或自修改程序可以修改程序文本（在首先更改内存保护后），这些修改不应该传递到底层文件中或影响其他进程。
- en: To map the initialized data segment of an executable or shared library. Such
    mappings are made private so that modifications to the contents of the mapped
    data segment are not carried through to the underlying file.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可执行文件或共享库的初始化数据段。此类映射为私有，以便对映射数据段内容的修改不会传递到底层文件。
- en: Both of these uses of *mmap()* are normally invisible to a program, because
    these mappings are created by the program loader and dynamic linker. Examples
    of both kinds of mappings can be seen in the `/proc/`*PID*`/maps` output shown
    in Section 48.5.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种* mmap() *的用途通常对程序是不可见的，因为这些映射是由程序加载器和动态链接器创建的。可以在第48.5节中看到这两种映射的示例，输出文件位于`/proc/`*PID*`/maps`中。
- en: One other, less frequent, use of a private file mapping is to simplify the file-input
    logic of a program. This is similar to the use of shared file mappings for memory-mapped
    I/O (described in the next section), but allows only for file input.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个较少见的私有文件映射用途是简化程序的文件输入逻辑。这类似于用于内存映射I/O的共享文件映射（将在下一节中描述），但仅允许文件输入。
- en: '![Overview of memory-mapped file](figs/web/49-1_MMAP-overview-scale90.png.jpg)Figure 49-1. Overview
    of memory-mapped file'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![内存映射文件概览](figs/web/49-1_MMAP-overview-scale90.png.jpg)图49-1. 内存映射文件概览'
- en: Shared File Mappings
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件映射
- en: When multiple processes create shared mappings of the same file region, they
    all share the same physical pages of memory. In addition, modifications to the
    contents of the mapping are carried through to the file. In effect, the file is
    being treated as the paging store for this region of memory, as shown in [Figure 49-2](ch49.html#two_processes_with_a_shared_mapping_of_t
    "Figure 49-2. Two processes with a shared mapping of the same region of a file").
    (We simplify things in this diagram by omitting to show that the mapped pages
    are typically not contiguous in physical memory.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个进程创建相同文件区域的共享映射时，它们共享相同的物理内存页面。此外，对映射内容的修改会传递到文件中。实际上，文件被当作该内存区域的分页存储，如[图49-2](ch49.html#two_processes_with_a_shared_mapping_of_t
    "图49-2. 两个进程共享同一文件区域的映射")所示。（我们在此图中简化处理，省略了映射的页面在物理内存中通常不是连续的这一细节。）
- en: 'Shared file mappings serve two purposes: memory-mapped I/O and IPC. We consider
    each of these uses below.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 共享文件映射有两个用途：内存映射I/O和进程间通信（IPC）。我们在下面将分别讨论这两种用途。
- en: '![Two processes with a shared mapping of the same region of a file](figs/web/49-2_MMAP-shared-mapping.png.jpg)Figure 49-2. Two
    processes with a shared mapping of the same region of a file'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个进程共享同一文件区域的映射](figs/web/49-2_MMAP-shared-mapping.png.jpg)图49-2. 两个进程共享同一文件区域的映射'
- en: Memory-mapped I/O
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存映射I/O
- en: Since the contents of the shared file mapping are initialized from the file,
    and any modifications to the contents of the mapping are automatically carried
    through to the file, we can perform file I/O simply by accessing bytes of memory,
    relying on the kernel to ensure that the changes to memory are propagated to the
    mapped file. (Typically, a program would define a structured data type that corresponds
    to the contents of the disk file, and then use that data type to cast the contents
    of the mapping.) This technique is referred to as *memory-mapped I/O*, and is
    an alternative to using *read()* and *write()* to access the contents of a file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于共享文件映射的内容是从文件初始化的，且对映射内容的任何修改都会自动传递到文件中，我们可以通过访问内存字节来执行文件I/O，依靠内核确保内存的变化被传播到映射的文件中。（通常，一个程序会定义一个结构化数据类型，该数据类型对应磁盘文件的内容，然后使用该数据类型将映射的内容进行转换。）这种技术被称为*内存映射I/O*，它是使用*read()*和*write()*访问文件内容的替代方案。
- en: 'Memory-mapped I/O has two potential advantages:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射I/O有两个潜在的优点：
- en: By replacing *read()* and *write()* system calls with memory accesses, it can
    simplify the logic of some applications.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将*read()*和*write()*系统调用替换为内存访问，它可以简化某些应用程序的逻辑。
- en: It can, in some circumstances, provide better performance than file I/O carried
    out using the conventional I/O system calls.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，它可以提供比使用传统I/O系统调用进行的文件I/O更好的性能。
- en: 'The reasons that memory-mapped I/O can provide performance benefits are as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射I/O能够提供性能优势的原因如下：
- en: 'A normal *read()* or *write()* involves two transfers: one between the file
    and the kernel buffer cache, and the other between the buffer cache and a user-space
    buffer. Using *mmap()* eliminates the second of these transfers. For input, the
    data is available to the user process as soon as the kernel has mapped the corresponding
    file blocks into memory. For output, the user process merely needs to modify the
    contents of the memory, and can then rely on the kernel memory manager to automatically
    update the underlying file.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常的*read()*或*write()*操作涉及两个传输：一个是文件与内核缓冲区缓存之间的传输，另一个是缓冲区缓存与用户空间缓冲区之间的传输。使用*mmap()*可以消除第二个传输。对于输入，数据在内核将相应的文件块映射到内存中后，即可供用户进程使用。对于输出，用户进程只需修改内存内容，然后依靠内核内存管理器自动更新底层文件。
- en: 'In addition to saving a transfer between kernel space and user space, *mmap()*
    can also improve performance by lowering memory requirements. When using *read()*
    or *write()*, the data is maintained in two buffers: one in user space and the
    other in kernel space. When using *mmap()*, a single buffer is shared between
    the kernel space and user space. Furthermore, if multiple processes are performing
    I/O on the same file, then, using *mmap()*, they can all share the same kernel
    buffer, resulting in an additional memory saving.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了节省内核空间与用户空间之间的传输外，*mmap()*还可以通过降低内存需求来提高性能。当使用*read()*或*write()*时，数据会保存在两个缓冲区中：一个在用户空间，另一个在内核空间。而使用*mmap()*时，内核空间和用户空间之间共享一个缓冲区。此外，如果多个进程正在对同一文件进行I/O操作，那么使用*mmap()*时，它们可以共享同一个内核缓冲区，从而实现额外的内存节省。
- en: Performance benefits from memory-mapped I/O are most likely to be realized when
    performing repeated random accesses in a large file. If we are performing sequential
    access of a file, then *mmap()* will probably provide little or no gain over *read()*
    and *write()*, assuming that we perform I/O using buffer sizes big enough to avoid
    making a large number of I/O system calls. The reason that there is little performance
    benefit is that, regardless of which technique we use, the entire contents of
    the file will be transferred between disk and memory exactly once, and the efficiency
    gains of eliminating a data transfer between user space and kernel space and reducing
    memory usage are typically negligible compared to the time required for disk I/O.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行大文件的重复随机访问时，内存映射 I/O 的性能优势最为明显。如果我们在执行文件的顺序访问，那么 *mmap()* 可能不会比 *read()*
    和 *write()* 提供更好的性能，前提是我们使用足够大的缓冲区大小，避免进行大量的 I/O 系统调用。之所以性能提升不明显，是因为无论使用哪种技术，文件的所有内容都会在磁盘和内存之间传输一次，而消除用户空间与内核空间之间的数据传输及减少内存使用的效率提升，通常与磁盘
    I/O 所需的时间相比微不足道。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Memory-mapped I/O can also have disadvantages. For small I/Os, the cost of memory-mapped
    I/O (i.e., mapping, page faulting, unmapping, and updating the hardware memory
    management unit’s translation look-aside buffer) can actually be higher than for
    a simple *read()* or *write()*. In addition, it can sometimes be difficult for
    the kernel to efficiently handle write-back for writable mappings (the use of
    *msync()* or *sync_file_range()* can help improve efficiency in this case).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射 I/O 也可能有一些缺点。对于小型 I/O 操作，内存映射 I/O 的成本（即映射、页面错误、取消映射以及更新硬件内存管理单元的转换旁路缓存）可能实际上比简单的
    *read()* 或 *write()* 更高。此外，内核有时可能难以高效地处理可写映射的写回操作（在这种情况下，使用 *msync()* 或 *sync_file_range()*
    可以帮助提高效率）。
- en: IPC using a shared file mapping
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用共享文件映射进行进程间通信（IPC）
- en: Since all processes with a shared mapping of the same file region share the
    same physical pages of memory, the second use of a shared file mapping is as a
    method of (fast) IPC. The feature that distinguishes this type of shared memory
    region from a System V shared memory object ([Chapter 48](ch48.html "Chapter 48. System
    V Shared Memory")) is that modifications to the contents of the region are carried
    through to the underlying mapped file. This feature is useful in an application
    that requires the shared memory contents to persist across application or system
    restarts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有共享同一文件区域映射的进程共享相同的物理内存页面，第二次使用共享文件映射的方法就是作为一种（快速的）进程间通信（IPC）方式。这种共享内存区域与
    System V 共享内存对象的区别在于（参见[第 48 章](ch48.html "第 48 章：System V 共享内存)")）的是，该区域内容的修改会反映到底层的映射文件中。这一特性在需要跨应用或系统重启保持共享内存内容的应用程序中非常有用。
- en: Example program
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 49-2](ch49.html#using_mmap_open_parenthesis_close_pa "Example 49-2. Using
    mmap() to create a shared file mapping") provides a simple example of the use
    of *mmap()* to create a shared file mapping. This program begins by mapping the
    file named in its first command-line argument. It then prints the value of the
    string lying at the start of the mapped region. Finally, if a second command-line
    argument is supplied, that string is copied into the shared memory region.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 49-2](ch49.html#using_mmap_open_parenthesis_close_pa "示例 49-2：使用 mmap()
    创建共享文件映射") 提供了一个使用 *mmap()* 创建共享文件映射的简单示例。该程序首先映射其第一个命令行参数指定的文件。然后打印映射区域起始处字符串的值。最后，如果提供了第二个命令行参数，该字符串将被复制到共享内存区域。'
- en: 'The following shell session log demonstrates the use of this program. We begin
    by creating a 1024-byte file that is populated with zeros:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 shell 会话日志演示了如何使用此程序。我们首先创建一个 1024 字节的文件，并用零填充：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then use our program to map the file and copy a string into the mapped region:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用程序映射文件并将一个字符串复制到映射区域：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The program displayed nothing for the current string because the initial value
    of the mapped files began with a null byte (i.e., zero-length string).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 程序没有显示当前字符串的内容，因为映射文件的初始值是一个空字节（即，零长度字符串）。
- en: 'Next, we use our program to again map the file and copy a new string into the
    mapped region:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用程序映射文件并将一个新的字符串复制到映射区域：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we dump the contents of the file, 8 characters per line, to verify
    its contents:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将文件内容按每行 8 个字符的方式转储，以验证其内容：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our trivial program doesn’t use any mechanism to synchronize access by multiple
    processes to the mapped file. However, real-world applications typically need
    to synchronize access to shared mappings. This can be done using a variety of
    techniques, including semaphores ([Chapter 47](ch47.html "Chapter 47. System V
    Semaphores") and [Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")) and file
    locking ([Chapter 55](ch55.html "Chapter 55. File Locking")).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单程序没有使用任何机制来同步多个进程对映射文件的访问。然而，现实世界的应用通常需要同步对共享映射的访问。这可以通过多种技术实现，包括信号量（[第47章](ch47.html
    "第47章. 系统V信号量")和[第53章](ch53.html "第53章. POSIX信号量")）以及文件锁定（[第55章](ch55.html "第55章.
    文件锁定")）。
- en: We explain the *msync()* system call used in [Example 49-2](ch49.html#using_mmap_open_parenthesis_close_pa
    "Example 49-2. Using mmap() to create a shared file mapping") in Section 49.5.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第49.5节中解释了在[示例49-2](ch49.html#using_mmap_open_parenthesis_close_pa "示例49-2.
    使用mmap()创建共享文件映射")中使用的*msync()*系统调用。
- en: Example 49-2. Using *mmap()* to create a shared file mapping
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例49-2. 使用*mmap()*创建共享文件映射
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Boundary Cases
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界情况
- en: In many cases, the size of a mapping is a multiple of the system page size,
    and the mapping falls entirely within the bounds of the mapped file. However,
    this is not necessarily so, and we now look at what happens when these conditions
    don’t hold.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，映射的大小是系统页面大小的倍数，且映射完全位于映射文件的范围内。然而，这并非总是如此，我们现在来看当这些条件不成立时会发生什么。
- en: '[Figure 49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul "Figure 49-3. Memory
    mapping whose length is not a multiple of the system page size") portrays the
    case where the mapping falls entirely within the bounds of the mapped file, but
    the size of the region is not a multiple of the system page size (which we assume
    is 4096 bytes for the purposes of this discussion).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul "图49-3. 内存映射长度不是系统页面大小的倍数")描述了映射完全位于映射文件的范围内，但该区域的大小不是系统页面大小的倍数的情况（在本讨论中我们假设系统页面大小为4096字节）。'
- en: '![Memory mapping whose length is not a multiple of the system page size](figs/web/49-3_MMAP-size-part-1.png.jpg)Figure 49-3. Memory
    mapping whose *length* is not a multiple of the system page size'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![内存映射长度不是系统页面大小的倍数](figs/web/49-3_MMAP-size-part-1.png.jpg)图49-3. 内存映射长度不是系统页面大小的倍数'
- en: Since the size of the mapping is not a multiple of the system page size, it
    is rounded up to the next multiple of the system page size. Because the file is
    larger than this rounded-up size, the corresponding bytes of the file are mapped
    as shown in [Figure 49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul "Figure 49-3. Memory
    mapping whose length is not a multiple of the system page size").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射的大小不是系统页面大小的倍数，它会被向上舍入到下一个系统页面大小的倍数。因为文件大于这个舍入后的大小，所以文件的相应字节会如[图49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul
    "图49-3. 内存映射长度不是系统页面大小的倍数")所示进行映射。
- en: Attempts to access bytes beyond the end of the mapping result in the generation
    of a `SIGSEGV` signal (assuming that there is no other mapping at that location).
    The default action for this signal is to terminate the process with a core dump.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问映射结束位置之后的字节会导致生成`SIGSEGV`信号（假设该位置没有其他映射）。此信号的默认动作是终止进程并生成核心转储。
- en: When the mapping extends beyond the end of the underlying file (see [Figure 49-4](ch49.html#memory_mapping_extending_beyond_end_of_m
    "Figure 49-4. Memory mapping extending beyond end of mapped file")), the situation
    is more complex. As before, because the size of the mapping is not a multiple
    of the system page size, it is rounded up. However, in this case, while the bytes
    in the rounded-up region (i.e., bytes 2200 to 4095 in the diagram) are accessible,
    they are not mapped to the underlying file (since no corresponding bytes exist
    in the file). Instead, they are initialized to 0 (SUSv3 requires this). These
    bytes will nevertheless be shared with other processes mapping the file, if they
    specify a sufficiently large *length* argument. Changes to these bytes are not
    written to the file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射超出底层文件的末尾时（见[图49-4](ch49.html#memory_mapping_extending_beyond_end_of_m "图49-4.
    内存映射超出映射文件末尾")），情况会更复杂。如前所述，由于映射的大小不是系统页面大小的倍数，它会被向上舍入。然而，在这种情况下，尽管舍入区域（即图中的字节2200到4095）是可访问的，但它们并没有映射到底层文件（因为文件中没有相应的字节）。相反，它们会被初始化为0（SUSv3要求这样做）。这些字节仍然会与映射该文件的其他进程共享，如果它们指定了足够大的*length*参数。这些字节的更改不会写入文件。
- en: If the mapping includes pages beyond the rounded-up region (i.e., bytes 4096
    and beyond in [Figure 49-4](ch49.html#memory_mapping_extending_beyond_end_of_m
    "Figure 49-4. Memory mapping extending beyond end of mapped file")), then attempts
    to access addresses in these pages result in the generation of a `SIGBUS` signal,
    which warns the process that there is no region of the file corresponding to these
    addresses. As before, attempts to access addresses beyond the end of the mapping
    result in the generation of a `SIGSEGV` signal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映射包含超出舍入区域的页（即，图[49-4](ch49.html#memory_mapping_extending_beyond_end_of_m
    "图49-4。超出映射文件末尾的内存映射")中的字节4096及以后），则尝试访问这些页面中的地址会生成 `SIGBUS` 信号，警告进程该文件中没有对应这些地址的区域。如前所述，尝试访问映射末尾之外的地址会生成
    `SIGSEGV` 信号。
- en: From the above description, it may appear pointless to create a mapping whose
    size exceeds that of the underlying file. However, by extending the size of the
    file (e.g., using *ftruncate()* or *write()*), we can render previously inaccessible
    parts of such a mapping usable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述描述来看，创建一个映射，其大小超出底层文件的大小似乎毫无意义。然而，通过扩展文件的大小（例如，使用 *ftruncate()* 或 *write()*），我们可以使该映射中之前无法访问的部分变得可用。
- en: '![Memory mapping extending beyond end of mapped file](figs/web/49-4_MMAP-size-part-2.png.jpg)Figure 49-4. Memory
    mapping extending beyond end of mapped file'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![超出映射文件末尾的内存映射](figs/web/49-4_MMAP-size-part-2.png.jpg)图49-4。超出映射文件末尾的内存映射'
- en: Memory Protection and File Access Mode Interactions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存保护与文件访问模式的相互作用
- en: One point that we have not so far explained in detail is the interaction between
    the memory protection specified in the *mmap() prot* argument and the mode in
    which the mapped file is opened. As a general principle, we can say that the `PROT_READ`
    and `PROT_EXEC` protections require that the mapped file is opened `O_RDONLY`
    or `O_RDWR`, and that the `PROT_WRITE` protection requires that the mapped file
    is opened `O_WRONLY` or `O_RDWR`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今尚未详细解释的一个要点是，*mmap() prot* 参数中指定的内存保护与映射文件打开模式之间的相互作用。作为一般原则，我们可以说，`PROT_READ`
    和 `PROT_EXEC` 保护要求映射文件以 `O_RDONLY` 或 `O_RDWR` 模式打开，而 `PROT_WRITE` 保护要求映射文件以 `O_WRONLY`
    或 `O_RDWR` 模式打开。
- en: 'However, the situation is complicated by the limited granularity of memory
    protections provided by some hardware architectures ([Creating a Mapping: *mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "Creating a Mapping: mmap()")). For such architectures, we make the following
    observations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况因某些硬件架构提供的内存保护的粒度有限而变得复杂（[创建映射：*mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "创建映射：mmap()")）。对于这些架构，我们提出以下观察：
- en: All combinations of memory protection are compatible with opening the file with
    the `O_RDWR` flag.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有内存保护的组合都可以与 `O_RDWR` 标志一起打开文件。
- en: 'No combination of memory protections—not even just `PROT_WRITE`—is compatible
    with a file opened `O_WRONLY` (the error `EACCES` results). This is consistent
    with the fact that some hardware architectures don’t allow us write-only access
    to a page. As noted in [Creating a Mapping: *mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "Creating a Mapping: mmap()"), `PROT_WRITE` implies `PROT_READ` on those architectures,
    which means that if the page can be written, then it can also be read. A read
    operation is incompatible with `O_WRONLY`, which must not reveal the original
    contents of the file.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何内存保护的组合——即使是仅仅 `PROT_WRITE`——可以与以 `O_WRONLY` 模式打开的文件兼容（会导致错误 `EACCES`）。这与某些硬件架构不允许我们对页面进行只写访问这一事实一致。如[创建映射：*mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "创建映射：mmap()")中所述，`PROT_WRITE` 在这些架构上意味着 `PROT_READ`，即如果页面可以被写入，那么它也可以被读取。读取操作与
    `O_WRONLY` 不兼容，因为 `O_WRONLY` 必须不会显示文件的原始内容。
- en: The results when a file is opened with the `O_RDONLY` flag depend on whether
    we specify `MAP_PRIVATE` or `MAP_SHARED` when calling *mmap()*. For a `MAP_PRIVATE`
    mapping, we can specify any combination of memory protection in *mmap()*—because
    modifications to the contents of a `MAP_PRIVATE` page are never written to the
    file, the inability to write to the file is not a problem. For a `MAP_SHARED`
    mapping, the only memory protections that are compatible with `O_RDONLY` are `PROT_READ`
    and `(PROT_READ | PROT_EXEC)`. This is logical, since a `PROT_WRITE`, `MAP_SHARED`
    mapping allows updates to the mapped file.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`O_RDONLY`标志打开文件时的结果取决于在调用*mmap()*时是否指定了`MAP_PRIVATE`或`MAP_SHARED`。对于`MAP_PRIVATE`映射，可以在*mmap()*中指定任何组合的内存保护——因为对`MAP_PRIVATE`页面内容的修改永远不会写入文件，所以无法写入文件不是问题。对于`MAP_SHARED`映射，唯一与`O_RDONLY`兼容的内存保护是`PROT_READ`和`(PROT_READ
    | PROT_EXEC)`。这是合乎逻辑的，因为`PROT_WRITE`和`MAP_SHARED`映射允许更新映射的文件。
- en: 'Synchronizing a Mapped Region: *msync()*'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步映射区域：*msync()*
- en: The kernel automatically carries modifications of the contents of a `MAP_SHARED`
    mapping through to the underlying file, but, by default, provides no guarantees
    about when such synchronization will occur. (SUSv3 doesn’t require an implementation
    to provide such guarantees.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内核会自动将`MAP_SHARED`映射的内容修改传递到底层文件中，但默认情况下，内核不保证同步操作何时发生。（SUSv3并没有要求实现提供此类保证。）
- en: The *msync()* system call gives an application explicit control over when a
    shared mapping is synchronized with the mapped file. Synchronizing a mapping with
    the underlying file is useful in various scenarios. For example, to ensure data
    integrity, a database application may call *msync()* to force data to be written
    to the disk. Calling *msync()* also allows an application to ensure that updates
    to a writable mapping are visible to some other process that performs a *read()*
    on the file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*msync()*系统调用使应用程序可以显式控制何时将共享映射与映射文件同步。将映射与底层文件同步在多种场景中都非常有用。例如，为了确保数据完整性，数据库应用程序可能会调用*msync()*强制将数据写入磁盘。调用*msync()*还允许应用程序确保对可写映射的更新对其他执行*read()*操作的进程可见。'
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns 0 on success, or -1 on error
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The *addr* and *length* arguments to *msync()* specify the starting address
    and size of the memory region to be synchronized. The address specified in *addr*
    must be page-aligned, and *len* is rounded up to the next multiple of the system
    page size. (SUSv3 specified that *addr must* be page-aligned. SUSv4 says that
    an implementation *may* require this argument to be page-aligned.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*msync()*的*addr*和*length*参数指定要同步的内存区域的起始地址和大小。*addr*指定的地址必须按页对齐，*len*会向上舍入到系统页面大小的下一个倍数。（SUSv3规定*addr必须*按页对齐。SUSv4则表示实现*可以*要求此参数按页对齐。）'
- en: 'Possible values for the *flags* argument include one of the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags*参数的可能值包括以下之一：'
- en: '`MS_SYNC`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_SYNC`'
- en: Perform a synchronous file write. The call blocks until all modified pages of
    the memory region have been written to the disk.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行同步文件写入。调用会阻塞，直到内存区域的所有修改页面都写入磁盘。
- en: '`MS_ASYNC`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_ASYNC`'
- en: Perform an asynchronous file write. The modified pages of the memory region
    are written to the disk at some later point and are immediately made visible to
    other processes performing a *read()* on the corresponding file region.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 执行异步文件写入。内存区域的修改页面将在稍后的某个时间点写入磁盘，并且会立即对其他执行*read()*操作的进程可见。
- en: Another way of distinguishing these two values is to say that after an `MS_SYNC`
    operation, the memory region is synchronized with the disk, while after an `MS_ASYNC`
    operation, the memory region is merely synchronized with the kernel buffer cache.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这两个值的另一种方式是：在执行`MS_SYNC`操作后，内存区域与磁盘同步，而在执行`MS_ASYNC`操作后，内存区域仅与内核缓冲区缓存同步。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: If we take no further action after an `MS_ASYNC` operation, then the modified
    pages in the memory region will eventually be flushed as part of the automatic
    buffer flushing performed by the *pdflush* kernel thread (*kupdated* in Linux
    2.4 and earlier). On Linux, there are two (nonstandard) methods of initiating
    the output sooner. We can follow the call to *msync()* with a call to *fsync()*
    (or *fdatasync()*) on the file descriptor corresponding to the mapping. This call
    will block until the buffer cache is synchronized with the disk. Alternatively,
    we can initiate asynchronous write out of the pages using the *posix_fadvise()*
    `POSIX_FADV_DONTNEED` operation. (The Linux-specific details in these two cases
    are not specified by SUSv3.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'One other value can additionally be specified for *flags*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '`MS_INVALIDATE`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Invalidate cached copies of mapped data. After any modified pages in the memory
    region have been synchronized with the file, all pages of the memory region that
    are inconsistent with the underlying file data are marked as invalid. When next
    referenced, the contents of the pages will be copied from the corresponding locations
    in the file. As a consequence, any updates that have been made to the file by
    another process are made visible in the memory region.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Like many other modern UNIX implementations, Linux provides a so-called *unified
    virtual memory* system. This means that, where possible, memory mappings and blocks
    of the buffer cache share the same pages of physical memory. Thus, the views of
    a file obtained via a mapping and via I/O system calls (*read()*, *write()*, and
    so on) are always consistent, and the only use of *msync()* is to force the contents
    of a mapped region to be flushed to disk.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: However, a unified virtual memory system is not required by SUSv3 and is not
    employed on all UNIX implementations. On such systems, a call to *msync()* is
    required to make changes to the contents of a mapping visible to other processes
    that *read()* the file, and the `MS_INVALIDATE` flag is required to perform the
    converse action of making writes to the file by another process visible in the
    mapped region. Multiprocess applications that employ both *mmap()* and I/O system
    calls to operate on the same file should be designed to make appropriate use of
    *msync()* if they are to be portable to systems that don’t have a unified virtual
    memory system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Additional *mmap()* Flags
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `MAP_PRIVATE` and `MAP_SHARED`, Linux allows a number of other
    values to be included (ORed) in the *mmap() flags* argument. [Table 49-3](ch49.html#bit-mask_values_for_the_mmap_open_parent
    "Table 49-3. Bit-mask values for the mmap() flags argument") summarizes these
    values. Other than `MAP_PRIVATE` and `MAP_SHARED`, only the `MAP_FIXED` flag is
    specified in SUSv3.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-3. Bit-mask values for the *mmap() flags* argument
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description | SUSv3 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `MAP_ANONYMOUS` | Create an anonymous mapping |   |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `MAP_FIXED` | Interpret *addr* argument exactly ([The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag")) | • |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `MAP_LOCKED` | Lock mapped pages into memory (since Linux 2.6) |   |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `MAP_HUGETLB` | Create a mapping that uses huge pages (since Linux 2.6.32)
    |   |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `MAP_NORESERVE` | Control reservation of swap space ([`MAP_NORESERVE` and
    Swap Space Overcommitting](ch49.html#map_underscore_noreserve_and_swap_space "MAP_NORESERVE
    and Swap Space Overcommitting")) |   |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `MAP_PRIVATE` | Modifications to mapped data are private | • |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `MAP_POPULATE` | Populate the pages of a mapping (since Linux 2.6) | • |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `MAP_SHARED` | Modifications to mapped data are visible to other processes
    and propagated to underlying file (converse of `MAP_PRIVATE`) | • |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `MAP_UNINITIALIZED` | Don’t clear an anonymous mapping (since Linux 2.6.33)
    |   |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: 'The following list provides further details on the *flags* values listed in
    [Table 49-3](ch49.html#bit-mask_values_for_the_mmap_open_parent "Table 49-3. Bit-mask
    values for the mmap() flags argument") (other than `MAP_PRIVATE` and `MAP_SHARED`,
    which have already been discussed):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_ANONYMOUS`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Create an anonymous mapping—that is, a mapping that is not backed by a file.
    We describe this flag further in Section 49.7.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_FIXED`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We describe this flag in [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_HUGETLB` (since Linux 2.6.32)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This flag serves the same purpose for *mmap()* as the `SHM_HUGETLB` flag serves
    for System V shared memory segments. See Section 48.2.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_LOCKED` (since Linux 2.6)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Preload and lock the mapped pages into memory in the manner of *mlock()*. We
    describe the privileges required to use this flag and the limits governing its
    operation in Section 50.2.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_NORESERVE`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This flag is used to control whether reservation of swap space for the mapping
    is performed in advance. See [`MAP_NORESERVE` and Swap Space Overcommitting](ch49.html#map_underscore_noreserve_and_swap_space
    "MAP_NORESERVE and Swap Space Overcommitting") for details.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_POPULATE` (since Linux 2.6)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Populate the pages of a mapping. For a file mapping, this will perform read-ahead
    on the file. This means that later accesses of the contents of the mapping won’t
    be blocked by page faults (assuming that memory pressure has not in the meantime
    caused the pages to be swapped out).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_UNINITIALIZED` (since Linux 2.6.33)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Specifying this flag prevents the pages of an anonymous mapping from being zeroed.
    It provides a performance benefit, but carries a security risk, because the allocated
    pages may contain sensitive information left by a previous process. This flag
    is thus only intended for use on embedded systems, where performance may be critical,
    and the entire system is under the control of the embedded application(s). This
    flag is only honored if the kernel was configured with the `CONFIG_MMAP_ALLOW_UNINITIALIZED`
    option.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Mappings
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *anonymous mapping* is one that doesn’t have a corresponding file. In this
    section, we show how to create anonymous mappings, and look at the purposes served
    by private and shared anonymous mappings.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_ANONYMOUS` and `/dev/zero`'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, there are two different, equivalent methods of creating an anonymous
    mapping with *mmap()*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Specify `MAP_ANONYMOUS` in *flags* and specify *fd* as -1\. (On Linux, the value
    of *fd* is ignored when `MAP_ANONYMOUS` is specified. However, some UNIX implementations
    require fd to be -1 when employing `MAP_ANONYMOUS`, and portable applications
    should ensure that they do this.)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We must define either the `_BSD_SOURCE` or the `_SVID_SOURCE` feature test macros
    to get the definition of `MAP_ANONYMOUS` from `<sys/mman.h>`. Linux provides the
    constant `MAP_ANON` as a synonym for `MAP_ANONYMOUS` for compatibility with some
    other UNIX implementations using this alternative name.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `/dev/zero` device file and pass the resulting file descriptor to *mmap()*.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`/dev/zero` is a virtual device that always returns zeros when we read from
    it. Writes to this device are always discarded. A common use of `/dev/zero` is
    to populate a file with zeros (e.g., using the *dd(1)* command).'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With both the `MAP_ANONYMOUS` and the `/dev/zero` techniques, the bytes of the
    resulting mapping are initialized to 0\. For both techniques, the *offset* argument
    is ignored (since there is no underlying file in which to specify an offset).
    We show examples of each technique shortly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MAP_ANONYMOUS` and `/dev/zero` techniques are not specified in SUSv3, although
    most UNIX implementations support one or both of them. The reason for the existence
    of two different techniques with the same semantics is that one (`MAP_ANONYMOUS`)
    derives from BSD, while the other (`/dev/zero`) derives from System V.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE` anonymous mappings'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE` anonymous mappings are used to allocate blocks of process-private
    memory initialized to 0\. We can use the `/dev/zero` technique to create a `MAP_PRIVATE`
    anonymous mapping as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *glibc* implementation of *malloc()* uses `MAP_PRIVATE` anonymous mappings
    to allocate blocks of memory larger than `MMAP_THRESHOLD` bytes. This makes it
    possible to efficiently deallocate such blocks (via *munmap()*) if they are later
    given to *free()*. (It also reduces the possibility of memory fragmentation when
    repeatedly allocating and deallocating large blocks of memory.) `MMAP_THRESHOLD`
    is 128 kB by default, but this parameter is adjustable via the *mallopt()* library
    function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_SHARED` anonymous mappings'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `MAP_SHARED` anonymous mapping allows related processes (e.g., parent and
    child) to share a region of memory without needing a corresponding mapped file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MAP_SHARED` anonymous mappings are available only with Linux 2.4 and later.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `MAP_ANONYMOUS` technique to create a `MAP_SHARED` anonymous
    mapping as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the above code is followed by a call to *fork()*, then, because the child
    produced by *fork()* inherits the mapping, both processes share the memory region.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program in [Example 49-3](ch49.html#sharing_an_anonymous_mapping_between_par
    "Example 49-3. Sharing an anonymous mapping between parent and child processes")
    demonstrates the use of either `MAP_ANONYMOUS` or `/dev/zero` to share a mapped
    region between parent and child processes. The choice of technique is determined
    by whether `USE_MAP_ANON` is defined when compiling the program. The parent initializes
    an integer in the shared region to 1 prior to calling *fork()*. The child then
    increments the shared integer and exits, while the parent waits for the child
    to exit and then prints the value of the integer. When we run this program, we
    see the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 49-3. Sharing an anonymous mapping between parent and child processes
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remapping a Mapped Region: *mremap()*'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On most UNIX implementations, once a mapping has been created, its location
    and size can’t be changed. However, Linux provides the (nonportable) *mremap()*
    system call, which permits such changes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns starting address of remapped region on success, or `MAP_FAILED` on error
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The *old_address* and *old_size* arguments specify the location and size of
    an existing mapping that we wish to expand or shrink. The address specified in
    *old_address* must be page-aligned, and is normally a value returned by a previous
    call to *mmap()*. The desired new size of the mapping is specified in *new_size*.
    The values specified in *old_size* and *new_size* are both rounded up to the next
    multiple of the system page size.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'While carrying out the remapping, the kernel may relocate the mapping within
    the process’s virtual address space. Whether or not this is permitted is controlled
    by the *flags* argument, which is a bit mask that may either be 0 or include the
    following values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '`MREMAP_MAYMOVE`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: If this flag is specified, then, as space requirements dictate, the kernel may
    relocate the mapping within the process’s virtual address space. If this flag
    is not specified, and there is insufficient space to expand the mapping at the
    current location, then the error `ENOMEM` results.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`MREMAP_FIXED` (since Linux 2.4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be used only in conjunction with `MREMAP_MAYMOVE`. It serves a
    purpose for *mremap()* that is analogous to that served by `MAP_FIXED` for *mmap()*
    ([The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag "The MAP_FIXED
    Flag")). If this flag is specified, then *mremap()* takes an additional argument,
    *void *new_address*, that specifies a page-aligned address to which the mapping
    should be moved. Any previous mapping in the address range specified by *new_address*
    and *new_size* is unmapped.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: On success, *mremap()* returns the starting address of the mapping. Since (if
    the `MREMAP_MAYMOVE` flag is specified) this address may be different from the
    previous starting address, pointers into the region may cease to be valid. Therefore,
    applications that use *mremap()* should use only offsets (not absolute pointers)
    when referring to addresses in the mapped region (see [Storing Pointers in Shared
    Memory](ch48.html#storing_pointers_in_shared_memory "Storing Pointers in Shared
    Memory")).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, the *realloc()* function uses *mremap()* to efficiently reallocate
    large blocks of memory that *malloc()* previously allocated using *mmap()* `MAP_ANONYMOUS`.
    (We mentioned this feature of the *glibc malloc()* implementation in Section 49.7.)
    Using *mremap()* for this task makes it possible to avoid copying of bytes during
    the reallocation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_NORESERVE` and Swap Space Overcommitting'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications create large (usually private anonymous) mappings, but use
    only a small part of the mapped region. For example, certain types of scientific
    applications allocate a very large array, but operate on only a few widely separated
    elements of the array (a so-called *sparse array*).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If the kernel always allocated (or reserved) enough swap space for the whole
    of such mappings, then a lot of swap space would potentially be wasted. Instead,
    the kernel can reserve swap space for the pages of a mapping only as they are
    actually required (i.e., when the application accesses a page). This approach
    is called *lazy swap reservation*, and has the advantage that the total virtual
    memory used by applications can exceed the total size of RAM plus swap space.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To put things another way, lazy swap reservation allows swap space to be overcommitted.
    This works fine, as long as all processes don’t attempt to access the entire range
    of their mappings. However, if all applications do attempt to access the full
    range of their mappings, RAM and swap space will be exhausted. In this situation,
    the kernel reduces memory pressure by killing one or more of the processes on
    the system. Ideally, the kernel attempts to select the process causing the memory
    problems (see the discussion of the *OOM killer* below), but this isn’t guaranteed.
    For this reason, we may choose to prevent lazy swap reservation, instead forcing
    the system to allocate all of the necessary swap space when the mapping is created.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: How the kernel handles reservation of swap space is controlled by the use of
    the `MAP_NORESERVE` flag when calling *mmap()*, and via `/proc` interfaces that
    affect the system-wide operation of swap space overcommitting. These factors are
    summarized in [Table 49-4](ch49.html#handling_of_swap_space_reservation_durin
    "Table 49-4. Handling of swap space reservation during mmap()").
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-4. Handling of swap space reservation during *mmap()*
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| `overcommit_memory` value | `MAP_NORESERVE` specified in *mmap()* call? |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| No | Yes |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| 0 | Deny obvious overcommits | Allow overcommits |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| 1 | Allow overcommits | Allow overcommits |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| 2 (since Linux 2.6) | Strict overcommitting |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: 'The Linux-specific `/proc/sys/vm/overcommit_memory` file contains an integer
    value that controls the kernel’s handling of swap space overcommits. Linux versions
    before 2.6 differentiated only two values in this file: 0, meaning deny obvious
    overcommits (subject to the use of the `MAP_NORESERVE` flag), and greater than
    0, meaning that overcommits should be permitted in all cases.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Denying obvious overcommits means that new mappings whose size doesn’t exceed
    the amount of currently available free memory are permitted. Existing allocations
    may be overcommitted (since they may not be using all of the pages that they mapped).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Linux 2.6, a value of 1 has the same meaning as a positive value in earlier
    kernels, but the value 2 (or greater) causes *strict overcommitting* to be employed.
    In this case, the kernel performs strict accounting on all *mmap()* allocations
    and limits the system-wide total of all such allocations to be less than or equal
    to:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `overcommit_ratio` value is an integer—expressing a percentage—contained
    in the Linux-specific `/proc/sys/vm/overcommit_ratio` file. The default value
    contained in this file is 50, meaning that the kernel can overallocate up to 50%
    of the size of the system’s RAM, and this will be successful, as long as not all
    processes try to use their full allocation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that overcommit monitoring comes into play only for the following types
    of mappings:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: private writable mappings (both file and anonymous mappings), for which the
    swap “cost” of the mapping is equal to the size of the mapping for each process
    that employs the mapping; and
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shared anonymous mappings, for which the swap “cost” of the mapping is the size
    of the mapping (since all processes share that mapping).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reserving swap space for a read-only private mapping is unnecessary: since
    the contents of the mapping can’t be modified, there is no need to employ swap
    space. Swap space is also not required for shared file mappings, because the mapped
    file itself acts as the swap space for the mapping.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: When a child process inherits a mapping across a *fork()*, it inherits the `MAP_NORESERVE`
    setting for the mapping. The `MAP_NORESERVE` flag is not specified in SUSv3, but
    it is supported on a few other UNIX implementations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we have discussed how a call to *mmap()* may fail to increase
    the address space of a process because of the system limitations on RAM and swap
    space. A call to *mmap()* can also fail because it encounters the per-process
    `RLIMIT_AS` resource limit (described in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")), which places an upper limit on the size
    of the address space of the calling process.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The OOM killer
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Above, we noted that when we employ lazy swap reservation, memory may become
    exhausted if applications attempt to employ the entire range of their mappings.
    In this case, the kernel relieves memory exhaustion by killing processes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel code dedicated to selecting a process to kill when memory is exhausted
    is commonly known as the out-of-memory (OOM) killer. The OOM killer tries to choose
    the best process to kill in order to relieve the memory exhaustion, where “best”
    is determined by a range of factors. For example, the more memory a process is
    consuming, the more likely it will be a candidate for the OOM killer. Other factors
    that increase a process’s likelihood of selection are forking to create many child
    processes and having a low nice value (i.e., one that is greater than 0). The
    kernel disfavors killing the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: processes that are privileged, since they are probably performing important
    tasks;
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: processes that are performing raw device access, since killing them may leave
    the device in an unusable state; and
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: processes that have been running for a long time or have consumed a lot of CPU,
    since killing them would result in a lot of lost “work.”
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To kill the selected process, the OOM killer delivers a `SIGKILL` signal.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The Linux-specific `/proc/`*PID*`/oom_score` file, available since kernel 2.6.11,
    shows the weighting that the kernel gives to a process if it is necessary to invoke
    the OOM killer. The greater the value in this file, the more likely the process
    is to be selected, if necessary, by the OOM killer. The Linux-specific `/proc/`*PID*`/oom_adj`
    file, also available since kernel 2.6.11, can be used to influence the `oom_score`
    of a process. This file can be set to any value in the range -16 to +15, where
    negative values decrease the `oom_score` and positive values increase it. The
    special value -17 removes the process altogether as a candidate for selection
    by the OOM killer. For further details, see the *proc(5)* manual page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The `MAP_FIXED` Flag
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Specifying `MAP_FIXED` in the *mmap() flags* argument forces the kernel to interpret
    the address in *addr* exactly, rather than take it as a hint. If we specify `MAP_FIXED`,
    *addr* must be page-aligned.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a portable application should omit the use of `MAP_FIXED`, and specify
    *addr* as `NULL`, which allows the system to choose the address at which to place
    the mapping. The reasons for this are the same as those that we outlined in [Using
    Shared Memory](ch48.html#using_shared_memory "Using Shared Memory") when explaining
    why it usually preferable to specify *shmaddr* as `NULL` when attaching a System
    V shared memory segment using *shmat()*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one situation where a portable application might use `MAP_FIXED`.
    If `MAP_FIXED` is specified when calling *mmap()*, and the memory region beginning
    at *addr* and running for *length* bytes overlaps the pages of any previous mapping,
    then the overlapped pages are replaced by the new mapping. We can use this feature
    to portably map multiple parts of a file (or files) into a contiguous region of
    memory, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Use *mmap()* to create an anonymous mapping ([Anonymous Mappings](ch49.html#anonymous_mappings
    "Anonymous Mappings")). In the *mmap()* call, we specify *addr* as `NULL` and
    don’t specify the `MAP_FIXED` flag. This allows the kernel to choose an address
    for the mapping.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a series of *mmap()* calls specifying `MAP_FIXED` to map (i.e., overlay)
    file regions into different parts of the mapping created in the preceding step.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we could skip the first step, and use a series of *mmap()* `MAP_FIXED`
    operations to create a set of contiguous mappings at an address range selected
    by the application, this approach is less portable than performing both steps.
    As noted above, a portable application should avoid trying to create a new mapping
    at a fixed address. The first step avoids the portability problem, because we
    let the kernel select a contiguous address range, and then create new mappings
    within that address range.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: From Linux 2.6 onward, the *remap_file_pages()* system call, which we describe
    in the next section, can also be used to achieve the same effect. However, the
    use of `MAP_FIXED` is more portable than *remap_file_pages()*, which is Linux-specific.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonlinear Mappings: *remap_file_pages()*'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File mappings created with *mmap()* are linear: there is a sequential, one-to-one
    correspondence between the pages of the mapped file and the pages of the memory
    region. For most applications, a linear mapping suffices. However, some applications
    need to create large numbers of nonlinear mappings—mappings where the pages of
    the file appear in a different order within contiguous memory. We show an example
    of a nonlinear mapping in [Figure 49-5](ch49.html#a_nonlinear_file_mapping "Figure 49-5. A
    nonlinear file mapping").'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'We described one way of creating nonlinear mappings in the previous section:
    using multiple calls to *mmap()* with the `MAP_FIXED` flag. However, this approach
    doesn’t scale well. The problem is that each of these *mmap()* calls creates a
    separate kernel virtual memory area (VMA) data structure. Each VMA takes time
    to set up and consumes some nonswappable kernel memory. Furthermore, the presence
    of a large number of VMAs can degrade the performance of the virtual memory manager;
    in particular, the time taken to process each page fault can significantly increase
    when there are tens of thousands of VMAs. (This was a problem for some large database
    management systems that maintain multiple different views in a database file.)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each line in the `/proc/`*PID*`/maps` file ([Location of Shared Memory in Virtual
    Memory](ch48.html#location_of_shared_memory_in_virtual_mem "Location of Shared
    Memory in Virtual Memory")) represents one VMA.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'From kernel 2.6 onward, Linux provides the *remap_file_pages()* system call
    to create nonlinear mappings without creating multiple VMAs. We do this as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Create a mapping with *mmap()*.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one or more calls to *remap_file_pages()* to rearrange the correspondence
    between the pages of memory and the pages of the file. (All that *remap_file_pages()*
    is doing is manipulating process page tables.)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to use *remap_file_pages()* to map the same page of a file into
    multiple locations within the mapped region.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pgoff* and *size* arguments identify a file region whose position in memory
    is to be changed. The *pgoff* argument specifies the start of the file region
    in units of the system page size (as returned by *sysconf(_SC_PAGESIZE)*). The
    *size* argument specifies the length of the file region, in bytes. The *addr*
    argument serves two purposes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: It identifies the existing mapping whose pages we want to rearrange. In other
    words, *addr* must be an address that falls somewhere within a region that was
    previously mapped with *mmap()*.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It specifies the memory address at which the file pages identified by *pgoff*
    and *size* are to be located.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both *addr* and *size* should be specified as multiples of the system page size.
    If they are not, they are rounded down to the nearest multiple of the page size.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we use the following call to *mmap()* to map three pages of the
    open file referred to by the descriptor *fd*, and that the call assigns the returned
    address `0x4001a000` to *addr*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following calls would then create the nonlinear mapping shown in [Figure 49-5](ch49.html#a_nonlinear_file_mapping
    "Figure 49-5. A nonlinear file mapping"):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![A nonlinear file mapping](figs/web/49-5_MMAP-nonlinear.png.jpg)Figure 49-5. A
    nonlinear file mapping'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other arguments to *remap_file_pages()* that we haven’t yet described:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The *prot* argument is ignored, and must be specified as 0\. In the future,
    it may be possible to use this argument to change the protection of the memory
    region affected by *remap_file_pages()*. In the current implementation, the protection
    remains the same as that on the entire VMA.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtual machines and garbage collectors are other applications that employ multiple
    VMAs. Some of these applications need to be able to write-protect individual pages.
    It was intended that *remap_file_pages()* would allow permissions on individual
    pages within a VMA to be changed, but this facility has not so far been implemented.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *flags* argument is currently unused.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As currently implemented, *remap_file_pages()* can be applied only to shared
    (`MAP_SHARED`) mappings.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The *remap_file_pages()* system call is Linux-specific; it is not specified
    in SUSv3 and is not available on other UNIX implementations.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *mmap()* system call creates a new memory mapping in the calling process’s
    virtual address space. The *munmap()* system call performs the converse operation,
    removing a mapping from a process’s address space.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'A mapping may be of two types: file-based or anonymous. A file mapping maps
    the contents of a file region into the process’s virtual address space. An anonymous
    mapping (created by using the `MAP_ANONYMOUS` flag or by mapping `/dev/zero`)
    doesn’t have a corresponding file region; the bytes of the mapping are initialized
    to 0.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Mappings can be either private (`MAP_PRIVATE`) or shared (`MAP_SHARED`). This
    distinction determines the visibility of changes made to the shared memory, and,
    in the case of file mappings, determines whether the kernel propagates changes
    to the contents of the mapping to the underlying file. When a process maps a file
    with the `MAP_PRIVATE` flag, any changes it makes to the contents of the mapping
    are not visible to other processes and are not carried through to the mapped file.
    A `MAP_SHARED` file mapping is the converse—changes to the mapping are visible
    to other processes and are carried through to the mapped file.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Although the kernel automatically propagates changes to the contents of a `MAP_SHARED`
    mapping to the underlying file, it doesn’t provide any guarantees about when this
    is done. An application can use the *msync()* system call to explicitly control
    when the contents of a mapping are synchronized with the mapped file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory mappings serve a variety of uses, including:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: allocating process-private memory (private anonymous mappings);
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: initializing the contents of the text and initialized data segments of a process
    (private file mappings);
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sharing memory between processes related via *fork()* (shared anonymous mappings);
    and
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: performing memory-mapped I/O, optionally combined with memory sharing between
    unrelated processes (shared file mappings).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two signals may come into play when accessing the contents of a mapping. `SIGSEGV`
    is generated if we attempt access in a manner that violates the protections on
    the mapping (or if we access any currently unmapped address). `SIGBUS` is generated
    for file-based mappings if we access a part of the mapping for which no corresponding
    region exists in the file (i.e., the mapping is larger than the underlying file).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Swap space overcommitting allows the system to allocate more memory to processes
    than is actually available in RAM and swap space. Overcommitting is possible because,
    typically, each process does not make full use of its allocation. Overcommitting
    can be controlled on a per-*mmap()* basis using the `MAP_NORESERVE` flag, and
    on a system-wide basis using `/proc` files.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The *mremap()* system call allows an existing mapping to be resized. The *remap_file_pages()*
    system call allows the creation of nonlinear file mappings.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Information about the implementation of *mmap()* on Linux can be found in [Bovet
    & Cesati, 2005]. Information about the implementation of *mmap()* on other UNIX
    systems can be found in [McKusick et al., 1996] (BSD), [Goodheart & Cox, 1994]
    (System V Release 4), and [Vahalia, 1996] (System V Release 4).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program, analogous to *cp(1)*, that uses *mmap()* and *memcpy()* calls
    (instead of *read()* or *write()*) to copy a source file to a destination file.
    (Use *fstat()* to obtain the size of the input file, which can then be used to
    size the required memory mappings, and use *ftruncate()* to set the size of the
    output file.)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`, page 1003) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`, page 1005) to use a shared memory mapping instead
    of System V shared memory.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write programs to verify that the `SIGBUS` and `SIGSEGV` signals are delivered
    in the circumstances described in [Boundary Cases](ch49.html#boundary_cases "Boundary
    Cases").
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that uses the `MAP_FIXED` technique described in [The `MAP_FIXED`
    Flag](ch49.html#the_map_underscore_fixed_flag "The MAP_FIXED Flag") to create
    a nonlinear mapping similar to that shown in [Figure 49-5](ch49.html#a_nonlinear_file_mapping
    "Figure 49-5. A nonlinear file mapping").
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
