- en: Chapter 49. Memory Mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses the use of the *mmap()* system call to create memory
    mappings. Memory mappings can be used for IPC, as well as a range of other purposes.
    We begin with an overview of some fundamental concepts before considering *mmap()*
    in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *mmap()* system call creates a new *memory mapping* in the calling process’s
    virtual address space. A mapping can be of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*File mapping*: A file mapping maps a region of a file directly into the calling
    process’s virtual memory. Once a file is mapped, its contents can be accessed
    by operations on the bytes in the corresponding memory region. The pages of the
    mapping are (automatically) loaded from the file as required. This type of mapping
    is also known as a *file-based mapping* or *memory-mapped file*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Anonymous mapping*: An anonymous mapping doesn’t have a corresponding file.
    Instead, the pages of the mapping are initialized to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way of thinking of an anonymous mapping (and one that is close to the
    truth) is that it is a mapping of a virtual file whose contents are always initialized
    with zeros.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The memory in one process’s mapping may be shared with mappings in other processes
    (i.e., the page-table entries of each process point to the same pages of RAM).
    This can occur in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: When two processes map the same region of a file, they share the same pages
    of physical memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child process created by *fork()* inherits copies of its parent’s mappings,
    and these mappings refer to the same pages of physical memory as the corresponding
    mappings in the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When two or more processes share the same pages, each process can potentially
    see the changes to the page contents made by other processes, depending on whether
    the mapping is *private* or *shared*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Private mapping* (`MAP_PRIVATE`): Modifications to the contents of the mapping
    are not visible to other processes and, for a file mapping, are not carried through
    to the underlying file. Although the pages of a private mapping are initially
    shared in the circumstances described above, changes to the contents of the mapping
    are nevertheless private to each process. The kernel accomplishes this using the
    copy-on-write technique ([Memory Semantics of *fork()*](ch24.html#memory_semantics_of_fork_open_parenthesi
    "Memory Semantics of fork()")). This means that whenever a process attempts to
    modify the contents of a page, the kernel first creates a new, separate copy of
    that page for the process (and adjusts the process’s page tables). For this reason,
    a `MAP_PRIVATE` mapping is sometimes referred to as a *private, copy-on-write
    mapping*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shared mapping* (`MAP_SHARED`): Modifications to the contents of the mapping
    are visible to other processes that share the same mapping and, for a file mapping,
    are carried through to the underlying file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two mapping attributes described above (file versus anonymous and private
    versus shared) can be combined in four different ways, as summarized in [Table 49-1](ch49.html#purposes_of_various_types_of_memory_mapp
    "Table 49-1. Purposes of various types of memory mappings").
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-1. Purposes of various types of memory mappings
  prefs: []
  type: TYPE_NORMAL
- en: '| Visibility of modifications | Mapping type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| File | Anonymous |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Private** | Initializing memory from contents of file | Memory allocation
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Shared** | Memory-mapped I/O; sharing memory between processes (IPC) |
    Sharing memory between processes (IPC) |'
  prefs: []
  type: TYPE_TB
- en: 'The four different types of memory mappings are created and used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Private file mapping*: The contents of the mapping are initialized from a
    file region. Multiple processes mapping the same file initially share the same
    physical pages of memory, but the copy-on-write technique is employed, so that
    changes to the mapping by one process are invisible to other processes. The main
    use of this type of mapping is to initialize a region of memory from the contents
    of a file. Some common examples are initializing a process’s text and initialized
    data segments from the corresponding parts of a binary executable file or a shared
    library file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private anonymous mapping*: Each call to *mmap()* to create a private anonymous
    mapping yields a new mapping that is distinct from (i.e., does not share physical
    pages with) other anonymous mappings created by the same (or a different) process.
    Although a child process inherits its parent’s mappings, copy-on-write semantics
    ensure that, after the *fork()*, the parent and child don’t see changes made to
    the mapping by the other process. The primary purpose of private anonymous mappings
    is to allocate new (zero-filled) memory for a process (e.g., *malloc()* employs
    *mmap()* for this purpose when allocating large blocks of memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shared file mapping*: All processes mapping the same region of a file share
    the same physical pages of memory, which are initialized from a file region. Modifications
    to the contents of the mapping are carried through to the file. This type of mapping
    serves two purposes. First, it permits *memory-mapped I/O*. By this, we mean that
    a file is loaded into a region of the process’s virtual memory, and modifications
    to that memory are automatically written to the file. Thus, memory-mapped I/O
    provides an alternative to using *read()* and *write()* for performing file I/O.
    A second purpose of this type of mapping is to allow unrelated processes to share
    a region of memory in order to perform (fast) IPC in a manner similar to System
    V shared memory segments ([Chapter 48](ch48.html "Chapter 48. System V Shared
    Memory")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shared anonymous mapping*: As with a private anonymous mapping, each call
    to *mmap()* to create a shared anonymous mapping creates a new, distinct mapping
    that doesn’t share pages with any other mapping. The difference is that the pages
    of the mapping are not copied-on-write. This means that when a child inherits
    the mapping after a *fork()*, the parent and child share the same pages of RAM,
    and changes made to the contents of the mapping by one process are visible to
    the other process. Shared anonymous mappings allow IPC in a manner similar to
    System V shared memory segments, but only between related processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We consider each of these types of mapping in more detail in the remainder of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mappings are lost when a process performs an *exec()*, but are inherited by
    the child of a *fork()*. The mapping type (`MAP_PRIVATE` or `MAP_SHARED`) is also
    inherited.
  prefs: []
  type: TYPE_NORMAL
- en: Information about all of a process’s mappings is visible in the Linux-specific
    `/proc/`*PID*`/maps` file, which we described in Section 48.5.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One further use of *mmap()* is with POSIX shared memory objects, which allow
    a region of memory to be shared between unrelated processes without having to
    create an associated disk file (as is required for a shared file mapping). We
    describe POSIX shared memory objects in [Chapter 54](ch54.html "Chapter 54. POSIX
    Shared Memory").
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Mapping: *mmap()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *mmap()* system call creates a new mapping in the calling process’s virtual
    address space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns starting address of mapping on success, or `MAP_FAILED` on error
  prefs: []
  type: TYPE_NORMAL
- en: The *addr* argument indicates the virtual address at which the mapping is to
    be located. If we specify *addr* as `NULL`, the kernel chooses a suitable address
    for the mapping. This is the preferred way of creating a mapping. Alternatively,
    we can specify a non-`NULL` value in *addr*, which the kernel takes as a hint
    about the address at which the mapping should be placed. In practice, the kernel
    will at the very least round the address to a nearby page boundary. In either
    case, the kernel will choose an address that doesn’t conflict with any existing
    mapping. (If the value `MAP_FIXED` is included in *flags*, then *addr* must be
    page-aligned. We describe this flag in [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").)
  prefs: []
  type: TYPE_NORMAL
- en: On success, *mmap()* returns the starting address of the new mapping. On error,
    *mmap()* returns `MAP_FAILED`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux (and on most other UNIX implementations), the `MAP_FAILED` constant
    equates to *((void *) -1)*. However, SUSv3 specifies this constant because the
    C standards can’t guarantee that *((void *) -1)* is distinct from a successful
    *mmap()* return value.
  prefs: []
  type: TYPE_NORMAL
- en: The *length* argument specifies the size of the mapping in bytes. Although *length*
    doesn’t need to be a multiple of the system page size (as returned by *sysconf(_SC_PAGESIZE)*),
    the kernel creates mappings in units of this size, so that *length* is, in effect,
    rounded up to the next multiple of the page size.
  prefs: []
  type: TYPE_NORMAL
- en: The *prot* argument is a bit mask specifying the protection to be placed on
    the mapping. It can be either `PROT_NONE` or a combination (ORing) of any of the
    other three flags listed in [Table 49-2](ch49.html#memory_protection_values "Table 49-2. Memory
    protection values").
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-2. Memory protection values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_NONE` | The region may not be accessed |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_READ` | The contents of the region can be read |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_WRITE` | The contents of the region can be modified |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_EXEC` | The contents of the region can be executed |'
  prefs: []
  type: TYPE_TB
- en: 'The *flags* argument is a bit mask of options controlling various aspects of
    the mapping operation. Exactly one of the following values must be included in
    this mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a private mapping. Modifications to the contents of the region are not
    visible to other processes employing the same mapping, and, in the case of a file
    mapping, are not carried through to the underlying file.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_SHARED`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a shared mapping. Modifications to the contents of the region are visible
    to other processes mapping the same region with the `MAP_SHARED` attribute and,
    in the case of a file mapping, are carried through to the underlying file. Updates
    to the file are not guaranteed to be immediate; see the discussion of the *msync()*
    system call in Section 49.5.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from `MAP_PRIVATE` and `MAP_SHARED`, other flag values can optionally
    be ORed in *flags*. We discuss these flags in [Additional *mmap()* Flags](ch49.html#additional_mmap_open_parenthesis_close_p
    "Additional mmap() Flags") and [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").
  prefs: []
  type: TYPE_NORMAL
- en: The remaining arguments, *fd* and *offset*, are used with file mappings (they
    are ignored for anonymous mappings). The *fd* argument is a file descriptor identifying
    the file to be mapped. The *offset* argument specifies the starting point of the
    mapping in the file, and must be a multiple of the system page size. To map the
    entire file, we would specify *offset* as 0 and *length* as the size of the file.
    We say more about file mappings in Section 49.5.
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection in more detail
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted above, the *mmap() prot* argument specifies the protection on a new
    memory mapping. It can contain the value `PROT_NONE`, or a mask of one of more
    of the flags `PROT_READ`, `PROT_WRITE`, and `PROT_EXEC`. If a process attempts
    to access a memory region in a way that violates the protection on the region,
    then the kernel delivers the `SIGSEGV` signal to a process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although SUSv3 specifies that `SIGSEGV` should be used to signal memory protection
    violations, on some implementations, `SIGBUS` is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: One use of pages of memory marked `PROT_NONE` is as guard pages at the start
    or end of a region of memory that a process has allocated. If the process accidentally
    steps into one of the pages marked `PROT_NONE`, the kernel informs it of that
    fact by generating a `SIGSEGV` signal.
  prefs: []
  type: TYPE_NORMAL
- en: Memory protections reside in process-private virtual memory tables. Thus, different
    processes may map the same memory region with different protections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory protection can be changed using the *mprotect()* system call ([Changing
    Memory Protection: *mprotect()*](ch50.html#changing_memory_protection_colon_mprotec
    "Changing Memory Protection: mprotect()")).'
  prefs: []
  type: TYPE_NORMAL
- en: On some UNIX implementations, the actual protections placed on the pages of
    a mapping may not be exactly those specified in *prot*. In particular, limitations
    of the protection granularity of the underlying hardware (e.g., older x86-32 architectures)
    mean that, on many UNIX implementations, `PROT_READ` implies `PROT_EXEC` and vice
    versa, and on some implementations, specifying `PROT_WRITE` implies `PROT_READ`.
    However, applications should not rely on such behavior; *prot* should always specify
    exactly the memory protections that are required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern x86-32 architectures provide hardware support for marking pages tables
    as *NX* (no execute), and, since kernel 2.6.8, Linux makes use of this feature
    to properly separate `PROT_READ` and `PROT_EXEC` permissions on Linux/x86-32.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment restrictions specified in standards for *offset* and *addr*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'SUSv3 specifies that the *offset* argument of *mmap()* must be page-aligned,
    and that the *addr* argument must also be page-aligned if `MAP_FIXED` is specified.
    Linux conforms to these requirements. However, it was later noted that the SUSv3
    requirements differed from earlier standards, which imposed looser requirements
    on these arguments. The consequence of the SUSv3 wording was to (unnecessarily)
    render some formerly standards-conformant implementations nonconforming. SUSv4
    returns to the looser requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: An implementation may require that *offset* be a multiple of the system page
    size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `MAP_FIXED` is specified, then an implementation may require that *addr*
    be page-aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `MAP_FIXED` is specified, and *addr* is nonzero, then *addr* and *offset*
    shall have the same remainder modulo the system page size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar situation arose for the *addr* argument of *mprotect()*, *msync()*,
    and *munmap()*. SUSv3 specified that this argument must be page-aligned. SUSv4
    says that an implementation may require this argument to be page-aligned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 49-1](ch49.html#using_mmap_open_parenthesis_close_parent "Example 49-1. Using
    mmap() to create a private file mapping") demonstrates the use of *mmap()* to
    create a private file mapping. This program is a simple version of *cat(1)*. It
    maps the (entire) file named in its command-line argument, and then writes the
    contents of the mapping to standard output.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 49-1. Using *mmap()* to create a private file mapping
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Unmapping a Mapped Region: *munmap()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *munmap()* system call performs the converse of *mmap()*, removing a mapping
    from the calling process’s virtual address space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *addr* argument is the starting address of the address range to be unmapped.
    It must be aligned to a page boundary. (SUSv3 specified that *addr must* be page-aligned.
    SUSv4 says that an implementation *may* require this argument to be page-aligned.)
  prefs: []
  type: TYPE_NORMAL
- en: The *length* argument is a nonnegative integer specifying the size (in bytes)
    of the region to be unmapped. The address range up to the next multiple of the
    system page size will be unmapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly, we unmap an entire mapping. Thus, we specify *addr* as the address
    returned by a previous call to *mmap()*, and specify the same *length* value as
    was used in the *mmap()* call. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can unmap part of a mapping, in which case the mapping either
    shrinks or is cut in two, depending on where the unmapping occurs. It is also
    possible to specify an address range spanning several mappings, in which case
    all of the mappings are unmapped.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no mappings in the address range specified by *addr* and *length*,
    then *munmap()* has no effect, and returns 0 (for success).
  prefs: []
  type: TYPE_NORMAL
- en: During unmapping, the kernel removes any memory locks that the process holds
    for the specified address range. (Memory locks are established using *mlock()*
    or *mlockall()*, as described in Section 50.2.)
  prefs: []
  type: TYPE_NORMAL
- en: All of a process’s mappings are automatically unmapped when it terminates or
    performs an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the contents of a shared file mapping are written to the underlying
    file, a call to *msync()* ([Synchronizing a Mapped Region: *msync()*](ch49.html#synchronizing_a_mapped_region_colon_msyn
    "Synchronizing a Mapped Region: msync()")) should be made before unmapping a mapping
    with *munmap()*.'
  prefs: []
  type: TYPE_NORMAL
- en: File Mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a file mapping, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a descriptor for the file, typically via a call to *open()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass that file descriptor as the *fd* argument in a call to *mmap()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result of these steps, *mmap()* maps the contents of the open file into
    the address space of the calling process. Once *mmap()* has been called, we can
    close the file descriptor without affecting the mapping. However, in some cases
    it may be useful to keep this file descriptor open—see, for example, [Example 49-1](ch49.html#using_mmap_open_parenthesis_close_parent
    "Example 49-1. Using mmap() to create a private file mapping") and also [Chapter 54](ch54.html
    "Chapter 54. POSIX Shared Memory").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as normal disk files, it is possible to use *mmap()* to map the contents
    of various real and virtual devices, such as hard disks, optical disks, and `/dev/mem`.
  prefs: []
  type: TYPE_NORMAL
- en: The file referred to by the descriptor *fd* must have been opened with permissions
    appropriate for the values specified in *prot* and *flags*. In particular, the
    file must always be opened for reading, and, if `PROT_WRITE` and `MAP_SHARED`
    are specified in *flags*, then the file must be opened for both reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: The *offset* argument specifies the starting byte of the region to be mapped
    from the file, and must be a multiple of the system page size. Specifying *offset*
    as 0 causes the file to be mapped from the beginning. The *length* argument specifies
    the number of bytes to be mapped. Together, the *offset* and *length* arguments
    determine which region of the file is to be mapped into memory, as shown in [Figure 49-1](ch49.html#overview_of_memory-mapped_file
    "Figure 49-1. Overview of memory-mapped file").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, the pages of a file mapping are mapped in on the first access. This
    means that if changes are made to a file region after the *mmap()* call, but before
    the corresponding part (i.e., page) of the mapping is accessed, then the changes
    may be visible to the process, if the page has not otherwise already been loaded
    into memory. This behavior is implementation-dependent; portable applications
    should avoid relying on a particular kernel behavior in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Private File Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The two most common uses of private file mappings are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow multiple processes executing the same program or using the same shared
    library to share the same (read-only) text segment, which is mapped from the corresponding
    part of the underlying executable or library file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the executable text segment is normally protected to allow only read
    and execute access (`PROT_READ | PROT_EXEC`), it is mapped using `MAP_PRIVATE`
    rather than `MAP_SHARED`, because a debugger or a self-modifying program can modify
    the program text (after first changing the protection on the memory), and such
    changes should not be carried through to the underlying file or affect other processes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To map the initialized data segment of an executable or shared library. Such
    mappings are made private so that modifications to the contents of the mapped
    data segment are not carried through to the underlying file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these uses of *mmap()* are normally invisible to a program, because
    these mappings are created by the program loader and dynamic linker. Examples
    of both kinds of mappings can be seen in the `/proc/`*PID*`/maps` output shown
    in Section 48.5.
  prefs: []
  type: TYPE_NORMAL
- en: One other, less frequent, use of a private file mapping is to simplify the file-input
    logic of a program. This is similar to the use of shared file mappings for memory-mapped
    I/O (described in the next section), but allows only for file input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of memory-mapped file](figs/web/49-1_MMAP-overview-scale90.png.jpg)Figure 49-1. Overview
    of memory-mapped file'
  prefs: []
  type: TYPE_NORMAL
- en: Shared File Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When multiple processes create shared mappings of the same file region, they
    all share the same physical pages of memory. In addition, modifications to the
    contents of the mapping are carried through to the file. In effect, the file is
    being treated as the paging store for this region of memory, as shown in [Figure 49-2](ch49.html#two_processes_with_a_shared_mapping_of_t
    "Figure 49-2. Two processes with a shared mapping of the same region of a file").
    (We simplify things in this diagram by omitting to show that the mapped pages
    are typically not contiguous in physical memory.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared file mappings serve two purposes: memory-mapped I/O and IPC. We consider
    each of these uses below.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two processes with a shared mapping of the same region of a file](figs/web/49-2_MMAP-shared-mapping.png.jpg)Figure 49-2. Two
    processes with a shared mapping of the same region of a file'
  prefs: []
  type: TYPE_NORMAL
- en: Memory-mapped I/O
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the contents of the shared file mapping are initialized from the file,
    and any modifications to the contents of the mapping are automatically carried
    through to the file, we can perform file I/O simply by accessing bytes of memory,
    relying on the kernel to ensure that the changes to memory are propagated to the
    mapped file. (Typically, a program would define a structured data type that corresponds
    to the contents of the disk file, and then use that data type to cast the contents
    of the mapping.) This technique is referred to as *memory-mapped I/O*, and is
    an alternative to using *read()* and *write()* to access the contents of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory-mapped I/O has two potential advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: By replacing *read()* and *write()* system calls with memory accesses, it can
    simplify the logic of some applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can, in some circumstances, provide better performance than file I/O carried
    out using the conventional I/O system calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reasons that memory-mapped I/O can provide performance benefits are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A normal *read()* or *write()* involves two transfers: one between the file
    and the kernel buffer cache, and the other between the buffer cache and a user-space
    buffer. Using *mmap()* eliminates the second of these transfers. For input, the
    data is available to the user process as soon as the kernel has mapped the corresponding
    file blocks into memory. For output, the user process merely needs to modify the
    contents of the memory, and can then rely on the kernel memory manager to automatically
    update the underlying file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to saving a transfer between kernel space and user space, *mmap()*
    can also improve performance by lowering memory requirements. When using *read()*
    or *write()*, the data is maintained in two buffers: one in user space and the
    other in kernel space. When using *mmap()*, a single buffer is shared between
    the kernel space and user space. Furthermore, if multiple processes are performing
    I/O on the same file, then, using *mmap()*, they can all share the same kernel
    buffer, resulting in an additional memory saving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance benefits from memory-mapped I/O are most likely to be realized when
    performing repeated random accesses in a large file. If we are performing sequential
    access of a file, then *mmap()* will probably provide little or no gain over *read()*
    and *write()*, assuming that we perform I/O using buffer sizes big enough to avoid
    making a large number of I/O system calls. The reason that there is little performance
    benefit is that, regardless of which technique we use, the entire contents of
    the file will be transferred between disk and memory exactly once, and the efficiency
    gains of eliminating a data transfer between user space and kernel space and reducing
    memory usage are typically negligible compared to the time required for disk I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memory-mapped I/O can also have disadvantages. For small I/Os, the cost of memory-mapped
    I/O (i.e., mapping, page faulting, unmapping, and updating the hardware memory
    management unit’s translation look-aside buffer) can actually be higher than for
    a simple *read()* or *write()*. In addition, it can sometimes be difficult for
    the kernel to efficiently handle write-back for writable mappings (the use of
    *msync()* or *sync_file_range()* can help improve efficiency in this case).
  prefs: []
  type: TYPE_NORMAL
- en: IPC using a shared file mapping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since all processes with a shared mapping of the same file region share the
    same physical pages of memory, the second use of a shared file mapping is as a
    method of (fast) IPC. The feature that distinguishes this type of shared memory
    region from a System V shared memory object ([Chapter 48](ch48.html "Chapter 48. System
    V Shared Memory")) is that modifications to the contents of the region are carried
    through to the underlying mapped file. This feature is useful in an application
    that requires the shared memory contents to persist across application or system
    restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 49-2](ch49.html#using_mmap_open_parenthesis_close_pa "Example 49-2. Using
    mmap() to create a shared file mapping") provides a simple example of the use
    of *mmap()* to create a shared file mapping. This program begins by mapping the
    file named in its first command-line argument. It then prints the value of the
    string lying at the start of the mapped region. Finally, if a second command-line
    argument is supplied, that string is copied into the shared memory region.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell session log demonstrates the use of this program. We begin
    by creating a 1024-byte file that is populated with zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use our program to map the file and copy a string into the mapped region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The program displayed nothing for the current string because the initial value
    of the mapped files began with a null byte (i.e., zero-length string).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use our program to again map the file and copy a new string into the
    mapped region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we dump the contents of the file, 8 characters per line, to verify
    its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our trivial program doesn’t use any mechanism to synchronize access by multiple
    processes to the mapped file. However, real-world applications typically need
    to synchronize access to shared mappings. This can be done using a variety of
    techniques, including semaphores ([Chapter 47](ch47.html "Chapter 47. System V
    Semaphores") and [Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")) and file
    locking ([Chapter 55](ch55.html "Chapter 55. File Locking")).
  prefs: []
  type: TYPE_NORMAL
- en: We explain the *msync()* system call used in [Example 49-2](ch49.html#using_mmap_open_parenthesis_close_pa
    "Example 49-2. Using mmap() to create a shared file mapping") in Section 49.5.
  prefs: []
  type: TYPE_NORMAL
- en: Example 49-2. Using *mmap()* to create a shared file mapping
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Boundary Cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, the size of a mapping is a multiple of the system page size,
    and the mapping falls entirely within the bounds of the mapped file. However,
    this is not necessarily so, and we now look at what happens when these conditions
    don’t hold.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul "Figure 49-3. Memory
    mapping whose length is not a multiple of the system page size") portrays the
    case where the mapping falls entirely within the bounds of the mapped file, but
    the size of the region is not a multiple of the system page size (which we assume
    is 4096 bytes for the purposes of this discussion).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory mapping whose length is not a multiple of the system page size](figs/web/49-3_MMAP-size-part-1.png.jpg)Figure 49-3. Memory
    mapping whose *length* is not a multiple of the system page size'
  prefs: []
  type: TYPE_NORMAL
- en: Since the size of the mapping is not a multiple of the system page size, it
    is rounded up to the next multiple of the system page size. Because the file is
    larger than this rounded-up size, the corresponding bytes of the file are mapped
    as shown in [Figure 49-3](ch49.html#memory_mapping_whose_length_is_not_a_mul "Figure 49-3. Memory
    mapping whose length is not a multiple of the system page size").
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to access bytes beyond the end of the mapping result in the generation
    of a `SIGSEGV` signal (assuming that there is no other mapping at that location).
    The default action for this signal is to terminate the process with a core dump.
  prefs: []
  type: TYPE_NORMAL
- en: When the mapping extends beyond the end of the underlying file (see [Figure 49-4](ch49.html#memory_mapping_extending_beyond_end_of_m
    "Figure 49-4. Memory mapping extending beyond end of mapped file")), the situation
    is more complex. As before, because the size of the mapping is not a multiple
    of the system page size, it is rounded up. However, in this case, while the bytes
    in the rounded-up region (i.e., bytes 2200 to 4095 in the diagram) are accessible,
    they are not mapped to the underlying file (since no corresponding bytes exist
    in the file). Instead, they are initialized to 0 (SUSv3 requires this). These
    bytes will nevertheless be shared with other processes mapping the file, if they
    specify a sufficiently large *length* argument. Changes to these bytes are not
    written to the file.
  prefs: []
  type: TYPE_NORMAL
- en: If the mapping includes pages beyond the rounded-up region (i.e., bytes 4096
    and beyond in [Figure 49-4](ch49.html#memory_mapping_extending_beyond_end_of_m
    "Figure 49-4. Memory mapping extending beyond end of mapped file")), then attempts
    to access addresses in these pages result in the generation of a `SIGBUS` signal,
    which warns the process that there is no region of the file corresponding to these
    addresses. As before, attempts to access addresses beyond the end of the mapping
    result in the generation of a `SIGSEGV` signal.
  prefs: []
  type: TYPE_NORMAL
- en: From the above description, it may appear pointless to create a mapping whose
    size exceeds that of the underlying file. However, by extending the size of the
    file (e.g., using *ftruncate()* or *write()*), we can render previously inaccessible
    parts of such a mapping usable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory mapping extending beyond end of mapped file](figs/web/49-4_MMAP-size-part-2.png.jpg)Figure 49-4. Memory
    mapping extending beyond end of mapped file'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Protection and File Access Mode Interactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One point that we have not so far explained in detail is the interaction between
    the memory protection specified in the *mmap() prot* argument and the mode in
    which the mapped file is opened. As a general principle, we can say that the `PROT_READ`
    and `PROT_EXEC` protections require that the mapped file is opened `O_RDONLY`
    or `O_RDWR`, and that the `PROT_WRITE` protection requires that the mapped file
    is opened `O_WRONLY` or `O_RDWR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the situation is complicated by the limited granularity of memory
    protections provided by some hardware architectures ([Creating a Mapping: *mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "Creating a Mapping: mmap()")). For such architectures, we make the following
    observations:'
  prefs: []
  type: TYPE_NORMAL
- en: All combinations of memory protection are compatible with opening the file with
    the `O_RDWR` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No combination of memory protections—not even just `PROT_WRITE`—is compatible
    with a file opened `O_WRONLY` (the error `EACCES` results). This is consistent
    with the fact that some hardware architectures don’t allow us write-only access
    to a page. As noted in [Creating a Mapping: *mmap()*](ch49.html#creating_a_mapping_colon_mmap_open_paren
    "Creating a Mapping: mmap()"), `PROT_WRITE` implies `PROT_READ` on those architectures,
    which means that if the page can be written, then it can also be read. A read
    operation is incompatible with `O_WRONLY`, which must not reveal the original
    contents of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results when a file is opened with the `O_RDONLY` flag depend on whether
    we specify `MAP_PRIVATE` or `MAP_SHARED` when calling *mmap()*. For a `MAP_PRIVATE`
    mapping, we can specify any combination of memory protection in *mmap()*—because
    modifications to the contents of a `MAP_PRIVATE` page are never written to the
    file, the inability to write to the file is not a problem. For a `MAP_SHARED`
    mapping, the only memory protections that are compatible with `O_RDONLY` are `PROT_READ`
    and `(PROT_READ | PROT_EXEC)`. This is logical, since a `PROT_WRITE`, `MAP_SHARED`
    mapping allows updates to the mapped file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Synchronizing a Mapped Region: *msync()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel automatically carries modifications of the contents of a `MAP_SHARED`
    mapping through to the underlying file, but, by default, provides no guarantees
    about when such synchronization will occur. (SUSv3 doesn’t require an implementation
    to provide such guarantees.)
  prefs: []
  type: TYPE_NORMAL
- en: The *msync()* system call gives an application explicit control over when a
    shared mapping is synchronized with the mapped file. Synchronizing a mapping with
    the underlying file is useful in various scenarios. For example, to ensure data
    integrity, a database application may call *msync()* to force data to be written
    to the disk. Calling *msync()* also allows an application to ensure that updates
    to a writable mapping are visible to some other process that performs a *read()*
    on the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *addr* and *length* arguments to *msync()* specify the starting address
    and size of the memory region to be synchronized. The address specified in *addr*
    must be page-aligned, and *len* is rounded up to the next multiple of the system
    page size. (SUSv3 specified that *addr must* be page-aligned. SUSv4 says that
    an implementation *may* require this argument to be page-aligned.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible values for the *flags* argument include one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MS_SYNC`'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a synchronous file write. The call blocks until all modified pages of
    the memory region have been written to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '`MS_ASYNC`'
  prefs: []
  type: TYPE_NORMAL
- en: Perform an asynchronous file write. The modified pages of the memory region
    are written to the disk at some later point and are immediately made visible to
    other processes performing a *read()* on the corresponding file region.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of distinguishing these two values is to say that after an `MS_SYNC`
    operation, the memory region is synchronized with the disk, while after an `MS_ASYNC`
    operation, the memory region is merely synchronized with the kernel buffer cache.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we take no further action after an `MS_ASYNC` operation, then the modified
    pages in the memory region will eventually be flushed as part of the automatic
    buffer flushing performed by the *pdflush* kernel thread (*kupdated* in Linux
    2.4 and earlier). On Linux, there are two (nonstandard) methods of initiating
    the output sooner. We can follow the call to *msync()* with a call to *fsync()*
    (or *fdatasync()*) on the file descriptor corresponding to the mapping. This call
    will block until the buffer cache is synchronized with the disk. Alternatively,
    we can initiate asynchronous write out of the pages using the *posix_fadvise()*
    `POSIX_FADV_DONTNEED` operation. (The Linux-specific details in these two cases
    are not specified by SUSv3.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One other value can additionally be specified for *flags*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MS_INVALIDATE`'
  prefs: []
  type: TYPE_NORMAL
- en: Invalidate cached copies of mapped data. After any modified pages in the memory
    region have been synchronized with the file, all pages of the memory region that
    are inconsistent with the underlying file data are marked as invalid. When next
    referenced, the contents of the pages will be copied from the corresponding locations
    in the file. As a consequence, any updates that have been made to the file by
    another process are made visible in the memory region.
  prefs: []
  type: TYPE_NORMAL
- en: Like many other modern UNIX implementations, Linux provides a so-called *unified
    virtual memory* system. This means that, where possible, memory mappings and blocks
    of the buffer cache share the same pages of physical memory. Thus, the views of
    a file obtained via a mapping and via I/O system calls (*read()*, *write()*, and
    so on) are always consistent, and the only use of *msync()* is to force the contents
    of a mapped region to be flushed to disk.
  prefs: []
  type: TYPE_NORMAL
- en: However, a unified virtual memory system is not required by SUSv3 and is not
    employed on all UNIX implementations. On such systems, a call to *msync()* is
    required to make changes to the contents of a mapping visible to other processes
    that *read()* the file, and the `MS_INVALIDATE` flag is required to perform the
    converse action of making writes to the file by another process visible in the
    mapped region. Multiprocess applications that employ both *mmap()* and I/O system
    calls to operate on the same file should be designed to make appropriate use of
    *msync()* if they are to be portable to systems that don’t have a unified virtual
    memory system.
  prefs: []
  type: TYPE_NORMAL
- en: Additional *mmap()* Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `MAP_PRIVATE` and `MAP_SHARED`, Linux allows a number of other
    values to be included (ORed) in the *mmap() flags* argument. [Table 49-3](ch49.html#bit-mask_values_for_the_mmap_open_parent
    "Table 49-3. Bit-mask values for the mmap() flags argument") summarizes these
    values. Other than `MAP_PRIVATE` and `MAP_SHARED`, only the `MAP_FIXED` flag is
    specified in SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-3. Bit-mask values for the *mmap() flags* argument
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description | SUSv3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_ANONYMOUS` | Create an anonymous mapping |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_FIXED` | Interpret *addr* argument exactly ([The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag")) | • |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_LOCKED` | Lock mapped pages into memory (since Linux 2.6) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_HUGETLB` | Create a mapping that uses huge pages (since Linux 2.6.32)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_NORESERVE` | Control reservation of swap space ([`MAP_NORESERVE` and
    Swap Space Overcommitting](ch49.html#map_underscore_noreserve_and_swap_space "MAP_NORESERVE
    and Swap Space Overcommitting")) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_PRIVATE` | Modifications to mapped data are private | • |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_POPULATE` | Populate the pages of a mapping (since Linux 2.6) | • |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_SHARED` | Modifications to mapped data are visible to other processes
    and propagated to underlying file (converse of `MAP_PRIVATE`) | • |'
  prefs: []
  type: TYPE_TB
- en: '| `MAP_UNINITIALIZED` | Don’t clear an anonymous mapping (since Linux 2.6.33)
    |   |'
  prefs: []
  type: TYPE_TB
- en: 'The following list provides further details on the *flags* values listed in
    [Table 49-3](ch49.html#bit-mask_values_for_the_mmap_open_parent "Table 49-3. Bit-mask
    values for the mmap() flags argument") (other than `MAP_PRIVATE` and `MAP_SHARED`,
    which have already been discussed):'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_ANONYMOUS`'
  prefs: []
  type: TYPE_NORMAL
- en: Create an anonymous mapping—that is, a mapping that is not backed by a file.
    We describe this flag further in Section 49.7.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_FIXED`'
  prefs: []
  type: TYPE_NORMAL
- en: We describe this flag in [The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag
    "The MAP_FIXED Flag").
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_HUGETLB` (since Linux 2.6.32)'
  prefs: []
  type: TYPE_NORMAL
- en: This flag serves the same purpose for *mmap()* as the `SHM_HUGETLB` flag serves
    for System V shared memory segments. See Section 48.2.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_LOCKED` (since Linux 2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: Preload and lock the mapped pages into memory in the manner of *mlock()*. We
    describe the privileges required to use this flag and the limits governing its
    operation in Section 50.2.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_NORESERVE`'
  prefs: []
  type: TYPE_NORMAL
- en: This flag is used to control whether reservation of swap space for the mapping
    is performed in advance. See [`MAP_NORESERVE` and Swap Space Overcommitting](ch49.html#map_underscore_noreserve_and_swap_space
    "MAP_NORESERVE and Swap Space Overcommitting") for details.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_POPULATE` (since Linux 2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: Populate the pages of a mapping. For a file mapping, this will perform read-ahead
    on the file. This means that later accesses of the contents of the mapping won’t
    be blocked by page faults (assuming that memory pressure has not in the meantime
    caused the pages to be swapped out).
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_UNINITIALIZED` (since Linux 2.6.33)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying this flag prevents the pages of an anonymous mapping from being zeroed.
    It provides a performance benefit, but carries a security risk, because the allocated
    pages may contain sensitive information left by a previous process. This flag
    is thus only intended for use on embedded systems, where performance may be critical,
    and the entire system is under the control of the embedded application(s). This
    flag is only honored if the kernel was configured with the `CONFIG_MMAP_ALLOW_UNINITIALIZED`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *anonymous mapping* is one that doesn’t have a corresponding file. In this
    section, we show how to create anonymous mappings, and look at the purposes served
    by private and shared anonymous mappings.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_ANONYMOUS` and `/dev/zero`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, there are two different, equivalent methods of creating an anonymous
    mapping with *mmap()*:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify `MAP_ANONYMOUS` in *flags* and specify *fd* as -1\. (On Linux, the value
    of *fd* is ignored when `MAP_ANONYMOUS` is specified. However, some UNIX implementations
    require fd to be -1 when employing `MAP_ANONYMOUS`, and portable applications
    should ensure that they do this.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We must define either the `_BSD_SOURCE` or the `_SVID_SOURCE` feature test macros
    to get the definition of `MAP_ANONYMOUS` from `<sys/mman.h>`. Linux provides the
    constant `MAP_ANON` as a synonym for `MAP_ANONYMOUS` for compatibility with some
    other UNIX implementations using this alternative name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `/dev/zero` device file and pass the resulting file descriptor to *mmap()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`/dev/zero` is a virtual device that always returns zeros when we read from
    it. Writes to this device are always discarded. A common use of `/dev/zero` is
    to populate a file with zeros (e.g., using the *dd(1)* command).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With both the `MAP_ANONYMOUS` and the `/dev/zero` techniques, the bytes of the
    resulting mapping are initialized to 0\. For both techniques, the *offset* argument
    is ignored (since there is no underlying file in which to specify an offset).
    We show examples of each technique shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MAP_ANONYMOUS` and `/dev/zero` techniques are not specified in SUSv3, although
    most UNIX implementations support one or both of them. The reason for the existence
    of two different techniques with the same semantics is that one (`MAP_ANONYMOUS`)
    derives from BSD, while the other (`/dev/zero`) derives from System V.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE` anonymous mappings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE` anonymous mappings are used to allocate blocks of process-private
    memory initialized to 0\. We can use the `/dev/zero` technique to create a `MAP_PRIVATE`
    anonymous mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *glibc* implementation of *malloc()* uses `MAP_PRIVATE` anonymous mappings
    to allocate blocks of memory larger than `MMAP_THRESHOLD` bytes. This makes it
    possible to efficiently deallocate such blocks (via *munmap()*) if they are later
    given to *free()*. (It also reduces the possibility of memory fragmentation when
    repeatedly allocating and deallocating large blocks of memory.) `MMAP_THRESHOLD`
    is 128 kB by default, but this parameter is adjustable via the *mallopt()* library
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_SHARED` anonymous mappings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `MAP_SHARED` anonymous mapping allows related processes (e.g., parent and
    child) to share a region of memory without needing a corresponding mapped file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MAP_SHARED` anonymous mappings are available only with Linux 2.4 and later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `MAP_ANONYMOUS` technique to create a `MAP_SHARED` anonymous
    mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the above code is followed by a call to *fork()*, then, because the child
    produced by *fork()* inherits the mapping, both processes share the memory region.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program in [Example 49-3](ch49.html#sharing_an_anonymous_mapping_between_par
    "Example 49-3. Sharing an anonymous mapping between parent and child processes")
    demonstrates the use of either `MAP_ANONYMOUS` or `/dev/zero` to share a mapped
    region between parent and child processes. The choice of technique is determined
    by whether `USE_MAP_ANON` is defined when compiling the program. The parent initializes
    an integer in the shared region to 1 prior to calling *fork()*. The child then
    increments the shared integer and exits, while the parent waits for the child
    to exit and then prints the value of the integer. When we run this program, we
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 49-3. Sharing an anonymous mapping between parent and child processes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Remapping a Mapped Region: *mremap()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On most UNIX implementations, once a mapping has been created, its location
    and size can’t be changed. However, Linux provides the (nonportable) *mremap()*
    system call, which permits such changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns starting address of remapped region on success, or `MAP_FAILED` on error
  prefs: []
  type: TYPE_NORMAL
- en: The *old_address* and *old_size* arguments specify the location and size of
    an existing mapping that we wish to expand or shrink. The address specified in
    *old_address* must be page-aligned, and is normally a value returned by a previous
    call to *mmap()*. The desired new size of the mapping is specified in *new_size*.
    The values specified in *old_size* and *new_size* are both rounded up to the next
    multiple of the system page size.
  prefs: []
  type: TYPE_NORMAL
- en: 'While carrying out the remapping, the kernel may relocate the mapping within
    the process’s virtual address space. Whether or not this is permitted is controlled
    by the *flags* argument, which is a bit mask that may either be 0 or include the
    following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MREMAP_MAYMOVE`'
  prefs: []
  type: TYPE_NORMAL
- en: If this flag is specified, then, as space requirements dictate, the kernel may
    relocate the mapping within the process’s virtual address space. If this flag
    is not specified, and there is insufficient space to expand the mapping at the
    current location, then the error `ENOMEM` results.
  prefs: []
  type: TYPE_NORMAL
- en: '`MREMAP_FIXED` (since Linux 2.4)'
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be used only in conjunction with `MREMAP_MAYMOVE`. It serves a
    purpose for *mremap()* that is analogous to that served by `MAP_FIXED` for *mmap()*
    ([The `MAP_FIXED` Flag](ch49.html#the_map_underscore_fixed_flag "The MAP_FIXED
    Flag")). If this flag is specified, then *mremap()* takes an additional argument,
    *void *new_address*, that specifies a page-aligned address to which the mapping
    should be moved. Any previous mapping in the address range specified by *new_address*
    and *new_size* is unmapped.
  prefs: []
  type: TYPE_NORMAL
- en: On success, *mremap()* returns the starting address of the mapping. Since (if
    the `MREMAP_MAYMOVE` flag is specified) this address may be different from the
    previous starting address, pointers into the region may cease to be valid. Therefore,
    applications that use *mremap()* should use only offsets (not absolute pointers)
    when referring to addresses in the mapped region (see [Storing Pointers in Shared
    Memory](ch48.html#storing_pointers_in_shared_memory "Storing Pointers in Shared
    Memory")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, the *realloc()* function uses *mremap()* to efficiently reallocate
    large blocks of memory that *malloc()* previously allocated using *mmap()* `MAP_ANONYMOUS`.
    (We mentioned this feature of the *glibc malloc()* implementation in Section 49.7.)
    Using *mremap()* for this task makes it possible to avoid copying of bytes during
    the reallocation.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_NORESERVE` and Swap Space Overcommitting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications create large (usually private anonymous) mappings, but use
    only a small part of the mapped region. For example, certain types of scientific
    applications allocate a very large array, but operate on only a few widely separated
    elements of the array (a so-called *sparse array*).
  prefs: []
  type: TYPE_NORMAL
- en: If the kernel always allocated (or reserved) enough swap space for the whole
    of such mappings, then a lot of swap space would potentially be wasted. Instead,
    the kernel can reserve swap space for the pages of a mapping only as they are
    actually required (i.e., when the application accesses a page). This approach
    is called *lazy swap reservation*, and has the advantage that the total virtual
    memory used by applications can exceed the total size of RAM plus swap space.
  prefs: []
  type: TYPE_NORMAL
- en: To put things another way, lazy swap reservation allows swap space to be overcommitted.
    This works fine, as long as all processes don’t attempt to access the entire range
    of their mappings. However, if all applications do attempt to access the full
    range of their mappings, RAM and swap space will be exhausted. In this situation,
    the kernel reduces memory pressure by killing one or more of the processes on
    the system. Ideally, the kernel attempts to select the process causing the memory
    problems (see the discussion of the *OOM killer* below), but this isn’t guaranteed.
    For this reason, we may choose to prevent lazy swap reservation, instead forcing
    the system to allocate all of the necessary swap space when the mapping is created.
  prefs: []
  type: TYPE_NORMAL
- en: How the kernel handles reservation of swap space is controlled by the use of
    the `MAP_NORESERVE` flag when calling *mmap()*, and via `/proc` interfaces that
    affect the system-wide operation of swap space overcommitting. These factors are
    summarized in [Table 49-4](ch49.html#handling_of_swap_space_reservation_durin
    "Table 49-4. Handling of swap space reservation during mmap()").
  prefs: []
  type: TYPE_NORMAL
- en: Table 49-4. Handling of swap space reservation during *mmap()*
  prefs: []
  type: TYPE_NORMAL
- en: '| `overcommit_memory` value | `MAP_NORESERVE` specified in *mmap()* call? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Deny obvious overcommits | Allow overcommits |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Allow overcommits | Allow overcommits |'
  prefs: []
  type: TYPE_TB
- en: '| 2 (since Linux 2.6) | Strict overcommitting |'
  prefs: []
  type: TYPE_TB
- en: 'The Linux-specific `/proc/sys/vm/overcommit_memory` file contains an integer
    value that controls the kernel’s handling of swap space overcommits. Linux versions
    before 2.6 differentiated only two values in this file: 0, meaning deny obvious
    overcommits (subject to the use of the `MAP_NORESERVE` flag), and greater than
    0, meaning that overcommits should be permitted in all cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Denying obvious overcommits means that new mappings whose size doesn’t exceed
    the amount of currently available free memory are permitted. Existing allocations
    may be overcommitted (since they may not be using all of the pages that they mapped).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Linux 2.6, a value of 1 has the same meaning as a positive value in earlier
    kernels, but the value 2 (or greater) causes *strict overcommitting* to be employed.
    In this case, the kernel performs strict accounting on all *mmap()* allocations
    and limits the system-wide total of all such allocations to be less than or equal
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `overcommit_ratio` value is an integer—expressing a percentage—contained
    in the Linux-specific `/proc/sys/vm/overcommit_ratio` file. The default value
    contained in this file is 50, meaning that the kernel can overallocate up to 50%
    of the size of the system’s RAM, and this will be successful, as long as not all
    processes try to use their full allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that overcommit monitoring comes into play only for the following types
    of mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: private writable mappings (both file and anonymous mappings), for which the
    swap “cost” of the mapping is equal to the size of the mapping for each process
    that employs the mapping; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shared anonymous mappings, for which the swap “cost” of the mapping is the size
    of the mapping (since all processes share that mapping).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reserving swap space for a read-only private mapping is unnecessary: since
    the contents of the mapping can’t be modified, there is no need to employ swap
    space. Swap space is also not required for shared file mappings, because the mapped
    file itself acts as the swap space for the mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: When a child process inherits a mapping across a *fork()*, it inherits the `MAP_NORESERVE`
    setting for the mapping. The `MAP_NORESERVE` flag is not specified in SUSv3, but
    it is supported on a few other UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we have discussed how a call to *mmap()* may fail to increase
    the address space of a process because of the system limitations on RAM and swap
    space. A call to *mmap()* can also fail because it encounters the per-process
    `RLIMIT_AS` resource limit (described in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")), which places an upper limit on the size
    of the address space of the calling process.
  prefs: []
  type: TYPE_NORMAL
- en: The OOM killer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Above, we noted that when we employ lazy swap reservation, memory may become
    exhausted if applications attempt to employ the entire range of their mappings.
    In this case, the kernel relieves memory exhaustion by killing processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel code dedicated to selecting a process to kill when memory is exhausted
    is commonly known as the out-of-memory (OOM) killer. The OOM killer tries to choose
    the best process to kill in order to relieve the memory exhaustion, where “best”
    is determined by a range of factors. For example, the more memory a process is
    consuming, the more likely it will be a candidate for the OOM killer. Other factors
    that increase a process’s likelihood of selection are forking to create many child
    processes and having a low nice value (i.e., one that is greater than 0). The
    kernel disfavors killing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: processes that are privileged, since they are probably performing important
    tasks;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: processes that are performing raw device access, since killing them may leave
    the device in an unusable state; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: processes that have been running for a long time or have consumed a lot of CPU,
    since killing them would result in a lot of lost “work.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To kill the selected process, the OOM killer delivers a `SIGKILL` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux-specific `/proc/`*PID*`/oom_score` file, available since kernel 2.6.11,
    shows the weighting that the kernel gives to a process if it is necessary to invoke
    the OOM killer. The greater the value in this file, the more likely the process
    is to be selected, if necessary, by the OOM killer. The Linux-specific `/proc/`*PID*`/oom_adj`
    file, also available since kernel 2.6.11, can be used to influence the `oom_score`
    of a process. This file can be set to any value in the range -16 to +15, where
    negative values decrease the `oom_score` and positive values increase it. The
    special value -17 removes the process altogether as a candidate for selection
    by the OOM killer. For further details, see the *proc(5)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: The `MAP_FIXED` Flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Specifying `MAP_FIXED` in the *mmap() flags* argument forces the kernel to interpret
    the address in *addr* exactly, rather than take it as a hint. If we specify `MAP_FIXED`,
    *addr* must be page-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a portable application should omit the use of `MAP_FIXED`, and specify
    *addr* as `NULL`, which allows the system to choose the address at which to place
    the mapping. The reasons for this are the same as those that we outlined in [Using
    Shared Memory](ch48.html#using_shared_memory "Using Shared Memory") when explaining
    why it usually preferable to specify *shmaddr* as `NULL` when attaching a System
    V shared memory segment using *shmat()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one situation where a portable application might use `MAP_FIXED`.
    If `MAP_FIXED` is specified when calling *mmap()*, and the memory region beginning
    at *addr* and running for *length* bytes overlaps the pages of any previous mapping,
    then the overlapped pages are replaced by the new mapping. We can use this feature
    to portably map multiple parts of a file (or files) into a contiguous region of
    memory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *mmap()* to create an anonymous mapping ([Anonymous Mappings](ch49.html#anonymous_mappings
    "Anonymous Mappings")). In the *mmap()* call, we specify *addr* as `NULL` and
    don’t specify the `MAP_FIXED` flag. This allows the kernel to choose an address
    for the mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a series of *mmap()* calls specifying `MAP_FIXED` to map (i.e., overlay)
    file regions into different parts of the mapping created in the preceding step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we could skip the first step, and use a series of *mmap()* `MAP_FIXED`
    operations to create a set of contiguous mappings at an address range selected
    by the application, this approach is less portable than performing both steps.
    As noted above, a portable application should avoid trying to create a new mapping
    at a fixed address. The first step avoids the portability problem, because we
    let the kernel select a contiguous address range, and then create new mappings
    within that address range.
  prefs: []
  type: TYPE_NORMAL
- en: From Linux 2.6 onward, the *remap_file_pages()* system call, which we describe
    in the next section, can also be used to achieve the same effect. However, the
    use of `MAP_FIXED` is more portable than *remap_file_pages()*, which is Linux-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonlinear Mappings: *remap_file_pages()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File mappings created with *mmap()* are linear: there is a sequential, one-to-one
    correspondence between the pages of the mapped file and the pages of the memory
    region. For most applications, a linear mapping suffices. However, some applications
    need to create large numbers of nonlinear mappings—mappings where the pages of
    the file appear in a different order within contiguous memory. We show an example
    of a nonlinear mapping in [Figure 49-5](ch49.html#a_nonlinear_file_mapping "Figure 49-5. A
    nonlinear file mapping").'
  prefs: []
  type: TYPE_NORMAL
- en: 'We described one way of creating nonlinear mappings in the previous section:
    using multiple calls to *mmap()* with the `MAP_FIXED` flag. However, this approach
    doesn’t scale well. The problem is that each of these *mmap()* calls creates a
    separate kernel virtual memory area (VMA) data structure. Each VMA takes time
    to set up and consumes some nonswappable kernel memory. Furthermore, the presence
    of a large number of VMAs can degrade the performance of the virtual memory manager;
    in particular, the time taken to process each page fault can significantly increase
    when there are tens of thousands of VMAs. (This was a problem for some large database
    management systems that maintain multiple different views in a database file.)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each line in the `/proc/`*PID*`/maps` file ([Location of Shared Memory in Virtual
    Memory](ch48.html#location_of_shared_memory_in_virtual_mem "Location of Shared
    Memory in Virtual Memory")) represents one VMA.
  prefs: []
  type: TYPE_NORMAL
- en: 'From kernel 2.6 onward, Linux provides the *remap_file_pages()* system call
    to create nonlinear mappings without creating multiple VMAs. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mapping with *mmap()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one or more calls to *remap_file_pages()* to rearrange the correspondence
    between the pages of memory and the pages of the file. (All that *remap_file_pages()*
    is doing is manipulating process page tables.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to use *remap_file_pages()* to map the same page of a file into
    multiple locations within the mapped region.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pgoff* and *size* arguments identify a file region whose position in memory
    is to be changed. The *pgoff* argument specifies the start of the file region
    in units of the system page size (as returned by *sysconf(_SC_PAGESIZE)*). The
    *size* argument specifies the length of the file region, in bytes. The *addr*
    argument serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It identifies the existing mapping whose pages we want to rearrange. In other
    words, *addr* must be an address that falls somewhere within a region that was
    previously mapped with *mmap()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It specifies the memory address at which the file pages identified by *pgoff*
    and *size* are to be located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both *addr* and *size* should be specified as multiples of the system page size.
    If they are not, they are rounded down to the nearest multiple of the page size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we use the following call to *mmap()* to map three pages of the
    open file referred to by the descriptor *fd*, and that the call assigns the returned
    address `0x4001a000` to *addr*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following calls would then create the nonlinear mapping shown in [Figure 49-5](ch49.html#a_nonlinear_file_mapping
    "Figure 49-5. A nonlinear file mapping"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![A nonlinear file mapping](figs/web/49-5_MMAP-nonlinear.png.jpg)Figure 49-5. A
    nonlinear file mapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other arguments to *remap_file_pages()* that we haven’t yet described:'
  prefs: []
  type: TYPE_NORMAL
- en: The *prot* argument is ignored, and must be specified as 0\. In the future,
    it may be possible to use this argument to change the protection of the memory
    region affected by *remap_file_pages()*. In the current implementation, the protection
    remains the same as that on the entire VMA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtual machines and garbage collectors are other applications that employ multiple
    VMAs. Some of these applications need to be able to write-protect individual pages.
    It was intended that *remap_file_pages()* would allow permissions on individual
    pages within a VMA to be changed, but this facility has not so far been implemented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *flags* argument is currently unused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As currently implemented, *remap_file_pages()* can be applied only to shared
    (`MAP_SHARED`) mappings.
  prefs: []
  type: TYPE_NORMAL
- en: The *remap_file_pages()* system call is Linux-specific; it is not specified
    in SUSv3 and is not available on other UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *mmap()* system call creates a new memory mapping in the calling process’s
    virtual address space. The *munmap()* system call performs the converse operation,
    removing a mapping from a process’s address space.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mapping may be of two types: file-based or anonymous. A file mapping maps
    the contents of a file region into the process’s virtual address space. An anonymous
    mapping (created by using the `MAP_ANONYMOUS` flag or by mapping `/dev/zero`)
    doesn’t have a corresponding file region; the bytes of the mapping are initialized
    to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Mappings can be either private (`MAP_PRIVATE`) or shared (`MAP_SHARED`). This
    distinction determines the visibility of changes made to the shared memory, and,
    in the case of file mappings, determines whether the kernel propagates changes
    to the contents of the mapping to the underlying file. When a process maps a file
    with the `MAP_PRIVATE` flag, any changes it makes to the contents of the mapping
    are not visible to other processes and are not carried through to the mapped file.
    A `MAP_SHARED` file mapping is the converse—changes to the mapping are visible
    to other processes and are carried through to the mapped file.
  prefs: []
  type: TYPE_NORMAL
- en: Although the kernel automatically propagates changes to the contents of a `MAP_SHARED`
    mapping to the underlying file, it doesn’t provide any guarantees about when this
    is done. An application can use the *msync()* system call to explicitly control
    when the contents of a mapping are synchronized with the mapped file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory mappings serve a variety of uses, including:'
  prefs: []
  type: TYPE_NORMAL
- en: allocating process-private memory (private anonymous mappings);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: initializing the contents of the text and initialized data segments of a process
    (private file mappings);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sharing memory between processes related via *fork()* (shared anonymous mappings);
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: performing memory-mapped I/O, optionally combined with memory sharing between
    unrelated processes (shared file mappings).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two signals may come into play when accessing the contents of a mapping. `SIGSEGV`
    is generated if we attempt access in a manner that violates the protections on
    the mapping (or if we access any currently unmapped address). `SIGBUS` is generated
    for file-based mappings if we access a part of the mapping for which no corresponding
    region exists in the file (i.e., the mapping is larger than the underlying file).
  prefs: []
  type: TYPE_NORMAL
- en: Swap space overcommitting allows the system to allocate more memory to processes
    than is actually available in RAM and swap space. Overcommitting is possible because,
    typically, each process does not make full use of its allocation. Overcommitting
    can be controlled on a per-*mmap()* basis using the `MAP_NORESERVE` flag, and
    on a system-wide basis using `/proc` files.
  prefs: []
  type: TYPE_NORMAL
- en: The *mremap()* system call allows an existing mapping to be resized. The *remap_file_pages()*
    system call allows the creation of nonlinear file mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Information about the implementation of *mmap()* on Linux can be found in [Bovet
    & Cesati, 2005]. Information about the implementation of *mmap()* on other UNIX
    systems can be found in [McKusick et al., 1996] (BSD), [Goodheart & Cox, 1994]
    (System V Release 4), and [Vahalia, 1996] (System V Release 4).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program, analogous to *cp(1)*, that uses *mmap()* and *memcpy()* calls
    (instead of *read()* or *write()*) to copy a source file to a destination file.
    (Use *fstat()* to obtain the size of the input file, which can then be used to
    size the required memory mappings, and use *ftruncate()* to set the size of the
    output file.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`, page 1003) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`, page 1005) to use a shared memory mapping instead
    of System V shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write programs to verify that the `SIGBUS` and `SIGSEGV` signals are delivered
    in the circumstances described in [Boundary Cases](ch49.html#boundary_cases "Boundary
    Cases").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that uses the `MAP_FIXED` technique described in [The `MAP_FIXED`
    Flag](ch49.html#the_map_underscore_fixed_flag "The MAP_FIXED Flag") to create
    a nonlinear mapping similar to that shown in [Figure 49-5](ch49.html#a_nonlinear_file_mapping
    "Figure 49-5. A nonlinear file mapping").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
