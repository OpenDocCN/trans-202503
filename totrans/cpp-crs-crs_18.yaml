- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: STRINGS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STRINGS**
- en: '*If you talk to a man in a language he understands, that goes to his head.
    If you talk to him in his language, that goes to his heart.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你用一个人能理解的语言和他交谈，那会打动他的头脑。如果你用他的语言和他说话，那会打动他的心。*'
- en: —Nelson Mandela*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —纳尔逊·曼德拉*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The STL provides a special *string container* for human-language data, such
    as words, sentences, and markup languages. Available in the `<string>` header,
    the `std::basic_string` is a class template that you can specialize on a string’s
    underlying character type. As a sequential container, `basic_string` is essentially
    similar to a `vector` but with some special facilities for manipulating language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了一种专门的 *字符串容器* 用于处理人类语言数据，如单词、句子和标记语言。`std::basic_string` 是一个类模板，可以根据字符串的底层字符类型进行特化，位于
    `<string>` 头文件中。作为一个顺序容器，`basic_string` 本质上类似于 `vector`，但具有一些特殊的功能，用于处理语言数据。
- en: STL `basic_string` provides major safety and feature improvements over C-style
    or null-terminated strings, and because human-language data inundates most modern
    programs, you’ll probably find `basic_string` indispensable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的 `basic_string` 在安全性和功能性上相较于 C 风格的字符串或空终止字符串有了显著提升，而且由于人类语言数据充斥着现代程序，你很可能会发现
    `basic_string` 是不可或缺的。
- en: '**std::string**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**std::string**'
- en: 'The STL provides four `basic_string` specializations in the `<string>` header.
    Each specialization implements a string using one of the fundamental character
    types that you learned about in [Chapter 2](ch02.xhtml#ch02):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了四种 `basic_string` 特化形式，在 `<string>` 头文件中定义。每种特化形式使用你在[第 2 章](ch02.xhtml#ch02)中学习到的基本字符类型之一来实现字符串：
- en: '`std::string` for `char` is used for character sets like ASCII.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string` 用于 `char`，适用于像 ASCII 这样的字符集。'
- en: '`std::wstring` for `wchar_t` is large enough to contain the largest character
    of the implementation’s locale.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::wstring` 用于 `wchar_t`，其大小足以包含实现区域设置中的最大字符。'
- en: '`std::u16string` for `char16_t` is used for character sets like UTF-16.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::u16string` 用于 `char16_t`，适用于像 UTF-16 这样的字符集。'
- en: '`std::u32string` for `char32_t` is used for character sets like UTF-32.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::u32string` 用于 `char32_t`，适用于像 UTF-32 这样的字符集。'
- en: You’ll use the specialization with the appropriate underlying type. Because
    these specializations have the same interface, all the examples in this chapter
    will use `std::string`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用具有适当底层类型的特化形式。因为这些特化形式具有相同的接口，本章中的所有示例将使用 `std::string`。
- en: '***Constructing***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: 'The `basic_string` container takes three template parameters:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic_string` 容器接受三个模板参数：'
- en: The underlying character type, `T`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层字符类型，`T`
- en: The underlying type’s traits, `Traits`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层类型的特性，`Traits`
- en: An allocator, `Alloc`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器，`Alloc`
- en: Of these, only `T` is required. The STL’s `std::char_traits` template class
    in the `<string>` header abstracts character and string operations from the underlying
    character type. Also, unless you plan on supporting a custom character type, you
    won’t need to implement your own type traits, because `char_traits` has specializations
    available for `char, wchar_t`, `char16_t`, and `char32_t`. When the stdlib provides
    specializations for a type, you won’t need to provide it yourself unless you require
    some kind of exotic behavior.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些参数中，只有 `T` 是必需的。STL 中的 `std::char_traits` 模板类位于 `<string>` 头文件中，抽象了字符和字符串操作，隐藏了底层字符类型的细节。此外，除非你计划支持自定义字符类型，否则你不需要实现自己的类型特性，因为
    `char_traits` 已经为 `char`、`wchar_t`、`char16_t` 和 `char32_t` 提供了特化。如果标准库为某个类型提供了特化，除非你需要某种特殊行为，否则不必自己实现。
- en: 'Together, a `basic_string` specialization looks like this, where `T` is a character
    type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 合起来，一个 `basic_string` 特化形式看起来像这样，其中 `T` 是字符类型：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In most cases, you’ll be dealing with one of the predefined specializations,
    especially string or wstring. However, if you need a custom allocator, you’ll
    need to specialize basic_string appropriately.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*在大多数情况下，你将处理其中一个预定义的特化形式，尤其是 `string` 或 `wstring`。然而，如果你需要自定义分配器，你将需要适当地特化
    `basic_string`。*'
- en: The `basic_string<T>` container supports the same constructors as `vector<T>`,
    plus additional convenience constructors for converting a C-style string. In other
    words, a `string` supports the constructors of `vector<char>`, a `wstring` supports
    the constructors of `vector<wchar_t>`, and so on. As with `vector`, use parentheses
    for all `basic_string` constructors except when you actually want an initializer
    list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic_string<T>` 容器支持与 `vector<T>` 相同的构造函数，并提供额外的便利构造函数用于转换 C 风格字符串。换句话说，`string`
    支持 `vector<char>` 的构造函数，`wstring` 支持 `vector<wchar_t>` 的构造函数，依此类推。与 `vector` 一样，除了当你确实想要使用初始化列表时，所有
    `basic_string` 的构造函数都需要使用圆括号。'
- en: You can default construct an empty string, or if you want to fill a `string`
    with a repeating character, you can use the fill constructor by passing a `size_t`
    and a `char`, as [Listing 15-1](ch15.xhtml#ch15ex01) illustrates.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以默认构造一个空字符串，或者如果你想用重复的字符填充一个`string`，你可以使用填充构造函数，通过传递一个`size_t`和一个`char`，正如[清单15-1](ch15.xhtml#ch15ex01)所示。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 15-1: The default and fill constructors of `string`*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-1：`string`的默认构造函数和填充构造函数*'
- en: After you default construct a `string` ➊, it contains no elements ➋. If you
    want to fill the `string` with repeating characters, you can use the fill constructor
    by passing in the number of elements you want to fill and their value ➌. The example
    fills a string with three `A` characters ➍.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你默认构造一个`string` ➊之后，它不包含任何元素 ➋。如果你想用重复的字符填充`string`，你可以使用填充构造函数，通过传入你想要填充的元素个数及其值
    ➌。这个例子将一个字符串填充了三个`A`字符 ➍。
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll learn about std::string comparisons with operator== later in the chapter.
    Because you generally handle C-style strings with raw pointers or raw arrays,
    operator== returns true only when given the same object. However, for std::string,
    operator== returns true if the contents are equivalent. As you can see in [Listing
    15-1](ch15.xhtml#ch15ex01), the comparison works even when one of the operands
    is a C-style string literal.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*你将在本章稍后了解std::string的比较操作符==。因为你通常通过原始指针或原始数组来处理C风格字符串，所以操作符==只有在给定相同对象时才返回true。然而，对于std::string，操作符==如果内容相同则返回true。如[清单15-1](ch15.xhtml#ch15ex01)所示，即使其中一个操作数是C风格字符串字面量，比较也能正常工作。*'
- en: The `string` constructor also offers two `const char*`-based constructors. If
    the argument points to a null-terminated `string`, the `string` constructor can
    determine the input’s length on its own. If the pointer does *not* point to a
    null-terminated string or if you only want to use the first part of a `string`,
    you can pass a length argument that informs the `string` constructor of how many
    elements to copy, as [Listing 15-2](ch15.xhtml#ch15ex02) illustrates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`构造函数还提供了两个基于`const char*`的构造函数。如果传入的参数指向一个以null结尾的字符串，`string`构造函数可以自行确定输入的长度。如果指针*不*指向一个以null结尾的字符串，或者你只想使用`string`的前一部分，你可以传递一个长度参数，告诉`string`构造函数需要复制多少元素，正如[清单15-2](ch15.xhtml#ch15ex02)所示。'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 15-2: Constructing a `string` from C-style strings*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-2：从C风格字符串构造`string`*'
- en: You create a `const char*` called `word` pointing to the C-style string literal
    `gobbledygook` ➊. Next, you construct a `string` by passing `word`. As expected,
    the resulting `string` contains `gobbledygook` ➋. In the next test, you pass the
    number `6` as a second argument. This causes `string` to only take the first six
    characters of `word`, resulting in the `string` containing `gobble` ➌.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为`word`的`const char*`，指向C风格字符串字面量`gobbledygook` ➊。接着，你通过传入`word`来构造一个`string`。如预期的那样，结果的`string`包含`gobbledygook`
    ➋。在接下来的测试中，你传入数字`6`作为第二个参数。这导致`string`只取`word`的前六个字符，结果`string`包含`gobble` ➌。
- en: Additionally, you can construct `string`s from other `string`s. As an STL container,
    `string` fully supports copy and move semantics. You can also construct a `string`
    from a *substring*—a contiguous subset of another string. [Listing 15-3](ch15.xhtml#ch15ex03)
    illustrates these three constructors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以从其他`string`构造`string`。作为一个STL容器，`string`完全支持复制和移动语义。你还可以通过传入一个*子字符串*——另一个字符串的连续子集，来构造`string`。[清单15-3](ch15.xhtml#ch15ex03)展示了这三种构造方法。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 15-3: Copy, move, and substring construction of `string` objects*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-3：`string`对象的复制、移动和子字符串构造*'
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In [Listing 15-3](ch15.xhtml#ch15ex03), `word` is in a moved-from state, which,
    you’ll recall from “Move Semantics” on [page 122](ch04.xhtml#page_122), means
    it can only be reassigned or destructed.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[清单15-3](ch15.xhtml#ch15ex03)中，`word`处于一个已移动的状态，正如你从“移动语义”部分（见[第122页](ch04.xhtml#page_122)）所记得的那样，这意味着它只能被重新赋值或销毁。*'
- en: Here, you construct a `string` called `word` containing the characters `catawampus`
    ➊. Copy construction yields another `string` containing a copy of the characters
    of `word` ➋. Move construction steals the characters of `word`, resulting in a
    new `string` containing `catawampus` ➌. Finally, you can construct a new `string`
    based on substrings. By passing `word`, a starting position of 0, and a length
    of 3, you construct a new `string` containing the characters `cat` ➍. If you instead
    pass `word` and a starting position of 4 (without a length), you get all the characters
    from the fourth to the end of the original string, resulting in `wampus` ➎.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个名为 `word` 的 `string`，包含字符 `catawampus` ➊。复制构造产生了另一个 `string`，包含 `word`
    的字符副本 ➋。移动构造偷取了 `word` 的字符，结果是一个包含 `catawampus` 的新 `string` ➌。最后，你可以基于子字符串构造一个新的
    `string`。通过传递 `word`、起始位置为 0 和长度为 3，你构造了一个包含字符 `cat` 的新 `string` ➍。如果你改为传递 `word`
    和起始位置为 4（不指定长度），你会得到从第四个字符到原始字符串末尾的所有字符，结果为 `wampus` ➎。 |
- en: The `string` class also supports literal construction with `std::string_``literals::operator""s`.
    The major benefit is notational convenience, but you can also use `operator""s`
    to embed null characters within a `string` easily, as [Listing 15-4](ch15.xhtml#ch15ex04)
    illustrates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类还支持使用 `std::string_literals::operator""s` 进行字面量构造。其主要优点是符号简洁，但你也可以使用
    `operator""s` 在 `string` 中轻松嵌入 null 字符，正如 [示例 15-4](ch15.xhtml#ch15ex04) 所示。 |'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 15-4: Constructing a `string`*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-4：构造一个 `string`*'
- en: In the first test, you construct a `string` using the literal `idioglossia\0ellohay!`
    ➊, which results in a `string` containing `idioglossia` ➋, The remainder of the
    literal didn’t get copied into the `string` due to embedded nulls. In the second
    test, you bring in the `std::string_literals` namespace ➌ so you can use `operator""s`
    to construct a `string` from a literal directly ➍. Unlike the `std::string` constructor
    ➊, `operator""s` yields a string containing the entire literal—embedded null bytes
    and all ➎.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，你使用字面量 `idioglossia\0ellohay!` ➊ 构造了一个 `string`，该字符串包含 `idioglossia`
    ➋，由于嵌入了 null 字符，字面量的其余部分没有被复制到 `string` 中。在第二次测试中，你引入了 `std::string_literals`
    命名空间 ➌，这样就可以使用 `operator""s` 从字面量直接构造一个 `string` ➍。与 `std::string` 构造函数 ➊ 不同，`operator""s`
    返回一个包含整个字面量的字符串——包括嵌入的 null 字节 ➎。 |
- en: '[Table 15-1](ch15.xhtml#ch15tab01) summarizes the options for constructing
    a `string`. In this table, `c` is a `char, n` and `pos` are `size_t, str` is a
    `string` or a C-style string, `c_str` is a C-style string, and `beg` and `end`
    are input iterators.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-1](ch15.xhtml#ch15tab01) 总结了构造 `string` 的选项。在此表中，`c` 是 `char`，`n` 和 `pos`
    是 `size_t`，`str` 是 `string` 或 C 风格字符串，`c_str` 是 C 风格字符串，`beg` 和 `end` 是输入迭代器。
    |'
- en: '**Table 15-1:** Supported `std::string` Constructors'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：** 支持的 `std::string` 构造函数'
- en: '| **Constructor** | **Produces** a string **containing** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **构造函数** | 生成一个包含的字符串 |'
- en: '| `string()` | No characters. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `string()` | 没有字符。 |'
- en: '| `string(`n`,` c`)` | c repeated n times. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `string(`n`,` c`)` | c 重复 n 次。 |'
- en: '| `string(`str`,` pos`, [`n`])` | The half-open range pos to pos`+`n of str.
    Substring extends from pos to str’s end if n is omitted. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `string(`str`,` pos`, [`n`])` | str 中从 pos 到 pos+n 的半开区间。如果省略 n，子字符串将从 pos
    到 str 的末尾。 |'
- en: '| `string(`c_str`, [`n`])` | A copy of c_str, which has length n. If c_str
    is null terminated, n defaults to the null-terminated string’s length. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `string(`c_str`, [`n`])` | c_str 的副本，长度为 n。如果 c_str 是以 null 结尾的，n 默认设置为以
    null 结尾的字符串的长度。 |'
- en: '| `string(`beg`,` end`)` | A copy of the elements in the half-open range from
    beg to end. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `string(`beg`,` end`)` | beg 到 end 半开区间内元素的副本。 |'
- en: '| `string(`str`)` | A copy of str. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `string(`str`)` | str 的副本。 |'
- en: '| `string(move(`str`))` | The contents of str, which is in a moved-from state
    after construction. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `string(move(`str`))` | str 的内容，构造后处于已移动状态。 |'
- en: '| `string{` c1`,` c2`,` c3 `}` | The characters c1, c2, and c3. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `string{` c1`,` c2`,` c3 `}` | 字符 c1, c2 和 c3。 |'
- en: '| `"`my string literal`"s` | A string containing the characters `my string
    literal`. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `"`my string literal`"s` | 一个包含字符 `my string literal` 的字符串。 |'
- en: '***String Storage and Small String Optimizations***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串存储和小字符串优化***'
- en: Exactly like `vector, string` uses dynamic storage to store its constituent
    elements contiguously. Accordingly, `vector` and `string` have very similar copy/move-construction/assignment
    semantics. For example, copy operations are potentially more expensive than move
    operations because the contained elements reside in dynamic memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `vector` 完全一样，`string` 使用动态存储来连续存储其组成元素。因此，`vector` 和 `string` 在复制/移动构造/赋值语义上非常相似。例如，复制操作可能比移动操作更昂贵，因为包含的元素位于动态内存中。
    |
- en: The most popular STL implementations have *small string optimizations (SSO)*.
    The SSO places the contents of a `string` within the object’s storage (rather
    than dynamic storage) if the contents are small enough. As a general rule, a `string`
    with fewer than 24 bytes is an SSO candidate. Implementers make this optimization
    because in many modern programs, most `string`s are short. (A `vector` doesn’t
    have any small optimizations.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的 STL 实现具有 *小字符串优化（SSO）*。如果 `string` 的内容足够小，SSO 会将其内容存储在对象的存储区内（而不是动态存储）。一般而言，少于
    24 字节的 `string` 是 SSO 的候选者。实现者之所以做出此优化，是因为在许多现代程序中，大多数 `string` 都是短的。（`vector`
    没有任何小优化。）
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Practically, SSO affects moves in two ways. First, any references to the elements
    of a `string` will invalidate if the `string` moves. Second, moves are potentially
    slower for `string`s than `vector`s because `string`s need to check for SSO.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，SSO 以两种方式影响移动操作。首先，如果 `string` 移动，任何对 `string` 元素的引用都会失效。其次，`string` 的移动操作可能比
    `vector` 慢，因为 `string` 需要检查 SSO。*'
- en: A `string` has a *size* (or *length*) and a *capacity*. The size is the number
    of characters contained in the `string`, and the capacity is the number of characters
    that the string can hold before needing to resize.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `string` 有一个 *大小*（或 *长度*）和一个 *容量*。大小是 `string` 中包含的字符数，而容量是 `string` 在需要调整大小之前能够容纳的字符数。
- en: '[Table 15-2](ch15.xhtml#ch15tab02) contains methods for reading and manipulating
    the size and capacity of a `string`. In this table, `n` is a `size_t`. An asterisk
    (*) indicates that this operation invalidates raw pointers and iterators to the
    elements of `s` in at least some circumstances.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-2](ch15.xhtml#ch15tab02) 包含读取和操作 `string` 的大小和容量的方法。在此表中，`n` 是 `size_t`
    类型。星号 (*) 表示在某些情况下，这个操作会使指向 `s` 元素的原始指针和迭代器无效。'
- en: '**Table 15-2:** Supported `std::string` Storage and Length Methods'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-2：** 支持的 `std::string` 存储和长度方法'
- en: '| **Method** | **Returns** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **返回值** |'
- en: '| s`.empty()` | `true` if s contains no characters; otherwise `false`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| s`.empty()` | 如果 s 不包含任何字符，则返回 `true`；否则返回 `false`。 |'
- en: '| s`.size()` | The number of characters in s. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| s`.size()` | s 中字符的数量。 |'
- en: '| s`.length()` | Identical to s`.size()` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| s`.length()` | 与 s`.size()` 相同 |'
- en: '| s`.max_size()` | The maximum possible size of s (due to system/runtime limitations).
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| s`.max_size()` | s 的最大可能大小（由于系统/运行时的限制）。 |'
- en: '| s`.capacity()` | The number of characters s can hold before needing to resize.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| s`.capacity()` | 在需要调整大小之前，s 能够容纳的字符数量。 |'
- en: '| s`.shrink_to_fit()` | `void`; issues a non-binding request to reduce s`.capacity()`
    to s`.size()`.* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| s`.shrink_to_fit()` | `void`；发出一个非绑定请求，将 s`.capacity()` 缩减到 s`.size()`。*'
- en: '| s`.reserve([`n`])` | `void`; if `n >` s`.capacity()`, resizes so s can hold
    at least n elements; otherwise, issues a non-binding request* to reduce s`.capacity()`
    to n or s`.size()`, whichever is greater. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| s`.reserve([`n`])` | `void`；如果 `n >` s`.capacity()`，则调整大小以便 s 至少能容纳 n 个元素；否则，发出非绑定请求*，将
    s`.capacity()` 缩减到 n 或 s`.size()`，取两者中的较大值。 |'
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At press time, the draft C++20 standard changes the behavior of the `reserve`
    method when its argument is less than the size of the `string`. This will match
    the behavior of `vector`, where there is no effect rather than being equivalent
    to invoking `shrink_to_fit`.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至新闻发布时，草案 C++20 标准更改了当 `reserve` 方法的参数小于 `string` 的大小时的行为。这将与 `vector` 的行为相匹配，在这种情况下没有效果，而是等同于调用
    `shrink_to_fit`。*'
- en: Note that the size and capacity methods of `string` match those of `vector`
    very closely. This is a direct result of the closeness of their storage models.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`string` 的大小和容量方法与 `vector` 非常相似。这是由于它们存储模型的紧密性所致。
- en: '***Element and Iterator Access***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***元素和迭代器访问***'
- en: Because `string` offers random-access iterators to contiguous elements, it accordingly
    exposes similar element- and iterator-access methods to `vector`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `string` 提供对连续元素的随机访问迭代器，所以它相应地暴露了与 `vector` 类似的元素和迭代器访问方法。
- en: For interoperation with C-style APIs, `string` also exposes a `c_str` method,
    which returns a non-modifiable, null-terminated version of the string as a `const
    char*`, as [Listing 15-5](ch15.xhtml#ch15ex05) illustrates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 C 风格的 API 进行互操作，`string` 还暴露了一个 `c_str` 方法，该方法返回一个不可修改的、以 null 结尾的字符串版本，作为
    `const char*`，正如 [清单 15-5](ch15.xhtml#ch15ex05) 所示。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 15-5: Extracting a null-terminated string from a `string`*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-5：从 `string` 中提取一个 null 终止的字符串*'
- en: You construct a `string` called `word` containing the characters `horripilation`
    ➊ and use its `c_str` method to extract a null-terminated string called `as_cstr`
    ➋. Because `as_cstr` is a `const char*`, you can use `operator[]` to illustrate
    that it contains the same characters as `word` ➌ and that it is null terminated
    ➍.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个包含字符 `horripilation` ➊ 的 `string`，并使用其 `c_str` 方法提取一个名为 `as_cstr` 的 null
    终止字符串 ➋。由于 `as_cstr` 是一个 `const char*`，你可以使用 `operator[]` 来说明它包含与 `word` 相同的字符
    ➌，并且它是 null 终止的 ➍。
- en: '**NOTE**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `std::string` class also supports `operator[]`, which has the same behavior
    as with a C-style string.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*`std::string` 类还支持 `operator[]`，其行为与 C 风格字符串相同。*'
- en: Generally, `c_str` and `data` produce identical results except that references
    returned by `data` can be non-`const`. Whenever you manipulate a `string`, implementations
    usually ensure that the contiguous memory backing the `string` ends with a null
    terminator. The program in [Listing 15-6](ch15.xhtml#ch15ex06) illustrates this
    behavior by printing the results of calling `data` and `c_str` alongside their
    addresses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`c_str` 和 `data` 返回相同的结果，唯一的区别是 `data` 返回的引用可以是非 `const` 的。每当你操作一个 `string`
    时，实施通常会确保支持 `string` 的连续内存以 null 终止符结束。[列表 15-6](ch15.xhtml#ch15ex06) 中的程序通过打印调用
    `data` 和 `c_str` 及其地址的结果来展示这种行为。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 15-6: Illustrating that `c_str` and `data` return equivalent addresses*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-6：说明 `c_str` 和 `data` 返回等效地址*'
- en: Both `c_str` and `data` produce identical results because they point to the
    same addresses ➊ ➋. Because the address is the beginning of a null-terminated
    `string, printf` yields identical output for both invocations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`c_str` 和 `data` 返回相同的结果，因为它们指向相同的地址 ➊ ➋。由于该地址是一个 null 终止的 `string` 的起始位置，`printf`
    对两次调用的输出结果相同。'
- en: '[Table 15-3](ch15.xhtml#ch15tab03) lists the access methods of `string`. Note
    that `n` is a `size_t` in the table.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-3](ch15.xhtml#ch15tab03) 列出了 `string` 的访问方法。注意，表中的 `n` 是 `size_t` 类型。'
- en: '**Table 15-3:** Supported `std::string` Element and Iterator Access Methods'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-3：** 支持的 `std::string` 元素和迭代器访问方法'
- en: '| **Method** | **Returns** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **返回值** |'
- en: '| s`.begin()` | An iterator pointing to the first element. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| s`.begin()` | 一个指向第一个元素的迭代器。 |'
- en: '| s`.cbegin()` | A `const` iterator pointing to the first element. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| s`.cbegin()` | 一个指向第一个元素的 `const` 迭代器。 |'
- en: '| s`.end()` | An iterator pointing to one past the last element. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| s`.end()` | 一个指向超出最后一个元素位置的迭代器。 |'
- en: '| s`.cend()` | A `const` iterator pointing to one past the last element. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| s`.cend()` | 一个指向超出最后一个元素位置的 `const` 迭代器。 |'
- en: '| s`.at(`n`)` | A reference to element n of s. Throws `std::out_of_range` if
    out of bounds. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| s`.at(`n`)` | 引用 s 中的第 n 个元素。如果越界，抛出 `std::out_of_range`。 |'
- en: '| s`[`n`]` | A reference to element n of s. Undefined behavior if n `>` s`.size()`.
    Also s`[`s`.size()]` must be 0, so writing a non-zero value into this character
    is undefined behavior. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| s`[`n`]` | 引用 s 中的第 n 个元素。如果 n `>` s`.size()`，则行为未定义。此外，s`[`s`.size()]` 必须为
    0，因此写入一个非零值到该字符是未定义行为。 |'
- en: '| s`.front()` | A reference to first element. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| s`.front()` | 引用第一个元素。 |'
- en: '| s`.back()` | A reference to last element. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| s`.back()` | 引用最后一个元素。 |'
- en: '| s`.data()` | A raw pointer to the first element if string is non-empty. For
    an empty string, returns a pointer to a null character. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| s`.data()` | 如果字符串非空，返回指向第一个元素的原始指针。如果字符串为空，返回指向一个 null 字符的指针。 |'
- en: '| s`.c_str()` | Returns a non-modifiable, null-terminated version of the contents
    of s. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| s`.c_str()` | 返回一个不可修改的、以 null 终止的 s 内容版本。 |'
- en: '***String Comparisons***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串比较***'
- en: Note that `string` supports comparisons with other strings and with raw C-style
    strings using the usual comparison operators. For example, the equality `operator==`
    returns `true` if the size and contents of the left and right size are equal,
    whereas the inequality `operator!=` returns the opposite. The remaining comparison
    operators perform *lexicographical comparison*, meaning they sort alphabetically
    where *A* < *Z* < *a* < *z* and where, if all else is equal, shorter words are
    less than longer words (for example, *pal* < *palindrome*). [Listing 15-7](ch15.xhtml#ch15ex07)
    illustrates comparisons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`string` 支持与其他字符串以及原始 C 风格字符串的比较，使用常见的比较操作符。例如，等号 `operator==` 如果左右两侧的大小和内容相同，则返回
    `true`，而不等号 `operator!=` 返回相反的结果。其余比较操作符执行 *字典顺序比较*，即按字母顺序排列，其中 *A* < *Z* < *a*
    < *z*，并且在其他条件相同的情况下，较短的单词小于较长的单词（例如，*pal* < *palindrome*）。[列表 15-7](ch15.xhtml#ch15ex07)
    展示了比较的例子。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, lexicographical comparison depends on the encoding of the `string`.
    It’s theoretically possible that a system could use a default encoding where the
    alphabet is in some completely jumbled order (such as the nearly obsolete EBCDIC
    encoding, which put lowercase letters before uppercase letters), which would affect
    `string` comparison. For ASCII-compatible encodings, you don’t need to worry since
    they imply the expected lexicographical behavior.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，字典顺序比较依赖于 `string` 的编码。理论上，可能存在一个系统使用默认编码，其中字母表的顺序完全混乱（例如，几乎被淘汰的 EBCDIC
    编码，它将小写字母排在大写字母之前），这将影响 `string` 比较。对于与 ASCII 兼容的编码，你不需要担心，因为它们默认具有预期的字典顺序行为。*'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 15-7: The `string` class supports comparison*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-7：`string` 类支持比较*'
- en: Here, you bring in the `std::literals::string_literals` namespace so you can
    easily construct a `string` with `operator""s` ➊. You also construct a `string`
    called `word` containing the characters `allusion` ➋. In the first set of tests,
    you examine `operator==` and `operator!=`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你引入了 `std::literals::string_literals` 命名空间，以便可以轻松地使用 `operator""s` 来构造一个
    `string` ➊。你还构造了一个名为 `word` 的 `string`，其中包含字符 `allusion` ➋。在第一组测试中，你检查了 `operator==`
    和 `operator!=`。
- en: You can see that `word` equals (`==`) `allusion` as both a C-style string ➌
    and a `string` ➍, but it doesn’t equal (`!=`) `string`s containing `Allusion`
    ➎ or `illusion` ➏. As usual, `operator==` and `operator!=` always return opposite
    results ➐.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`word` 等于（`==`）`allusion`，无论是作为 C 风格字符串 ➌ 还是作为 `string` ➍，但是它不等于（`!=`）包含
    `Allusion` ➎ 或 `illusion` ➏ 的 `string`。像往常一样，`operator==` 和 `operator!=` 总是返回相反的结果
    ➐。
- en: The next set of tests uses `operator<` to show that `allusion` is less than
    `illu``sion` ➑, because *a* is lexicographically less than *i*. Comparisons work
    with C-style strings and `string`s ➒. [Listing 15-7](ch15.xhtml#ch15ex07) also
    shows that `Allusion` is less than `allusion` ➓ because *A* is lexicographically
    less than *a*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组测试使用 `operator<` 来显示 `allusion` 小于 `illusion` ➑，因为 *a* 在字典顺序上小于 *i*。比较操作适用于
    C 风格字符串和 `string` ➒。[示例 15-7](ch15.xhtml#ch15ex07) 还显示了 `Allusion` 小于 `allusion`
    ➓，因为 *A* 在字典顺序上小于 *a*。
- en: '[Table 15-4](ch15.xhtml#ch15tab04) lists the comparison methods of `string`.
    Note that `other` is a `string` or `char*` C-style string in the table.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-4](ch15.xhtml#ch15tab04) 列出了 `string` 的比较方法。请注意，表中的 `other` 是一个 `string`
    或 `char*` C 风格的字符串。'
- en: '**Table 15-4:** Supported `std::string` Comparison Operators'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-4：** 支持的 `std::string` 比较运算符'
- en: '| **Method** | **Returns** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **返回值** |'
- en: '| s `==` other | `true` if s and other have identical characters and lengths;
    otherwise `false` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| s `==` other | 如果 s 和 other 具有相同的字符和长度，则返回 `true`；否则返回 `false` |'
- en: '| s `!=` other | The opposite of `operator==` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| s `!=` other | `operator==` 的相反操作 |'
- en: '| s`.compare(`other`)` | Returns 0 if s `==` other, a negative number if s
    `<` other, and a positive number if s `>` other |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| s`.compare(`other`)` | 如果 s `==` other，则返回 0；如果 s `<` other，则返回负数；如果 s `>`
    other，则返回正数 |'
- en: '| s `<` others `>` others `<=` others `>=` other | The result of the corresponding
    comparison operation, according to lexicographical sort |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| s `<` other `>` other `<=` other `>=` other | 根据字典顺序排序的相应比较操作结果 |'
- en: '***Manipulating Elements***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作元素***'
- en: For manipulating elements, `string` has *a lot* of methods. It supports all
    the methods of `vector<char>` plus many others useful to manipulating human-language
    data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元素操作，`string` 提供了 *许多* 方法。它支持 `vector<char>` 的所有方法，并且还有许多其他有助于处理人类语言数据的方法。
- en: '**Adding Elements**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加元素**'
- en: To add elements to a `string`, you can use `push_back`, which inserts a single
    character at the end. When you want to insert more than one character to the end
    of a `string`, you can use `operator+=` to append a character, a null-terminated
    `char*` string, or a `string`. You can also use the `append` method, which has
    three overloads. First, you can pass a `string` or a null-terminated `char*` string,
    an optional offset into that `string`, and an optional number of characters to
    append. Second, you can pass a length and a `char`, which will append that number
    of `char`s to the string. Third, you can append a half-open range. [Listing 15-8](ch15.xhtml#ch15ex08)
    illustrates all of these operations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 `string` 中添加元素，可以使用 `push_back`，它会将一个字符插入到字符串末尾。当你想向 `string` 的末尾插入多个字符时，可以使用
    `operator+=` 来追加一个字符、一个以 null 结尾的 `char*` 字符串，或一个 `string`。你也可以使用 `append` 方法，该方法有三种重载形式。首先，你可以传递一个
    `string` 或一个以 null 结尾的 `char*` 字符串，以及一个可选的偏移量和一个可选的字符数来追加。其次，你可以传递一个长度和一个 `char`，它将把指定数量的
    `char` 追加到字符串末尾。第三，你可以追加一个半开区间。[示例 15-8](ch15.xhtml#ch15ex08) 展示了所有这些操作。
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 15-8: Appending to a `string`*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-8：追加到 `string`*'
- en: To begin, you initialize a `string` called `word` containing the characters
    `butt` ➊. In the first test, you invoke `push_back` with the letter `e` ➋, which
    yields `butte`. Next, you add `erfinger` to `word` using `operator+=` ➌, yielding
    `butterfinger`. In the first invocation of `append`, you append a single `s` ➍
    to yield `butts`. (This setup works just like `push_back`.) A second overload
    of `append` allows you to provide a `char*` and a length. By providing `stockings`
    and length `5`, you add `stock` to `word` to yield `buttstock` ➎. Because `append`
    works with half-open ranges, you can also construct a `string` called `other`
    containing the characters `onomatopoeia` ➏ and append the first two characters
    via a half-open range to yield `button` ➐.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个名为`word`的`string`，包含字符`butt` ➊。在第一个测试中，你调用`push_back`并添加字母`e` ➋，结果是`butte`。接下来，你使用`operator+=`将`erfinger`添加到`word`中
    ➌，结果是`butterfinger`。在第一次调用`append`时，你追加一个单独的`s` ➍，得到`butts`。（这个操作和`push_back`一样。）`append`的第二个重载允许你提供一个`char*`和一个长度。通过提供`stockings`和长度`5`，你将`stock`添加到`word`中，得到`buttstock`
    ➎。由于`append`支持半开区间，你还可以构造一个名为`other`的`string`，包含字符`onomatopoeia` ➏，并通过半开区间将前两个字符追加到`word`中，得到`button`
    ➐。
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall from “Test Cases and Sections” on [page 308](ch10.xhtml#page_308) that
    each `SECTION` of a Catch unit test runs independently, so modifications to `word`
    are independent of each other: the setup code resets `word` for each test.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*回顾“测试用例和章节”中的[第308页](ch10.xhtml#page_308)，每个Catch单元测试的`SECTION`是独立运行的，因此对`word`的修改彼此独立：每个测试的设置代码都会重置`word`。*'
- en: '**Removing Elements**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除元素**'
- en: To remove elements from a `string`, you have several options. The simplest method
    is to use `pop_back`, which follows `vector` in removing the last character from
    a `string`. If you want to instead remove all the characters (to yield an empty
    `string`), use the `clear` method. When you need more precision in removing elements,
    use the `erase` method, which provides several overloads. You can provide an index
    and a length, which removes the corresponding characters. You can also provide
    an iterator to remove a single element or a half-open range to remove many. [Listing
    15-9](ch15.xhtml#ch15ex09) illustrates removing elements from a `string`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`string`中删除元素，你有几种选择。最简单的方法是使用`pop_back`，它和`vector`一样，删除`string`中的最后一个字符。如果你想删除所有字符（从而得到一个空的`string`），可以使用`clear`方法。当你需要更精确地删除元素时，可以使用`erase`方法，它提供了多种重载方式。你可以提供一个索引和长度，删除相应的字符。你也可以提供一个迭代器来删除单个元素，或者提供一个半开区间来删除多个元素。[列表
    15-9](ch15.xhtml#ch15ex09)展示了如何从`string`中删除元素。
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 15-9: Removing elements from a `string`*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-9：从`string`中删除元素*'
- en: You construct a `string` called `word` containing the characters `therein` ➊.
    In the first test, you call `pop_back` twice to first remove the letter `n` followed
    by the letter `i` so `word` contains the characters `there` ➋. Next, you invoke
    `clear`, which removes all the characters from `word` so it’s `empty` ➌. The last
    two tests use `erase` to remove some subset of the characters in `word`. In the
    first usage, you remove the first three characters with a half-open range so `word`
    contains `rein` ➍. In the second, you remove the characters starting at index
    5 (`i` in `therein`) and extending two characters ➎. Like the first test, this
    yields the characters `there`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个名为`word`的`string`，包含字符`therein` ➊。在第一个测试中，你调用`pop_back`两次，首先删除字母`n`，然后删除字母`i`，因此`word`包含字符`there`
    ➋。接下来，你调用`clear`，这将删除`word`中的所有字符，使其变为空`string` ➌。最后两个测试使用`erase`删除`word`中某些字符的子集。在第一次使用中，你使用半开区间删除前三个字符，因此`word`包含`rein`
    ➍。在第二次使用中，你删除从索引5（即`therein`中的`i`）开始，长度为两个字符的部分 ➎。像第一个测试一样，这将得到字符`there`。
- en: '**Replacing Elements**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**替换元素**'
- en: To insert and remove elements simultaneously, use `string` to expose the `replace`
    method, which has many overloads.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时插入和删除元素，可以使用`string`来调用`replace`方法，它有多个重载版本。
- en: First, you can provide a half-open range and a null-terminated `char*` or a
    `string`, and `replace` will perform a simultaneous `erase` of all the elements
    within the half-open range and an `insert` of the provided `string` where the
    range used to be. Second, you can provide two half-open ranges, and `replace`
    will insert the second range instead of a `string`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以提供一个半开区间和一个以空字符结尾的`char*`或`string`，然后`replace`将同时执行对半开区间内所有元素的`erase`操作，并在原区间位置插入提供的`string`。其次，你可以提供两个半开区间，`replace`将插入第二个区间，而不是`string`。
- en: Instead of replacing a range, you can use either an index or a single iterator
    and a length. You can supply a new half-open range, a character and a size, or
    a `string`, and `replace` will substitute new elements over the implied range.
    [Listing 15-10](ch15.xhtml#ch15ex10) demonstrates some of these possibilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 替代替换一个范围，你可以使用索引或单一的迭代器和长度。你可以提供一个新的半开范围、一个字符和大小，或一个 `string`，`replace` 将在隐式范围内替换新元素。[示例
    15-10](ch15.xhtml#ch15ex10) 演示了这些可能性中的一些。
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 15-10: Replacing elements of a `string`*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-10：替换 `string` 的元素*'
- en: Here, you construct a `string` called `word` containing `substitution` ➊. In
    the first test, you replace all the characters from index 9 to the end with the
    letter `e`, resulting in the word `substitute` ➋. Next, you replace the first
    three letters of `word` with the first two letters of a `string` containing `innuendo`
    ➌, resulting in `institution`. Finally, you use an alternate way of specifying
    the target sequence with an index and a length to replace the characters `stitut`
    with the characters `vers`, yielding `subversion` ➍.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个名为 `word` 的 `string`，其内容为 `substitution` ➊。在第一次测试中，你将从索引 9 到末尾的所有字符替换为字母
    `e`，得到单词 `substitute` ➋。接下来，你将 `word` 的前三个字母替换为一个包含 `innuendo` 的 `string` 的前两个字母
    ➌，得到 `institution`。最后，你使用另一种通过索引和长度来指定目标序列的方式，将字符 `stitut` 替换为字符 `vers`，得到 `subversion`
    ➍。
- en: 'The `string` class offers a `resize` method to manually set the length of `string`.
    The `resize` method takes two arguments: a new length and an optional `char`.
    If the new length of `string` is smaller, `resize` ignores the `char`. If the
    new length of `string` is larger, `resize` appends the `char` the implied number
    of times to achieve the desired length. [Listing 15-11](ch15.xhtml#ch15ex11) illustrates
    the `resize` method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类提供了一个 `resize` 方法，用于手动设置 `string` 的长度。`resize` 方法接受两个参数：新的长度和一个可选的
    `char`。如果新的 `string` 长度较小，`resize` 会忽略 `char`。如果新的 `string` 长度较大，`resize` 会按所需次数附加
    `char` 以达到期望的长度。[示例 15-11](ch15.xhtml#ch15ex11) 展示了 `resize` 方法的使用。'
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 15-11: Resizing a `string`*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-11：调整 `string` 大小*'
- en: You construct a `string` called `word` containing the characters `shamp` ➊.
    In the first test, you resize `word` to length `4` so it contains `sham` ➋. In
    the second, you `resize` to a length of 7 and provide the optional character `o`
    as the value to extend `word` with ➌. This results in `word` containing `shampoo`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个名为 `word` 的 `string`，其内容为字符 `shamp` ➊。在第一次测试中，你将 `word` 调整为长度 `4`，使其包含
    `sham` ➋。在第二次测试中，你将 `resize` 为长度 7，并提供可选字符 `o` 作为扩展 `word` 的值 ➌。这导致 `word` 包含
    `shampoo`。
- en: 'The “Constructing” section on [page 482](ch15.xhtml#page_482) explained a substring
    constructor that can extract contiguous sequences of characters to create a new
    `s``tring`. You can also generate substrings using the `substr` method, which
    takes two optional arguments: a position argument and a length. The position defaults
    to 0 (the beginning of the `string`), and the length defaults to the remainder
    of the `string`. [Listing 15-12](ch15.xhtml#ch15ex12) illustrates how to use `substr`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 482 页](ch15.xhtml#page_482) 的“构造”部分，解释了一个可以提取连续字符序列并创建新 `string` 的子字符串构造函数。你还可以使用
    `substr` 方法生成子字符串，该方法接受两个可选参数：一个位置参数和一个长度。位置默认值为 0（`string` 的开始），长度默认值为 `string`
    的其余部分。[示例 15-12](ch15.xhtml#ch15ex12) 演示了如何使用 `substr`。
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 15-12: Extracting substrings from a `string`*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-12：从 `string` 中提取子字符串*'
- en: You declare a `string` called `word` containing `hobbits` ➊. If you invoke `sub``str`
    with no arguments, you simply copy the `string` ➋. When you provide the position
    argument `3, substr` extracts the substring beginning at element 3 and extending
    to the end of the `string`, yielding `bits` ➌. Finally, when you provide a position
    (3) and a length (3), you instead get `bit` ➍.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个名为 `word` 的 `string`，其内容为 `hobbits` ➊。如果你调用不带参数的 `sub``str`，你只是简单地复制了
    `string` ➋。当你提供位置参数 `3` 时，`substr` 提取从第 3 个元素开始直到 `string` 末尾的子字符串，结果为 `bits`
    ➌。最后，当你提供位置（3）和长度（3）时，你将得到 `bit` ➍。
- en: '**Summary of string Manipulation Methods**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串操作方法总结**'
- en: '[Table 15-5](ch15.xhtml#ch15tab05) lists many of the insertion and deletion
    methods of `string`. In this table, `str` is a string or a C-style `char*` string,
    `p` and `n` are `size_t, ind` is a `size_t` index or an iterator into `s, n` and
    `i` are a `size_t, c` is a `char`, and `beg` and `end` are iterators. An asterisk
    (*) indicates that this operation invalidates raw pointers and iterators to `v`’s
    elements in at least some circumstances.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-5](ch15.xhtml#ch15tab05) 列出了 `string` 的许多插入和删除方法。在此表中，`str` 是一个字符串或 C
    风格的 `char*` 字符串，`p` 和 `n` 是 `size_t` 类型，ind 是 `size_t` 索引或指向 s 的迭代器，n 和 i 是 `size_t`
    类型，c 是 `char`，beg 和 end 是迭代器。星号 (*) 表示此操作在某些情况下会使原始指针和迭代器失效，无法访问 `v` 的元素。 |'
- en: '**Table 15-5:** Supported `std::string` Element Manipulation Methods'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-5：** 支持的 `std::string` 元素操作方法 |'
- en: '| **Method** | **Description** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| s`.insert(`ind`,` str`, [`p`], [`n`])` | Inserts the n elements of str, starting
    at p, into s just before ind. If no n supplied, inserts the entire `string` or
    up to the first null of a `char*`; p defaults to 0.* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| s`.insert(`ind`,` str`, [`p`], [`n`])` | 将从 p 开始的 str 的 n 个元素插入到 s 中，插入位置在
    ind 之前。如果没有提供 n，则插入整个 `string` 或直到 `char*` 的第一个空字符；p 默认为 0。* |'
- en: '| s`.insert(`ind`,` n`,` c`)` | Inserts n copies of c just before ind.* |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| s`.insert(`ind`,` n`,` c`)` | 在 ind 之前插入 n 个 c 的副本。* |'
- en: '| s`.insert(`ind`,` beg`,` end`)` | Inserts the half-open range from beg to
    end just before ind. * |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| s`.insert(`ind`,` beg`,` end`)` | 将从 beg 到 end 的半开区间插入到 ind 之前。* |'
- en: '| s`.append(`str`, [`p`], [`n`])` | Equivalent to s`.insert(`s`.end(),` str`,
    [`p`], [`n`])`.* |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| s`.append(`str`, [`p`], [`n`])` | 等同于 s`.insert(`s`.end(),` str`, [`p`],
    [`n`])`。* |'
- en: '| s`.append(`n`,` c`)` | Equivalent to s`.insert(`s`.end(),` n`,` c`)`.* |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| s`.append(`n`,` c`)` | 等同于 s`.insert(`s`.end(),` n`,` c`)`。* |'
- en: '| s`.append(`beg`,` end`)` | Appends the half-open range from beg to end to
    the end of s.* |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| s`.append(`beg`,` end`)` | 将从 beg 到 end 的半开区间追加到 s 的末尾。* |'
- en: '| s `+=` c s `+=` str | Appends c or str to the end of s.* |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| s `+=` c s `+=` str | 将 c 或 str 追加到 s 的末尾。* |'
- en: '| s`.push_back(`c`)` | Appends c to the end of s.* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| s`.push_back(`c`)` | 将 c 添加到 s 的末尾。* |'
- en: '| s`.clear()` | Removes all characters from s.* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| s`.clear()` | 移除 s 中的所有字符。* |'
- en: '| s`.erase([`i`], [`n`])` | Removes n characters starting at position i; i
    defaults to 0, and n defaults to the remainder of s.* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase([`i`], [`n`])` | 从位置 i 开始移除 n 个字符；i 默认为 0，n 默认为 s 的剩余字符。* |'
- en: '| s`.erase(`itr`)` | Erases the element pointed to by itr.* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase(`itr`)` | 删除由 itr 指向的元素。* |'
- en: '| s`.erase(`beg`,` end`)` | Erases the elements on the half-open range from
    beg to end.* |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase(`beg`,` end`)` | 删除从 beg 到 end 的半开区间中的元素。* |'
- en: '| s`.pop_back()` | Removes the last element of s.* |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| s`.pop_back()` | 移除 s 的最后一个元素。* |'
- en: '|  s`.resize(`n`,``[`c`])`  | Resizes the string so it contains n characters.
    If this operation increases the string’s length, it adds copies of c, which defaults
    to 0.* |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| s`.resize(`n`,``[`c`])`  | 调整字符串大小，使其包含 n 个字符。如果此操作增加了字符串的长度，则会添加 c 的副本，默认为
    0。* |'
- en: '| s`.replace(`i`,` n1`,` str`,` `[`p`], [`n2`])` | Replaces the n1 characters
    starting at index i with the n2 elements in str starting at p. By default, p is
    0 and n2 is str`.length()`.* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`i`,` n1`,` str`,` `[`p`], [`n2`])` | 从索引 i 开始用 str 中从 p 开始的 n2
    个元素替换 n1 个字符。默认情况下，p 为 0，n2 为 str`.length()`。* |'
- en: '| s`.replace(`beg`,` end`,` str`)` | Replaces the half-open range beg to end
    with str.* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`beg`,` end`,` str`)` | 用 str 替换半开区间 beg 到 end 的元素。* |'
- en: '| s`.replace(`p`,` n`,` str`)` | Replaces from index p to p+n with str.* |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`p`,` n`,` str`)` | 用 str 从索引 p 开始到 p+n 位置替换元素。* |'
- en: '| s`.replace(`beg1`,` end1`,` beg2`,` end2`)` | Replaces the half-open range
    beg1 to end1 with the half-open range beg2 to end2.* |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`beg1`,` end1`,` beg2`,` end2`)` | 用从 beg2 到 end2 的半开区间替换从 beg1
    到 end1 的半开区间。* |'
- en: '| s`.replace(`ind`,` c`, [`n`])` | Replaces n elements starting at ind with
    cs.* |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`ind`,` c`, [`n`])` | 用 cs 从 ind 开始替换 n 个元素。* |'
- en: '| s`.replace(`ind`,` beg`,` end`)` | Replaces elements starting at ind with
    the half-open range beg to end.* |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| s`.replace(`ind`,` beg`,` end`)` | 用半开区间 beg 到 end 替换从 ind 开始的元素。* |'
- en: '| s`.substr([`p`], [`c`])` | Returns the substring starting at p with length
    c. By default, p is 0 and c is the remainder of the string. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| s`.substr([`p`], [`c`])` | 返回从 p 开始，长度为 c 的子字符串。默认情况下，p 为 0，c 为字符串的剩余部分。
    |'
- en: '| s1`.swap(`s2`)` `swap(`s1`,` s2`)` | Exchanges the contents of s1 and s2.*
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| s1`.swap(`s2`)` `swap(`s1`,` s2`)` | 交换 s1 和 s2 的内容。* |'
- en: '***Search***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索*** |'
- en: In addition to the preceding methods, `string` offers several *search methods*,
    which enable you to locate substrings and characters that you’re interested in.
    Each method performs a particular kind of search, so which you choose depends
    on the particulars of the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述方法，`string` 还提供了几个 *搜索方法*，它们可以帮助你找到感兴趣的子字符串和字符。每个方法执行特定类型的搜索，选择哪个方法取决于应用的具体需求。
- en: '**find**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**find**'
- en: The first method `string` offers is `find`, which accepts a `string`, a C-style
    `string`, or a `char` as its first argument. This argument is an element that
    you want to locate within `this`. Optionally, you can provide a second `size_t`
    position argument that tells `find` where to start looking. If `find` fails to
    locate the substring, it returns the special `size_t`-valued, constant, `static`
    member `std::string::npos`. [Listing 15-13](ch15.xhtml#ch15ex13) illustrates the
    `find` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 提供的第一个方法是 `find`，它的第一个参数可以是 `string`、C 风格的 `string` 或 `char`。这个参数是你希望在
    `this` 中定位的元素。你还可以选择性地提供第二个 `size_t` 类型的位置参数，告诉 `find` 从哪里开始查找。如果 `find` 未能找到子字符串，它将返回一个特殊的
    `size_t` 值，即常量 `static` 成员 `std::string::npos`。[示例 15-13](ch15.xhtml#ch15ex13)
    演示了 `find` 方法。'
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 15-13: Finding substrings within a `string`*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-13：在 `string` 中查找子字符串*'
- en: Here, you construct the `string` called `word` containing `pizzazz` ➊. In the
    first test, you invoke `find` with a `string` containing `zz`, which returns `2`
    ➋, the index of the first *z* in `pi``z``zazz`. When you provide a position argument
    of `3` corresponding to the second *z* in `piz``z``azz, find` locates the second
    *zz* beginning at `5` ➌. In the third test, you use the C-style string `zaz`,
    and `find` returns 3, again corresponding to the second *z* in `piz``z``azz` ➍.
    Finally, you attempt to find the character *x*, which doesn’t appear in `pizzazz`,
    so `find` returns `std::string::npos` ➎.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你构建了一个名为 `word` 的 `string`，其内容为 `pizzazz` ➊。在第一次测试中，你调用 `find`，并传入包含 `zz`
    的 `string`，返回 `2` ➋，即 `pi``z``zazz` 中第一个 *z* 的索引。当你提供位置参数 `3`，即 `piz``z``azz`
    中第二个 *z* 时，`find` 定位到第二个 *zz*，其起始位置为 `5` ➌。第三次测试中，你使用 C 风格的字符串 `zaz`，`find` 返回
    3，再次对应 `piz``z``azz` 中的第二个 *z* ➍。最后，你尝试查找字符 *x*，但 `pizzazz` 中没有该字符，所以 `find` 返回
    `std::string::npos` ➎。
- en: '**rfind**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**rfind**'
- en: The `rfind` method is an alternative to `find` that takes the same arguments
    but searches *in reverse*. You might want to use this functionality if, for example,
    you were looking for particular punctuation at the end of a `string`, as [Listing
    15-14](ch15.xhtml#ch15ex14) illustrates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`rfind` 方法是 `find` 的一种替代方法，它接受相同的参数，但以 *反向* 搜索。你可能会希望在某些情况下使用这个功能，比如，如果你在查找
    `string` 末尾的特定标点符号，就如 [示例 15-14](ch15.xhtml#ch15ex14) 所示。'
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 15-14: Finding substrings in reverse within a `string`*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-14：在 `string` 中反向查找子字符串*'
- en: Using the same `word` ➊, you use the same arguments as in [Listing 15-13](ch15.xhtml#ch15ex13)
    to test `rfind`. Given `zz, rfind` returns `5`, the second to last *z* in `pizza``z``z`
    ➋. When you provide the positional argument `3, rfind` instead returns the first
    *z* in `pi``z``zazz` ➌. Because there’s only one occurrence of the substring `zaz,
    rfind` returns the same position as `find` ➍. Also like `find, rfind` returns
    `std::string::npos` when given `x` ➎.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的 `word` ➊，你使用与 [示例 15-13](ch15.xhtml#ch15ex13) 相同的参数来测试 `rfind`。给定 `zz`，`rfind`
    返回 `5`，即 `pizza``z``z` 中倒数第二个 *z* ➋。当你提供位置参数 `3` 时，`rfind` 则返回 `pi``z``zazz` 中的第一个
    *z* ➌。因为子字符串 `zaz` 只有一个出现，`rfind` 返回与 `find` 相同的位置 ➍。像 `find` 一样，当给定 `x` 时，`rfind`
    返回 `std::string::npos` ➎。
- en: '**find_*_of**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**find_*_of**'
- en: Whereas `find` and `rfind` locate exact subsequences in a `string`, a family
    of related functions finds the first character contained in a given argument.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `find` 和 `rfind` 用于定位 `string` 中的精确子序列，一系列相关的函数可以找到给定参数中包含的第一个字符。
- en: The `find_first_of` function accepts a `string` and locates the first character
    in this contained in the argument. Optionally, you can provide a `size_t` position
    argument to indicate to `find_first_of` where to start in the string. If `find_first_of`
    cannot find a matching character, it will return `std::string::npos`. [Listing
    15-15](ch15.xhtml#ch15ex15) illustrates the `find_first_of` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_first_of` 函数接受一个 `string`，并定位该 `string` 中包含的第一个字符。你还可以选择性地提供一个 `size_t`
    类型的位置参数，指示 `find_first_of` 从哪里开始查找。如果 `find_first_of` 未能找到匹配的字符，它将返回 `std::string::npos`。[示例
    15-15](ch15.xhtml#ch15ex15) 演示了 `find_first_of` 函数。'
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 15-15: Finding the first element from a set within a `string`*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-15：在 `string` 中查找集合的第一个元素*'
- en: The `string` called `sentence` contains `I am a Zizzer-Zazzer-Zuzz as you` `can
    plainly see.` ➊. Here, you invoke `find_first_of` with the string `Zz`, which
    matches both lowercase and uppercase *z*. This returns `7`, which corresponds
    to the first `Z` in `sentence, Z``izzer` ➋. In the second test, you again provide
    the string `Zz` but also pass the position argument `11`, which corresponds to
    the `e` in `Zizz``e``r`. This results in `14`, which corresponds to the `Z` in
    `Z``azzer` ➌. Finally, you invoke `find_first_of` with `Xx`, which results in
    `std::string::npos` because `sentence` doesn’t contain an `x` (or an `X`) ➍.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`sentence`的`string`包含`I am a Zizzer-Zazzer-Zuzz as you` `can plainly see.`
    ➊。在这里，你调用`find_first_of`并传入字符串`Zz`，它匹配小写和大写的*z*。返回值是`7`，对应于`sentence`中的第一个`Z`，即`Z``izzer`
    ➋。在第二个测试中，你再次传入字符串`Zz`，但同时传入位置参数`11`，对应`Zizz``e``r`中的`e`。结果是`14`，对应`Z``azzer`中的`Z`
    ➌。最后，你调用`find_first_of`并传入`Xx`，结果是`std::string::npos`，因为`sentence`中没有`x`（或`X`）
    ➍。
- en: 'A `string` offers three `find_first_of` variations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`提供了三种`find_first_of`变体：'
- en: '`find_first_not_of` returns the first character *not* contained in the `string`
    argument. Rather than providing a `string` containing the elements you want to
    find, you provide a `string` of characters you *don’t* want to find.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_first_not_of`返回`string`参数中*不*包含的第一个字符。与其提供一个包含你想要查找的元素的`string`，你应该提供一个你*不*想找到的字符组成的`string`。'
- en: '`find_last_of` performs matching in reverse; rather than searching from the
    beginning of the `string` or from the position argument and proceeding to the
    end, `find_last_of` begins at the end of the `string` or from the position argument
    and proceeds to the beginning.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_last_of`执行反向匹配；与从`string`的开头或某个位置参数开始搜索并向结尾进行不同，`find_last_of`从`string`的结尾或某个位置参数开始，向开头搜索。'
- en: '`find_last_not_of` combines the two prior variations: you pass a `string` containing
    elements you don’t want to find, and `find_last_not_of` searches in reverse.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_last_not_of`结合了前两种变体：你传入一个不希望找到的元素组成的`string`，而`find_last_not_of`则从末尾反向搜索。'
- en: Your choice of `find` function boils down to what your algorithmic requirements
    are. Do you need to search from the back of a `string`, say for a punctuation
    mark? If so, use `find_last_of`. Are you looking for the first space in a `string`?
    If so, use `find_first_of`. Do you want to invert your search and look for the
    first element that is not a member of some set? Then use the alternatives `find_first_not_of`
    and `find_last_not_of`, depending on whether you want to start from the beginning
    or end of the `string`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的`find`函数取决于你的算法需求。你是否需要从`string`的末尾开始搜索，例如查找标点符号？如果是，使用`find_last_of`。你是否在寻找`string`中的第一个空格？如果是，使用`find_first_of`。你是否想反转搜索，查找第一个不属于某个集合的元素？那么，根据你是想从字符串的开头还是结尾开始，使用`find_first_not_of`或`find_last_not_of`。
- en: '[Listing 15-16](ch15.xhtml#ch15ex16) illustrates these three `find_first_of`
    variations.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-16](ch15.xhtml#ch15ex16)展示了这三种`find_first_of`变体。'
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 15-16: Alternatives to the `find_first_of` method of `string`*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-16：`string`的`find_first_of`方法的替代方案*'
- en: Here, you initialize the same `sentence` as in [Listing 15-15](ch15.xhtml#ch15ex15)
    ➊. In the first test, you use `find_last_of` on `Zz`, which searches in reverse
    for any *z* or *Z* and returns `24`, the last *z* in the sentence `Zuz``z` ➋.
    Next, you use `find_first_not_of` and pass a farrago of characters (not including
    the letter *u*), which results in `22`, the position of the first *u* in `Z``u``zz`
    ➌. Finally, you use `find_last_not_of` to find the last character not equal to
    space, period, *e*, or *s*. This results in `43`, the position of *y* in `plainl``y`
    ➍.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你初始化与[示例 15-15](ch15.xhtml#ch15ex15)相同的`sentence` ➊。在第一个测试中，你对`Zz`使用`find_last_of`，它从字符串的末尾反向搜索任何*z*或*Z*，返回`24`，即`Zuz``z`中的最后一个*z*
    ➋。接下来，你使用`find_first_not_of`并传入一堆字符（不包括字母*u*），结果是`22`，即`Z``u``zz`中第一个*u*的位置 ➌。最后，你使用`find_last_not_of`查找最后一个不等于空格、句点、*e*或*s*的字符。结果是`43`，即`plainl``y`中的*y*的位置
    ➍。
- en: '**Summary of string Search Methods**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串搜索方法总结**'
- en: '[Table 15-6](ch15.xhtml#ch15tab06) lists many of the search methods for `string`.
    Note that `s2` is a string; `cstr` is a C-style `char*` string; `c` is a `char`;
    and `n, l`, and `pos` are `size_t` in the table.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-6](ch15.xhtml#ch15tab06)列出了许多`string`的搜索方法。请注意，`s2`是一个字符串；`cstr`是一个C风格的`char*`字符串；`c`是一个`char`类型；`n`、`l`和`pos`是表中的`size_t`类型。'
- en: '**Table 15-6:** Supported `std::string` Search Algorithms'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-6：** 支持的`std::string`搜索算法'
- en: '| **Method** | **Searches** s **starting at** p **and returns the position
    of the . . .** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **从** p **开始搜索并返回…的位置** |'
- en: '| s`.find(`s2`, [`p`])` | First substring equal to s2; p defaults to 0. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| s`.find(`s2`, [`p`])` | 第一个子串等于s2；p默认为0。 |'
- en: '| s`.find(`cstr`, [`p`], [`l`])` | First substring equal to the first l characters
    of cstr; p defaults to 0; l defaults to cstr’s length per null termination. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| s`.find(`cstr`, [`p`], [`l`])` | 第一个子串等于cstr的前l个字符；p默认为0；l默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.find(`c`, [`p`])` | First character equal to c; p defaults to 0. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| s`.find(`c`, [`p`])` | 第一个字符等于c；p默认为0。 |'
- en: '| s`.rfind(`s2`, [`p`])` | Last substring equal to s2; p defaults to `npos`.
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| s`.rfind(`s2`, [`p`])` | 最后一个子串等于s2；p默认为`npos`。 |'
- en: '| s`.rfind(`cstr`, [`p`], [`l`])` | Last substring equal to the first l characters
    of cstr; p defaults to `npos`; `l` defaults to cstr’s length per null termination.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| s`.rfind(`cstr`, [`p`], [`l`])` | 最后一个子串等于cstr的前l个字符；p默认为`npos`；l默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.rfind(`c`, [`p`])` | Last character equal to c; p defaults to `npos`.
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| s`.rfind(`c`, [`p`])` | 最后一个字符等于c；p默认为`npos`。 |'
- en: '| s`.find_first_of(`s2`, [`p`])` | First character contained in s2; p defaults
    to 0. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_of(`s2`, [`p`])` | 第一个字符包含在s2中；p默认为0。 |'
- en: '| s`.find_first_of(`cstr`, [`p`], [`l`])` | First character contained in the
    first l characters of cstr; p defaults to 0; `l` defaults to cstr’s length per
    null termination. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_of(`cstr`, [`p`], [`l`])` | 第一个字符包含在cstr的前l个字符中；p默认为0；`l`默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.find_first_of(`c`, [`p`])` | First character equal to c; p defaults to
    0. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_of(`c`, [`p`])` | 第一个字符等于c；p默认为0。 |'
- en: '| s`.find_last_of(`s2`, [`p`])` | Last character contained in s2; p defaults
    to 0. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_of(`s2`, [`p`])` | 最后一个字符包含在s2中；p默认为0。 |'
- en: '| s`.find_last_of(`cstr`, [`p`], [`l`])` | Last character contained in the
    first l characters of cstr; p defaults to 0; l defaults to cstr’s length per null
    termination. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_of(`cstr`, [`p`], [`l`])` | 最后一个字符包含在cstr的前l个字符中；p默认为0；l默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.find_last_of(`c`, [`p`])` | Last character equal to c; p defaults to 0.
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_of(`c`, [`p`])` | 最后一个字符等于c；p默认为0。 |'
- en: '| s`.find_first_not_of(`s2`, [`p`])` | First character not contained in s2;
    p defaults to 0. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_not_of(`s2`, [`p`])` | 第一个字符不包含在s2中；p默认为0。 |'
- en: '| s`.find_first_not_of(`cstr`, [`p`], [`l`])` | First character not contained
    in the first l characters of cstr; p defaults to 0; l defaults to cstr’s length
    per null termination. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_not_of(`cstr`, [`p`], [`l`])` | 第一个字符不包含在cstr的前l个字符中；p默认为0；l默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.find_first_not_of(`c`, [`p`])` | First character not equal to c; p defaults
    to 0. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_first_not_of(`c`, [`p`])` | 第一个字符不等于c；p默认为0。 |'
- en: '| s`.find_last_not_of(`s2`, [`p`])` | Last character not contained in s2; p
    defaults to 0. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_not_of(`s2`, [`p`])` | 最后一个字符不包含在s2中；p默认为0。 |'
- en: '| s`.find_last_not_of(`cstr`, [`p`], [`l`])` | Last character not contained
    in the first l characters of cstr; p defaults to 0; l defaults to cstr’s length
    per null termination. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_not_of(`cstr`, [`p`], [`l`])` | 最后一个字符不包含在cstr的前l个字符中；p默认为0；l默认为cstr的长度（以空字符为终止）。
    |'
- en: '| s`.find_last_not_of(`c`, [`p`])` | Last character not equal to c; p defaults
    to 0. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| s`.find_last_not_of(`c`, [`p`])` | 最后一个字符不等于c；p默认为0。 |'
- en: '***Numeric Conversions***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值转换***'
- en: The STL provides functions for converting between `string` or `wstring` and
    the fundamental numeric types. Given a numeric type, you can use the `std::to_string`
    and `std::to_wstring` functions to generate its `string` or `wstring` representation.
    Both functions have overloads for all the numeric types. [Listing 15-17](ch15.xhtml#ch15ex17)
    illustrates `string` and `wstring`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了将`string`或`wstring`与基本数值类型之间进行转换的函数。给定一个数值类型，你可以使用`std::to_string`和`std::to_wstring`函数生成其`string`或`wstring`表示。这两个函数都为所有数值类型提供了重载。[列表15-17](ch15.xhtml#ch15ex17)展示了`string`和`wstring`的使用。
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 15-17: Numeric conversion functions of `string`*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-17：`string`的数字转换函数*'
- en: '**NOTE**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Thanks to the inherent inaccuracy of the double type, the second unit test*
    ➋ *might fail on your system.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于`double`类型本身的精度限制，第二个单元测试* ➋ *可能在你的系统上失败。*'
- en: The first example uses `to_string` to convert the `int 8675309` into a `string`
    ➊; the second example uses `to_wstring` to convert the `double 109951.1627776`
    into a `wstring` ➋.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用`to_string`将`int 8675309`转换为`string` ➊；第二个示例使用`to_wstring`将`double 109951.1627776`转换为`wstring`
    ➋。
- en: 'You can also convert the other way, going from a `string` or `wstring` to a
    numeric type. Each numeric conversion function accepts a `string` or `wstring`
    containing a string-encoded number as its first argument. Next, you can provide
    an optional pointer to a `size_t`. If provided, the conversion function will write
    the index of the last character it was able to convert (or the length of the input
    `string` if it decoded all characters). By default, this index argument is `nullptr`,
    in which case the conversion function doesn’t write the index. When the target
    type is integral, you can provide a third argument: an `int` corresponding to
    the base of the encoded `string`. This base argument is optional and defaults
    to 10.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以反向转换，从 `string` 或 `wstring` 转换为数字类型。每个数字转换函数都接受一个包含字符串编码数字的 `string` 或 `wstring`
    作为第一个参数。接下来，你可以提供一个可选的指向 `size_t` 的指针。如果提供了，转换函数将写入它所能转换的最后一个字符的索引（或者如果它解码了所有字符，则写入输入
    `string` 的长度）。默认情况下，这个索引参数为 `nullptr`，此时转换函数不会写入索引。当目标类型是整数类型时，你可以提供第三个参数：一个 `int`，表示编码字符串的进制。这个进制参数是可选的，默认值为
    10。
- en: Each conversion function throws `std::invalid_argument` if no conversion could
    be performed and throws `std::out_of_range` if the converted value is out of range
    for the corresponding type.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个转换函数如果无法执行转换，会抛出 `std::invalid_argument`，如果转换的值超出相应类型的范围，则抛出 `std::out_of_range`。
- en: '[Table 15-7](ch15.xhtml#ch15tab07) lists each of these conversion functions
    along with its target type. In this table, `s` is a string. If `p` is not `nullptr`,
    the conversion function will write the position of the first unconverted character
    in `s` to the memory pointed to by `p`. If all characters are encoded, returns
    the length of `s`. Here, `b` is the number’s base representation in `s`. Note
    that `p` defaults to `nullptr`, and `b` defaults to 10.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-7](ch15.xhtml#ch15tab07) 列出了这些转换函数及其目标类型。在此表中，`s` 是一个字符串。如果 `p` 不是 `nullptr`，转换函数将把
    `s` 中第一个未转换字符的位置写入 `p` 指向的内存中。如果所有字符都已编码，则返回 `s` 的长度。这里，`b` 是 `s` 中数字的进制表示。注意，`p`
    默认为 `nullptr`，`b` 默认为 10。'
- en: '**Table 15-7:** Supported Numeric Conversion Functions for `std::string` and
    `std::wstring`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-7：** `std::string` 和 `std::wstring` 的支持的数字转换函数'
- en: '| **Function** | **Converts** `s` to |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **将 `s` 转换为** |'
- en: '| `stoi(`s`, [`p`], [`b`])` | An `int` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `stoi(`s`, [`p`], [`b`])` | 一个 `int` |'
- en: '| `stol(`s`, [`p`], [`b`])` | A `long` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `stol(`s`, [`p`], [`b`])` | 一个 `long` |'
- en: '| `stoll(`s`, [`p`], [`b`])` | A `long long` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `stoll(`s`, [`p`], [`b`])` | 一个 `long long` |'
- en: '| `stoul(`s`, [`p`], [`b`])` | An `unsigned long` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `stoul(`s`, [`p`], [`b`])` | 一个 `unsigned long` |'
- en: '| `stoull(`s`, [`p`], [`b`])` | An `unsigned long long` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `stoull(`s`, [`p`], [`b`])` | 一个 `unsigned long long` |'
- en: '| `stof(`s`, [`p`])` | A `float` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `stof(`s`, [`p`])` | 一个 `float` |'
- en: '| `stod(`s`, [`p`])` | A `double` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `stod(`s`, [`p`])` | 一个 `double` |'
- en: '| `stold(`s`, [`p`])` | A `long double` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `stold(`s`, [`p`])` | 一个 `long double` |'
- en: '| `to_string(`n`)` | A `string` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `to_string(`n`)` | 一个 `string` |'
- en: '| `to_wstring(`n`)` | A `wstring` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `to_wstring(`n`)` | 一个 `wstring` |'
- en: '[Listing 15-18](ch15.xhtml#ch15ex18) illustrates several numeric conversion
    functions.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-18](ch15.xhtml#ch15ex18) 演示了几个数字转换函数。'
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 15-18: String conversion functions of `string`*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-18：`string` 的字符串转换函数*'
- en: 'First, you use `stoi` to convert `8675309` to an integer ➊. In the second test,
    you attempt to use `stoi` to convert the `string 1099511627776` into an integer.
    Because this value is too large for an `int, stoi` throws `std::out_of_range`
    ➋. Next, you convert `0xD3C34C3D` with `stoi`, but you provide the two optional
    arguments: a pointer to a `size_t` called `last_character` and a hexadecimal base
    ➌. The `last_character` object is `10`, the length of `0xD3C34C3D`, because `stoi`
    can parse every character. The `string` in the next test, `42six`, contains the
    unparsable characters `six`. When you invoke `stoul` this time, the `result` is
    `42` and `last_character` equals `2`, the position of `s` in `six` ➍. Finally,
    you use `stod` to convert the `string 2.7182818` to a `double` ➎.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `stoi` 将 `8675309` 转换为整数 ➊。在第二次测试中，尝试使用 `stoi` 将 `string 1099511627776`
    转换为整数。由于该值对于 `int` 来说过大，`stoi` 抛出 `std::out_of_range` ➋。接下来，使用 `stoi` 转换 `0xD3C34C3D`，但提供了两个可选参数：指向
    `size_t` 的指针 `last_character` 和一个十六进制进制 ➌。`last_character` 对象的值为 `10`，即 `0xD3C34C3D`
    的长度，因为 `stoi` 能解析每个字符。下一个测试中的 `string` 为 `42six`，包含无法解析的字符 `six`。当你这次调用 `stoul`
    时，`result` 为 `42`，`last_character` 等于 `2`，即 `s` 中 `six` 的位置 ➍。最后，你使用 `stod` 将
    `string 2.7182818` 转换为 `double` ➎。
- en: '**NOTE**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost’s Lexical Cast provides an alternative, template-based approach to numeric
    conversions. Refer to the documentation for `boost::lexical_cast` available in
    the `<boost/lexical_cast.hpp>` header.*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 的 Lexical Cast 提供了一种基于模板的替代方法，用于数值转换。有关 `boost::lexical_cast` 的文档，请参考
    `<boost/lexical_cast.hpp>` 头文件中的文档。*'
- en: '**String View**'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串视图**'
- en: A *string view* is an object that represents a constant, contiguous sequence
    of characters. It’s very similar to a `const string` reference. In fact, string
    view classes are often implemented as a pointer to a character sequence and a
    length.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串视图* 是一个表示常量、连续字符序列的对象。它非常类似于 `const string` 引用。实际上，字符串视图类通常实现为指向字符序列的指针和长度。'
- en: 'The STL offers the class template `std::basic_string_view` in the `<string_view>`
    header, which is analogous to `std::basic_string`. The template `std::basic_string_view`
    has a specialization for each of the four commonly used character types:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了类模板 `std::basic_string_view`，位于 `<string_view>` 头文件中，它类似于 `std::basic_string`。模板
    `std::basic_string_view` 对四种常用字符类型都有特化：
- en: '`char` has `string_view`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 有 `string_view`'
- en: '`wchar_t` has `wstring_view`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wchar_t` 有 `wstring_view`'
- en: '`char16_t` has `u16string_view`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char16_t` 有 `u16string_view`'
- en: '`char32_t` has `u32string_view`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char32_t` 有 `u32string_view`'
- en: This section discusses the `string_view` specialization for demonstration purposes,
    but the discussion generalizes to the other three specializations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 `string_view` 的特化用于演示，但讨论内容同样适用于其他三种特化。
- en: The `string_view` class supports most of the same methods as `string`; in fact,
    it’s designed to be a drop-in replacement for a `const string&`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类支持大多数与 `string` 相同的方法；实际上，它被设计成可以替代 `const string&`。'
- en: '***Constructing***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: The `string_view` class supports default construction, so it has zero length
    and points to `nullptr`. Importantly, `string_view` supports implicit construction
    from a `const string&` or a C-style string. You can construct `string_view` from
    a `char*` and a `size_t`, so you can manually specify the desired length in case
    you want a substring or you have embedded nulls. [Listing 15-19](ch15.xhtml#ch15ex19)
    illustrates the use of `string_view`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类支持默认构造，因此它的长度为零，并且指向 `nullptr`。重要的是，`string_view` 支持从 `const
    string&` 或 C 风格字符串隐式构造。你可以从 `char*` 和 `size_t` 构造 `string_view`，这样你就可以手动指定所需的长度，以便获取子串或处理嵌入的空字符。
    [Listing 15-19](ch15.xhtml#ch15ex19) 说明了 `string_view` 的使用。'
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 15-19: The constructors of `string_view`*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-19：`string_view` 的构造函数*'
- en: The default-constructed `string_view` points to `nullptr` and is empty ➊. When
    you construct a `string_view` from a `string` ➋ or a C-style string ➌, it points
    to the original’s contents. The final test provides the optional length argument
    `4`, which means the `string_view` refers to only the first four characters instead
    ➍.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的 `string_view` 指向 `nullptr`，并且是空的 ➊。当你从 `string` ➋ 或 C 风格字符串 ➌ 构造 `string_view`
    时，它会指向原始内容。最后的测试提供了可选的长度参数 `4`，意味着 `string_view` 只指向前四个字符 ➍。
- en: Although `string_view` also supports copy construction and assignment, it doesn’t
    support move construction or assignment. This design makes sense when you consider
    that `string_view` doesn’t own the sequence to which it points.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `string_view` 也支持复制构造和赋值，但不支持移动构造和赋值。这个设计是合理的，因为 `string_view` 不拥有它所指向的字符序列。
- en: '***Supported string_view Operations***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的 string_view 操作***'
- en: 'The `string_view` class supports many of the same operations as a `const` `string&`
    with identical semantics. The following lists all the shared methods between `string`
    and `string_view`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类支持与 `const` `string&` 相同的许多操作，并且语义相同。以下列出了 `string` 和 `string_view`
    之间共享的所有方法：'
- en: '**Iterators** `begin, end`, `rbegin, rend`, `cbegin, cend`, `crbegin`, `crend`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器** `begin, end`, `rbegin, rend`, `cbegin, cend`, `crbegin`, `crend`'
- en: '**Element Access** `operator[], at`, `front, back`, `data`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素访问** `operator[], at`, `front, back`, `data`'
- en: '**Capacity** `size, length`, `max_size`, `empty`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**容量** `size, length`, `max_size`, `empty`'
- en: '**Search** `find, rfind`, `find_first_of, find_last_of`, `find_first_not_of`,
    `find_last_not_of`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索** `find, rfind`, `find_first_of, find_last_of`, `find_first_not_of`, `find_last_not_of`'
- en: '**Extraction** `copy`, `substr`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取** `copy`, `substr`'
- en: '**Comparison** `compare, operator==, operator!=` , `operator<`, `operator>`,
    `operator<=`, `operator>=`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较** `compare, operator==, operator!=` , `operator<`, `operator>`, `operator<=`,
    `operator>=`'
- en: In addition to these shared methods, `string_view` supports the `remove_prefix`
    method, which removes the given number of characters from the beginning of the
    `string_view`, and the `remove_suffix` method, which instead removes characters
    from the end. [Listing 15-20](ch15.xhtml#ch15ex20) illustrates both methods.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些共享的方法，`string_view`还支持`remove_prefix`方法，用于从`string_view`的开始位置移除指定数量的字符，以及`remove_suffix`方法，用于从末尾移除字符。[列表
    15-20](ch15.xhtml#ch15ex20)展示了这两种方法。
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 15-20: Modifying a `string_view` with `remove_prefix` and `remove_suffix`*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-20: 使用`remove_prefix`和`remove_suffix`修改`string_view`*'
- en: Here, you declare a `string_view` referring to the string literal `previewing`
    ➊. The first test invokes `remove_prefix` with `3` ➋, which removes three characters
    from the front of `string_view` so it now refers to `viewing`. The second test
    instead invokes `remove_suffix` with `3` ➌, which removes three characters from
    the back of the `string_view` and results in `preview`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你声明了一个`string_view`，它引用了字符串字面量`previewing` ➊。第一个测试调用`remove_prefix`，参数为`3`
    ➋，这将从`string_view`的前面移除三个字符，因此它现在引用`viewing`。第二个测试则调用`remove_suffix`，参数为`3` ➌，这会从`string_view`的末尾移除三个字符，结果是`preview`。
- en: '***Ownership, Usage, and Efficiency***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***所有权、使用和效率***'
- en: Because `string_view` doesn’t own the sequence to which it refers, it’s up to
    you to ensure that the lifetime of the `string_view` is a subset of the referred-to
    sequence’s lifetime.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`string_view`并不拥有它所引用的序列，所以你必须确保`string_view`的生命周期是被引用序列生命周期的子集。
- en: Perhaps the most common usage of `string_view` is as a function parameter. When
    you need to interact with an immutable sequence of characters, it’s the first
    port of call. Consider the `count_vees` function in [Listing 15-21](ch15.xhtml#ch15ex21),
    which counts the frequency of the letter `v` in a sequence of characters.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view`最常见的用法之一是作为函数参数。当你需要与不可变的字符序列交互时，它是首选。考虑[列表 15-21](ch15.xhtml#ch15ex21)中的`count_vees`函数，它用于计算字符序列中字母`v`的频率。'
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 15-21: The `count_vees` function*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-21: `count_vees` 函数*'
- en: The `count_vees` function takes a `string_view` called `my_view` ➊, which you
    iterate over using a range-based `for` loop ➋. Each time a character in `my_view`
    equals `v`, you increment a `result` variable ➌, which you return after exhausting
    the sequence ➍.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_vees`函数接受一个名为`my_view`的`string_view` ➊，你使用基于范围的`for`循环 ➋遍历它。每当`my_view`中的字符等于`v`时，你就增加`result`变量
    ➌，并在遍历完整个序列后返回该变量 ➍。'
- en: You could reimplement [Listing 15-21](ch15.xhtml#ch15ex21) by simply replacing
    `string_view` with `const string&`, as demonstrated in [Listing 15-22](ch15.xhtml#ch15ex22).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地将`string_view`替换为`const string&`来重新实现[列表 15-21](ch15.xhtml#ch15ex21)，正如在[列表
    15-22](ch15.xhtml#ch15ex22)中所展示的那样。
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 15-22: The `count_vees` function reimplemented to use a `const string&`
    instead of a `string_view`*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-22: 重新实现的`count_vees`函数，使用`const string&`代替`string_view`*'
- en: 'If `string_view` is just a drop-in replacement for a `const string&`, why bother
    having it? Well, if you invoke `count_vees` with a `std::string`, there’s no difference:
    modern compilers will emit the same code.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`string_view`仅仅是`const string&`的替代品，那为什么还要使用它呢？其实，如果你用`std::string`调用`count_vees`，并没有什么区别：现代编译器会生成相同的代码。
- en: 'If you instead invoke `count_vees` with a string literal, there’s a big difference:
    when you pass a string literal for a `const string&`, you construct a `string`.
    When you pass a string literal for a `string_view`, you construct a `string_view`.
    Constructing a `string` is probably more expensive, because it might have to allocate
    dynamic memory and it definitely has to copy characters. A `string_view` is just
    a pointer and a length (no copying or allocating is required).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用字符串字面量来调用`count_vees`，则会有很大区别：当你将字符串字面量作为`const string&`传递时，你会构造一个`string`。而当你将字符串字面量作为`string_view`传递时，你会构造一个`string_view`。构造`string`可能更昂贵，因为它可能需要分配动态内存，并且必须复制字符。而`string_view`只是一个指针和一个长度（不需要复制或分配内存）。
- en: '**Regular Expressions**'
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: A *regular expression*, also called a *regex*, is a string that defines a search
    pattern. Regexes have a long history in computer science and form a sort of mini-language
    for searching, replacing, and extracting language data. The STL offers regular
    expression support in the `<regex>` header.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*，也叫做*regex*，是定义搜索模式的字符串。正则表达式在计算机科学中有着悠久的历史，并形成了一种用于搜索、替换和提取语言数据的迷你语言。STL在`<regex>`头文件中提供了正则表达式的支持。'
- en: When used judiciously, regular expressions can be tremendously powerful, declarative,
    and concise; however, it’s also easy to write regexes that are totally inscrutable.
    Use regexes deliberately.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在谨慎使用时可以非常强大、声明式且简洁；然而，也很容易写出完全无法理解的正则表达式。请有意地使用正则表达式。
- en: '***Patterns***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模式***'
- en: You build regular expressions using strings called *patterns*. Patterns represent
    a desired set of strings using a particular regular expression grammar that sets
    the syntax for building patterns. In other words, a pattern defines the subset
    of all possible strings that you’re interested in. The STL supports a handful
    of grammars, but the focus here will be on the very basics of the default grammar,
    the modified ECMAScript regular expression grammar (see [re.grammar] for details).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用叫做*模式*的字符串来构建正则表达式。模式使用特定的正则表达式语法来表示一个期望的字符串集，这些语法规定了构建模式的语法。换句话说，模式定义了你感兴趣的所有可能字符串的子集。STL
    支持一些语法，但这里的重点是默认语法，即修改过的 ECMAScript 正则表达式语法（有关详细信息，请参见[re.grammar]）。
- en: '**Character Classes**'
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: 'In the ECMAScript grammar, you intermix literal characters with special markup
    to describe your desired strings. Perhaps the most common markup is a *character
    class*, which stands in for a set of possible characters: `\d` matches any digit,
    `\s` matches any whitespace, and `\w` matches any alphanumeric (“word”) character.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 语法中，你将字面字符与特殊标记混合使用来描述你期望的字符串。最常见的标记可能是*字符类*，它代表一组可能的字符：`\d` 匹配任何数字，`\s`
    匹配任何空白字符，`\w` 匹配任何字母数字（“单词”）字符。
- en: '[Table 15-8](ch15.xhtml#ch15tab08) lists a few example regular expressions
    and possible interpretations.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-8](ch15.xhtml#ch15tab08)列出了几个示例正则表达式及其可能的解释。'
- en: '**Table 15-8:** Regular Expression Patterns Using Only Character Classes and
    Literals'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-8：**仅使用字符类和字面量的正则表达式模式'
- en: '| **Regex pattern** | **Possibly describes** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式模式** | **可能描述** |'
- en: '| `\d\d\d-\d\d\d-\d\d\d\d` | An American phone number, such as 202-456-1414
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `\d\d\d-\d\d\d-\d\d\d\d` | 一个美国电话号码，例如 202-456-1414 |'
- en: '| `\d\d:\d\d \wM` | A time in HH:MM AM/PM format, such as 08:49 PM |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `\d\d:\d\d \wM` | 一个时间，格式为 HH:MM AM/PM，例如 08:49 PM |'
- en: '| `\w\w\d\d\d\d\d\d` | An American ZIP code including a prepended state code,
    such as NJ07932 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `\w\w\d\d\d\d\d\d` | 一个美国邮政编码，包含前置的州代码，例如 NJ07932 |'
- en: '| `\w\d-\w\d` | An astromech droid identifier, such as R2-D2 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `\w\d-\w\d` | 一个天文机械人标识符，例如 R2-D2 |'
- en: '| `c\wt` | A three-letter word starting with *c* and ending with *t*, such
    as *cat* or *cot* |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `c\wt` | 一个以*c*开头并以*t*结尾的三字母单词，例如*cat*或*cot* |'
- en: 'You can also invert a character class by capitalizing the *d*, *s*, or *w*
    to give the opposite: `\D` matches any non-digit, `\S` matches any non-whitespace,
    and `\W` matches any non-word character.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将*d*、*s*或*w*大写来反转字符类，得到相反的效果：`\D`匹配任何非数字，`\S`匹配任何非空白字符，`\W`匹配任何非单词字符。
- en: In addition, you can build your own character classes by explicitly enumerating
    them between square brackets `[]`. For example, the character class `[02468]`
    includes even digits. You can also use hyphens as shortcuts to include implied
    ranges, so the character class `[0-9a-fA-F]` includes any hexadecimal digit whether
    the letter is capitalized or not. Finally, you can invert a custom character class
    by prepending the list with a caret `^`. For example, the character class `[^aeiou]`
    includes all non-vowel characters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过在方括号 `[]` 中显式列出它们来构建自己的字符类。例如，字符类 `[02468]` 包含偶数数字。你还可以使用连字符作为快捷方式来包含隐含的范围，因此字符类
    `[0-9a-fA-F]` 包含任何十六进制数字，无论字母是否大写。最后，你可以通过在列表前加上脱字符 `^` 来反转自定义字符类。例如，字符类 `[^aeiou]`
    包含所有非元音字符。
- en: '**Quantifiers**'
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**量词**'
- en: You can save some typing by using *quantifiers*, which specify that the character
    directly to the left should be repeated some number of times. [Table 15-9](ch15.xhtml#ch15tab09)
    lists the regex quantifiers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用*量词*来减少一些打字，这些量词指定左边的字符应该重复一定次数。[表 15-9](ch15.xhtml#ch15tab09)列出了正则表达式量词。
- en: '**Table 15-9:** Regular Expression Quantifiers'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-9：** 正则表达式量词'
- en: '| **Regex quantifier** | **Specifies a quantity of** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式量词** | **指定数量** |'
- en: '| * | 0 or more |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| * | 0 次或更多次 |'
- en: '| + | 1 or more |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| + | 1 次或更多次 |'
- en: '| ? | 0 or 1 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| ? | 0 次或 1 次 |'
- en: '| {n} | Exactly n |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| {n} | 正好 n 次 |'
- en: '| {n,m} | Between n and m, inclusive |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| {n,m} | 介于 n 和 m 之间（包括 n 和 m） |'
- en: '| {n,} | At least n |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| {n,} | 至少 n 次 |'
- en: Using quantifiers, you can specify all words beginning with *c* and ending with
    *t* using the pattern `c\w*t`, because `\w*` matches any number of word characters.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用量词，你可以通过模式`c\w*t`指定所有以*c*开头并以*t*结尾的单词，因为`\w*`匹配任意数量的字母数字字符。
- en: '**Groups**'
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**组**'
- en: A *group* is a collection of characters. You can specify a group by placing
    it within parentheses. Groups are useful in several ways, including specifying
    a particular collection for eventual extraction and for quantification.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*组*是字符的集合。你可以通过将字符放入括号中来指定一个组。组在多个方面都有用，包括指定一个特定的集合以便最终提取和量化。'
- en: 'For example, you could improve the ZIP pattern in [Table 15-8](ch15.xhtml#ch15tab08)
    to use quantifiers and groups, like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以改进[表 15-8](ch15.xhtml#ch15tab08)中的邮政编码模式，使用量词和分组，像这样：
- en: '[PRE23]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you have three groups: the optional state ➊, the ZIP code ➋, and an optional
    four-digit suffix ➌. As you’ll see later on, these groups make parsing from regexes
    much easier.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了三个组：可选的状态➊、邮政编码➋，以及一个可选的四位数字后缀➌。正如你稍后将看到的，这些组使得从正则表达式中解析数据变得更加容易。
- en: '**Other Special Characters**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他特殊字符**'
- en: '[Table 15-10](ch15.xhtml#ch15tab10) lists several other special characters
    available for use in regex patterns.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-10](ch15.xhtml#ch15tab10)列出了可用于正则表达式模式的其他特殊字符。'
- en: '**Table 15-10:** Example Special Characters'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-10:** 示例特殊字符'
- en: '| **Character** | **Specifies** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **指定内容** |'
- en: '| X&#124;Y | Character X or Y |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| X&#124;Y | 字符X或Y |'
- en: '| \Y | The special character Y as a literal (in other words, escape it) |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| \Y | 字符Y作为字面量（换句话说，转义它） |'
- en: '| \n | Newline |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| \n | 换行符 |'
- en: '| \r | Carriage return |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| \r | 回车符 |'
- en: '| \t | Tab |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| \t | 制表符 |'
- en: '| \0 | Null |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| \0 | 空字符 |'
- en: '| \xYY | The hexadecimal character corresponding to YY |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| \xYY | 对应YY的十六进制字符 |'
- en: '***basic_regex***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***basic_regex***'
- en: 'The STL’s `std::basic_regex` class template in the `<regex>` header represents
    a regular expression constructed from a pattern. The `basic_regex` class accepts
    two template parameters, a character type and an optional traits class. You’ll
    almost always want to use one of the convenience specializations: `std::regex`
    for `std::basic_regex<char>` or `std::wregex` for `std::basic_regex<wchar_t>`.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`std::basic_regex`类模板位于`<regex>`头文件中，表示由模式构造的正则表达式。`basic_regex`类接受两个模板参数，一个是字符类型，另一个是可选的traits类。你几乎总是希望使用其中一种便捷的特化：`std::regex`用于`std::basic_regex<char>`，或`std::wregex`用于`std::basic_regex<wchar_t>`。
- en: The primary means of constructing a `regex` is by passing a string literal containing
    your regex pattern. Because patterns will require a lot of escaped characters—especially
    the backslash `\`—it’s a good idea to use raw string literals, such as `R"()"`.
    The constructor accepts a second, optional parameter for specifying syntax flags
    like the regex grammar.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`regex`的主要方式是通过传递包含正则表达式模式的字符串字面量。由于模式中需要大量转义字符，尤其是反斜杠`\`，因此使用原始字符串字面量，如`R"()"`，是一个好主意。构造函数接受一个第二个可选参数，用于指定语法标志，如正则表达式语法。
- en: 'Although `regex` is used primarily as input into regular expression algorithms,
    it does offer a few methods that users can interact with. It supports the usual
    copy and move construction and assignment suite and `swap`, plus the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`regex`主要用于作为正则表达式算法的输入，但它确实提供了一些方法，允许用户与之交互。它支持常见的复制、移动构造和赋值操作，以及`swap`，还有以下功能：
- en: '`assign(``s``)` reassigns the pattern to `s`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assign(``s``)`将模式重新分配给`s`'
- en: '`mark_count()` returns the number of groups in the pattern'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mark_count()`返回模式中的组数'
- en: '`flags()` returns the syntax flags issued at construction'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags()`返回构造时发出的语法标志'
- en: '[Listing 15-23](ch15.xhtml#ch15ex23) illustrates how you could construct a
    ZIP code `regex` and inspect its subgroups.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-23](ch15.xhtml#ch15ex23)展示了如何构造一个邮政编码`regex`并检查其子组。'
- en: '[PRE24]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 15-23: Constructing a `regex` using a raw string literal and extracting
    its group count*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-23：使用原始字符串字面量构造`regex`并提取其组数*'
- en: Here, you construct a `regex` called `zip_regex` using the pattern `(\w{2})?(\d{5})(-\d{4})?`
    ➊. Using the `mark_count` method, you see that `zip_regex` contains three groups
    ➋.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用模式`(\w{2})?(\d{5})(-\d{4})?` ➊构造了一个名为`zip_regex`的`regex`。通过使用`mark_count`方法，你会看到`zip_regex`包含三个组➋。
- en: '***Algorithms***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算法***'
- en: 'The `<regex>` class contains three algorithms for applying `std::basic_regex`
    to a target string: matching, searching, or replacing. Which you choose depends
    on the task at hand.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`<regex>`类包含三种算法，用于将`std::basic_regex`应用于目标字符串：匹配、搜索或替换。你选择哪一种取决于手头的任务。'
- en: '**Matching**'
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**匹配**'
- en: '*Matching* attempts to marry a regular expression to an *entire* `string`.
    The STL provides the `std::regex_match` function for matching, which has four
    overloads.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*匹配* 尝试将正则表达式与 *整个* `string` 进行匹配。STL 提供了 `std::regex_match` 函数用于匹配，它有四种重载形式。'
- en: First, you can provide `regex_match` a `string`, a C-string, or a begin and
    end iterator forming a half-open range. The next parameter is an optional reference
    to a `std::match_results` object that receives details about the match. The next
    parameter is a `std::basic_regex` that defines the matching, and the final parameter
    is an optional `std::regex_constants::match_flag_type` that specifies additional
    matching options for advanced use cases. The `regex_match` function returns a
    `bool`, which is `true` if it found a match; otherwise, it’s `false`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以为 `regex_match` 提供一个 `string`、一个 C 字符串，或者一个形成半开区间的开始和结束迭代器。下一个参数是一个可选的
    `std::match_results` 对象的引用，用于接收匹配的详细信息。下一个参数是定义匹配的 `std::basic_regex`，最后一个参数是一个可选的
    `std::regex_constants::match_flag_type`，用于指定高级用例的附加匹配选项。`regex_match` 函数返回一个 `bool`，如果找到匹配则为
    `true`，否则为 `false`。
- en: 'To summarize, you can invoke `regex_match` in the following ways:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你可以通过以下方式调用 `regex_match`：
- en: '[PRE25]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Either provide a half-open range from `beg` to `end` or a `string`/C-string
    `str` to search. Optionally, you can provide a `match_results` called `mr` to
    store all the details of any matches found. You obviously have to provide a regex
    `rgx`. Finally, the flags `flg` are seldom used.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供从 `beg` 到 `end` 的半开区间，或一个 `string`/C 字符串 `str` 来进行搜索。你也可以选择提供一个名为 `mr` 的
    `match_results` 来存储找到的所有匹配的详细信息。显然，你必须提供一个正则表达式 `rgx`。最后，`flg` 标志很少使用。
- en: '**NOTE**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For details on match flags `flg`, refer to [re.alg.match].*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关匹配标志 `flg` 的详细信息，请参考 [re.alg.match]。*'
- en: A *submatch* is a subsequence of the matched string that corresponds to a group.
    The ZIP code–matching regular expression `(\w{2})(\d{5})(-\d{4})?` can produce
    two or three submatches depending on the string. For example, TX78209 contains
    the two submatches TX and 78209, and NJ07936-3173 contains the three submatches
    NJ, 07936, and -3173.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*子匹配*是与某个分组对应的匹配字符串的子序列。ZIP 代码匹配的正则表达式 `(\w{2})(\d{5})(-\d{4})?` 可以根据字符串产生两个或三个子匹配。例如，TX78209
    包含两个子匹配 TX 和 78209，而 NJ07936-3173 包含三个子匹配 NJ、07936 和 -3173。'
- en: The `match_results` class stores zero or more `std::sub_match` instances. A
    `sub_match` is a simple class template that exposes a `length` method to return
    the length of a submatch and a `str` method to build a `string` from the `sub_match`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results` 类存储零个或多个 `std::sub_match` 实例。`sub_match` 是一个简单的类模板，公开一个 `length`
    方法来返回子匹配的长度，以及一个 `str` 方法来从 `sub_match` 构建一个 `string`。'
- en: Somewhat confusingly, if `regex_match` successfully matches a string, `match_results`
    stores the entire matched string as its first element and then stores any submatches
    as subsequent elements.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有些令人困惑的是，如果 `regex_match` 成功匹配一个字符串，`match_results` 会将整个匹配字符串作为第一个元素，然后将任何子匹配存储为后续元素。
- en: The `match_results` class provides the operations listed in [Table 15-11](ch15.xhtml#ch15tab11).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results` 类提供了 [表 15-11](ch15.xhtml#ch15tab11) 中列出的操作。'
- en: '**Table 15-11:** Supported Operations of `match_results`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-11：** `match_results` 的支持操作'
- en: '| **Operation** | **Description** |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| mr`.empty()` | Checks whether the match was successful. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| mr`.empty()` | 检查匹配是否成功。 |'
- en: '| mr`.size()` | Returns the number of submatches. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| mr`.size()` | 返回子匹配的数量。 |'
- en: '| mr`.max_size()` | Returns the maximum number of submatches. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| mr`.max_size()` | 返回子匹配的最大数量。 |'
- en: '| mr`.length([`i`])` | Returns the length of the submatch `i`, which defaults
    to 0. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| mr`.length([`i`])` | 返回子匹配 `i` 的长度，默认值为 0。 |'
- en: '| mr`.position([`i`])` | Returns the character of the first position of submatch
    `i`, which defaults to 0. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| mr`.position([`i`])` | 返回子匹配 `i` 的第一个位置的字符，默认值为 0。 |'
- en: '| mr`.str([`i`])` | Returns the string representing submatch `i`, which defaults
    to 0. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| mr`.str([`i`])` | 返回表示子匹配 `i` 的字符串，默认值为 0。 |'
- en: '| mr `[`i`]` | Returns a reference to a `std::sub_match` class corresponding
    to submatch `i`, which defaults to 0. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| mr `[`i`]` | 返回一个引用，指向与子匹配 `i` 对应的 `std::sub_match` 类，默认值为 0。 |'
- en: '| mr`.prefix()` | Returns a reference to a `std::sub_match` class corresponding
    to the sequence before the match. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| mr`.prefix()` | 返回一个引用，指向与匹配前序列对应的 `std::sub_match` 类。 |'
- en: '| mr`.suffix()` | Returns a reference to a `std::sub_match` class corresponding
    to the sequence after the match. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| mr`.suffix()` | 返回一个引用，指向与匹配后序列对应的 `std::sub_match` 类。 |'
- en: '| mr`.format(`str`)` | Returns a `string` with contents according to the format
    string str. There are three special sequences: $'' for the characters before a
    match, $'' for the characters after the match, and $& for the matched characters.
    |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| mr`.format(`str`)` | 返回一个 `string`，其内容按照格式字符串 str 排列。有三个特殊序列：$'' 表示匹配前的字符，$''
    表示匹配后的字符，$& 表示匹配的字符。 |'
- en: '| mr`.begin()`mr`.end()`mr`.cbegin()`mr`.cend()` | Returns the corresponding
    iterator to the sequence of submatches. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| mr`.begin()`mr`.end()`mr`.cbegin()`mr`.cend()` | 返回指向子匹配序列的相应迭代器。 |'
- en: 'The `std::sub_match` class template has predefined specializations to work
    with common string types:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sub_match` 类模板有预定义的特化来与常见的字符串类型一起使用：'
- en: '`std::csub_match` for a `const char*`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::csub_match` 用于 `const char*`'
- en: '`std::wcsub_match` for a `const wchar_t*`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::wcsub_match` 用于 `const wchar_t*`'
- en: '`std::ssub_match` for a `std::string`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ssub_match` 用于 `std::string`'
- en: '`std::wssub_match` for a `std::wstring`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::wssub_match` 用于 `std::wstring`'
- en: Unfortunately, you’ll have to keep track of all these specializations manually
    due to the design of `std::regex_match`. This design generally befuddles newcomers,
    so let’s look at an example. [Listing 15-24](ch15.xhtml#ch15ex24) uses the ZIP
    code regular expression `(\w{2})(\d{5})(-\d{4})?` to match against the strings
    `NJ07936-3173` and `Iomega Zip 100`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你将不得不手动跟踪所有这些特化，因为 `std::regex_match` 的设计。这种设计通常会让新手感到困惑，因此让我们来看一个例子。[列表
    15-24](ch15.xhtml#ch15ex24) 使用 ZIP 代码正则表达式 `(\w{2})(\d{5})(-\d{4})?` 来匹配字符串 `NJ07936-3173`
    和 `Iomega Zip 100`。
- en: '[PRE26]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 15-24: A `regex_match` attempts to match a `regex` to a `string`.*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-24：`regex_match` 尝试将 `regex` 匹配到 `string`。*'
- en: You construct a `regex` with the raw literal `R"((\w{2})(\d{5})(-\d{4})?)"`
    ➊ and default construct an `smatch` ➋. In the first test, you `regex_match` the
    valid ZIP code `NJ07936-3173` ➌, which returns the `true` value `matched` to indicate
    success ➍. Because you provide an `smatch` to `regex_match`, it contains the valid
    ZIP code as the first element ➎, followed by each of the three subgroups ➏.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个带有原始文字的 `regex`：`R"((\w{2})(\d{5})(-\d{4})?)"` ➊，并默认构造了一个 `smatch` ➋。在第一次测试中，你用
    `regex_match` 对有效的 ZIP 代码 `NJ07936-3173` ➌ 进行匹配，返回 `true` 值 `matched` 以表示成功 ➍。因为你为
    `regex_match` 提供了一个 `smatch`，它将有效的 ZIP 代码作为第一个元素 ➎，接着是每个子组 ➏。
- en: In the second test, you `regex_match` the invalid ZIP code `Iomega Zip 100`
    ➐, which fails to match and returns `false` ➑.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次测试中，你使用 `regex_match` 对无效的 ZIP 代码 `Iomega Zip 100` ➐ 进行匹配，匹配失败并返回 `false`
    ➑。
- en: '**Searching**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**搜索**'
- en: '*Searching* attempts to match a regular expression to a *part* of a string.
    The STL provides the `std::regex_search` function for searching, which is essentially
    a replacement for `regex_match` that succeeds even when only a part of a string
    matches a `regex`.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*搜索* 尝试将正则表达式匹配到字符串的 *一部分*。STL 提供了 `std::regex_search` 函数用于搜索，它本质上是 `regex_match`
    的替代方案，即使只有字符串的一部分匹配 `regex`，它也会成功。'
- en: For example, `The string NJ07936-3173 is a ZIP Code.` contains a ZIP code. But
    applying the ZIP regular expression to it using `std::regex_match` will return
    `false` because the `regex` doesn’t match the *entire* string. However, applying
    `std::regex_search` instead would yield `true` because the string embeds a valid
    ZIP code. [Listing 15-25](ch15.xhtml#ch15ex25) illustrates `regex_match` and `regex_search`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串 `The string NJ07936-3173 is a ZIP Code.` 包含一个 ZIP 代码。但使用 `std::regex_match`
    对其应用 ZIP 正则表达式将返回 `false`，因为 `regex` 没有匹配到 *整个* 字符串。然而，使用 `std::regex_search`
    会返回 `true`，因为字符串中嵌入了有效的 ZIP 代码。[列表 15-25](ch15.xhtml#ch15ex25) 演示了 `regex_match`
    和 `regex_search` 的使用。
- en: '[PRE27]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 15-25: Comparing `regex_match` and `regex_search`*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-25：比较 `regex_match` 和 `regex_search`*'
- en: As before, you construct the ZIP `regex` ➊. You also construct the example string
    `sentence`, which embeds a valid ZIP code ➋. The first test calls `regex_``match`
    with `sentence` and `regex`, which returns `false` ➌. The second test instead
    calls `regex_search` with the same arguments and returns `true` ➍.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你构造了 ZIP `regex` ➊。你还构造了示例字符串 `sentence`，其中嵌入了有效的 ZIP 代码 ➋。第一个测试使用 `regex_match`
    对 `sentence` 和 `regex` 进行匹配，返回 `false` ➌。第二个测试则调用 `regex_search`，使用相同的参数，返回 `true`
    ➍。
- en: '**Replacing**'
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**替换**'
- en: '*Replacing* substitutes regular expression occurrences with replacement text.
    The STL provides the `std::regex_replace` function for replacing.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 将正则表达式匹配的内容替换为替换文本。STL 提供了 `std::regex_replace` 函数来进行替换。'
- en: 'In its most basic usage, you pass `regex_replace` three arguments:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的用法中，你传递给 `regex_replace` 三个参数：
- en: A source `string`/C-string/half-open range to search
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个源 `string`/C-string/半开区间进行搜索
- en: A regular expression
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正则表达式
- en: A replacement string
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个替换字符串
- en: As an example, [Listing 15-26](ch15.xhtml#ch15ex26) replaces all the vowels
    in the phrase `queue``ing and cooeeing in eutopia` with underscores (`_`).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 15-26](ch15.xhtml#ch15ex26)将短语 `queueing and cooeeing in eutopia` 中的所有元音字母替换为下划线（`_`）。
- en: '[PRE28]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 15-26: Using `std::regex_replace` to substitute underscores for vowels
    in a `string`*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-26：使用 `std::regex_replace` 将元音字母替换为下划线*'
- en: You construct a `std::regex` that contains the set of all vowels ➊ and a `string`
    called `phrase` containing the vowel-rich contents `queueing and cooeeing in eutopia`
    ➋. Next, you invoke `std::regex_replace` with `phrase`, the regex, and the string
    literal `_` ➌, which replaces all vowels with underscores ➍.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个包含所有元音字母集合 ➊ 的 `std::regex`，并且创建一个名为 `phrase` 的 `string`，其中包含元音丰富的内容 `queueing
    and cooeeing in eutopia` ➋。接着，你调用 `std::regex_replace`，传入 `phrase`、正则表达式和字符串字面量
    `_` ➌，它将所有元音字母替换为下划线 ➍。
- en: '**NOTE**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost Regex provides regular expression support mirroring the STL’s in the
    `<boost/regex.hpp>` header. Another Boost library, Xpressive, offers an alternative
    approach with regular expressions that you can express directly in C++ code. It
    has some major advantages, such as expressiveness and compile-time syntax checking,
    but the syntax necessarily diverges from standard regular expression syntaxes
    like POSIX, Perl, and ECMAScript.*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost Regex 提供了与 STL 在 `<boost/regex.hpp>` 头文件中的正则表达式支持相对应的功能。另一个 Boost 库，Xpressive，提供了一种替代方法，可以直接在
    C++ 代码中表达正则表达式。它具有一些主要优点，如表达能力和编译时语法检查，但其语法不可避免地与标准的正则表达式语法（如 POSIX、Perl 和 ECMAScript）有所不同。*'
- en: '**Boost String Algorithms**'
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost 字符串算法**'
- en: Boost’s String Algorithms library offers a bounty of `string` manipulation functions.
    It contains functions for common tasks related to `string`, such as trimming,
    case conversion, finding/replacing, and evaluating characteristics. You can access
    all the Boost String Algorithms functions in the `boost::algorithm` namespace
    and in the `<boost/algorithm/string.hpp>` convenience header.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 的字符串算法库提供了丰富的 `string` 操作函数。它包含了常见的字符串处理任务的函数，例如修剪、大小写转换、查找/替换和评估特征。你可以在
    `boost::algorithm` 命名空间和 `<boost/algorithm/string.hpp>` 便捷头文件中访问所有 Boost 字符串算法函数。
- en: '***Boost Range***'
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boost Range***'
- en: '*Range* is a concept (in the [Chapter 6](ch06.xhtml#ch06) compile-time polymorphism
    sense of the word) that has a beginning and an end that allow you to iterate over
    constituent elements. The range aims to improve the practice of passing a half-open
    range as a pair of iterators. By replacing the pair with a single object, you
    can *compose* algorithms together by using the range result of one algorithm as
    the input to another. For example, if you wanted to transform a range of strings
    to all uppercase and sort them, you could pass the results of one operation directly
    into the other. This is not generally possible to do with iterators alone.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*是一个概念（在[第6章](ch06.xhtml#ch06)编译时多态性的意义上），它有一个起点和终点，允许你遍历其中的元素。范围旨在改进传递半开范围作为一对迭代器的做法。通过将这对迭代器替换为一个单一对象，你可以*组合*算法，通过使用一个算法的范围结果作为另一个算法的输入。例如，如果你想将一系列字符串转换为全大写并对它们进行排序，你可以将一个操作的结果直接传递给另一个。这种操作单独使用迭代器通常是无法做到的。'
- en: Ranges are not currently part of the C++ standard, but several experimental
    implementations exist. One such implementation is Boost Range, and because Boost
    String Algorithms uses Boost Range extensively, let’s look at it now.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 范围目前还不是 C++ 标准的一部分，但已有多个实验性实现。其中一个实现是 Boost Range，并且由于 Boost 字符串算法广泛使用 Boost
    Range，现在我们来了解一下它。
- en: 'The Boost Range concept is like the STL container concept. It provides the
    usual complement of `begin`/`end` methods to expose iterators over the elements
    in the range. Each range has a *traversal category*, which indicates the range’s
    supported operations:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Range 概念类似于 STL 容器概念。它提供了常见的 `begin`/`end` 方法，用于暴露范围内元素的迭代器。每个范围都有一个*遍历类别*，它指示范围支持的操作：
- en: A *single-pass range* allows one-time, forward iteration.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*单向范围*允许一次性、正向迭代。
- en: A *forward range* allows (unlimited) forward iteration and satisfies single-pass
    range.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*正向范围*允许（无限次）正向迭代，并满足单向范围的要求。
- en: A *bidirectional range* allows forward and backward iteration and satisfies
    forward range.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*双向范围*允许正向和反向迭代，并满足正向范围的要求。
- en: A *random-access range* allows arbitrary element access and satisfies bidirectional
    range.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*随机访问范围*允许任意元素访问，并满足双向范围的要求。
- en: Boost String Algorithms is designed for `std::string`, which satisfies the random-access
    range concept. For the most part, the fact that Boost String Algorithms accepts
    Boost Range rather than `std::string` is a totally transparent abstraction to
    users. When reading the documentation, you can mentally substitute `Range` with
    `string`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 字符串算法是为 `std::string` 设计的，它满足随机访问范围的概念。在大多数情况下，Boost 字符串算法接受 Boost Range
    而不是 `std::string` 对用户来说是完全透明的抽象。在阅读文档时，你可以将 `Range` 心理上替换为 `string`。
- en: '***Predicates***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***谓词***'
- en: Boost String Algorithms incorporates predicates extensively. You can use them
    directly by bringing in the `<boost/algorithm/string/predicate.hpp>` header. Most
    of the predicates contained in this header accept two ranges, `r1` and `r2`, and
    return a `bool` based on their relationship. The predicate `starts_with`, for
    example, returns `true` if `r1` begins with `r2`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 字符串算法广泛地集成了谓词。你可以通过引入 `<boost/algorithm/string/predicate.hpp>` 头文件直接使用它们。这个头文件中的大多数谓词接受两个范围
    `r1` 和 `r2`，并根据它们之间的关系返回 `bool`。例如，谓词 `starts_with` 如果 `r1` 以 `r2` 开头，则返回 `true`。
- en: Each predicate has a case-insensitive version, which you can use by prepending
    the letter `i` to the method name, such as `istarts_with`. [Listing 15-27](ch15.xhtml#ch15ex27)
    illustrates `starts_with` and `istarts_with`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每个谓词都有一个不区分大小写的版本，你可以通过在方法名前加字母 `i` 来使用，如 `istarts_with`。[列表 15-27](ch15.xhtml#ch15ex27)
    演示了 `starts_with` 和 `istarts_with`。
- en: '[PRE29]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 15-27: Both `starts_with` and `istarts_with` check a range’s beginning
    characters.*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-27：`starts_with` 和 `istarts_with` 都检查范围的起始字符。*'
- en: You initialize a `string` containing `cymotrichous` ➊. The first test shows
    that `starts_with` returns `true` when with `word` and `cymo` ➋. The case-insensitive
    version `istarts_with` also returns `true` given `word` and `cYmO` ➌.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化一个包含 `cymotrichous` 的 `string` ➊。第一次测试显示，当使用 `word` 和 `cymo` ➋ 时，`starts_with`
    返回 `true`。不区分大小写的版本 `istarts_with` 在使用 `word` 和 `cYmO` ➌ 时也返回 `true`。
- en: Note that `<boost/algorithm/string/predicate.hpp>` also contains an `all` predicate,
    which accepts a single range `r` and a predicate `p`. It returns `true` if `p`
    evaluates to `true` for all elements of `r`, as [Listing 15-28](ch15.xhtml#ch15ex28)
    illustrates.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<boost/algorithm/string/predicate.hpp>` 还包含一个 `all` 谓词，它接受一个范围 `r` 和一个谓词
    `p`。如果 `p` 对 `r` 中的所有元素计算结果为 `true`，则返回 `true`，正如 [列表 15-28](ch15.xhtml#ch15ex28)
    所示。
- en: '[PRE30]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 15-28: The `all` predicate evaluates if all elements in a range satisfy
    a predicate.*'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-28：`all` 谓词评估范围内所有元素是否满足谓词。*'
- en: You initialize a string containing `juju` ➊, which you pass to `all` as the
    range ➋. You pass a lambda predicate, which returns `true` for the letters `j`
    and `u` ➌. Because `juju` contains only these letters, `all` returns `true`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化一个包含 `juju` 的字符串 ➊，并将其作为范围 ➋ 传递给 `all`。你传递一个 lambda 谓词，它对字母 `j` 和 `u` 返回
    `true` ➌。因为 `juju` 只包含这些字母，`all` 返回 `true`。
- en: '[Table 15-12](ch15.xhtml#ch15tab12) lists the predicates available in `<boost/algorithm/string/predicate.hpp>`.In
    this table, `r, r1`, and `r2` are string ranges, and `p` is an element comparison
    predicate.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-12](ch15.xhtml#ch15tab12) 列出了 `<boost/algorithm/string/predicate.hpp>`
    中可用的谓词。在此表中，`r, r1` 和 `r2` 是字符串范围，`p` 是元素比较谓词。'
- en: '**Table 15-12:** Predicates in the Boost String Algorithms Library'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-12：** Boost 字符串算法库中的谓词'
- en: '| **Predicate** | **Returns** true **if** |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| **谓词** | **返回** `true` **如果** |'
- en: '| `starts_with(`r1`,` r2`, [`p`])``istarts_with(`r1`,` r2`)` | r1 starts with
    r2; p used for character-wise comparison. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `starts_with(`r1`,` r2`, [`p`])``istarts_with(`r1`,` r2`)` | r1 以 r2 开头；p
    用于逐字符比较。 |'
- en: '| `ends_with(`r1`,` r2`, [`p`])``iends_with(`r1`,` r2`)` | r1 ends with r2;
    p used for character-wise comparison. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `ends_with(`r1`,` r2`, [`p`])``iends_with(`r1`,` r2`)` | r1 以 r2 结尾；p 用于逐字符比较。
    |'
- en: '| `contains(`r1`,` r2`, [`p`])``icontains(`r1`,` r2`)` | r1 contains r2; p
    used for character-wise comparison. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `contains(`r1`,` r2`, [`p`])``icontains(`r1`,` r2`)` | r1 包含 r2；p 用于逐字符比较。
    |'
- en: '| `equals(`r1`,` r2`, [`p`])``iequals(`r1`,` r2) | r1 equals r2; p used for
    character-wise comparison. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `equals(`r1`,` r2`, [`p`])``iequals(`r1`,` r2) | r1 等于 r2；p 用于逐字符比较。 |'
- en: '| `lexicographical_compare(`r1`,` r2`, [`p`])``ilexicographical_compare(`r1`,`
    r2) | r1 lexicographically less than r2; p used for character-wise comparison.
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `lexicographical_compare(`r1`,` r2`, [`p`])``ilexicographical_compare(`r1`,`
    r2) | r1 在字典顺序上小于 r2；p 用于逐字符比较。 |'
- en: '| `all(`r`, [`p`])` | All elements of r return `true` for p. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `all(`r`, [`p`])` | r 的所有元素对于 p 返回 `true`。 |'
- en: Function permutations beginning with `i` are case-insensitive.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `i` 开头的函数变种是不区分大小写的。
- en: '***Classifiers***'
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分类器***'
- en: '*Classifiers* are predicates that evaluate some characteristics about a character.
    The `<boost/algorithm/string/classification.hpp>` header offers generators for
    creating classifiers. A *generator* is a non-member function that acts like a
    constructor. Some generators accept arguments for customizing the classifier.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*分类器* 是评估字符某些特征的谓词。`<boost/algorithm/string/classification.hpp>` 头文件提供了用于创建分类器的生成器。*生成器*
    是一种非成员函数，类似于构造函数。一些生成器接受参数，以自定义分类器。'
- en: '**NOTE**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Of course, you can create your own predicates just as easily with your own
    function objects, like lambdas, but Boost provides a menu of premade classifiers
    for convenience.*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，你也可以像使用自己定义的函数对象（比如 lambda）一样，轻松地创建你自己的谓词，但 Boost 为了方便提供了一些现成的分类器。*'
- en: The `is_alnum` generator, for example, creates a classifier that determines
    whether a character is alphanumeric. [Listing 15-29](ch15.xhtml#ch15ex29) illustrates
    how to use this classifier independently or in conjunction with `all`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_alnum` 生成器，例如，用于创建一个分类器来判断一个字符是否为字母数字字符。[示例 15-29](ch15.xhtml#ch15ex29)
    说明了如何独立使用这个分类器或与 `all` 一起使用。'
- en: '[PRE31]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 15-29: The `is_alum` generator determines whether a character is alphanumeric.*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-29：`is_alum` 生成器判断字符是否为字母数字。*'
- en: Here, you construct a `classifier` from the `is_alnum` generator ➊. The first
    test uses the `classifier` to evaluate that `a` is alphanumeric ➋ and `$` is not
    ➌. Because all classifiers are predicates that operate on characters, you can
    use them in conjunction with the `all` predicate discussed in the previous section
    to determine that `nostarch` contains all alphanumeric characters ➍ and `@nostarch`
    doesn’t ➎.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你从 `is_alnum` 生成器构造一个 `classifier` ➊。第一个测试使用 `classifier` 来评估字符 `a` 是否为字母数字
    ➋，而 `$` 则不是 ➌。由于所有分类器都是作用于字符的谓词，你可以将它们与前一节讨论的 `all` 谓词结合使用，以确定 `nostarch` 是否包含所有字母数字字符
    ➍，而 `@nostarch` 则不包含 ➎。
- en: '[Table 15-13](ch15.xhtml#ch15tab13) lists the character classifications available
    in `<boost/algorithm/string/classification.hpp>`. In this table, `r` is a string
    range, and `beg` and `end` are element comparison predicates.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-13](ch15.xhtml#ch15tab13) 列出了 `<boost/algorithm/string/classification.hpp>`
    中可用的字符分类。在这个表中，`r` 是一个字符串范围，`beg` 和 `end` 是元素比较谓词。'
- en: '**Table 15-13:** Character Predicates in the Boost String Algorithms Library'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-13：** Boost 字符串算法库中的字符谓词'
- en: '| **Predicate** | **Returns** true **if element is . . .** |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **谓词** | **当元素是 . . . 时返回** true |'
- en: '| `is_space` | A space |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `is_space` | 空格 |'
- en: '| `is_alnum` | An alphanumeric character |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `is_alnum` | 字母数字字符 |'
- en: '| `is_alpha` | An alphabetical character |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `is_alpha` | 字母字符 |'
- en: '| `is_cntrl` | A control character |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `is_cntrl` | 控制字符 |'
- en: '| `is_digit` | A decimal digit |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `is_digit` | 十进制数字 |'
- en: '| `is_graph` | A graphical character |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `is_graph` | 图形字符 |'
- en: '| `is_lower` | A lowercase character |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `is_lower` | 小写字母 |'
- en: '| `is_print` | A printable character |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `is_print` | 可打印字符 |'
- en: '| `is_punct` | A punctuation character |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `is_punct` | 标点符号字符 |'
- en: '| `is_upper` | An uppercase character |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `is_upper` | 大写字母 |'
- en: '| `is_xdigit` | A hexadecimal digit |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `is_xdigit` | 十六进制数字 |'
- en: '| `is_any_of(`r`)` | Contained in r |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `is_any_of(`r`)` | 包含在 r 中 |'
- en: '| `is_from_range(`beg`,` end`)` | Contained in the range from beg to end |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `is_from_range(`beg`,` end`)` | 包含在从 beg 到 end 的范围内 |'
- en: '***Finders***'
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找器***'
- en: A *finder* is a concept that determines a position in a range corresponding
    to some specified criteria, usually a predicate or a regular expression. Boost
    String Algorithms provides some generators for producing finders in the `<boost/algorithm/string/finder.hpp>`
    header.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找器* 是一个概念，用来确定范围内与某些特定条件（通常是谓词或正则表达式）匹配的元素位置。Boost 字符串算法库在 `<boost/algorithm/string/finder.hpp>`
    头文件中提供了一些生成器，用于生成查找器。'
- en: For example, the `nth_finder` generator accepts a range `r` and an index `n`,
    and it creates a finder that will search a range (taken as a `begin` and an `end`
    iterator) for the `n`th occurrence of `r`, as [Listing 15-30](ch15.xhtml#ch15ex30)
    illustrates.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`nth_finder` 生成器接受一个范围 `r` 和一个索引 `n`，它创建一个查找器，搜索一个范围（由 `begin` 和 `end` 迭代器表示），查找
    `r` 的第 `n` 次出现，如 [示例 15-30](ch15.xhtml#ch15ex30) 所示。
- en: '[PRE32]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 15-30: The `nth_finder` generator creates a finder that locates the
    *n*th occurrence of a sequence.*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-30：`nth_finder` 生成器创建一个查找器，用于定位一个序列的第 *n* 次出现。*'
- en: You use the `nth_finder` generator to create `finder`, which will locate the
    second instance of `na` in a range (`n` is zero based) ➊. Next, you construct
    `name` containing `Carl Brutananadilewski` ➋ and invoke `finder` with the `begin`
    and `end` iterators of `name` ➌. The `result` is a range whose `begin` points
    to the second *n* in `Brutana``n``adilewski` ➍ and whose `end` points to the first
    *d* in `Brutanana``d``ilewski` ➎.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `nth_finder` 生成器来创建 `finder`，它会定位范围内 `na` 的第二个实例（`n` 是从零开始的） ➊。接下来，你构造一个包含
    `Carl Brutananadilewski` 的 `name` ➋，并使用 `name` 的 `begin` 和 `end` 迭代器调用 `finder`
    ➌。`result` 是一个范围，其 `begin` 指向 `Brutana``n``adilewski` 中第二个 *n* ➍，而 `end` 指向 `Brutanana``d``ilewski`
    中第一个 *d* ➎。
- en: '[Table 15-14](ch15.xhtml#ch15tab14) lists the finders available in `<boost/algorithm/string/finder.hpp>`.
    In this table, `s` is a string, `p` is an element comparison predicate, `n` is
    an integral value, `beg` and `end` are iterators, `rgx` is a regular expression,
    and `r` is a string range.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-14](ch15.xhtml#ch15tab14) 列出了 `<boost/algorithm/string/finder.hpp>` 中可用的查找器。在此表中，`s`
    是字符串，`p` 是元素比较谓词，`n` 是整数值，`beg` 和 `end` 是迭代器，`rgx` 是正则表达式，`r` 是字符串范围。'
- en: '**Table 15-14:** Finders in the Boost String Algorithms Library'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-14：** Boost 字符串算法库中的查找器'
- en: '| **Generator** | **Creates a finder that, when invoked, returns . . .** |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| **生成器** | **创建一个查找器，当被调用时返回...** |'
- en: '| `first_finder(`s`,` p`)` | The first element matching s using p |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `first_finder(`s`,` p`)` | 使用 p 查找匹配 s 的第一个元素 |'
- en: '| `last_finder(`s`,` p) | The last element matching s using p |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `last_finder(`s`,` p)` | 使用 p 查找匹配 s 的最后一个元素 |'
- en: '| `nth_finder(`s`,` p`,` n`)` | The nth element matching s using p |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `nth_finder(`s`,` p`,` n`)` | 使用 p 查找匹配 s 的第 n 个元素 |'
- en: '| `head_finder(`n`)` | The first n elements |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `head_finder(`n`)` | 前 n 个元素 |'
- en: '| `tail_finder(`n`)` | the last n elements |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `tail_finder(`n`)` | 后 n 个元素 |'
- en: '| `token_finder(`p`)` | The character matching p |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `token_finder(`p`)` | 匹配 p 的字符 |'
- en: '| `range_finder(`r`)``range_finder(`beg`,` end`)` | r regardless of input |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `range_finder(`r`)``range_finder(`beg`,` end`)` | 不考虑输入，始终返回 r |'
- en: '| `regex_finder(`rgx`)` | The first substring matching rgx |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `regex_finder(`rgx`)` | 匹配 rgx 的第一个子字符串 |'
- en: '**NOTE**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost String Algorithms specifies a formatter concept, which presents the
    results of a finder to a replace algorithm. Only an advanced user will need these
    algorithms. Refer to the documentation for the `find_format` algorithms in the
    `<boost/algorithm/string/find_format.hpp>` header for more information.*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 字符串算法指定了一个格式化器概念，它将查找器的结果呈现给替换算法。只有高级用户才需要这些算法。更多信息，请参考 `<boost/algorithm/string/find_format.hpp>`
    头文件中的 `find_format` 算法文档。*'
- en: '***Modifying Algorithms***'
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改算法***'
- en: Boost contains a *lot* of algorithms for modifying a `string` (range). Between
    the `<boost/algorithm/string/case_conv.hpp>``, <boost/algorithm/string/trim.hpp>`,
    and `<boost/algorithm/string/replace.hpp>` headers, algorithms exist to convert
    case, trim, replace, and erase many different ways.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 包含了许多用于修改 `string`（范围）的算法。在 `<boost/algorithm/string/case_conv.hpp>`、`<boost/algorithm/string/trim.hpp>`
    和 `<boost/algorithm/string/replace.hpp>` 头文件中，存在将大小写转换、修剪、替换和删除多种不同方式的算法。
- en: For example, the `to_upper` function will convert all of a string’s letters
    to uppercase. If you want to keep the original unmodified, you can use the `to_upper_copy`
    function, which will return a new object. [Listing 15-31](ch15.xhtml#ch15ex31)
    illustrates `to_upper` and `to_upper_copy`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`to_upper` 函数将把字符串中的所有字母转换为大写。如果你想保持原始字符串不变，可以使用 `to_upper_copy` 函数，它会返回一个新的对象。[示例
    15-31](ch15.xhtml#ch15ex31) 说明了 `to_upper` 和 `to_upper_copy`。
- en: '[PRE33]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 15-31: Both `to_upper` and `to_upper_copy` convert the case of a `string`.*'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-31：`to_upper` 和 `to_upper_copy` 都会将 `string` 的字母转换为大写。*'
- en: You create a `string` called `powers` ➊. The first test invokes `to_upper` on
    `powers` ➋, which modifies it in place to contain all uppercase letters ➌. The
    second test uses the `_copy` variant to create a new `string` called `result`
    ➍. The `powers` string is unaffected ➎, whereas `result` contains an all uppercase
    version ➏.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为 `powers` 的 `string` ➊。第一次测试调用 `to_upper` 函数作用于 `powers` ➋，它会原地修改 `powers`，使其包含所有大写字母
    ➌。第二次测试使用 `_copy` 变体，创建一个名为 `result` 的新 `string` ➍。此时，`powers` 字符串不受影响 ➎，而 `result`
    包含一个全大写的版本 ➏。
- en: Some Boost String Algorithms, such as `replace_first`, also have case-insensitive
    versions. Just prepend an `i`, and matching will proceed regardless of case. For
    algorithms like `replace_first` that also have `_copy` variants, any permutation
    will work (`replace_first`, `ireplace_first``, replace_first_copy`, and `ireplace_first_copy`).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Boost 字符串算法，例如 `replace_first`，也有不区分大小写的版本。只需在前面加上 `i`，匹配将不受大小写限制。对于像 `replace_first`
    这样的算法，它们还有 `_copy` 变种，任何排列组合都能正常工作（`replace_first`、`ireplace_first`、`replace_first_copy`
    和 `ireplace_first_copy`）。
- en: The `replace_first` algorithm and its variants accept an input range `s`, a
    match range `m`, and a replace range `r`, and replaces the first instance of `m`
    in `s` with `r`. [Listing 15-32](ch15.xhtml#ch15ex32) illustrates `replace_first`
    and `i_replace_first`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace_first` 算法及其变种接受输入范围 `s`、匹配范围 `m` 和替换范围 `r`，并将 `s` 中第一个匹配 `m` 的实例替换为
    `r`。[列表 15-32](ch15.xhtml#ch15ex32) 说明了 `replace_first` 和 `i_replace_first`。'
- en: '[PRE34]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 15-32: Both `replace_first` and `i_replace_first` replace matching
    `string` sequences.*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-32：`replace_first` 和 `i_replace_first` 都会替换匹配的 `string` 序列。*'
- en: Here, you construct a `string` called `publisher` containing `No Starch Press`
    ➊. The first test invokes `replace_first` with `publisher` as the input string,
    `No` as the match string, and `Medium` as the replacement string ➋. Afterward,
    `publisher` contains `Medium Starch Press` ➌. The second test uses the `ireplace_first_copy`
    variant, which is case insensitive and performs a copy. You pass `NO` and `MEDIUM`
    as the match and replace strings ➍, respectively, and the `result` contains `MEDIUM
    Starch Press` ➏, whereas `publisher` is unaffected ➎.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个名为 `publisher` 的 `string`，其值为 `No Starch Press` ➊。第一个测试调用 `replace_first`，以
    `publisher` 作为输入字符串，`No` 作为匹配字符串，`Medium` 作为替换字符串 ➋。随后，`publisher` 的值变为 `Medium
    Starch Press` ➌。第二个测试使用不区分大小写并执行复制的 `ireplace_first_copy` 变种。你分别将 `NO` 和 `MEDIUM`
    作为匹配和替换字符串 ➍，此时 `result` 包含 `MEDIUM Starch Press` ➏，而 `publisher` 不受影响 ➎。
- en: '[Table 15-15](ch15.xhtml#ch15tab15) lists many of the modifying algorithms
    available in Boost String Algorithms. In this table, `r, s, s1`, and `s2` are
    strings; `p` is an element comparison predicate; `n` is an integral value; and
    `rgx` is a regular expression.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-15](ch15.xhtml#ch15tab15) 列出了 Boost 字符串算法中许多可用的修改算法。在这个表格中，`r`、`s`、`s1`
    和 `s2` 是字符串；`p` 是元素比较谓词；`n` 是整数值；`rgx` 是正则表达式。'
- en: '**Table 15-15:** Modifying Algorithms in the Boost String Algorithms Library'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-15：** Boost 字符串算法库中的修改算法'
- en: '| **Algorithm** | **Description** |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| `to_upper(`s`)``to_upper_copy(`s`)` | Converts s to all uppercase |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `to_upper(`s`)``to_upper_copy(`s`)` | 将 s 转换为全大写 |'
- en: '| `to_lower(`s`)``to_lower_copy(`s`)` | Converts s to all lowercase |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `to_lower(`s`)``to_lower_copy(`s`)` | 将 s 转换为全小写 |'
- en: '| `trim_left_copy_if(`s`, [`p`])``trim_left_if(`s`, [`p`])``trim_left_copy(`s`)``trim_left(`s`)`
    | Removes leading spaces from s |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `trim_left_copy_if(`s`, [`p`])``trim_left_if(`s`, [`p`])``trim_left_copy(`s`)``trim_left(`s`)`
    | 移除 s 中的前导空格 |'
- en: '| `trim_right_copy_if(`s`, [`p`])``trim_right_if(`s`, [`p`])``trim_right_copy(`s`)``trim_right(`s`)`
    | Removes trailing spaces from s |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `trim_right_copy_if(`s`, [`p`])``trim_right_if(`s`, [`p`])``trim_right_copy(`s`)``trim_right(`s`)`
    | 移除 s 中的尾随空格 |'
- en: '| `trim_copy_if(`s`, [`p`])``trim_if(`s`, [`p`])``trim_copy(`s`)``trim(`s`)`
    | Removes leading and trailing spaces from s |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `trim_copy_if(`s`, [`p`])``trim_if(`s`, [`p`])``trim_copy(`s`)``trim(`s`)`
    | 移除 s 中的前导和尾随空格 |'
- en: '| `replace_first(`s1`,` s2`,` r`)``replace_first_copy(`s1`,` s2`,` r`)``ireplace_first(`s1`,`
    s2`,` r`)``ireplace_first_copy(`s1`,` s2`,` r`)` | Replaces the first occurrence
    of s2 in s1 with r |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `replace_first(`s1`,` s2`,` r`)``replace_first_copy(`s1`,` s2`,` r`)``ireplace_first(`s1`,`
    s2`,` r`)``ireplace_first_copy(`s1`,` s2`,` r`)` | 将 s1 中第一个出现的 s2 替换为 r |'
- en: '| `erase_first(`s1`,` s2`)``erase_first_copy(`s1`,` s2`)``ierase_first(`s1`,`
    s2`)``ierase_first_copy(`s1`,` s2`)` | Erases the first occurrence of s2 in s1
    |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `erase_first(`s1`,` s2`)``erase_first_copy(`s1`,` s2`)``ierase_first(`s1`,`
    s2`)``ierase_first_copy(`s1`,` s2`)` | 删除 s1 中第一个出现的 s2 |'
- en: '| `replace_last(`s1`,` s2`,` r`)``replace_last_copy(`s1`,` s2`,` r`)``ireplace_last(`s1`,`
    s2`,` r`)``ireplace_last_copy(`s1`,` s2`,` r`)` | Replaces the last occurrence
    of s2 in s1 with r |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `replace_last(`s1`,` s2`,` r`)``replace_last_copy(`s1`,` s2`,` r`)``ireplace_last(`s1`,`
    s2`,` r`)``ireplace_last_copy(`s1`,` s2`,` r`)` | 将 s1 中最后一个出现的 s2 替换为 r |'
- en: '| `erase_last(`s1`,` s2`)``erase_last_copy(`s1`,` s2`)``ierase_last(`s1`,`
    s2`)``ierase_last_copy(`s1`,` s2`)` | Erases the last occurrence of s2 in s1 |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `erase_last(`s1`,` s2`)``erase_last_copy(`s1`,` s2`)``ierase_last(`s1`,`
    s2`)``ierase_last_copy(`s1`,` s2`)` | 删除 s1 中最后一个出现的 s2 |'
- en: '| `replace_nth(`s1`,` s2`,` n`,` r`)``replace_nth_copy(`s1`,` s2`,` n`,` r`)``ireplace_nth(`s1`,`
    s2`,` n`,` r`)``ireplace_nth_copy(`s1`,` s2`,` n`,` r`)` | Replaces the nth occurrence
    of s2 in s1 with r |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `replace_nth(`s1`,` s2`,` n`,` r`)``replace_nth_copy(`s1`,` s2`,` n`,` r`)``ireplace_nth(`s1`,`
    s2`,` n`,` r`)``ireplace_nth_copy(`s1`,` s2`,` n`,` r`)` | 替换 s1 中第 n 次出现的 s2
    为 r |'
- en: '| `erase_nth(`s1`,` s2`,` n`)``erase_nth_copy(`s1`,` s2`,` n`)``ierase_nth(`s1`,`
    s2`,` n`)``ierase_nth_copy(`s1`,` s2`,` n`)` | Erases the nth occurrence of s2
    in s1 |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `erase_nth(`s1`,` s2`,` n`)``erase_nth_copy(`s1`,` s2`,` n`)``ierase_nth(`s1`,`
    s2`,` n`)``ierase_nth_copy(`s1`,` s2`,` n`)` | 删除 s1 中第 n 次出现的 s2 |'
- en: '| `replace_all(`s1`,` s2`,` r`)``replace_all_copy(`s1`,` s2`,` r`)``ireplace_all(`s1`,`
    s2`,` r`)``ireplace_all_copy(`s1`,` s2`,` r`)` | Replaces all occurrences of s2
    in s1 with r |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `replace_all(`s1`,` s2`,` r`)``replace_all_copy(`s1`,` s2`,` r`)``ireplace_all(`s1`,`
    s2`,` r`)``ireplace_all_copy(`s1`,` s2`,` r`)` | 用 r 替换 s1 中所有 s2 的出现 |'
- en: '| `erase_all(`s1`,` s2`)``erase_all_copy(`s1`,` s2`)``ierase_all(`s1`,` s2`)``ierase_all_copy(`s1`,`
    s2`)` | Erases all occurrences of s2 in s1 |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `erase_all(`s1`,` s2`)``erase_all_copy(`s1`,` s2`)``ierase_all(`s1`,` s2`)``ierase_all_copy(`s1`,`
    s2`)` | 删除 s1 中所有 s2 的出现 |'
- en: '| `replace_head(`s`,` n`,` r`)``replace_head_copy(`s`,` n`,` r`)` | Replaces
    the first n characters of s with r |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `replace_head(`s`,` n`,` r`)``replace_head_copy(`s`,` n`,` r`)` | 用 r 替换
    s 的前 n 个字符 |'
- en: '| `erase_head(`s`,` n`)``erase_head_copy(`s`,` n`)` | Erases the first n characters
    of s |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `erase_head(`s`,` n`)``erase_head_copy(`s`,` n`)` | 删除 s 的前 n 个字符 |'
- en: '| `replace_tail(`s`,` n`,` r`)``replace_tail_copy(`s`,` n`,` r`)` | Replaces
    the last n characters of s with r |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `replace_tail(`s`,` n`,` r`)``replace_tail_copy(`s`,` n`,` r`)` | 用 r 替换
    s 的最后 n 个字符 |'
- en: '| `erase_tail(`s`,` n`)``erase_tail_copy(`s`,` n`)` | Erases the last n characters
    of s |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `erase_tail(`s`,` n`)``erase_tail_copy(`s`,` n`)` | 删除 s 的最后 n 个字符 |'
- en: '| `replace_regex(`s`,` rgx`,` r`)``replace_regex_copy(`s`,` rgx`,` r`)` | Replaces
    the first instance of rgx in s with r |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `replace_regex(`s`,` rgx`,` r`)``replace_regex_copy(`s`,` rgx`,` r`)` | 替换
    s 中 rgx 的第一次出现为 r |'
- en: '| `erase_regex(`s`,` rgx`)``erase_regex_copy(`s`,` rgx`)` | Erases the first
    instance of rgx in s |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `erase_regex(`s`,` rgx`)``erase_regex_copy(`s`,` rgx`)` | 删除 s 中 rgx 的第一次出现
    |'
- en: '| `replace_all_regex(`s`,` rgx`,` r`)``replace_all_regex_copy(`s`,` rgx`,`
    r`)` | Replaces all instances of rgx in s with r |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `replace_all_regex(`s`,` rgx`,` r`)``replace_all_regex_copy(`s`,` rgx`,`
    r`)` | 替换 s 中所有 rgx 的实例为 r |'
- en: '| `erase_all_regex(`s`,` rgx`)``erase_all_regex_copy(`s`,` rgx`)` | Erases
    all instances of rgx in s |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `erase_all_regex(`s`,` rgx`)``erase_all_regex_copy(`s`,` rgx`)` | 删除 s 中所有
    rgx 的实例 |'
- en: '***Splitting and Joining***'
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拆分与连接***'
- en: Boost String Algorithms contains functions for splitting and joining strings
    in the `<boost/algorithm/string/split.hpp>` and `<boost/algorithm/string/join.``hpp>`
    headers.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 字符串算法包含用于拆分和连接字符串的函数，分别位于 `<boost/algorithm/string/split.hpp>` 和 `<boost/algorithm/string/join.hpp>`
    头文件中。
- en: To split a `string`, you provide the `split` function with an STL container
    `res`, a range `s`, and a predicate `p`. It will tokenize the range `s` using
    the predicate `p` to determine delimiters and insert the results into `res`. [Listing
    15-33](ch15.xhtml#ch15ex33) illustrates the `split` function.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 要拆分一个 `string`，你需要提供 `split` 函数一个 STL 容器 `res`、一个范围 `s` 和一个谓词 `p`。它将使用谓词 `p`
    来确定分隔符，并将结果插入到 `res` 中。 [列表 15-33](ch15.xhtml#ch15ex33) 演示了 `split` 函数。
- en: '[PRE35]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 15-33: The `split` function tokenizes a `string`.*'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-33：`split` 函数将一个 `string` 拆分成多个标记。*'
- en: Armed again with `publisher` ➊, you create a `vector` called `tokens` to contain
    the results ➋. You invoke `split` with `tokens` as the results container, `publisher`
    as the range, and an `is_space` as your predicate ➌. This splits the publisher
    into pieces by spaces. Afterward, `tokens` contains `No, Starch`, and `Press`
    as expected ➍.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `publisher` ➊，你创建一个名为 `tokens` 的 `vector` 来存储结果 ➋。你调用 `split`，将 `tokens`
    作为结果容器，`publisher` 作为范围，`is_space` 作为你的谓词 ➌。这将把 publisher 按空格拆分。之后，`tokens` 包含
    `No, Starch` 和 `Press`，正如预期的那样 ➍。
- en: You can perform the inverse operation with `join`, which accepts an STL container
    `seq` and a separator string `sep`. The `join` function will bind each element
    of `seq` together with `sep` between each.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `join` 执行逆操作，它接受一个 STL 容器 `seq` 和一个分隔符字符串 `sep`。`join` 函数会将 `seq` 中的每个元素与
    `sep` 分隔符连接在一起。
- en: '[Listing 15-34](ch15.xhtml#ch15ex34) illustrates the utility of `join` and
    the indispensability of the Oxford comma.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-34](ch15.xhtml#ch15ex34) 演示了 `join` 函数的实用性以及牛津逗号的不可或缺性。'
- en: '[PRE36]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 15-34: The `join` function attaches `string` tokens together with
    a separator.*'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-34：`join` 函数将 `string` 标记与分隔符连接在一起。*'
- en: You instantiate a `vector` called `tokens` with three `string` objects ➊. Next,
    you use `join` to bind token’s constituent elements together with a comma followed
    by a space ➋. The result is a single `string` containing the constituent elements
    bound together with commas and spaces ➌.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你实例化了一个名为 `tokens` 的 `vector`，包含三个 `string` 对象 ➊。接着，你使用 `join` 将 token 的构成元素用逗号和空格连接在一起
    ➋。结果是一个单一的 `string`，其中包含了通过逗号和空格连接的构成元素 ➌。
- en: '[Table 15-16](ch15.xhtml#ch15tab16) lists many of the split/join algorithms
    available in `<boost/algorithm/string/split.hpp>` and `<boost/algorithm/string/join.hpp>`.
    In this table, `res, s, s1`, `s2`, and `sep` are strings; `seq` is a range of
    strings; `p` is an element comparison predicate; and `rgx` is a regular expression.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-16](ch15.xhtml#ch15tab16)列出了 `<boost/algorithm/string/split.hpp>` 和 `<boost/algorithm/string/join.hpp>`
    中提供的许多拆分/连接算法。在此表中，`res, s, s1`, `s2` 和 `sep` 是字符串；`seq` 是字符串的范围；`p` 是元素比较谓词；`rgx`
    是正则表达式。'
- en: '**Table 15-16:** `split` and `join` Algorithms in the Boost String Algorithms
    Library'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-16：** Boost 字符串算法库中的 `split` 和 `join` 算法'
- en: '| **Function** | **Description** |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `find_all(`res`,` s1`,` s2`)``ifind_all(`res`,` s1`,` s2`)``find_all_regex(`res`,`
    s1`,` rgx`)``iter_find(`res`,` s1`,` s2`)` | Finds all instances of s2 or rgx
    in s1, writing each into res |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `find_all(`res`,` s1`,` s2`)``ifind_all(`res`,` s1`,` s2`)``find_all_regex(`res`,`
    s1`,` rgx`)``iter_find(`res`,` s1`,` s2`)` | 查找 s1 中所有出现的 s2 或 rgx，将每个结果写入 res
    |'
- en: '| `split(`res`,` s`,` p`)``split_regex(`res`,` s`,` rgx`)``iter_split(`res`,`
    s`,` s2`)` | Split s using p, rgx, or s2, writing tokens into res |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| `split(`res`,` s`,` p`)``split_regex(`res`,` s`,` rgx`)``iter_split(`res`,`
    s`,` s2`)` | 使用 p、rgx 或 s2 拆分 s，并将结果写入 res |'
- en: '| `join(`seq`,` sep`)` | Returns a `string` joining seq using sep as a separator
    |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `join(`seq`,` sep`)` | 返回一个 `string`，使用 sep 作为分隔符连接 seq 中的元素 |'
- en: '| `join_if(`seq`,` sep`,` p`)` | Returns a `string` joining all elements of
    seq matching p using sep as a separator |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `join_if(`seq`,` sep`,` p`)` | 返回一个 `string`，连接 seq 中所有匹配 p 的元素，并使用 sep 作为分隔符
    |'
- en: '***Searching***'
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找***'
- en: Boost String Algorithms offers a handful of functions for searching ranges in
    the `<boost/algorithm/string/find.hpp>` header. These are essentially convenient
    wrappers around the finders in [Table 15-8](ch15.xhtml#ch15tab08).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 字符串算法在 `<boost/algorithm/string/find.hpp>` 头文件中提供了许多查找范围的函数。这些函数本质上是 [表
    15-8](ch15.xhtml#ch15tab08) 中查找器的便捷封装。
- en: For example, the `find_head` function accepts a range `s` and a length `n`,
    and it returns a range containing the first `n` elements of `s`. [Listing 15-35](ch15.xhtml#ch15ex35)
    illustrates the `find_head` function.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`find_head` 函数接受一个范围 `s` 和一个长度 `n`，并返回一个包含 `s` 的前 `n` 个元素的范围。[示例 15-35](ch15.xhtml#ch15ex35)
    演示了 `find_head` 函数的用法。
- en: '[PRE37]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 15-35: The `find_head` function creates a range from the beginning
    of a `string`.*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-35：`find_head` 函数从 `string` 的开头创建一个范围。*'
- en: You construct a `string` called `word` containing `blandishment` ➊. You pass
    it into `find_head` along with the length argument `5` ➋. The `begin` of `result`
    points to the beginning of `word` ➌, and its `end` points to 1 past the fifth
    element ➍.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建了一个名为 `word` 的 `string`，其中包含 `blandishment` ➊。然后，你将它和长度参数 `5` 一起传递给 `find_head`
    ➋。`result` 的 `begin` 指向 `word` 的开始位置 ➌，`end` 指向第五个元素之后的位置 ➍。
- en: '[Table 15-17](ch15.xhtml#ch15tab17) lists many of the find algorithms available
    in `<boost/algorithm/string/find.hpp>`. In this table, `s, s1`, and `s2` are strings;
    `p` is an element comparison predicate; `rgx` is a regular expression; and `n`
    is an integral value.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-17](ch15.xhtml#ch15tab17)列出了 `<boost/algorithm/string/find.hpp>` 中提供的许多查找算法。在此表中，`s,
    s1` 和 `s2` 是字符串；`p` 是元素比较谓词；`rgx` 是正则表达式；`n` 是一个整数值。'
- en: '**Table 15-17:** Find Algorithms in the Boost String Algorithms Library'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-17：** Boost 字符串算法库中的查找算法'
- en: '| **Predicate** | **Finds the . . .** |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| **谓词** | **查找 . . .** |'
- en: '| `find_first(`s1`,` s2`)``ifind_first(`s1`,` s2`)` | First instance of s2
    in s1 |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `find_first(`s1`,` s2`)``ifind_first(`s1`,` s2`)` | s1 中首次出现 s2 的位置 |'
- en: '| `find_last(`s1`,` s2`)``ifind_last(`s1`,` s2`)` | First instance of s2 in
    s1 |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `find_last(`s1`,` s2`)``ifind_last(`s1`,` s2`)` | s1 中最后一次出现 s2 的位置 |'
- en: '| `find_nth(`s1`,` s2`,` n`)``ifind_nth(`s1`,` s2`,` n`)` | nth instance of
    s2 in s1 |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `find_nth(`s1`,` s2`,` n`)``ifind_nth(`s1`,` s2`,` n`)` | s1 中第 n 次出现 s2
    的位置 |'
- en: '| `find_head(`s`,` n`)` | First n characters of s |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `find_head(`s`,` n`)` | s 的前 n 个字符 |'
- en: '| `find_tail(`s`,` n`)` | Last n characters of s |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `find_tail(`s`,` n`)` | s 的最后 n 个字符 |'
- en: '| `find_token(`s`,` p`)` | First character matching p in s |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `find_token(`s`,` p`)` | s 中第一个与 p 匹配的字符 |'
- en: '| `find_regex(`s`,` rgx`)` | First substring matching rgx in s |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `find_regex(`s`,` rgx`)` | s 中与 rgx 匹配的第一个子字符串 |'
- en: '| `find(`s`,` fnd`)` | Result of applying fnd to s |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `find(`s`,` fnd`)` | 将 fnd 应用于 s 的结果 |'
- en: '**Boost Tokenizer**'
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost Tokenizer**'
- en: 'Boost Tokenizer’s `boost::tokenizer` is a class template that provides a view
    of a series of tokens contained in a `string`. A `tokenizer` takes three optional
    template parameters: a tokenizer function, an iterator type, and a string type.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Tokenizer 的 `boost::tokenizer` 是一个类模板，它提供了一个 `string` 中包含的标记序列的视图。一个 `tokenizer`
    接受三个可选的模板参数：一个 tokenizer 函数，一个迭代器类型，和一个字符串类型。
- en: The *tokenizer function* is a predicate that determines whether a character
    is a delimiter (returns `true`) or not (returns `false`). The default tokenizer
    function interprets spaces and punctuation marks as separators. If you want to
    specify the delimiters explicitly, you can use the `boost::char_separator<char>`
    class, which accepts a C-string containing all the delimiting characters. For
    example, a `boost::char_separator<char>(";|,")` would separate on semicolons (`;`),
    pipes (`|`), and commas (`,`).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '*tokenizer 函数* 是一个谓词，用来判断一个字符是否是分隔符（返回 `true`）或不是（返回 `false`）。默认的 tokenizer
    函数将空格和标点符号视为分隔符。如果你想明确指定分隔符，可以使用 `boost::char_separator<char>` 类，它接受一个包含所有分隔符字符的
    C 字符串。例如，`boost::char_separator<char>(";|,")` 会在分号（`;`）、管道符号（`|`）和逗号（`,`）处分割。'
- en: The iterator type and string type correspond with the type of `string` you want
    to split. By default, these are `std::string::const_iterator` and `std::string`,
    respectively.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类型和字符串类型与你想要分割的 `string` 类型对应。默认情况下，它们分别是 `std::string::const_iterator` 和
    `std::string`。
- en: Because `tokenizer` doesn’t allocate memory and `boost::algorithm::split` does,
    you should strongly consider using the former whenever you only need to iterate
    over the tokens of a `string` once.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `tokenizer` 不会分配内存，而 `boost::algorithm::split` 会，因此当你只需要一次迭代 `string` 的标记时，强烈建议使用前者。
- en: A `tokenizer` exposes `begin` and `end` methods that return input iterators,
    so you can treat it as a range of values corresponding to the underlying token
    sequence.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenizer` 提供了 `begin` 和 `end` 方法，它们返回输入迭代器，因此你可以将其视为一个与底层标记序列对应的值范围。'
- en: '[Listing 15-36](ch15.xhtml#ch15ex36) tokenizes the iconic palindrome `A man,
    a plan, a canal, Panama!` by comma.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-36](ch15.xhtml#ch15ex36) 按逗号分割标志性回文 `A man, a plan, a canal, Panama!`。'
- en: '[PRE38]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 15-36: The `boost::tokenizer` splits strings by specified delimiters.*'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-36：`boost::tokenizer` 按指定分隔符分割字符串。*'
- en: Here, you construct `palindrome` ➊, char_separator ➋, and the corresponding
    `tokenizer` ➌. Next, you extract an iterator from the tokenizer using its `begin`
    method ➍. You can treat the resulting iterator as usual, dereferencing its value
    ➎ and incrementing to the next element ➏.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构建了 `palindrome` ➊，`char_separator` ➋ 和相应的 `tokenizer` ➌。接下来，你使用其 `begin`
    方法 ➍ 从 tokenizer 中提取一个迭代器。你可以像通常那样处理结果迭代器，解引用其值 ➎ 并递增到下一个元素 ➏。
- en: '**Localizations**'
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**本地化**'
- en: A *locale* is a class for encoding cultural preferences. The locale concept
    is typically encoded in whatever operating environment your application runs within.
    It also controls many preferences, such as string comparison; date and time, money,
    and numeric formatting; postal and ZIP codes; and phone numbers.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '*locale* 是一个用于编码文化偏好的类。locale 概念通常被编码在你的应用程序运行的操作环境中。它还控制许多偏好设置，例如字符串比较；日期和时间、货币和数字格式；邮政编码和
    ZIP 代码；以及电话号码。'
- en: The STL offers the `std::locale` class and many helper functions and classes
    in the `<locale>` header.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了 `std::locale` 类以及 `<locale>` 头文件中的许多辅助函数和类。
- en: Mainly for brevity (and partially because English speakers are the primary intended
    audience for this book), this chapter won’t explore locales any further.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简洁性（并且部分原因是本书的主要读者是讲英语的人），本章将不再深入探讨 locales。
- en: '**Summary**'
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter covered `std::string` and its ecosystem in detail. After exploring
    its similarities to `std::vector`, you learned about its built-in methods for
    handling human-language data, such as comparing, adding, removing, replacing,
    and searching. You looked at how the numeric conversion functions allow you to
    convert between numbers and strings, and you examined the role that `std::string_view`
    plays in passing strings around your programs. You also learned how to employ
    regular expressions to perform intricate match, search, and replacement based
    on potentially complicated patterns. Finally, you trekked through the Boost String
    Algorithms library, which complements and extends the built-in methods of `std::string`
    with additional methods for searching, replacing, trimming, erasing, splitting,
    and joining.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了`std::string`及其生态系统。你在探索它与`std::vector`的相似性后，学习了它处理人类语言数据的内建方法，例如比较、添加、删除、替换和搜索。你了解了数字转换函数如何让你在数字和字符串之间转换，并且分析了`std::string_view`在传递字符串时的作用。你还学习了如何利用正则表达式执行基于复杂模式的匹配、搜索和替换。最后，你深入了解了Boost字符串算法库，它补充并扩展了`std::string`的内建方法，提供了额外的搜索、替换、修剪、删除、分割和连接方法。
- en: '**EXERCISES**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**15-1.** Refactor the histogram calculator in [Listings 9-30](ch09.xhtml#ch09ex30)
    and [9-31](ch09.xhtml#ch09ex31) to use `std::string`. Construct a `string` from
    the program’s input and modify `AlphaHistogram` to accept a `string_view` or a
    `const string&` in its `ingest` method. Use a range-based `for` loop to iterate
    over the ingested elements of `string`. Replace the `counts` field’s type with
    an associative container.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-1.** 重构[清单9-30](ch09.xhtml#ch09ex30)和[9-31](ch09.xhtml#ch09ex31)中的直方图计算器，改用`std::string`。根据程序的输入构造一个`string`，并修改`AlphaHistogram`的`ingest`方法，使其接受`string_view`或`const
    string&`。使用基于范围的`for`循环遍历已输入的`string`元素。将`counts`字段的类型替换为关联容器。'
- en: '**15-2.** Implement a program that determines whether the user’s input is a
    palindrome.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-2.** 实现一个程序，判断用户输入的是否为回文。'
- en: '**15-3.** Implement a program that counts the number of vowels in the user’s
    input.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-3.** 实现一个程序，计算用户输入中的元音字母个数。'
- en: '**15-4.** Implement a calculator program that supports addition, subtraction,
    multiplication, and division of any two numbers. Consider using the `find` method
    of `std::string` and the numeric conversion functions.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-4.** 实现一个支持加法、减法、乘法和除法的计算器程序，能够处理任意两个数字。考虑使用`std::string`的`find`方法和数字转换函数。'
- en: '**15-5.** Extend your calculator program in some of the following ways: permit
    multiple operations or the modulo operator and accept floating-point numbers or
    parentheses.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-5.** 通过以下方式扩展你的计算器程序：允许多种操作或模运算符，并接受浮动小数点数或括号。'
- en: '**15-6.** Optional: Read more about locales in [localization].'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**15-6.** 可选：阅读更多关于[本地化]的信息。'
- en: '**FURTHER READING**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO国际标准 ISO/IEC (2017) — 编程语言 C++*（国际标准化组织；瑞士日内瓦；* [https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)
    *）'
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++编程语言*，第4版，作者：Bjarne Stroustrup（Pearson Education，2013）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++库*，第2版，作者：Boris Schäling（XML Press，2014）'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++标准库：教程与参考*，第2版，作者：Nicolai M. Josuttis（Addison-Wesley Professional，2012）'
