- en: Chapter 38. Writing Secure Privileged Programs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第38章 编写安全的特权程序
- en: 'Privileged programs have access to features and resources (files, devices,
    and so on) that are not available to ordinary users. A program can run with privileges
    by two general means:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 特权程序可以访问普通用户无法访问的功能和资源（文件、设备等）。程序可以通过两种方式之一运行特权：
- en: The program was started under a privileged user ID. Many daemons and network
    servers, which are typically run as *root*, fall into this category.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序在特权用户ID下启动。许多守护进程和网络服务器，通常以*root*身份运行，属于这一类。
- en: The program has its set-user-ID or set-group-ID permission bit set. When a set-user-ID
    (set-group-ID) program is execed, it changes the effective user (group) ID of
    the process to be the same as the owner (group) of the program file. (We first
    described set-user-ID and set-group-ID programs in Section 9.3.) In this chapter,
    we’ll sometimes use the term set-user-ID-*root* to distinguish a set-user-ID program
    that gives superuser privileges to a process from one that gives a process another
    effective identity.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序设置了用户标识符（set-user-ID）或组标识符（set-group-ID）权限位。当一个设置了用户标识符（set-user-ID）或组标识符（set-group-ID）的程序被执行时，它会将进程的有效用户（组）ID更改为与程序文件的所有者（组）相同。（我们在第9.3节首次描述了设置用户标识符和组标识符程序。）在本章中，我们有时会使用“set-user-ID-*root*”这个术语，来区分一个赋予进程超级用户权限的set-user-ID程序与赋予进程其他有效身份的程序。
- en: If a privileged program contains bugs, or can be subverted by a malicious user,
    then the security of the system or an application can be compromised. From a security
    viewpoint, we should write programs so as to minimize both the chance of a compromise
    and the damage that can be done if a compromise does occur. These topics form
    the subject of this chapter, which provides a set of recommended practices for
    secure programming, and describes various pitfalls that should be avoided when
    writing privileged programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特权程序存在漏洞，或者能被恶意用户破坏，那么系统或应用程序的安全性可能会受到威胁。从安全的角度来看，我们应该编写程序以最小化被攻击的可能性，并减少如果发生攻击时可能造成的损害。本章的内容就是关于这一主题，提供了一套安全编程的推荐实践，并描述了在编写特权程序时应该避免的各种陷阱。
- en: Is a Set-User-ID or Set-Group-ID Program Required?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否需要设置用户标识符或组标识符程序？
- en: One of the best pieces of advice concerning set-user-ID and set-group-ID programs
    is to avoid writing them whenever possible. If there is an alternative way of
    performing a task that doesn’t involve giving a program privilege, we should generally
    employ that alternative, since it eliminates the possibility of a security compromise.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置用户标识符和组标识符程序的最佳建议之一是尽可能避免编写它们。如果有其他方式可以执行某个任务，而不涉及给予程序特权，那么我们通常应该选择这种替代方式，因为它消除了安全漏洞的可能性。
- en: 'Sometimes, we can isolate the functionality that needs privilege into a separate
    program that performs a single task, and exec that program in a child process
    as required. This technique can be especially useful for libraries. One example
    of such a use is provided by the *pt_chown* program described in [Changing Slave
    Ownership and Permissions: *grantpt()*](ch64.html#changing_slave_ownership_and_permissions
    "Changing Slave Ownership and Permissions: grantpt()").'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可以将需要特权的功能隔离到一个独立的程序中，该程序执行单一任务，并在需要时在子进程中执行该程序。这种技术对于库特别有用。一个这样的用法示例由*pt_chown*程序提供，该程序在[改变从属设备的所有权和权限：*grantpt()*](ch64.html#changing_slave_ownership_and_permissions
    "改变从属设备的所有权和权限：grantpt()")中进行了描述。
- en: Even in cases where a set-user-ID or set-group-ID is needed, it isn’t always
    necessary for a set-user-ID program to give a process *root* credentials. If giving
    a process some other credentials suffices, then this option should be preferred,
    since running with *root* privileges opens the gates to possible security compromises.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使需要设置用户标识符（set-user-ID）或组标识符（set-group-ID），也并不总是需要将进程的身份设置为*root*。如果仅需要其他凭据来执行某个任务，那么应该优先选择这种方式，因为以*root*权限运行程序可能会导致安全漏洞。
- en: Consider a set-user-ID program that needs to allow users to update a file on
    which they do not have write permission. A safer way to do this is to create a
    dedicated group account (group ID) for this program, change the group ownership
    of the file to that group (and make the file writable by that group), and write
    a set-group-ID program that sets the process’s effective group ID to the dedicated
    group ID. Since the dedicated group ID is not otherwise privileged, this greatly
    limits the damage that can be done if the program contains bugs or can otherwise
    be subverted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个需要允许用户更新他们没有写权限的文件的设置用户 ID 程序。更安全的做法是为该程序创建一个专门的用户组账户（组 ID），将文件的组所有权更改为该组（并使该组具有写权限），然后编写一个设置组
    ID 的程序，将进程的有效组 ID 设置为专门的组 ID。由于专门的组 ID 没有其他特权，这大大限制了如果程序存在 bug 或者被篡改时可能造成的损害。
- en: Operate with Least Privilege
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小特权操作
- en: A set-user-ID (or set-group-ID) program typically requires privileges only to
    perform certain operations. While the program (especially one assuming superuser
    privileges) is performing other work, it should disable these privileges. When
    privileges will never again be required, they should be dropped permanently. In
    other words, the program should always operate with the *least privilege* required
    to accomplish the tasks that it is currently performing. The saved set-user-ID
    facility was designed for this purpose ([Saved Set-User-ID and Saved Set-Group-ID](ch09.html#saved_set-user-id_and_saved_set-group-id
    "Saved Set-User-ID and Saved Set-Group-ID")).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户 ID（或设置组 ID）程序通常只在执行某些操作时需要特权。当程序（尤其是需要超级用户特权的程序）执行其他工作时，它应该禁用这些特权。当特权再也不需要时，它们应该被永久放弃。换句话说，程序应该始终以完成当前任务所需的*最小特权*运行。保存的设置用户
    ID 功能就是为此目的而设计的（[保存的设置用户 ID 和保存的设置组 ID](ch09.html#saved_set-user-id_and_saved_set-group-id
    "保存的设置用户 ID 和保存的设置组 ID")）。
- en: Hold privileges only while they are required
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅在需要时持有特权
- en: 'In a set-user-ID program, we can use the following sequence of *seteuid()*
    calls to temporarily drop and then reacquire privileges:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用户 ID 程序中，我们可以使用以下 *seteuid()* 调用序列来暂时放弃然后重新获得特权：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first call makes the effective user ID of the calling process the same as
    its real ID. The second call restores the effective user ID to the value held
    in the saved set-user-ID.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用使调用进程的有效用户 ID 与其真实 ID 相同。第二个调用将有效用户 ID 恢复为保存的设置用户 ID 中的值。
- en: 'For set-group-ID programs, the saved set-group-ID saves the program’s initial
    effective group ID, and *setegid()* is used to drop and reacquire privilege. We
    describe *seteuid()*, *setegid()*, and other similar system calls mentioned in
    the following recommendations in [Chapter 9](ch09.html "Chapter 9. Process Credentials")
    and summarize them in [Table 9-1](ch09.html#summary_of_interfaces_used_to_change_pro
    "Table 9-1. Summary of interfaces used to change process credentials") (in [Example:
    Displaying Process Credentials](ch09.html#example_colon_displaying_process_credent
    "Example: Displaying Process Credentials")).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设置组 ID 程序，保存的设置组 ID 保存程序最初的有效组 ID，*setegid()* 用于放弃并重新获得特权。我们在[第 9 章](ch09.html
    "第 9 章. 进程凭证")中描述了 *seteuid()*、*setegid()* 以及以下建议中提到的其他类似系统调用，并在[表 9-1](ch09.html#summary_of_interfaces_used_to_change_pro
    "表 9-1. 用于更改进程凭证的接口总结")中总结了它们（在[示例：显示进程凭证](ch09.html#example_colon_displaying_process_credent
    "示例：显示进程凭证")中）。
- en: The safest practice is to drop privileges immediately on program startup, and
    then temporarily reacquire them as needed at later points in the program. If,
    at a certain point, privileges will never be required again, then the program
    should drop them irreversibly, by ensuring that the saved set-user-ID is also
    changed. This eliminates the possibility of the program being tricked into reacquiring
    privilege, perhaps via the stack-crashing technique described in Section 38.9.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的做法是在程序启动时立即放弃特权，然后在程序的后续部分根据需要临时重新获得它们。如果在某个时刻特权再也不需要了，那么程序应该通过确保保存的设置用户
    ID 也被更改来永久放弃特权。这消除了程序可能通过栈溢出技术（如第 38.9 节所述）被欺骗重新获得特权的可能性。
- en: Drop privileges permanently when they will never again be required
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当特权再也不需要时，永久放弃它们
- en: If a set-user-ID or set-group-ID program finishes all tasks that require privileges,
    then it should drop its privileges permanently in order to eliminate any security
    risk that could occur because the program is compromised by a bug or other unexpected
    behavior. Dropping privileges permanently is accomplished by resetting all process
    user (group) IDs to the same value as the real (group) ID.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个设置用户 ID 或设置组 ID 程序完成了所有需要特权的任务，那么它应当永久丢弃其特权，以消除任何可能发生的安全风险，这些风险可能源自程序因错误或其他意外行为被攻破。永久丢弃特权是通过将所有进程的用户（组）ID
    重置为与真实（组）ID 相同的值来实现的。
- en: 'From a set-user-ID-*root* program whose effective user ID is currently 0, we
    can reset all user IDs using the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个有效用户 ID 当前为 0 的设置用户 ID 为 *root* 的程序中，我们可以使用以下代码重置所有用户 ID：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, the above code does *not* reset the saved set-user-ID if the effective
    user ID of the calling process is currently nonzero: when called from a program
    whose effective user ID is nonzero, *setuid()* changes only the effective user
    ID ([Retrieving and Modifying Real, Effective, and Saved Set IDs](ch09.html#retrieving_and_modifying_real_comma_effe
    "Retrieving and Modifying Real, Effective, and Saved Set IDs")). In other words,
    in a set-user-ID-*root* program, the following sequence doesn’t permanently drop
    the user ID 0:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述代码*并没有*重置保存的设置用户 ID，如果调用进程的有效用户 ID 当前为非零：当从有效用户 ID 非零的程序调用时，*setuid()*
    仅更改有效用户 ID（[获取和修改真实、有效和保存的 ID](ch09.html#retrieving_and_modifying_real_comma_effe
    "Retrieving and Modifying Real, Effective, and Saved Set IDs")）。换句话说，在设置用户 ID
    为 *root* 的程序中，以下序列并不会永久丢弃用户 ID 0：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead, we must regain privilege prior to dropping it permanently, by inserting
    the following call between steps 1 and 2 above:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须在永久丢弃特权之前重新获得特权，通过在上述步骤 1 和步骤 2 之间插入以下调用：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On the other hand, if we have a set-user-ID program owned by a user other than
    *root*, then, because *setuid()* is insufficient to change the saved set-user-ID,
    we must use either *setreuid()* or *setresuid()* to permanently drop the privileged
    identifier. For example, we could achieve the desired result using *setreuid()*,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个由 *root* 以外的用户拥有的设置用户 ID 程序，则由于 *setuid()* 不足以更改保存的设置用户 ID，我们必须使用
    *setreuid()* 或 *setresuid()* 来永久丢弃特权标识符。例如，我们可以使用 *setreuid()* 来实现预期结果，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code relies on a feature of the Linux implementation of *setreuid()*:
    if the first (*ruid*) argument is not -1, then the saved set-user-ID is also set
    to the same value as the (new) effective user ID. SUSv3 doesn’t specify this feature,
    but many other implementations behave the same way as Linux. SUSv4 does specify
    this feature.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于 Linux 实现中 *setreuid()* 的一个特性：如果第一个（*ruid*）参数不是 -1，那么保存的设置用户 ID 也会被设置为与（新的）有效用户
    ID 相同的值。SUSv3 没有指定这一特性，但许多其他实现与 Linux 的行为相同。SUSv4 确实指定了这一特性。
- en: The *setregid()* or *setresgid()* system call must likewise be used to permanently
    drop a privileged group ID in a set-group-ID program, since, when the effective
    user ID of a program is nonzero, *setgid()* changes only the effective group ID
    of the calling process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*setregid()* 或 *setresgid()* 系统调用同样需要在设置组 ID 程序中使用，以永久丢弃特权组 ID，因为当程序的有效用户 ID
    非零时，*setgid()* 仅更改调用进程的有效组 ID。'
- en: General points on changing process credentials
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于更改进程凭证的通用点
- en: 'In the preceding pages, we described techniques for temporarily and permanently
    dropping privileges. We now add a few general points regarding the use of these
    techniques:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们描述了暂时和永久丢弃特权的技巧。现在，我们补充一些关于这些技巧使用的通用点：
- en: The semantics of some of the system calls that change process credentials vary
    across systems. Furthermore, the semantics of some of these system calls vary
    depending on whether or not the caller is privileged (effective user ID of 0).
    For details, see [Chapter 9](ch09.html "Chapter 9. Process Credentials"), and
    especially [Summary of Calls for Modifying Process Credentials](ch09.html#summary_of_calls_for_modifying_process_c
    "Summary of Calls for Modifying Process Credentials"). Because of these variations,
    [Tsafrir et al., 2008] recommends that applications should use system-specific
    *nonstandard* system calls for changing process credentials, since, in many cases,
    these nonstandard system calls provide simpler and more consistent semantics than
    their standard counterparts. On Linux, this would translate to using *setresuid()*
    and *setresgid()* to change user and group credentials. Although these system
    calls are not present on all systems, their use is likely to be less prone to
    error. ([Tsafrir et al., 2008] proposes a library of functions that make credential
    changes using what they consider to be the best interfaces available on each platform.)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些更改进程凭证的系统调用的语义在不同系统之间有所不同。此外，这些系统调用的语义还取决于调用者是否具有特权（有效用户 ID 为 0）。有关详细信息，请参见[第
    9 章](ch09.html "第 9 章. 进程凭证")，尤其是[修改进程凭证的系统调用总结](ch09.html#summary_of_calls_for_modifying_process_c
    "修改进程凭证的系统调用总结")。由于这些差异，[Tsafrir 等人，2008] 建议应用程序应使用特定于系统的 *非标准* 系统调用来更改进程凭证，因为在许多情况下，这些非标准的系统调用提供了比标准调用更简洁且一致的语义。在
    Linux 上，这意味着使用 *setresuid()* 和 *setresgid()* 来更改用户和组凭证。虽然这些系统调用并非所有系统都有，但它们的使用可能会更不容易出错。（[Tsafrir
    等人，2008] 提出了一个函数库，使用他们认为每个平台上最佳的接口来进行凭证更改。）
- en: On Linux, even if the caller has an effective user ID of 0, system calls for
    changing credentials may not behave as expected if the program has explicitly
    manipulated its capabilities. For example, if the `CAP_SETUID` capability has
    been disabled, then attempts to change process user IDs will fail or, even worse,
    silently change only some of the requested user IDs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上，即使调用者的有效用户 ID 为 0，如果程序显式地修改了其权限，系统调用用于更改凭证时可能不会按预期行为执行。例如，如果禁用了 `CAP_SETUID`
    能力，则尝试更改进程用户 ID 会失败，或者更糟糕的是，只会悄悄地更改部分请求的用户 ID。
- en: Because of the possibilities listed in the two preceding points, it is highly
    recommended practice (see, for example, [Tsafrir et al., 2008]) to not only check
    that a credential-changing system call has succeeded, but also to verify that
    the change occurred as expected. For example, if we are temporarily dropping or
    reacquiring a privileged user ID using *seteuid()*, then we should follow that
    call with a *geteuid()* call that verifies that the effective user ID is what
    we expect. Similarly, if we are dropping a privileged user ID permanently, then
    we should verify that the real user ID, effective user ID, and saved set-user-ID
    have all been successfully changed to the unprivileged user ID. Unfortunately,
    while there are standard system calls for retrieving the real and effective IDs,
    there are no standard system calls for retrieving the saved set IDs. Linux and
    a few other systems provide *getresuid()* and *getresgid()* for this purpose;
    on some other systems, we may need to employ techniques such as parsing information
    in `/proc` files.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于前面提到的两点中的可能性，强烈推荐的做法是（例如，参见 [Tsafrir 等人，2008]）不仅要检查凭证更改的系统调用是否成功，还要验证更改是否按预期发生。例如，如果我们暂时丢弃或重新获取特权用户
    ID 使用 *seteuid()*，则应该紧接着调用 *geteuid()* 来验证有效用户 ID 是否如预期所示。类似地，如果我们永久丢弃特权用户 ID，那么我们应该验证实际用户
    ID、有效用户 ID 和已保存的用户 ID 是否都已成功更改为非特权用户 ID。不幸的是，虽然有标准的系统调用来检索实际和有效的 ID，但没有标准的系统调用来检索已保存的用户
    ID。Linux 和一些其他系统提供了 *getresuid()* 和 *getresgid()* 来实现此目的；在某些其他系统中，我们可能需要使用诸如解析
    `/proc` 文件中的信息等技术。
- en: Some credential changes can be made only by processes with an effective user
    ID of 0\. Therefore, when changing multiple IDs—supplementary group IDs, group
    IDs, and user IDs—we should drop the privileged effective user ID last when dropping
    privileged IDs. Conversely, we should raise the privileged effective user ID first
    when raising privileged IDs.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些凭证更改只能由有效用户 ID 为 0 的进程执行。因此，在更改多个 ID（附加组 ID、组 ID 和用户 ID）时，我们应在丢弃特权 ID 时最后丢弃特权有效用户
    ID。相反，在提升特权 ID 时，我们应首先提升特权有效用户 ID。
- en: Be Careful When Executing a Program
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行程序时要小心
- en: Caution is required when a privileged program executes another program, either
    directly, via an *exec()*, or indirectly, via *system()*, *popen()*, or a similar
    library function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当特权程序执行另一个程序时，无论是直接通过*exec()*，还是间接通过*system()*、*popen()*或类似的库函数，都需要小心。
- en: Drop privileges permanently before execing another program
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在执行另一个程序之前永久丢弃权限
- en: If a set-user-ID (or set-group-ID) program executes another program, then it
    should ensure that all process user (group) IDs are reset to the same value as
    the real user (group) ID, so that the new program doesn’t start with privileges
    and also can’t reacquire them. One way to do this is to reset all of the IDs before
    performing the *exec()*, using the techniques described in Section 38.2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个设置用户ID（或设置组ID）程序执行另一个程序，则它应该确保所有进程的用户（组）ID被重置为与真实用户（组）ID相同的值，以便新程序不会带有特权启动，也无法重新获得特权。实现此目的的一种方法是，在执行*exec()*之前重置所有ID，使用第38.2节中描述的技术。
- en: The same result can be achieved by preceding the *exec()* with the call *setuid(getuid())*.
    Even though this *setuid()* call changes only the effective user ID in a process
    whose effective user ID is nonzero, privileges are nevertheless dropped because
    (as described in [Saved Set-User-ID and Saved Set-Group-ID](ch09.html#saved_set-user-id_and_saved_set-group-id
    "Saved Set-User-ID and Saved Set-Group-ID")) a successful *exec()* goes on to
    copy the effective user ID to the saved set-user-ID. (If the *exec()* fails, then
    the saved set-user-ID is left unchanged. This may be useful if the program then
    needs to perform other privileged work because the *exec()* failed.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在*exec()*之前调用*setuid(getuid())*，可以实现相同的结果。即使这个*setuid()*调用仅改变了有效用户ID，而该进程的有效用户ID非零，权限仍然会被丢弃，因为（如[保存的设置用户ID和保存的设置组ID](ch09.html#saved_set-user-id_and_saved_set-group-id
    "Saved Set-User-ID and Saved Set-Group-ID")中所述）成功的*exec()*会将有效用户ID复制到保存的设置用户ID中。（如果*exec()*失败，保存的设置用户ID将保持不变。如果程序随后需要执行其他特权工作，这可能会有用，因为*exec()*失败了。）
- en: A similar approach (i.e., *setgid(getgid())*) can be used with set-group-ID
    programs, since a successful *exec()* also copies the effective group ID to the
    saved set-group-ID.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法（即*setgid(getgid())*）可以用于设置组ID程序，因为成功的*exec()*也会将有效的组ID复制到保存的设置组ID。
- en: 'As an example, suppose that we have a set-user-ID program owned by user ID
    200\. When this program is executed by a user whose ID is 1000, the user IDs of
    the resulting process will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个由用户ID 200拥有的设置用户ID程序。当该程序由用户ID为1000的用户执行时，生成的进程的用户ID将如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If this program subsequently executes the call *setuid(getuid())*, then the
    process user IDs are changed to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该程序随后执行*setuid(getuid())*调用，则进程用户ID将被更改为以下内容：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the process executes an unprivileged program, the effective user ID of
    the process is copied to the saved set-user-ID, resulting in the following set
    of process user IDs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当该进程执行一个非特权程序时，进程的有效用户ID将被复制到保存的设置用户ID中，从而导致以下的进程用户ID：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Avoid executing a shell (or other interpreter) with privileges
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免以特权身份执行shell（或其他解释器）
- en: Privileged programs running under user control should never exec a shell, either
    directly or indirectly (via *system()*, *popen()*, *execlp()*, *execvp()*, or
    other similar library functions). The complexity and power of shells (and other
    unconstrained interpreters such as *awk*) mean that it is virtually impossible
    to eliminate all security loopholes, even if the execed shell doesn’t allow interactive
    access. The consequent risk is that the user may be able to execute arbitrary
    shell commands under the effective user ID of the process. If a shell must be
    execed, ensure that privileges are permanently dropped beforehand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户控制下运行的特权程序永远不应该直接或间接地执行shell（通过*system()*、*popen()*、*execlp()*、*execvp()*或其他类似的库函数）。由于shell（以及其他不受限制的解释器，如*awk*）的复杂性和强大功能，几乎不可能消除所有安全漏洞，即使被执行的shell不允许交互式访问。由此带来的风险是，用户可能能够在该进程的有效用户ID下执行任意的shell命令。如果必须执行shell，请确保在此之前已经永久丢弃了权限。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of the kind of security loophole that can occur when execing a shell
    is noted in the discussion of *system()* in Section 27.6.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第27.6节讨论的*system()*中，提到了一种可能发生的执行shell时的安全漏洞。
- en: A few UNIX implementations honor the set-user-ID and set-group-ID permission
    bits when they are applied to interpreter scripts ([Interpreter Scripts](ch27.html#interpreter_scripts
    "Interpreter Scripts")), so that, when the script is run, the process executing
    the script assumes the identity of some other (privileged) user. Because of the
    security risks just described, Linux, like some other UNIX implementations, silently
    ignores the set-user-ID and set-group-ID permission bits when execing a script.
    Even on implementations where set-user-ID and set-group-ID scripts are permitted,
    their use should be avoided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现会在应用于解释器脚本时尊重设置用户ID和设置组ID的权限位（[解释器脚本](ch27.html#interpreter_scripts
    "解释器脚本")），这样，在运行脚本时，执行脚本的进程将假定某个其他（特权）用户的身份。由于前面描述的安全风险，Linux像一些其他UNIX实现一样，在执行脚本时会默默忽略设置用户ID和设置组ID的权限位。即使在允许设置用户ID和设置组ID脚本的实现中，也应避免使用这些脚本。
- en: Close all unnecessary file descriptors before an *exec()*
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在*exec()*之前关闭所有不必要的文件描述符
- en: In [File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()"), we noted that, by default, file descriptors remain
    open across an *exec()*. A privileged program may open a file that normal processes
    can’t access. The resulting open file descriptor represents a privileged resource.
    The file descriptor should be closed before an *exec()*, so that the execed program
    can’t access the associated file. We can do this either by explicitly closing
    the file descriptor or by setting its close-on-exec flag ([File Descriptors and
    *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "File Descriptors
    and exec()")).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[文件描述符和*exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "文件描述符和exec()")中，我们提到，默认情况下，文件描述符会在*exec()*调用时保持打开状态。特权程序可能会打开一个普通进程无法访问的文件。由此产生的打开文件描述符代表了一个特权资源。文件描述符应该在*exec()*之前关闭，以便被exec的程序无法访问相关文件。我们可以通过显式关闭文件描述符，或者通过设置其close-on-exec标志来做到这一点（[文件描述符和*exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "文件描述符和exec()")）。
- en: Avoid Exposing Sensitive Information
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免暴露敏感信息
- en: 'When a program reads passwords or other sensitive information, it should perform
    whatever processing is required, and then immediately erase the information from
    memory. (We show an example of this in Section 8.5.) Leaving such information
    in memory is a security risk, for the following reasons:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序读取密码或其他敏感信息时，应执行所需的处理，然后立即从内存中删除这些信息。（在第8.5节中我们展示了一个示例。）将这些信息保留在内存中存在安全风险，原因如下：
- en: The virtual memory page containing the data may be swapped out (unless it is
    locked in memory using *mlock()* or similar), and could then be read from the
    swap area by a privileged program.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含数据的虚拟内存页面可能会被交换出去（除非它通过*mlock()*或类似方式锁定在内存中），然后可能会被特权程序从交换区读取。
- en: If the process receives a signal that causes it to produce a core dump file,
    then that file may be read to obtain the information.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程接收到一个信号，导致其生成一个核心转储文件，那么该文件可能会被读取以获取相关信息。
- en: Following on from the last point, as a general principle, a secure program should
    prevent core dumps, so that a core dump file can’t be inspected for sensitive
    information. A program can ensure that a core dump file is not created by using
    *setrlimit()* to set the `RLIMIT_CORE` resource limit to `0` (see [Details of
    Specific Resource Limits](ch36.html#details_of_specific_resource_limits "Details
    of Specific Resource Limits")).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上面提到的内容，作为一般原则，一个安全的程序应该防止核心转储，以确保无法通过核心转储文件检查到敏感信息。程序可以通过使用*setrlimit()*将`RLIMIT_CORE`资源限制设置为`0`来确保不会创建核心转储文件（见[特定资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "特定资源限制的详细信息")）。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, Linux doesn’t permit a set-user-ID program to perform a core dump
    in response to a signal ([Core Dump Files](ch22.html#core_dump_files "Core Dump
    Files")), even if the program has dropped all privileges. However, other UNIX
    implementations may not provide this security feature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Linux 不允许设置用户ID的程序在接收到信号时执行核心转储（[核心转储文件](ch22.html#core_dump_files "核心转储文件")），即使该程序已经丧失了所有特权。然而，其他UNIX实现可能没有提供此安全功能。
- en: Confine the Process
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制进程范围
- en: In this section, we consider ways in which we can confine a program to limit
    the damage that is done if the program is compromised.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考虑通过哪些方式可以限制程序，从而在程序被破坏时减少所造成的损害。
- en: Consider using capabilities
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑使用能力
- en: The Linux capabilities scheme divides the traditional all-or-nothing UNIX privilege
    scheme into distinct units called *capabilities*. A process can independently
    enable or disable individual capabilities. By enabling just those capabilities
    that it requires, a program operates with less privilege than it would have if
    run with full *root* privileges. This reduces the potential for damage if the
    program is compromised.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的能力机制将传统的全有或全无的UNIX权限机制划分为不同的单元，称为*能力*。进程可以独立地启用或禁用各个能力。通过仅启用其所需的那些能力，程序运行时的权限比使用完整*root*权限时要低。这减少了程序被破坏时可能造成的损害。
- en: Furthermore, using capabilities and the *securebits* flags, we can create a
    process that has a limited set of capabilities but is not owned by *root* (i.e.,
    all of its user IDs are nonzero). Such a process can no longer use *exec()* to
    regain a full set of capabilities. We describe capabilities and the *securebits*
    flags in [Chapter 39](ch39.html "Chapter 39. Capabilities").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用能力和*securebits*标志，我们可以创建一个具有有限能力集但不是由*root*拥有的进程（即，其所有用户ID都为非零）。这样的进程将无法再使用*exec()*恢复完整的能力集。我们在[第39章](ch39.html
    "第39章。能力")中描述了能力和*securebits*标志。
- en: Consider using a *chroot* jail
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑使用*chroot*监狱
- en: 'A useful security technique in certain cases is to establish a *chroot* jail
    to limit the set of directories and files that a program may access. (Make sure
    to also call *chdir()* to change the process’s current working directory to a
    location within the jail.) Note, however, that a *chroot* jail is insufficient
    to confine a set-user-ID-*root* program (see [Changing the Root Directory of a
    Process: *chroot()*](ch18.html#changing_the_root_directory_of_a_process "Changing
    the Root Directory of a Process: chroot()")).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一种有用的安全技术是建立一个*chroot*监狱，以限制程序可以访问的目录和文件集合。（确保还调用*chdir()*，将进程的当前工作目录更改为监狱内的一个位置。）然而，请注意，*chroot*监狱不足以限制一个设有用户ID-*root*的程序（参见[改变进程的根目录：*chroot()*](ch18.html#changing_the_root_directory_of_a_process
    "改变进程的根目录：chroot()")）。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative to using a *chroot* jail is a *virtual server*, which is a server
    implemented on top of a virtual kernel. Because each virtual kernel is isolated
    from other virtual kernels that may be running on the same hardware, a virtual
    server is more secure and flexible than a *chroot* jail. (Several other modern
    operating systems also provide their own implementations of virtual servers.)
    The oldest virtualization implementation on Linux is User-Mode Linux (UML), which
    is a standard part of the Linux 2.6 kernel. Further information about UML can
    be found at [http://user-mode-linux.sourceforge.net/](http://user-mode-linux.sourceforge.net/).
    More recent virtual kernel projects include Xen ([http://www.cl.cam.ac.uk/Research/SRG/netos/xen/](http://www.cl.cam.ac.uk/Research/SRG/netos/xen/))
    and KVM ([http://kvm.qumranet.com/](http://kvm.qumranet.com/)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*chroot*监狱的替代方法是*虚拟服务器*，它是在虚拟内核上实现的服务器。由于每个虚拟内核与可能在同一硬件上运行的其他虚拟内核隔离，因此虚拟服务器比*chroot*监狱更安全、更灵活。（其他一些现代操作系统也提供了自己的虚拟服务器实现。）Linux上最早的虚拟化实现是用户模式Linux（UML），它是Linux
    2.6内核的标准部分。有关UML的更多信息，请访问[http://user-mode-linux.sourceforge.net/](http://user-mode-linux.sourceforge.net/)。更现代的虚拟内核项目包括Xen（[http://www.cl.cam.ac.uk/Research/SRG/netos/xen/](http://www.cl.cam.ac.uk/Research/SRG/netos/xen/)）和KVM（[http://kvm.qumranet.com/](http://kvm.qumranet.com/)）。
- en: Beware of Signals and Race Conditions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当心信号和竞争条件
- en: A user may send arbitrary signals to a set-user-ID program that they have started.
    Such signals may arrive at any time and with any frequency. We need to consider
    the race conditions that can occur if a signal is delivered at *any* point in
    the execution of the program. Where appropriate, signals should be caught, blocked,
    or ignored to prevent possible security problems. Furthermore, the design of signal
    handlers should be as simple as possible, in order to reduce the risk of inadvertently
    creating a race condition.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会向他们启动的设有用户ID的程序发送任意信号。这些信号可能会在任何时间、以任何频率到达。我们需要考虑在程序执行的*任何*时刻发送信号可能导致的竞争条件。在适当的情况下，应该捕获、阻塞或忽略信号，以防止可能的安全问题。此外，信号处理程序的设计应尽可能简单，以减少无意中产生竞争条件的风险。
- en: 'This issue is particularly relevant with the signals that stop a process (e.g.,
    `SIGTSTP` and `SIGSTOP`). The problematic scenario is the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在停止进程的信号（例如，`SIGTSTP`和`SIGSTOP`）中尤为相关。问题场景如下：
- en: A set-user-ID program determines some information about its run-time environment.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个设置用户ID的程序决定了其运行时环境的某些信息。
- en: The user manages to stop the process running the program and change details
    of the run-time environment. Such changes may include modifying the permissions
    on a file, changing the target of a symbolic link, or removing a file that the
    program depends on.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户能够停止运行该程序的进程，并更改运行时环境的细节。这些更改可能包括修改文件的权限、改变符号链接的目标，或删除程序依赖的文件。
- en: The user resumes the process with a `SIGCONT` signal. At this point, the program
    will continue execution based on now false assumptions about its run-time environment,
    and these assumptions may lead to a security breach.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过`SIGCONT`信号恢复进程。此时，程序将继续执行，但基于关于其运行时环境的错误假设，这些假设可能导致安全漏洞。
- en: 'The situation described here is really just a special case of a *time-of-check*,
    *time-of-use* race condition. A privileged process should avoid performing operations
    based on previous verifications that may no longer hold (refer to the discussion
    of the *access()* system call in [Checking File Accessibility: *access()*](ch15.html#checking_file_accessibility_colon_access
    "Checking File Accessibility: access()") for a specific example). This guideline
    applies even when the user can’t send signals to the process. The ability to stop
    a process simply allows a user to widen the interval between the time of the check
    and the time of use.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '这里描述的情况实际上只是一个*检查时间*、*使用时间*竞态条件的特殊情况。特权进程应避免基于之前验证的操作，因为这些验证可能不再有效（具体示例请参见[检查文件可访问性：*access()*](ch15.html#checking_file_accessibility_colon_access
    "Checking File Accessibility: access()")中对*access()*系统调用的讨论）。即使用户无法向进程发送信号，这条指南仍然适用。停止一个进程的能力仅仅是让用户能够延长检查时间和使用时间之间的间隔。'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it may be difficult on a single attempt to stop a process between the
    time of check and time of use, a malicious user could execute a set-user-ID program
    repeatedly, and use another program or a shell script to repeatedly send stop
    signals to the set-user-ID program and change the run-time environment. This greatly
    improves the chances of subverting the set-user-ID program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在一次尝试中很难在检查时间和使用时间之间停止一个进程，但恶意用户可以反复执行设置用户ID的程序，并使用其他程序或shell脚本反复发送停止信号给设置用户ID的程序，改变其运行时环境。这大大增加了颠覆该设置用户ID程序的可能性。
- en: Pitfalls When Performing File Operations and File I/O
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行文件操作和文件I/O时的陷阱
- en: 'If a privileged process needs to create a file, then we must take care of that
    file’s ownership and permissions to ensure that there is never a point, no matter
    how brief, when the file is vulnerable to malicious manipulation. The following
    guidelines apply:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特权进程需要创建一个文件，那么我们必须注意该文件的所有权和权限，以确保在任何时候，即使是短暂的，文件也不会被恶意操控。以下指南适用：
- en: 'The process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")) should be set to a value that
    ensures that the process never creates publicly writable files, since these could
    be modified by a malicious user.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '进程的umask（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")）应设置为一个确保进程永远不会创建公开可写文件的值，因为这些文件可能会被恶意用户修改。'
- en: Since the ownership of a file is taken from the effective user ID of the creating
    process, judicious use of *seteuid()* or *setreuid()* to temporarily change process
    credentials may be required in order ensure that a newly created file doesn’t
    belong to the wrong user. Since the group ownership of the file *may* be taken
    from process’s effective group ID (see [Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")), a similar statement applies with respect to set-group-ID
    programs, and the corresponding group ID calls can be used to avoid such problems.
    (To be strictly accurate, on Linux, the owner of a new file is determined by the
    process’s file-system user ID, which normally has the same value as the process’s
    effective user ID; refer to Section 9.5.)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文件的所有权是由创建进程的有效用户 ID 获取的，因此可能需要谨慎使用*seteuid()*或*setreuid()*来临时更改进程凭据，以确保新创建的文件不会归属于错误的用户。由于文件的组所有权*可能*由进程的有效组
    ID 获取（参见[新文件的所有权](ch15.html#ownership_of_new_files "新文件的所有权")），对于设置组 ID 的程序也适用类似的说明，且可以使用相应的组
    ID 调用来避免此类问题。（严格来说，在 Linux 上，新文件的所有者是由进程的文件系统用户 ID 确定的，通常该 ID 的值与进程的有效用户 ID 相同；请参阅第
    9.5 节。）
- en: If a set-user-ID-*root* program must create a file that initially it must own,
    but which will eventually be owned by another user, the file should be created
    so that it is initially not writable by other users, either by using a suitable
    *mode* argument to *open()* or by setting the process umask before calling *open()*.
    Afterward, the program can change its ownership with *fchown()*, and then change
    its permissions, if necessary, with *fchmod()*. The key point is that a set-user-ID
    program should ensure that it never creates a file that is owned by the program
    owner and that is even momentarily writable by other users.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个设置用户 ID 为 *root* 的程序必须创建一个最初由它拥有的文件，但最终将由其他用户拥有，那么该文件应创建为最初不可被其他用户写入，无论是通过使用合适的*mode*参数来调用*open()*，还是通过在调用*open()*之前设置进程的
    umask。之后，程序可以使用*fchown()*更改文件所有权，并在必要时使用*fchmod()*更改文件权限。关键点是，设置用户 ID 的程序应该确保它永远不会创建一个由程序所有者拥有的文件，且该文件即使是短暂地可供其他用户写入。
- en: Checks on file attributes should be performed on open file descriptors (e.g.,
    *open()* followed by *fstat()*), rather than by checking the attributes associated
    with a pathname and then opening the file (e.g., *stat()* followed by *open()*).
    The latter method creates a time-of-use, time-of-check problem.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在打开的文件描述符上执行文件属性检查（例如，*open()* 后跟 *fstat()*），而不是通过检查与路径名关联的属性后再打开文件（例如，*stat()*
    后跟 *open()*）。后一种方法会引发使用时与检查时的时间问题。
- en: If a program must ensure that it is the creator of a file, then the `O_EXCL`
    flag should be used when calling *open()*.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个程序必须确保它是文件的创建者，那么在调用*open()*时应该使用`O_EXCL`标志。
- en: A privileged program should avoid creating or relying on files in publicly writable
    directories such as `/tmp`, since this leaves the program vulnerable to malicious
    attempts to create unauthorized files with names expected by the privileged program.
    A program that absolutely must create a file in a publicly writable directory
    should at least ensure that the file has an unpredictable name, by using a function
    such as *mkstemp()* ([Creating Temporary Files](ch05.html#creating_temporary_files
    "Creating Temporary Files")).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权程序应避免在公开可写的目录（如`/tmp`）中创建或依赖文件，因为这会使程序容易受到恶意攻击，创建未经授权的文件，且这些文件的名称会被特权程序所预期。必须在公开可写的目录中创建文件的程序，至少应确保文件名不可预测，可以使用诸如*mkstemp()*的函数（参见[创建临时文件](ch05.html#creating_temporary_files
    "创建临时文件")）。
- en: Don’t Trust Inputs or the Environment
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要信任输入或环境。
- en: Privileged programs should avoid making assumptions about the input they are
    given, or the environment in which they are running.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 特权程序应避免对其接收到的输入或运行环境做出假设。
- en: Don’t trust the environment list
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要信任环境列表。
- en: Set-user-ID and set-group-ID programs should not assume that the values of environment
    variables are reliable. Two variables that are particularly relevant are `PATH`
    and `IFS`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户 ID 和设置组 ID 的程序不应假设环境变量的值是可靠的。两个特别相关的变量是`PATH`和`IFS`。
- en: '`PATH` determines where the shell (and thus *system()* and *popen()*), as well
    as *execlp()* and *execvp()*, search for programs. A malicious user can set `PATH`
    to a value that may trick a set-user-ID program employing one of these functions
    into executing an arbitrary program with privilege. If these functions are to
    be used, PATH should be set to a trustworthy list of directories (but better still,
    absolute pathnames should be specified when execing programs). However, as already
    noted, it is best to drop privileges before execing a shell or employing one of
    the aforementioned functions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 确定 shell（以及 *system()* 和 *popen()*），以及 *execlp()* 和 *execvp()*，搜索程序的位置。恶意用户可以将
    `PATH` 设置为一个可能会欺骗一个使用这些函数的 set-user-ID 程序，从而使其以特权身份执行任意程序。如果要使用这些函数，`PATH` 应该设置为一个可信的目录列表（但更好的做法是，执行程序时指定绝对路径）。然而，如前所述，最好在执行
    shell 或使用上述函数之前先放弃特权。'
- en: '`IFS` specifies the delimiting characters that the shell interprets as separating
    the words of a command line. This variable should be set to an empty string, which
    means that only white-space characters are interpreted by the shell as word separators.
    Some shells always set `IFS` in this way on startup. ([Executing a Shell Command:
    *system()*](ch27.html#executing_a_shell_command_colon_system_o "Executing a Shell
    Command: system()") describes one vulnerability relating to `IFS` that appeared
    in older Bourne shells.)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFS` 指定 shell 解释为分隔命令行单词的定界字符。该变量应设置为空字符串，这意味着只有空白字符会被 shell 解释为单词分隔符。一些 shell
    在启动时始终以这种方式设置 `IFS`。([执行 Shell 命令：*system()*](ch27.html#executing_a_shell_command_colon_system_o
    "Executing a Shell Command: system()") 介绍了一个关于 `IFS` 的漏洞，该漏洞出现在早期的 Bourne shell
    中。)'
- en: In some cases, it may be safest to erase the entire environment list ([Environment
    List](ch06.html#environment_list-id1 "Environment List")), and then restore selected
    environment variables with known-safe values, especially when executing other
    programs or calling libraries that may be affected by environment variable settings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，最安全的做法是清除整个环境变量列表（[环境变量列表](ch06.html#environment_list-id1 "Environment
    List")），然后使用已知安全值恢复选定的环境变量，特别是在执行可能会受到环境变量设置影响的其他程序或调用库时。
- en: Handle untrusted user inputs defensively
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防御性地处理不可信的用户输入
- en: A privileged program should carefully validate all inputs from untrusted sources
    before taking action based on those inputs. Such validation may include verifying
    that numbers fall within acceptable limits, and that strings are of an acceptable
    length and consist of acceptable characters. Among inputs that may need to be
    validated in this way are those coming from user-created files, command-line arguments,
    interactive inputs, CGI inputs, email messages, environment variables, interprocess
    communication channels (FIFOs, shared memory, and so on) accessible by untrusted
    users, and network packets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 特权程序应在根据来自不可信来源的输入采取行动之前，仔细验证所有输入。这种验证可能包括检查数字是否在可接受的范围内，字符串是否具有可接受的长度，并且由可接受的字符组成。需要以这种方式验证的输入包括来自用户创建的文件、命令行参数、交互式输入、CGI
    输入、电子邮件消息、环境变量、不可信用户可访问的进程间通信通道（如FIFO、共享内存等）和网络数据包。
- en: Avoid unreliable assumptions about the process’s run-time environment
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免对进程的运行时环境做出不可靠的假设
- en: A set-user-ID program should avoid making unreliable assumptions about its initial
    run-time environment. For example, standard input, output, or error may have been
    closed. (These descriptors might have been closed in the program that execs the
    set-user-ID program.) In this case, opening a file could inadvertently reuse descriptor
    1 (for example), so that, while the program thinks it is writing to standard output,
    it is actually writing to the file it opened.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: set-user-ID 程序应避免对其初始运行时环境做出不可靠的假设。例如，标准输入、输出或错误可能已经被关闭。（这些描述符可能在执行 set-user-ID
    程序的程序中已经关闭。）在这种情况下，打开文件可能会无意中重用描述符 1（例如），因此，程序虽然认为它正在写入标准输出，但实际上它是在写入它打开的文件。
- en: There are many other possibilities to consider. For example, a process may exhaust
    various resource limits, such as the limit on the number of processes that may
    be created, the CPU time resource limit, or the file size resource limit, with
    the result that various system calls may fail or various signals may be generated.
    Malicious users may attempt to deliberately engineer resource exhaustion in an
    attempt to subvert a program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的可能性需要考虑。例如，某个进程可能会耗尽各种资源限制，例如可创建的进程数量限制、CPU 时间资源限制或文件大小资源限制，从而导致某些系统调用失败或生成各种信号。恶意用户可能会故意制造资源耗尽，以图破坏程序。
- en: Beware of Buffer Overruns
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心缓冲区溢出
- en: Beware of buffer overruns (overflows), where an input value or copied string
    exceeds the allocated buffer space. Never use *gets()*, and employ functions such
    as *scanf()*, *sprintf()*, *strcpy()*, and *strcat()* with caution (e.g., guarding
    their use with `if` statements that prevent buffer overruns).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 小心缓冲区溢出（overrun），即输入值或复制的字符串超出了分配的缓冲区空间。切勿使用*gets()*，并谨慎使用诸如*scanf()*、*sprintf()*、*strcpy()*和*strcat()*等函数（例如，使用`if`语句防止缓冲区溢出）。
- en: Buffer overruns allow techniques such as *stack crashing* (also known as *stack
    smashing*), whereby a malicious user employs a buffer overrun to place carefully
    coded bytes into a stack frame in order to force the privileged program to execute
    arbitrary code. (Several online sources explain the details of stack crashing;
    see also [Erickson, 2008] and [Anley, 2007].) Buffer overruns are probably the
    single most common source of security breaches on computer systems, as evidenced
    by the frequency of advisories posted by CERT ([http://www.cert.org/](http://www.cert.org/))
    and to Bugtraq ([http://www.securityfocus.com/](http://www.securityfocus.com/)).
    Buffer overruns are particularly dangerous in network servers, since they leave
    a system open to remote attack from anywhere on a network.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出可以导致诸如*栈崩溃*（也称为*栈破坏*）等技术，其中恶意用户利用缓冲区溢出来将精心编码的字节放入栈帧中，以迫使特权程序执行任意代码。（有多个在线来源解释了栈崩溃的细节；另见
    [Erickson, 2008] 和 [Anley, 2007]。）缓冲区溢出可能是计算机系统上最常见的安全漏洞来源，如CERT（[http://www.cert.org/](http://www.cert.org/)）和
    Bugtraq（[http://www.securityfocus.com/](http://www.securityfocus.com/)）发布的安全通报所证明。缓冲区溢出在网络服务器中尤其危险，因为它们使系统容易受到网络上任何地方的远程攻击。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to make stack crashing more difficult—in particular, to make such attacks
    much more time-consuming when conducted remotely against network servers—from
    kernel 2.6.12 onward, Linux implements *address-space randomization*. This technique
    randomly varies the location of the stack over an 8 MB range at the top of virtual
    memory. In addition, the locations of memory mappings may also be randomized,
    if the soft `RLIMIT_STACK` limit is not infinite and the Linux-specific `/proc/sys/vm/legacy_va_layout`
    file contains the value 0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使栈崩溃更为困难——特别是为了在远程攻击网络服务器时使这种攻击更加耗时——从内核 2.6.12 开始，Linux 实现了*地址空间随机化*。该技术在虚拟内存顶部的
    8 MB 范围内随机变化栈的位置。此外，如果软`RLIMIT_STACK`限制不是无限的，并且 Linux 特定的 `/proc/sys/vm/legacy_va_layout`
    文件包含值 0，则内存映射的位置也可以被随机化。
- en: More recent x86-32 architectures provide hardware support for marking page tables
    as *NX* (“no execute”). This feature is used to prevent execution of program code
    on the stack, thus making stack crashing more difficult.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版的 x86-32 架构提供了硬件支持，用于将页表标记为*NX*（"不执行"）。该功能用于防止在栈上执行程序代码，从而使栈崩溃更加困难。
- en: 'There are safe alternatives to many of the functions mentioned above—for example,
    *snprintf()*, *strncpy()*, and *strncat()*—that allow the caller to specify the
    maximum number of characters that should be copied. These functions take the specified
    maximum into account in order to avoid overrunning the target buffer. In general,
    these alternatives are preferable, but must still be handled with care. In particular,
    note the following points:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述提到的许多函数，存在安全的替代方案——例如*snprintf()*、*strncpy()*和*strncat()*——这些函数允许调用者指定应复制的最大字符数。它们会考虑指定的最大值，以避免溢出目标缓冲区。通常，这些替代方案更为推荐，但仍然需要谨慎处理。特别需要注意以下几点：
- en: With most of these functions, if the specified maximum is reached, then a truncated
    version of the source string is placed in the target buffer. Since such a truncated
    string may be meaningless in terms of the semantics of the program, the caller
    must check if truncation occurred (e.g., using the return value from *snprintf()*),
    and take appropriate action if it has.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数这些函数，如果达到了指定的最大值，则会将源字符串的截断版本放入目标缓冲区。由于这种截断的字符串在程序语义上可能没有意义，因此调用者必须检查是否发生了截断（例如，使用*snprintf()*的返回值），并在发生时采取适当的措施。
- en: Using *strncpy()* can carry a performance impact. If, in the call *strncpy(s1*,
    *s2*, *n*), the string pointed to by *s2* is less than *n* bytes in length, then
    padding null bytes are written to *s1* to ensure that *n* bytes in total are written.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*strncpy()*可能会影响性能。如果在调用*strncpy(s1*, *s2*, *n*)时，*s2*指向的字符串长度小于*n*字节，那么将会向*s1*写入填充的空字节，以确保总共写入*n*字节。
- en: If the maximum size value given to *strncpy()* is not long enough to permit
    the inclusion of the terminating null character, then the target string is *not*
    null-terminated.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给*strncpy()*的最大大小值不足以包括终止空字符，那么目标字符串将*不会*以空字符结尾。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations provide the *strlcpy()* function, which, given a length
    argument *n*, copies at most *n - 1* bytes to the destination buffer and always
    appends a null character at the end of the buffer. However, this function is not
    specified in SUSv3 and is not implemented in *glibc*. Furthermore, in cases where
    the caller is not carefully checking string lengths, this function only substitutes
    one problem (buffer overflows) for another (silently discarding data).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现提供了*strlcpy()*函数，该函数接受一个长度参数*n*，最多将*n - 1*字节复制到目标缓冲区，并始终在缓冲区末尾附加一个空字符。然而，这个函数并未在SUSv3中指定，也未在*glibc*中实现。此外，在调用者没有仔细检查字符串长度的情况下，这个函数只是将一个问题（缓冲区溢出）替换成另一个问题（悄悄丢弃数据）。
- en: Beware of Denial-of-Service Attacks
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警惕拒绝服务攻击
- en: With the increase in Internet-based services has come a corresponding increase
    in the opportunities for remote denial-of-service attacks. These attacks attempt
    to make a service unavailable to legitimate clients, either by sending the server
    malformed data that causes it to crash or by overloading it with bogus requests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基于互联网的服务增多，远程拒绝服务攻击的机会也相应增加。这些攻击试图通过向服务器发送格式错误的数据导致其崩溃，或通过向其发送大量虚假请求来使服务对合法客户端不可用。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Local denial-of-service attacks are also possible. The most well-known example
    is when a user runs a simple fork bomb (a program that repeatedly forks, thus
    consuming all of the process slots on the system). However, the origin of local
    denial-of-service attacks is much easier to determine, and they can generally
    be prevented by suitable physical and password security measures.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本地拒绝服务攻击也是可能的。最著名的例子是当用户运行一个简单的fork炸弹（一个反复创建子进程的程序，从而消耗掉系统中的所有进程槽）。然而，本地拒绝服务攻击的来源更容易确定，通常可以通过适当的物理和密码安全措施来防止。
- en: Dealing with malformed requests is straightforward—a server should be programmed
    to rigorously check its inputs and avoid buffer overruns, as described above.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 处理格式错误的请求很简单——服务器应该编程严格检查其输入并避免缓冲区溢出，如上所述。
- en: 'Overload attacks are more difficult to deal with. Since the server can’t control
    the behavior of remote clients or the rate at which they submit requests, such
    attacks are impossible to prevent. (The server may not even be able to determine
    the true origin of the attack, since the source IP address of a network packet
    can be spoofed. Alternatively, distributed attacks may enlist unwitting intermediary
    hosts to direct an attack at a target system.) Nevertheless, various measures
    can be taken to minimize the risk and consequences of an overload attack:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 过载攻击更难处理。由于服务器无法控制远程客户端的行为或请求提交的速率，因此这些攻击是无法防止的。（服务器甚至可能无法确定攻击的真实来源，因为网络数据包的源IP地址可以被伪造。此外，分布式攻击可能会招募不知情的中介主机，将攻击指向目标系统。）尽管如此，可以采取各种措施来最小化过载攻击的风险和后果：
- en: The server should perform load throttling, dropping requests when the load exceeds
    some predetermined limit. This will have the consequence of dropping legitimate
    requests, but prevents the server and host machine from becoming overloaded. The
    use of resource limits and disk quotas may also be helpful in limiting excessive
    loads. (Refer to [http://sourceforge.net/projects/linuxquota/](http://sourceforge.net/projects/linuxquota/)
    for more information on disk quotas.)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应进行负载限制，在负载超过预定限制时丢弃请求。这将导致合法请求被丢弃，但能防止服务器和主机机器过载。使用资源限制和磁盘配额也有助于限制过度的负载。（有关磁盘配额的更多信息，请参见
    [http://sourceforge.net/projects/linuxquota/](http://sourceforge.net/projects/linuxquota/)）。
- en: A server should employ timeouts for communication with a client, so that if
    the client (perhaps deliberately) doesn’t respond, the server is not tied up indefinitely
    waiting on the client.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应该对与客户端的通信设置超时，这样如果客户端（可能是故意的）不响应，服务器就不会无限期地等待客户端。
- en: In the event of an overload, the server should log suitable messages so that
    the system administrator is notified of the problem. (However, logging should
    be throttled, so that logging itself does not overload the system.)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现过载的情况下，服务器应记录适当的消息，以便系统管理员能及时了解到问题。（不过，日志记录应该受到限制，以防止日志记录本身导致系统过载。）
- en: The server should be programmed so that it doesn’t crash in the face of an unexpected
    load. For example, bounds checking should be rigorously performed to ensure that
    excessive requests don’t overflow a data structure.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应该进行编程，以便在面对意外负载时不会崩溃。例如，应严格进行边界检查，确保过多的请求不会溢出数据结构。
- en: Data structures should be designed to avoid *algorithmic-complexity attacks*.
    For example, a binary tree may be balanced and deliver acceptable performance
    under typical loads. However, an attacker could construct a sequence of inputs
    that result in an unbalanced tree (the equivalent of a linked list in the worst
    case), which could cripple performance. [Crosby & Wallach, 2003] details the nature
    of such attacks and discusses data-structuring techniques that can be used to
    avoid them.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构应设计为避免*算法复杂性攻击*。例如，二叉树可以平衡并在典型负载下提供可接受的性能。然而，攻击者可能构造一系列输入，导致树不平衡（在最坏的情况下相当于链表），这可能会严重影响性能。[Crosby
    & Wallach, 2003] 详细说明了此类攻击的性质，并讨论了可用于避免这些攻击的数据结构技术。
- en: Check Return Statuses and Fail Safely
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查返回状态并安全失败
- en: A privileged program should always check to see whether system calls and library
    functions succeed, and whether they return expected values. (This is true for
    all programs, of course, but is especially important for privileged programs.)
    Various system calls can fail, even for a program running as *root*. For example,
    *fork()* may fail if the system-wide limit on the number of processes is encountered,
    an *open()* for writing may fail on a read-only file system, or *chdir()* may
    fail if the target directory doesn’t exist.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 特权程序应始终检查系统调用和库函数是否成功，并且它们是否返回了预期的值。（当然，这对所有程序都是正确的，但对于特权程序尤其重要。）各种系统调用可能会失败，即使程序以*root*身份运行。例如，如果系统级进程数限制被触及，*fork()*可能会失败；如果在只读文件系统上执行*open()*以进行写入，可能会失败；或者，如果目标目录不存在，*chdir()*可能会失败。
- en: 'Even where a system call succeeds, it may be necessary to check its result.
    For example, where it matters, a privileged program should check that a successful
    *open()* has not returned one of the three standard file descriptors: 0, 1, or
    2.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使系统调用成功，也可能需要检查其结果。例如，在需要的情况下，特权程序应检查成功的*open()*是否没有返回三个标准文件描述符之一：0、1或2。
- en: Finally, if a privileged program encounters an unexpected situation, then the
    appropriate behavior is usually either to terminate or, in the case of a server,
    to drop the client request. Attempting to fix unexpected problems typically requires
    making assumptions that may not be justified in all circumstances and may lead
    to the creation of security loopholes. In such situations, it is safer to have
    the program terminate, or to have the server log a message and discard the client’s
    request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果特权程序遇到意外情况，通常的适当行为是终止程序，或者在服务器的情况下，丢弃客户端请求。尝试修复意外问题通常需要做出假设，这些假设在所有情况下可能并不成立，并可能导致安全漏洞的产生。在这种情况下，最好让程序终止，或者让服务器记录日志并丢弃客户端的请求。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Privileged programs have access to system resources that are not available
    to ordinary users. If such programs can be subverted, then the security of the
    system can be compromised. In this chapter, we presented a set of guidelines for
    writing privileged programs. The aim of these guidelines is twofold: to minimize
    the chances of a privileged program being subverted, and to minimize the damage
    that can be done in the event that a privileged program is subverted.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特权程序可以访问普通用户无法访问的系统资源。如果这些程序被破坏，系统的安全性就会受到威胁。在本章中，我们提供了一套编写特权程序的指南。这些指南的目的是双重的：一是尽量减少特权程序被破坏的可能性，二是尽量减少在特权程序被破坏时可能造成的损害。
- en: Further information
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Viega & McGraw, 2002] covers a broad range of topics relating to the design
    and implementation of secure software. General information about security on UNIX
    systems, as well as a chapter on secure-programming techniques can be found in
    [Garfinkel et al., 2003]. Computer security is covered at some length in [Bishop,
    2005], and at even greater length by the same author in [Bishop, 2003]. [Peikari
    & Chuvakin, 2004] describes computer security with a focus on the various means
    by which system may be attacked. [Erickson, 2008] and [Anley, 2007] both provide
    a thorough discussion of various security exploits, providing enough detail for
    wise programmers to avoid these exploits. [Chen et al., 2002] is a paper describing
    and analyzing the UNIX set-user-ID model. [Tsafrir et al., 2008] revises and enhances
    the discussion of various points in [Chen et al., 2002]. [Drepper, 2009] provides
    a wealth of tips on secure and defensive programming on Linux.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[Viega & McGraw, 2002] 涵盖了与安全软件设计和实施相关的广泛主题。有关UNIX系统安全性的一般信息，以及关于安全编程技巧的章节，可以在[Garfinkel
    等, 2003]中找到。[Bishop, 2005]详细介绍了计算机安全，Bishop 同一作者在[Bishop, 2003]中更为深入地讨论了这一主题。[Peikari
    & Chuvakin, 2004]描述了计算机安全，重点介绍了系统可能遭受攻击的各种方式。[Erickson, 2008] 和 [Anley, 2007]
    都对各种安全漏洞进行了深入讨论，提供了足够的细节，帮助明智的程序员避免这些漏洞。[Chen 等, 2002] 是一篇描述和分析UNIX set-user-ID模型的论文。[Tsafrir
    等, 2008] 修订并增强了[Chen 等, 2002]中的讨论。[Drepper, 2009] 提供了关于Linux上安全和防御性编程的大量技巧。'
- en: 'Several sources of information about writing secure programs are available
    online, including the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写安全程序的多个信息来源可以在线获取，包括以下内容：
- en: 'Matt Bishop has written a range of security-related papers, which are available
    online at [http://nob.cs.ucdavis.edu/~bishop/secprog](http://nob.cs.ucdavis.edu/~bishop/secprog).
    The most interesting of these is “How to Write a Setuid Program,” (originally
    published in *;login: 12(1) Jan/Feb 1986*). Although somewhat dated, this paper
    contains a wealth of useful tips.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Matt Bishop 写了许多与安全相关的论文，这些论文可以在[http://nob.cs.ucdavis.edu/~bishop/secprog](http://nob.cs.ucdavis.edu/~bishop/secprog)上在线获取。其中最有趣的一篇是《如何编写Setuid程序》，（最初发表于*;login:
    12(1) Jan/Feb 1986*）。虽然有些过时，但这篇论文包含了大量有用的技巧。'
- en: The *Secure Programming for Linux and Unix HOWTO*, written by David Wheeler,
    is available at [http://www.dwheeler.com/secure-programs/](http://www.dwheeler.com/secure-programs/).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由David Wheeler编写的*Linux和Unix安全编程指南*可以在[http://www.dwheeler.com/secure-programs/](http://www.dwheeler.com/secure-programs/)在线获取。
- en: A useful checklist for writing set-user-ID programs is available online at [http://www.homeport.org/~adam/setuid.7.html](http://www.homeport.org/~adam/setuid.7.html).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于编写set-user-ID程序的有用清单可以在[http://www.homeport.org/~adam/setuid.7.html](http://www.homeport.org/~adam/setuid.7.html)在线获取。
- en: Exercises
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Log in as a normal, unprivileged user, create an executable file (or copy an
    existing file such as `/bin/sleep`), and enable the set-user-ID permission bit
    on that file (*chmod u+s*). Try modifying the file (e.g., *cat >> file*). What
    happens to the file permissions as a result (*ls -l*)? Why does this happen?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以普通无特权用户身份登录，创建一个可执行文件（或复制一个现有文件，如`/bin/sleep`），并在该文件上启用set-user-ID权限位（*chmod
    u+s*）。尝试修改该文件（例如，*cat >> file*）。文件权限会发生什么变化（*ls -l*）？为什么会发生这种情况？
- en: 'Write a set-user-ID-*root* program similar to the *sudo(8)* program. This program
    should take command-line options and arguments as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类似于*sudo(8)*程序的set-user-ID-*root*程序。该程序应支持以下命令行选项和参数：
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *douser* program executes *program-file*, with the given arguments, as though
    it was run by *user*. (If the *-u* option is omitted, then *user* should default
    to *root*.) Before executing *program-file*, *douser* should request the password
    for *user*, authenticate it against the standard password file (see [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "Example 8-2. Authenticating a user against the shadow password file"), in [Summary](ch08.html#summary-id7
    "Summary")), and then set all of the process user and group IDs to the correct
    values for that user.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*douser*程序执行*program-file*，并使用给定的参数，就像是由*user*运行的一样。（如果省略了*-u*选项，则*user*默认应为*root*。）在执行*program-file*之前，*douser*应该请求输入*user*的密码，并与标准密码文件进行身份验证（参见[示例
    8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2. 使用shadow密码文件验证用户身份")，在[总结](ch08.html#summary-id7
    "总结")中），然后将所有进程的用户和组ID设置为该用户的正确值。'
