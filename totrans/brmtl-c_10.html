<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="141" id="Page_141"/>9</span><br/>
<span class="ChapterTitle">Serial Output on the STM</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">We’re now back to “Hello World,” only this time we’ll use our Nucleo board, which presents several challenges. The first is where to write the message. There is no display. Fortunately, the chip has a serial port that’s nicely connected to a USB/serial port on the top half of the board.</p>
<p>The next challenge is the writing itself. We need to initialize the device and create a procedure to actually write a character. The device is designed to accept one character at a time, and we must keep that limitation in mind when writing our program.</p>
<p>We’ll simulate the process before working with the device. C has a great deal of standard functions, such as <code>puts</code>, that make outputting data easy. The Nucleo board doesn’t have such nice features, so we must write our own output functions. In order to transition into the low-level coding we need for the Nucleo, we’ll write out “Hello World” one character at a time.</p>
<h2 id="h1-501621c09-0001"><span epub:type="pagebreak" title="142" id="Page_142"/>Writing a String One Character at a Time</h2>
<p class="BodyFirst">When a C program calls the standard <code>puts</code> function, it starts a long programming process that involves kernel calls, internal buffering, interrupt scheduling, and device drivers (more on those in the next chapter). Ultimately, it reaches the point where it sends one character at a time to the device. To simulate this, we’ll send one character at a time to the operating system. In other words, we’ll limit ourselves to using only the standard <code>putchar</code> function to write the output.</p>
<p><a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> contains a program that writes out <code>"Hello World\n"</code> the hard way. Again, we’re doing this the hard way because later, with the Nucleo board, we’re going to have to do it the <em>really</em> hard way.</p>
<p class="CodeLabel"><b>putchar.c</b></p>
<pre><code>/*
 * Print a string one character at a time.
 */
#include &lt;stdio.h&gt;
  
char hello[] = "Hello World\n"; // The characters to print
int curChar;    // Character number we are printing
  
int main()
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> for (curChar = 0; hello[curChar] != '\0'; ++curChar)
        putchar(hello[curChar]);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><em><a id="listing9-1">Listing 9-1</a>: Writing a string one character at a time</em></p>
<p>The only interesting piece in this program is the <code>for</code> loop <span class="CodeAnnotation" aria-label="annotation1">1</span>, which does not stop after a certain number of characters. Instead, it stops when the program reaches the end-of-string (<code>'\0'</code>) character. That way, the program can output any length of string.</p>
<h3 id="h2-501621c09-0001">Defining Our Own putchar</h3>
<p class="BodyFirst">To improve this program, first we’ll make <code>curChar</code> a local variable. Then we’ll define a function called <code>myPutchar</code> that sends the character to standard out (see <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a>).</p>
<p class="CodeLabel"><b>my_putchar.c</b></p>
<pre><code>/**
 * Print a string one character at a time
 * using our own function.
 */
#include &lt;stdio.h&gt;
  
char hello[] = "Hello World\n"; // The characters to print
  
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> /**
 * Reimplementation of putchar
 *
 * @param ch The character to send
<span epub:type="pagebreak" title="143" id="Page_143"/> *
 * @note Not as apparently useless as it seems
 */
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void myPutchar(const char ch)
{
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> putchar(ch);
}
  
int main()
{
    int curChar;        // Index of the current character we
                        // are printing
    for (curChar = 0; hello[curChar] != '\0'; ++curChar)
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> myPutchar(hello[curChar]);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><em><a id="listing9-2">Listing 9-2</a>: One character at a time using our own output function</em></p>
<p>At the beginning of <code>myPutchar</code>, we’ve added some additional elements <span class="CodeAnnotation" aria-label="annotation1">1</span> to the comment block. The keyword <code>@param</code> indicates a parameter, and the <code>@note</code> keyword defines a note. You can use lots of other keywords in Doxygen-style comments, but for now we’ll use the basics to be compatible with the existing STM code.</p>
<p>The actual function starts with the <code>void myPutchar(const char ch) </code>declaration <span class="CodeAnnotation" aria-label="annotation2">2</span>, which indicates that the <code>myPutchar</code> procedure returns nothing and takes one parameter of type <code>char</code>. The <code>const</code> modifier indicates that we don’t change it inside the procedure. (In fact, we can’t change it, because if we try, the compiler will generate an error.)</p>
<p>When the procedure is executed <span class="CodeAnnotation" aria-label="annotation4">4</span>, the program performs the following steps:</p>
<ol class="decimal">
<li value="1">It computes the value of <code>hello[curChar]</code>.</li>
<li value="2">It places this value in a location where <code>myPutchar</code> can find it.</li>
<li value="3">It records the address of the next instruction (the end of the <code>for</code> loop).</li>
<li value="4">It starts executing <code>myPutchar</code>. (The <code>ch</code> variable will have been initialized by step 2.)</li>
</ol>
<p>A similar set of steps is executed when we call <code>putchar</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The only difference is that we had to write <code>myPutchar</code>, and the people who wrote the standard C library supplied <code>putchar</code>.</p>
<p>Creating a function (<code>myPutchar</code>) that does nothing but call another (<code>putchar</code>) is not very useful. The Nucleo board doesn’t have a <code>putchar</code> function, so we’ll write our own later in the chapter. But before we do that, let’s look at the details of the serial device.</p>
<h2 id="h1-501621c09-0002">Serial Output</h2>
<p class="BodyFirst">Serial output is one of the easiest ways to get data out of an embedded system. The electrical interface consists of a send line (TX), a receive line <span epub:type="pagebreak" title="144" id="Page_144"/>(RX), and ground (GND). Most embedded systems have them hidden away, available only to developers willing to crack open the case and connect to the serial port.</p>
<p>Our chip has a serial device we can write to. All we need to do is connect TX, RX, and GND between our microcontroller (the bottom half of the development board) and the USB/serial device on the top half of the board.</p>
<p>The following table shows the connections we need:</p>
<table id="tabular-501621c09-0001" border="1">
<thead>
<tr>
<td colspan="2"><b>Microcontroller</b></td>
<td colspan="2"><b>USB/serial and other support devices</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>RX</td>
<td>CN9-1</td>
<td>TX</td>
<td>CN3-1</td>
</tr>
<tr>
<td>TX</td>
<td>CN9-2</td>
<td>RX</td>
<td>CN3-2</td>
</tr>
<tr>
<td>GND</td>
<td>CN6-5</td>
<td>GND</td>
<td>CN4-3</td>
</tr>
</tbody>
</table>
<p>We would have to make these connections if we had a Raspberry Pi or other embedded system without a built-in serial controller. <a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a> shows the layout of these components and the internal wiring supplied by STM.</p>
<p>STM has already made the connections for us. No jumpers needed.</p>
<figure>
<img src="image_fi/501621c09/f09001.png" alt="f09001" class=""/>
<figcaption><p><a id="figure9-1">Figure 9-1</a>: Serial communications on the Nucleo board</p></figcaption>
</figure>
<h3 id="h2-501621c09-0002"><span epub:type="pagebreak" title="145" id="Page_145"/>A Brief History of Serial Communications</h3>
<p class="BodyFirst">Serial communications go back a long way, back to the BC years (as in, <em>before computers</em>). The telegraph was the internet of its day, allowing for the transmission of long-distance messages over wires. The sender consisted of a telegraph key that, when pressed, would cause the receiver to “click.” The clicks were encoded using a system called <em>Morse code</em> (still in use today). This invention revolutionized communications. You could send a message to the next city and get a response the same day. Take that, Pony Express.</p>
<p>There was just one problem, however; you needed skilled operators at both ends of the telegraph who knew Morse code. Unskilled people could not send or receive messages, and training operators was expensive. One solution was to use two clocks: one for the transmitter and one for the receiver. On the clock dial were the letters, from <em>A</em> to <em>Z</em>. To send an <em>S</em>, for example, the sender would wait until the single hand on the clock pointed to the <em>S</em> and press the telegraph key. The receiver would see that the hand pointed to <em>S</em> and record the letter.</p>
<p>Keeping the clocks in sync was next to impossible, though, so a very smart inventor decided that each clock would stop its hands at the top position. When the sender wanted to send a letter, they would press the telegraph key as a <em>start signal</em>. The clocks would keep good enough time to make it around the dial once correctly. The sender would then press the letter signal. When the hand reached the top, a short pause called the <em>stop time</em> would give the slower clock a chance to catch up. The sequence of events went like this: start signal, letter signal, stop time.</p>
<p>Now let’s fast-forward to the invention of the teletype machine, which could send text over the equivalent of telegraph lines. Instead of a single letter pulse, the teletype encoded the characters into a series of eight pulses (seven for data and one for primitive error checking). It used a keyboard encoder built out of levers to turn a key press into an 8-bit code that was fed to a mechanical shift register that looked like a distributor cap. This device sent the pulses down the wire, where another teletype would turn them into a single printed letter.</p>
<p>The teletype sequence went like this: The sender would press a key, and the mechanical sender would send out a 10-bit signal (1 start bit, 8 data bits, and 1 stop bit). When the receiver got the start bit, it turned on its shift register (another motor with a distributor cap) and used the incoming pulses to turn a print head so the right letter printed. After the 8 data bits were sent, both machines paused at least 1 bit time (the stop bit) to remain synchronized.</p>
<p>Most teletypes could transmit characters at 110 baud (bits/second), or 10 characters a second. That doesn’t sound like much in the day of megabit internet connections, but it was a revolutionary improvement in communications.</p>
<p>Computers today still use the serial communication that the teletype used. The speeds have improved, but the basic protocol remains the same.</p>
<h4 id="h3-501621c09-0001"><span epub:type="pagebreak" title="146" id="Page_146"/>Line Endings</h4>
<p class="BodyFirst">In fact, we’re still dealing with one other teletype legacy: line endings. After typing 80 characters, you could send the machine a character called a <em>carriage return</em> to make it return to position 1. The problem was that it took two-tenths of a second to move the printhead. If you sent a character immediately after the carriage return, you’d get a blurred blob printed in the middle of the line as the printhead tried to print while moving.</p>
<p>The teletype people solved this issue by making the end of a line two characters. The first, the carriage return, moved the print head to position 1. The second, the line feed, moved the paper up one line. Since the line feed didn’t print anything on the paper, the fact that it was done while the printhead was flying to the left didn’t matter.</p>
<p>However, when computers came out, storage cost a lot of money (hundreds of dollars <em>per</em> <em>byte</em>), so storing two characters for an end of line was costly. The people who created Unix, the inspiration for Linux, decided to use the line feed (<code>\n</code>) character only. Apple decided to use the carriage return (<code>\r</code>) only, and Microsoft decided to use both the carriage return and the line feed (<code>\r\n</code>) for its line ending.</p>
<p>C automatically handles the different types of newlines in the system library, but only when you use the system library. If you are doing it yourself, like we are about to do, you must write out the full end-of-line sequence (<code>\r\n</code>).</p>
<h4 id="h3-501621c09-0002">Serial Communications Today</h4>
<p class="BodyFirst">Today, almost every embedded processor has a serial interface on it. Serial devices are simple and cheap to make. The only difference between the interface of today and that of the 1800s is that speed has gone up (from 110 bits/second up to 115,200 bits/second), and the voltages have changed. In the 1800s they used –15 to –3 as a zero bit and +3 to +15 as a one bit. That’s still the “standard,” but most computers use voltages of 0 (for zero) and 3 (for one).</p>
<p>The device that handles the serial I/O is called a <em>universal asynchronous receiver-transmitter (UART)</em>. There are two major types of serial communication: <em>asynchronous</em> and <em>synchronous</em>. With synchronous communications, the sender’s and receiver’s clocks must be synchronized by having the sender continually send out characters. The receiver then looks at the incoming characters and deduces the clock timing from them. The sender must always send characters, even if it’s just an “idle” character (indicating no data). With asynchronous communications, there is no shared clock. The start bit triggers the receiver to start its clock and look for a character. Asynchronous communications assume that the sender and receiver can keep their clocks close enough together for one character time. Because there is no need for continuous transmissions to keep the clocks synchronized, there is no idle character. When idle, the transmitter just doesn’t send anything.</p>
<p>The STM chip has one port that allows for both synchronous and asynchronous communications, so in the STM documentation, you’ll see it referred to as a <em>universal synchronous/asynchronous receiver-transmitter (USART)</em>. This program uses the term <em>UART</em> to be compatible with the STM HAL library.</p>
<h3 id="h2-501621c09-0003"><span epub:type="pagebreak" title="147" id="Page_147"/>Serial Hello World!</h3>
<p class="BodyFirst">Let’s create a new project for <em>main.c</em>, which is a somewhat long “Hello World,” but it has to do all the things that the operating system hides from us. First, we include the header files that define the information about the UART (and lots of other devices as well):</p>
<pre><code>#include "stm32f0xx.h"
#include "stm32f0xx_nucleo.h"</code></pre>
<p>For the code, we’ll start with the <code>main</code> function:</p>
<pre><code>int main(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> HAL_Init(); // Initialize hardware.
    led2_Init();
    uart2_Init();
 
    // Keep sending the message for a long time.
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> for (;;) {
        // Send character by character.
        for(current = 0; hello[current] != '\0'; ++current) {
          <span class="CodeAnnotationCode" aria-label="annotation3">3</span> myPutchar(hello[current]);
        }
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> HAL_Delay(500);
    }
}</code></pre>
<p>The <code>main</code> function looks pretty much like the one in Listings 9-1 and 9-2. One addition is that it must initialize all the devices we’re going to use <span class="CodeAnnotation" aria-label="annotation1">1</span>, including the hardware library (<code>HAL_Init</code>), the red LED (<code>led2_Init</code>), and the UART (<code>uart2_Init</code>). Our embedded program can’t stop, so we have an infinite loop <span class="CodeAnnotation" aria-label="annotation2">2</span> that sends out the string <span class="CodeAnnotation" aria-label="annotation3">3</span> and then sleeps for half a second <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>One of the first things to do next is create an <code>ErrorHandler</code> function, which the HAL library calls if something goes wrong. We can’t print an error message, because our printing code just went south, so we resort to blinking the red light. True, it’s a very limited error indication, but so is the check engine light in your car. In both cases, the designers are doing the best they can. We won’t go through the <code>Error_Handler</code> function here; it’s “blink” from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> with a new name.</p>
<h3 id="h2-501621c09-0004">UART Initialization</h3>
<p class="BodyFirst">A serial device should be simple to program. The engineers at STMicroelectronics, however, have decided to improve the simple UART by providing additional features. As a result, our simple serial device now takes 45 pages worth of reference manual to describe. We just want to use the thing to send characters. It doesn’t even need to receive them.</p>
<p>Fortunately, the HAL library provides a function called <code>HAL_UART_Init</code> that hides many of the messy details from us. Unfortunately, it doesn’t hide <span epub:type="pagebreak" title="148" id="Page_148"/>the messy details of calling <code>HAL_UART_Init</code>, but you can’t have everything. In the <code>uart2_Init</code> function, we have to set up an initialization structure and then call <code>HAL_UART_Init</code>:</p>
<pre><code>void uart2_Init(void)
{
    // UART initialization
    // UART2 -- one connected to ST-LINK USB
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> uartHandle.Instance = USART2;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> uartHandle.Init.BaudRate = 9600;                   // Speed 9600
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> uartHandle.Init.WordLength = UART_WORDLENGTH_8B;   // 8 bits/character
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> uartHandle.Init.StopBits = UART_STOPBITS_1;        // 1 stop bit
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> uartHandle.Init.Parity = UART_PARITY_NONE;         // No parity
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> uartHandle.Init.Mode = UART_MODE_TX_RX;            // Transmit &amp; receive
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;   // No hw control

    // Oversample the incoming stream.
    uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;

    // Do not use one-bit sampling.
  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> uartHandle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;

    // Nothing advanced
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> uartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    /*
     * For those of you connecting a terminal emulator, the above parameters
     * translate to 9600,8,N,1.
     */
 
    if (HAL_UART_Init(&amp;uartHandle) != HAL_OK)
    {
        Error_Handler();
    }
}</code></pre>
<p>We first tell the system which UART to use <span class="CodeAnnotation" aria-label="annotation1">1</span>. Our chip has more than one, and the second one is connected to the USB serial interface. Next, we set the speed to 9,600 baud (bits/second) <span class="CodeAnnotation" aria-label="annotation2">2</span>, or 960 characters a second. Why the 10 to 1 ratio? We have 1 bit for the start bit, 8 data bits, and 1 stop bit. The number of bits per character is 8, because C stores characters in 8-bit units. It is possible to have systems with 5, 6, 7, or 9 bits per character, but almost everyone uses 8, except for a TDD deaf communication device, which uses 5. We need to tell the system that we’re using 8 bits <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>The next line configures the number of stop bits <span class="CodeAnnotation" aria-label="annotation4">4</span>, which is the amount of time (in bits) that occurs between characters. Most people use 1 stop bit. (If the sender uses 2 and the receiver uses 1, it still works. The extra bit will be interpreted as between-character idle time.)</p>
<p>Early serial devices used a 7-bit character and 1 parity bit. The parity bit provided a simple, primitive method of error checking. We do not use this feature, so we turn parity off <span class="CodeAnnotation" aria-label="annotation5">5</span>. We then enable the transmitter and receiver <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p><span epub:type="pagebreak" title="149" id="Page_149"/>The original serial interface (RS-232 standard) has a number of hardware flow control lines. On our board, they are not wired up, and we don’t use them <span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<p>One of this UART’s advanced features is <em>oversampling</em>, which allows the receiver to check the state of an incoming bit multiple times before deciding whether it is a one or a zero. This feature is sometimes useful when you have a noisy electrical environment and are running serial cables over long distances. Our serial “cable” consists of two traces that run from the bottom of the board to the top, a distance of about 3 inches. We don’t need oversampling, but we do have to turn it off <span class="CodeAnnotation" aria-label="annotation8">8</span>. Finally, we are not using any advanced features.</p>
<p>Next, we call <code>HAL_UART_Init</code> to initialize the UART <span class="CodeAnnotation" aria-label="annotation9">9</span>, which needs help to do its job. The general-purpose input/output (GPIO) pins on our processor can do a lot of different things, including act as GPIO pins. Most of them have “alternate functions,” meaning that you can program them to act as different devices (GPIO pin, USART device, SPI bus, I2C bus, PWM pin, and so on). Note that not all pins support all devices. Finally, <code>HAL_UART_Init</code> calls <code>HAL_UART_MspInit</code>, which sets up pins for the UART:</p>
<pre><code>HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation. */
  if(huart == NULL)
  {
    return HAL_ERROR;
  }
  // ...
  if(huart-&gt;gState == HAL_UART_STATE_RESET)
  {
    /* Allocate lock resource and initialize it. */
    huart-&gt;Lock = HAL_UNLOCKED;

    /* Initialize the low-level hardware: GPIO, CLOCK. */
    HAL_UART_MspInit(huart);
  }</code></pre>
<p>We need to supply <code>HAL_UART_MspInit</code>. Keep in mind that pins are expensive and transistors to drive them are cheap. By default, the two pins that drive our serial device, named PA2 and PA3, are GPIO pins. We need to tell the system to use the pins’ alternate function and turn them into serial device pins.</p>
<p>Our <code>HAL_UART_MspInit</code> function looks a lot like the initialization code for the GPIO pin we used for “blink,” but with some slight differences:</p>
<pre><code>void HAL_UART_MspInit(UART_HandleTypeDef* uart)
{
    GPIO_InitTypeDef GPIO_InitStruct;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if(uart-&gt;Instance == USART2)
    {
        /* Peripheral clock enable */
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> __HAL_RCC_USART2_CLK_ENABLE();

<span epub:type="pagebreak" title="150" id="Page_150"/>        /*
         * USART2 GPIO Configuration
         * PA2     ------&gt; USART2_TX
         * PA3     ------&gt; USART2_RX
         */
        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        // Alternate function -- that of UART
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
    }
}</code></pre>
<p>This function starts by checking which USART we are using. We only set up USART2 in this code <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then we enable the clock for the device <span class="CodeAnnotation" aria-label="annotation2">2</span>. Next, we configure the GPIO pins <span class="CodeAnnotation" aria-label="annotation3">3</span> (we’ve done this before in our blink program), which tells the chip that PA2/PA3 are not GPIO pins but instead should be connected to USART2.</p>
<h3 id="h2-501621c09-0005">Transmitting a Character</h3>
<p class="BodyFirst">We’ll use the <code>myPutchar</code> function to transmit characters over the serial device. The USART is a memory-mapped I/O device. To send a character, we have to assign (write) it to the magic memory location (a <em>register</em>), and then it goes out the wire:</p>
<pre><code>uartHandle.Instance-&gt;TDR = ch;     // Send character to the UART.</code></pre>
<p>We also need to time the character just right, and that requires some extra code:</p>
<pre><code>void myPutchar(const char ch)
{
    // This line gets and saves the value of UART_FLAG_TXE at call
    // time. This value changes so if you stop the program on the "if"
    // line below, the value will be set to zero because it goes away
    // faster than you can look at it.
    int result __attribute__((unused)) =
        (uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE);

    // Block until the transmit empty (TXE) flag is set.
    while ((uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE) == 0)
        continue;
  
    uartHandle.Instance-&gt;TDR = ch;     // Send character to the UART.
}</code></pre>
<p><span epub:type="pagebreak" title="151" id="Page_151"/>The register we are writing is called the <em>transmit data register (TDR)</em>. If we write this register while a character is being transmitted, the new character overwrites the old one, causing errors and confusion. To send <code>a</code>, <code>b</code>, <code>c</code>, we’d write code like this:</p>
<pre><code>uartHandle.Instance-&gt;TDR = 'a';
sleep_1_960_second();
uartHandle.Instance-&gt;TDR = 'b';
sleep_1_960_second();
uartHandle.Instance-&gt;TDR = 'c';
sleep_1_960_second();</code></pre>
<p>This sort of timing is tricky, especially if we want to execute code between characters. The STM32 chip has a bit for everything, including “TDR empty, you can write another character now.”</p>
<p>This bit is in a register called the <em>interrupt and status register (ISR)</em> that has a number of bits in it indicating the status of the device. <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a> shows a diagram of this register from the STM32F030R8 reference manual (“RM0360 Reference manual/STM32F030x4/x6/x8/xC and STM32F070x6/xB”).</p>
<figure>
<img src="image_fi/501621c09/f09002.png" alt="f09002" class=""/>
<figcaption><p><a id="figure9-2">Figure 9-2</a>: Interrupt and status register contents</p></figcaption>
</figure>
<p>We are interested in the bit named TXE (bit 0 in the diagram). The HAL defines the TXE bit using the name <code>UART_FLAG_TXE</code>. We must wait for the TXE bit to clear (become zero) before we can send data to the TDR without clobbering a character being transmitted. Nothing in the code changes <code>uartHandle.Instance-&gt;ISR</code>.</p>
<p>However, <code>uartHandle.Instance-&gt;ISR</code> is a magic memory location electrically connected to the device. The state of the device changes when something like a character transmission completes, and when that happens, the contents of <code>uartHandle.Instance-&gt;ISR</code> change as well.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="152" id="Page_152"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The <code>ISR</code> field is declared <code>volatile</code> to tell C that it can change magically at any time in ways that are not under the control of the compiler.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now if you try to examine <code>uartHandle.Instance-&gt;ISR</code> using the debugger, the <code>UART_FLAG_TXE</code> flag will appear always to be set. That’s because it’s cleared when a character is transmitted (in 1/960th of a second), which is a long time in terms of computers, but a very short time in terms of humans typing commands.</p>
<p>To help show what’s going on, we’ve added a useless statement:</p>
<pre><code>int result __attribute__((unused)) =
    (uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE);</code></pre>
<p>This statement tests the value of <code>UART_FLAG_TXE</code> and stores it in <code>result</code>. Now the value of <code>(uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE)</code> might magically change, but the value <code>result</code> will remain the same for the lifetime of the procedure.</p>
<p>You can look at <code>result</code> in the debugger and see what the value of the bit was at the beginning of the loop. You’ll notice a strange phrase in the code:</p>
<pre><code>__attribute__((unused))</code></pre>
<p>This is a GCC extension to the C language. It tells the compiler that we know this variable is not used, so it doesn’t generate a warning. (In fact, it’s not used by the program, but it may be used by the debugger. The compiler doesn’t see anything outside the program itself.)</p>
<p>The string we send for “Hello World” ends with <code>\r\n</code> (carriage return, line feed). In our original “Hello World” program from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, the operating system edited the output stream and changed <code>\n</code> into <code>\r\n</code> for us. We have no operating system, so we must do it all ourselves.</p>
<p><a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a> contains the full serial version of our “Hello World” program.</p>
<pre><code>/**
 * @brief Write hello world on the serial port.
 */
#include &lt;stdbool.h&gt;
#include "stm32f0xx_nucleo.h"
#include "stm32f0xx.h"

const char hello[] = "Hello World!\r\n";   // The message to send
int current; // The character in the message we are sending

UART_HandleTypeDef uartHandle;      // UART initialization

/**
  * @brief This function is executed in case of error occurrence.
  *
  * All it does is blink the LED.
  */
void Error_Handler(void)
{
<span epub:type="pagebreak" title="153" id="Page_153"/>    /* Turn LED2 on. */
    HAL_GPIO_WritePin(LED2_GPIO_PORT, LED2_PIN, GPIO_PIN_SET);

    while (true)
    {
        // Toggle the state of LED2.
        HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);
        HAL_Delay(1000);        // Wait one second.
    }
}
/**
 * Send character to the UART.
 *
 * @param ch The character to send
 */
void myPutchar(const char ch)
{
    // This line gets and saves the value of UART_FLAG_TXE at call
    // time. This value changes so if you stop the program on the "if"
    // line below, the value will be set to zero because it goes away
    // faster than you can look at it.
    int result __attribute__((unused)) =
        (uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE);

    // Block until the transmit empty (TXE) flag is set.
    while ((uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE) == 0)
        continue;

    uartHandle.Instance-&gt;TDR = ch;     // Send character to the UART.
}
  
/**
 * Initialize LED2 (so we can blink red for error).
 */
void led2_Init(void)
{
    // LED clock initialization
    LED2_GPIO_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_LedInit;      // Initialization for the LED
    // Initialize LED.
    GPIO_LedInit.Pin = LED2_PIN;
    GPIO_LedInit.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_LedInit.Pull = GPIO_PULLUP;
    GPIO_LedInit.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_LedInit);
}

/**
 * Initialize UART2 for output.
 */
void uart2_Init(void)
{
    // UART initialization
    // UART2 -- one connected to ST-LINK USB
<span epub:type="pagebreak" title="154" id="Page_154"/>    uartHandle.Instance = USART2;
    uartHandle.Init.BaudRate = 9600;                    // Speed 9600
    uartHandle.Init.WordLength = UART_WORDLENGTH_8B;    // 8 bits/character
    uartHandle.Init.StopBits = UART_STOPBITS_1;         // 1 stop bit
    uartHandle.Init.Parity = UART_PARITY_NONE;          // No parity
    uartHandle.Init.Mode = UART_MODE_TX_RX;             // Transmit &amp; receive
    uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;    // No hw control

    // Oversample the incoming stream.
    uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;

    // Do not use one-bit sampling.
    uartHandle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;

    // Nothing advanced
    uartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    /*
     * For those of you connecting a terminal emulator, the above parameters
     * translate to 9600,8,N,1.
     */

    if (HAL_UART_Init(&amp;uartHandle) != HAL_OK)
    {
        Error_Handler();
    }
}

int main(void)
{
    HAL_Init(); // Initialize hardware.
    led2_Init();
    uart2_Init();

    // Keep sending the message for a long time.
    for (;;) {
        // Send character by character.
        for(current = 0; hello[current] != '\0'; ++current) {
            myPutchar(hello[current]);
        }
        HAL_Delay(500);
    }
}

/**
 * Magic function that's called by the HAL layer to actually
 * initialize the UART. In this case we need to
 * put the UART pins in alternate mode so they act as
 * UART pins and not like GPIO pins.
 *
 * @note: Only works for UART2, the one connected to the USB serial
 * converter
 *
 * @param uart The UART information
<span epub:type="pagebreak" title="155" id="Page_155"/> */
void HAL_UART_MspInit(UART_HandleTypeDef* uart)
{
    GPIO_InitTypeDef GPIO_InitStruct;
    if(uart-&gt;Instance == USART2)
    {
        /* Peripheral clock enable */
        __HAL_RCC_USART2_CLK_ENABLE();

        /*
         * USART2 GPIO Configuration
         * PA2     ------&gt; USART2_TX
         * PA3     ------&gt; USART2_RX
         */
        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        // Alternate function -- that of UART
        GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
    }

}

/**
 * Magic function called by HAL layer to de-initialize the
 * UART hardware. It's something we never do, but we put it
 * in here for the sake of completeness.
 *
 * @note: Only works for UART2, the one connected to the USB serial
 * converter
 *
 * @param uart The UART information
 */
void HAL_UART_MspDeInit(UART_HandleTypeDef* uart)
{
    if(uart-&gt;Instance == USART2)
    {
        /* Peripheral clock disable */
        __HAL_RCC_USART2_CLK_DISABLE();

        /*
         * USART2 GPIO Configuration
         * PA2     ------&gt; USART2_TX
         * PA3     ------&gt; USART2_RX
         */
        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);
    }
}</code></pre>
<p class="CodeListingCaption"><em><a id="listing9-3">Listing 9-3</a>: Program</em> 08.serial</p>
<h2 id="h1-501621c09-0003"><span epub:type="pagebreak" title="156" id="Page_156"/>Communicating with the Device</h2>
<p class="BodyFirst">We now have a program that sends out the “Hello World” message on the serial line. The serial line is connected to the USB/serial device on the board, which is plugged in to your computer. To view the message, you need to run a terminal emulator on your computer. <a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a> shows the setup.</p>
<figure>
<img src="image_fi/501621c09/f09003.png" alt="f09003" class=""/>
<figcaption><p><a id="figure9-3">Figure 9-3</a>: Serial communications</p></figcaption>
</figure>
<p>Each operating system has a different terminal emulator program, and in some cases, more than one. The ones mentioned here are common, free, and easy to use.</p>
<h3 id="h2-501621c09-0006">Windows</h3>
<p class="BodyFirst">On Windows, we’ll use the PuTTY program (<a href="https://putty.org" class="LinkURL">https://putty.org</a>). Download and install it on your system, selecting the defaults for all options, and then follow these steps:</p>
<ol class="decimal">
<li value="1">Make sure the Nucleo board is <em>not</em> connected to your computer. Open the Control Panel and go to the Device Manager screen (see <a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a>). There is no serial device and, therefore, no Ports section in the list.<figure>
<img src="image_fi/501621c09/f09004.png" alt="f09004" class=""/>
<figcaption><p><a id="figure9-4">Figure 9-4</a>: Serial device not installed</p></figcaption>
</figure>
</li>
<li value="2"><span epub:type="pagebreak" title="157" id="Page_157"/>Plug in the Nucleo board. The device list will change as shown in <a href="#figure9-5" id="figureanchor9-5">Figure 9-5</a>.<figure>
<img src="image_fi/501621c09/f09005.png" alt="f09005" class=""/>
<figcaption><p><a id="figure9-5">Figure 9-5</a>: New USB serial device</p></figcaption>
</figure>
<p class="ListBody">You should see a new USB serial device named COM3. (Windows has a system for assigning COM parts to serial devices, but no one knows what that is. You may see a different COM port on your machine.)</p>
</li>
<li value="3">Start PuTTY. In the main window, shown in <a href="#figure9-6" id="figureanchor9-6">Figure 9-6</a>, select the <b>Serial</b> radio button. Under <b>Serial Line</b>, select the new COM port you just found in the Device Manager. The speed should default to 9600.<figure>
<img src="image_fi/501621c09/f09006.png" alt="f09006" class=""/>
<figcaption><p><a id="figure9-6">Figure 9-6</a>: Starting PuTTY</p></figcaption>
</figure></li>
</ol>
<ol>
<li value="4">Click <b>Open</b>. A terminal window should appear, and the device should start greeting you.</li>
</ol>
<h3 id="h2-501621c09-0007"><span epub:type="pagebreak" title="158" id="Page_158"/>Linux and macOS</h3>
<p class="BodyFirst">On Unix-based systems like Linux and macOS, the <code>screen</code> program works well. (The <code>minicom</code> program also does the job.) To use <code>screen</code>, you need to know the serial device’s name, which is different on different operating systems. On Linux, the device is most likely <em>/dev/ttyACM0</em>, although if you have other serial devices plugged in, it might be <em>/dev/ttyACM1</em>, <em>/dev/ttyACM2</em>, or similar. On macOS, the name is likely <em>/dev/tty.usbmodem001</em>, but it could be <em>/dev/tty.usbmodem002</em>, <em>/dev/tty.usbmodem003</em>, or something similar.</p>
<p>To find the name, make sure the Nucleo board is <em>not</em> connected to your computer, then execute one of the following commands in the terminal:</p>
<pre><code>$ <b>ls /dev/ttyACM*</b>          (Linux)
$ <b>ls /dev/tty.usbmodem*</b>    (macOS)</code></pre>
<p>Plug in the device and execute the same command again. You should see one more device in the list. Use that one. Now execute the following command:</p>
<pre><code>$ <b>screen /dev/ttyACM0 9600</b></code></pre>
<p>You should see “Hello World” appear. To exit the program, press <span class="KeyCaps">CTRL</span>-A-\.</p>
<h2 id="h1-501621c09-0004">Summary</h2>
<p class="BodyFirst">This programming book covers “Hello World” in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>. Why? Because we had to do everything ourselves. Writing a simple program to send out our message, character by character, involved initializing the UART (a nontrivial process), telling the GPIO pin that it was now a serial pin, and using a hardware register (those mysterious memory locations that magically change depending on the state of the device) to see when the UART was ready to transmit a character.</p>
<p>We’ve made a tremendous leap forward. First, we’ve programmed a moderately complex device and in the process learned a lot about direct low-level I/O. Second, the serial port is the main diagnostic and maintenance device hidden in many embedded devices. Despite all the advances in computer technology in the last 60 years, the most commonly used debugging technique is still <code>printf</code> to the serial port. The serial port is a very simple robust device that’s cheap to make and easy to connect to, and now we know how to use it to debug our embedded systems.</p>
<h2 id="h1-501621c09-0005"><span epub:type="pagebreak" title="159" id="Page_159"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">For the student: After you get the program working, see what happens if you remove the <code>\r</code>. Then try it with the <code>\r</code> back in, but the <code>\n</code> removed.</li>
<li value="2">Moderately difficult mystery: Try changing the configuration so that you send 7 data bits and even parity (instead of 8 data bits, no parity). Do not change your terminal emulator’s configuration. Some of the characters will be changed. Examine the bit pattern of the characters and figure out which ones changed and why.</li>
<li value="3">Advanced: As written, our program has no flow control. You’re going to get a “Hello World” whether you like it or not. Change the initialization code to use soft flow control. This means when you type the XOFF character (<span class="KeyCaps">CTRL</span>-S), the output should stop. When you type XON (<span class="KeyCaps">CTRL</span>-Q), it should resume.</li>
<li value="4">Advanced: Write a function for the Nucleo board that reads a character. It will look much like the <code>myPutchar</code> function, only it will check a different bit and read the I/O port instead of writing to it. You’ll need to read the microcontroller’s documentation to see what the RDR bit does.</li>
</ol>
</section>
</body></html>