<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch13">
  <div id="header1301" class="chapter">
   <h1 class="cn">
    <span class="page" id="p280">
    </span>
    <span class="page" id="p281">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch13">
     13
    </a>
   </h1>
   <h1 class="ctfm">
    AVR and Character Liquid Crystal Displays
   </h1>
  </div>
  <div class="figure" id="ct13">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   In previous chapters you’ve used LEDs, numerical LED displays, and the larger MAX7219 to display numerical values. However, a common
   <i class="calibre5">
    liquid crystal display (LCD)
   </i>
   module can allow your AVR projects to show a more versatile range of output, including text, numerical data, and your own custom characters.
  </p>
  <p class="calibre8">
   In this chapter, you’ll use character LCD modules to display all three types of data. To do so, you’ll learn to convert integers into string variables and display floating-point numbers on the LCD. Along the way, you’ll build your own digital clock and a digital thermometer that can display the minimum and maximum temperature over time.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah1501">
    <span class="page" id="p282">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1501">
     Introducing LCDs
    </a>
   </h2>
   <p class="paft">
    Our LCD-based projects will use inexpensive LCDs that can display 2 rows of 16 characters. Any LCD with an HD44780- or KS0066-compatible interface and a 5 V backlight, such as the one in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13001">
     Figure 13-1
    </a>
    , should work with these projects.
   </p>
   <div class="figure" id="f13001">
    <p class="fig">
     <img alt="Photo of a 16×2-character LCD module" height="1034" src="images/nsp-boxall502581-f13001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-1:
      </span>
      A 16×2-character LCD module
     </p>
    </div>
   </div>
   <p class="calibre8">
    Some rare LCDs have a 4.5 V rather than a 5 V backlight. If this is true of your LCD, place a 1N4004 diode in series between the 5 V power supply and the LCD’s LED+ or A pin.
   </p>
   <p class="calibre8">
    LCDs like the one in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13001">
     Figure 13-1
    </a>
    usually come without any wiring or connectors. To use an LCD with a solderless breadboard, you’ll need to solder in some 0.1 inch / 2.54 mm pitch inline header pins (such as PMD Way part number 1242070A) like those shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13002">
     Figure 13-2
    </a>
    . These are usually supplied in 40-pin lengths; however, you can easily trim them down to the required 16-pin length.
   </p>
   <div class="figure" id="f13002">
    <p class="fig">
     <img alt="Photo of a stack of 40-pin inline header pins" height="898" src="images/nsp-boxall502581-f13002.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-2:
      </span>
      Inline header pins
     </p>
    </div>
   </div>
   <p class="calibre8">
    Once assembled, your LCD will fit easily into the solderless breadboard, as shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13003">
     Figure 13-3
    </a>
    . Note the labels on pins 1 through 16.
   </p>
   <div class="figure" id="f13003">
    <p class="fig">
     <span id="p283">
     </span>
     <img alt="Photo of an LCD in a solderless breadboard" height="587" src="images/nsp-boxall502581-f13003.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-3:
      </span>
      An LCD in a solderless breadboard
     </p>
    </div>
   </div>
   <p class="calibre8">
    The schematic symbol for our LCD is shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13004">
     Figure 13-4
    </a>
    .
   </p>
   <div class="figure" id="f13004">
    <p class="fig">
     <img alt="16×2-character LCD schematic symbol" height="532" src="images/nsp-boxall502581-f13004.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-4:
      </span>
      Schematic symbol for our 16×2-character LCD
     </p>
    </div>
   </div>
   <p class="calibre8">
    Pins DB0 through DB7 constitute the 8-bit data interface of the LCD, which communicates with our ATmega328P-PU microcontroller. If you need to save wiring, you can also use the LCD in a 4-bit mode, which only requires DB4 through B7. We’ll use this method in our projects.
   </p>
   <p class="calibre8">
    Finally, you’ll also need a small 10
    <span lang="en" xml:lang="en">
     kΩ
    </span>
    trimpot to control the contrast of the display. You can get breadboard-compatible trimpots that don’t require any extra soldering, like the one shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13005">
     Figure 13-5
    </a>
    .
   </p>
   <div class="figure" id="f13005">
    <p class="fig">
     <img alt="Photo of a breadboard-compatible trimpot" height="850" src="images/nsp-boxall502581-f13005.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-5:
      </span>
      An example of a breadboard trimpot
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p284">
    </span>
    The schematic symbol for the trimpot in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13005">
     Figure 13-5
    </a>
    is shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13006">
     Figure 13-6
    </a>
    .
   </p>
   <div class="figure" id="f13006">
    <p class="fig">
     <img alt="Breadboard trimpot schematic symbol" height="921" src="images/nsp-boxall502581-f13006.jpg" width="953" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-6:
      </span>
      Schematic symbol for our breadboard trimpot
     </p>
    </div>
   </div>
   <p class="calibre8">
    Once you’ve gotten your LCD ready to use with a solderless breadboard, it’s time to understand how to display various kinds of data. To use the LCD in your projects, you will need functions for the following tasks:
   </p>
   <ul class="calibre10">
    <li class="blf">
     • Converting instructions into suitable control signals in order to send commands to the LCD
    </li>
    <li class="bl">
     • Initializing the LCD for use
    </li>
    <li class="bl">
     • Clearing all data from the LCD
    </li>
    <li class="bl">
     • Moving the cursor to the required position on the LCD
    </li>
    <li class="bll">
     • Displaying text on the LCD
    </li>
   </ul>
   <p class="calibre8">
    As there are no functions to complete these tasks in our AVR toolchain, we’ll use the custom functions described in the following sections.
   </p>
   <p class="calibre8">
    You’ll notice that each of these functions sends values to the LCD to cause a given effect. For example, sending
    <code class="calibre23">
     0x01
    </code>
    to the LCD clears the screen. To determine which values we should use to accomplish certain tasks, we refer to the LCD’s instruction table, which is Table 6 in the HD44780’s data sheet (widely available and included with the book’s code download at
    <a class="url-i" href="https://nostarch.com/avr-workshop/">
     https://nostarch.com/avr-workshop/
    </a>
    ). This table shows the status of the RS and R/_W pins required for a particular command, along with the binary representation of the command.
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13007">
     Figure 13-7
    </a>
    shows the clear display command,
    <code class="calibre23">
     0x01
    </code>
    .
   </p>
   <div class="figure" id="f13007">
    <p class="fig">
     <img alt="The “clear display” row from Table 6 in the HD44780’s data sheet" height="245" src="images/nsp-boxall502581-f13007.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-7:
      </span>
      A numerical description of the LCD’s “clear screen” command
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p285">
    </span>
    As the figure shows, to clear the display we need to set the LCD pins RS and R/_W to low, then send
    <code class="calibre23">
     0b00000001
    </code>
    (or
    <code class="calibre23">
     0x01
    </code>
    ) to the LCD. We’ll do this with the
    <code class="calibre23">
     commandLCD()
    </code>
    function (introduced in the following section), which is then called from the
    <code class="calibre23">
     clearLCD()
    </code>
    function (described shortly in “Clear the LCD”).
   </p>
   <p class="calibre8">
    In the following sections, refer to the table in the HD44780’s data sheet to understand which values I use to construct the other LCD commands. Later, you can use the table to create commands to suit your own needs.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1501">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1501">
      Send Commands to the LCD
     </a>
    </h3>
    <p class="paft">
     All information sent to the LCD, be it setup commands or data to display, is sent in bytes. However, as we’re using the LCD in 4-bit mode to save on hardware connections, we’ll need to use the following function to split the bytes of data into nibbles (4 bits) and send them to the LCD in the correct order:
    </p>
    <pre>
     <p class="clf">
      void commandLCD(uint8_t _command)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ PORTD = (PORTD &amp; 0x0F)|(_command &amp; 0xF0);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ PORTD &amp;= ~(1&lt;&lt;PD0);
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ PORTD = (PORTD &amp; 0x0F)|(_command &lt;&lt; 4);
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     To understand what’s happening in this code, recall that a byte of data consists of 8 bits, or 2 nibbles: the higher nibble, which consists of bits 7 to 4, and the lower nibble, which consists of bits 3 to 0. For example:
    </p>
    <pre>
     <p class="clf">
      <code class="b">
       1111
      </code>
      0000    // Ones are the higher nibble
     </p>
     <p class="cll">
      0000
      <code class="b">
       1111
      </code>
      // Ones are the lower nibble
     </p>
    </pre>
    <p class="calibre8">
     The
     <code class="calibre23">
      commandLCD()
     </code>
     function first takes the upper nibble of the command byte
     <code class="calibre23">
      _command
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶ and uses bitwise arithmetic (see
     <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
      Chapter 2
     </a>
     ) to clear the GPIO pins back to low. It then ensures the GPIO pins are set to match the upper nibble, the first half of the command byte.
    </p>
    <p class="calibre8">
     Next, it sets the RS pin on the LCD to low
     <!--<ccust1>2</ccust1>-->
     ❷, which tells the LCD we need to send data to its instruction register, and quickly sets the LCD’s E pin on
     <!--<ccust1>3</ccust1>-->
     ❸ and off
     <!--<ccust1>4</ccust1>-->
     ❹, which tells the LCD more data is coming.
    </p>
    <p class="calibre8">
     The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble up into the higher nibble
     <!--<ccust1>5</ccust1>-->
     ❺, which will match the GPIO pins used for sending data to the LCD. Finally, it again sets the LCD’s E pin on
     <!--<ccust1>6</ccust1>-->
     ❻ and off
     <!--<ccust1>7</ccust1>-->
     ❼ to finalize the data transmission. We use the
     <code class="calibre23">
      _delay_us()
     </code>
     (delay in microseconds, not milliseconds) function to give the LCD time to process the changes.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1502">
     <span class="page" id="p286">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1502">
      Initialize the LCD for Use
     </a>
    </h3>
    <p class="paft">
     Like many other devices, the LCD needs to be initialized with various parameters before we first use it in our code. We’ll use the
     <code class="calibre23">
      initLCD()
     </code>
     function to do this:
    </p>
    <pre>
     <p class="clf">
      void initLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRD = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ commandLCD(0x02);
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ commandLCD(0x28);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ commandLCD(0x0C);
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ commandLCD(0x06);
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This function first sets the required GPIO pins to digital outputs
     <!--<ccust1>1</ccust1>-->
     ❶. After a short delay to give the LCD time to wake up, it then sends the command to set the cursor (the position at which data is first displayed) back to the top left of the screen
     <!--<ccust1>2</ccust1>-->
     ❷. The next command configures the LCD’s controller IC to use it as a 16×2-character unit with a 4-bit data interface and to select a default font with characters that consist of 5×8 pixels
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     The following command
     <!--<ccust1>4</ccust1>-->
     ❹ tells the LCD to not use a block cursor, to not blink the cursor, and to turn the display on. We then tell the LCD controller we need the cursor to move in incremental stages
     <!--<ccust1>5</ccust1>-->
     ❺ so that if we wish to display more than one character in turn, we don’t need to explicitly set the cursor position after each character. Finally, we clear the LCD of all characters
     <!--<ccust1>6</ccust1>-->
     ❻ and give it a little time to process the change.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1503">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1503">
      Clear the LCD
     </a>
    </h3>
    <p class="paft">
     The convenient
     <code class="calibre23">
      clearLCD()
     </code>
     function simply clears the LCD of all data:
    </p>
    <pre>
     <p class="clf">
      void clearLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ commandLCD(0x80);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     We send the command to clear the screen
     <!--<ccust1>1</ccust1>-->
     ❶, then the command to return the cursor to the top left of the LCD
     <!--<ccust1>2</ccust1>-->
     ❷.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1504">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1504">
      Set the Cursor
     </a>
    </h3>
    <p class="paft">
     The
     <code class="calibre23">
      cursorLCD()
     </code>
     function sets the cursor to a given location on the LCD, following which you can display data starting from that position:
    </p>
    <pre>
     <p class="clf">
      void cursorLCD(uint8_t column, uint8_t row)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p287">
      </span>
      if (row == 0 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ commandLCD((column &amp; 0x0F)|0x80);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (row == 1 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ commandLCD((column &amp; 0x0F)|0xC0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     With our LCD, we have 2 rows of 16 characters: rows 0 and 1, with 16 columns numbered 0 to 15. This function creates the required LCD command based on the position data received for a row 0 location
     <!--<ccust1>1</ccust1>-->
     ❶ and for a row 1 location
     <!--<ccust1>2</ccust1>-->
     ❷.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1505">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1505">
      Print to the LCD
     </a>
    </h3>
    <p class="paft">
     The
     <code class="calibre23">
      printLCD()
     </code>
     function is used to display data on the LCD, such as text or numbers:
    </p>
    <pre>
     <p class="clf">
      void printLCD(char *_string)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ for (i=0; _string[i]!=0; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ PORTD = (PORTD &amp; 0x0F)|(_string[i] &amp; 0xF0);
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ PORTD = (PORTD &amp; 0x0F)|(_string[i] &lt;&lt; 4);
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This function can accept text in quotes, like this:
    </p>
    <pre>
     <p class="clf">
      printLCD("AVR Workshop!");
     </p>
     <p class="cll">
      printLCD("3.141592654");
     </p>
    </pre>
    <p class="pcon">
     or an array of characters, like this:
    </p>
    <pre>
     <p class="clf">
      char resultsArray[9];
     </p>
     <p class="cll">
      printLCD(resultsArray);
     </p>
    </pre>
    <p class="calibre8">
     The function sends each character in turn from the array using its
     <code class="calibre23">
      for
     </code>
     loop
     <!--<ccust1>1</ccust1>-->
     ❶, representing characters as numerical values from a standard ASCII table (discussed in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     ). All LCD displays on the market should support the values 33 to 125, which includes the lower- and uppercase
     <span id="p288">
     </span>
     alphabet, numbers, and standard popular symbols and punctuation marks. We set the location of the first (or only) character to display using the
     <code class="calibre23">
      cursorLCD()
     </code>
     or
     <code class="calibre23">
      clearLCD()
     </code>
     functions.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      printLCD()
     </code>
     function is very similar to the
     <code class="calibre23">
      commandLCD()
     </code>
     function. It first takes the upper nibble of the character byte
     <code class="calibre23">
      _string[i]
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷ and uses bitwise arithmetic to clear the GPIO pins back to low. It then ensures the GPIO pins are set to match the upper nibble, the first half of the command byte.
    </p>
    <p class="calibre8">
     Next, it sets the RS pin on the LCD to high
     <!--<ccust1>3</ccust1>-->
     ❸, which tells the LCD we need to send data to its instruction register, and quickly sets the LCD’s E pin on
     <!--<ccust1>4</ccust1>-->
     ❹ and off
     <!--<ccust1>5</ccust1>-->
     ❺, which tells the LCD more data is coming.
    </p>
    <p class="calibre8">
     The function then uses bitwise arithmetic to shift the 4 bits of the lower nibble up into the higher nibble
     <!--<ccust1>6</ccust1>-->
     ❻, which will match the GPIO pins used for sending data to the LCD. Finally, it again sets the LCD’s E pin on
     <!--<ccust1>7</ccust1>-->
     ❼ and off
     <!--<ccust1>8</ccust1>-->
     ❽ to finalize the data transmission. We use the
     <code class="calibre23">
      _delay_us()
     </code>
     (delay in microseconds) function to give the LCD time to process the changes.
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     To use
     <code class="calibre23">
      printLCD()
     </code>
     to display the contents of an integer variable, first convert the variable to an array of characters with
     <code class="calibre23">
      itoa(
     </code>
     <code class="i3">
      a
     </code>
     <code class="calibre23">
      ,
     </code>
     <code class="i3">
      b
     </code>
     <code class="calibre23">
      ,
     </code>
     <code class="i3">
      c
     </code>
     <code class="calibre23">
      )
     </code>
     . This takes the integer
     <code class="i3">
      a
     </code>
     and places it in an array of characters
     <code class="i3">
      b
     </code>
     with a maximum length of
     <code class="i3">
      c
     </code>
     characters. You’ll need to include the
     <i class="calibre12">
      stdlib.h
     </i>
     library along with the other
     <code class="calibre23">
      include
     </code>
     statements in your code, as it contains the
     <code class="calibre23">
      itoa()
     </code>
     function.
    </p>
    <p class="calibre8">
     In the following projects, you’ll put the LCD to use.
    </p>
    <p class="hd" id="pro52">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro52">
      <span class="ccust1">
       Project 52: Using a Character LCD with Your AVR
      </span>
     </a>
    </p>
    <p class="paft">
     In this project you’ll consolidate the information presented so far about controlling the LCD by building your own LCD circuit and displaying various information. This will introduce you to using LCDs in your own projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1506">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1506">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • 16×2-character LCD with fitted inline header pins
     </li>
     <li class="bl">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      breadboard-compatible trimpot (variable resistor)
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     <span id="p289">
     </span>
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13008">
      Figure 13-8
     </a>
     .
    </p>
    <div class="figure" id="f13008">
     <p class="fig">
      <img alt="Schematic diagram for Project 52" height="870" src="images/nsp-boxall502581-f13008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-8:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro52">
        Project 52
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Once you’ve finished with this circuit, keep it assembled, as you’ll use it again for
     <a class="url" href="nsp-boxall502581-0023.xhtml#pro55">
      Project 55
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1507">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1507">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 52
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 13
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a few moments, the LCD should show the text in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13009">
      Figure 13-9
     </a>
     .
    </p>
    <div class="figure" id="f13009">
     <p class="fig">
      <img alt="Photo of the LCD displaying the initial message from Project 52" height="546" src="images/nsp-boxall502581-f13009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-9:
       </span>
       First example of text displayed using
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro52">
        Project 52
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     That text should soon be replaced with an incrementing digit, as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13010">
      Figure 13-10
     </a>
     .
    </p>
    <div class="figure" id="f13010">
     <p class="fig">
      <span id="p290">
      </span>
      <img alt="Photo of the LCD displaying “counting up:” and the numbers from 0 to 9" height="531" src="images/nsp-boxall502581-f13010.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-10:
       </span>
       Example of the counting display routine from
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro52">
        Project 52
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Let’s examine the code and review the functions that make this possible:
    </p>
    <pre>
     <p class="clf">
      // Project 52 - Using a Character LCD with Your AVR
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="clf">
      void initLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRD = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="clf">
      commandLCD(0x02);
     </p>
     <p class="cl">
      commandLCD(0x28);
     </p>
     <p class="cl">
      commandLCD(0x0C);
     </p>
     <p class="cl">
      commandLCD(0x06);
     </p>
     <p class="cl">
      commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void commandLCD(uint8_t _command)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &amp; 0xF0
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1)
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void clearLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD (0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      commandLCD (0x80);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void printLCD(char *_string)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p291">
      </span>
      uint8_t i;
     </p>
     <p class="cl">
      for(i=0; _string[i]!=0; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void cursorLCD(uint8_t column, uint8_t row)
     </p>
     <p class="cl">
      // Move cursor to desired column (0–15), row (0–1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (row == 0 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0x80);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (row == 1 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0xC0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ initLCD();
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ char numbers[9];
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ int i;
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ cursorLCD(1,0);
     </p>
     <p class="cl">
      printLCD("AVR Workshop!");
     </p>
     <p class="cl">
      cursorLCD(0,1);
     </p>
     <p class="cl">
      printLCD("Learning LCD use");
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ clearLCD();
     </p>
     <p class="cl">
      cursorLCD(1,0);
     </p>
     <p class="cl">
      printLCD("Counting up:");
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ for (i = 0; i&lt;10; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ itoa(i,numbers,10);
     </p>
     <p class="cl">
      cursorLCD(i,1);
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ printLCD(numbers);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      clearLCD();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p292">
     </span>
     This code puts the LCD functions described earlier to use. In the main section of the code, we first initialize the LCD
     <!--<ccust1>1</ccust1>-->
     ❶, then declare a character array for displaying numbers
     <!--<ccust1>2</ccust1>-->
     ❷ and the required variable for counting
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     Next, we set up the display operation. We position and display text using the
     <code class="calibre23">
      cursorLCD()
     </code>
     and
     <code class="calibre23">
      printLCD()
     </code>
     functions
     <!--<ccust1>4</ccust1>-->
     ❹, then clear the display with
     <code class="calibre23">
      clearLCD()
     </code>
     <!--<ccust1>5</ccust1>-->
     ❺. The
     <code class="calibre23">
      for
     </code>
     loop
     <!--<ccust1>6</ccust1>-->
     ❻ displays the numbers from zero to nine along the second row of the LCD (as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13010">
      Figure 13-10
     </a>
     ). We use
     <code class="calibre23">
      itoa()
     </code>
     <!--<ccust1>7</ccust1>-->
     ❼ to convert the integer variable
     <code class="calibre23">
      i
     </code>
     into a character array of numbers, then display that array using
     <code class="calibre23">
      printLCD()
     </code>
     <!--<ccust1>8</ccust1>-->
     ❽.
    </p>
    <p class="calibre8">
     Now that you know how to set up and use a character LCD, let’s put this skill to good use by creating a digital clock.
    </p>
    <p class="hd" id="pro53">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro53">
      <span class="ccust1">
       Project 53: Building an AVR-Based LCD Digital Clock
      </span>
     </a>
    </p>
    <p class="paft">
     In this project you’ll combine the DS3231 real-time clock module and an LCD to build your own digital clock.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1508">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1508">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • 16×2-character LCD with fitted inline header pins
     </li>
     <li class="bl">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      breadboard-compatible trimpot (variable resistor)
     </li>
     <li class="bl">
      • DS3231 RTC module with backup battery
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13011">
      Figure 13-11
     </a>
     . Don’t forget to connect the DS3231 board to 5 V and GND as well.
    </p>
    <div class="figure" id="f13011">
     <p class="fig">
      <span id="p293">
      </span>
      <img alt="Schematic diagram for Project 53" height="870" src="images/nsp-boxall502581-f13011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-11:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro53">
        Project 53
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1509">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1509">
      The Code
     </a>
    </h3>
    <p class="paft">
     As with
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
      Project 51
     </a>
     from
     <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
      Chapter 12
     </a>
     , you’ll first need to set the time and date in the DS3231 module. In your text editor, open the
     <i class="calibre5">
      main.c
     </i>
     file in the
     <i class="calibre5">
      Project 53
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 13
     </i>
     folder and remove the comment slashes in front of the function
     <code class="calibre23">
      setTimeDS3231()
     </code>
     . Update the parameters in that function to match your current date and time.
    </p>
    <p class="calibre8">
     Now save the file, then use the
     <code class="b">
      make flash
     </code>
     command as usual from the terminal window. Reopen the
     <i class="calibre5">
      main.c
     </i>
     file and place the comment slashes in front of the same function, save the file, and reflash the code. Once you’ve done so, you should see the current time and date displayed on your LCD module. An example of this is shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13012">
      Figure 13-12
     </a>
     . Congratulations—you’ve made your own LCD digital clock!
    </p>
    <div class="figure" id="f13012">
     <p class="fig">
      <img alt="Photo of the LCD clock from Project 53" height="566" src="images/nsp-boxall502581-f13012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-12:
       </span>
       Example operation of
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro53">
        Project 53
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p294">
     </span>
     Let’s examine the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 53 - Building an AVR-Based LCD Digital Clock
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="clf">
      // Variables to store time and date
     </p>
     <p class="cl">
      uint8_t hours, minutes, seconds, dow, dom, mo, years;
     </p>
     <p class="clf">
      void I2Cenable()
     </p>
     <p class="cl">
      // Enable I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWBR = 72;           // 100 kHz I2C bus
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwait()
     </p>
     <p class="cl">
      // Wait until I2C finishes an operation
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait until bit TWINT in TWCR is set to 1
     </p>
     <p class="cl">
      while (!(TWCR &amp; (1&lt;&lt;TWINT)));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2CstartWait(unsigned char address)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t status;
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Send START condition
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
     </p>
     <p class="clf">
      // Send device address
     </p>
     <p class="cl">
      TWDR = address;
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status == 0b00100000 )||(status == 0b01011000))
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
     </p>
     <p class="clf">
      // Wait until stop condition is executed and I2C bus released
     </p>
     <p class="cl">
      while(TWCR &amp; (1&lt;&lt;TWSTO));
     </p>
     <p class="cl">
      <span id="p295">
      </span>
      continue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cstop()
     </p>
     <p class="cl">
      // Stop I2C bus and release GPIO pins
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Clear interrupt, enable I2C, generate stop condition
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwrite(uint8_t data)
     </p>
     <p class="cl">
      // Send ′data′ to I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWDR = data;
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2Cread()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2CreadACK()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus and ACK signal
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWEA);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t decimalToBcd(uint8_t val)
     </p>
     <p class="cl">
      // Convert integer to BCD
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/10*16)+(val%10));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t bcdToDec(uint8_t val)
     </p>
     <p class="cl">
      // Convert BCD to integer
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/16*10)+(val%16));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw, uint8_t dd,
     </p>
     <p class="cl">
      uint8_t mo, uint8_t yy)
     </p>
     <p class="cl">
      // Set the time on DS3231
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p296">
      </span>
      I2CstartWait(0xD0);            // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);                // Start with hours register
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(ss));    // Seconds
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(mm));    // Minutes
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(hh));    // Hours
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dw));    // Day of week
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dd));    // Date
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(mo));    // Month
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(yy));    // Year
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void readTimeDS3231()
     </p>
     <p class="cl">
      // Retrieve time and date from DS3231
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      I2CstartWait(0xD0);            // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);                // Seconds register
     </p>
     <p class="cl">
      I2CstartWait(0xD1);            // DS3231 read
     </p>
     <p class="cl">
      seconds = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      minutes = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      hours = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dow = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dom = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      mo = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      years = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void commandLCD(uint8_t _command)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Takes command byte and sends upper nibble, lower nibble to LCD
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRD = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      commandLCD(0x02);
     </p>
     <p class="cl">
      commandLCD(0x28);
     </p>
     <p class="cl">
      commandLCD(0x0C);
     </p>
     <p class="cl">
      commandLCD(0x06);
     </p>
     <p class="cl">
      commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p297">
      </span>
      void clearLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD (0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      commandLCD (0x80);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void printLCD(char *_string)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for(i=0; _string[i]!=0; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void cursorLCD(uint8_t column, uint8_t row)
     </p>
     <p class="cl">
      // Move cursor to desired column (0–15), row (0–1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (row == 0 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0x80);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (row == 1 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0xC0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      initLCD();
     </p>
     <p class="cl">
      I2Cenable();
     </p>
     <p class="cl">
      char numbers[9];
     </p>
     <p class="cl">
      // Uncomment to set time and date, then comment and reflash code
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ // setTimeDS3231(8,50,0,3,16,6,21); // h, m, s, dow, dom, m, y
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ readTimeDS3231();
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ itoa(hours,numbers,10);          // Hours
     </p>
     <p class="cl">
      cursorLCD(4,0);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ if (hours==0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p298">
      </span>
      printLCD("00");
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ } else if (hours&gt;0 &amp;&amp; hours &lt;10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("0");
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      } else if (hours&gt;=10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      cursorLCD(6,0);
     </p>
     <p class="cl">
      printLCD(":");
     </p>
     <p class="clf">
      itoa(minutes,numbers,10);        // Minutes
     </p>
     <p class="cl">
      cursorLCD(7,0);
     </p>
     <p class="cl">
      if (minutes==0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("00");
     </p>
     <p class="cl">
      } else if (minutes&gt;0 &amp;&amp; minutes &lt;10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("0");
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      } else if (minutes&gt;=10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      cursorLCD(0,9);
     </p>
     <p class="cl">
      printLCD(":");
     </p>
     <p class="cl">
      itoa(seconds,numbers,10);        // Seconds
     </p>
     <p class="cl">
      cursorLCD(10,0);
     </p>
     <p class="cl">
      if (seconds==0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("00");
     </p>
     <p class="cl">
      } else if (seconds&gt;0 &amp;&amp; seconds &lt;10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("0");
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      } else if (seconds&gt;=10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      cursorLCD(2,1);                  // Day of week
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ switch(dow)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 1 : printLCD("Mon"); break;
     </p>
     <p class="cl">
      case 2 : printLCD("Tue"); break;
     </p>
     <p class="cl">
      case 3 : printLCD("Wed"); break;
     </p>
     <p class="cl">
      case 4 : printLCD("Thu"); break;
     </p>
     <p class="cl">
      case 5 : printLCD("Fri"); break;
     </p>
     <p class="cl">
      case 6 : printLCD("Sat"); break;
     </p>
     <p class="cl">
      case 7 : printLCD("Sun"); break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      itoa(dom,numbers,10);            // Day of month
     </p>
     <p class="cl">
      <span id="p299">
      </span>
      cursorLCD(6,1);
     </p>
     <p class="cl">
      if (dom&lt;10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("0");
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="clf">
      cursorLCD(8,1);
     </p>
     <p class="cl">
      printLCD("/");
     </p>
     <p class="clf">
      itoa(mo,numbers,10);             // Month
     </p>
     <p class="cl">
      cursorLCD(9,1);
     </p>
     <p class="cl">
      if (mo&lt;10)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      printLCD("0");
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="clf">
      cursorLCD(11,1);
     </p>
     <p class="cl">
      printLCD("/");
     </p>
     <p class="clf">
      itoa(years,numbers,10);          // Year
     </p>
     <p class="cl">
      cursorLCD(12,1);
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="clf">
      <!--<ccust1>7</ccust1>-->
      ❼ _delay_ms(900);
     </p>
     <p class="cl">
      clearLCD();                      // Refresh LCD
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The first section of the code includes all the I
     <sup class="calibre6">
      2
     </sup>
     C functions required to read and write data with our DS3231 RTC module as described in
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
      Project 51
     </a>
     in
     <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
      Chapter 12
     </a>
     , using the same method of working with the time and date information we employed with the MAX7219 display module. It also includes each LCD function explained previously in this chapter. Then we need to ensure the time and date are set using the
     <code class="calibre23">
      setTimeDS3231()
     </code>
     function
     <!--<ccust1>1</ccust1>-->
     ❶, and retrieve that information and display it in a nice format on the LCD.
    </p>
    <p class="calibre8">
     The code displays time in 24-hour format, using two digits to represent each of the hour, minute, and second parts. It first retrieves the data from the DS3231
     <!--<ccust1>2</ccust1>-->
     ❷ in the same way as
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
      Project 51
     </a>
     in
     <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
      Chapter 12
     </a>
     . then converts the hour, minute and second information using
     <code class="calibre23">
      itoa()
     </code>
     <!--<ccust1>3</ccust1>-->
     ❸ and displays each part at the correct place on the LCD with
     <code class="calibre23">
      cursorLCD()
     </code>
     .
    </p>
    <p class="calibre8">
     To maintain correct spacing and display of information, we must ensure the LCD displays single-digit values with a zero preceding them (representing the sixth day of the month as 06, for example). To do so, the code checks if the value from the time clock is zero
     <!--<ccust1>4</ccust1>-->
     ❹ or between one and nine
     <!--<ccust1>5</ccust1>-->
     ❺, then writes the required zeros before any single-digit time data. It does this for the hours, minutes, seconds, day of month, and month values.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      switch...case
     </code>
     statement
     <!--<ccust1>6</ccust1>-->
     ❻ then takes the day of week data—a value from 1 to 7 corresponding to Sunday through Saturday or Monday through
     <span id="p300">
     </span>
     Sunday, depending on your region and preference—and displays the day in abbreviated form. After all the information has been displayed, the clock waits for 900 ms
     <!--<ccust1>7</ccust1>-->
     ❼ before clearing the display, then starting over.
    </p>
    <p class="calibre8">
     For a challenge, you might convert this project into a 12-hour clock with an AM/PM display, or perhaps add an alarm that sounds a piezo buzzer at a certain time every day.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1502">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1502">
     Displaying Floating-Point Numbers on the LCD
    </a>
   </h2>
   <p class="paft">
    Our
    <a class="url" href="nsp-boxall502581-0023.xhtml#pro54">
     next project
    </a>
    requires us to display a floating-point number on the LCD. As with integers, floating-point numbers first need to be converted from floats to character arrays. To do this we use the
    <code class="calibre23">
     dtostrf()
    </code>
    function, as described in
    <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
     Chapter 4
    </a>
    , then display the character array as usual with the
    <code class="calibre23">
     printLCD()
    </code>
    function. Always ensure you declare your character array with enough space to cover the entire number and fraction.
   </p>
   <p class="calibre8">
    For example, to display the numbers 1.2345678 and 12345.678, replace the
    <code class="calibre23">
     int main()
    </code>
    loop from
    <a class="url" href="nsp-boxall502581-0023.xhtml#pro54">
     Project 54
    </a>
    with the following code:
   </p>
   <pre>
    <p class="clf">
     int main()
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>1</ccust1>-->
     ❶ float a = 1.2345678;
    </p>
    <p class="cl">
     float b = 12345.678;
    </p>
    <p class="cl">
     <!--<ccust1>2</ccust1>-->
     ❷ char displayNumber[10];
    </p>
    <p class="cl">
     <!--<ccust1>3</ccust1>-->
     ❸ initLCD();
    </p>
    <p class="cl">
     while(1)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>4</ccust1>-->
     ❹ cursorLCD(0,0);
    </p>
    <p class="cl">
     <!--<ccust1>5</ccust1>-->
     ❺ dtostrf(a,9,7, displayNumber);
    </p>
    <p class="cl">
     printLCD(displayNumber);
    </p>
    <p class="cl">
     cursorLCD(0,1);
    </p>
    <p class="cl">
     <!--<ccust1>6</ccust1>-->
     ❻ dtostrf(b,9,3, displayNumber);
    </p>
    <p class="cl">
     printLCD(displayNumber);
    </p>
    <p class="cl">
     _delay_ms(1000);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cll">
     }
    </p>
   </pre>
   <p class="calibre8">
    We declare variables holding two sample numbers to display on the LCD for the purposes of demonstration
    <!--<ccust1>1</ccust1>-->
    ❶, and the character array used in the display process
    <!--<ccust1>2</ccust1>-->
    ❷. We then initialize the LCD as usual
    <!--<ccust1>3</ccust1>-->
    ❸ and move the cursor to the top left of the display
    <!--<ccust1>4</ccust1>-->
    ❹.
   </p>
   <p class="calibre8">
    The code then converts the number 1.2345678 to a string displayed using 10 characters, with 7 of them after the decimal point
    <!--<ccust1>5</ccust1>-->
    ❺. Finally, it displays the number 12345.678 using 9 characters, this time with 3 of them after the decimal point
    <!--<ccust1>6</ccust1>-->
    ❻.
   </p>
   <p class="calibre8">
    Flash the code and you should see a display like the one in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13013">
     Figure 13-13
    </a>
    .
   </p>
   <div class="figure" id="f13013">
    <p class="fig">
     <span id="p301">
     </span>
     <img alt="Photo of the LCD displaying floating-point numbers" height="526" src="images/nsp-boxall502581-f13013.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-13:
      </span>
      Floating-point numbers on the LCD
     </p>
    </div>
   </div>
   <p class="calibre8">
    This example displayed two positive numbers. If you’d like to display negative numbers, remember to allow one character space for the negative sign in front of the first digit. For example, to display −123.45, you would need to allocate seven character spaces.
   </p>
   <p class="calibre8">
    You’ll put this new skill to work in the
    <a class="url" href="nsp-boxall502581-0023.xhtml#pro54">
     next project
    </a>
    .
   </p>
   <p class="hd" id="pro54">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro54">
     <span class="ccust1">
      Project 54: LCD Digital Thermometer with Min/Max Display
     </span>
    </a>
   </p>
   <p class="paft">
    With this project you’ll make a digital thermometer that can display the minimum and maximum temperature over time along with the current and average temperature over time. This project is another example of how to incorporate functions from previous chapters into new and more complicated projects.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1510">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1510">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • 16×2-character LCD with fitted inline header pins
     </li>
     <li class="bl">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      breadboard-compatible trimpot (variable resistor)
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor (C4)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13014">
      Figure 13-14
     </a>
     . Don’t forget to connect the microcontroller’s AV
     <sub class="calibre28">
      CC
     </sub>
     pin to 5 V!
    </p>
    <div class="figure" id="f13014">
     <p class="fig">
      <span id="p302">
      </span>
      <img alt="Schematic diagram for Project 54" height="807" src="images/nsp-boxall502581-f13014.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-14:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro54">
        Project 54
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1511">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1511">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 54
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 13
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a moment or two, the LCD should alternate between showing the minimum and maximum temperatures, as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13015">
      Figure 13-15
     </a>
     , and the current and average temperatures, as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13016">
      Figure 13-16
     </a>
     . The temperature readings are in degrees Celsius and cover the period since the project was last reset or turned on.
    </p>
    <div class="figure" id="f13015">
     <p class="fig">
      <img alt="Photo of the LCD displaying minimum and maximum temperatures" height="519" src="images/nsp-boxall502581-f13015.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-15:
       </span>
       The LCD displaying the minimum and maximum temperatures
      </p>
     </div>
    </div>
    <div class="figure" id="f13016">
     <p class="fig">
      <span id="p303">
      </span>
      <img alt="Photo of the LCD displaying current and average temperatures" height="505" src="images/nsp-boxall502581-f13016.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-16:
       </span>
       The LCD displaying the current and average temperatures
      </p>
     </div>
    </div>
    <p class="calibre8">
     Let’s take a look at the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 54 - LCD Digital Thermometer with Min/Max Display
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void startADC()
     </p>
     <p class="cl">
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);              // Use AVcc pin with ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0); // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      // Prescaler for 16MHz (/128)
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ ADCSRA |= (1 &lt;&lt; ADPS2) |(1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0);
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);              // Enable ADC
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void commandLCD(uint8_t _command)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRD = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      commandLCD(0x02);
     </p>
     <p class="cl">
      commandLCD(0x28);
     </p>
     <p class="cl">
      commandLCD(0x0C);
     </p>
     <p class="cl">
      <span id="p304">
      </span>
      commandLCD(0x06);
     </p>
     <p class="cl">
      commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void clearLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD (0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      commandLCD (0x80);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void printLCD(char *_string)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for(i=0; _string[i]!=0; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void cursorLCD(uint8_t column, uint8_t row)
     </p>
     <p class="cl">
      // Move cursor to desired column (0–15), row (0–1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (row == 0 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0x80);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (row == 1 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0xC0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRC = 0b00000000;                // Set PORTC as inputs
     </p>
     <p class="cl">
      startADC();
     </p>
     <p class="cl">
      initLCD();
     </p>
     <p class="cl">
      char numbers[9];
     </p>
     <p class="clf">
      float temperature;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      float average;
     </p>
     <p class="cl">
      <span id="p305">
      </span>
      <!--<ccust1>3</ccust1>-->
      ❸ float minimum = -273;             // Needs an initial value
     </p>
     <p class="cl">
      float maximum;
     </p>
     <p class="cl">
      uint16_t ADCvalue;
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ // Take reading from TMP36 via ADC
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait for conversion
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="clf">
      // Get value from ADC (which is 10-bit) register
     </p>
     <p class="cl">
      ADCvalue = ADC;
     </p>
     <p class="clf">
      // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      voltage = (ADCvalue * 5);
     </p>
     <p class="cl">
      voltage = voltage / 1024;
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ temperature = ((voltage - 0.5) * 100);
     </p>
     <p class="clf">
      // Min/max and average
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ if (temperature &lt; minimum)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      minimum = temperature;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      if (temperature &gt; maximum)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      maximum = temperature;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ average = ((minimum+maximum)/2);
     </p>
     <p class="clf">
      <!--<ccust1>8</ccust1>-->
      ❽ // Display information
     </p>
     <p class="cl">
      cursorLCD(0,0);
     </p>
     <p class="cl">
      printLCD("Current:");
     </p>
     <p class="cl">
      dtostrf(temperature,6,2,numbers);
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      cursorLCD(15,0);
     </p>
     <p class="cl">
      printLCD("C");
     </p>
     <p class="clf">
      cursorLCD(0,1);
     </p>
     <p class="cl">
      printLCD("Average:");
     </p>
     <p class="cl">
      dtostrf(average,6,2,numbers);
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      cursorLCD(15,1);
     </p>
     <p class="cl">
      printLCD("C");
     </p>
     <p class="clf">
      _delay_ms(1000);
     </p>
     <p class="cl">
      clearLCD();
     </p>
     <p class="clf">
      cursorLCD(0,0);
     </p>
     <p class="cl">
      printLCD("Minimum:");
     </p>
     <p class="cl">
      dtostrf(minimum,6,2,numbers);
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      cursorLCD(15,0);
     </p>
     <p class="cl">
      printLCD("C");
     </p>
     <p class="clf">
      <span id="p306">
      </span>
      cursorLCD(0,1);
     </p>
     <p class="cl">
      printLCD("Maximum:");
     </p>
     <p class="cl">
      dtostrf(maximum,6,2,numbers);
     </p>
     <p class="cl">
      printLCD(numbers);
     </p>
     <p class="cl">
      cursorLCD(15,1);
     </p>
     <p class="cl">
      printLCD("C");
     </p>
     <p class="clf">
      _delay_ms(1000);
     </p>
     <p class="cl">
      clearLCD();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The code for this project breaks down into two concepts: determining the temperature from the TMP36 sensor (as demonstrated in
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      Chapter 3
     </a>
     ), then displaying the temperature values using the LCD.
    </p>
    <p class="calibre8">
     We first use a series of functions and commands to activate the ADC on pin 28 and call it into action in the main code
     <!--<ccust1>1</ccust1>-->
     ❶. The
     <code class="calibre23">
      startADC()
     </code>
     function is slightly different from its equivalent in previous projects; since we’re now operating the microcontroller at 16 MHz rather than 1 MHz, we need a larger prescaler to operate the ADC. Therefore, we set the ADCSRA register to use a prescaler of 128
     <!--<ccust1>2</ccust1>-->
     ❷. We arrive at this value by dividing 16 MHz by 200 kHz (the ideal speed for the ADC), which results in 80; the closest prescaler value is 128, so we use that.
    </p>
    <p class="calibre8">
     The code reads the raw data from the ADC
     <!--<ccust1>4</ccust1>-->
     ❹ and converts it to degrees Celsius
     <!--<ccust1>5</ccust1>-->
     ❺. It then determines if the current temperature is a minimum or maximum
     <!--<ccust1>6</ccust1>-->
     ❻ and calculates the average temperature measured since the last reset
     <!--<ccust1>7</ccust1>-->
     ❼. Note that the variable
     <code class="calibre23">
      minimum
     </code>
     is declared with a value of −273 degrees
     <!--<ccust1>3</ccust1>-->
     ❸. If we leave it without an initial value, it will default to 0 and we won’t get a true minimum temperature value (unless the sensor is outside and the temperature never goes below freezing!). Finally, we display all this temperature data over two screens, using the LCD functions from earlier in this chapter
     <!--<ccust1>8</ccust1>-->
     ❽.
    </p>
    <p class="calibre8">
     You can of course change the temperature values displayed to Fahrenheit by multiplying them by 1.8 and adding 32. Or, if you feel like a challenge, why not modify this project by combining it with what you learned in
     <a class="url" href="nsp-boxall502581-0023.xhtml#pro53">
      Project 53
     </a>
     to build a clock that shows the current temperature?
    </p>
    <p class="calibre8">
     When you’ve finished experimenting, let’s move on to creating our final type of output: custom characters.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1503">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1503">
     Displaying Custom Characters on the LCD
    </a>
   </h2>
   <p class="paft">
    In addition to using the standard letters, numbers, and symbols available on most keyboards, you can define up to eight of your own characters in each project. As you know, each character in the LCD module is made up of eight rows of five pixels, as shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13017">
     Figure 13-17
    </a>
    .
   </p>
   <div class="figure" id="f13017">
    <p class="fig">
     <span id="p307">
     </span>
     <img alt="Photo of an LCD with contrast adjusted to maximum in order to display individual character pixels" height="480" src="images/nsp-boxall502581-f13017.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-17:
      </span>
      Each LCD character is made up of eight rows of five pixels.
     </p>
    </div>
   </div>
   <p class="calibre8">
    To display your own custom characters, you must first define each character using an array consisting of eight elements (one element per character line). The value of the element defines the state of the pixels in that line. For example, to create a simple “smiley face,” plan out the pixels on a grid as shown in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13018">
     Figure 13-18
    </a>
    .
   </p>
   <div class="figure" id="f13018">
    <p class="fig">
     <img alt="Diagram illustrating numerical composition of custom LCD characters" height="1049" src="images/nsp-boxall502581-f13018.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 13-18:
      </span>
      Elements of a custom smiley face character
     </p>
    </div>
   </div>
   <p class="calibre8">
    Convert each horizontal line into a value by converting it from a binary number matching the pixels’ on or off state to a decimal number. Then create an array to define your custom character by entering in the eight decimal values, as shown below for the elements in
    <a class="url" href="nsp-boxall502581-0023.xhtml#f13018">
     Figure 13-18
    </a>
    :
   </p>
   <pre>
    <p class="cls">
     uint8_t smiley[] = {27,27,0,4,0,17,10,4};
    </p>
   </pre>
   <p class="calibre8">
    The code for this chapter includes a spreadsheet that simplifies this array creation process.
   </p>
   <p class="calibre8">
    Once you’ve created the array, you need to program it into the LCD’s
    <i class="calibre5">
     character generator RAM (CGRAM)
    </i>
    . This is a type of RAM used in the LCD’s controller chip that stores the design of the characters to display. There
    <span id="p308">
    </span>
    are eight possible positions in our LCD’s CGRAM. To write this character data and use the custom characters, we’ll use the three custom functions defined in the following sections.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1512">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1512">
      Write Data to CGRAM
     </a>
    </h3>
    <p class="paft">
     The
     <code class="calibre23">
      writeLCD()
     </code>
     function writes an individual line of data to the LCD’s CGRAM:
    </p>
    <pre>
     <p class="cl3f">
      void writeLCD(uint8_t _data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0); // RS high
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_data &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_data);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl3l">
      }
     </p>
    </pre>
    <p class="calibre8">
     This function operates in the same way as our
     <code class="calibre23">
      commandLCD()
     </code>
     function, except that
     <code class="calibre23">
      writeLCD()
     </code>
     sets the RS pin on the LCD high instead of low, which tells the LCD that the incoming data is for the CGRAM and not a regular command. It’s used in conjunction with the following two functions.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1513">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1513">
      Send Custom Character Data to LCD
     </a>
    </h3>
    <p class="paft">
     The
     <code class="calibre23">
      createCC()
     </code>
     function directs the custom character data array (
     <code class="calibre23">
      ccdata[]
     </code>
     ) into the specified CGRAM memory position (
     <code class="calibre23">
      slot
     </code>
     ), from 0 to 7:
    </p>
    <pre>
     <p class="cl3f">
      void createCC(uint8_t ccdata[], uint8_t slot)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t x;
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ commandLCD(0x40+(slot*8)); // Select character memory (0-7)
     </p>
     <p class="cl">
      for (x = 0; x&lt;8; x++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ writeLCD(ccdata[x]&lt;&lt;4);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl3l">
      }
     </p>
    </pre>
    <p class="calibre8">
     We command the LCD to prepare for character data and to store it in the character position in the variable
     <code class="calibre23">
      slot
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶, then send each element of the character array in turn to the LCD’s CGRAM with the
     <code class="calibre23">
      writeLCD()
     </code>
     function
     <!--<ccust1>2</ccust1>-->
     ❷.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1514">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1514">
      Display Custom Characters on LCD
     </a>
    </h3>
    <p class="paft">
     The
     <code class="calibre23">
      printCCLCD()
     </code>
     function displays one of the LCD’s eight custom characters, storing it in position
     <code class="calibre23">
      slot
     </code>
     :
    </p>
    <pre>
     <p class="cl3f">
      <span id="p309">
      </span>
      void printCCLCD(uint8_t slot)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (slot &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (slot &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl3l">
      }
     </p>
    </pre>
    <p class="calibre8">
     This function operates similarly to
     <code class="calibre23">
      printLCD()
     </code>
     , but it doesn’t need the string decoding and goes straight to showing the character in CGRAM location 0 through 7 (
     <code class="calibre23">
      slot
     </code>
     ) at the current cursor position.
    </p>
    <p class="calibre8">
     The
     <a class="url" href="nsp-boxall502581-0023.xhtml#pro55">
      next project
     </a>
     demonstrates how to use these functions to display custom characters.
    </p>
    <p class="hd" id="pro55">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro55">
      <span class="ccust1">
       Project 55: Displaying Custom LCD Characters
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll reuse the hardware from
     <a class="url" href="nsp-boxall502581-0023.xhtml#pro52">
      Project 52
     </a>
     to practice creating and displaying custom characters on an LCD. Open a terminal window, navigate to the
     <i class="calibre5">
      Project 55
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 13
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a moment or two, the LCD should display eight custom characters, as shown in
     <a class="url" href="nsp-boxall502581-0023.xhtml#f13019">
      Figure 13-19
     </a>
     .
    </p>
    <div class="figure" id="f13019">
     <p class="fig">
      <img alt="Photo of the LCD displaying custom characters from Project 55" height="546" src="images/nsp-boxall502581-f13019.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 13-19:
       </span>
       The results of
       <a class="url" href="nsp-boxall502581-0023.xhtml#pro55">
        Project 55
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Let’s look at the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 55 - Displaying Custom LCD Characters
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      uint8_t ch0[] = {14,10,14,10,0,31,21,21};  // "AM"
     </p>
     <p class="cl">
      uint8_t ch1[] = {14,10,14,8,0,31,21,21};   // "PM"
     </p>
     <p class="cl">
      uint8_t ch2[] = {4,31,17,17,17,31,31,31};  // "Battery"
     </p>
     <p class="cl">
      uint8_t ch3[] = {10,21,17,10,4,0,0,0};     // "Heart"
     </p>
     <p class="cl">
      uint8_t ch4[] = {4,4,31,4,4,0,31,0};       // "+ -"
     </p>
     <p class="cl">
      <span id="p310">
      </span>
      uint8_t ch5[] = {27,27,0,4,0,17,10,4};     // "Happy face"
     </p>
     <p class="cl">
      uint8_t ch6[] = {17,10,17,4,4,0,14,17};    // "Sad face"
     </p>
     <p class="cl">
      uint8_t ch7[] = {21,10,21,10,21,10,21,10}; // "Pattern"
     </p>
     <p class="clf">
      <!--<ccust1>1</ccust1>-->
      ❶ void writeLCD(uint8_t _data)
     </p>
     <p class="cl">
      // Used for writing to CGRAM
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0); // RS high
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_data &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_data);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void commandLCD(uint8_t _command)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD0);                     // RS low
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_command &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void createCC(uint8_t ccdata[], uint8_t slot)
     </p>
     <p class="cl">
      // Sends custom character data to LCD
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t x;
     </p>
     <p class="cl">
      commandLCD(0x40+(slot*8));              // Select character memory (0–7)
     </p>
     <p class="cl">
      for (x = 0; x&lt;8; x++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      writeLCD(ccdata[x]&lt;&lt;4);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void printCCLCD(uint8_t slot)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (slot &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (slot &lt;&lt; 4);
     </p>
     <p class="cl">
      <span id="p311">
      </span>
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRD = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      commandLCD(0x02);
     </p>
     <p class="cl">
      commandLCD(0x28);
     </p>
     <p class="cl">
      commandLCD(0x0C);
     </p>
     <p class="cl">
      commandLCD(0x06);
     </p>
     <p class="cl">
      commandLCD(0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void clearLCD()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD (0x01);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      commandLCD (0x80);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void printLCD(char *_string)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for(i=0; _string[i]!=0; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &amp; 0xF0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD0);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(200);
     </p>
     <p class="cl">
      PORTD = (PORTD &amp; 0x0F) | (_string[i] &lt;&lt; 4);
     </p>
     <p class="cl">
      PORTD |= (1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_us(1);
     </p>
     <p class="cl">
      PORTD &amp;= ~(1&lt;&lt;PD1);
     </p>
     <p class="cl">
      _delay_ms(2);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void cursorLCD(uint8_t column, uint8_t row)
     </p>
     <p class="cl">
      // Move cursor to desired column (0–15), row (0–1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (row == 0 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0x80);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      else if (row == 1 &amp;&amp; column&lt;16)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      commandLCD((column &amp; 0x0F)|0xC0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <span id="p312">
      </span>
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      initLCD();
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ createCC(ch0,0); // "AM"
     </p>
     <p class="cl">
      createCC(ch1,1); // "PM"
     </p>
     <p class="cl">
      createCC(ch2,2); // "Battery"
     </p>
     <p class="cl">
      createCC(ch3,3); // "Heart"
     </p>
     <p class="cl">
      createCC(ch4,4); // "+ -"
     </p>
     <p class="cl">
      createCC(ch5,5); // "Happy face"
     </p>
     <p class="cl">
      createCC(ch6,6); // "Sad face"
     </p>
     <p class="cl">
      createCC(ch7,7); // "Pattern"
     </p>
     <p class="clf">
      <!--<ccust1>6</ccust1>-->
      ❻ cursorLCD(0,0);
     </p>
     <p class="cl">
      printCCLCD(0);
     </p>
     <p class="cl">
      cursorLCD(2,0);
     </p>
     <p class="cl">
      printCCLCD(1);
     </p>
     <p class="cl">
      cursorLCD(4,0);
     </p>
     <p class="cl">
      printCCLCD(2);
     </p>
     <p class="cl">
      cursorLCD(6,0);
     </p>
     <p class="cl">
      printCCLCD(3);
     </p>
     <p class="cl">
      cursorLCD(8,0);
     </p>
     <p class="cl">
      printCCLCD(4);
     </p>
     <p class="cl">
      cursorLCD(10,0);
     </p>
     <p class="cl">
      printCCLCD(5);
     </p>
     <p class="cl">
      cursorLCD(12,0);
     </p>
     <p class="cl">
      printCCLCD(6);
     </p>
     <p class="cl">
      cursorLCD(14,0);
     </p>
     <p class="cl">
      printCCLCD(7);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      clearLCD();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This project demonstrates how easy it is to create custom characters when we use the three custom functions described previously to do the heavy lifting: respectively, they write the custom character data
     <!--<ccust1>1</ccust1>-->
     ❶, send commands to the LCD
     <!--<ccust1>2</ccust1>-->
     ❷, and send the custom character data to the LCD
     <!--<ccust1>3</ccust1>-->
     ❸. We simply insert the required data for the characters
     <!--<ccust1>4</ccust1>-->
     ❹, then feed that data to each location in the LCD’s CGRAM in turn with the
     <code class="calibre23">
      createCC()
     </code>
     function
     <!--<ccust1>5</ccust1>-->
     ❺. Finally, we position the cursor and display each custom character in turn with the
     <code class="calibre23">
      cursorLCD()
     </code>
     and
     <code class="calibre23">
      printCCLCD()
     </code>
     functions
     <!--<ccust1>6</ccust1>-->
     ❻.
    </p>
    <p class="calibre8">
     After working through this chapter you have the skills required to display all sorts of text and numerical data, as well as your own custom characters, on inexpensive and popular LCD modules. For a challenge, try creating your own AVR LCD library to make this code easier to include in your own future projects; every time you want to use the LCD, this library will save you development time and reduce complexity.
    </p>
    <p class="calibre8">
     In the
     <a class="url" href="nsp-boxall502581-0024.xhtml#ch14">
      next and final chapter
     </a>
     , you’ll add yet another tool to your growing AVR toolbox: the ability to control servos.
    </p>
   </div>
  </div>
 </div>
</div></body></html>