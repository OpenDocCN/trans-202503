- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: AUDIO SIGNALS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**音频信号**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, we continue exploring the relationship between continuous and
    discrete signals. The *Nyquist–Shannon sampling theorem* relates continuous signals
    and discrete signals. To properly discretize a continuous signal, we must sample
    it at a rate at least twice that of the highest frequency present in the signal.
    The theorem is why compact discs sample audio signals at 44.1 kHz, or 44,100 times
    per second. At that rate, any frequency up to 22,050 Hz will be captured. Note
    that 22 kHz is the theoretical upper limit on the highest frequency a human can
    hear, though most adults have a much lower upper limit; mine is about 13.5 kHz.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将继续探讨连续信号与离散信号之间的关系。*奈奎斯特-香农采样定理*描述了连续信号和离散信号之间的关系。为了正确地离散化一个连续信号，我们必须以至少是信号中最高频率两倍的采样率进行采样。正是这个定理使得光盘的音频信号采样率为44.1
    kHz，也就是每秒44,100次采样。在这个采样率下，任何最高频率为22,050 Hz的信号都会被捕捉到。需要注意的是，22 kHz是人耳能够听到的最高频率的理论上限，尽管大多数成人的上限要低得多；我自己的上限大约是13.5
    kHz。
- en: This chapter explores *compressed sensing* (or compressive sensing), a technique
    for beating Nyquist and Shannon at their own game. With compressed sensing, it
    becomes possible to acquire less data when digitizing a signal than the Nyquist-Shannon
    theorem says is required. This is an exciting real-world inverse problem involving
    randomness.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨*压缩感知*（或称为压缩感知技术），这是一种在奈奎斯特和香农的框架下进行逆袭的技术。通过压缩感知，我们可以在对信号进行数字化时采集比奈奎斯特-香农定理所要求的更少的数据。这是一个令人兴奋的现实世界反问题，涉及到随机性。
- en: We’ll begin by walking through the main points of compressed sensing; we’ll
    cover some of the math, but I encourage you to explore the rest on your own. Then
    we’ll explore compressed sensing in one dimension, audio, to see how it lets us
    break the Nyquist limit. Finally, as unraveled images are, to compressed sensing,
    no different from signals in time, we’ll apply compressed sensing to reconstruct
    images from what seems like too little data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从压缩感知的主要观点开始讲解；我们会涉及一些数学内容，但我鼓励你自行探索其余部分。接下来，我们将探讨一维的压缩感知，特别是音频信号，看看它如何让我们突破奈奎斯特极限。最后，由于解压后的图像对压缩感知而言与时间信号没有什么区别，我们将应用压缩感知技术，从看似过少的数据中重构图像。
- en: There’s some matrix-vector math in the first section, but it doesn’t go much
    beyond what we encountered in [Chapter 7](ch07.xhtml) with iterated function systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含一些矩阵-向量的数学运算，但它不超过我们在[第7章](ch07.xhtml)遇到的迭代函数系统的内容。
- en: '**Compressed Sensing**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**压缩感知**'
- en: Digitizing a signal usually means reading the output of an analog-to-digital
    converter at a specified but constant time interval. The number of readings per
    second is the sampling rate, which the Nyquist-Shannon theorem is concerned with.
    If we acquire the samples according to the Nyquist-Shannon theorem, we can accurately
    reconstruct the signal from the samples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数字化信号通常意味着在一个指定且恒定的时间间隔内读取模拟到数字转换器的输出。每秒的读取次数就是采样率，这是奈奎斯特-香农定理所关注的内容。如果我们按照奈奎斯特-香农定理获取样本，我们就能从这些样本中准确重构信号。
- en: When we sample at a fixed time interval, we are *uniform sampling*. However,
    there are times when uniform sampling isn’t desired, possibly because it’s too
    expensive or there’s too much risk associated with it (for example, in X-ray tomography).
    In such situations, it would be nice to acquire less data but still reconstruct
    the entire signal. For example, if the signal we want is denoted as ***x***, we’ll
    measure some subset of the signal, ***y***, and from ***y*** reconstruct ***x***.
    Mathematically, we can cast this process as a matrix equation
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以固定时间间隔进行采样时，我们称之为*均匀采样*。然而，有时不希望进行均匀采样，可能是因为成本过高或存在过多的风险（例如，在X射线断层扫描中）。在这种情况下，如果能采集较少的数据但仍能重构整个信号，那就很有帮助。例如，如果我们想要的信号表示为***x***，我们将测量信号的某个子集***y***，然后从***y***重构***x***。从数学角度看，我们可以将这个过程表示为一个矩阵方程
- en: '![Image](../images/f0256-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0256-01.jpg)'
- en: where we know vector ***y*** because we measured it and matrix ***C*** because
    it dictates the parts of ***x*** we sampled. We want ***x***, the vector we would’ve
    measured following standard sampling theory. Keep [Equation 9.1](ch09.xhtml#ch09equ1)
    in the back of your mind for the time being.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道向量***y***因为我们已经测量过它，而矩阵***C***因为它决定了我们采样的***x***的部分。我们要找的是***x***，即按照标准采样理论我们应该测量的向量。暂时记住[方程
    9.1](ch09.xhtml#ch09equ1)。
- en: 'Let’s return to algebra class, which asks us to solve systems of equations,
    usually two equations and two unknowns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到代数课，通常要求我们解方程组，通常是两个方程和两个未知数：
- en: '![Image](../images/f0256-02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0256-02.jpg)'
- en: 'Here, *a* through *f* are constants. Because there are two equations and two
    unknowns, we can find *x* and *y* values that satisfy both, assuming one equation
    isn’t a multiple of the other. In matrix form, we write the system of equations
    as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a* 到 *f* 是常数。因为有两个方程和两个未知数，我们可以找到满足这两个方程的 *x* 和 *y* 值，前提是其中一个方程不是另一个方程的倍数。以矩阵形式，我们将方程组写成：
- en: '![Image](../images/f0256-03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0256-03.jpg)'
- en: The rules of matrix-vector multiplication tell us to multiply each row of the
    matrix, ***A***, by the corresponding elements of the vector, ***x***, then sum.
    This transforms the matrix equation into the system. Regardless of the number
    of elements in the vectors, this rule applies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法的规则告诉我们，要将矩阵 ***A*** 的每一行与向量 ***x*** 对应的元素相乘，然后求和。这将矩阵方程转化为方程组。无论向量中有多少个元素，这个规则都适用。
- en: The system of equations works because there are as many unknowns as there are
    equations, meaning the number of elements in the vectors, here ***b*** and ***x***,
    matches the number of rows in the matrix, ***A***. For such an equation, the solution
    (if there is one), or the ***x*** vector that makes the equation true, is ***A***^(–1)***b***
    = ***x*** for ***A***^(–1), the inverse matrix of ***A***. For example, this system
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程组能够工作的原因是未知数的数量与方程的数量相等，意味着向量中的元素数量，这里是 ***b*** 和 ***x***，与矩阵 ***A*** 的行数相匹配。对于这样的方程，解（如果存在的话），即使方程成立的
    ***x*** 向量，是 ***A***^(–1)***b*** = ***x***，其中 ***A***^(–1) 是 ***A*** 的逆矩阵。例如，这个系统
- en: '![Image](../images/f0257-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0257-01.jpg)'
- en: becomes
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '![Image](../images/f0257-02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0257-02.jpg)'
- en: with solution
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解为
- en: '![Image](../images/f0257-03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0257-03.jpg)'
- en: where the inverse of a matrix ***A*** is ***A***^(–1) such that ***AA***^(–1)
    = ***A***^(–1)***A*** = ***I***.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，矩阵 ***A*** 的逆矩阵是 ***A***^(–1)，使得 ***AA***^(–1) = ***A***^(–1)***A*** = ***I***。
- en: Here, ***I*** is the *identity matrix*—the matrix of all zeros with ones along
    the diagonal. In the world of matrices, ***I*** is akin to the number 1\. Use
    NumPy’s `linalg.inv` function to find ***A***^(–1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，***I*** 是 *单位矩阵*——所有元素为零、对角线上的元素为一的矩阵。在矩阵的世界里，***I*** 类似于数字 1。使用 NumPy 的
    `linalg.inv` 函数来求解 ***A***^(–1)。
- en: '***A*** is a *square matrix*, meaning it has as many rows as columns. If ***A***
    is square, and the number of rows matches the number of elements in ***b*** and
    ***x***, then we can use ***A***^(–1) to find ***x***.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '***A*** 是一个 *方阵*，意味着它的行数和列数相等。如果 ***A*** 是方阵，并且行数与 ***b*** 和 ***x*** 中的元素数量匹配，那么我们可以使用
    ***A***^(–1) 来求解 ***x***。'
- en: Now comes the fun part. Return to [Equation 9.1](ch09.xhtml#ch09equ1). By design,
    there are *fewer* elements in ***y***, the values we measure, than in ***x***,
    the full signal. If there are *N* elements in ***y*** and *M* elements in ***x***,
    then ***C*** is an *N*×*M* matrix with *N* rows and *M* columns. There are more
    unknowns in [Equation 9.1](ch09.xhtml#ch09equ1) than there are equations. Such
    a system is called *underdetermined*. Underdetermined systems have an infinite
    number of solutions; there are an infinite number of vectors, ***x***, that, when
    multiplied by ***C***, give ***y***.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。回到 [方程 9.1](ch09.xhtml#ch09equ1)。根据设计，***y***（我们测量的值）的元素比 ***x***（完整信号）的元素要
    *少*。如果 ***y*** 中有 *N* 个元素，***x*** 中有 *M* 个元素，那么 ***C*** 是一个 *N*×*M* 的矩阵，具有 *N*
    行和 *M* 列。方程 [方程 9.1](ch09.xhtml#ch09equ1) 中的未知数比方程的数量要多。这样的系统称为 *欠定*。欠定系统有无限多个解；有无限多个向量
    ***x***，当它们与 ***C*** 相乘时，得到 ***y***。
- en: We want to get ***x*** by measuring ***y***, but ***y*** alone doesn’t have
    enough information to tell us *which* of the infinite set of ***x*** vectors we
    want. Compressed sensing comes to the rescue—at least in some cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想通过测量 ***y*** 来得到 ***x***，但是仅凭 ***y*** 本身没有足够的信息来告诉我们 *哪个* 无限集合中的 ***x***
    向量是我们需要的。压缩感知可以提供帮助——至少在某些情况下。
- en: According to compressed sensing theory, if ***x*** is *sparse*, meaning most
    of its elements are essentially zero, then we can recover ***x*** from ***y***
    by solving the *inverse problem*, which searches for the ***x*** that minimizes
    some measure of the difference ***Ax*** – ***b*** while strongly encouraging ***x***
    to be sparse. As we’ll see, algorithms capable of this kind of optimization exist.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据压缩感知理论，如果***x***是*稀疏的*，也就是说其大部分元素基本为零，那么我们可以通过解决*逆问题*从***y***恢复出***x***，这个逆问题寻找一个***x***，使得***Ax***
    - ***b***之间的差异最小，同时强烈鼓励***x***保持稀疏性。正如我们将看到的，存在能够执行这种优化的算法。
- en: Great! We’re in business. We measure ***y*** containing some subset of the elements
    that would be in ***x***, and we get ***x*** from ***y*** by solving a minimization
    problem. But it isn’t that simple; the optimization trick only works if ***x***
    is sparse. Most signals are not sparse; an audio signal isn’t likely to be. Recall
    working with the waveforms in [Chapter 8](ch08.xhtml). Are we doomed? Not necessarily.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们开始进入正题。我们测量包含某些元素子集的***y***，这些元素本应出现在***x***中，我们通过解决一个最小化问题从***y***得到***x***。但事情并没有那么简单；这个优化技巧只有在***x***是稀疏时才有效。大多数信号并不是稀疏的；例如，音频信号通常不是。回想一下在[第8章](ch08.xhtml)中处理波形的情况。我们就此注定失败了吗？不一定。
- en: While an audio signal isn’t sparse, there are Fourier-like transformations that
    map from a signal changing in time to one changing in frequency, and it is often
    the case that the frequency domain signal *is* sparse. Therefore, if we can write
    ***x*** = **Ψ*****s*** for some transformation matrix **Ψ** (psi) and sparse vector
    ***s***, [Equation 9.1](ch09.xhtml#ch09equ1) becomes
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然音频信号并不稀疏，但存在类似傅里叶变换的方式，可以将时间变化的信号映射到频率变化的信号，通常情况下，频域信号*是*稀疏的。因此，如果我们可以将***x***写成***x***
    = **Ψ*****s***的形式，其中**Ψ**是某个变换矩阵（psi），而***s***是稀疏向量，那么[公式 9.1](ch09.xhtml#ch09equ1)就变成了：
- en: '![Image](../images/f0258-03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0258-03.jpg)'
- en: where **Θ** = ***C*****Ψ**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中**Θ** = ***C*****Ψ**。
- en: While ***x*** isn’t sparse and is therefore unrecoverable, ***s*** is, meaning
    the optimization trick might have a chance of working. The measurements in ***y***
    combined with the external knowledge that ***s*** is sparse will let us find ***s***.
    Once we have ***s***, we get ***x***.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管***x***不是稀疏的，因此无法恢复，但***s***是稀疏的，这意味着优化技巧或许有可能奏效。通过将***y***中的测量结果与外部知识结合起来，得知***s***是稀疏的，我们就能找到***s***。一旦得到***s***，就可以恢复出***x***。
- en: But, what are all these matrices floating around? The *measurement matrix*,
    ***C***, can mathematically be any matrix of values such that the values in ***C***
    satisfy some notion of *incoherence* in relation to the elements of **Ψ**. For
    us, the elements of ***C*** are binary, zero or one, and serve to select specific
    elements of ***x*** that are actually measured. This requirement supplies the
    necessary mathematical incoherence between ***C*** and **Ψ**. The most important
    point is that ***C*** is somehow *random*. In practice, we don’t explicitly define
    ***C***, but our measurement process uses it implicitly. The random bit is essential
    to the entire operation, however.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有这些浮动的矩阵是做什么的呢？*测量矩阵* ***C*** 在数学上可以是任何满足某种*不相干性*的矩阵，这种不相干性是指***C***中的元素与**Ψ**中的元素之间的关系。对于我们来说，***C***的元素是二值的，即零或一，作用是选择实际测量的***x***中特定的元素。这一要求提供了***C***和**Ψ**之间所需的数学不相干性。最重要的一点是，***C***在某种程度上是*随机的*。在实际操作中，我们并不会显式定义***C***，但我们的测量过程隐含地使用了它。随机性是整个操作的关键所在。
- en: The **Ψ** matrix is a transformation matrix that transforms the sparse vector,
    ***s***, into a new representation, ***x***, which we ultimately want to measure.
    For us, **Ψ** is a Fourier-like *discrete cosine transformation (DCT)*. Signals
    are often sparse in this domain, thereby making it very useful for compressed
    sensing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ψ**矩阵是一个变换矩阵，它将稀疏向量***s***转化为我们最终想要测量的新表示***x***。对于我们来说，**Ψ**是一个类似傅里叶变换的*离散余弦变换（DCT）*。信号在这个领域通常是稀疏的，因此在压缩感知中非常有用。'
- en: Finally, **Θ** represents the combination of the measurement process working
    on **Ψ**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**Θ**表示测量过程作用于**Ψ**的组合。
- en: 'We are now in a position to try solving ***y*** = **Θ*****s*** for some ***s***
    that both is sparse and leads to ***y***, the set of measurements we have. There
    are multiple algorithms available, but we’ll use the Lasso algorithm, courtesy
    of scikit-learn. Likewise, we need the DCT and its inverse, which SciPy dutifully
    supplies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来尝试求解***y*** = **Θ*****s***，寻找一个既稀疏又能产生我们已有的测量集***y***的***s***。有多种算法可以使用，但我们将采用scikit-learn提供的Lasso算法。同样，我们还需要DCT及其逆变换，SciPy提供了这些工具：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lasso minimizes the following
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Lasso最小化以下内容
- en: '![Image](../images/f0258-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0258-01.jpg)'
- en: where *n* is the number of samples, or the number of elements in ***y***.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*是样本数量，或者是***y***中的元素数量。
- en: 'The double vertical bar notation refers to a *norm*, which is a metric measuring
    distance of some kind. The first term uses the square of the *ℓ*² norm, while
    the second term multiplies the *ℓ*¹ norm by *α*. The *ℓ^p* norm of a vector, ***x***,
    is defined as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 双竖线符号表示*范数*，它是一种衡量距离的度量。第一个项使用*ℓ*²范数的平方，而第二个项将*ℓ*¹范数乘以*α*。向量***x***的*ℓ^p*范数定义为：
- en: '![Image](../images/f0258-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0258-02.jpg)'
- en: The *ℓ*² norm is the Euclidean distance. The *ℓ*¹ norm, sometimes called the
    Manhattan or taxicab distance, is the sum of the absolute values of the elements
    of ***x***. Lasso uses this term, scaled by *α*, to find an ***s*** vector that
    minimizes the Euclidean distance between the measurements, ***y***, and **Θ*****s***
    while simultaneously minimizing the sum of the absolute values of the elements
    of ***s***. This latter constraint forces many elements of ***s*** toward zero,
    thereby ensuring sparsity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*ℓ*²范数是欧几里得距离。*ℓ*¹范数，有时称为曼哈顿距离或出租车距离，是向量***x***各元素绝对值的总和。Lasso使用这个项，并将其按*α*缩放，用以找到一个***s***向量，该向量最小化测量值***y***和**Θ*****s***之间的欧几里得距离，同时最小化***s***各元素绝对值的总和。这个后者约束迫使***s***的许多元素趋向零，从而确保稀疏性。'
- en: To understand why the *ℓ*¹ norm term is present in the Lasso objective function,
    consider a simple case where we have a two-element vector and a single-element
    output. This is akin to finding a solution to *x* + *y* = *c* that is as sparse
    as possible, where *x* = 0 or *y* = 0\. Geometrically, minimizing the *ℓ*¹ norm
    leads to a situation as on the left of [Figure 9-1](ch09.xhtml#ch09fig01), while
    minimizing the *ℓ*² norm is shown on the right. Minimizing the *ℓ*² norm is standard
    least-squares regression.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么Lasso目标函数中存在*ℓ*¹范数项，考虑一个简单的情况，其中我们有一个二维向量和一个单元素输出。这类似于找到一个尽可能稀疏的* x*
    + * y* = *c*的解，其中* x* = 0 或* y* = 0。几何上，最小化*ℓ*¹范数导致的情况如[图 9-1](ch09.xhtml#ch09fig01)左侧所示，而最小化*ℓ*²范数如右侧所示。最小化*ℓ*²范数是标准的最小二乘回归。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Minimizing the ℓ¹ norm (left) and the ℓ² norm (right)*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：最小化ℓ¹范数（左）和ℓ²范数（右）*'
- en: The line in [Figure 9-1](ch09.xhtml#ch09fig01) represents the infinite set of
    solutions to *ax* + *by* = *c* for some *c*. The diamond on the left and the circle
    on the right correspond to constant *ℓ*¹ and *ℓ*² norms, respectively. Minimizing
    the *ℓ*¹ norm intersects the line at a point where *y* is zero, while minimizing
    *ℓ*² intersects the line at a point where neither *x* nor *y* is zero. This trend
    continues as the dimensionality increases. In each case, minimizing the *ℓ*¹ norm
    implies sparsity in the solution while minimizing the *ℓ*² norm distributes the
    “energy” throughout each dimension, the opposite of enforcing sparsity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch09fig01)中的直线表示某个*c*的*ax* + *by* = *c*的无限解集。左侧的菱形和右侧的圆形分别对应常数*ℓ*¹和*ℓ*²范数。最小化*ℓ*¹范数在*
    y*为零时与直线相交，而最小化*ℓ*²范数在* x*或* y*都不为零的点与直线相交。随着维度的增加，这一趋势持续下去。在每种情况下，最小化*ℓ*¹范数意味着解的稀疏性，而最小化*ℓ*²范数则将“能量”分布在每个维度上，正好与强制稀疏性相反。'
- en: Let’s sum up. We want to acquire ***x*** by measuring a subset of it, ***y***.
    To solve for random-ish measurement matrix ***A***, we want ***y*** = ***Ax***.
    This expression is underdetermined, meaning there are an infinite number of ***x***
    that work as solutions, so we need extra information to find the one we (likely)
    want. We get this information from expressing ***x*** in some other form (basis)
    where it becomes sparse. If sparse, the probability of finding a meaningful and
    parsimonious solution presents itself. A commonly used basis for this comes from
    the Fourier family of transformations, like the DCT, ***x*** = **Ψ*****s***, where
    **Ψ** encapsulates the DCT and ***s*** is a sparse vector we want to find. If
    we find ***s***, we find ***x***.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下。我们希望通过测量它的一个子集，***y***，来获取***x***。为了求解随机的测量矩阵***A***，我们希望***y*** = ***Ax***。这个表达式是欠定的，意味着有无数个***x***可以作为解，因此我们需要额外的信息来找到我们（可能）想要的那个解。我们通过将***x***表示为其他形式（基）来获得这个信息，在这种形式下它变得稀疏。如果是稀疏的，那么找到一个有意义且简洁的解的可能性就显现出来。常用的基来自傅里叶变换家族，如离散余弦变换（DCT），***x***
    = **Ψ*****s***，其中**Ψ**包含了DCT，***s***是我们希望找到的稀疏向量。如果我们找到***s***，我们就找到了***x***。
- en: Combining the measurement matrix and the DCT gives us a new equation, ***y***
    = **Θ*****s***, where we know ***y*** and **Θ**. It’s still underdetermined, but
    we know ***s*** is sparse. To find ***s***, we use an optimization algorithm that
    knows how to minimize the *ℓ*¹ norm of ***s*** in the process. This enforces sparsity
    and gives us some confidence that we might find a suitable ***s***.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将测量矩阵与离散余弦变换（DCT）结合，得到一个新的方程，***y*** = **Θ*****s***，其中我们已知***y***和**Θ**。方程仍然是欠定的，但我们知道***s***是稀疏的。为了求解***s***，我们使用一种优化算法，该算法能在过程中最小化*s*¹范数。这强制执行稀疏性，并让我们有信心可能找到一个合适的***s***。
- en: Let’s give the recipe a go and see what happens.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个方法，看看会发生什么。
- en: '**Signal Generation**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**信号生成**'
- en: 'We’ll walk through *cs_signal.py*, which illustrates the compressed sensing
    process and why we need to use random measurements. First, let’s run it, then
    I’ll explain the various plots it generates. Here’s the command line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步讲解*cs_signal.py*，它演示了压缩感知过程以及为什么我们需要使用随机测量。首先，运行它，然后我将解释它生成的各种图表。命令行如下：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Several plots should appear in succession; close each to move to the next. Output
    files are created as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会依次显示几个图表；关闭每个图表后，继续查看下一个。输出文件也会被创建。
- en: The code first generates a one-second signal, the sum of three sine waves forming
    a C major chord. Standard Nyquist sampling gives this signal for a sample rate
    of 4,096 Hz, that is, ***x***. This is a demonstration, so we start with ***x***
    and then throw much of it away to create a ***y*** that we might have plausibly
    measured in the first place. The command line includes an argument of `0.2`, the
    fraction of ***x*** to retain, meaning that ***y*** has 20 percent of the samples;
    we throw the remaining 80 percent away. The remainder of the command line specifies
    the randomness source (`minstd`) and a seed value (`65536`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先生成一个一秒钟的信号，它是由三条正弦波组成的C大调和弦。标准的奈奎斯特采样法给出了这个信号，采样率为4,096 Hz，即***x***。这是一个演示，所以我们从***x***开始，然后丢弃其中的大部分，生成一个***y***，这是我们最初可能测量到的信号。命令行中包括一个`0.2`的参数，表示保留***x***的20%，即***y***包含20%的样本；剩余的80%被丢弃。命令行的其余部分指定了随机性源（`minstd`）和种子值（`65536`）。
- en: 'The signal comes from:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 信号来自于：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We used similar code in [Chapter 8](ch08.xhtml). The three frequencies (`f0`,
    `f1`, `f2`) are the C major chord. The `samples` vector is the final signal, ***x***.
    It’s a vector of 4,096 elements because the sampling rate is 4,096 Hz and the
    duration is one second.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](ch08.xhtml)中使用了类似的代码。三个频率（`f0`、`f1`、`f2`）是C大调和弦。`samples`向量是最终的信号，***x***。它是一个包含4,096个元素的向量，因为采样率是4,096
    Hz，持续时间是1秒。
- en: 'Let’s build ***y*** from ***x***. This process makes implicit use of the measurement
    matrix. We’ll keep 20 percent of the samples in ***x***, first by selecting samples
    at a uniform interval, and then randomly. The uniform samples correspond to measuring
    the signal at some rate below the Nyquist limit:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从***x***构建***y***。这个过程隐式地使用了测量矩阵。我们将保留***x***中的20%样本，首先通过均匀间隔选择样本，然后随机选择。均匀样本对应于以低于奈奎斯特极限的速率测量信号：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are `nsamp` samples in ***y***. The first ***y*** vector is `bu`, uniformly
    sampled, and the second is `br`, randomly sampled. [Figure 9-2](ch09.xhtml#ch09fig02)
    shows the original signal with the uniform and random samples marked (*cs_signal_samples.png*).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '***y***中有`nsamp`个样本。第一个***y***向量是`bu`，均匀采样，第二个是`br`，随机采样。[图9-2](ch09.xhtml#ch09fig02)显示了原始信号及标记的均匀和随机样本（*cs_signal_samples.png*）。'
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig02.jpg)'
- en: '*Figure 9-2: Random (top) and uniform samples (bottom)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：随机采样（上）与均匀采样（下）*'
- en: 'We have the measurements. Now we need **Θ**, the combination of **Ψ** and the
    measurement matrix. Once we have that, we’re ready to use Lasso. We have two ***y***
    vectors, so we need two **Θ** matrices:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了测量值。现在我们需要**Θ**，即**Ψ**和测量矩阵的组合。一旦我们有了它，就可以开始使用Lasso了。我们有两个***y***向量，因此我们需要两个**Θ**矩阵：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first, `U`, keeps only the uniformly selected measurements. The second,
    `R`, uses the randomly selected measurements. Here, `D` is the discrete Fourier
    transform matrix, **Ψ**, and `U` and `R` are **Θ***[u]* and **Θ***[r]*, respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`U`，只保留均匀选择的测量值。第二个，`R`，使用随机选择的测量值。在这里，`D`是离散傅里叶变换矩阵，**Ψ**，而`U`和`R`分别是**Θ***[u]*和**Θ***[r]*。
- en: 'We optimize twice, first ***y**[u]* = **Θ***[u]**s**[u]* and then ***y**[r]*
    = **Θ***[r]**s**[r]*, where the subscripts refer now to the uniformly and randomly
    sampled measurements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行两次优化，首先是***y**[u]* = **Θ***[u]**s**[u]*，然后是***y**[r]* = **Θ***[r]**s**[r]*，其中下标现在表示均匀采样和随机采样的测量值：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Lasso` follows the scikit-learn convention of creating an instance of a class
    and then calling `fit` to do the optimization. For `Lasso`, the solution vector
    is buried in the `coef_` member variable, which we extract to get `su` and `sr`,
    the uniform and random ***s*** vectors, respectively. [Figure 9-3](ch09.xhtml#ch09fig03)
    shows the two ***s*** vectors (*cs_signal_sparse.png*).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lasso` 遵循 scikit-learn 的惯例，创建一个类的实例，然后调用 `fit` 来进行优化。对于 `Lasso`，解向量隐藏在 `coef_`
    成员变量中，我们提取它以获得 `su` 和 `sr`，即均匀和随机的 ***s*** 向量。 [图 9-3](ch09.xhtml#ch09fig03) 显示了这两个
    ***s*** 向量（*cs_signal_sparse.png*）。'
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig03.jpg)'
- en: '*Figure 9-3: Random (top) and uniform (bottom) solution vectors,* s'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：随机（上）和均匀（下）解向量，* s'
- en: The top plot shows ***s**[u]* and the bottom shows ***s**[r]*. The spikes correspond
    to DCT components. Both ***s*** vectors are sparse, with most of the 4,096 elements
    near zero, but the bottom vector has more than 10 nonzero elements while the top
    has only 3 (the shape is sometimes both positive and negative). Recall, ***x***
    is the sum of three sine waves, so the three sine waves and three spikes in the
    ***s**[r]* vector seems promising.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面的图显示了 ***s**[u]*，底部显示了 ***s**[r]*。这些尖峰对应于 DCT 组件。两个 ***s*** 向量都是稀疏的，大多数 4,096
    个元素接近零，但底部的向量有超过 10 个非零元素，而顶部的向量只有 3 个（形状有时既为正也为负）。回想一下，***x*** 是三条正弦波的总和，因此 ***s**[r]*
    向量中的三条正弦波和三次尖峰似乎很有前景。
- en: 'Lasso has solved ***y*** = **Θ*****s*** for us. Now we need ***x*** = **Ψ*****s***,
    which we find by calling the inverse DCT:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Lasso 已经为我们求解了 ***y*** = **Θ*****s***。现在我们需要 ***x*** = **Ψ*****s***，我们通过调用逆
    DCT 来找到它：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 9-4](ch09.xhtml#ch09fig04) shows us ***x**[u]* (`ru`) and ***x**[r]*
    (`rr`); see *cs_signal_recon.png*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch09fig04) 显示了 ***x**[u]* (`ru`) 和 ***x**[r]* (`rr`); 参见
    *cs_signal_recon.png*。'
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig04.jpg)'
- en: '*Figure 9-4: From top: the original, reconstructed randomly sampled, and reconstructed
    uniformly sampled signals*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：从上至下：原始信号、随机采样重建信号、均匀采样重建信号*'
- en: The topmost plot shows the original signal. The middle plot shows the signal
    reconstructed from 20 percent of the original signal using randomly selected measurements.
    Finally, the bottom plot shows the signal reconstructed from the uniformly selected
    measurements, likewise 20 percent of the original number. Which do you think more
    faithfully captured the original signal?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面的图显示了原始信号。中间的图显示了通过随机选择的测量值，从原始信号的 20% 重建的信号。最后，底部的图显示了通过均匀选择的测量值，同样是原始信号的
    20%，重建的信号。你认为哪一种更忠实地捕捉到了原始信号？
- en: 'The final step is to output the signal as a WAV file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将信号输出为 WAV 文件：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See [Listing 8-1](ch08.xhtml#ch08list01) to review how `WriteOutputWav` works.
    Play the output files. I think you’ll agree that random sampling produced the
    better result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [清单 8-1](ch08.xhtml#ch08list01) 来回顾 `WriteOutputWav` 是如何工作的。播放输出文件。我想你会同意，随机采样产生了更好的结果。
- en: Uniform sampling failed for deep mathematical reasons related to coherence between
    the measurement matrix and the DCT transform basis. However, we can intuitively
    understand the failure due to uniform sampling at less than the Nyquist rate,
    which means *aliasing* where higher frequency signals look like lower frequency
    signals, and there’s no way to disentangle the two. On the other hand, with random
    sampling, the likelihood of aliasing decreases, making Lasso more likely to find
    a suitable ***s*** vector.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀采样在深层数学原因上失败，原因与测量矩阵和 DCT 变换基之间的相干性有关。然而，我们可以直观地理解均匀采样在低于 Nyquist 率时失败，这意味着会出现
    *混叠*，即高频信号看起来像低频信号，且无法将两者区分开来。另一方面，通过随机采样，混叠的可能性降低，使得 Lasso 更可能找到合适的 ***s*** 向量。
- en: Rerun *cs_signal.py*, but alter the fraction from 20 percent to smaller and
    higher values. Is there a place where everything falls apart? See if you can re-create
    the signal from only 10 percent, 5 percent, or even 1 percent of the original,
    and then try the opposite direction. Sampling even slightly above 50 percent appears
    to have a dramatic effect on the quality of the uniform sample. Why might that
    be? Consider the Nyquist-Shannon sampling theorem requirements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行 *cs_signal.py*，但将分数从 20% 改为更小和更大的值。有没有地方出现问题？看看你能否仅通过原始信号的 10%、5% 甚至 1%
    来重建信号，然后尝试反方向。即使是稍微超过 50% 的采样，也似乎对均匀采样的质量产生了显著影响。为什么会这样呢？考虑一下 Nyquist-Shannon
    采样定理的要求。
- en: '**Unraveled Images**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解开的图像**'
- en: 'The file *cs_image.py* applies compressed sensing to images. It’s similar to
    *cs_signal.py*, but it unravels the image before selecting the measured components
    (pixels). The image is ***x***, with the selected mask pixels forming ***y***.
    The code expects these command line arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*cs_image.py*将压缩感知应用于图像。它类似于*cs_signal.py*，但它在选择测量的组件（像素）之前展开图像。图像是***x***，选定的掩膜像素形成***y***。代码期望以下命令行参数：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The input image may be grayscale or RGB. If RGB, each channel is processed individually
    using the same random mask. The output directory contains the original image,
    the reconstructed image, and a parameter file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图像可以是灰度图像或RGB图像。如果是RGB图像，每个通道将使用相同的随机掩膜单独处理。输出目录包含原始图像、重建图像和一个参数文件。
- en: 'The code tries to import from scikit-image. It will run if scikit-image isn’t
    installed, but you can install it with:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试从scikit-image中导入。如果scikit-image没有安装，它也会运行，但你可以通过以下命令安装：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If scikit-image is present, the code imports `structural_similarity`, which
    measures the mean structural similarity between two images—here the original image
    and the reconstructed image. Higher similarity is better, with 1.0 indicating
    an exact match.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在scikit-image，代码会导入`structural_similarity`，它测量两幅图像之间的平均结构相似性——这里是原始图像和重建图像。相似性越高越好，1.0表示完全匹配。
- en: 'The code loads the input image, converts it to RGB, and tests to see if it’s
    really grayscale:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码加载输入图像，将其转换为RGB，并测试是否真的是灰度图像：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A grayscale image converted to RGB ends up with every channel the same, hence
    the call to `array_equal`. The test is not entirely foolproof, but it’s good enough
    for us.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个转换为RGB的灰度图像，其每个通道都会相同，因此会调用`array_equal`。这个测试不是完全无懈可击的，但对我们来说已经足够好了。
- en: 'The next step generates the random mask, the subset of actual image pixels
    that construct ***y***:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步生成随机掩膜，实际图像像素的子集，用来构造***y***：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `mask` vector is 1 for selected pixels.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask`向量对于选定的像素值为1。'
- en: 'The remainder of the code calls `CS` for each image channel, if RGB, or the
    first channel, if grayscale, before dumping the original image, reconstructed
    image, and parameters to the output directory. All the action is in `CS`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分会针对每个图像通道调用`CS`，如果是RGB图像，或者如果是灰度图像，则调用第一个通道，然后将原始图像、重建图像和参数转储到输出目录中。所有操作都在`CS`中：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `CS` function is a compact version of the essential code in *cs_signal.py*.
    It forms the unraveled image (`f`) and then selects the masked regions to form
    `y`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`CS`函数是*cs_signal.py*中精简版的核心代码。它形成了展开的图像（`f`），然后选择掩膜区域来形成`y`。'
- en: To make the code reproducible from a given seed value, we define the local variable,
    `seed`, and pass it to the `Lasso` constructor before calling `fit`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码从给定的种子值可复现，我们定义了局部变量`seed`，并在调用`fit`之前将其传递给`Lasso`构造函数。
- en: When `fit` exits, the inverse DCT uses the sparse vector (***s***) to recover
    the image. The image isn’t scaled to [0, 255], so we first scale it to [0, 1]
    and then multiply by 255 and reshape (`oimg`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fit`退出时，逆DCT使用稀疏向量（***s***）来恢复图像。图像没有被缩放到[0, 255]，因此我们首先将其缩放到[0, 1]，然后乘以255并重塑（`oimg`）。
- en: Let’s find out whether *cs_image.py* works. This command line
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看*cs_image.py*是否有效。这个命令行
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: attempts to reconstruct the peppers image. It will take several minutes to run
    before producing [Figure 9-5](ch09.xhtml#ch09fig05).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重建辣椒图像。它将在运行几分钟后生成[图9-5](ch09.xhtml#ch09fig05)。
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig05.jpg)'
- en: '*Figure 9-5: The original image (left), mask (middle), and reconstructed image
    (right)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：原始图像（左），掩膜（中），重建图像（右）*'
- en: The original image is on the left, the 10 percent mask in the middle, and the
    reconstructed image on the right. This is best viewed in color; look at the files
    in the *peppers* directory. I inverted the mask image to show the selected pixels
    in black.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像在左侧，10%的掩膜在中间，重建图像在右侧。最好查看彩色版本；查看*peppers*目录中的文件。我反转了掩膜图像，以便将选定的像素显示为黑色。
- en: The reconstructed image isn’t particularly impressive until you remember that
    90 percent of the original image information was discarded or, in practice, never
    measured in the first place.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重建的图像并不特别引人注目，直到你记得原始图像信息中有90%被丢弃，或者实际上根本就没有被测量过。
- en: I claimed that Lasso finds sparse ***s*** vectors. The signal example was sparse,
    but what about images? The test images are 128×128 = 16, 384 pixels, meaning ***s***
    has that many elements. A quick test with the *barbara.png* image, keeping 20
    percent of the pixels, returned an ***s*** that’s 70 percent zeros. Dropping down
    to 10 percent jumps to 81 percent zeros, while moving up to 80 percent drops to
    only 15 percent zeros. Fewer measurements imply a sparser ***s***, which seems
    reasonable. Recall that ***s*** is the representation of the image in the discrete
    cosine transform space. If we can find only a few presumably low frequency components
    when attempting to best fit the few measurements in ***y***, we might expect most
    of ***s*** to be zero after imposing *ℓ*¹ regularization.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾声称 Lasso 找到稀疏的 ***s*** 向量。信号示例是稀疏的，但图像呢？测试图像为 128×128 = 16,384 像素，这意味着 ***s***
    含有这么多元素。使用 *barbara.png* 图像进行快速测试，保留 20% 的像素，返回的 ***s*** 中有 70% 是零。降到 10% 时，零的比例上升到
    81%，而升到 80% 时，零的比例降至仅 15%。测量减少意味着 ***s*** 更稀疏，这似乎是合理的。回想一下，***s*** 是图像在离散余弦变换空间中的表示。如果我们在尝试最优拟合
    ***y*** 的少量测量时，能找到少数低频成分，我们可能会期待大部分 ***s*** 在施加 *ℓ*¹ 正则化后变为零。
- en: The *cs_image_test* script runs *cs_image.py* repeatedly on the same test image
    while varying the measured fraction of pixels from 1 percent up to 80 percent.
    [Figure 9-6](ch09.xhtml#ch09fig06) shows the resulting reconstructed images.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*cs_image_test* 脚本反复运行 *cs_image.py*，在同一测试图像上，测量像素的比例从 1% 到 80% 不等。[图 9-6](ch09.xhtml#ch09fig06)
    显示了重建图像的结果。'
- en: '![Image](../images/09fig06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/09fig06.jpg)'
- en: '*Figure 9-6: Reconstructions of the* zelda.png *image by varying the fraction
    of the original pixels*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：通过改变原始像素的比例重建 *zelda.png* 图像*'
- en: At 10 percent, we can start to recognize the image, but it isn’t clear that
    it’s a person’s face until 20 percent. Note that I altered the intensity of the
    original *zelda.png* image to use the entire range [0, 255]; this makes it as
    bright as the reconstructions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10% 时，我们已经能够开始辨认图像，但直到 20% 时，才清楚地知道这是一张人的面孔。注意，我调整了原始 *zelda.png* 图像的亮度，使其使用整个
    [0, 255] 范围；这使其亮度与重建图像一致。
- en: '[Figure 9-7](ch09.xhtml#ch09fig07) shows a plot of the mean structural similarity
    index (SSIM) between the reconstructions and the original image.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-7](ch09.xhtml#ch09fig07) 显示了重建图像与原始图像之间的平均结构相似性指数 (SSIM) 的变化曲线。'
- en: '![Image](../images/09fig07.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/09fig07.jpg)'
- en: '*Figure 9-7: The mean structural similarity index as a function of measurements*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：平均结构相似性指数随测量数量的变化*'
- en: As we might anticipate, the index increases rapidly as the number of pixels
    measured increases. The results are encouraging, because there’s little perceptual
    difference between the original image and the one made from 20 percent fewer measurements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，随着测量像素数量的增加，指数迅速增加。结果令人鼓舞，因为原始图像和从减少 20% 测量中重建的图像之间几乎没有感知上的差异。
- en: '**Compressed Sensing Applications**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**压缩感知应用**'
- en: Compressed sensing is used in many places, including medical imaging, where
    its use has improved acquisition times in magnetic resonance imaging and various
    forms of tomography. Applying compressed sensing to tomography implies collecting
    fewer projections, leading to a substantial reduction in the amount of X-ray energy
    used (ionizing radiation).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩感知被广泛应用于许多领域，包括医学影像学，在磁共振成像和各种断层扫描形式中，压缩感知的应用显著提高了获取时间。将压缩感知应用于断层扫描意味着采集更少的投影，从而大幅减少使用的
    X 光能量（电离辐射）。
- en: Magnetic resonance imaging is a natural target for compressed sensing. The image
    acquisition process literally measures in *k-space*, or Fourier space, equivalent
    to measuring ***s*** directly. The desired image is recovered by a two-dimensional
    inverse Fourier transform, just as we recovered ***x*** from ***s*** via the inverse
    discrete cosine transform. Many k-space sampling strategies have been developed
    to speed image acquisition while still producing clinically valuable images. How
    magnetic resonance image acquisition works makes the simple random sampling in
    this chapter impractical, but alternative approaches for sampling k-space in a
    mathematically incoherent manner exist and lead to reduced acquisition times.
    For example, GE’s *HyperSense*, an advanced compressed sensing method, can reduce
    scan times by up to 50 percent. Faster scan times mean less scanner time for the
    patient.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 磁共振成像是压缩感知的自然应用目标。图像采集过程实际上是在*k空间*（或傅里叶空间）中进行测量，相当于直接测量***s***。通过二维反傅里叶变换恢复所需图像，就像我们通过逆离散余弦变换从***s***恢复***x***一样。许多k空间采样策略已被开发出来，以加速图像采集，同时仍能生成具有临床价值的图像。磁共振图像采集的工作原理使得本章中的简单随机采样不适用，但存在用于以数学上不相干的方式采样k空间的替代方法，这些方法能够减少采集时间。例如，GE的*HyperSense*，一种先进的压缩感知方法，能够将扫描时间减少最多50%。更快的扫描时间意味着患者所需的扫描时间减少。
- en: The future of compressed sensing is, however, a bit unclear. Deep neural networks
    are also quite good at solving inverse linear problems—in fact, likely better
    than traditional compressed sensing. Using deep neural networks in place of traditional
    CS, or in combination with it, is an active research area.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，压缩感知的未来有些不确定。深度神经网络在解决逆线性问题方面也非常擅长——事实上，可能比传统的压缩感知更好。将深度神经网络替代传统的压缩感知，或与其结合使用，是一个活跃的研究领域。
- en: '**Exercises**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: 'This brief chapter included two experiments, first with one-dimensional signals,
    then with images expressed as one-dimensional vectors. Here are some possible
    avenues for further exploration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了两个实验，首先是处理一维信号，然后是将图像表示为一维向量。以下是一些可能的进一步探索方向：
- en: 'The code in *cs_signal.py* worked with the entire one-second sound sample.
    How might you modify this basic approach to compress an arbitrary WAV file? Hint:
    try keeping only a random subset of each few hundred milliseconds of sound and
    reconstructing each.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cs_signal.py*中的代码是针对整个一秒钟的声音样本工作的。你如何修改这种基本方法来压缩任意WAV文件？提示：试着仅保留每几百毫秒声音的随机子集，并重建每个子集。'
- en: Assuming you build an arbitrary WAV filesystem, can you get away with using
    the same measurement matrix (the same random sampling) for each subset, or is
    it better to alter that in some way—maybe by using a fixed pseudorandom seed and
    selecting measurements in blocks as needed?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你构建了一个任意的WAV文件系统，你能否使用相同的测量矩阵（相同的随机采样）来处理每个子集，还是更好地以某种方式进行修改——也许使用固定的伪随机种子并根据需要以块的方式选择测量？
- en: All of our image experiments used *α* = 0.001\. Try varying *α* from near 0
    up to, or even beyond, 1\. If *α* = 0, the *ℓ*¹ regularization term in Lasso vanishes,
    and the optimization becomes standard least-squares using only the *ℓ*² norm.
    Does compressed sensing work well when *α* is very small? Note that the scikit-learn
    documentation for Lasso warns not to use *α* = 0, so, for that case, replace `Lasso`
    with `LinearRegression`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所有的图像实验都使用了*α* = 0.001。试着将*α*的值从接近0逐渐增加到1，甚至更大。如果*α* = 0，则Lasso中的*ℓ*¹正则化项消失，优化变成了仅使用*ℓ*²范数的标准最小二乘法。当*α*非常小时，压缩感知是否有效？注意，scikit-learn文档中对Lasso的警告是不要使用*α*
    = 0，因此在这种情况下，请将`Lasso`替换为`LinearRegression`。
- en: The *cs_image.py* file includes checks to see if the supplied randomness source
    is `quasi` and, if so, to interpret the seed value as the quasi-random generator
    base. What happens if you use `quasi` for different prime bases like 2, 3, or
    13? Can you explain the results you see?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cs_image.py*文件包含检查所提供的随机性源是否为`quasi`，如果是，则将种子值解释为准随机生成器的基数。如果使用不同的素数基数，如2、3或13，使用`quasi`会发生什么？你能解释你看到的结果吗？'
- en: We process RGB images color channel by color channel. As an alternative, we
    can unravel the full RGB image into a vector three times larger and then perform
    the optimization (remember to re-form the RGB image on output). Alter *cs_image.py*
    to do this. Does it matter? Does it help or hurt?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们处理RGB图像时是逐个颜色通道进行的。作为替代方案，我们可以将整个RGB图像展开为一个三倍大小的向量，然后进行优化（记得在输出时重新构建RGB图像）。修改*cs_image.py*来实现这一点。这有影响吗？会有帮助还是有害？
- en: Are all random measurement matrices created equal?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的随机测量矩阵都是平等的吗？
- en: '**Summary**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Compressed sensing breaks the Nyquist-Shannon sampling theorem limit and allows
    signals to be reconstructed from fewer samples than initially thought possible.
    In this chapter, we experimented with a basic form of compressed sensing and applied
    it to audio signals and images.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩感知突破了奈奎斯特-香农采样定理的限制，允许从比最初认为可能的更少的样本中重建信号。在本章中，我们实验了压缩感知的基本形式，并将其应用于音频信号和图像。
- en: First, we discussed the core concepts in compressed sensing, including sparsity
    and *ℓ*¹ regularization. We then expressed the compressed sensing problem as an
    inverse linear problem of the form ***y*** = ***Cx*** for measured vector ***y***
    and desired output vector ***x***. In practice, sparsity constraints means using
    an alternate form of ***x*** = **Ψ*****s*** for sparse vector ***s*** and basis
    **Ψ**. For us, **Ψ** came from the discrete cosine transform in which signals
    are known to be sparse.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了压缩感知中的核心概念，包括稀疏性和*ℓ*¹正则化。接着，我们将压缩感知问题表示为一个逆线性问题，形式为***y*** = ***Cx***，其中***y***为测量向量，***x***为期望输出向量。实际上，稀疏性约束意味着使用***x***
    = **Ψ*****s***的另一种形式，其中***s***为稀疏向量，**Ψ**为基。对我们来说，**Ψ**来源于离散余弦变换，在这种变换下，信号被认为是稀疏的。
- en: The compressed sensing problem then became one of finding solution vector ***s***
    such that the *ℓ*² distance between ***y*** and ***C*****Ψ*****s*** = **Θ*****s***
    was as small as possible, subject to the constraint that ∥***s***∥[1] was also
    as small as possible. We discovered that Lasso regression accomplishes this goal
    quite nicely.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩感知问题变成了寻找解向量***s***，使得***y***和***C*****Ψ*****s*** = **Θ*****s***之间的*ℓ*²距离尽可能小，同时满足∥***s***∥[1]也尽可能小的约束。我们发现，Lasso回归非常好地实现了这一目标。
- en: Theory in hand, we performed two sets of experiments. The first sought to reconstruct
    a one-second audio signal, a C major chord, using uniform sampling below the Nyquist
    limit and random sampling. Uniform sampling couldn’t recover the signal until
    the sampling rate exceeded half the playback rate (in which more than 50 percent
    of samples were kept). On the other hand, random sampling with compressed sensing
    returned good results even after discarding up to 90 percent of the original data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 手头有了理论，我们进行了两组实验。第一组实验旨在利用低于奈奎斯特限制的均匀采样和随机采样来重建一个一秒钟的音频信号，即C大调和弦。均匀采样无法恢复信号，直到采样率超过播放率的一半（此时保留了超过50%的样本）。另一方面，使用压缩感知的随机采样，即使丢弃了最多90%的原始数据，仍然能得到良好的结果。
- en: In the second experiment, we worked with both grayscale and RGB images. As with
    signals, we successfully used compressed sensing and the discrete cosine transform
    to recover images from as little as 10 percent of the original pixels, often with
    considerable noise. The DCT isn’t necessarily the best basis for images, but better
    ones, like wavelets, are beyond the scope of this book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个实验中，我们处理了灰度图像和RGB图像。与信号一样，我们成功地使用了压缩感知和离散余弦变换，从原始图像的10%的像素恢复出图像，尽管通常伴随有相当大的噪声。DCT不一定是图像的最佳基底，但更好的基底，如小波变换，超出了本书的讨论范围。
- en: We closed the chapter by pointing out that compressed sensing has been a boon
    to medical imaging to improve patient comfort and reduce exposure to ionizing
    radiation. Finally, we noted that recent advances in deep neural networks will
    likely substantially impact the future of compressed sensing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指出压缩感知对医学影像的贡献来结束这一章，它改善了患者的舒适度，并减少了电离辐射的暴露。最后，我们提到，深度神经网络的最新进展可能会对压缩感知的未来产生重大影响。
- en: We’ll take a break from experimenting in the next chapter to explore how we
    use randomness in experiments themselves. Modern science critically depends on
    properly designed experiments, and randomness is a powerful player in that process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂停实验，探讨在实验中如何使用随机性。现代科学在很大程度上依赖于精心设计的实验，而随机性在这一过程中起着重要作用。
