- en: '**1 Basics of Memory Extraction**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we jump into exploits that extract firmware from locked microcontrollers,
    let’s take a chapter to consider the basics. Let’s briefly race through many of
    the methods that might work, then in later chapters we will learn those same attacks
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: First, it’s important to collect all of the available documentation on the chip,
    its debugging mechanism, and its bootloaders.
  prefs: []
  type: TYPE_NORMAL
- en: For publicly documented chips, you’ll want the datasheet, the family guide,
    a few reference designs, and a working cross compiler. Only by first understanding
    how the chip would be programmed in a factory will you find the bug that dumps
    the firmware out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps I should back up a little and explain these terms. A datasheet is a
    short description of the chip, usually less than a hundred pages and describing
    what you need to build a circuit board for it. Family guides go by different names:
    programmer’s guide, integration guide, user’s guide, or whatever the vendor feels
    like that week. They usually describe a whole family of related parts, and they’ll
    refer you to still more documentation. Reference designs are schematics, source
    code, and CAD files that chip vendors encourage engineers to copy as a way to
    get their chips into finished products.'
  prefs: []
  type: TYPE_NORMAL
- en: For undocumented and unlabeled chips, you’ll have to make do with what few scraps
    you can acquire, such as designs for related chips or leaked documentation from
    developers. With a little luck, these clues will lead to something useful. When
    reverse engineering the Tytera MD380’s proprietary radio chip, labeled as HR C5000,
    a confidential developer’s guide in Chinese was found through `DocIn.com`.^([1](footnotes.xhtml#ch1fn1))
    Reverse engineering a modern Tamagotchi toy, Natalie Silvanovich sorted through
    dozens and dozens of die bonding photographs to identify that an unlabeled microcontroller
    was a General Plus GPLB52X, for which datasheets could then be found.^([2](footnotes.xhtml#ch1fn2))
    While the RF430TAL152 RFID chip in the Freestyle Libre glucose monitor is undocumented,
    the publicly documented RF430FRL152 is nearly identical except for minor details,
    such as its ROM contents.^([3](footnotes.xhtml#ch1fn3))
  prefs: []
  type: TYPE_NORMAL
- en: It is tempting to jump straight to attacking a chip, without first using the
    chip as a developer, but you’ll notice that nearly every exploit in this book
    begins with an understanding of the target’s nuances. For any new chip, take the
    time to draw out its memory map, to explore an unlocked chip with a debugger,
    and to really understand how the chip is used. If at all possible, don’t skip
    the step of compiling and running Hello World on your target!
  prefs: []
  type: TYPE_NORMAL
- en: '**JTAG**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For debugging and failure analysis, most chips implement some variant of the
    JTAG protocol in hardware. The classic variant uses four signal wires: TDI, TDO,
    TCK, and TMS. A fifth signal, TRST, is sometimes included, and multiple two-wire
    variants exist for easier routing, such as cJTAG, single wire debug (SWD), and
    spy-bi-wire.'
  prefs: []
  type: TYPE_NORMAL
- en: These wires all have a purpose. TDI and TDO are serial input and output signals,
    clocked by the TCK signal. TMS selects the mode, letting the debugger move the
    target state machine between different registers. All of these details are abstracted
    away by the debugger hardware and software, and you needn’t dive into them until
    you need to write your own.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re lucky, you have an unlocked chip and can dump the chip by simply connecting
    a JTAG adapter and using a debugger to export the full range of flash memory to
    disk. Developers often leave devices unlocked for failure analysis reasons, so
    that they can more easily improve the manufacturing yield and keep the assembly
    line running. Some devices don’t even support locking, and those are always easy
    to read!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re less lucky, the JTAG port will be fully or partially disabled to prevent
    readout, configured by a fuse or a nonvolatile memory flag.
  prefs: []
  type: TYPE_NORMAL
- en: Full JTAG locks are often bypassed by some form of fault injection, in which
    the electrical, photovoltaic, or electromagnetic requirements of the chip are
    briefly violated to bypass a protection mechanism. For example, the full lock
    on many of the STM32 chips can be degraded to a partial lock by a supply voltage
    glitch after reset.^([4](footnotes.xhtml#ch1fn4)) Many MSP430 chips fall from
    their full lock to an unlocked state if hit by a camera flash.^([5](footnotes.xhtml#ch1fn5))
  prefs: []
  type: TYPE_NORMAL
- en: Partial JTAG locks are a little trickier, if only because they are so diverse.
    Generally, a partial lock allows some form of debugging for failure analysis purposes,
    while applying restrictions to flash memory. The STM32F0’s partial protection
    disconnects flash from the data bus after JTAG connects, but it does so a few
    clock cycles too late, so that you can dump memory by repeatedly reconnecting
    to extract a single 32-bit word.^([6](footnotes.xhtml#ch1fn6)) Similarly, the
    partial protection of the STM32F1 can be broken by realizing that interrupt handlers
    are fetched through the instruction bus, so that by relocating the table with
    the vector table offset register (VTOR), one might fire interrupts while single
    stepping and observing registers in order to leak words from flash memory.^([7](footnotes.xhtml#ch1fn7))
  prefs: []
  type: TYPE_NORMAL
- en: '**ROM Bootloaders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many microcontrollers ship with a mask ROM. The contents and format for these
    vary dramatically, but when present, they’ll usually contain at least a bootloader
    and perhaps also some convenience functions, much like an old IBM PC’s BIOS. The
    bits of these ROMs come from a lithography mask at the time of manufacturing,
    and often you can photograph them to see and decode these bits.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the application code that we’re trying to extract from flash memory,
    the ROM code can be decompiled and reverse engineered. An exploitable bug in this
    code can be difficult or impossible to patch, leading to firmware dumps from entire
    families of chips.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F2 and STM32F4 ROMs, for a specific example, contain three bootloaders,
    allowing the chips to boot from USB, Serial and CAN bus. These three bootloaders
    contain three different re-implementations of the partial JTAG lock functionality,
    and a software bug in the USB device firmware update (DFU) bootloader allows code
    to be executed from an arbitrary address, which can in turn dump all of a locked
    device’s firmware.^([8](footnotes.xhtml#ch1fn8))
  prefs: []
  type: TYPE_NORMAL
- en: In very high volume chips, you might find custom ROM images. These won’t match
    the ones of the consumer model of the chip, but they are often forked from that
    same code, which can give you clues to their contents before a successful dump.^([9](footnotes.xhtml#ch1fn9))
    Because the bits of the ROM are sometimes visible under a microscope, we can read
    these bits out visually with a bit of patience and software assistance.^([10](footnotes.xhtml#ch1fn10))
  prefs: []
  type: TYPE_NORMAL
- en: '**Flash Bootloaders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already discussed bootloaders in ROM, which come from the chip manufacturer,
    but many device manufacturers will add their own bootloader, either written from
    scratch or forked from a reference design.
  prefs: []
  type: TYPE_NORMAL
- en: The Tytera MD380, for example, is a two-way radio whose firmware was dumped
    and then patched to add new features for the ham radio community. Its STM32F405
    includes the ROM bootloader mentioned above, but also a second flash bootloader,
    with a custom variant of the DFU protocol. The flash bootloader allows the SPI
    flash chip of the radio to be read and written in cleartext, while the internal
    flash region can only be written, and only with encrypted firmware updates. An
    uninitialized pointer in this bootloader allows the first 48kB of memory to be
    dumped, containing the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: By patching this bootloader to leave the chip unlocked, cleartext firmware can
    be freely extracted with JTAG!^([11](footnotes.xhtml#ch1fn11))
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your target and whatever your technique, the goal is to get code out
    of a protected chip. With the right techniques and a good understanding of how
    the protection works, almost any chip will fall to a dedicated reverse engineer.
  prefs: []
  type: TYPE_NORMAL
