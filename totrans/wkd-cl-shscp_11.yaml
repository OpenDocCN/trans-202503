- en: '**10**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**INTERNET SERVER ADMINISTRATION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The job of managing a web server and service is often completely separate from
    the job of designing and managing content on the website. While the previous chapter
    offered tools geared primarily toward web developers and other content managers,
    this chapter shows how to analyze web server log files, mirror websites, and monitor
    network health.
  prefs: []
  type: TYPE_NORMAL
- en: '**#73 Exploring the Apache access_log**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re running Apache or a similar web server that uses the *Common Log Format*,
    you can do quite a bit of quick statistical analysis with a shell script. In a
    standard configuration, the server writes *access_log* and *error_log* files for
    the site (generally in */var/log*, but this can be system dependent). If you’ve
    got your own server, you should definitely be archiving this valuable information.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-1](ch10.xhtml#ch10table1) lists the fields in an *access_log* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Field Values in the *access_log* File'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | IP of host accessing the server |'
  prefs: []
  type: TYPE_TB
- en: '| 2–3 | Security information for HTTPS/SSL connections |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Date and time zone offset of the specific request |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Method invoked |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | URL requested |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Protocol used |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Result code |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Number of bytes transferred |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Referrer |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Browser identification string |'
  prefs: []
  type: TYPE_TB
- en: 'A typical line in *access_log* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The result code (field 8) of `301` indicates that the request was considered
    a success. The referrer (field 10) indicates the URL of the page that the user
    was visiting immediately before the page request. Ten years ago, this would have
    been the URL of the previous page; now it’s generally `"-"`, as you see here,
    for privacy reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The number of hits to the site can be determined by doing a line count on the
    log file, and the date range of entries in the file can be ascertained by comparing
    the first and last lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With these points in mind, the script in [Listing 10-1](ch10.xhtml#ch10ex1)
    produces a number of useful statistics from an Apache-format *access_log* file.
    This script expects the `scriptbc` and `nicenumber` scripts we wrote in [Chapter
    1](ch01.xhtml#ch01) to be in the `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: The* `*webaccess*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s consider each block as a separate little script. For example, the first
    few lines extract the `firstdate` and `lastdate` ➊ by simply grabbing the fourth
    field of the first and last lines of the file. The number of hits is calculated
    by counting lines in the file using `wc` ➋, and the number of page views is calculated
    by simply subtracting requests for image files (that is, files with *.gif*, *.jpg*,
    or *.png* as their extension) from the hits. Total bytes transferred are calculated
    by summing up the value of the 10th field in each line and then invoking `nicenumber`
    to present it attractively.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the most popular pages, first we extract just the pages requested
    from the log file, and then we screen out any image files ➌. Next we use `uniq
    -c` to sort and calculate the number of occurrences of each unique line. Finally,
    we sort one more time to ensure that the most commonly occurring lines are presented
    first. In the code, this whole process is at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we do normalize things a little bit: the `sed` invocation strips
    out any trailing slashes to ensure that `/subdir/` and `/subdir` are counted as
    the same request.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the section that retrieves the 10 most requested pages, the section
    at ➎ pulls out the referrer information.
  prefs: []
  type: TYPE_NORMAL
- en: This extracts field 11 from the log file, screening out entries that were referred
    from the current host as well as entries that are `"-"`, the value sent when the
    web browser is blocking referrer data. Then the code feeds the result to the same
    sequence of `sort|uniq -c|sort -rn|head -10` to get the 10 most common referrers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, specify the name of an Apache (or other Common Log Format)
    log file as its only argument.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The result of running this script on a typical log file is quite informative,
    as [Listing 10-2](ch10.xhtml#ch10ex2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0238-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Listing 10-2: Running the* `*webaccess*` *script on an Apache access log*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One challenge of analyzing Apache log files is that there are situations in
    which two different URLs refer to the same page; for example, */custer/* and */custer/index.html*
    are the same page. Calculating the 10 most popular pages should take this into
    account. The conversion performed by the `sed` invocation already ensures that
    */custer* and */custer/* aren’t treated separately, but knowing the default filename
    for a given directory might be a bit trickier (especially since this can be a
    special configuration on the web server).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make the 10 most popular referrers more useful by trimming referrer
    URLs to just the base domain name (e.g., *slashdot.org*). [Script #74](ch10.xhtml#ch10lev1sec02),
    coming up next, explores additional information available from the referrer field.
    The next time your website gets “slashdotted,” you should have no excuse for not
    knowing!'
  prefs: []
  type: TYPE_NORMAL
- en: '**#74 Understanding Search Engine Traffic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Script #73](ch10.xhtml#ch10lev1sec01) can offer a broad overview of some of
    the search engine queries that point to your site, but further analysis can reveal
    not only which search engines are delivering traffic but also what keywords were
    entered by users who arrived at your site via search engines. This information
    can be invaluable for understanding whether your site has been properly indexed
    by the search engines. Moreover, it can provide the starting point for improving
    the rank and relevancy of your search engine listings, though, as we mentioned
    earlier, this additional information is slowly being deprecated by Apache and
    web browser developers. [Listing 10-3](ch10.xhtml#ch10ex3) details the shell script
    for retrieving this information from your Apache logs.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3: The* `*searchinfo*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main `for` loop ➊ of this script extracts all entries in the log file that
    have a valid referrer with a string length greater than 4, a referrer domain that
    does not match the `$host` variable, and a `?` in the referrer string, indicating
    that a user search was performed.
  prefs: []
  type: TYPE_NORMAL
- en: The script then tries to identify the domain name of the referrer and the search
    value entered by the user ➋. An examination of hundreds of search queries shows
    that common search sites use a small number of common variable names. For example,
    search on Yahoo! and your search string is `p=pattern`. Google and MSN use `q`
    as the search variable name. The `grep` invocation contains `p`, `q`, and the
    other most common search variable names.
  prefs: []
  type: TYPE_NORMAL
- en: The invocation of `sed` ➌ cleans up the resultant search patterns, replacing
    `+` and `%20` sequences with spaces and chopping out quotes, and the `cut` command
    returns everything that occurs after the first equal sign. In other words, the
    code returns just the search terms.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional immediately following these lines tests whether the `args` variable
    is empty. If it is (that is, if the query format isn’t a known format), then it’s
    a search engine we haven’t seen, so we output the entire pattern rather than a
    cleaned-up, pattern-only value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, simply specify the name of an Apache or other Common Log
    Format log file on the command line (see [Listing 10-4](ch10.xhtml#ch10ex4)).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is one of the slowest scripts in this book because it’s spawning lots
    of subshells to perform various tasks, so don’t be surprised if it takes a while
    to run.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-4: Running the* `*searchinfo*` *script on Apache logs*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One way to tweak this script is to skip the referrer URLs that are most likely
    not from search engines. To do so, simply comment out the `else` clause at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to approach this task would be to search for all hits coming from
    a specific search engine, entered as the second command argument, and then compare
    the search strings specified. The core `for` loop would change, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll also want to tweak the usage message so that it mentions the new second
    argument. Again, this script is going to eventually just report blank data due
    to changes in how web browsers—and Google in particular— report the Referer info.
    As you can see, of the matching entries in this log file, 771 reported no referrer
    and therefore no useful information about keyword usage.
  prefs: []
  type: TYPE_NORMAL
- en: '**#75 Exploring the Apache error_log**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as [Script #73](ch10.xhtml#ch10lev1sec01) on [page 235](ch10.xhtml#page_235)
    reveals the interesting and useful statistical information found in the regular
    access log of an Apache or Apache-compatible web server, this script extracts
    the critical information from the *error_log* file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For those web servers that don’t automatically split their logs into separate
    *access_log* and *error_log* components, you can sometimes split a central log
    file into these components by filtering based on the return code (field 9) of
    each entry in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A return code that begins with a 4 or a 5 is a failure (the 400s are client
    errors and the 500s are server errors), and a return code beginning with a 2 or
    a 3 is a success (the 200s are success messages and the 300s are redirects).
  prefs: []
  type: TYPE_NORMAL
- en: Other servers that produce a single central log file containing both successes
    and errors denote the error message entries with an `[error]` field value. In
    that case, the split can be done with a `grep '[error]'` to create the error log
    and a `grep -v '[error]'` to create the access log.
  prefs: []
  type: TYPE_NORMAL
- en: Whether your server automatically creates an error log or you have to create
    your own error log by searching for entries with the `'[error]'` string, just
    about everything in the error log is different from the content of the access
    log, including the way the date is specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the access log, dates are specified as a compact one-field value with no
    spaces; the error log takes five fields instead. Furthermore, rather than a consistent
    scheme in which the word/string position in a space-delimited entry consistently
    identifies a particular field, entries in the error log have a meaningful error
    description that varies in length. An examination of just those description values
    reveals surprising variation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some of these errors should be examined by hand because they can be difficult
    to track backward to the offending web page.
  prefs: []
  type: TYPE_NORMAL
- en: The script in [Listing 10-5](ch10.xhtml#ch10ex5) focuses on the most common
    problems—in particular, `File does not exist` errors—and then produces a dump
    of all other error log entries that don’t match well-known error situations.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-5: The* `*weberrors*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script works by scanning the error log for the five errors specified in
    the calls to the `checkfor` function, extracting the last field on each error
    line with an `awk` call for `$NF` (which represents the number of fields in that
    particular input line). This output is then fed through `sort | uniq -c | sort
    -rn` ➋ to make it easy to extract the most commonly occurring errors for that
    category of problem.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that only those error types with matches are shown, each specific
    error search is saved to the temporary file, which is then tested to make sure
    it isn’t empty before a message is output. This is all neatly done with the `checkfor()`
    function that appears near the top of the script.
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines of the script identify the most common errors not otherwise
    checked for by the script but that are still in standard Apache error log format.
    The `grep` invocations at ➊ are part of a longer pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Then the script identifies the most common errors not otherwise checked for
    by the script that *don’t* occur in standard Apache error log format. Again, the
    `grep` invocations at ➌ are part of a longer pipe.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This script should be passed the path to a standard Apache-format error log
    as its only argument, shown in [Listing 10-6](ch10.xhtml#ch10ex6). If invoked
    with a `-l length` argument, it will display `length` number of matches per error
    type checked rather than the default of five entries per error type.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-6: Running the* `*weberrors*` *script on Apache error logs*'
  prefs: []
  type: TYPE_NORMAL
- en: '**#76 Avoiding Disaster with a Remote Archive**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether or not you have a comprehensive backup strategy, it’s a nice insurance
    policy to back up a few critical files with a separate off-site archive system.
    Even if it’s just that one key file with all your customer addresses, your invoices,
    or even emails from your sweetheart, having an occasional off-site archive can
    save your proverbial bacon when you least expect it.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds more complex than it really is, because as you’ll see in [Listing
    10-7](ch10.xhtml#ch10ex7), the “archive” is just a file emailed to a remote mailbox,
    which could even be a Yahoo! or Gmail mailbox. The list of files is kept in a
    separate data file, with shell wildcards allowed. Filenames can contain spaces,
    something that rather complicates the script, as you’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-7: The* `*remotebackup*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the basic validity checks, the script processes the file containing the
    list of critical files, which is supplied as the first command line argument,
    to ensure that spaces embedded in its filenames will work in the `while` loop
    ➊. It does this by prefacing every space with a backslash. Then it builds the
    archive with the `tar` command ➋, which lacks the ability to read standard input
    for its file list and thus must be fed the filenames via a `cat` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: The `tar` invocation automatically compresses the archive, and `uuencode` is
    then utilized to ensure that the resultant archive data file can be successfully
    emailed without corruption. The end result is that the remote address receives
    an email message with the uuencoded `tar` archive as an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `*uuencode*` *program wraps up binary data so that it can safely travel
    through the email system without being corrupted. See* `*man uuencode*` *for more
    information.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script expects two arguments: the name of a file that contains a list
    of files to archive and back up and the destination email address for the compressed,
    `uuencoded` archive file. The file list can be as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 10-8](ch10.xhtml#ch10ex8) details running the `remotebackup` shell
    script to back up all HTML and shell script files in the current directory, and
    then printing the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-8: Running the* `*remotebackup*` *script to back up HTML and shell
    script files*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First off, if you have a modern version of `tar`, you might find that it has
    the ability to read a list of files from `stdin` (for example, GNU’s `tar` has
    a `-T` flag to have the file list read from standard input). In this case, the
    script can be shortened by updating how the file list is given to `tar`.
  prefs: []
  type: TYPE_NORMAL
- en: The file archive can then be unpacked or simply saved, with a mailbox trimmer
    script run weekly to ensure that the mailbox doesn’t get too big. [Listing 10-9](ch10.xhtml#ch10ex9)
    details a sample trimmer script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-9: The* `*trimmailbox*` *script, to be used in conjunction with
    the* `*remotebackup*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: This succinct script deletes all messages in the mailbox other than the most
    recent ones (`$keep`). Obviously, if you’re using something like Hotmail or Yahoo!
    Mail for your archive storage, this script won’t work and you’ll have to log in
    occasionally to trim things.
  prefs: []
  type: TYPE_NORMAL
- en: '**#77 Monitoring Network Status**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most puzzling administrative utilities in Unix is `netstat`, which
    is too bad, because it offers quite a bit of useful information about network
    throughput and performance. With the `-s` flag, `netstat` outputs volumes of information
    about each of the protocols supported on your computer, including TCP, UDP, IPv4/v6,
    ICMP, IPsec, and more. Most of those protocols are irrelevant for a typical configuration;
    usually the protocol you want to examine is TCP. This script analyzes TCP protocol
    traffic, determining the percentage of packet transmission failure and including
    a warning if any values are out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing network performance as a snapshot of long-term performance is useful,
    but a much better way to analyze data is with trends. If your system regularly
    has 1.5 percent packet loss in transmission, and in the last three days the rate
    has jumped up to 7.8 percent, a problem is brewing and needs to be analyzed in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, this script is two parts. The first part, shown in [Listing 10-10](ch10.xhtml#ch10ex10),
    is a short script that is intended to run every 10 to 30 minutes, recording key
    statistics in a log file. The second script ([Listing 10-11](ch10.xhtml#ch10ex11))
    parses the log file, reporting typical performance and any anomalies or other
    values that are increasing over time.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some flavors of Unix can’t run this code as is (though we’ve confirmed it’s
    working on OS X as is)! It turns out that there is quite a variation in the output
    format (many subtle whitespace changes or slight spelling) of the* `*netstat*`
    *command between Linux and Unix versions. Normalizing* `*netstat*` *output would
    be a nice script unto itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-10: The* `*getstats*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: The second script, shown in [Listing 10-11](ch10.xhtml#ch10ex11), analyzes the
    `netstat` historical log file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-11: The* `*netperf*` *script, to be used with the* `*getstats*`
    *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `netstat` program is tremendously useful, but its output can be intimidating.
    [Listing 10-12](ch10.xhtml#ch10ex12) shows just the first 10 lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-12: Running* `*netstat*` *to get TCP information*'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to extract just those entries that contain interesting and
    important network performance statistics. That’s the main job of `getstats`, and
    it does this by saving the output of the `netstat` command into the temp file
    *$temp* and going through *$temp* to calculate key values, such as total packets
    sent and received. The line at ➊, for example, gets the number of packets sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sed` invocation removes any nondigit values to ensure that no tabs or
    spaces end up as part of the resulting value. Then all of the extracted values
    are written to the *netstat.log* log file in the format `var1Name=var1Value; var2Name=var2Value;`
    and so forth. This format will let us later use `eval` on each line in *netstat.log*
    and have all the variables instantiated in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0253-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `netperf` script does the heavy lifting, parsing *netstat.log* and reporting
    both the most recent performance numbers and any anomalies or other values that
    are increasing over time. The `netperf` script calculates the current percentage
    of retransmits by dividing retransmits by packets sent and multiplying this result
    by 100\. An integer-only version of the retransmission percentage is calculated
    by taking the result of dividing retransmissions by total packets sent, multiplying
    it by 10,000, and then dividing by 100 ➌.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the naming scheme for variables within the script begins with
    the abbreviations assigned to the various `netstat` values, which are stored in
    *netstat.log* at the end of the `getstats` script ➋. The abbreviations are `snt`,
    `re`, `rec`, `dup`, `oo`, `creq`, `cacc`, and `reto`. In the `netperf` script,
    the `p` suffix is added to any of these abbreviations for variables that represent
    decimal percentages of total packets sent or received. The `pn` suffix is added
    to any of the abbreviations for variables that represent integer-only percentages
    of total packets sent or received. Later in the `netperf` script, the `ps` suffix
    denotes a variable that represents the percentage summaries (averages) used in
    the final calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop steps through each entry of *netstat.log*, calculating the
    four key percentile variables (`re`, `retr`, `dup`, and `oo`, which are retransmits,
    transmit timeouts, duplicates, and out of order, respectively). All are written
    to the `$stats` temp file, and then the `awk` script sums each column in `$stats`
    and calculates average column values by dividing the sums by the number of records
    in the file (`NR`).
  prefs: []
  type: TYPE_NORMAL
- en: The `eval` line at ➍ ties things together. The `awk` invocation is fed the set
    of summary statistics (`$stats`) produced by the `while` loop and utilizes the
    calculations saved in the `$awktmp` file to output `variable=value` sequences.
    These `variable=value` sequences are then incorporated into the shell with the
    `eval` statement, instantiating the variables `reps`, `retops`, `dupps`, and `oops`,
    which are average retransmit, average retransmit timeouts, average duplicate packets,
    and average out-of-order packets, respectively. The current percentile values
    can then be compared to these average values to spot problematic trends.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the `netperf` script to work, it needs information in the *netstat.log*
    file. That information is generated by having a `crontab` entry that invokes `getstats`
    with some level of frequency. On a modern OS X, Unix, or Linux system, the following
    `crontab` entry will work fine, with the correct path to the script for your system
    of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It will produce a log file entry every 15 minutes. To ensure the necessary file
    permissions, it’s best to actually create an empty log file by hand before running
    `getstats` for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now the `getstats` program should chug along happily, building a historical
    picture of the network performance of your system. To analyze the contents of
    the log file, run `netperf` without any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First off, let’s check on the *.netstatlog* file, shown in [Listing 10-13](ch10.xhtml#ch10ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0255-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Listing 10-13: The last three lines of the* .netstatlog *that results from
    a* `*crontab*` *entry running the* `*getstats*` *script on a regular interval*'
  prefs: []
  type: TYPE_NORMAL
- en: It looks good. [Listing 10-14](ch10.xhtml#ch10ex14) shows the results of running
    `netperf` and what it has to report.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-14: Running the* `*netperf*` *script to analyze the* .netstatlog
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve likely already noticed that rather than using a human-readable date format,
    the `getstats` script saves entries in the *.netstatlog* file using epoch time,
    which represents the number of seconds that have elapsed since January 1, 1970\.
    For example, 1,063,983,000 seconds represents a day in late September 2003\. The
    use of epoch time will make it easier to enhance this script by enabling it to
    calculate the time elapsed between readings.
  prefs: []
  type: TYPE_NORMAL
- en: '**#78 Renicing Tasks by Process Name**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many times when it’s useful to change the priority of a task, whether
    a chat server is supposed to use only “spare” cycles, an MP3 player app is not
    that important, a file download has become less important, or a real-time CPU
    monitor needs an increase in priority. You can change a process’s priority with
    the `renice` command; however, it requires you to specify the process ID, which
    can be a hassle. A much more useful approach is to have a script like the one
    in [Listing 10-15](ch10.xhtml#ch10ex15) that matches process name to process ID
    and automatically renices the specified application.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-15: The* `*renicename*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script borrows liberally from [Script #47](ch06.xhtml#ch06lev1sec03) on
    [page 150](ch06.xhtml#page_150), which does a similar mapping of process name
    to process ID—but that script kills the jobs rather than just lowering their priority.'
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you don’t want to accidentally renice a number of matching
    processes (imagine `renicename -n 10 "*"`, for example), so the script fails if
    more than one process matches. Otherwise, it makes the change specified and lets
    the actual `renice` program report any errors that may have been encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have a number of possible options when running this script: `-n val` allows
    you to specify the desired `nice` (job priority) value. The default is specified
    as `niceval=1`. The `-u user` flag allows matching processes to be limited by
    user, while `-t tty` allows a similar filter by terminal name. To see just the
    matching process ID and not actually renice the application, use the `-p` flag.
    In addition to one or more flags, `renicename` requires a command pattern, which
    will be compared to the running process names on the system to ascertain which
    of the processes match.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First off, [Listing 10-16](ch10.xhtml#ch10ex16) shows what happens when there
    is more than one matching process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-16: Running the* `*renicename*` *script with a process name with
    multiple process IDs*'
  prefs: []
  type: TYPE_NORMAL
- en: We subsequently quit one of these processes and ran the same command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that this worked and our `vi` process was prioritized by using
    the `-l` flag to `ps` with the process ID specified, shown in [Listing 10-17](ch10.xhtml#ch10ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-17: Confirming the process has been niced appropriately*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to read this super-wide output format from the `ps` command, but notice
    that field 7 is `NI` and that for this process its value is 1 ➊. Check any other
    process you’re running, and you’ll see they’re all priority 0, the standard user
    priority level.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An interesting addendum to this script would be another script that watches
    for any time-critical programs that are launched and automatically renices them
    to a set priority. This could be helpful if certain internet services or applications
    tend to consume a lot of CPU resources, for example. [Listing 10-18](ch10.xhtml#ch10ex18)
    uses `renicename` to map process name to process ID and then checks the process’s
    current nice level. It issues a `renice` if the nice level specified as a command
    argument is higher (a lesser priority) than the current level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-18: The* `*watch_and_nice*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: Within a `cron` job, this script could be used to ensure that certain apps are
    pushed to the desired priority within a few minutes of being launched.
  prefs: []
  type: TYPE_NORMAL
