- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REPRESENTING
    GRAPHS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A *graph* is an abstract data type that can be implemented with a variety of
    data structures. This chapter introduces the fundamental components of a graph,
    nodes and edges, then shows how to build the two most common graph representations:
    adjacency lists and adjacency matrices. Understanding the structure and composition
    of graphs is critical to harnessing their power and designing algorithms to use
    them efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: To implement the graphs, we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    classes upon which almost every algorithm in this book relies. We discuss what
    information the classes store and provide functions for interacting with these
    objects. We also discuss the trade-offs involved in different implementations,
    along with possible alternatives and hybrids.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Graph Structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph consists of two components: nodes and edges. A *node* (also called
    a *vertex*) represents a location or item within the graph. Nodes are often used
    to model concrete entities like people, cities, or computers. *Edges* (also called
    *links* or *arcs*) link together pairs of nodes, defining the relative connections
    within the graph. They are used to represent both concrete items, such as roads
    between cities, and abstract concepts, such as the friendship of two people.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](#fig1-1) shows an example graph with five nodes and seven edges.
    We use the standard graphical representation with nodes as circles and edges as
    lines connecting two circles. Many figures in the book also include a label within
    each circle to identify individual nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Seven lines, representing edges, join pairs of circles.](../images/f01001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: A graph with five
    nodes and seven edges</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To describe graphs in mathematical notation, we use *V* to represent the set
    of nodes and *E* to represent the set of edges. The number of nodes and edges
    are represented using the mathematical notation for the size of a set, meaning
    the number of nodes is |*V* | and the number of edges is |*E*|.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these simple components, we can represent a surprisingly large number
    of real-world systems and answer a range of real-world practical questions. For
    example, graphs allow us to model the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transportation networks **Nodes are cities, and edges represent paths. We
    can compute the shortest path between points or look for single points of failure
    that would cut off one part of the network from another.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mazes **Nodes are intersections, and edges are the halls linking them. We
    can search for paths through the maze.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Educational topics **Each node is a topic, and the edges link two related
    topics. We can sort topics by prerequisite knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Social networks **Nodes are people, and edges are their friendship connections.
    We can model information flow through the network to predict how rumors will travel.'
  prefs: []
  type: TYPE_NORMAL
- en: We can further increase the power of our graphs by allowing the edges to provide
    additional information like directionality and weight, as discussed in the following
    subsections and in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighted Edges</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In almost every real-world transportation network, there is a different *cost*
    for traversing different edges. We might measure this cost in distance or the
    price of gas, for example; either way, it is cheaper to drive from Boston to New
    York than it is to drive from Boston to Los Angeles. Cost measures can also be
    more complicated, such as factoring in the stress of navigating a narrow, winding
    road through the mountains. Alternatively, for some problems, we want to consider
    the inverse of a cost, such as the strength of a connection between nodes or the
    benefit of following a particular edge. Accounting for the edge’s costs or benefits
    is critical in accurately solving many graph problems, such as finding the shortest
    (or least scary) path between two locations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Weighted edges* capture not only the links between nodes but also the costs
    or benefits of traversing those links. For some applications, the weightings are
    obvious and easy to obtain, such as the distance between cities. For example,
    we could assign an edge between Pittsburgh and Cleveland the weighting of 133
    to reflect 133 miles of highway between the two cities. In other contexts, we
    might use weightings to represent more abstract concepts like the strength of
    a friendship. A weighting of 10 for the connection between Tina and Bob could
    indicate that the two are best friends, while a weighting of 1 for Tina’s connection
    with Alice would indicate that they are mere acquaintances. It is usually obvious
    from context whether a weight represents a cost or benefit.'
  prefs: []
  type: TYPE_NORMAL
- en: We call graphs with weighted edges *weighted graphs* and those without such
    edges *unweighted graphs*. We visually represent edge weights as numeric labels
    adjacent to the line representing the edge itself. In [Figure 1-2](#fig1-2), for
    example, three of the edges have weight 1.0, one edge has weight 2.0, and the
    remaining three have weight 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![This graph has five nodes and seven edges. Each edge is labeled with a numerical
    weight. The top two edges have weights 1.0 and 2.0.](../images/f01002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A weighted graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, we can use weighted graphs to model unweighted edges by either
    using a single weight for all edges, such as 1.0, or ignoring the weight attribute
    in our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Directed Edges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some systems, connections between nodes are not symmetric. For example, consider
    the pipe from a building’s water heater to the kitchen faucet. Unless the plumbing
    is very broken, it is not possible for the water to flow into the faucet and back
    to the water heater.
  prefs: []
  type: TYPE_NORMAL
- en: '*Directed edges* indicate such directionality in the connection between two
    nodes. We use terminology that mirrors real-world transportation networks: the
    node from which a directed edge begins is the *origin* or <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>,
    while the node to which the directed edge points is the *destination* or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: While directed edges can represent physical directionality, such as a one-way
    road, we can also use them to model more abstract directionality, such as prerequisite
    courses in an educational institution. If each node is a course, a directed edge
    might indicate that we need to take Introduction to Computer Science before Advanced
    Graph Algorithms, as shown in [Figure 1-3](#fig1-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Two boxes representing course descriptions. The first box is CS100: Introduction
    to Computer Science and has no prerequisites. The second box is CS401: Advanced
    Graph Algorithms with CS100 and CS201 listed as prerequisites. An arrow goes from
    the first box to the second. Two more arrows to CS401 represent the two other
    prerequisites with ellipses.](../images/f01003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: Arrows showing
    the directionality of course prerequisites</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We call graphs with directed edges *directed graphs*. Graphs without directed
    edges (such as those in [Figures 1-1](#fig1-1) and [1-2](#fig1-2)) are known as
    *undirected graphs* with *undirected edges*.
  prefs: []
  type: TYPE_NORMAL
- en: We can use directed edges to extend our earlier social network model. While
    it would be ideal if all friendships were reciprocated, this is sadly not always
    the case. Tina and Bob might call each other best friends. However, while Alice
    considers Tina a dear friend, Tina thinks of Alice simply as an acquaintance from
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](#fig1-4) shows an example graph with directed edges, where each
    directed edge is shown as a single arrow indicating its direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and eight directed edges. Each edge is shown as one
    or two arrows.](../images/f01004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: A directed graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can represent symmetric or undirected relationships between nodes in a directed
    graph by using pairs of directed edges, one in each direction, as shown between
    the bottom two nodes in [Figure 1-4](#fig1-4). This allows us to model systems
    with a mix of directed and undirected relationships. For example, real-world transportation
    networks contain a mix of one-way and two-way roads, and many social networks
    contain mutual friendships. By using a directed graph and corresponding edge pairs,
    we can fully model these systems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Both Weight
    and Direction</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To maximize the representational power of the graph, we can combine the use
    of weighted edges and directed edges, as shown in [Figure 1-5](#fig1-5). This
    representation allows the graph to capture both the directionality and the cost
    versus benefit of each connection.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and eight directed edges. Each edge is shown as one
    or two arrows and each arrow is labeled with a number representing the weight.](../images/f01005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: A directed and
    weighted graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We must specify a separate weight for each directed edge between two nodes,
    but, as with the bottom pair of nodes in [Figure 1-5](#fig1-5), these weights
    need not be equal. When modeling the cost of traversing a road, for example, we
    might choose a much higher cost for the uphill direction than for the downhill
    one. Depending on the application, such as planning a cycling trip, the cost of
    uphill roads might be significantly higher. Similarly, Tina and Alice assign different
    levels of importance to their friendship.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will use graph implementations that support both weighting
    and directionality. If necessary, these data structures can still be used to store
    simpler graphs without weighted or directed edges. While this generality adds
    some small complexity to the data structure and may potentially add overhead to
    algorithms that do not use all the information, this approach results in a flexible
    data structure that can be used by a range of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Adjacency List Representation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graph representation used throughout the majority of this book is the *adjacency
    list representation*, which stores a graph’s structure as a set of individual
    lists of neighbors for each node. This allows us to mirror real-world phenomena
    where each node maintains information on its local connections, such as in a social
    network where individuals maintain contact information for their immediate friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of ways to implement the adjacency list representation.
    Nodes and edges can be represented implicitly through associations or explicitly
    as data structures in their own right. In the simplest implementation, we could
    implicitly store a graph using a single list of lists, where each node has a numeric
    ID and each entry in the list corresponds to a given node’s neighbors. For example,
    consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This list of lists <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> represents
    the undirected, unweighted graph with five nodes and seven edges shown in [Figure
    1-6](#fig1-6). The first entry in the list on the right-hand side of the figure
    indicates that node 0 has three neighbors: nodes 1, 3, and 4\. Each undirected
    edge is represented in two different neighbor lists, one for the node on each
    end.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The left figure shows a graph with seven edges and five nodes given labels
    0 through 4\. Node 0 in the graph is connected to nodes 1, 3, and 4\. The right
    figure shows an array where each element points to a list, indicating that node’s
    neighbors. Element 0 in the array points to a list of the numbers 1, 3, and 4.](../images/f01006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: A graph (left)
    and its adjacency list representation (right)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    data structure that contains not only the adjacency list but also supplementary
    information. This might include a label to identify the node, a Boolean indicating
    whether the node has been processed, or an integer indicating the time at which
    we first saw the node. We could also make the representation more detailed by
    defining an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structure
    with information about directionality and weight, then storing a list of adjacent
    edges within each node.
  prefs: []
  type: TYPE_NORMAL
- en: The optimal representation for any given use case depends highly on the purpose
    of the data structure. For large graphs in limited memory environments, a sparser
    representation like the list of lists in [Figure 1-6](#fig1-6) might be ideal.
    However, when modeling more complex problems, such as directional traffic flows
    over different road conditions, we may need to store more information.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section introduces a highly structured adjacency list representation
    that prioritizes generality and understandability so that we can reuse it throughout
    the different algorithms in this book. We use both <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects to facilitate
    the storage of a variety of auxiliary information for both pieces. Each <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object maintains its own list
    of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects
    that store the information needed to encode weights and directionality.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of this implementation is that each node has a unique *numeric
    index* that indicates its location within the overall <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    data structure. Throughout this book, we will refer to a node and its index relatively
    interchangeably. For example, we refer to the node at index 0 as node 0\. We might
    also say that a function returns a list of nodes visited when the implementation
    returns a list of indices.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see throughout the book, this graph representation lends itself to
    algorithms that traverse the graph node by node, such as the majority of algorithms
    in this book. While this implementation is effective for illustrating a range
    of graph algorithms, the reader may want to use more memory-efficient or computationally
    efficient representations that are better optimized for specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object
    as little more than a container that stores information for directed and weighted
    edges:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s destination
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s origin
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">weight</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the edge’s weight. Where necessary for a particular use case, we’ll use a value
    of 1 to represent unweighted edges
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 1-7](#fig1-7), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    object stores all the information we may need to work with an edge independent
    from other classes. The inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class may seem
    redundant because we are storing the edges in a list at each node and thus can
    retrieve that information from the node. However, explicitly storing this information
    will enable us to use algorithms later in the book that work with sets of edges
    independent of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![A pair of circles joined by an arrow from left to right. The left circle
    is labeled “from_node”; the right circle is labeled “to_node.” The arrow is labeled
    “weight.”](../images/f01007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: The information
    contained in the</samp> <samp class="SANS_TheSansMonoCd_W7Italic">Edge</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the attributes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    class, we define a constructor that copies in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class is
    used primarily for storage, it does not include any additional functions. Attributes
    are accessed directly. We can model undirected edges in the graph by storing a
    pair of directed edges from each node. That is, an undirected edge between nodes
    A and B would materialize as a directed edge from node A to node B and a directed
    edge from node B to node A. While this doubles the number of edges stored in an
    undirected graph, it emphasizes flexibility and allows us to use the same class
    for a range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class illustrates
    how we use the numeric node identifier throughout the code. Instead of storing
    an explicit link to the node, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, we store the
    integer index of the corresponding nodes. When we need to access additional attributes
    within the node, we use these indices to directly look up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object from the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nodes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object
    to both store the information relevant to the node and provide basic operations
    on that information. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object contains the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the numeric index of the node
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp>**) **Stores
    the edges out of the node
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">label</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**,**
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">string</samp>**, or** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">object</samp>**) **An
    optional label used to identify the node or mark its current state
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a list to store the edges, we use a dictionary keyed by the
    destination node’s integer index and with <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    objects as values. This representation allows us to efficiently ask questions
    like “Is there an edge between node A and node B?” without iterating through all
    of node A’s edges.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    object as part of a high school social network. Each student is represented as
    a node with their student ID number as their index. The <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    dictionary represents that student’s personal list of friends. As noted earlier,
    each <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object can be directional
    and weighted to fully capture the complexities of high school alliances and feuds.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> string can be used
    to store information about each student, such as whether they have heard the latest
    rumor.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> classes, we define a
    constructor to set up the initial state of the node, as well as a series of helper
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The constructor sets the integer index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    to the given value. It creates an empty dictionary (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.edges</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    to store future edges and starts with an empty label (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class contains
    a variety of helper functions to facilitate working with it. When implementing
    the graph, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class
    needs to be defined before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class. We also need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    (by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">from typing import Union</samp>
    at the start of the file) to support the optional type hints used in the example
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The first two functions provide access to the node’s edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_edges()</samp>
    function returns the number of edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>
    function returns a given edge, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    if no such edge exists. This allows us to combine lookups and existence checks
    into a single function.
  prefs: []
  type: TYPE_NORMAL
- en: The next two functions modify the node’s connections. The <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    function takes a destination index and weight, then creates and inserts the corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object. It overwrites
    the existing edge if the neighbor’s index already appears in the dictionary, allowing
    us to update edge weights. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    drops an edge from the dictionary if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The final two functions are convenience functions for returning the node’s edges
    as lists. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge_list()</samp>
    returns the edges in their dictionary ordering and is used whenever an algorithm
    needs access to the list. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>
    returns the edges in order of increasing neighbor index and is primarily used
    throughout this book to provide a consistent ordering for examples.
  prefs: []
  type: TYPE_NORMAL
- en: While these functions use dictionaries to store a node’s edges (indexed by the
    destination node), it’s possible to adapt each function to store the node’s edges
    as a list instead. Compact lists of just the outgoing edges prioritize memory
    usage over the time it takes to look up a specific edge. In contrast, to prioritize
    lookup speed for specific edges, each node could store a list of length |*V* |
    with a space for each possible edge and store <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    for edges that do not occur. The dictionary-based approach balances these two
    competing aspects.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Graph Class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class used in
    the majority of this book consists of a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    objects and some utility information that simplifies common computations:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    the graph’s nodes
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether this is a directed or undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> values can be computed
    from the structure of the graph itself but are stored for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: We always store directed edges and use the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    to modify behavior when working with directed and undirected graphs. Most notably,
    as demonstrated later in the section “Accessing, Building, and Modifying the Graph,”
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> to insert
    a pair of directed edges when the graph itself is undirected. Other common implementations
    either use separate functions, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_undirected_edge()</samp>
    function, or create entirely different implementations for directed and undirected
    graphs. Again, we are prioritizing generality of the data structure over pure
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this information, we can create a simple constructor for building a graph
    with a given number of nodes and no edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The constructor initializes the convenience variables, then creates a list of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects. The function
    does not create any edges. Implicit in this implementation is the existence of
    a unique numeric identifier for each node that corresponds to its location in
    the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> list.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class also includes
    a variety of functions to create, search, access, and otherwise process graphs.
    Instead of providing a huge block of code for all graph functions in this section,
    we’ll introduce the general functions throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing, Building, and Modifying
    the Graph</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To facilitate accessing edges, we next define a series of helper functions
    within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    takes an origin index and a destination index and returns the corresponding edge,
    if it exists. It performs basic bounds checking for validity, then uses the origin
    node’s corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp>
    function to retrieve an edge if one exists and return <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    otherwise. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp>
    function simply checks for the existence of any edge with the given origin and
    destination. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp>
    function dynamically constructs and returns a list of all edges in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class’s constructor
    allocates a given number of nodes but does not create any edges. Obviously, this
    does not produce a remotely useful graph. To model any interesting problem, our
    graph needs to include both nodes and edges. We therefore add a few additional
    functions for creating and modifying our adjacency graph representation. First,
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, we provide
    the ability to add and remove edges given the indices of the origin and destination
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions
    follow the same flow: they start by checking that both the origin and destination
    indices correspond to nodes included in the graph ❶ ❸. If the node indices are
    invalid, the functions raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: If the indices are valid, the functions modify the adjacency list of the origin
    node. The insertion function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp>
    function. The removal function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp>
    function. Because we are using a single class to represent both directed and undirected
    graphs, the functions also need to add ❷ or remove ❹ the corresponding inverse
    edge in the case of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these functions together to dynamically create graphs. For example,
    we can use the following code to create a directed graph with five nodes and then
    insert eight weighted edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This generates the graph shown in [Figure 1-8](#fig1-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![a five-node graph with arrows linking the nodes. Each arrow is labeled with
    a number. For example, Node 0 has an arrow to node 1 with weight 1.0, an arrow
    to node 3 with weight 1.0, and an arrow to node 4 with weight 3.0.](../images/f01008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: A directed and
    weighted graph with nodes labeled by their indices</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we provide the ability to pre-allocate nodes in the constructor, for
    some algorithms, we need to insert new nodes as we explore a graph. To facilitate
    this, we also provide a function for inserting new nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> function
    creates a new node and automatically assigns the identification number to the
    next index. The node is then appended to the <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    list, the count of nodes is incremented, and the new node is returned.
  prefs: []
  type: TYPE_NORMAL
- en: While the functions in this section provide the building blocks for constructing
    graphs, it would be tedious to manually specify graphs with a long sequence of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    calls. [Appendix A](appendix_A.xhtml) examines a few sample algorithms that build
    off these initial functions to programmatically create graphs from files or common
    problem specifications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Copying the Graph</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, we also define a helper function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class that produces a new copy of the graph for use with algorithms that modify
    the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_copy()</samp> code starts
    by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> object
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>) with the same number
    of nodes and undirected setting as the current graph. It then uses two nested
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to iterate through
    each node and its outgoing edges. For each node, it copies the label ❶. For each
    edge, it inserts an equivalent edge into <samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the graph will allow us to employ algorithms that destructively modify
    the graph. For example, in [Chapter 16](chapter16.xhtml) we will introduce an
    algorithm for assigning colors that iteratively removes nodes from the graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Adjacency Matrix Representation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another powerful graph representation is the *adjacency matrix*. While we will
    primarily rely on the previous adjacency list representation for most of the algorithms
    in this book, the adjacency matrix representation is important for an entire class
    of mathematically based algorithms. Many algorithms can be described or analyzed
    via matrix operations. We will make use of the matrix formulation in [Chapter
    13](chapter13.xhtml) when considering random walks on graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *adjacency matrix* representation of a graph uses a single matrix to indicate
    the edge weights between each pair of nodes. The value in row *i*, column *j*,
    represents the weight of the edge from node *i* to node *j*. A value of 0 indicates
    that no such edge exists. Represented as a list of lists, the following matrix
    would create an undirected, unweighted graph with five nodes and seven edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to the graph shown in [Figure 1-9](#fig1-9), where node 0’s
    three connections are represented by the corresponding nonzero entries in the
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![The left figure shows a graph with five nodes given labels 0 through 4\.
    Node 0 is connected to nodes 1, 3, and 4\. The right figure shows a 5 × 5 matrix
    filled with values of 0 and 1\. The top row, indicating connections from node
    0 reads 0, 1, 0, 1, 1.](../images/f01009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-9: A graph (left)
    and its adjacency matrix representation (right)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix of connection can use any setting of values. Floating-point entries
    can be used to represent weighted edges. Undirected edges are represented by a
    matching pair of values, making undirected graphs symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: To create and store adjacency graphs, we’ll use the basic <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    class presented in this section. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class, we optimize the representation for understandability rather than computational
    cost or memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> class
    contains three pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">connections</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>
    **of** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores the
    adjacency matrix
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp>**) **Indicates
    whether this is a directed or undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data
    structure, we allow <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    to represent both directed and undirected graphs. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    attribute to specify which type of edges are included. We define a simple constructor
    for building a graph with a given number of nodes and no edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code initializes every entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, creating a graph without
    any edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a getter function to retrieve the weight of a connection between
    two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code checks that both the origin and destination indices are valid. If so,
    the core returns the corresponding floating-point value from the array.
  prefs: []
  type: TYPE_NORMAL
- en: While we store the adjacency matrix in a list of lists to keep this illustration
    simple, it is often preferable to use a representation optimized for matrix operations,
    such as that provided in the popular numpy package. Such numerical packages will
    be faster and provide a range of helper functions. We leave the implementation
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> in numpy
    or a similar mathematical package as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class,
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> object
    pre-allocates all the space to store edge information in the main <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp>
    matrix. We can directly set entries in this matrix to add or remove edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code checks that both the origin and destination indices are valid and,
    if not, raises an error ❶. If the indices are valid, the function sets the matrix
    entry corresponding to this edge ❷. If the graph is undirected, the function modifies
    the symmetric entry in the matrix ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_edge()</samp>
    function to add, remove, or modify edges. We add new edges by setting the entries
    to nonzero weights. If an edge already exists between those two nodes, the function
    updates the weight. We remove edges by setting an entry to 0\. For example, we
    could create the graph in [Figure 1-8](#fig1-8) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]  ### <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The graph structure and its underlying implementations form the foundation of
    all algorithms in this book and drive their development. Deciding which representation
    to use requires us to consider trade-offs in memory usage, computational efficiency,
    and complexity, depending on what makes sense for the task at hand. In cases where
    we want only to iterate over a node’s immediate neighbors, for example, the best
    choice might be an adjacency list representation because we can access the neighbor
    lists independently. In contrast, for algorithms that are more mathematical, we
    might prefer a matrix representation that can make use of existing mathematical
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of introducing the implementations in this chapter is not to provide
    a single canonical approach, but rather to introduce the different ways of thinking
    about graphs and the different trade-offs inherent in their representations. There
    are a huge variety of hybrid approaches or further adaptations we can make to
    the implementations presented in this chapter to optimize a graph representation
    to the problem of interest.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we’ll introduce a series of problems we can solve
    using graphs, building on the concepts and code introduced in this chapter as
    we do so. For each problem, we present a few practical algorithms that can readily
    be applied in real-world situations. We’ll start in the next chapter by introducing
    the concept of neighboring nodes and using algorithms to construct neighborhoods.
  prefs: []
  type: TYPE_NORMAL
