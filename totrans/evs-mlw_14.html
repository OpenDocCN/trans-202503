<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">COVERT CODE EXECUTION AND MISDIRECTION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">Continuing <a href="part3.xhtml">Part III</a>’s discussion of anti-reversing tactics used by malware, in this chapter we’ll look at <i>covert code execution</i>, in which malware executes code in a stealthy manner, frustrating an analyst’s attempts to follow its logic and code and sometimes evading debugging altogether. This can also serve the purpose of misdirecting the analyst, causing confusion and slowing down the reverse engineering process. Let’s explore a few of the specific covert code execution and misdirection techniques you might encounter.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>&#13;
<h3 class="H1" id="sec1"><span id="h-171"/><samp class="SANS_Futura_Std_Bold_B_11">Callback Functions</samp></h3>&#13;
<p class="TNI1"><i>Callback functions</i> are application-defined functions that are triggered by a specific event and are used as input for other functions. For example, the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> uses callback functions to enumerate display monitors that are configured on the host. When <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> is called, monitors are enumerated one by one, and information about each of them (such as screen size) is passed to the callback function. The program defines this callback function and can point it to any code it wishes.</p>&#13;
<p class="TX">Malware can abuse functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> by creating a custom callback and pointing it to malicious code, as illustrated in <a href="chapter11.xhtml#fig11-1">Figure 11-1</a>. This code will then be executed by the calling function (<samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp>), which serves the purposes of obfuscating control flow (as an anti-disassembly and anti-disassembly technique) and even possibly causing the malware analyst to lose control of the malware in a debugger. This method can also confuse some automated sandboxes.</p>&#13;
<figure class="IMG"><img class="img80" id="fig11-1" src="../images/fig11-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A callback function example with EnumDisplayMonitors</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware in this figure calls <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> and defines its own callback function containing malicious code. When <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDisplayMonitors</samp> is called, the control flow transfers to the malicious callback function. Seeing this behavior in a debugger or during static code analysis can be very confusing to a malware analyst who isn’t aware of how callbacks work, as the jump to this callback function may not be apparent in the code.</p>&#13;
<p class="TX">This technique can theoretically work with nearly any Windows API function that uses callbacks (and there are several), but I’ve found that many of the functions that malware may abuse begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">Enum</samp>, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumDateFormatsEx</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumSystemLanguageGroups</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumChildWindows</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-172"/><samp class="SANS_Futura_Std_Bold_B_11">TLS Callbacks</samp></h3>&#13;
<p class="TNI1">As <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> explained, a thread is a series of instructions that operates inside a process. Thread-local storage (TLS) allows each of the program’s running threads to have its own version of a variable that every other thread can access with a unique value. For example, if a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>is defined in TLS, each thread in the process can store a different value in it. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> is acting as a sort of global variable name, but with a unique value for each thread.</p>&#13;
<p class="TX">A TLS callback function allows programs to clear data objects from the TLS. These callback functions run before the actual program code starts, so a malware author can exploit this by crafting special TLS callback functions that execute before the main malware code begins to run. This technique not only can confuse and misdirect analysts who are debugging the malware’s code but also can obfuscate the code’s control flow. Let’s look at a simple example of how to identify and locate TLS callback routines.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To follow along in this section, download the sample from VirusTotal or MalShare using this hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: e4bd2245b1f75abf37abd5a4b58e05f00886d56a5556080c4331847c7266b5b6</p>&#13;
</blockquote>&#13;
<p class="TX">To identify malware that might be using TLS callback functions, you can use one of many static executable analyzer tools, such as PEStudio, my personal favorite. PEStudio has a tab called TLS Callbacks that lists any registered callbacks in the executable file and their addresses. Our malware file in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>, for example, contains two TLS callbacks.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-2" src="../images/fig11-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A TLS callback viewed in PEStudio</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Keep in mind that TLS callbacks were originally designed for benign purposes, so the presence of one doesn’t necessarily mean that the executable is malicious.</p>&#13;
<p class="TX">To better understand how TLS callback functions can confuse and misdirect analysts and to learn how to work with malware that is using them, let’s take a look at this sample in a debugger. I’m using x64dbg, but any similar debugger should work.</p>&#13;
<p class="TX">First, if you spot TLS callbacks in a malware sample (using PEStudio, for example), always make sure that the debugger is configured to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>break on TLS callback functions. Otherwise, the debugger will execute and may not break on the callback function, and you’ll likely never realize it ran. To ensure x64dbg breaks on a TLS callback, click <b>Options</b><span class="MenuArrow"></span><b>Preferences</b><span class="MenuArrow"></span><b>Events</b> and confirm that TLS Callbacks is checked, as shown in <a href="chapter11.xhtml#fig11-3">Figure 11-3</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig11-3" src="../images/fig11-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Enabling breakpoints on TLS callbacks</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After attaching the malware sample to the debugger, you can run the malware sample normally by pressing F9, and the debugger will break on the TLS callback function, as shown in <a href="chapter11.xhtml#fig11-4">Figure 11-4</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-4" src="../images/fig11-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: Hitting the TLS breakpoint</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The debugger is now paused on the TLS callback function address, which will likely be the entry into the malicious code that the malware wishes to covertly execute, as shown in <a href="chapter11.xhtml#fig11-5">Figure 11-5</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-5" src="../images/fig11-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: TLS callback code</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note that TLS callbacks aren’t always so clearly registered and displayed in static analysis tools. TLS entries are stored in the Thread Environment Block (TEB), a data structure that stores information about the currently running thread (see <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> for a refresher on it). Malware could modify its own TEB at runtime, possibly manipulating the TLS callbacks and adding or removing callbacks dynamically. In doing so, malware authors could <span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>hide their TLS callbacks so that they execute even more covertly and evade analysis tools.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-173"/><samp class="SANS_Futura_Std_Bold_B_11">Structured Exception Handling</samp></h3>&#13;
<p class="TNI1">As its name suggests, the <i>structured exception handler (SEH)</i> is how Windows applications handle exceptions. Whenever a Windows program runs into an exception, it invokes SEH. Developers can choose to execute certain code if an exception occurs in their program by implementing an SEH <i>record</i>. For example, if the program throws an error because it’s missing a certain required file, the developer might instruct it to display a pop-up box with the message, “The required file does not exist!” This instruction often appears in the form of a <samp class="SANS_TheSansMonoCd_W5Regular_11">try... catch</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">try... except</samp> sequence. The program will <i>try</i> to execute some code, and if the code fails for some reason, the <i>catch</i> (exception) will be executed.</p>&#13;
<p class="TX">SEH consists of multiple records that are stored on the program’s stack. Each record in turn is composed of two addresses: the first is a pointer to the function responsible for handling the exception (that is, the <i>exception handler</i>), and the second is a pointer to the previously defined SEH record, which creates a chain of SEH records (typically called a <i>linked list</i> in Windows).</p>&#13;
<p class="TX">The address of the exception handler is stored in the special CPU register FS (GS for 64-bit applications), which points to the TEB. In the TEB structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp> contains the current SEH frame, which points to the first SEH record on the stack. <a href="chapter11.xhtml#fig11-6">Figure 11-6</a> illustrates this structure.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-6" src="../images/fig11-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: An SEH linked-list chain</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice that the FS register points to the address of the TEB, which in turn contains a pointer to the first SEH record on the stack. The SEH record contains an address for the next SEH record in the chain, as well as an address for the exception handler (the code that will be executed when the exception is triggered).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>When a program adds a new SEH record to the SEH chain on the stack, it must first push the address of the new handler to the stack and then push the address of the previous handler to the stack. This looks like the following code:</p>&#13;
<pre class="pre-92"><code><var>--snip--</var>&#13;
push HandlerAddress ; Address of new handler&#13;
push fs:[0]         ; Address of old handler&#13;
mov fs:[0], esp&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">After pushing the new and previous handler addresses to the stack, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov fs:[0], esp</samp> sets up the new handler. Once a new exception occurs in the program, <samp class="SANS_TheSansMonoCd_W5Regular_11">HandlerAddress</samp> will be the “first responder” to the exception.</p>&#13;
<p class="TX">Just as many benign Windows features can be repurposed for malicious uses, SEH chains can be abused to obfuscate the malware’s control flow and misdirect the analysts debugging the code. Let’s take a look at this in practice.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To follow along, download the sample from VirusTotal or MalShare using this hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: d52f0647e519edcea013530a23e9e5bf871cf3bd8acb30e5c870ccc8c7b89a09</p>&#13;
<p class="NoteContinued1"><i>You’ll also need a debugger such as x64dbg.</i></p>&#13;
<p class="NoteContinued"><i>Keep in mind that this sample is a ransomware variant, so be sure to take precautions. You might consider using some of the tips discussed in <a href="appendix-A.xhtml">Appendix A</a>.</i></p>&#13;
</blockquote>&#13;
<p class="TX">First, rename the file with the <i>.exe</i> extension (such as <i>evil.exe</i>) and open it in x64dbg. (It’s a 32-bit file, so you’ll need to open the file in the 32-bit version.) The executable will be paused at this point. Select <b>Debug</b><span class="MenuArrow"></span><b>Run to User Code</b> to skip to the beginning of the malware’s code. You should now be at the malware’s entry point, as shown in <a href="chapter11.xhtml#fig11-7">Figure 11-7</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-7" src="../images/fig11-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: The malware’s entry point in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The following lines of code will be executed by the malware; note that the addresses may be different in your running sample, but the code should be similar:</p>&#13;
<pre class="pre-94"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>mov  eax, evil.429D8C&#13;
push eax&#13;
push dword ptr fs:[0]&#13;
mov  dword ptr fs:[0],esp&#13;
xor  eax,eax&#13;
mov  dword ptr ds:[eax],ecx</code></pre>&#13;
<p class="TX">First, the malware moves the address <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.429D8C</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> and pushes it to the stack. This address contains the malicious code that will be executed by the exception handler. Next, the malware pushes the current value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp> to the stack, which points to the topmost SEH record. Then, the malware moves the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">esp</samp> (the stack pointer) to <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>, which effectively adds the address of the new handler.</p>&#13;
<p class="TX">To trigger the exception handler and stealthily execute its code, the malware must force an exception. To do this, the malware clears the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register using <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> and then executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction that attempts to move the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> into the address stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. Because the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> is currently <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_ACCESS_VIOLATION</samp> error in x64dbg (shown in <a href="chapter11.xhtml#fig11-8">Figure 11-8</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-8" src="../images/fig11-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: An exception forced by the malware</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The control flow is transferred to the handler containing the malicious code, as shown in <a href="chapter11.xhtml#fig11-9">Figure 11-9</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-9" src="../images/fig11-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-9: Transfer of the control flow to the handler containing malicious code</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Unless we explicitly tell the debugger to break at this handler code, however, the code will be executed too quickly for us to inspect it. To address this issue, we’ll set a breakpoint on this handler code by using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">bp 00429D8C</samp> in the debugger. Now, if we continue executing the sample, we’ll break on the malicious handler code, as shown in <a href="chapter11.xhtml#fig11-9">Figure 11-9</a>. If you’re already past this point in the debugger, you may need to terminate the sample and rerun it, being sure to set the breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">00429D8C</samp>.</p>&#13;
<p class="TX">Had we not known that the malware was using this SEH abuse technique and had we not closely inspected the code, we likely would have completely missed this code execution. Since many disassemblers may not be SEH aware, we also would not have seen this jump when performing static code analysis.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/>Also, rather than directly altering the SEH chain, malware can abuse SEH by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">KiUserExceptionDispatcher</samp> function, which takes an exception handler address as a parameter. Malware can pass an arbitrary address to this function, adding a new handler to the current SEH chain. Then, by forcing an exception as just described, the malware can covertly execute malicious code.</p>&#13;
<p class="TX">When you’re analyzing malware that uses the techniques discussed here, it helps to monitor the SEH chain. There are two ways to do this. In x64dbg, you’ll see an SEH tab that lists the SEH chain. In my experience, however, this feature isn’t always reliable. The better option is to add a <i>watch</i> for <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp> modifications. This way, you’ll be alerted when malware manipulates the data stored in a register or address such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp>. To do this in x64dbg, navigate to the <b>Watch</b> tab underneath the CPU window, right-click and select <b>Add</b>, and then type <samp class="SANS_TheSansMonoCd_W7Bold_B_11">fs:[0]</samp> (see <a href="chapter11.xhtml#fig11-10">Figure 11-10</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-10" src="../images/fig11-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-10: Adding a watch expression in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once you’ve added the watch, right-click it and select <b>Changed</b> on the menu. This will pause the program every time the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:[0]</samp> changes, as shown in <a href="chapter11.xhtml#fig11-11">Figure 11-11</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig11-11" src="../images/fig11-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-11: Triggering a watch expression</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-174"/><samp class="SANS_Futura_Std_Bold_B_11">VEH and 64-Bit SEH</samp></h3>&#13;
<p class="TNI1">Another important exception-handling mechanism in Windows is <i>vectored exception handling (VEH)</i>, an extension to SEH for Windows x86 applications. VEH is sometimes used alongside SEH in 32-bit Windows applications but takes precedence over it; that is, if an exception is triggered in the application, VEH will attempt to handle it before SEH does.</p>&#13;
<p class="TX">Like SEH, VEH can be abused by malware. For example, malware can call the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">AddVectoredExceptionHandler</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlAddVectoredExceptionHandler</samp>, both of which will register a new VEH record. These functions accept a parameter called <samp class="SANS_TheSansMonoCd_W5Regular_11">PVECTORED_EXCEPTION_HANDLER</samp>, which represents the function that will be called once the exception occurs. The malware can then purposefully trigger an exception, in which case VEH will be triggered and the malicious code will be executed. If you happen to spot malware calling these functions, it’s worth taking a deeper look to see if it’s abusing VEH to covertly execute code.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>In x64 applications, SEH (sometimes called <i>x64 SEH</i>) is implemented as a table that is stored in the executable’s PE header. This table contains descriptions for all of the program’s exception handling. Furthermore, x64 SEH uses a technique known as <i>stack unwinding</i>, which is executed in kernel mode and involves popping addresses off the stack to resume execution at another address on the stack. Stack unwinding is beyond the scope of this book, but exploits are uncommon since the x64 SEH table is stored in the file header, making it difficult to tamper with the SEH chains, and because the stack unwinding takes place in kernel mode, whereas most malware runs in user mode. It’s also important to note that VEH can be implemented in 64-bit applications, so the VEH abuse scenario applies for x64-bit malware as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-175"/><samp class="SANS_Futura_Std_Bold_B_11">Hidden Threads</samp></h3>&#13;
<p class="TNI1">The Windows API exposes a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> that can be used to set the priority of a thread. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> has a parameter called <samp class="SANS_TheSansMonoCd_W5Regular_11">THREADINFOCLASS</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadInformationClass</samp>, which points to a structure that may contain several values, one of which is particularly interesting: <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadHideFromDebugger</samp>. If this value is set, the code thread will no longer send debug events to the debugger, meaning the code will be essentially flying under the radar. This presents an opportunity for malware to bypass any debuggers that an analyst may have attached and to covertly execute its code. The simplest way to overcome this technique is to look for calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> and set breakpoints on them. Once a breakpoint is hit, modify the parameters to the function or simply patch the function call out of the code.</p>&#13;
<p class="TX">A similar evasion technique involves the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> function, which has a special flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER</samp>, that can be set to hide the newly created thread from the debugger. As you might guess, this can cause problems for malware analysts, as the code will be executed outside the immediate scope of the debugger. Be on the lookout for malware invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">THREAD_CREATE_FLAGS _HIDE_FROM_DEBUGGER</samp> flag (0x4 in hex) enabled.</p>&#13;
<aside class="box" aria-label="box-9">&#13;
<p class="BoxTitle" id="box-9"><samp class="SANS_Dogma_OT_Bold_B_11">PROCESS INJECTION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">One final covert code execution and misdirection technique worth mentioning is</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process injection</samp><samp class="SANS_Futura_Std_Book_11">, which allows malware to write (or “inject”) code into the calling process or a remote process and run the code in that process’s context. This can cause headaches for a malware analyst attempting to follow a malware sample’s execution in a sandbox or investigating its code in a debugger. Since process injection can also be used for evading host defenses and during unpacking, we’ll cover it more thoroughly in <a href="chapter12.xhtml">Chapters 12</a> and <a href="chapter17.xhtml">17</a>.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>&#13;
<h3 class="H1" id="sec6"><span id="h-176"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, you learned about several ways in which malware can execute code while flying completely under the radar of analysis tools like debuggers. You also saw how malware can use callback functions to obfuscate its control flow while stealthily executing its malicious code. These techniques abuse underlying and otherwise legitimate Windows functions, and even though some are many years old, they’re still seen in the wild. In the next chapter, we’ll explore a few additional techniques that malware authors may use to covertly execute code and accomplish other evil things: process injection, manipulation, and hooking.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>