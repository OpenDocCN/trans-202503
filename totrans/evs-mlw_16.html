<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PROCESS INJECTION, MANIPULATION, AND HOOKING</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">To blend in with their target environment, modern evasive threats must remain hidden on the infected host. Two methods they use to do so are process injection and process image manipulation. <i>Process injection</i> involves injecting and executing nefarious code inside another process rather than executing it directly, while <i>process image manipulation</i> involves tampering with process images and abusing the way Windows handles processes. Malware can also use process injection techniques to inject hooks into a target process. Hooking allows the malware to intercept API function calls and monitor or manipulate them, helping it remain undetected.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>We’ll begin this chapter by looking at different forms of process injection. Then, we’ll discuss two close cousins of the technique (process image manipulation and DLL and shim hijacking) along with various hooking methods. At the end of the chapter, we’ll briefly explore how to mitigate these types of attacks.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-177"/><samp class="SANS_Futura_Std_Bold_B_11">Process Injection</samp></h3>&#13;
<p class="TNI1">There are several reasons why malware might want to implement process injection techniques:</p>&#13;
<p class="ListHead"><b>Hiding from defenses and investigators</b></p>&#13;
<p class="ListPlainFirst">Injecting code into another process, particularly a well-known one like <i>notepad.exe</i> or <i>explorer.exe</i>, may help the malware persist on the infected host, hidden from endpoint defenses and investigators.</p>&#13;
<p class="ListHead"><b>Mimicking normal behavior</b></p>&#13;
<p class="ListPlainFirst">Malware might inject code into certain processes to disguise its behavior. For example, injecting code into a web browser and communicating with a C2 server from this process can help hide suspicious web traffic, as it’s normal and expected for web browsers to communicate with the internet.</p>&#13;
<p class="ListHead"><b>Thwarting debugging efforts</b></p>&#13;
<p class="ListPlainFirst">Injecting code into a remote process can help circumvent and evade tools like debuggers, causing the analyst to lose control of the malware’s code execution flow.</p>&#13;
<p class="ListHead"><b>Elevating privileges</b></p>&#13;
<p class="ListPlainFirst">Specific types of process injection techniques can help malware elevate its privileges on the infected host, giving it a higher level of access within the system.</p>&#13;
<p class="ListHead"><b>Intercepting data via hooking</b></p>&#13;
<p class="ListPlainFirst">Injecting hooking code into a process can allow the malware to intercept and modify Windows API calls or intercept sensitive data.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">Let’s examine various process injection techniques in more detail, starting with how malware identifies a target process for injection.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-178"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Random vs. Specific Target Processes</samp></h4>&#13;
<p class="TNI1">Malware can inject code into either a random process or a specifically chosen target, depending on what it’s trying to achieve. For example, some malware injects malicious code into multiple arbitrary processes on the host to ensure its own survival. The malware could simply enumerate all processes on the host using <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> and then attempt to open and get a handle to the target process using <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>. If it successfully opens the target process with its current privilege levels, the malware injects its code there. This approach isn’t very stealthy, however. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>A more covert approach is to inject code into specific target processes, such as well-known and common Windows processes, or into processes that allow the malware to achieve a certain objective. Certain variants of the malware family Formbook, for example, inject code into browser-related processes, attempting to sniff out sensitive data such as web logins.</p>&#13;
<p class="TX">Some malware might even inject code into its own process (a technique known as <i>self-injection</i>) or into a child process that it creates. These types of injection techniques often take place during the <i>unpacking</i> process, in which malware decrypts, or unpacks, its payload in memory and then injects it into a child process. <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span> will discuss unpacking in more detail. For now, let’s look at one of the most basic and prevalent forms of process injection: shellcode injection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-179"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode Injection</samp></h4>&#13;
<p class="TNI1"><i>Shellcode injection</i>, also known as <i>direct injection</i>, is one of the oldest injection techniques; as its name suggests, it involves injecting <i>shellcode</i>, a type of position-independent machine code. Once the shellcode has been injected, the malware can remain hidden while executing its malicious code directly from within the victim process’s memory. <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> illustrates how it works.</p>&#13;
<figure class="IMG"><img class="img80" id="fig12-1" src="../images/fig12-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: The shellcode injection technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To inject the shellcode, first the malware must open an object handle to the target process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> (or by directly calling its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> function has a couple of important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> parameter represents the access rights requested by the calling process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp> is the ID of the target process. You can reference the function prototype information for <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> like so:</p>&#13;
<pre class="pre-95"><code>OpenProcess(&#13;
  DWORD dwDesiredAccess, // Access rights requested.&#13;
  BOOL bInheritHandle,   // If true, processes created by this process inherit this process's handle.&#13;
  DWORD dwProcessId      // Process ID of the target process&#13;
);</code></pre>&#13;
<p class="TX">Once the malware has obtained an object handle to the target process, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate memory in the target process for injecting its shellcode. (Alternatively, it could call the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function.) The most relevant parameters for the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/><samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> function are <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>, which represent the starting address and the size of the region of memory being allocated, respectively. The prototype information for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> function is as follows:</p>&#13;
<pre class="pre-96"><code>VirtualAlloc(&#13;
  LPVOID lpAddress,       // Start address of region of memory to be allocated&#13;
  SIZE_T dwSize,          // Size of memory allocation&#13;
  DWORD flAllocationType, // Memory type to be allocated&#13;
  DWORD flProtect         // Memory protection to be assigned to this region&#13;
);</code></pre>&#13;
<p class="TX">After allocation, the malware writes the malicious code into this fresh memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> (or its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>). <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> takes some important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>, the handle of the process being written into; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>, a pointer to the base address where the data will be written; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>, a pointer to a memory location that contains the data to be written; and <samp class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>, the number of bytes to be written into the target process’s memory. Here is the prototype information for the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function:</p>&#13;
<pre class="pre-97"><code>WriteProcessMemory(&#13;
  HANDLE hProcess,              // Handle of process being written to&#13;
  LPVOID lpBaseAddress,         // Base address where data will be written&#13;
  LPCVOID lpBuffer,             // Contains the data to be written&#13;
  SIZE_T nSize,                 // Size of data to be written&#13;
  SIZE_T lpNumberOfBytesWritten // Optional parameter; pointer to a variable that receives&#13;
                  the number of bytes that were written&#13;
);</code></pre>&#13;
<p class="TX">Finally, after writing the malicious code into its target process, the malware is ready to execute it within the process context. To do so, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> (alternatively, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>) to create a remote thread within the process context and execute it. The most important parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>, a handle to the target process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>, the starting address of the code to be executed. The function prototype for <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is as follows:</p>&#13;
<pre class="pre-98"><code>CreateRemoteThread(&#13;
  HANDLE hProcess,                          // Handle to the process in which to create the&#13;
                        thread&#13;
  LPSECURITY_ATTRIBUTES lpThreadAttributes, // Pointer to a security attributes structure;&#13;
                        pertains to security and access control&#13;
  SIZE_T dwStackSize,                       // Initial size of the stack for the new thread&#13;
  LPTHREAD_START_ROUTINE lpStartAddress,    // Starting address of the new thread&#13;
  LPVOID lpParameter,                       // Pointer to a variable that will be passed to&#13;
                        the thread's function&#13;
  DWORD dwCreationFlags,                    // Creation flags for the thread (such as&#13;
                        CREATE_SUSPENDED)&#13;
  LPDWORD lpThreadId                        // Pointer to a variable that receives the new&#13;
                        Thread ID&#13;
);</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/>Note that this is only one of the many methods of shellcode injection and execution. The flow of this technique and the functions being called (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, and so on) are the basic building blocks of several techniques we’ll touch on in this chapter. Keep in mind as well that many of the functions listed in this chapter are interchangeable with other functions. For example, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, malware might call the native API <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>. Instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>, it could invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>.</p>&#13;
<p class="TX">To trace process injection, I like to use API Monitor, which allows you to quickly see the way the malware is injecting code and even extract the injected code. You can also use it to inspect the parameters of each function call in an easy-to-read format.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In the next section, I’ll be using a malware executable that you can download from VirusTotal or MalShare using the following file hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625</p>&#13;
</blockquote>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-2">Figure 12-2</a> shows the result of loading the malware sample in API Monitor and filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> functions.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-2" src="../images/fig12-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Shellcode injection captured in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see, this sample begins by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> (with the <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp> permission and several other access permissions), then makes multiple calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate memory in the target process. The malware then writes code into that process using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> and executes it by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.</p>&#13;
<p class="TX">If you inspect the buffer for the third call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, you can see that the malware is writing what looks like shellcode into the target process (see <a href="chapter12.xhtml#fig12-3">Figure 12-3</a>).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>It takes some practice, but you can identify shellcode by inspecting the data and looking for bytes that represent common assembly instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b ec</samp> (which translates to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp, esp</samp>). Refer back to <a href="chapter3.xhtml">Chapter 3</a> for additional assembly instructions.</i></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>&#13;
<figure class="IMG"><img class="img100" id="fig12-3" src="../images/fig12-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: Shellcode injected into a target process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To verify that it’s shellcode, save the data (click the Save icon in the upper-left corner of the hex buffer window) and then view it in a disassembler. You should see the following:</p>&#13;
<pre class="pre-99"><code><var>--snip--</var>&#13;
push ebp&#13;
mov  ebp, esp&#13;
add  esp, 0FFFFFFF4h&#13;
mov  eax, [ebp+8]&#13;
mov  edx, [eax]&#13;
mov  [ebp-0Ch], edx&#13;
mov  edx, [eax+4]&#13;
mov  [ebp-8], edx&#13;
mov  edx, [eax+8]&#13;
mov  [ebp-4], edx&#13;
push dword ptr [ebp-8]&#13;
call dword ptr [ebp-0Ch]&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Because this data cleanly converts to assembly code, this indeed appears to be shellcode. I won’t go into this code in more detail here, but if I were analyzing this malware sample, I would try to understand this code’s purpose by investigating it further in the disassembler and then investigating it dynamically in a debugger. Note that in some circumstances, the disassembler may incorrectly recognize this as data instead of code. (Refer back to the <span class="Xref">“Disassembly”</span> box on <span class="Xref"><a href="chapter3.xhtml#pg_51">page 51</a></span> for a refresher on the code vs. data problem.) You might have to “force” the disassembler to read it as code.</p>&#13;
<p class="TX">Before we move on, there’s something else injected into the target process worth noting. If you inspect the buffer for the first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, you’ll see a reference to <i>kernel32.dll</i> (see <a href="chapter12.xhtml#fig12-4">Figure 12-4</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-4" src="../images/fig12-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The string KERNEL32.DLL written into memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This indicates that the sample could also be using another process injection technique, DLL injection, which we’ll take a look at now.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>&#13;
<h4 class="H2" id="sec4"><span id="h-180"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL Injection</samp></h4>&#13;
<p class="TNI1">While DLL injection is another common form of process injection, don’t be misled by its name. In this type of attack, the malware doesn’t physically inject a DLL into a target process; instead, it writes <i>the path</i> to a malicious DLL file located on disk into the target process and then forces the target process to load and execute that DLL on its behalf. <a href="chapter12.xhtml#fig12-5">Figure 12-5</a> illustrates this technique.</p>&#13;
<figure class="IMG"><img class="img80" id="fig12-5" src="../images/fig12-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The DLL injection technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware first drops a malicious DLL file to disk. Then, as in shellcode injection, it invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> to get a handle to its chosen target process and uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate memory within that process. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> to write the location of that DLL file into the process. Finally, to make the victim process load its DLL, the malware gets the procedural address of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> parameter set to that address. Once the remote thread executes, the target process calls <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and, in doing so, loads the malicious DLL. Here’s how this looks in pseudocode:</p>&#13;
<pre class="pre-100"><code>WriteProcessMemory(victimProcess, <var>lpBaseAddress</var>, maliciousDllName, <var>nSize</var>,&#13;
<var>lpNumberOfBytesWritten</var>);&#13;
hModule = GetModuleHandle("Kernel32.dll");&#13;
GetProcAddress(<var>hModule</var>, "LoadLibraryA");&#13;
CreateRemoteThread(victimProcess, <var>lpThreadAttributes</var>, <var>dwStackSize</var>,&#13;
addressOfLoadLibraryA, maliciousDllName, <var>dwCreationFlags</var>, <var>lpThreadId</var>);</code></pre>&#13;
<p class="TX">This malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> to write the malicious DLL path, <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>, into the target process, <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>. Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, to get the procedural address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> function. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>, passing the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> and the path to the malicious DLL as parameters. This forces the victim process to load the malicious DLL and execute the code within a new thread.</p>&#13;
<p class="TX">One problem with traditional DLL injection for malware authors is that the DLL must be loaded from disk, using the standard Windows library <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>loading procedures. These standard loading procedures are monitored and easily spotted by endpoint defenses. A stealthier approach to DLL injection is reflective DLL injection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-181"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reflective DLL Injection</samp></h4>&#13;
<p class="TNI1">In <i>reflective</i> DLL injection, the DLL is stored in memory rather than on disk, and the malware loads it without having to rely on the standard Windows loading mechanism. This makes reflective DLL injection a more covert alternative to the standard DLL injection method just described.</p>&#13;
<p class="TX">The initial steps of reflective DLL injection are fairly similar to the standard DLL injection. The malware obtains a handle to its victim process using <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> and allocates memory in that process using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. However, instead of writing only the path to the DLL file, the malware copies the entire malicious DLL to the target process’s memory. Then, it transfers control flow to the newly injected DLL (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>, for example), which executes the injected DLL’s “bootstrap” loader code.</p>&#13;
<p class="TX">This bootstrap code is custom code that must re-create the normal Windows DLL loading process. At a high level, these are the steps:</p>&#13;
<p class="ListNumber1">  1.  The bootstrap code calculates its own image location in memory and performs its own image base relocations, which means realigning the hardcoded addresses in the executable code to match its current location in memory. The loader also finds the location of the injected DLL’s PEB.</p>&#13;
<p class="ListNumber">  2.  The bootstrap code parses the exports table of <i>kernel32.dll</i> to locate the addresses of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and other fundamental functions.</p>&#13;
<p class="ListNumber2">  3.  The malicious DLL has now been successfully loaded inside the victim process and is ready to run. To execute the DLL’s malicious code, malware typically invokes a function in the DLL’s exports table, such as the function shown in <a href="chapter12.xhtml#fig12-6">Figure 12-6</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-6" src="../images/fig12-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The DLL export function</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The malware shown here was generated with the popular penetration testing tool Cobalt Strike and has <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp> as the default export function. Once this export function is invoked, the malicious code is executed.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-7">Figure 12-7</a> illustrates a typical reflective DLL injection attack.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/>&#13;
<figure class="IMG"><img class="img80" id="fig12-7" src="../images/fig12-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The reflective DLL injection technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this figure, the running malware downloads its DLL payload from a staging server controlled by the attacker <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is then temporarily stored in the malware’s process memory space <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (Note that this technique does not always rely on a remote staging server, but we’ll touch on that in a moment.) Next, the bootstrap code is injected into a target process along with the DLL <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then executed by the malware. The bootstrap code performs the manual DLL loading process and then calls the export function of the injected DLL, which executes the malicious code in the context of the target process <span class="CodeAnnotation" aria-label="annotation4">❹</span>. You can read more about reflective DLL injection from the original author of the technique at <a href="https://github.com/stephenfewer/ReflectiveDLLInjection"><i>https://<wbr/>github<wbr/>.com<wbr/>/stephenfewer<wbr/>/ReflectiveDLLInjection</i></a>.</p>&#13;
<p class="TX">Reflective DLL injection, as with many of the injection methods I discuss throughout this chapter, can be subdivided into so-called staged and stageless techniques. The technique just presented is considered <i>staged</i>, as the payload to be injected is hosted and downloaded from the attacker’s staging server. In <i>stageless</i> reflective DLL injection, the payload is already embedded in the original malware executable before being unpacked and injected into the target process.</p>&#13;
<p class="TX">A similar technique, sometimes called <i>shellcode reflective injection</i>, involves converting a DLL into shellcode and then injecting it into a target process. I won’t cover this technique further since it combines techniques you’ve already seen, but you can read more about it at <a href="https://github.com/monoxgas/sRDI"><i>https://<wbr/>github<wbr/>.com<wbr/>/monoxgas<wbr/>/sRDI</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Hollowing</samp></h4>&#13;
<p class="TNI1"><i>Process hollowing</i> (sometimes called <i>RunPE</i>, <i>process replacement</i>, or <i>hollowed process injection</i>) involves unmapping code from a target process’s memory and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>then remapping malicious code there. Process hollowing is a bit different from the other injection techniques we’ve seen so far, as it doesn’t usually involve an arbitrary remote process. Instead, the malware starts a new process (often a trusted executable, such as our beloved <i>Calculator.exe</i>), unmaps the legitimate code, and remaps malicious code in a suspended state, at which point the malware executes the malicious code. This hides the malicious code from the prying eyes of endpoint defenses and investigators, disguising it as a normal process. <a href="chapter12.xhtml#fig12-8">Figure 12-8</a> illustrates the technique.</p>&#13;
<figure class="IMG"><img class="img80" id="fig12-8" src="../images/fig12-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The process-hollowing technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This malware sample begins by creating a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> and then sets the process creation flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp> (not shown); this starts the new process in a suspended state. Next, the malware “hollows out” the newly created process by unmapping its legitimate code with the function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>. Then, the malware allocates a new region of memory for its malicious code using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and writes (maps) its payload here using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> to point the current thread to the newly injected code and resume thread execution, respectively, which runs the malicious code.</p>&#13;
<p class="TX">Let’s take a look at this in practice, using a variant of the ransomware family Satan (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: cbbd2bd6f98bd819f3860dea78f812d5c180fd19924cef32e94B d7f6929023779</samp>). The screen capture from API Monitor in <a href="chapter12.xhtml#fig12-9">Figure 12-9</a> shows a malware sample (a variant of the Satan ransomware family) using the process-hollowing technique.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-9" src="../images/fig12-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: A malware sample using the process-hollowing technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>Notice how this malware starts a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp> from an executable on disk (<i>financialz.exe</i>) in a suspended state (<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>), as just discussed. Then, it makes multiple calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp> to map data into the new target process. Inspecting this function call further in API Monitor reveals that this malware sample is writing a PE file into the target process, then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp> to execute it (see <a href="chapter12.xhtml#fig12-10">Figure 12-10</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-10" src="../images/fig12-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: The PE header in memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note that while process hollowing is typically classified as a process injection technique, it’s not a true injection technique, since it relies on the malware spawning a new process in a suspended state and then replacing the process’s preexisting code with malicious code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-183"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Hijacking</samp></h4>&#13;
<p class="TNI1"><i>Thread hijacking</i> involves opening a running thread in a victim process, writing malicious code into that thread, and forcing the victim process to execute the code. Thread hijacking shares many of the functions used in the process-hollowing technique, but there are a few notable differences. To execute thread hijacking, the malware invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp> function, specifying a thread ID as a parameter, and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp> for 64-bit processes) to suspend the victim thread. Once the thread is in a suspended state, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, respectively, to allocate memory in the target process and write its malicious code there. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp> to transfer control flow from the currently suspended thread to the newly injected malicious code, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> to execute the code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-184"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC Injection</samp></h4>&#13;
<p class="TNI1">An <i>asynchronous procedure call (APC)</i> is a Windows feature that allows for various tasks to be queued and executed in the context of a running thread. A program might invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp> function, passing both the handle to the thread and a pointer to the code that the program wishes to run, to add that task to the APC queue. <i>APC injection</i> abuses this functionality to stealthily execute code and, potentially, elevate privileges.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>For a program to be able to call functions in the APC queue, the thread must be in an <i>alertable</i> state, meaning the thread periodically checks for new items in the queue and runs the next queued task. Many processes running on the system, from web browsers to video players, have threads running in alertable states. Generally, such threads eventually receive an interrupt request from the operating system, at which point the process will inspect the APC queue and run the next queued task.</p>&#13;
<p class="TX">Malware takes advantage of APC functionality by attempting to inject malicious code into other processes via APC queuing. <a href="chapter12.xhtml#fig12-11">Figure 12-11</a> illustrates this attack.</p>&#13;
<figure class="IMG"><img class="img80" id="fig12-11" src="../images/fig12-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: The APC injection technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This malware first gets a handle to its target victim process in the usual way (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>) and writes the malicious code to be executed into the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>). Next, it opens a target thread by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) to queue a new APC task. Whenever the thread receives an interrupt request from the operating system, this malicious code will be executed.</p>&#13;
<p class="TX">A variation of this technique creates a new process in a suspended state (similar to process hollowing) and writes the malicious code into it. Then, the malware queues its APC function and resumes the thread. Once the thread resumes, the malicious code will be executed. At this point, the malware can terminate its original process, as its payload is now running under a new process and may go unnoticed by endpoint defenses and unaware end users. <a href="chapter12.xhtml#fig12-12">Figure 12-12</a> shows this attack, captured in API Monitor.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-12" src="../images/fig12-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Malware using a variation of the APC injection technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This malware sample uses APC injection to run malicious code in the context of the <i>iexplore.exe</i> process. In this case, the malware starts <i>iexplore.exe</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>) instead of hijacking another process (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>&#13;
<h4 class="H2" id="sec9"><span id="h-185"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Atom Bombing</samp></h4>&#13;
<p class="TNI1">The last process injection technique we’ll cover in this chapter is <i>atom bombing</i>, which shares some features of APC injection but involves <i>atoms</i>, references to specific pieces of data such as strings. Atoms are stored in an OS structure known as the <i>atom table</i>, and each atom has a unique atom identifier. Atoms are often used in interprocess communication to coordinate actions between processes. For example, Process A might create an atom to indicate that a particular piece of data is available, and Process B can use that atom to access the data.</p>&#13;
<p class="TX">Atom tables can be global (that is, accessible from any process running on the system) or local (accessible to only one specific process). To add data to the global atom table, an application invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp> function; to add an atom to a local table, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddAtom</samp> function. Atom bombing abuses these atom tables to temporarily store malicious code. <a href="chapter12.xhtml#fig12-13">Figure 12-13</a> illustrates this attack.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-13" src="../images/fig12-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: The atom bombing technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At a high level, this technique creates a new global atom (<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>) in the global atom table, where it stores malicious shellcode <span class="CodeAnnotation" aria-label="annotation1">❶</span> and uses APC queuing (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) <span class="CodeAnnotation" aria-label="annotation2">❷</span> to force the victim process into executing <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Once the atom is retrieved by the victim process, the shellcode stored in the atom table can be run in that process’s context <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-186"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection Wrap-up</samp></h4>&#13;
<p class="TNI1">As you’ve seen, many process injection techniques use the same API function calls and behave similarly. Nearly all process injection techniques create a process or open a handle to a target process, allocate memory and write or map code into the target process, and then force the injected code to execute in the context of the target process, as summarized in <a href="chapter12.xhtml#fig12-14">Figure 12-14</a>. (Special thanks to malware researcher Karsten Hahn, who inspired this image.)</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>&#13;
<figure class="IMG"><img class="img100" id="fig12-14" src="../images/fig12-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: A summary of process injection behaviors and API calls</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that we’ve looked at various process injection techniques, let’s pivot to another method used for similar purposes: process image manipulation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-187"/><samp class="SANS_Futura_Std_Bold_B_11">Process Image Manipulation</samp></h3>&#13;
<p class="TNI1"><i>Process image manipulation</i> abuses both the standard Windows process creation routine and the way endpoint defenses (specifically, anti-malware software) operate. To defend a system from malware attacks, anti-malware software needs to know when a new process is started in order to monitor it for suspect behaviors. This is where the API function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp> comes in. When a new process is created, this function sends notification messages to endpoint defense software, which then inspects and scans the originating executable file that started the process. If the anti-malware software sees that the executable file contains malicious code, it can quarantine the file and terminate any associated processes. The problem is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp> is invoked not at the exact moment of a process’s creation, but rather on the creation and execution of the first few threads running within the process context. This gives malware a nice window of opportunity to modify the original executable file before anti-malware solutions have time to scan it.</p>&#13;
<p class="TX">Process manipulation also involves interfering with the way Windows creates processes (as described in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>). In essence, Windows usually <span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>, a kernel function that handles the details of process creation and then maps processes into memory by executing the following steps:</p>&#13;
<p class="ListNumber1">  1.  Obtain a handle to an executable file (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>, for example).</p>&#13;
<p class="ListNumber">  2.  Create a section object for the file, typically by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp> function. In this case, a <i>section</i> is simply an object that will be mapped into memory.</p>&#13;
<p class="ListNumber">  3.  Create a process object by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp> with a parameter referencing the newly created section object, mapping the process object into memory as a new process.</p>&#13;
<p class="ListNumber2">  4.  Execute the process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> to create and start a new thread.</p>&#13;
<p class="TX">Let’s take a look at how different process manipulation techniques are used to interfere with these steps.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-188"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Herpaderping</samp></h4>&#13;
<p class="TNI1"><i>Process herpaderping</i> has a funny name but packs a powerful punch. It confuses the operating system and anti-malware solutions by interfering with the way Windows creates processes. <a href="chapter12.xhtml#fig12-15">Figure 12-15</a> illustrates how this technique works.</p>&#13;
<figure class="IMG"><img class="img80" id="fig12-15" src="../images/fig12-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: The process-herpaderping technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This malware first creates a new file on disk and obtains a handle to it, keeping that handle open <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It writes malicious executable code into this empty file, then creates a section object for the file <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, it creates a process using the new section object <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The malicious code is now mapped into memory, but it isn’t executing yet. So far, this approach follows the standard Windows PE loading steps, but things are about to get interesting.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>The malware modifies or removes the malicious code within the file it created on disk <span class="CodeAnnotation" aria-label="annotation4">❹</span>. It then starts a new thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>), which executes the malicious code in memory, and closes the handle to the open file. At this point, the aforementioned <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp> callback will occur and endpoint defenses will kick in, inspecting the malicious file. However, since the malicious file in fact no longer contains malicious code, the anti-malware software is tricked into thinking all is well. Anti-malware software, as well as Windows itself, assumes that a file on disk can’t (or shouldn’t) be modified when it’s already mapped into memory and running inside a process. Process herpaderping takes advantage of such assumptions to execute malicious code. You can find out more about this technique from its author at <a href="https://jxy-s.github.io/herpaderping/"><i>https://<wbr/>jxy<wbr/>-s<wbr/>.github<wbr/>.io<wbr/>/herpaderping<wbr/>/</i></a>. If you’d like to test it yourself, you can explore the proof of concept at <a href="https://github.com/jxy-s/herpaderping"><i>https://<wbr/>github<wbr/>.com<wbr/>/jxy<wbr/>-s<wbr/>/herpaderping</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-189"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Doppelganging</samp></h4>&#13;
<p class="TNI1"><i>Process doppelganging</i>, first presented at Black Hat 2017 by security researchers Eugene Kogan and Tal Liberman, is a manipulation technique that uses Transactional NTFS to hide malicious code execution. The term <i>doppelganging</i> originates from the word <i>doppelganger</i>, which is commonly used to describe a person with an uncanny resemblance to someone else. <i>Transactional NTFS</i> was designed to add extra features and support (like file integrity preservation and better error handling) to NTFS, the default filesystem in Windows. It allows the use of <i>transactions</i>, which track changes to the filesystem that can be rolled back when necessary. Actions like file deletion first occur virtually. If the file deletion request succeeds, the transaction is committed and the file is actually deleted. If the file deletion request results in an error, however, the transaction is rolled back and no action occurs. Ultimately, transactions seek to prevent data inconsistency and corruption resulting from a system failure or other unexpected event.</p>&#13;
<p class="TX">A new file created with transactions normally can’t be accessed from outside the process currently interacting with it; even certain anti-malware solutions can’t access it in this case. For this reason, transactions can provide a safe location for a malicious file to temporarily hide. And since transacted files can be “rolled back” to a previous state, endpoint defenses can easily become confused. This is exactly why process doppelganging is effective. <a href="chapter12.xhtml#fig12-16">Figure 12-16</a> illustrates how this technique works.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>&#13;
<figure class="IMG"><img class="img80" id="fig12-16" src="../images/fig12-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: The process-doppelganging technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This malware creates a new NTFS transaction using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateTransaction</samp> and opens an existing executable file using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFileTransacted</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (It could instead call lower-level functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateTransaction</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetCurrentTransaction</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateFile</samp> to achieve the same effect.) Next, the malware writes its malicious code into the existing PE file (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>), which will replace the original executable’s code <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The malware then executes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp> to create a new process, passing the location of the new malicious PE file (the doppelganger) as a parameter <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Once the PE file is mapped into memory and the malicious process is running, the malware deliberately rolls back the original NTFS transaction (<samp class="SANS_TheSansMonoCd_W5Regular_11">RollbackTransaction</samp>), returning the file to its original, preinfected state <span class="CodeAnnotation" aria-label="annotation4">❹</span>. When the anti-malware software is notified of the process creation and scans the process’s executable file on disk, it’s too late; the original executable file has already been rolled back to its nonmalicious state.</p>&#13;
<p class="TX">A few variations of the process-doppelganging technique have emerged since it was first published in 2017. One variant, dubbed <i>transacted hollowing</i> by researchers at Malwarebytes, combines process hollowing with process doppelganging (see the blog post “Process Doppelg<span class="accent">ä</span>nging Meets Process Hollowing in Osiris Dropper” at <a href="https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris"><i>https://<wbr/>www<wbr/>.malwarebytes<wbr/>.com<wbr/>/blog<wbr/>/news<wbr/>/2018<wbr/>/08<wbr/>/process<wbr/>-doppelganging<wbr/>-meets<wbr/>-process<wbr/>-hollowing<wbr/>_osiris</i></a>). As with doppelganging, the malware creates a new process for the injected payload. However, instead of directly injecting the payload, it creates the process in a suspended state and maps the malicious code into memory, as in process hollowing. This is a good example of how security research is often used later by malware authors as a jumping-off point for new techniques.</p>&#13;
<p class="TX">As you’ve seen, process image manipulation techniques rely on the exploitation of fundamental Windows behaviors, and they’re unlikely to go away anytime soon. It’s important for analysts to keep current on what’s cropping up in the wild. To close out this section, we’ll look at two newer process manipulation techniques.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>&#13;
<h4 class="H2" id="sec14"><span id="h-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Reimaging and Ghosting</samp></h4>&#13;
<p class="TNI1"><i>Process reimaging</i> is similar to the previously described techniques in that it relies on manipulating a currently running process to circumvent security controls. To execute process reimaging, the malware modifies its <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> attribute, which contains the filepath of the malware’s executable on disk, to point instead to a benign, legitimate executable. This technique relies on the fact that there are inconsistencies in the way Windows handles <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE _OBJECT</samp>, and as a result, some anti-malware products put too much trust in what’s stored in a malicious process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> location. More information on this technique can be found in the blog post “In NTDLL I Trust” from McAfee (<a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/in-ntdll-i-trust-process-reimaging-and-endpoint-security-solution-bypass/"><i>https://<wbr/>www<wbr/>.mcafee<wbr/>.com<wbr/>/blogs<wbr/>/other<wbr/>-blogs<wbr/>/mcafee<wbr/>-labs<wbr/>/in<wbr/>-ntdll<wbr/>-i<wbr/>-trust<wbr/>-process<wbr/>-reimaging<wbr/>-and<wbr/>-endpoint<wbr/>-security<wbr/>-solution<wbr/>-bypass<wbr/>/</i></a>) and on GitHub (<a href="https://github.com/djhohnstein/ProcessReimaging"><i>https://<wbr/>github<wbr/>.com<wbr/>/djhohnstein<wbr/>/ProcessReimaging</i></a>).</p>&#13;
<p class="TX"><i>Process ghosting</i> is most similar to process herpaderping. The malware creates a file and requests that Windows puts the file into a pending deletion state. Since there can be a delay between when the file is put into this state and when it’s actually deleted, the malware can write malicious executable code into the file and create an image object for it (copying the file content into memory) before Windows deletes it. Finally, the malware creates a process with the image object of the now-deleted file and executes it. Since Windows prevents endpoint defenses like anti-malware from reading and inspecting the file while it’s in a pending deletion state, these defenses are effectively blinded to the malicious code in the file. You can read more about this technique in the blog post “What You Need to Know About Process Ghosting” at <a href="https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack"><i>https://<wbr/>www<wbr/>.elastic<wbr/>.co<wbr/>/blog<wbr/>/process<wbr/>-ghosting<wbr/>-a<wbr/>-new<wbr/>-executable<wbr/>-image<wbr/>-tampering<wbr/>-attack</i></a>.</p>&#13;
<p class="TX">Now we’ll turn to another pair of methods for injecting and covertly executing code.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-191"/><samp class="SANS_Futura_Std_Bold_B_11">DLL and Shim Hijacking</samp></h3>&#13;
<p class="TNI1"><i>Hijacking</i> is a general term for techniques that involve interfering with the normal execution flow of a program or manipulating the way Windows runs programs, in order to execute unauthorized code. Specifically, <i>DLL hijacking</i> exploits the way legitimate executables load their required libraries, in order to inject a malicious DLL. <i>Shim hijacking</i> involves using Windows application <i>shims</i>, or small libraries that intercept API calls, to inject code into an executing process. Let’s dig a little deeper into each technique.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h-192"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL Hijacking</samp></h4>&#13;
<p class="TNI1">All Windows applications must load DLL files at some point to function. Most applications have some sort of manifest that lists all the required DLLs and where they reside on disk. This manifest is part of the application’s DLL <i>search order.</i> Other possible search order locations include the application’s default install directory (such as <i>C:\Program Files\CoolApplication</i>), where its primary executable file is located, and Windows directories that house the standard Windows DLLs (such as <i>%SystemRoot%\system32</i>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>This setup leaves open an interesting attack vector. Many poorly written applications don’t verify the contents or signature of the DLLs they’re loading; instead, they blindly load the required files based on their search order. Worse still, some poorly written applications simply load all DLLs in their install or running directory haphazardly. If a threat actor knows that a particular application is vulnerable to DLL hijacking, it could craft a specialized piece of malware that drops its payload in the form of a DLL to the directory from which the application is loading its DLLs. The actor can then simply wait for the application to start and autoload the DLL into memory, or it can execute the application directly and force the malicious DLL to load. Lastly, some malware will directly modify an application’s DLL search order or manifest to force a malicious DLL to load. There are several variations of this attack (DLL search order hijacking, sideloading, preloading, remote preloading, and so on), but they all have the same effect: deviously and silently loading a malicious DLL into the vulnerable application’s process memory space and executing unauthorized code.</p>&#13;
<p class="TX">An example of this attack comes from the Qbot malware family. One Qbot variant was delivered to a victim with a few files, most notably a malicious DLL file (<i>WindowsCodecs.dll</i>), a copy of an older but legitimate version of Windows Calculator (<i>calc.exe</i>), and a DLL called <i>7533.dll</i>. The <i>calc.exe</i> file had a curious import in its IAT, highlighted in <a href="chapter12.xhtml#fig12-17">Figure 12-17</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-17" src="../images/fig12-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-17: A curious import in the</samp> <samp class="SANS_Futura_Std_Book_11">calc.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file delivered from a Qbot variant</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Upon execution, starting with its present location, this <i>calc.exe</i> application searches for <i>WindowsCodecs.dll</i>, the real version of which is a legitimate, benign Windows helper application. Since the malware author “helpfully” included <i>WindowsCodecs.dll</i> alongside the <i>calc.exe</i> file, the malicious version of the DLL is injected into <i>calc.exe</i> and its code is executed. <a href="chapter12.xhtml#fig12-18">Figure 12-18</a> illustrates this attack in Procmon.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-18" src="../images/fig12-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-18: The malicious</samp> <samp class="SANS_Futura_Std_Book_11">WindowsCodecs.dll</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file being sideloaded</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This Procmon timeline export illustrates the victim executing the vulnerable <i>calc.exe</i> file (Process Start), which then loads the malicious <i>WindowsCodecs.dll</i> file (Load Image), which in turn executes another payload (<i>regsvr32.exe 7533.dll)</i>. The malware author knows that this particular <span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>older version of <i>calc.exe</i> is vulnerable to DLL hijacking because it blindly loads and executes any DLL named <i>WindowsCodecs.dll</i> in its running location. Very crafty indeed!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shim Hijacking</samp></h4>&#13;
<p class="TNI1">Microsoft’s Application Compatibility framework allows for application <i>shimming</i>, or adding compatibility for software designed for older versions of Windows so that it can run on more recent versions of the OS. Developers can use shims to apply patches to a program without having to rewrite or recompile code. Shims are not only great tools for developers, though; using them is also a powerful method of code injection for malware. Using shims, malware can intercept API calls and modify their parameters. When a user starts an application, Windows starts the shim engine and checks to see if that application has any installed shims. Malware can take advantage of this behavior by abusing the shim <i>InjectDLL</i>, which, as its name implies, injects a DLL module into the shimmed application. Once the application is started via its executable file, a malicious DLL file is also loaded into the image of the victim application and executed.</p>&#13;
<p class="TX">A malicious actor can create a shim on the victim system by using the built-in Windows shim database installer tool <i>sdbinst.exe</i>. The malware invokes this tool and points it to the malicious shim database (<i>.sdb</i>) file like so:</p>&#13;
<pre class="pre-101"><code>C:\&gt; sdbinst.exe firefox.sdb</code></pre>&#13;
<p class="TX">Once the malware installs a shim on a victim host, the shim database is installed in <i>C:\Windows\AppPatch\Custom</i> or <i>C:\Windows\AppPatch\AppPatch64\Custom\Custom64</i> (for 64-bit applications) in the form of one or more <i>.sdb</i> files. <a href="chapter12.xhtml#fig12-19">Figure 12-19</a> shows what such a file might look like.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-19" src="../images/fig12-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-19: An</samp> <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file installed on a Windows system</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Installed shims typically have a registry entry in either <i>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom</i> or <i>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB</i>, as shown in <a href="chapter12.xhtml#fig12-20">Figure 12-20</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-20" src="../images/fig12-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-20: Shim database registry entries</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>During an investigation, you can explore suspicious <i>.sdb</i> files in more detail by using the aptly named SDB Explorer tool, available for free from <a href="https://ericzimmerman.github.io/"><i>https://<wbr/>ericzimmerman<wbr/>.github<wbr/>.io<wbr/>/</i></a> and shown in <a href="chapter12.xhtml#fig12-21">Figure 12-21</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-21" src="../images/fig12-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-21: Analyzing an</samp> <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file in SDB Explorer</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see in this output, the file seems to be shimming <i>chrome.exe</i>, <i>explorer.exe</i>, <i>firefox.exe</i>, and <i>iexplore.exe</i>. You can also tell that it’s using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InjectDll</samp> functionality and referencing a DLL file (<i>spvc32loader.dll</i>). Based on this information, we can suspect that this shim is targeting browser processes and attempting to inject a malicious DLL into their respective memory address space, which will occur when the browser process first executes.</p>&#13;
<p class="TX">A good example of shim hijacking is documented in a report from Mandiant on the threat group FIN7, which was able to install the Carbanak backdoor and persist on the infected endpoints by registering a new shim database and patching the legitimate Windows <i>services.exe</i> executable. <i>Services.exe</i> is a critical system process and always runs when Windows first boots up. Once <i>services.exe</i> executes, the shim executes and launches the malicious Carbanak payload. For full details on the attack, see <a href="https://www.mandiant.com/resources/fin7-shim-databases-persistence"><i>https://<wbr/>www<wbr/>.mandiant<wbr/>.com<wbr/>/resources<wbr/>/fin7<wbr/>-shim<wbr/>-databases<wbr/>-persistence</i></a>.</p>&#13;
<p class="TX">Shims are a multipurpose evasive mechanism. They’re a means of covertly injecting code to fly under the radar of endpoint defenses and investigators, as well as a way to establish persistence (as demonstrated by <span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>the FIN7 attack). In addition to these purposes, shims can serve as a rudimentary method for hooking. Let’s look at how hooking works.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h-194"/><samp class="SANS_Futura_Std_Bold_B_11">Hooking</samp></h3>&#13;
<p class="TNI1">As described in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, hooking is a technique used to intercept, monitor, and possibly modify Windows function calls. It has both malicious and legitimate applications; for example, hooking can be used by the following applications:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Benign applications (such as shims), to modify or patch code or to monitor a system or other applications</li>&#13;
<li class="BL">Sandboxes and other malware analysis tools, to monitor the malware’s behaviors</li>&#13;
<li class="BL">Endpoint defense software, such as anti-malware and endpoint detection and response (EDR)</li>&#13;
<li class="BL">Keyloggers and other infostealer malware, to intercept keyboard events in order to capture keystrokes and steal sensitive data</li>&#13;
<li class="BL">Evasive malware, to prevent its code from being detected by endpoint defenses</li>&#13;
</ul>&#13;
<p class="TX">In this section, first we’ll discuss how hooking works in Windows before looking at some common hooking techniques. To wrap up the section and the chapter, we’ll then look at how malware can implement and inject hooks into victim processes.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h-195"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SetWindowsHookEx Hooking and Injection</samp></h4>&#13;
<p class="TNI1">One of the simplest ways to implement a hook is to use a Windows function designed specifically for that purpose: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>. This function allows the caller to specify which system events to hook, such as mouse or keyboard events, and which code to execute when an event occurs. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> can also be abused for DLL injection, as it accepts a DLL file as a parameter. The following simplified pseudocode illustrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> can be used to hook and stealthily run malicious code within the context of a victim process:</p>&#13;
<pre class="pre-102"><code>hmod = LoadLibrary("evil.dll");&#13;
lpfn = GetProcAddress(hmod, "Function_1");&#13;
idHook = "WH_MOUSE_LL";&#13;
dwThreadId = 0;&#13;
HHOOK hook = SetWindowsHookEx(idHook, lpfn, hmod, dwThreadId);</code></pre>&#13;
<p class="TX">In this example, several variables are passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> as parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">idHook</samp> parameter can have a number of different values, each representing a system event to be monitored and hooked. For example, the values <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE_LL</samp> (the latter is shown here) will intercept mouse-related events such as clicks. Two other hooks commonly used <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>by malware are <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD_LL</samp>, which intercept keyboard-related events.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">hmod</samp> parameter represents the name of the loaded module containing the malicious code that will be executed once a mouse event occurs. In the current example, this malware is calling <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, which will load the malicious DLL (<i>evil.dll</i>) into the victim process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpfn</samp> parameter represents a pointer to code that will execute when a mouse event occurs. In this case, the malicious function to be executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">Function_1</samp>, which resides in <i>evil.dll</i>.</p>&#13;
<p class="TX">Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwThreadId</samp> parameter represents a specific thread ID to be monitored. If the program calling <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> wishes to monitor only a single thread in a single application, it can set the thread ID here. If the calling program wishes to monitor all threads, it can set this parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
<p class="TX">In summary, the malicious <i>evil.dll</i> file will load and execute inside the victim process whenever a mouse event is detected. Since the malware could potentially hide and wait for a very specific event to occur, such as a certain number of mouse clicks or a particular key being pressed, this attack can be very stealthy. Note, however, that this technique is rather old, and modern versions of Windows can prevent such an attack, not to mention that this behavior is very suspicious and will likely trigger endpoint defenses. Furthermore, this specific example will almost certainly result in a very unstable system. (Loading a DLL every time there’s a mouse event isn’t a wise decision!) However, variations of this technique are still used in modern malware, so it’s important to be aware of it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h-196"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Hooking</samp></h4>&#13;
<p class="TNI1">One of the most common forms of user-space hooking is <i>inline hooking</i>, which relies on injecting code into a target process and simultaneously modifying the legitimate function being hooked to force a jump to the injected code. First, the process that wishes to hook another process (the target process) must inject code into it by using one of the previously described methods; DLL injection is one of the most common. Next, the first process modifies the function it wishes to hook within the target process’s address space to point and jump to the injected hooking code. When the target process executes that function, control flow is transferred from the original code to the hooked code, which can then be used for monitoring, intercepting, or modifying calls to the original function. <a href="chapter12.xhtml#fig12-22">Figure 12-22</a> illustrates the inline hooking technique.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-22" src="../images/fig12-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-22: The inline API hooking technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>This application calls the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, which is located inside <i>ntdll.dll</i>. Normally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> code inside <i>ntdll.dll</i> would then execute. However, <i>ntdll.dll</i> has been tampered with and its legitimate code has been overwritten with a jump instruction, so now the program will jump to and execute the hooking code instead. Once the malicious code is run, control flow is transferred back to <i>ntdll.dll</i> and finally returns to the original application.</p>&#13;
<p class="TX">Let’s say our system has been infected with a malware sample that wishes to intercept and monitor all calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> in a victim process (<i>firefox.exe</i>, for example). After injecting the malicious hooking DLL into <i>firefox.exe</i>, the malware must modify the <i>ntdll.dll</i> module in the victim process’s address space. The malware locates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> function within <i>ntdll.dll</i> and overwrites the first 5 bytes to jump to the malicious injected DLL instead of executing the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> code. (Overwriting 5 bytes is common because that’s a typical size for jump instructions.) The first byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp> (the jump instruction), is followed by 4 bytes representing the memory location to jump to. To modify the function code in the target process, the first process can call <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>. This code block shows the first bytes of the legitimate <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> function (in x64 assembly):</p>&#13;
<pre class="pre-103"><code><var>--snip--</var>&#13;
mov  r10, rcx&#13;
mov  eax, 55&#13;
test byte ptr ds:[7FFE0308], 1&#13;
jne  ntdll.7FFC61D3CB65&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">After the malware modifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> function, it might look like this; notice the jump to the malicious code:</p>&#13;
<pre class="pre-104"><code><var>--snip--</var>&#13;
jmp  hooked_code ; Jump to hooking code.&#13;
mov  eax, 55&#13;
test byte ptr ds:[7FFE0308], 1&#13;
jne  ntdll.7FFC61D3CB65&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement, the jump to the hooked code could be accomplished with a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction like so:</p>&#13;
<pre class="pre-105"><code><var>--snip--</var>&#13;
push address_of_hooked_code ; Push the address of the hooked code to the stack.&#13;
ret                         ; Return (jump) to the hooked code.&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">When installing an inline hook, the code author often will want the original function code to execute after the hooked code runs in order to avoid scrutiny from system users. Let’s say that in our <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> example, the author wants to intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, execute the hooked code, and then execute the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> code. This can be accomplished <span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>in the form of a <i>trampoline</i>, which is simply a jump back to the original function, as shown in <a href="chapter12.xhtml#fig12-23">Figure 12-23</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig12-23" src="../images/fig12-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-23: An inline hook trampoline</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Trampolines are often implemented with an instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">call NtCreateFile+5</samp>. After the hooking code executes (inside the injected DLL, in this case), this instruction will transfer control flow back to the real <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, skipping over the first 5 bytes where the inserted <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement resides in the modified <i>ntdll.dll</i> file.</p>&#13;
<p class="TX">When you’re analyzing malware, there are three function calls that can hint at inline hooking. First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> to read the first bytes of code in the function it wishes to hook inside the target process. Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> to modify the permissions of the target memory region and prepare for writing the jump instruction that will jump to the malicious code injected into the target process. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> to write the jump statement into the target function’s code.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Another user-space hooking technique is</i> <span class="note_Italic">IAT hooking</span><i>, which involves altering the import address table of the target process to point to the hooking code rather than to the original function code. However, IAT hooking isn’t often used by modern malware since it’s easily detected by host-based defenses, so I won’t go into more detail on this method.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h-197"/><samp class="SANS_Futura_Std_Bold_B_11">Mitigations for Process and Hook Injection</samp></h3>&#13;
<p class="TNI1">As new injection and hooking techniques are used in malware or discovered by researchers and published, Microsoft counters them with built-in protections as much as possible. For example, <i>data execution prevention</i>, introduced in Windows XP, seeks to prevent malware from executing injected malicious code by marking memory regions as nonexecutable. <i>AppLocker</i>, introduced in Windows 7, prevents unauthorized executables (which can include injected DLLs) from executing. <i>Control Flow Guard</i>, released in Windows 8.1, is designed to detect whether malware modifies the code control flow of another process, which often takes place during process injection. And <i>Arbitrary Code Guard (ACG)</i>, added in Windows 10, seeks to prevent <span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>malware from modifying the code of legitimate processes, thus preventing certain types of process and hook injection.</p>&#13;
<p class="TX">In addition, complementary defenses such as EDR and anti-malware software can monitor suspicious processes and detect or prevent some of these injections. Keep in mind, however, that not all injection is malicious: plenty of benign, legitimate applications use injection for various reasons, so it can be difficult for endpoint defense products to determine the difference between good and evil. <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> will explore some of these endpoint defenses and how malware attempts to bypass them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h-198"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, we discussed some of the common techniques malware uses to inject and run code within the context of other processes in order to evade endpoint defenses and blend in with the environment in which it’s running. We also covered some of the common hooks malware uses to hide its malicious behaviors or implement rootkit functionality. There are many types of injection and hooking techniques, and it’s impossible to cover them all in this book. I’ve tried to focus on those that you’re most likely to encounter in the wild, as well as some of the newer techniques that malware authors might add to their evasion toolboxes.</p>&#13;
<p class="TX">In the next chapter, we’ll start looking at ways in which malware can circumvent endpoint and network defenses to execute and hide its malicious code in a well-protected environment.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>