<html><head></head><body><section class="chapter" title="Chapter&#xA0;5.&#xA0;Let&#x2019;s Get Functional" epub:type="chapter" id="letapostrophes_get_functional"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Let’s Get Functional</h2></div></div></div><p>I’ve mentioned several times that F# is a functional language, but as you’ve learned from previous chapters you can build rich applications in F# without using any functional techniques. Does that mean that F# isn’t really a functional language? No. F# is a general-purpose, multiparadigm language that allows you to program in the style most suited to your task. It is considered a functional-first language, meaning that its constructs encourage a functional style. In other words, when developing in F# you should favor functional approaches whenever possible and switch to other styles as appropriate.</p><p>In this chapter, we’ll see what functional programming really is and how functions in F# differ from those in other languages. Once we’ve established that foundation, we’ll explore several data types commonly used with functional programming and take a brief side trip into lazy evaluation.</p><div class="sect1" title="What Is Functional Programming?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="what_is_functional_programmingquestion_m">What Is Functional Programming?</h2></div></div></div><p><a id="iddle1298" class="indexterm"/><a id="iddle1569" class="indexterm"/><a id="iddle1845" class="indexterm"/><a id="iddle1856" class="indexterm"/><a id="iddle2070" class="indexterm"/>Functional programming takes a fundamentally different approach toward developing software than object-oriented programming. While object-oriented programming is primarily concerned with managing an ever-changing system state, functional programming emphasizes immutability and the application of deterministic functions. This difference drastically changes the way you build software, because in object-oriented programming you’re mostly concerned with defining classes (or structs), whereas in functional programming your focus is on defining functions with particular emphasis on their input and output.</p><p>F# is an impure functional language where data is immutable by default, though you can still define mutable data or cause other side effects in your functions. Immutability is part of the functional concept called <span class="emphasis"><em>referential transparency</em></span>, which means that an expression can be replaced with its result without affecting the program’s behavior. For example, if you can replace <code class="literal">let sum = add 5 10</code> with <code class="literal">let sum = 15</code> without otherwise affecting the program’s behavior, then <code class="literal">add</code> is said to be referentially transparent. But immutability and referential transparency are only two aspects of functional programming, and they certainly don’t make a language functional on their own.</p></div><div class="sect1" title="Programming with Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="programming_with_functions">Programming with Functions</h2></div></div></div><p>If you’ve never done any “real” functional programming, F# will forever change the way you think about functions because its functions closely resemble mathematical functions in both structure and behavior. For example, <a class="xref" href="ch03.html" title="Chapter 3. Fundamentals">Chapter 3</a> introduced the <code class="literal">unit</code> type, but I avoided discussing its importance in functional programming. Unlike C# and Visual Basic, F# makes no distinction between functions that return values and those that don’t. In fact, every function in F# accepts exactly one input value and returns exactly one output value. The <code class="literal">unit</code> type enables this behavior. When a function doesn’t have any specific input (no parameters), it actually accepts <code class="literal">unit</code>. Similarly, when a function doesn’t have any specific output, it returns <code class="literal">unit</code>.</p><p>The fact that every F# function returns a value allows the compiler to make certain assumptions about your code. One important assumption is that the result of the last evaluated expression in a function is the function’s return value. This means that although <code class="literal">return</code> is a keyword in F#, you don’t need to explicitly identify return values.</p><div class="sect2" title="Functions as Data"><div class="titlepage"><div><div><h3 class="title" id="functions_as_data">Functions as Data</h3></div></div></div><p>A defining (and arguably the most important) characteristic of any functional language is that it treats functions like any other data type. The .NET Framework has always supported this concept to some degree with delegation, but until relatively recently delegation was too cumbersome to be viable in all but a few limited scenarios. Only when LINQ was introduced <a id="iddle1058" class="indexterm"/><a id="iddle1094" class="indexterm"/><a id="iddle1385" class="indexterm"/><a id="iddle1453" class="indexterm"/><a id="iddle1455" class="indexterm"/><a id="iddle1462" class="indexterm"/><a id="iddle1467" class="indexterm"/><a id="iddle1469" class="indexterm"/><a id="iddle1504" class="indexterm"/><a id="iddle2021" class="indexterm"/>with the goodness of lambda expressions and the built-in generic delegate types (<code class="literal">Action</code> and <code class="literal">Func</code>) did delegation reach its full potential. F# uses delegation behind the scenes, but unlike C# and Visual Basic, its syntax abstracts away the delegation with the <code class="literal">-&gt;</code> token. The <code class="literal">-&gt;</code> token, generally read as “goes to” or “returns,” identifies a value as a <span class="emphasis"><em>function value</em></span> where the data type specified on the left is the function’s input type and the data type on the right is its return type. For example, the signature for a function that both accepts and returns a string is <code class="literal">string -&gt; string</code>. Similarly, a parameterless function that returns a string is represented as <code class="literal">unit -&gt; string</code>.</p><p>Signatures become increasingly complex when you begin working with <span class="emphasis"><em>higher-order functions</em></span>—functions that accept or return other functions. Higher-order functions are used extensively in F# (and functional programming in general) because they allow you to isolate common parts of functions and substitute the parts that change.</p><p>In some ways, higher-order functions are to functional programming what interfaces are to object-oriented programming. For example, consider a function that applies a transformation to a string and prints the result. Its signature might look something like <code class="literal">(string -&gt; string) -&gt; string -&gt; unit</code>. This simple notation goes a long way toward making your code more comprehensible than when you’re dealing with the delegates directly.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note01"/>Note</h3><p><span class="emphasis"><em>You can use the function signatures in type annotations whenever you’re expecting a function. As with other data types, though, the compiler can often infer the function type.</em></span></p></div></div><div class="sect2" title="Interoperability Considerations"><div class="titlepage"><div><div><h3 class="title" id="interoperability_considerations">Interoperability Considerations</h3></div></div></div><p>Despite the fact that F# functions are ultimately based on delegation, be careful when working with libraries written in other .NET languages, because the delegate types aren’t interchangeable. F# functions rely on the overloaded <code class="literal">FSharpFunc</code> delegate types, whereas traditional .NET delegates are often based on the <code class="literal">Func</code> and <code class="literal">Action</code> types. If you need to pass <code class="literal">Func</code> and <code class="literal">Action</code> delegates into an F# assembly, you can use the following class to simplify the conversion.</p><a id="pro_id00236"/><pre class="programlisting">open System.Runtime.CompilerServices

[&lt;Extension&gt;]
type public FSharpFuncUtil =
  [&lt;Extension&gt;]
  static member ToFSharpFunc&lt;'a, 'b&gt; (func : System.Func&lt;'a, 'b&gt;) =
    fun x -&gt; func.Invoke(x)

  [&lt;Extension&gt;]
  static member ToFSharpFunc&lt;'a&gt; (act : System.Action&lt;'a&gt;) =
    fun x -&gt; act.Invoke(x)</pre><p>The <code class="literal">FSharpFuncUtil</code> class defines the overloaded <code class="literal">ToFSharpFunc</code> method as traditional .NET extension methods (via the <code class="literal">ExtensionAttribute</code> on both the class and methods) so you can easily call them from another language. The <a id="iddle1273" class="indexterm"/><a id="iddle1735" class="indexterm"/>first overload handles converting single-parameter <code class="literal">Func</code> instances, while the second handles single-parameter <code class="literal">Action</code> instances. These extension methods don’t cover every use case, but they’re certainly a good starting point.</p></div></div><div class="sect1" title="Currying"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="currying">Currying</h2></div></div></div><p>Functions in F# work a bit differently than you’re probably accustomed to. For example, consider the simple <code class="literal">add</code> function, introduced in <a class="xref" href="ch02.html" title="Chapter 2. F# Interactive">Chapter 2</a>.</p><a id="pro_id00237"/><pre class="programlisting">let add a b = a + b</pre><p>You might think that <code class="literal">add</code> accepts two parameters, but that’s not how F# functions work. Remember, in F# every function accepts exactly one input and returns exactly one output. If you create the preceding binding in FSI or hover over the name in Visual Studio, you’ll see that its signature is:</p><a id="pro_id00238"/><pre class="programlisting">val add : a:int -&gt; b:int -&gt; int</pre><p>Here, the name <code class="literal">add</code> is bound to a function that accepts an integer (<code class="literal">a</code>) and returns a function. The returned function accepts an integer (<code class="literal">b</code>) and returns an integer. Understanding this automatic function chaining—called <span class="emphasis"><em>currying</em></span>—is critical to using F# effectively because it enables several other features that affect how you design functions.</p><p>To better illustrate how currying actually works, let’s rewrite <code class="literal">add</code> to more closely resemble the compiled code.</p><a id="pro_id00239"/><pre class="programlisting">&gt; <span class="strong"><strong>let add a = fun b -&gt; (+) a b;;</strong></span>

val add : a:int -&gt; b:int -&gt; int</pre><p>The most significant thing here is that both this and the previous version have exactly the same signature. Here, though, <code class="literal">add</code> accepts only a single parameter (<code class="literal">a</code>) and returns a separate function as defined by a lambda expression. The returned function accepts the second parameter (<code class="literal">b</code>) and invokes the multiplication operator as another function call.</p><div class="sect2" title="Partial Application"><div class="titlepage"><div><div><h3 class="title" id="partial_application">Partial Application</h3></div></div></div><p>One of the capabilities unlocked by curried functions is partial application. <span class="emphasis"><em>Partial application</em></span> allows you to create new functions from existing ones simply by supplying some of the arguments. For example, in the case of <code class="literal">add</code>, you could use partial application to create a new <code class="literal">addTen</code> function that always adds 10 to a number.</p><a id="pro_id00240"/><pre class="programlisting">&gt; <span class="strong"><strong>let addTen = add 10;;</strong></span>

val addTen : ① (int -&gt; int)
&gt; <span class="strong"><strong>addTen 10;;</strong></span>
val it : int = 20</pre><p><a id="iddle1036" class="indexterm"/><a id="iddle1448" class="indexterm"/><a id="iddle1451" class="indexterm"/><a id="iddle1769" class="indexterm"/><a id="iddle1771" class="indexterm"/><a id="iddle1772" class="indexterm"/>Notice at ① how <code class="literal">addTen</code>’s definition and signature are listed. Although we didn’t explicitly include any parameters in the definition, the signature is still a function that both accepts and returns an integer. The compiler evaluated the curried <code class="literal">add</code> function as far as it could with the provided arguments (just <code class="literal">10</code>, in this case) and bound the resulting function to the name, <code class="literal">addTen</code>.</p><p>Currying applies arguments one at a time, from left to right, so partially applied arguments must correspond to the function’s first parameters.</p><div class="warning" title="Warning" epub:type="warning"><h3 class="title"><a id="ch05note02"/>Warning</h3><p><span class="emphasis"><em>Once you’re comfortable with currying and partial application, you may start thinking that you could simulate them in C# or Visual Basic by returning Func or Action instances. Don’t. Neither language is designed to support this type of functional programming, so simulating these concepts is inelegant at best and immensely error prone at worst.</em></span></p></div></div><div class="sect2" title="Pipelining"><div class="titlepage"><div><div><h3 class="title" id="pipelining">Pipelining</h3></div></div></div><p>Another feature often associated with currying (and used extensively in F#) is pipelining. <span class="emphasis"><em>Pipelining</em></span> allows you to create your own function chains by evaluating one expression and sending the result to another function as the final argument.</p><div class="sect3" title="Forward Pipelining"><div class="titlepage"><div><div><h4 class="title" id="forward_pipelining">Forward Pipelining</h4></div></div></div><p>Usually you’ll send values forward to the next function using the <span class="emphasis"><em>forward pipelining operator</em></span> (<code class="literal">|&gt;</code>). If you don’t want to do anything with a function’s result when it returns something other than <code class="literal">unit</code>, you can pipe the result forward to the <code class="literal">ignore</code> function like this:</p><a id="pro_id00241"/><pre class="programlisting">add 2 3 |&gt; ignore</pre><p>Pipelining isn’t restricted to simple scenarios like ignoring a result. As long as the last argument of the receiving function is compatible with the source function’s return type, you can create complex function chains. For example, suppose you have a list of daily temperatures in degrees Fahrenheit and want to find the average temperature, convert it to Celsius, and print the result. You could do it the old-fashioned, procedural way by defining a binding for each step, or you could use pipelining to chain the steps like this:</p><a id="pro_id00242"/><pre class="programlisting">let fahrenheitToCelsius degreesF = (degreesF - 32.0) * (5.0 / 9.0)

let marchHighTemps = [ 33.0; 30.0; 33.0; 38.0; 36.0; 31.0; 35.0;
                       42.0; 53.0; 65.0; 59.0; 42.0; 31.0; 41.0;
                       49.0; 45.0; 37.0; 42.0; 40.0; 32.0; 33.0;
                       42.0; 48.0; 36.0; 34.0; 38.0; 41.0; 46.0;
                       54.0; 57.0; 59.0 ]
<span class="strong"><strong>marchHighTemps</strong></span>
<span class="strong"><strong>|&gt; List.average</strong></span>
<span class="strong"><strong>|&gt; fahrenheitToCelsius</strong></span>
<span class="strong"><strong>|&gt; printfn "March Average (C): %f"</strong></span></pre><p><a id="iddle1010" class="indexterm"/><a id="iddle1012" class="indexterm"/><a id="iddle1032" class="indexterm"/><a id="iddle1037" class="indexterm"/><a id="iddle1197" class="indexterm"/><a id="iddle1199" class="indexterm"/><a id="iddle1200" class="indexterm"/><a id="iddle1446" class="indexterm"/><a id="iddle1452" class="indexterm"/><a id="iddle1463" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle1773" class="indexterm"/>Here the <code class="literal">marchHighTemps</code> list is piped to the <code class="literal">List</code> module’s <code class="literal">average</code> function. The <code class="literal">average</code> function is then evaluated and its result passed on to the <code class="literal">fahrenheitToCelsius</code> function. Finally, the average temperature in Celsius is passed along to <code class="literal">printfn</code>.</p></div><div class="sect3" title="Backward Pipelining"><div class="titlepage"><div><div><h4 class="title" id="backward_pipelining">Backward Pipelining</h4></div></div></div><p>Like its forward counterpart, the <span class="emphasis"><em>backward pipelining operator</em></span> (<code class="literal">&lt;|</code>) sends the result of an expression to another function as the final argument, but does it from right to left instead. Because it changes precedence within an expression, the backward pipelining operator is sometimes used as a replacement for parentheses.</p><p>The backward pipelining operator can change the semantics of your code. For instance, in the <code class="literal">fahrenheitToCelsius</code> example in the previous section, the emphasis is on the list of temperatures because that’s what’s listed first. To change the semantics to emphasize the output, you could place the <code class="literal">printfn</code> function call ahead of the backward pipelining operator.</p><a id="pro_id00243"/><pre class="programlisting">printfn "March Average (F): %f" &lt;| List.average marchHighTemps</pre></div><div class="sect3" title="Noncurried Functions"><div class="titlepage"><div><div><h4 class="title" id="noncurried_functions">Noncurried Functions</h4></div></div></div><p>Although pipelining is typically associated with curried functions, it also works with noncurried functions (like methods) that accept only a single argument. For instance, to force a delay in execution you could pipe a value into the <code class="literal">TimeSpan</code> class’s static <code class="literal">FromSeconds</code> method and then send the resulting <code class="literal">TimeSpan</code> object to <code class="literal">Thread.Sleep</code>, as shown here.</p><a id="pro_id00244"/><pre class="programlisting">5.0
|&gt; System.TimeSpan.FromSeconds
|&gt; System.Threading.Thread.Sleep</pre><p>Because neither the <code class="literal">TimeSpan</code> class nor the <code class="literal">Thread</code> class is defined in F#, the functions aren’t curried, but you can see how we can chain these functions together with the forward pipelining operator.</p></div></div><div class="sect2" title="Function Composition"><div class="titlepage"><div><div><h3 class="title" id="function_composition">Function Composition</h3></div></div></div><p>Like pipelining, <span class="emphasis"><em>function composition</em></span> allows you to create function chains. It comes in two forms: forward (<code class="literal">&gt;&gt;</code>) and backward (<code class="literal">&lt;&lt;</code>).</p><p>Function composition is subject to the same rules as pipelining regarding inputs and outputs. Where function composition differs is that instead of <a id="iddle1011" class="indexterm"/><a id="iddle1033" class="indexterm"/><a id="iddle1198" class="indexterm"/><a id="iddle1447" class="indexterm"/><a id="iddle1828" class="indexterm"/><a id="iddle1840" class="indexterm"/>defining a one-time operation, the composition operators actually generate new functions. Continuing with our average temperature example, you could easily create a new function from the <code class="literal">List.average</code> and <code class="literal">fahrenheitToCelsius</code> functions with the forward composition operator.</p><a id="pro_id00245"/><pre class="programlisting">&gt; <span class="strong"><strong>let averageInCelsius = List.average &gt;&gt; fahrenheitToCelsius;;</strong></span>

val averageInCelsius : (float list -&gt; float)</pre><p>The composition operator results in a new function that accepts a list of floats and returns a float. Now, instead of calling the two functions independently, you can simply call <code class="literal">averageInCelsius</code> instead.</p><a id="pro_id00246"/><pre class="programlisting">printfn "March average (C): %f" &lt;| <span class="strong"><strong>averageInCelsius marchHighTemps</strong></span></pre><p>As with pipelining, you can compose functions from noncurried functions. For instance, you could compose the forced delay example from <a class="xref" href="ch05.html#noncurried_functions" title="Noncurried Functions">Noncurried Functions</a> as well.</p><a id="pro_id00247"/><pre class="programlisting">&gt; <span class="strong"><strong>let delay = System.TimeSpan.FromSeconds &gt;&gt; System.Threading.Thread.Sleep;;</strong></span>

val delay : (float -&gt; unit)</pre><p>As you might expect, you can now call the <code class="literal">delay</code> function to temporarily pause execution.</p><a id="pro_id00248"/><pre class="programlisting">&gt; <span class="strong"><strong>delay 5.0;;</strong></span>
val it : unit = ()</pre></div></div><div class="sect1" title="Recursive Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="recursive_functions">Recursive Functions</h2></div></div></div><p>There are typically three looping constructs associated with imperative code: <code class="literal">while</code> loops, simple <code class="literal">for</code> loops, and enumerable <code class="literal">for</code> loops. Because each relies on a state change to determine when the exit criteria have been met, you’ll need to take a different approach to looping when writing purely functional code. In functional programming, the preferred looping mechanism is <span class="emphasis"><em>recursion</em></span>. A <span class="emphasis"><em>recursive function</em></span> is one that calls itself either directly or indirectly through another function.</p><p>Although methods within a type are implicitly recursive, <code class="literal">let</code>-bound functions, such as those defined within a module, are not. To make a <code class="literal">let-</code>bound function recursive, you must include the <code class="literal">rec</code> keyword in its definition, as this factorial function illustrates.</p><a id="pro_id00249"/><pre class="programlisting">let <span class="strong"><strong>rec</strong></span> factorial v =
  match v with | 1L -&gt; 1L
               | _ -&gt; v * <span class="strong"><strong>factorial (v - 1L)</strong></span></pre><p><a id="iddle1841" class="indexterm"/><a id="iddle1977" class="indexterm"/>The <code class="literal">rec</code> keyword instructs the compiler to make the function name available within the function but does not otherwise change the function’s signature (<code class="literal">int64 -&gt; int64</code>).</p><div class="sect2" title="Tail-Call Recursion"><div class="titlepage"><div><div><h3 class="title" id="tail-call_recursion">Tail-Call Recursion</h3></div></div></div><p>The preceding factorial example is simple, but it suffers from a major flaw. For example, consider what happens when you call <code class="literal">factorial 5</code>. On each recursive iteration (other than when the value is 1), the function calculates the product of <code class="literal">v</code> and the factorial of <code class="literal">v - 1</code>. In other words, calculating the factorial for a given value inherently requires each subsequent factorial call to complete. At run time, it looks a bit like this:</p><a id="pro_id00250"/><pre class="programlisting">5L * (factorial 4L)
5L * (4L * (factorial 3L))
5L * (4L * (3L * (factorial 2L)))
-- <span class="emphasis"><em>snip</em></span> --</pre><p>The preceding snippet shows that each call is added to the stack. It’s unlikely that this would be a problem with a factorial function, since the calculation can quickly overflow the data type, but more complex recursion scenarios could result in running out of stack space. To address this problem, you can revise the function to use a <span class="emphasis"><em>tail call</em></span> by removing the dependency on subsequent iterations, as shown here:</p><a id="pro_id00251"/><pre class="programlisting">① let factorial v =
  let ② rec fact c p =
    match c with | 0L -&gt; p
                 | _ -&gt;  ③ fact &lt;| c - 1L &lt;| c * p
  ④ fact v 1L</pre><p>The revised factorial function ① creates and then calls a nested recursive function, <code class="literal">fact</code> ②, to isolate the implementation details. The <code class="literal">fact</code> function accepts both the current iteration value (<code class="literal">c</code>) and the product calculated by the previous iteration (<code class="literal">p</code>). At ③ (the nonzero case), the <code class="literal">fact</code> function makes the recursive call. (Notice how only the arguments to the recursive call are calculated here.) Finally, to initiate recursion, the <code class="literal">factorial</code> function ④ invokes the first <code class="literal">fact</code> iteration, passing the supplied value and <code class="literal">1L</code>.</p><p>Although the recursive call is still present in the code, when the F# compiler detects that no iteration is dependent on subsequent iterations, it optimizes the compiled form by replacing the recursion with an imperative loop. This allows the system to iterate as long as necessary. You can observe this optimization by examining the stack traces for each version by inserting a breakpoint and looking at the call stack window (if you’re running this as a console application) or by printing out the stack information returned from <code class="literal">System.Diagnostics.StackTrace</code>, as shown here. (Note that your namespaces will likely vary.)</p><a id="pro_id00252"/><pre class="programlisting"><span class="strong"><strong>Standard recursion</strong></span>
   at FSI_0024.printTrace()
   at FSI_0028.factorial(Int64 v)
   at FSI_0028.factorial(Int64 v)
   at FSI_0028.factorial(Int64 v)
   at FSI_0028.factorial(Int64 v)
   at FSI_0028.factorial(Int64 v)
   at &lt;StartupCode$FSI_0029&gt;.$FSI_0029.main@()
   -- <span class="emphasis"><em>snip</em></span> --

<span class="strong"><strong>Tail recursion</strong></span>
   at FSI_0024.printTrace()
   at FSI_0030.fact@75-8(Int64 c, Int64 p)
   at &lt;StartupCode$FSI_0031&gt;.$FSI_0031.main@()
   -- <span class="emphasis"><em>snip</em></span> --</pre></div><div class="sect2" title="Mutually Recursive Functions"><div class="titlepage"><div><div><h3 class="title" id="mutually_recursive_functions">Mutually Recursive Functions</h3></div></div></div><p><a id="iddle1119" class="indexterm"/><a id="iddle1120" class="indexterm"/><a id="iddle1663" class="indexterm"/>When two or more functions call each other recursively, they are said to be <span class="emphasis"><em>mutually recursive</em></span>. Like mutually recursive types (described in <a class="xref" href="ch04.html" title="Chapter 4. Staying Objective">Chapter 4</a>), mutually recursive functions must be defined together with the <code class="literal">and</code> keyword. For example, a Fibonacci number calculation is easily expressed through mutual recursion.</p><a id="pro_id00253"/><pre class="programlisting">let fibonacci n =
  <span class="strong"><strong>let rec f = function</strong></span>
              <span class="strong"><strong>| 1 -&gt; 1</strong></span>
              <span class="strong"><strong>| n -&gt; g (n - 1)</strong></span>
  <span class="strong"><strong>and g = function</strong></span>
          <span class="strong"><strong>| 1 -&gt; 0</strong></span>
          <span class="strong"><strong>| n -&gt; g (n - 1) + f (n - 1)</strong></span>
  f n + g n</pre><p>The preceding <code class="literal">fibonacci</code> function defines two mutually recursive functions, <code class="literal">f</code> and <code class="literal">g</code>. (The function keyword inside each is a shortcut for pattern matching.) For all values other than 1, <code class="literal">f</code> calls <code class="literal">g</code>. Similarly, <code class="literal">g</code> recursively calls itself and <code class="literal">f</code>.</p><p>Because the mutual recursion is hidden inside <code class="literal">fibonacci</code>, consumers of this code can simply call <code class="literal">fibonacci</code> directly. For example, to compute the sixth number in the Fibonacci sequence you’d write:</p><a id="pro_id00254"/><pre class="programlisting">&gt; <span class="strong"><strong>fibonacci 6;;</strong></span>
val it : int = 8</pre><p>Mutual recursion can be useful, but this example is really only good for illustrating the concept. For performance reasons, a more realistic Fibonacci example would likely forego mutual recursion in favor of a technique called <span class="emphasis"><em>memoization</em></span>, where expensive computations are performed once and the results are cached to avoid calculating the same values multiple times.</p></div></div><div class="sect1" title="Lambda Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="lambda_expressions">Lambda Expressions</h2></div></div></div><p><a id="iddle1059" class="indexterm"/><a id="iddle1237" class="indexterm"/><a id="iddle1454" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1552" class="indexterm"/>If you’ve ever used LINQ or done any other functional programming, you’re probably already familiar with <span class="emphasis"><em>lambda expressions</em></span> (or <span class="emphasis"><em>function expressions</em></span>, as they’re sometimes called). Lambda expressions are used extensively in functional programming. In brief, they provide a convenient way to define simple, single-use, anonymous (unnamed) functions. Lambda expressions are typically favored over let-bound functions when the function is significant only within its context (such as when filtering a collection).</p><p>Lambda expression syntax is similar to that of a function value except that it begins with the <code class="literal">fun</code> keyword, omits the function identifier, and uses the arrow token (<code class="literal">-&gt;</code>) in place of an equal sign. For example, you could express the Fahrenheit-to-Celsius conversion function inline as a lambda expression and immediately evaluate it like this:</p><a id="pro_id00255"/><pre class="programlisting"><span class="strong"><strong>(fun degreesF -&gt; (degreesF - 32.0) * (5.0 / 9.0))</strong></span> 212.0</pre><p>Although defining ad hoc functions like this is certainly one use for lambda expressions, they’re more commonly created inline with calls to higher-order functions, or included in pipeline chains.</p></div><div class="sect1" title="Closures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="closures">Closures</h2></div></div></div><p><span class="emphasis"><em>Closures</em></span> enable functions to access values visible in the scope where a function is defined regardless of whether that value is part of the function. Although closures are typically associated with lambda expressions, nested functions created with <code class="literal">let</code> bindings can be closures as well, since ultimately they both compile to either an <code class="literal">FSharpFunc</code> or a formal method. Closures are typically used to isolate some state. For instance, consider the quintessential closure example—a function that returns a function that manipulates an internal counter value, as shown here:</p><a id="pro_id00256"/><pre class="programlisting">let createCounter() =
  let count = ref 0
  (fun () -&gt; count := !count + 1
             !count)</pre><p>The <code class="literal">createCounter</code> function defines a reference cell that’s captured by the returned function. Because the reference cell is in scope when the returned function is created, the function has access to it no matter when it’s called. This allows you to simulate a stateful object without a formal type definition.</p><p>To observe the function modifying the reference cell’s value, we just need to invoke the generated function and call it like this:</p><a id="pro_id00257"/><pre class="programlisting">let increment = createCounter()
for i in [1..10] do printfn "%i" (increment())</pre></div><div class="sect1" title="Functional Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="functional_types">Functional Types</h2></div></div></div><p><a id="iddle1007" class="indexterm"/><a id="iddle2032" class="indexterm"/><a id="iddle2035" class="indexterm"/>F# includes native support for several additional data types. These types—tuples, records, and discriminated unions—are typically associated with functional programming, but they’re often useful in mixed-paradigm development as well. While each of these types has a specific purpose, they’re all intended to help you remain focused on the problem your software is trying to solve.</p><div class="sect2" title="Tuples"><div class="titlepage"><div><div><h3 class="title" id="tuples">Tuples</h3></div></div></div><p>The most basic functional type is the <span class="emphasis"><em>tuple</em></span>. Tuples are a convenient way to group a number of values within a single immutable construct without creating a custom type. Tuples are expressed as comma-delimited lists and are sometimes enclosed in parentheses. For example, the following two definitions representing geometric points as tuples are equally valid.</p><a id="pro_id00258"/><pre class="programlisting">&gt; <span class="strong"><strong>let point1 = 10.0, 10.0;;</strong></span>

val point1 : float * float = (10.0, 10.0)

&gt; <span class="strong"><strong>let point2 = (20.0, 20.0);;</strong></span>

val point2 : float * float = (20.0, 20.0)</pre><p>The signature for a tuple type includes the type of each value separated by an asterisk (<code class="literal">*</code>). The asterisk is used as the tuple element delimiter for mathematical reasons: Tuples represent the Cartesian product of all values their elements contain. Therefore, to express a tuple in a type annotation, you write it as an asterisk-delimited list of types like this:</p><a id="pro_id00259"/><pre class="programlisting">let point : <span class="strong"><strong>float * float</strong></span> = 0.0, 0.0</pre><p>Despite some syntactic similarities, particularly when the values are enclosed in parentheses, it’s important to recognize that other than the fact that they contain multiple values, tuples aren’t collections; they simply group a fixed number of values within a single construct. The tuple types don’t implement <code class="literal">IEnumerable&lt;'T&gt;</code>, so they can’t be enumerated or iterated over in an enumerable <code class="literal">for</code> loop, and individual tuple values are exposed only through properties with nonspecific names like <code class="literal">Item1</code> and <code class="literal">Item2</code>.</p><div class="sidebar"><a id="tuples_in_dotnet"/><div class="sidebar-title">Tuples in .NET</div><p><a id="iddle1460" class="indexterm"/><a id="iddle1758" class="indexterm"/><a id="iddle1932" class="indexterm"/><a id="iddle2033" class="indexterm"/>Tuples have always been part of F# but were only introduced to the larger .NET Framework with .NET 4. Prior to .NET 4, the tuple classes were located in the <code class="literal">FSharp.Core</code> library, but they have since been moved to <code class="literal">mscorlib</code>. This difference is only really important if you intend to write cross-language code against earlier versions of the .NET Framework, because it affects which assembly you reference.</p></div><div class="sect3" title="Extracting Values"><div class="titlepage"><div><div><h4 class="title" id="extracting_values">Extracting Values</h4></div></div></div><p>Tuples are often useful for returning multiple values from a function or for sending multiple values to a function without currying them. For instance, to calculate the slope of a line you could pass two points as tuples to a <code class="literal">slope</code> function. To make the function work, though, you’ll need some way to access the individual values. (Fortunately, tupled values are always accessible in the order in which they’re defined, so some of the guesswork is eliminated.)</p><p>When working with <span class="emphasis"><em>pairs</em></span> (tuples containing two values like the geometric points we discussed previously), you can use the <code class="literal">fst</code> and <code class="literal">snd</code> functions to retrieve the first and second values, respectively, as shown here.</p><a id="pro_id00260"/><pre class="programlisting">let slope p1 p2 =
  let x1 = <span class="strong"><strong>fst</strong></span> p1
  let y1 = <span class="strong"><strong>snd</strong></span> p1
  let x2 = <span class="strong"><strong>fst</strong></span> p2
  let y2 = <span class="strong"><strong>snd</strong></span> p2
  (y1 - y2) / (x1 - x2)

slope (13.0, 8.0) (1.0, 2.0)</pre><p>Notice how we define bindings for the various coordinates with the <code class="literal">fst</code> and <code class="literal">snd</code> functions. As you can see, however, extracting each value this way can get pretty tedious and these functions work only with pairs; if you were to try either against a <span class="emphasis"><em>triple</em></span> (a tuple with three values), you’d get a type mismatch. (The reason is that at their core, tuples compile to one of the nine generic overloads of the <code class="literal">Tuple</code> class.) Aside from sharing a common name, the tuple classes are independent of each other and are otherwise incompatible.</p><p>A more practical approach to extract tuple values involves introducing a <span class="emphasis"><em>Tuple pattern</em></span>. Tuple patterns allow you to specify an identifier for each value in the tuple by separating the identifiers with commas. For example, here’s the <code class="literal">slope</code> function revised to use Tuple patterns instead of the pair functions.</p><a id="pro_id00261"/><pre class="programlisting">let slope p1 p2 =
  let <span class="strong"><strong>x1, y1</strong></span> = p1
  let <span class="strong"><strong>x2, y2</strong></span> = p2
  (y1 - y2) / (x1 - x2)</pre><p><a id="iddle1077" class="indexterm"/><a id="iddle1547" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle1976" class="indexterm"/><a id="iddle2037" class="indexterm"/><a id="iddle2118" class="indexterm"/>You can see how Tuple patterns may help, but you need to be careful with them. If your pattern doesn’t match the number of values in the tuple, you’ll get a type mismatch.</p><p>Fortunately, unlike the pair functions, resolving the problem is simply a matter of adding or removing identifiers. If you don’t care about a particular value in your Tuple pattern, you can ignore it with the Wildcard pattern (<code class="literal">_</code>). For instance, if you have three-dimensional coordinates but care only about the z-coordinate, you could ignore the x- and y-values as follows:</p><a id="pro_id00262"/><pre class="programlisting">&gt; let <span class="strong"><strong>_, _, z</strong></span> = (10.0, 10.0, 10.0);;

val z : int = 10</pre><p>Tuple patterns aren’t limited to <code class="literal">let</code> bindings. In fact, we can make a further revision to the <code class="literal">slope</code> function and include the patterns right in the function signature!</p><a id="pro_id00263"/><pre class="programlisting">let slope <span class="strong"><strong>(x1, y1) (x2, y2)</strong></span> = (y1 - y2) / (x1 - x2)</pre></div><div class="sect3" title="Equality Semantics"><div class="titlepage"><div><div><h4 class="title" id="equality_semantics">Equality Semantics</h4></div></div></div><p>Despite the fact that they’re formally reference types, each of the built-in tuple types implements the <code class="literal">IStructuralEquatable</code> interface. This ensures that all equality comparisons involve comparing the individual component values rather than checking that two tuple instances reference the same <code class="literal">Tuple</code> object in memory. In other words, two tuple instances are considered equal when the corresponding component values in each instance are the same, as shown here:</p><a id="pro_id00264"/><pre class="programlisting">&gt; <span class="strong"><strong>(1, 2) = (1, 2);;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>(2, 1) = (1, 2);;</strong></span>
val it : bool = false</pre><p>For the same reasons that the <code class="literal">fst</code> and <code class="literal">snd</code> functions work only with pairs, comparing tuples of different lengths will cause an error.</p></div><div class="sect3" title="Syntactic Tuples"><div class="titlepage"><div><div><h4 class="title" id="syntactic_tuples">Syntactic Tuples</h4></div></div></div><p>So far, all of the tuples we’ve looked have been concrete ones, but F# also includes <span class="emphasis"><em>syntactic tuples</em></span>. For the most part, syntactic tuples are how F# works around noncurried functions in other languages. Because F# functions always accept a single parameter, but functions in C# and Visual Basic can <a id="iddle1714" class="indexterm"/><a id="iddle2036" class="indexterm"/>accept more than one, in order to call functions from libraries written in other languages you can use a syntactic tuple and let the compiler work out the details.</p><p>For example, the <code class="literal">String</code> class’s <code class="literal">Format</code> method accepts both a format string and a <code class="literal">params</code> array of values. If <code class="literal">String.Format</code> were a curried function, you’d expect its signature to be something like <code class="literal">Format : format:string -&gt; params args : obj [] -&gt; string</code>, but it’s not. Instead, if you hover your cursor over the function name in Visual Studio, you’ll see that its signature is actually <code class="literal">Format(format:string, params args : obj []) : string</code>. This distinction is significant because it means that the arguments must be applied as a group rather than individually as they would with curried functions. If you were to try invoking the method as a curried F# function, you’d get an error like this:</p><a id="pro_id00265"/><pre class="programlisting">&gt; <span class="strong"><strong>System.String.Format "hello {0}" "Dave";;</strong></span>

  System.String.Format "hello {0}" "Dave";;
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

stdin(3,1): error FS0003: This value is not a function and cannot be applied</pre><p>The correct way to call <code class="literal">String.Format</code> in F# is with a syntactic tuple, like this:</p><a id="pro_id00266"/><pre class="programlisting">&gt; <span class="strong"><strong>System.String.Format ("hello {0}", "Dave");;</strong></span>
val it : string = "hello Dave"</pre><p>You’ve probably noticed that F# generally doesn’t require parentheses around arguments when calling a function; it uses parentheses primarily to establish precedence. Because functions are applied from left to right, you’ll mainly use parentheses in a function call to pass the result of another function as an argument. In this case, the parentheses around the arguments are necessary. Without them, the left-to-right evaluation would cause the compiler to essentially treat the expression as <code class="literal">((System.String.Format "hello {0}"), "Dave")</code>. In general, it’s good practice to include parentheses around syntactic tuples in order to remove any ambiguity.</p></div><div class="sect3" title="Out Parameters"><div class="titlepage"><div><div><h4 class="title" id="out_parameters">Out Parameters</h4></div></div></div><p>F# doesn’t directly support <code class="literal">out</code> parameters—parameters passed by reference with values assigned in the method body so they can be returned to the caller. To fully support the .NET Framework, however, F# needs a way to access <code class="literal">out</code> parameter values. For example, the <code class="literal">TryParse</code> methods on the various numeric data type classes attempt to convert a string to the corresponding numeric type and return a Boolean value indicating success or failure. If the conversion succeeds, the <code class="literal">TryParse</code> methods set the <code class="literal">out</code> parameter to the appropriate converted value. For instance, calling <code class="literal">System.Int32.TryParse</code> with <code class="literal">"10"</code> would return <code class="literal">true</code> and set the <code class="literal">out</code> parameter to <code class="literal">10</code>. Similarly, calling the same function with <code class="literal">"abc"</code> would return <code class="literal">false</code> and leave the <code class="literal">out</code> parameter unchanged.</p><p>In C#, calling <code class="literal">System.Int32.TryParse</code> would look like this:</p><a id="pro_id00267"/><pre class="programlisting">  // C#
① int v;
  var r = System.Int32.TryParse("10", <span class="strong"><strong>out v</strong></span>);</pre><p>The problem with <code class="literal">out</code> parameters in a functional language is that they require a side effect, as shown by the uninitialized variable at ①. To work around this problem, the F# compiler converts the return value and <code class="literal">out</code> parameter to a pair. Therefore, when you invoke a method with an <code class="literal">out</code> parameter in F#, you treat it exactly like any other tuple-returning function.</p><p>Calling the same <code class="literal">Int32.TryParse</code> method in F# looks like this:</p><a id="pro_id00268"/><pre class="programlisting">// F#
let r, v = System.Int32.TryParse "10"</pre><p>For a behind-the-scenes look at the generated class, we can once again turn to ILSpy to see how it’s represented in C#.</p><a id="pro_id00269"/><pre class="programlisting">// C#
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
namespace &lt;StartupCode$Samples&gt;
{
  internal static class $Samples
  {
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    internal static readonly Tuple&lt;bool, int&gt; patternInput@3;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    internal static readonly int v@3;
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    internal static readonly bool r@3;
    [DebuggerBrowsable(DebuggerBrowsableState.Never), DebuggerNonUserCode, CompilerGenerated]
    internal static int init@;
  ① static $Samples()
    {
      int item = 0;
      $Samples.patternInput@3 = ② new Tuple&lt;bool, int&gt;(③ int.TryParse("10", out item), item);
      ④ $Samples.v@3 = Samples.patternInput@3.Item2;
      ⑤ $Samples.r@3 = Samples.patternInput@3.Item1;
    }
  }
}</pre><p>Here, the F# compiler wrapped the <code class="literal">Int32.TryParse</code> call inside a static class. The generated class’s static constructor ① invokes <code class="literal">TryParse</code> at ③ and wraps the results in a tuple at ②. Then, the internal <code class="literal">v@3</code> and <code class="literal">r@3</code> fields are assigned to the <code class="literal">out</code> parameter value and the return value at ④ and ⑤, respectively. In turn, the <code class="literal">v</code> and <code class="literal">r</code> values defined by the <code class="literal">let</code> binding are compiled to read-only properties that return the <code class="literal">v@3</code> and <code class="literal">r@3</code> values.</p></div></div><div class="sect2" title="Record Types"><div class="titlepage"><div><div><h3 class="title" id="record_types">Record Types</h3></div></div></div><p><a id="iddle1830" class="indexterm"/><a id="iddle1831" class="indexterm"/><a id="iddle1833" class="indexterm"/><a id="iddle1836" class="indexterm"/><a id="iddle1837" class="indexterm"/><a id="iddle2051" class="indexterm"/>Like tuples, <span class="emphasis"><em>record types</em></span> allow you to group values in a single immutable construct. You might think of them as bridging the functional gap between tuples and your own classes. Record types provide many of the same conveniences as tuples, like simple syntax and value equality semantics, while offering you some control over their internal structure and allowing you to add custom functionality.</p><div class="sect3" title="Defining Record Types"><div class="titlepage"><div><div><h4 class="title" id="defining_record_types">Defining Record Types</h4></div></div></div><p>Record type definitions consist of the <code class="literal">type</code> keyword, an identifier, and a list of labels with type annotations all enclosed in braces. For example, this listing shows a simple record type representing an RGB color.</p><a id="pro_id00270"/><pre class="programlisting">&gt; <span class="strong"><strong>type rgbColor = { R : byte; G : byte; B : byte };;</strong></span>

type rgbColor =
  {R: byte;
   G: byte;
   B: byte;}</pre><p>If you take a peek at what the compiler generates from this definition, you’ll see a sealed class with read-only properties, equality semantics, and a single constructor to initialize all values.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note03"/>Note</h3><p><span class="emphasis"><em>When defining record types on a single line, you must separate each label and type annotation pair by semicolons. If you place each pair on a separate line, you can safely omit the semicolons.</em></span></p></div></div><div class="sect3" title="Creating Records"><div class="titlepage"><div><div><h4 class="title" id="creating_records">Creating Records</h4></div></div></div><p>New records are created via <span class="emphasis"><em>record expressions</em></span>. Record expressions allow you to specify a value for each label in the record type. For example, you could create a new <code class="literal">rgbColor</code> instance using a record expression, as shown next. (Note that, as when defining a record type, you must separate each label or assignment pair by semicolons or place it on a line of its own.)</p><a id="pro_id00271"/><pre class="programlisting">&gt; <span class="strong"><strong>let red = { R = 255uy; G = 0uy; B = 0uy };;</strong></span>

val red : rgbColor = {R = 255uy;
                      G = 0uy;
                      B = 0uy;}</pre><p>Notice that nowhere in the record expression do we include an explicit reference to the <code class="literal">rgbColor</code> type. This is another example of F#’s type inference engine at work. Based on the labels alone, the compiler was able to infer that we were creating an instance of <code class="literal">rgbColor</code>. Because the compiler relies on the labels rather than position to determine the correct type, order doesn’t matter. This means that you can place the label and value pairs in any order. Here, we create an <code class="literal">rgbColor</code> instance with the labels in <code class="literal">G</code>, <code class="literal">B</code>, <code class="literal">R</code> order.</p><a id="pro_id00272"/><pre class="programlisting">&gt; <span class="strong"><strong>let red = { G = 0uy; B = 0uy; R = 255uy };;</strong></span>

val red : rgbColor = {R = 255uy;
                      G = 0uy;
                      B = 0uy;}</pre><p><a id="iddle1839" class="indexterm"/>Unlike with tuples, we don’t need to use special value extraction functions like <code class="literal">fst</code> or <code class="literal">snd</code> with record types, because each value can be accessed by its label. For instance, a function that converts an <code class="literal">rgbColor</code> value to its hexadecimal string equivalent might look like this:</p><a id="pro_id00273"/><pre class="programlisting">let rgbColorToHex (c : rgbColor) =
  sprintf "#%02X%02X%02X" <span class="strong"><strong>c.R c.G c.B</strong></span></pre></div><div class="sect3" title="Avoiding Naming Conflicts"><div class="titlepage"><div><div><h4 class="title" id="avoiding_naming_conflicts">Avoiding Naming Conflicts</h4></div></div></div><p>The compiler can usually infer the correct type, but it’s possible to define two record types with the same structure. Consider what happens when you add a <code class="literal">color</code> type with the same structure as <code class="literal">rgbColor</code>.</p><a id="pro_id00274"/><pre class="programlisting">&gt; <span class="strong"><strong>type rgbColor = { R : byte; G : byte; B : byte }</strong></span>
<span class="strong"><strong>type color = { R : byte; G : byte; B : byte };;</strong></span>

type rgbColor =
  {R: byte;
   G: byte;
   B: byte;}
type color =
  {R: byte;
   G: byte;
   B: byte;}

&gt; <span class="strong"><strong>let red = { R = 255uy; G = 0uy; B = 0uy };;</strong></span>

val red : ① color = {R = 255uy;
                     G = 0uy;
                     B = 0uy;}</pre><p>Despite having two record types with the same structure, type inference still succeeds, but notice at ① that the resulting type is <code class="literal">color</code>. Due to F#’s top-down evaluation, the compiler uses the most recently defined type that matches the labels. If your goal was to define <code class="literal">red</code> as <code class="literal">color</code> you’d be fine, but if you wanted <code class="literal">rgbColor</code> instead you’d have to be a bit more explicit in your record expression and include the type name, as shown here:</p><a id="pro_id00275"/><pre class="programlisting">&gt; <span class="strong"><strong>let red = {</strong></span> ① <span class="strong"><strong>rgbColor.R = 255uy; G = 0uy; B = 0uy };;</strong></span>

val red : ② rgbColor = {R = 255uy;
                        G = 0uy;
                        B = 0uy;}</pre><p><a id="iddle1005" class="indexterm"/><a id="iddle1161" class="indexterm"/><a id="iddle1661" class="indexterm"/><a id="iddle1829" class="indexterm"/><a id="iddle1835" class="indexterm"/><a id="iddle1838" class="indexterm"/>By qualifying one of the names with the type name at ①, you bypass type inference and the correct type is resolved ②. (Although you can technically qualify the type on any name, the convention is to do it on either the first one or all of them.)</p></div><div class="sect3" title="Copying Records"><div class="titlepage"><div><div><h4 class="title" id="copying_records">Copying Records</h4></div></div></div><p>Not only can you use record expressions to create new record instances from scratch, but you can also use them to create new record instances from existing ones by copying values forward and setting new values for one or more properties. The alternate syntax, called a <span class="emphasis"><em>copy and update record expression</em></span>, makes it easy to create yellow from red, as shown here:</p><a id="pro_id00276"/><pre class="programlisting">&gt; let red = { R = 255uy; G = 0uy; B = 0uy }
let yellow = <span class="strong"><strong>{ red with G = 255uy };;</strong></span>

val red : color = {R = 255uy;
                   G = 0uy;
                   B = 0uy;}
val yellow : color = {R = 255uy;
                      G = 255uy;
                      B = 0uy;}</pre><p>To specify new values for multiple properties, separate them with semicolons.</p></div><div class="sect3" title="Mutability"><div class="titlepage"><div><div><h4 class="title" id="mutability">Mutability</h4></div></div></div><p>Like virtually everything else in F#, record types are immutable by default. However, because their syntax is so convenient, they’re commonly used in place of classes. In many cases, though, these scenarios require mutability. To make record type properties mutable within F#, use the <code class="literal">mutable</code> keyword just as with a <code class="literal">let</code> binding. For instance, you could make all of <code class="literal">rgbColor</code>’s members mutable like this:</p><a id="pro_id00277"/><pre class="programlisting">&gt; <span class="strong"><strong>type rgbColor = { mutable R : byte</strong></span>
                  <span class="strong"><strong>mutable G : byte</strong></span>
                  <span class="strong"><strong>mutable B : byte };;</strong></span>

type rgbColor =
  {mutable R: byte;
   mutable G: byte;
   mutable B: byte;}</pre><p>When a record type property is mutable, you can change its value with the standard assignment operator (<code class="literal">&lt;-</code>) like this:</p><a id="pro_id00278"/><pre class="programlisting">let myColor = { R = 255uy; G = 255uy; B = 255uy }
myColor.G &lt;- 100uy</pre><div class="sidebar"><a id="climutable"/><div class="sidebar-title">Climutable</div><p><a id="iddle1235" class="indexterm"/><a id="iddle1662" class="indexterm"/><a id="iddle1834" class="indexterm"/>Although record types support binary serialization by default, other forms of serialization require a default constructor and writable properties. To allow for more situations where record types can be used in favor of classes, the F# team introduced the <code class="literal">CLIMutable</code> attribute in F# 3.0.</p><p>Decorating a record type with this attribute instructs the compiler to include a default constructor and to make the generated properties read/write, but the compiler doesn’t expose those capabilities within F#. Even though the generated properties are writable, unless they’re explicitly marked as mutable with the <code class="literal">mutable</code> keyword in the record type definition, their values can’t be changed in F# code. For this reason, be careful when using <code class="literal">CLIMutable</code> record types across language boundaries to ensure that you don’t inadvertently change something.</p></div></div><div class="sect3" title="Additional Members"><div class="titlepage"><div><div><h4 class="title" id="additional_members">Additional Members</h4></div></div></div><p>Because record types are really just syntactic sugar for classes, you can define additional members just as you would on a class. For example, you could augment <code class="literal">rgbColor</code> with a method that returns its hexadecimal string equivalent like this:</p><a id="pro_id00279"/><pre class="programlisting">type rgbColor = { R : byte; G : byte; B : byte }
                <span class="strong"><strong>member x.ToHexString() =</strong></span>
                  <span class="strong"><strong>sprintf "#%02X%02X%02X" x.R x.G x.B</strong></span></pre><p>Now you can call the <code class="literal">ToHexString</code> method on any <code class="literal">rgbColor</code> instance.</p><a id="pro_id00280"/><pre class="programlisting">&gt; <span class="strong"><strong>red.ToHexString();;</strong></span>
val it : string = "#FF0000"</pre><p>Additional members on record types can also be static. For example, suppose you wanted to expose a few common colors as static properties on a record type. You could do this:</p><a id="pro_id00281"/><pre class="programlisting">type rgbColor = { R : byte; G : byte; B : byte }
                -- <span class="emphasis"><em>snip</em></span> --
                <span class="strong"><strong>static member Red = { R = 255uy; G = 0uy; B = 0uy }</strong></span>
                <span class="strong"><strong>static member Green = { R = 0uy; G = 255uy; B = 0uy }</strong></span>
                <span class="strong"><strong>static member Blue = { R = 0uy; G = 0uy; B = 255uy }</strong></span></pre><p>The static <code class="literal">Red</code>, <code class="literal">Green</code>, and <code class="literal">Blue</code> properties behave like any other static member and can be used anywhere you need an <code class="literal">rgbColor</code> instance.</p><a id="pro_id00282"/><pre class="programlisting">&gt; <span class="strong"><strong>rgbColor.Red.ToHexString();;</strong></span>
val it : string = "#FF0000"</pre><p><a id="iddle1313" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1686" class="indexterm"/><a id="iddle1702" class="indexterm"/><a id="iddle1703" class="indexterm"/><a id="iddle1706" class="indexterm"/><a id="iddle1708" class="indexterm"/>You can also create custom operators for your record types as static members. Let’s implement the addition operator to add two <code class="literal">rgbColor</code> instances.</p><a id="pro_id00283"/><pre class="programlisting">open System
type rgbColor = { R : byte; G : byte; B : byte }
                -- <span class="emphasis"><em>snip</em></span> --
                <span class="strong"><strong>static member (+) (l : rgbColor, r : rgbColor) =</strong></span>
                  <span class="strong"><strong>{ R = Math.Min(255uy, l.R + r.R)</strong></span>
                   <span class="strong"><strong>G = Math.Min(255uy, l.G + r.G)</strong></span>
                   <span class="strong"><strong>B = Math.Min(255uy, l.B + r.B) }</strong></span></pre><p>The operator overload on <code class="literal">rgbColor</code> is defined and invoked like any other operator:</p><a id="pro_id00284"/><pre class="programlisting">&gt; <span class="strong"><strong>let yellow = { R = 255uy; G = 0uy; B = 0uy } +</strong></span>
             <span class="strong"><strong>{ R = 0uy; G = 255uy; B = 0uy };;</strong></span>

val yellow : rgbColor = {R = 255uy;
                         G = 255uy;
                         B = 0uy;}</pre></div></div></div><div class="sect1" title="Discriminated Unions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="discriminated_unions">Discriminated Unions</h2></div></div></div><p><span class="emphasis"><em>Discriminated unions</em></span> are user-defined data types whose values are restricted to a known set of values called <span class="emphasis"><em>union cases</em></span>. There are no equivalent structures in the other popular .NET languages.</p><p>At first glance, you might mistake some simple discriminated unions for enumerations because their syntax is so similar, but they’re entirely different constructs. For one, enumerations simply define labels for known integral values, but they aren’t restricted to those values. By contrast, the only valid values for discriminated unions are their union cases. Furthermore, each union case can either stand on its own or contain associated immutable data.</p><p>The built-in <code class="literal">Option&lt;'T&gt;</code> type highlights each of these points. We’re really only interested in its definition here, so let’s take a look at that.</p><a id="pro_id00285"/><pre class="programlisting">type Option&lt;'T&gt; =
| None
| Some of 'T</pre><p><code class="literal">Option&lt;'T&gt;</code> defines two cases, <code class="literal">None</code> and <code class="literal">Some</code>. <code class="literal">None</code> is an empty union case, meaning that it doesn’t contain any associated data. On the other hand, <code class="literal">Some</code> has an associated instance of <code class="literal">'T</code> as indicated by the <code class="literal">of</code> keyword.</p><p><a id="iddle2052" class="indexterm"/>To demonstrate how discriminated unions enforce a specific set of values, let’s define a simple function that accepts a generic option and writes out the associated value when the option is <code class="literal">Some</code>, or <code class="literal">"None"</code> when the option is <code class="literal">None</code>:</p><a id="pro_id00286"/><pre class="programlisting">let showValue (v : _ option) =
  printfn "%s" (match v with
                | Some x -&gt; x.ToString()
                | None -&gt; "None")</pre><p>When we invoke this function, we simply need to provide one of the option cases:</p><a id="pro_id00287"/><pre class="programlisting">&gt; <span class="strong"><strong>Some 123 |&gt; showValue;;</strong></span>
123
val it : unit = ()
&gt; <span class="strong"><strong>Some "abc" |&gt; showValue;;</strong></span>
abc
val it : unit = ()
&gt; <span class="strong"><strong>None |&gt; showValue;;</strong></span>
None
val it : unit = ()</pre><p>Notice how in each of the three calls to <code class="literal">showValue</code>, we specified only the union case names. The compiler resolved both <code class="literal">Some</code> and <code class="literal">None</code> as <code class="literal">Option&lt;'T&gt;</code>. (In the event of a naming conflict, you can qualify the case names with the discriminated union name just as you would with a record type.) However, if you were to call <code class="literal">showValue</code> with a value other than <code class="literal">Some</code> or <code class="literal">None</code>, the compiler will raise an error like this:</p><a id="pro_id00288"/><pre class="programlisting">&gt; <span class="strong"><strong>showValue "xyz";;</strong></span>

  showValue "xyz";;
  ----------^^^^^

stdin(9,11): error FS0001: This expression was expected to have type
    Option&lt;'a&gt;
but here has type
    string</pre><div class="sect2" title="Defining Discriminated Unions"><div class="titlepage"><div><div><h3 class="title" id="defining_discriminated_unions">Defining Discriminated Unions</h3></div></div></div><p>Like other types, discriminated union definitions begin with the <code class="literal">type</code> keyword. Union cases are delimited with bars. The bar before the first union case is optional, but omitting it when there’s only one case can be confusing because it will make the definition look like a type abbreviation. In fact, if you omit the bar in a single-case discriminated union and there is no data associated with the case, the compiler will treat the definition as a type abbreviation when there is a naming conflict with another type.</p><p><a id="iddle1316" class="indexterm"/>The normal rules for identifiers apply when you are defining union cases, with one exception: Union case names must begin with an uppercase letter to help the compiler differentiate union cases from other identifiers in pattern matching. If a case name does not begin with an uppercase letter, the compiler will raise an error.</p><p>In practice, discriminated unions typically serve one of three purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Representing simple object hierarchies</p></li><li class="listitem"><p>Representing tree structures</p></li><li class="listitem"><p>Replacing type abbreviations</p></li></ul></div><div class="sect3" title="Simple Object Hierarchies"><div class="titlepage"><div><div><h4 class="title" id="simple_object_hierarchies">Simple Object Hierarchies</h4></div></div></div><p>Discriminated unions are commonly used to represent simple object hierarchies. In fact, they excel at this task so much that they’re often used as a substitute for formal classes and inheritance.</p><p>Imagine working on a system that needs some basic geometry functionality. In an object-oriented environment, such functionality would probably consist of an <code class="literal">IShape</code> interface and a number of concrete shape classes like <code class="literal">Circle</code>, <code class="literal">Rectangle</code>, and <code class="literal">Triangle</code>, with each implementing <code class="literal">IShape</code>. A possible implementation might look like this:</p><a id="pro_id00289"/><pre class="programlisting">type IShape = interface end

type Circle(r : float) =
  interface IShape
  member x.Radius = r

type Rectangle(w : float, h : float) =
  interface IShape
  member x.Width = w
  member x.Height = h

type Triangle(l1 : float, l2 : float, l3 : float) =
  interface IShape
  member x.Leg1 = l1
  member x.Leg2 = l2
  member x.Leg3 = l3</pre><p>Discriminated unions offer a cleaner alternative that is less prone to side effects. Here’s what that same object hierarchy might look like as a discriminated union:</p><a id="pro_id00290"/><pre class="programlisting">type Shape =
/// Describes a circle by its radius
| Circle of float
/// Describes a rectangle by its width and height
| Rectangle of ① float * float
/// Describes a triangle by its three sides
| Triangle of ② float * float * float</pre><div class="sidebar"><a id="itapostrophes_bigger_on_the_inside"/><div class="sidebar-title">It’s Bigger on the Inside</div><p>Discriminated unions are much more complex than their syntax might lead you to believe. Each discriminated union compiles to an abstract class responsible for handling equality and comparison semantics as well as type checking and union case creation. Similarly, each union case compiles to a class that is both nested within and inherits from the union class. The union case classes define the properties and backing stores for each of their associated values along with an internal constructor.</p><p>Although it’s possible to replicate some of the discriminated union functionality within other languages, doing so is nontrivial. Proving just how complex discriminated unions really are, inspecting the compiled <code class="literal">Shape</code> type we just defined in ILSpy reveals nearly 700 lines of C# code!</p></div><p>The <code class="literal">Shape</code> type defines three cases: <code class="literal">Circle</code>, <code class="literal">Rectangle</code>, and <code class="literal">Triangle</code>. Each case has at least one attached value specific to the shape it represents. Notice at ① and ② how the tuple syntax is used to associate multiple data values with a case. But despite using the tuple syntax, cases don’t actually compile to tuples. Instead, each associated data item compiles to an individual property that follows the tuple naming pattern (that is, <code class="literal">Item1</code>, <code class="literal">Item2</code>, and so on). This distinction is important because there’s no direct conversion from a union case to a tuple, meaning that you can’t use them interchangeably. The only real exception to this rule is that when the types are wrapped in parentheses the compiler will interpret the grouping as a tuple. In other words, the compiler treats <code class="literal">of string * int</code> and <code class="literal">of (string * int)</code> differently; the former is tuple-like, while the latter actually is a tuple. Unless you really need a true tuple, though, use the default format.</p><p>As you’d expect, creating <code class="literal">Shape</code> instances is the same as creating <code class="literal">Option&lt;'T&gt;</code> instances. For example, here’s how to create an instance of each case:</p><a id="pro_id00291"/><pre class="programlisting">let c = Circle(3.0)
let r = Rectangle(10.0, 12.0)
let t = Triangle(25.0, 20.0, 7.0)</pre><p>One of the major annoyances with the tuple syntax for multiple associated values is that it’s easy to forget what each position represents. To work around the issue, include XML documentation comments—like those preceding each case in this section’s <code class="literal">Shape</code> definition—as a reminder.</p><p>Fortunately, relief is available. One of the language enhancements in F# 3.1 is support for named union type fields. The refined syntax resembles a hybrid of the current tupled syntax and type-annotated field definitions. For example, under the new syntax, <code class="literal">Shape</code> could be redefined as follows.</p><a id="pro_id00292"/><pre class="programlisting">type Shape =
| Circle of Radius : float
| Rectangle of Width : float * Height : float
| Triangle of Leg1 : float * Leg2 : float * Leg3 : float</pre><p><a id="iddle1317" class="indexterm"/><a id="iddle1319" class="indexterm"/>For discriminated unions defined with the F# 3.1 syntax, creating new case instances is significantly more developer friendly—not only because the labels appear in IntelliSense, but also because you can use named arguments like this:</p><a id="pro_id00293"/><pre class="programlisting">let c = Circle(Radius = 3.0)
let r = Rectangle(Width = 10.0, Height = 12.0)
let t = Triangle(Leg1 = 25.0, Leg2 = 20.0, Leg3 = 7.0)</pre></div><div class="sect3" title="Tree Structures"><div class="titlepage"><div><div><h4 class="title" id="tree_structures">Tree Structures</h4></div></div></div><p>Discriminated unions can also be <span class="emphasis"><em>self-referencing</em></span>, meaning that the data associated with a union case can be another case from the same union. This is handy for creating simple trees like this one, which represents a rudimentary markup structure:</p><a id="pro_id00294"/><pre class="programlisting">type Markup =
| ContentElement of string * ① Markup list
| EmptyElement of string
| Content of string</pre><p>Most of this definition should be familiar by now, but notice that the <code class="literal">ContentElement</code> case has an associated string and list of <code class="literal">Markup</code> values.</p><p>The nested <code class="literal">Markup</code> list ① makes it trivial to construct a simple HTML document like the following. Here, <code class="literal">ContentElement</code> nodes represent elements (such as <code class="literal">html</code>, <code class="literal">head</code>, and <code class="literal">body</code>) that contain additional content, while <code class="literal">Content</code> nodes represent raw text contained within a <code class="literal">ContentElement</code>.</p><a id="pro_id00295"/><pre class="programlisting">let movieList =
  ContentElement("html",
    [ ContentElement("head", [ ContentElement("title", [ Content "Guilty Pleasures" ])])
      ContentElement("body",
        [ ContentElement("article",
            [ ContentElement("h1", [ Content "Some Guilty Pleasures" ])
              ContentElement("p",
                [ Content "These are "
                  ContentElement("strong", [ Content "a few" ])
                  Content " of my guilty pleasures" ])
              ContentElement("ul",
                [ ContentElement("li", [ Content "Crank (2006)" ])
                  ContentElement("li", [ Content "Starship Troopers (1997)" ])
                  ContentElement("li", [ Content "RoboCop (1987)" ])])])])])</pre><p><a id="iddle1073" class="indexterm"/><a id="iddle1318" class="indexterm"/><a id="iddle1320" class="indexterm"/><a id="iddle1628" class="indexterm"/><a id="iddle1866" class="indexterm"/><a id="iddle1969" class="indexterm"/><a id="iddle2067" class="indexterm"/>To convert the preceding tree structure to an actual HTML document, you could write a simple recursive function with a match expression to handle each union case, like this:</p><a id="pro_id00296"/><pre class="programlisting">let rec toHtml markup =
  match markup with
  | ① ContentElement (tag, children) -&gt;
        use w = new System.IO.StringWriter()
        children
          |&gt; Seq.map toHtml
          |&gt; Seq.iter (fun (s : string) -&gt; w.Write(s))
        sprintf "&lt;%s&gt;%s&lt;/%s&gt;" tag (w.ToString()) tag
  | ② EmptyElement (tag) -&gt; sprintf "&lt;%s /&gt;" tag
  | ③ Content (c) -&gt; sprintf "%s" c</pre><p>The <code class="literal">match</code> expression is used here roughly like a <code class="literal">switch</code> statement in C# or a <code class="literal">SELECT CASE</code> statement in Visual Basic. Each match case, denoted by a vertical pipe (<code class="literal">|</code>), matches against an Identifier pattern that includes the union case name and identifiers for each of its associated values. For instance, the match case at ① matches <code class="literal">ContentElement</code> items and represents the associated values with the <code class="literal">tag</code> and <code class="literal">children</code> identifiers within the case body (the part after the arrow). Likewise, the match cases at ② and ③ match the <code class="literal">EmptyElement</code> and <code class="literal">Content</code> cases, respectively. (Note that because match expressions return a value, each match case’s return type must be the same.)</p><p>Invoking the <code class="literal">toHtml</code> function with <code class="literal">movieList</code> results in the following HTML (formatted for readability). As you look over the resulting HTML, try tracing each element back to its node in <code class="literal">movieList</code>.</p><a id="pro_id00297"/><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Guilty Pleasures&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;article&gt;
        &lt;h1&gt;Some Guilty Pleasures&lt;/h1&gt;
        &lt;p&gt;These are &lt;strong&gt;a few&lt;/strong&gt; of my guilty pleasures&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;Crank (2006)&lt;/li&gt;
            &lt;li&gt;Starship Troopers (1997)&lt;/li&gt;
            &lt;li&gt;RoboCop (1987)&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/article&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><div class="sect3" title="Replacing Type Abbreviations"><div class="titlepage"><div><div><h4 class="title" id="replacing_type_abbreviations">Replacing Type Abbreviations</h4></div></div></div><p>Single-case discriminated unions can be a useful alternative to type abbreviations, which, while nice for aliasing existing types, don’t provide any additional type safety. For instance, suppose you’ve defined <code class="literal">UserId</code> as an <a id="iddle1506" class="indexterm"/><a id="iddle1746" class="indexterm"/>alias for <code class="literal">System.Guid</code> and you have a function <code class="literal">UserId -&gt; User</code>. Although the function accepts <code class="literal">UserId</code>, nothing prevents you from sending in an arbitrary <code class="literal">Guid</code>, no matter what that <code class="literal">Guid</code> actually represents.</p><p>Let’s extend the markup examples from the previous section to show how single-case discriminated unions can solve this problem. If you wanted to display the generated HTML in a browser, you could define a function like this:</p><a id="pro_id00298"/><pre class="programlisting">  open System.IO

① type HtmlString = string

  let displayHtml (html ②: HtmlString) =
    let fn = Path.Combine(Path.GetTempPath(), "HtmlDemo.htm")
    let bytes = System.Text.UTF8Encoding.UTF8.GetBytes html
    using (new FileStream(fn, FileMode.Create, FileAccess.Write))
          (fun fs -&gt; fs.Write(bytes, 0, bytes.Length))
    System.Diagnostics.Process.Start(fn).WaitForExit()
    File.Delete fn</pre><p>The actual mechanics of the <code class="literal">displayHtml</code> function aren’t important for this discussion. Instead, focus your attention on ① the <code class="literal">HtmlString</code> type abbreviation and ② the type annotation explicitly stating that the <code class="literal">html</code> parameter is an <code class="literal">HtmlString</code>.</p><p>It’s clear from the signature that the <code class="literal">displayHtml</code> function expects the supplied string to contain HTML, but because <code class="literal">HtmlString</code> is merely a type abbreviation there’s nothing ensuring that it actually is HTML. As written, both <code class="literal">movieList |&gt; toHtml |&gt; displayHtml</code> and <code class="literal">"abc123" |&gt; displayHtml</code> are valid.</p><p>To introduce a bit more type safety, we can replace the <code class="literal">HtmlString</code> definition with a single-case discriminated union, like this:</p><a id="pro_id00299"/><pre class="programlisting">type HtmlString = | HtmlString of string</pre><p>Now that <code class="literal">HtmlString</code> is a discriminated union, we need to change the <code class="literal">displayHtml</code> function to extract the associated string. We can do this in one of two ways. The first option requires us to change the function’s signature to include an Identifier pattern. Alternatively, we can leave the signature alone and introduce an intermediate binding (also using an Identifier pattern) for the associated value. The first option is cleaner, so that’s the approach we’ll use.</p><a id="pro_id00300"/><pre class="programlisting">let displayHtml <span class="strong"><strong>(HtmlString(html))</strong></span> =
  let fn = Path.Combine(Path.GetTempPath(), "HtmlDemo.htm")
  let bytes = System.Text.UTF8Encoding.UTF8.GetBytes html
  using (new FileStream(fn, FileMode.Create, FileAccess.Write))
        (fun fs -&gt; fs.Write(bytes, 0, bytes.Length))
  System.Diagnostics.Process.Start(fn).WaitForExit()
  File.Delete fn</pre><p><a id="iddle1314" class="indexterm"/><a id="iddle1507" class="indexterm"/><a id="iddle1747" class="indexterm"/>To call the <code class="literal">displayHtml</code> function, we only need to wrap the string from the <code class="literal">toHtml</code> function in an <code class="literal">HtmlString</code> instance and pass it to <code class="literal">displayHtml</code> as follows:</p><a id="pro_id00301"/><pre class="programlisting">HtmlString(movieList |&gt; toHtml) |&gt; displayHtml</pre><p>Finally, we can further simplify this code by revising the <code class="literal">toHtml</code> function to return an <code class="literal">HtmlString</code> instead of a string. One approach would look like this:</p><a id="pro_id00302"/><pre class="programlisting">let rec toHtml markup =
  match markup with
  | ContentElement (tag, children) -&gt;
        use w = new System.IO.StringWriter()
        children
          |&gt; Seq.map toHtml
          |&gt; Seq.iter (fun ① (HtmlString(html)) -&gt; w.Write(html))
        HtmlString (sprintf "&lt;%s&gt;%s&lt;/%s&gt;" tag (w.ToString()) tag)
  | EmptyElement (tag) -&gt; HtmlString (sprintf "&lt;%s /&gt;" tag)
  | Content (c) -&gt; HtmlString (sprintf "%s" c)</pre><p>In this revised version, we’ve wrapped each case’s return value in an <code class="literal">HtmlString</code> instance. Less trivial, though, is ①, which now uses an Identifier pattern to extract the HTML from the recursive result in order to write the raw text to the <code class="literal">StringWriter</code>.</p><p>With the <code class="literal">toHtml</code> function now returning an <code class="literal">HtmlString</code>, passing its result to <code class="literal">displayHtml</code> is simplified to this:</p><a id="pro_id00303"/><pre class="programlisting">movieList |&gt; toHtml |&gt; displayHtml</pre><p>Single-case discriminated unions can’t guarantee that any associated values are actually correct, but they do offer a little extra safety in that they force developers to make conscious decisions about what they’re passing to a function. Developers could create an <code class="literal">HtmlString</code> instance with an arbitrary string, but if they do they’ll be forced to think about whether the data is correct.</p></div></div><div class="sect2" title="Additional Members"><div class="titlepage"><div><div><h3 class="title" id="additional_members-id00008">Additional Members</h3></div></div></div><p>Like record types, discriminated unions also allow additional members. For example, we could redefine the <code class="literal">toHtml</code> function as a method on the <code class="literal">Markup</code> discriminated union as follows:</p><a id="pro_id00304"/><pre class="programlisting">type Markup =
| ContentElement of string * Markup list
| EmptyElement of string
| Content of string

member x.toHtml() =
  match x with
  | ContentElement (tag, children) -&gt;
        use w = new System.IO.StringWriter()
        children
          |&gt; Seq.map (fun m -&gt; m.toHtml())
          |&gt; Seq.iter (fun (HtmlString(html)) -&gt; w.Write(html))
        HtmlString (sprintf "&lt;%s&gt;%s&lt;/%s&gt;" tag (w.ToString()) tag)
  | EmptyElement (tag) -&gt; HtmlString (sprintf "&lt;%s /&gt;" tag)
  | Content (c) -&gt; HtmlString (sprintf "%s" c)</pre><p><a id="iddle1330" class="indexterm"/><a id="iddle1556" class="indexterm"/><a id="iddle1557" class="indexterm"/><a id="iddle1558" class="indexterm"/>Calling this method is like calling a method on any other type:</p><a id="pro_id00305"/><pre class="programlisting">movieList.toHtml() |&gt; displayHtml</pre></div></div><div class="sect1" title="Lazy Evaluation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="lazy_evaluation">Lazy Evaluation</h2></div></div></div><p>By default, F# uses <span class="emphasis"><em>eager evaluation</em></span>, which means that expressions are evaluated immediately. Most of the time, eager evaluation will be fine in F#, but sometimes you can improve perceived performance by deferring execution until the result is actually needed, through <span class="emphasis"><em>lazy evaluation</em></span>.</p><p>F# supports a few mechanisms for enabling lazy evaluation, but one of the easiest and most common ways is through the use of the <code class="literal">lazy</code> keyword. Here, the lazy keyword is used in conjunction with a series of expressions that includes a delay to simulate a long-running operation.</p><a id="pro_id00306"/><pre class="programlisting"><span class="strong"><strong>&gt; let lazyOperation = lazy (printfn "evaluating lazy expression"</strong></span>
                          <span class="strong"><strong>System.Threading.Thread.Sleep(1000)</strong></span>
                          <span class="strong"><strong>42);;</strong></span>

val lazyOperation : Lazy&lt;int&gt; = Value is not created.</pre><p>You can see the <code class="literal">lazy</code> keyword’s impact. If this expression had been eagerly evaluated, <code class="literal">evaluating lazy expression</code> would have been printed and there would have been an immediate one-second delay before it returned <code class="literal">42</code>. Instead, the expression’s result is an instance of the built-in <code class="literal">Lazy&lt;'T&gt;</code> type. In this case, the compiler inferred the return type and created an instance of <code class="literal">Lazy&lt;int&gt;</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note04"/>Note</h3><p><span class="emphasis"><em>Be careful using the lazy type across language boundaries. Prior to F# 3.0, the <code class="literal">Lazy&lt;'T&gt;</code> class was located in the FSharp.Core assembly. In .NET 4.0, <code class="literal">Lazy&lt;'T&gt;</code> was moved to <code class="literal">mscorlib</code>.</em></span></p></div><p>The <code class="literal">Lazy&lt;'T&gt;</code> instance created by the <code class="literal">lazy</code> keyword can be passed around like any other type, but the underlying expression won’t be evaluated until you force that evaluation by either calling the <code class="literal">Force</code> method or accessing its <code class="literal">Value</code> property, as shown next. Convention generally favors the <code class="literal">Force</code> method, but it doesn’t really matter whether you use it or the <code class="literal">Value</code> property to force evaluation. Internally, <code class="literal">Force</code> is just an extension method that wraps the <code class="literal">Value</code> property.</p><a id="pro_id00307"/><pre class="programlisting">&gt; <span class="strong"><strong>lazyOperation.Force() |&gt; printfn "Result: %i";;</strong></span>
evaluating lazy expression
Result: 42
val it : unit = ()</pre><p>Now that we’ve forced evaluation, we see that the underlying expression has printed its message, slept, and returned <code class="literal">42</code>. The <code class="literal">Lazy&lt;'T&gt;</code> type can also improve application performance through memoization. Once the associated expression is evaluated, its result is cached within the <code class="literal">Lazy&lt;'T&gt;</code> instance and used for subsequent requests. If the expression involves an expensive or time-consuming operation, the result can be dramatic.</p><p>To more effectively observe memoization’s impact, we can enable timing in FSI and repeatedly force evaluation as follows:</p><a id="pro_id00308"/><pre class="programlisting">&gt; <span class="strong"><strong>let lazyOperation = lazy (System.Threading.Thread.Sleep(1000); 42)</strong></span>
<span class="strong"><strong>#time "on";;</strong></span>

val lazyOperation : Lazy&lt;int&gt; = Value is not created.


--&gt; Timing now on

&gt; <span class="strong"><strong>lazyOperation.Force() |&gt; printfn "Result: %i";;</strong></span>
Result: 42
Real: ① 00:00:01.004, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0
val it : unit = ()
&gt; <span class="strong"><strong>lazyOperation.Force() |&gt; printfn "Result: %i";;</strong></span>
Result: 42
Real: ② 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0
val it : unit = ()
&gt; <span class="strong"><strong>lazyOperation.Force() |&gt; printfn "Result: %i";;</strong></span>
Result: 42
Real: ③ 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0
val it : unit = ()</pre><p>As you can see at ①, the first time <code class="literal">Force</code> is called we incur the expense of putting the thread to sleep. The subsequent calls at ② and ③ complete instantaneously because the memoization mechanism has cached the result.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00009">Summary</h2></div></div></div><p>As you’ve seen in this chapter, functional programming requires a different mindset than object-oriented programming. While object-oriented programming emphasizes managing system state, functional programming is more concerned with program correctness and predictability through the application of side-effect-free functions to data. Functional languages like F# treat functions as data. In doing so, they allow for greater composability within systems through concepts like higher-order functions, currying, partial application, pipelining, and function composition. Functional data types like tuples, record types, and discriminated unions help you write correct code by letting you focus on the problem you’re trying to solve instead of attempting to satisfy the compiler.</p></div></section></body></html>