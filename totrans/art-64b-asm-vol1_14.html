<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="707" id="Page_707"/>12</span><br/>
<span class="ChapterTitle">Bit Manipulation</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Manipulating bits in memory is, perhaps, the feature for which assembly language is most famous. Even the C programming language, known for bit manipulation, doesn’t provide as complete a set of bit-manipulation operations.</p>
<p>This chapter discusses how to manipulate strings of bits in memory and registers by using x86-64 assembly language. It begins with a review of the bit-manipulation instructions covered thus far, introduces a few new instructions, then reviews information on packing and unpacking bit strings in memory, which is the basis for many bit-manipulation operations. Finally, this chapter discusses several bit-centric algorithms and their implementation in assembly language.</p>
<h2 id="h1-501089c12-0001">	12.1	What Is Bit Data, Anyway?</h2>
<p class="BodyFirst"><em>Bit manipulation</em> refers to working with <em>bit data</em>: data types that consist of strings of bits that are noncontiguous or not a multiple of 8 bits long. <span epub:type="pagebreak" title="708" id="Page_708"/>Generally, such bit objects will not represent numeric integers, although we will not place this restriction on our bit strings.</p>
<p>A <em>bit string</em> is a contiguous sequence of 1 or more bits. It does not have to start or end at any special point. For example, a bit string could start in bit 7 of a byte in memory and continue through to bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30 of EAX, consume the upper 2 bits of EAX, and then continue from bit 0 through bit 17 of EBX. In memory, the bits must be physically contiguous (that is, the bit numbers are always increasing except when crossing a byte boundary, and at byte boundaries the memory address increases by 1 byte). In registers, if a bit string crosses a register boundary, the application defines the continuation register, but the bit string always continues in bit 0 of that second register.</p>
<p>A <em>bit run </em>is a sequence of bits with all the same value. A <em>run of zeros </em>is a bit string that contains all 0s, and a <em>run of ones</em> is a bit string containing all 1s. The <em>first set bit</em> in a bit string is the bit position of the first bit containing a 1 in a bit string; that is, the first 1 bit following a possible run of zeros. A similar definition exists for the <em>first clear bit</em>. The <em>last set bit</em> is the last bit position in a bit string that contains 1s; the remainder of the string forms an uninterrupted run of zeros. A similar definition exists for the <em>last clear bit</em>.</p>
<p>A <em>bit set</em> is a collection of bits, not necessarily contiguous, within a larger data structure. For example, bits 0 to 3, 7, 12, 24, and 31 from a double word form a set of bits. Normally, we will deal with bit sets that are part of a <em>container object</em> (the data structure that encapsulates the bit set) no more than about 32 or 64 bits in size, though this limit is completely artificial. Bit strings are special cases of bit sets.</p>
<p>A <em>bit offset</em> is the number of bits from a boundary position (usually a byte boundary) to the specified bit. As noted in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we number the bits starting from 0 at the boundary location.</p>
<p>A <em>mask</em> is a sequence of bits that we’ll use to manipulate certain bits in another value. For example, the bit string 0000_1111_0000b, when it’s used with the <code>and</code> instruction, masks away (clears) all the bits except bits 4 through 7. Likewise, if you use the same value with the <code>or</code> instruction, it can set bits 4 through 7 in the destination operand. The term <em>mask</em> comes from the use of these bit strings with the <code>and</code> instruction. In those situations, the 1 and 0 bits behave like masking tape when you’re painting something; they pass through certain bits unchanged while masking out (clearing) the other bits.</p>
<p>Armed with these definitions, we’re ready to start manipulating some bits!</p>
<h2 id="h1-501089c12-0002">	12.2	Instructions That Manipulate Bits</h2>
<p class="BodyFirst">Bit manipulation generally consists of six activities: setting bits, clearing bits, inverting bits, testing and comparing bits, extracting bits from a bit string, and inserting bits into a bit string. The most basic bit-manipulation <span epub:type="pagebreak" title="709" id="Page_709"/>instructions are the <code>and</code>, <code>or</code>, <code>xor</code>, <code>not</code>, <code>test</code>, and shift and rotate instructions. The following paragraphs review these instructions, concentrating on how you could use them to manipulate bits in memory or registers.</p>
<h3 id="h2-501089c12-0001">12.2.1	The and Instruction</h3>
<p class="BodyFirst">The <code>and</code> instruction provides the ability to replace unwanted bits in a bit sequence with 0s. This instruction is especially useful for isolating a bit string or a bit set that is merged with other, unrelated data (or, at least, data that is not part of the bit string or bit set). For example, suppose that a bit string consumes bit positions 12 through 24 of the EAX register; we can isolate this bit string by setting all other bits in EAX to 0 by using the following instruction (see <a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a>):</p>
<pre><code>and eax, 1111111111111000000000000b </code></pre>
<p>In theory, you could use the <code>or</code> instruction to mask all unwanted bits to 1s rather than 0s, but later comparisons and operations are often easier if the unneeded bit positions contain 0.</p>
<figure>
<img src="image_fi/501089c12/f12001.png" alt="f12001" class=""/>
<figcaption><p><a id="figure12-1">Figure 12-1</a>: Isolating a bit string by using the <span class="LiteralInCaption"><code>and</code></span> instruction</p></figcaption>
</figure>
<p>Once you’ve cleared the unneeded bits in a set of bits, you can often operate on the bit set in place. For example, to see if the string of bits in positions 12 through 24 of EAX contains 12F3h, you could use the following code:</p>
<pre><code>and eax, 1111111111111000000000000b 
cmp eax, 1001011110011000000000000b </code></pre>
<p>Here’s another solution, using constant expressions, that’s a little easier to digest:</p>
<pre><code>and eax, 1111111111111000000000000b
cmp eax, 12F3h shl 12</code></pre>
<p><span epub:type="pagebreak" title="710" id="Page_710"/>To make the constants and other values you use in conjunction with this value easier to deal with, you can use the <code>shr</code> instruction to align the bit string with bit 0 after you’ve masked it, like this:</p>
<pre><code>and eax, 1111111111111000000000000b
shr eax, 12
cmp eax, 12F3h
<var>  Other operations that require the bit string at bit #0 </var></code></pre>
<h3 id="h2-501089c12-0002">12.2.2	The or Instruction</h3>
<p class="BodyFirst">The <code>or</code> instruction is especially useful for inserting a bit set into another bit string, using the following steps:</p>
<ol class="decimal">
<li value="1">Clear all the bits surrounding your bit set in the source operand.</li>
<li value="2">Clear all the bits in the destination operand where you wish to insert the bit set.</li>
<li value="3">OR the bit set and destination operand together.</li>
</ol>
<p>For example, suppose you have a value in bits 0 to 12 of EAX that you wish to insert into bits 12 to 24 of EBX without affecting any of the other bits in EBX. You would begin by stripping out bits 13 and above from EAX; then you would strip out bits 12 to 24 in EBX. Next, you would shift the bits in EAX so the bit string occupies bits 12 to 24 of EAX. Finally, you would OR the value in EAX into EBX (see <a href="#figure12-2" id="figureanchor12-2">Figure 12-2</a>), as shown here:</p>
<pre><code>and eax, 1FFFh      ; Strip all but bits 0 to 12 from EAX
and ebx, 0FE000FFFh ; Clear bits 12 to 24 in EBX
shl eax, 12         ; Move bits 0 to 12 to 12 to 24 in EAX
or ebx,eax          ; Merge the bits into EBX</code></pre>
<p>In <a href="#figure12-2">Figure 12-2</a>, the desired bits (AAAAAAAAAAAAA) form a bit string. However, this algorithm still works fine even if you’re manipulating a noncontiguous set of bits. All you have to do is to create a bit mask that has 1s in the appropriate places.</p>
<p>When you work with bit masks, it is incredibly poor programming style to use literal numeric constants as in the past few examples. You should always create symbolic constants in MASM. By combining these with some constant expressions, you can produce code that is much easier to read and maintain. The current example code is more properly written as the following:</p>
<pre><code>StartPosn = 12 
BitMask   = 1FFFh shl StartPosn ; Mask occupies bits 12 to 24
        . 
        .
        . 
   shl eax, StartPosn   ; Move into position
   and eax, BitMask     ; Strip all but bits 12 to 24 from EAX
   and ebx, not BitMask ; Clear bits 12 to 24 in EBX
   or  ebx, eax         ; Merge the bits into EBX</code></pre>
<span epub:type="pagebreak" title="711" id="Page_711"/><figure class="graphic">
<img src="image_fi/501089c12/f12002a.png" alt="f12002a"/></figure>

<figure class="graphic">
<img src="image_fi/501089c12/f12002b.png" alt="f12002b"/></figure>

<figure class="graphic">
<img src="image_fi/501089c12/f12002f.png" alt="f12002f"/></figure>

<figure class="graphic">
<img src="image_fi/501089c12/f12002d.png" alt="f12002d"/></figure>

<figure>
<img src="image_fi/501089c12/f12002e.png" alt="f12002e" class=""/>
<figcaption><p><a id="figure12-2">Figure 12-2</a>: Inserting bits 0 to 12 of EAX into bits 12 to 24 of EBX</p></figcaption>
</figure>
<p>The use of the compile time <code>not</code> operator to invert the bit mask saves having to create another constant in the program that has to be changed anytime you modify the <code>BitMask</code> constant. Having to maintain two separate symbols whose values are dependent on one another is not a good thing in a program.</p>
<p>Of course, in addition to merging one bit set with another, the <code>or</code> instruction is also useful for forcing bits to 1 in a bit string. By setting various bits in a source operand to 1, you can force the corresponding bits in the destination operand to 1 by using the <code>or</code> instruction.</p>
<h3 id="h2-501089c12-0003"><span epub:type="pagebreak" title="712" id="Page_712"/>12.2.3	The xor Instruction</h3>
<p class="BodyFirst">The <code>xor</code> instruction allows you to invert selected bits in a bit set. Of course, if you want to invert all the bits in a destination operand, the <code>not</code> instruction is more appropriate; however, if you want to invert selected bits while not affecting others, <code>xor</code> is the way to go.</p>
<p>One interesting fact about <code>xor</code>’s operation is that it lets you manipulate known data in just about any way imaginable. For example, if you know that a field contains 1010b, you can force that field to 0 by XORing it with 1010b. Similarly, you can force it to 1111b by XORing it with 0101b. Although this might seem like a waste, because you can easily force this 4-bit string to 0 or all 1s by using <code>and</code>/<code>or</code>, the <code>xor</code> instruction has two advantages. First, you are not limited to forcing the field to all 0s or all 1s; you can actually set these bits to any of the 16 valid combinations via <code>xor</code>. Second, if you need to manipulate other bits in the destination operand at the same time, <code>and</code>/<code>or</code> may not be able to do the job. </p>
<p>For example, suppose you know that one field contains 1010b that you want to force to 0, and another field in the same operand contains 1000b and you wish to increment that field by 1 (that is, set the field to 1001b). You cannot accomplish both operations with a single <code>and</code> or <code>or</code> instruction, but you can with a single <code>xor</code> instruction; just XOR the first field with 1010b and the second field with <code>0001b</code>. Remember, however, that this trick works only if you know the current value of a bit set within the destination operand. </p>
<h3 id="h2-501089c12-0004">12.2.4	Flag Modification by Logical Instructions</h3>
<p class="BodyFirst">In addition to setting, clearing, and inverting bits in a destination operand, the <code>and</code>, <code>or</code>, and <code>xor</code> instructions also affect various condition codes in the FLAGS register. These instructions do the following:</p>
<ul>
<li>Always clear the carry and overflow flags.</li>
<li>Set the sign flag if the result has a 1 in the HO bit. They clear it otherwise; that is, these instructions copy the HO bit of the result into the sign flag.</li>
<li>Set or clear the zero flag if the result is zero or not zero, respectively.</li>
<li>Set the parity flag if there is an even number of set bits in the LO byte of the destination operand, and clear the parity flag if there is an odd number of set bits.</li>
</ul>
<p>Because these instructions always clear the carry and overflow flags, you cannot expect the system to preserve the state of these two flags across the execution of these instructions. A common mistake in many assembly language programs is the assumption that these instructions do not affect the carry flag. Many people will execute an instruction that sets or clears the carry flag; execute an <code>and</code>, <code>or</code>, or <code>xor</code> instruction; and then attempt to test the state of the carry from the previous instruction. This simply will not work.</p>
<p>One of the more interesting aspects to these instructions is that they copy the HO bit of their result into the sign flag. Therefore, you can easily <span epub:type="pagebreak" title="713" id="Page_713"/>test the HO bit by testing the sign flag (using <code>cmovs</code> and <code>cmovns</code>, <code>sets</code> and <code>setns</code>, or <code>js</code> and <code>jns</code> instructions). For this reason, many assembly language programmers will place an important Boolean variable in the HO bit of an operand so they can easily test the state of that variable by using the sign flag after a logical operation.</p>
<h4 id="h3-501089c12-0001">12.2.4.1	The Parity Flag</h4>
<p class="BodyFirst"><em>Parity</em> is a simple error-detection scheme originally employed by telegraphs and other serial communication protocols. The idea was to count the number of set bits in a character and include an extra bit in the transmission to indicate whether that character contained an even or odd number of set bits. The receiving end of the transmission would also count the bits and verify that the extra <em>parity</em> bit indicated a successful transmission. The purpose of the parity flag is to help compute the value of this extra bit, though parity-checking has been taken over by hardware.<sup class="FootnoteReference"><a id="c12-footnoteref-1" href="#c12-footnote-1">1</a></sup></p>
<p>The x86-64 <code>and</code>, <code>or</code>, and <code>xor</code> instructions set the parity bit if the LO byte of their operand contains an even number of set bits. An important fact bears repeating here: the parity flag reflects only the number of set bits in the <em>LO byte</em> of the destination operand; it does not include the HO bytes in a word, double-word, or other-sized operand. The instruction set uses the LO byte only to compute the parity because communication programs that use parity are typically character-oriented transmission systems (better error-checking schemes could be used if you transmit more than 8 bits at a time).</p>
<h4 id="h3-501089c12-0002">12.2.4.2	The Zero Flag</h4>
<p class="BodyFirst">The zero flag setting is one of the more important results produced by the <code>and</code>, <code>or</code>, and <code>xor</code> instructions. Indeed, programs reference this flag so often after the <code>and</code> instruction that Intel added a separate instruction, <code>test</code>, whose main purpose is to logically AND two results and set the flags without otherwise affecting either instruction operand.</p>
<p>The zero flag has three main uses after the execution of an <code>and</code> or a <code>test</code> instruction: (1) checking to see if a particular bit in an operand is set, (2) checking to see if at least one of several bits in a bit set is 1, and (3) checking to see if an operand is 0. Using (1) is actually a special case of (2), in which the bit set contains only a single bit. We’ll explore each of these uses in the following paragraphs.</p>
<p>To test whether a particular bit is set in a given operand, use the <code>and</code> and <code>test</code> instructions for an operand with a constant value containing a single set bit you wish to test. This clears all the other bits in the operand, leaving a 0 in the bit position under test if the operand contained a 0 in that bit position and a 1 if it contained a 1. Because all of the other bits in the result are 0, the entire result will be 0 if that particular bit is 0; the entire result will be nonzero if that bit position contains a 1. The x86-64 <span epub:type="pagebreak" title="714" id="Page_714"/>reflects this status in the zero flag (Z = 1 indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence demonstrates how to test if bit 4 is set in EAX:</p>
<pre><code>     test eax, 10000b  ; Check bit #4 to see if it is 0 or 1
     jnz  bitIsSet

    <var>Do this if the bit is clear</var>
        .
        .
        .
bitIsSet:   ; Branch here if the bit is set</code></pre>
<p>You can also use the <code>and</code> and <code>test</code> instructions to see if any one of several bits is set. Simply supply a constant that has a 1 in all the positions you want to test (and 0s everywhere else). ANDing an operand with such a constant will produce a nonzero value if one or more of the bits in the operand under test contain a 1. The following example tests whether the value in EAX contains a 1 in bit positions 1, 2, 4, and 7:</p>
<pre><code>     test eax, 10010110b 
     jz   noBitsSet

    <var>Do whatever needs to be done if one of the bits is set</var>

noBitsSet: </code></pre>
<p>You cannot use a single <code>and</code> or <code>test</code> instruction to see if all the corresponding bits in the bit set are equal to 1. To accomplish this, you must first mask out the bits that are not in the set and then compare the result against the mask itself. If the result is equal to the mask, all the bits in the bit set contain 1s. You must use the <code>and</code> instruction for this operation because the <code>test</code> instruction does not modify the result. The following example checks whether all the bits in a bit set (<code>bitMask</code>) are equal to 1:</p>
<pre><code>     and eax, bitMask 
     cmp eax, bitMask 
     jne allBitsArentSet 

; All the bit positions in EAX corresponding to the set 
; bits in bitMask are equal to 1 if we get here.

    <var>Do whatever needs to be done if the bits match</var>

allBitsArentSet: </code></pre>
<p>Of course, once we stick the <code>cmp</code> instruction in there, we don’t really have to check whether all the bits in the bit set contain 1s. We can check for any combination of values by specifying the appropriate value as the operand to the <code>cmp</code> instruction.</p>
<p>Note that the <code>test</code> and <code>and</code> instructions will set the zero flag in the preceding code sequences only if all the bits in EAX (or other destination <span epub:type="pagebreak" title="715" id="Page_715"/>operand) have 0s in the positions where 1s appear in the constant operand. This suggests another way to check for all 1s in the bit set: invert the value in EAX prior to using the <code>and</code> or <code>test</code> instruction. Then if the zero flag is set, you know that there were all 1s in the (original) bit set. For example:</p>
<pre><code>not  eax 
test eax, bitMask 
jnz  NotAllOnes

; At this point, EAX contained all 1s in the bit positions 
; occupied by 1s in the bitMask constant. 

    <var>Do whatever needs to be done at this point</var>

NotAllOnes: </code></pre>
<p>The previous paragraphs all suggest that the <code>bitMask</code> (the source operand) is a constant, but you can use a variable or other register too. Simply load that variable or register with the appropriate bit mask before you execute the <code>test</code>, <code>and</code>, or <code>cmp</code> instructions in the preceding examples.</p>
<h3 id="h2-501089c12-0005">12.2.5	The Bit Test Instructions</h3>
<p class="BodyFirst">Another set of instructions we’ve already seen that we can use to manipulate bits is the <em>bit test instructions</em>. These instructions include <code>bt</code> (<em>bit test</em>), <code>bts</code> (<em>bit test and set</em>), <code>btc</code> (<em>bit test and complement</em>), and <code>btr</code> (<em>bit test and reset</em>). The <code>bt</code><var>x</var> instructions use the following syntax:</p>
<pre><code>bt<var>x</var>  <var>bits_to_test</var>, <var>bit_number</var>
bt<var>x</var>  <var>reg</var><sub>16</sub>, <var>reg</var><sub>16</sub>
bt<var>x</var>  <var>reg</var><sub>32</sub>, <var>reg</var><sub>32</sub>
bt<var>x</var>  <var>reg</var><sub>64</sub>, <var>reg</var><sub>64</sub>
bt<var>x</var>  <var>reg</var><sub>16</sub>, <var>constant</var>
bt<var>x</var>  <var>reg</var><sub>32</sub>, <var>constant</var>
bt<var>x</var>  <var>reg</var><sub>64</sub>, <var>constant</var>
bt<var>x</var>  <var>mem</var><sub>16</sub>, <var>reg</var><sub>16</sub>
bt<var>x</var>  <var>mem</var><sub>32</sub>, <var>reg</var><sub>32</sub>
bt<var>x</var>  <var>mem</var><sub>64</sub>, <var>reg</var><sub>64</sub>
bt<var>x</var>  <var>mem</var><sub>16</sub>, <var>constant</var>
bt<var>x</var>  <var>mem</var><sub>32</sub>, <var>constant</var>
bt<var>x</var>  <var>mem</var><sub>64</sub>, <var>constant</var></code></pre>
<p class="BodyContinued">where <var>x</var> is nothing, <code>c</code>, <code>s</code>, or <code>r</code>.</p>
<p>The <code>bt</code><var>x</var> instructions’ second operand is a bit number that specifies which bit to check in the first operand. If the first operand is a register, the second operand must contain a value between 0 and the size of the register (in bits) minus 1; because the x86-64’s largest (general-purpose) registers are 64 bits, this value has the maximum value of 63 (for 64-bit registers). If the first operand is a memory location, the bit count is not limited to values in the range 0 to 63. If the second operand is a constant, it can be any 8-bit value in the range 0 to 255. If the second operand is a register, it has no (practical) limitation and, in fact, it allows negative bit offsets.</p>
<p><span epub:type="pagebreak" title="716" id="Page_716"/>The <code>bt</code> instruction copies the specified bit from the second operand into the carry flag. For example, the <code>bt eax, 8</code> instruction copies bit 8 of the EAX register into the carry flag. You can test the carry flag after this instruction to determine whether bit 8 was set or clear in EAX.</p>
<p>The <code>bts</code>, <code>btc</code>, and <code>btr</code> instructions manipulate the bit they test while they are testing it. These instructions may be slow (depending on the processor you’re using), and you should avoid them if performance is your primary concern, particularly if you’re using an older CPU. If performance (versus convenience) is an issue, you should always try two different algorithms—one that uses these instructions, and one that uses <code>and</code> and <code>or</code> instructions—and measure the performance difference; then choose the best of the two approaches.</p>
<h3 id="h2-501089c12-0006">12.2.6	Manipulating Bits with Shift and Rotate Instructions</h3>
<p class="BodyFirst">The <em>shift and rotate instructions</em> are another group of instructions you can use to manipulate and test bits. These instructions move the HO (left shift and rotate) or LO (right shift and rotate) bits into the carry flag. Therefore, you can test the carry flag after you execute one of these instructions to determine the original setting of the operand’s HO or LO bit; for example:</p>
<pre><code>shr  al, 1
jc   LOBitWasSet</code></pre>
<p>The nice thing about the shift and rotate instructions is that they automatically move bits up or down in their operand so the next bit to test is in place; this is especially useful when operating within a loop.</p>
<p>The shift and rotate instructions are invaluable for aligning bit strings and packing and unpacking data. <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> has several examples of this, and some earlier examples in this chapter also use the shift instructions for this purpose.</p>
<h2 id="h1-501089c12-0003">	12.3	The Carry Flag as a Bit Accumulator</h2>
<p class="BodyFirst">The <code>bt</code><var>x</var>, shift, and rotate instructions set or clear the carry flag depending on the operation and selected bit. Because these instructions place their “bit result” in the carry flag, it is often convenient to think of the carry flag as a 1-bit register or accumulator for bit operations. In this section, we will explore some of the operations possible with this bit result in the carry flag.</p>
<p>Instructions that use the carry flag as some sort of input value are useful for manipulating bit results in the carry flag. For example:</p>
<ul>
<li><code>adc</code>, <code>sbb</code></li>
<li><code>rcl</code>, <code>rcr</code></li>
<li><code>cmc</code>, <code>clc</code>, and <code>stc</code> </li>
<li><code>cmovc</code>, <code>cmovnc</code></li>
<li><code>jc</code>, <code>jnc</code></li>
<li><code>setc</code>, <code>setnc</code></li>
</ul>
<p><span epub:type="pagebreak" title="717" id="Page_717"/>The <code>adc</code> and <code>sbb</code> instructions add or subtract their operands along with the carry flag, so if you’ve computed a bit result into the carry flag, you can figure that result into an addition or a subtraction by using these instructions.</p>
<p>To save a carry flag result, you can use the rotate-through-carry instructions (<code>rcl</code> and <code>rcr</code>), which move the carry flag into the LO or HO bits of their destination operand. These instructions are useful for packing a set of bit results into a byte, word, or double-word value.</p>
<p>The <code>cmc</code> (<em>complement carry</em>) instruction lets you easily invert the result of a bit operation. You can also use the <code>clc</code> and <code>stc</code> instructions to initialize the carry flag prior to a string of bit operations involving the carry flag.</p>
<p>Instructions that test the carry flag, like <code>jc</code>, <code>jnc</code>, <code>cmovc</code>, <code>cmovnc</code>, <code>setc</code>, and <code>setnc</code>, are useful after a calculation that leaves a bit result in the carry flag. </p>
<p>If you have a sequence of bit calculations and would like to test whether those calculations produce a specific set of 1-bit results, you can clear a register or memory location and use the <code>rcl</code> or <code>rcr</code> instruction to shift each result into that location. Once the bit operations are complete, compare the register or memory location, holding the result against a constant value. If you want to test a sequence of results involving ANDs and ORs, you could use the <code>setc</code> and <code>setnc</code> instruction to set a register to 0 or 1 and then use the <code>and</code> and <code>or</code> instructions to merge the results.</p>
<h2 id="h1-501089c12-0004">	12.4	Packing and Unpacking Bit Strings</h2>
<p class="BodyFirst">A common bit operation is inserting a bit string into an operand or extracting a bit string from an operand. <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> provided simple examples of packing and unpacking such data; now it is time to formally describe how to do this.</p>
<p>For our purposes, I will assume that we’re dealing with bit strings that fit within a byte, word, double-word, or quad-word operand. Large bit strings that cross object boundaries require additional processing; we’ll discuss bit strings that cross quad-word boundaries later in this section.</p>
<p>When packing and unpacking a bit string, we must consider its starting bit position and length. The <em>starting bit position</em> is the bit number of the LO bit of the string in the larger operand. The <em>length</em> is the number of bits in the operand. </p>
<p>To insert (pack) data into a destination operand, you start with a bit string of the appropriate length that is right-justified (starts in bit position 0) and zero-extended to 8, 16, 32, or 64 bits; then insert this data at the appropriate starting position in another operand that is 8, 16, 32, or 64 bits wide. There is no guarantee that the destination bit positions contain any particular value.</p>
<p>The first two steps (which can occur in any order) are to clear out the corresponding bits in the destination operand and to shift (a copy of) the bit string so that the LO bit begins at the appropriate bit position. The third step is to OR the shifted result with the destination operand. This inserts the bit string into the destination operand (see <a href="#figure12-3" id="figureanchor12-3">Figure 12-3</a>).</p>
<span epub:type="pagebreak" title="718" id="Page_718"/><figure class="graphic">
<img src="image_fi/501089c12/f12003a.png" alt="f12003a"/></figure>

<figure class="graphic">
<img src="image_fi/501089c12/f12003b.png" alt="f12003b"/></figure>

<figure class="graphic">
<img src="image_fi/501089c12/f12003f.png" alt="f12003f"/></figure>

<figure>
<img src="image_fi/501089c12/f12003d.png" alt="f12003d" class=""/>
<figcaption><p><a id="figure12-3">Figure 12-3</a>: Inserting a bit string into a destination operand </p></figcaption>
</figure>
<p> The following three instructions insert a bit string of known length into a destination operand, as shown in <a href="#figure12-3">Figure 12-3</a>. These instructions assume that the source operand is in BX and the destination operand is in AX:</p>
<pre><code>shl  bx, 5 
and  ax, 1111111000011111b 
or   ax, bx </code></pre>
<p>If the length and the starting position aren’t known when you’re writing the program (that is, you have to calculate them at runtime), then you can use a lookup table to insert a bit string. Let’s assume that we have two 8-bit values: a starting bit position for the field we’re inserting and a nonzero 8-bit length value. Also assume that the source operand is in EBX and the destination operand is in EAX. The <code>mergeBits</code> procedure in <a href="#listing12-1" id="listinganchor12-1">Listing 12-1</a> demonstrates how to do this.</p>
<pre><code><span epub:type="pagebreak" title="719" id="Page_719"/>; Listing 12-1
 
; Demonstrate inserting bit strings into a register.
 
; Note that this program must be assembled and linked
; with the "LARGEADDRESSAWARE:NO" option.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 12-1", 0

; The index into the following table specifies the length 
; of the bit string at each position. There are 65 entries
; in this table (one for each bit length from 0 to 64). 

            .const
MaskByLen   equ     this qword
    qword   0
    qword   1,           3,           7,           0fh
    qword   1fh,         3fh,         7fh,         0ffh
    qword   1ffh,        3ffh,        7ffh,        0fffh
    qword   1fffh,       3fffh,       7fffh,       0ffffh
    qword   1ffffh,      3ffffh,      7ffffh,      0fffffh
    qword   1fffffh,     3fffffh,     7fffffh,     0ffffffh 
    qword   1ffffffh,    3ffffffh,    7ffffffh,    0fffffffh 
    qword   1fffffffh,   3fffffffh,   7fffffffh,   0ffffffffh
    
    qword   1ffffffffh,         03ffffffffh
    qword   7ffffffffh,         0fffffffffh
    
    qword   1fffffffffh,        03fffffffffh
    qword   7fffffffffh,        0ffffffffffh
    
    qword   1ffffffffffh,       03ffffffffffh
    qword   7ffffffffffh,       0fffffffffffh
    
    qword   1fffffffffffh,      03fffffffffffh
    qword   7fffffffffffh,      0ffffffffffffh
    
    qword   1ffffffffffffh,     03ffffffffffffh
    qword   7ffffffffffffh,     0fffffffffffffh
    
    qword   1fffffffffffffh,    03fffffffffffffh
    qword   7fffffffffffffh,    0ffffffffffffffh
    
    qword   1ffffffffffffffh,   03ffffffffffffffh
    qword   7ffffffffffffffh,   0fffffffffffffffh
    
    qword   1fffffffffffffffh,  03fffffffffffffffh
    qword   7fffffffffffffffh,  0ffffffffffffffffh

<span epub:type="pagebreak" title="720" id="Page_720"/>Val2Merge   qword   12h, 1eh, 5555h, 1200h, 120h
LenInBits   byte    5,     9,    16,    16,   12
StartPosn   byte    7,     4,     4,    12,   18

MergeInto   qword   0ffffffffh, 0, 12345678h
            qword   11111111h, 0f0f0f0fh

            include getTitle.inc
            include print.inc

            .code

; mergeBits(Val2Merge, MergeWith, Start, Length):
; Length (LenInBits[i]) value is passed in DL.
; Start (StartPosn[i]) is passed in CL.
; Val2Merge (Val2Merge[i]) and MergeWith (MergeInto[i])
; are passed in RBX and RAX.
 
; mergeBits result is returned in RAX.

mergeBits   proc
            push    rbx
            push    rcx
            push    rdx
            push    r8
            movzx   edx, dl         ; Zero-extends to RDX
            mov     rdx, MaskByLen[rdx * 8]
            shl     rdx, cl
            not     rdx
            shl     rbx, cl
            and     rax, rdx
            or      rax, rbx
            pop     r8
            pop     rdx
            pop     rcx
            pop     rbx
            ret
mergeBits   endp 
            
; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage

; The following loop calls mergeBits as
; follows:

;  mergeBits(Val2Merge[i], MergeInto[i], 
;            StartPosn[i], LenInBits[i]);

<span epub:type="pagebreak" title="721" id="Page_721"/>; Where "i" runs from 4 down to 0.

; Index of the last element in the arrays:

            mov     r10, (sizeof LenInBits) - 1
testLoop:   

; Fetch the Val2Merge element and write
; its value to the display while it is handy.

            mov     rdx, Val2Merge[r10 * 8]
            call    print
            byte    "merge( %x, ", 0
            mov     rbx, rdx
            
; Fetch the MergeInto element and write
; its value to the display.

            mov     rdx, MergeInto[r10 * 8]
            call    print
            byte    "%x, ", 0
            mov     rax, rdx
            
; Fetch the StartPosn element and write
; its value to the display.

            movzx   edx, StartPosn[r10 * 1] ; Zero-extends to RDX
            call    print
            byte    "%d, ", 0
            mov     rcx, rdx
            
; Fetch the LenInBits element and write
; its value to the display.

            movzx   edx, LenInBits[r10 * 1] ; Zero-extends to RDX
            call    print
            byte    "%d ) = ", 0

; Call mergeBits(Val2Merge, MergeInto,
;                StartPosn, LenInBits)
            
            call    mergeBits
            
; Display the function result (returned
; in RAX). For this program, the results
; are always 32 bits, so it prints only
; the LO 32 bits of RAX:

            mov     edx, eax
            call    print
            byte    "%x", nl, 0

; Repeat for each element of the array.

            dec     r10
<span epub:type="pagebreak" title="722" id="Page_722"/>            jns     testLoop
             
allDone:    leave
            pop     rdi
            pop     rsi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: Inserting bits where the bit string length and starting position are variables</p>
<p>Here’s the build command and output for the program in <a href="#listing12-1">Listing 12-1</a>. Because this program accesses arrays directly (rather than loading their addresses into registers, which obfuscates the code), this program must be built with the <code>LARGEADDRESSAWARE:NO</code> flag, hence the use of the <em>sbuild.bat</em> batch file (see the description of <em>sbuild.bat</em> in <span class="xref" itemid="xref_target_“Large Address Unaware Applications” in Chapter 3">“Large Address Unaware Applications” in Chapter 3</span>):</p>
<pre><code>C:\&gt;<b>sbuild listing12-1</b>

C:\&gt;<b>echo off</b>
 Assembling: listing12-1.asm
c.cpp

C:\&gt;<b>listing12-1</b>
Calling Listing 12-1:
merge(120, f0f0f0f, 18, 12) = 4830f0f
merge(1200, 11111111, 12, 16) = 11200111
merge(5555, 12345678, 4, 16) = 12355558
merge(1e, 0, 4, 9) = 1e0
merge(12, ffffffff, 7, 5) = fffff97f
Listing 12-1 terminated</code></pre>
<p>Each entry in the <code>MaskByLen</code> table (in <a href="#listing12-1">Listing 12-1</a>) contains the number of 1 bits specified by the index into the table. Using the <code>mergeBits</code> <code>Length</code> parameter value as an index into this table fetches a value that has as many 1 bits as the <code>Length</code> value. The <code>mergeBits</code> function fetches an appropriate mask, shifts it to the left so that the LO bit of this run of 1s matches the starting position of the field into which we want to insert the data, and then inverts the mask and uses the inverted value to clear the appropriate bits in the destination operand.</p>
<p>To extract a bit string from a larger operand, all you have to do is mask out the unwanted bits and then shift the result until the LO bit of the bit string is in bit 0 of the destination operand. For example, to extract the 4-bit field starting at bit position 5 in EBX and leave the result in EAX, you could use the following code:</p>
<pre><code>mov eax, ebx        ; Copy data to destination
and eax, 111100000b ; Strip unwanted bits
shr eax, 5          ; Right-justify to bit position 0</code></pre>
<p><span epub:type="pagebreak" title="723" id="Page_723"/>If you do not know the bit string’s length and starting position when you’re writing the program, you can still extract the desired bit string. The code is similar to insertion (though a little simpler). Assuming you have the <code>Length</code> and <code>Start</code> values we used when inserting a bit string, you can extract the corresponding bit string by using the following code (assuming source = EBX and dest = EAX):</p>
<pre><code>movzx edx, Length
lea   r8, MaskByLen      ; Table from Listing 12-1
mov   rdx, [r8][rdx * 8]
mov   cl, StartingPosition
mov   rax, rbx
shr   rax, cl
and   rax, rdx</code></pre>
<p>The examples up to this point all assume that the bit string appears completely within a quad-word (or smaller) object. This will always be the case if the bit string is less than or equal to 64 bits in length. However, if the length of the bit string plus its starting position (modulo 8) within an object is greater than 64, the bit string will cross a quad-word boundary within the object. </p>
<p>Extracting such bit strings requires up to three operations: one operation to extract the start of the bit string (up to the first quad-word boundary), an operation that copies whole quad words (assuming the bit string is so long that it consumes several quad words), and a final operation that copies leftover bits in the last quad word at the end of the bit string. The actual implementation of this operation is left as an exercise for you.</p>
<h2 id="h1-501089c12-0005">	12.5	BMI1 Instructions to Extract Bits and Create Bit Masks</h2>
<p class="BodyFirst">If your CPU supports the BMI1 (<em>bit manipulation instructions, set 1</em>) instruction set extensions,<sup class="FootnoteReference"><a id="c12-footnoteref-2" href="#c12-footnote-2">2</a></sup> you can use the <code>bextr</code> (<em>bit extraction</em>) instruction to extract bits from a 32- or 64-bit general-purpose register. This instruction has the following syntax:</p>
<pre><code>bextr <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>, <var>reg</var><sub>ctrl</sub>
bextr <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub>, <var>reg</var><sub>ctrl</sub></code></pre>
<p>The operands must all be the same size and must be 32- or 64-bit registers (or memory locations).</p>
<p>The <code>bextr</code> instruction encodes two parameters into <var>reg</var><span class="SubscriptLiteral">ctrl</span>:</p>
<ul>
<li>Bits 0 to 7 of <var>reg</var><span class="SubscriptLiteral">ctrl</span> specify a starting bit position in the source operand (this must be a value in the range 0 to 31 for 32-bit operands and 0 to 63 for 64-bit operands).</li>
<li>Bits 8 to 15 of <var>reg</var><span class="SubscriptLiteral">ctrl</span> specify the number of bits to extract from the source operand.</li>
</ul>
<p><span epub:type="pagebreak" title="724" id="Page_724"/>The <code>bextr</code> instruction will extract the specified bits from <var>reg</var><span class="SubscriptLiteral">src</span> or <var>mem</var><span class="SubscriptLiteral">src</span> and store those bits (shifted down to bit 0) in <var>reg</var><span class="SubscriptLiteral">dest</span>. As a general rule, you should attempt to use RAX and EAX, RBX and EBX, RCX and ECX, or RDX and EDX as the <var>ctrl</var> register because you can easily manipulate the starting and length values by using the AH and AL, BH and BL, CH and CL, and DH and DL 8-bit registers. <a href="#listing12-2" id="listinganchor12-2">Listing 12-2</a> provides a quick demonstration of the <code>bextr</code> instruction.<sup class="FootnoteReference"><a id="c12-footnoteref-3" href="#c12-footnote-3">3</a></sup></p>
<pre><code>; Listing 12-2
 
; Demonstrate extracting bit strings from a register.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 12-2", 0

            include getTitle.inc
            include print.inc

; Here is the "asmMain" function.

            .code
            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage

; &gt;&gt;&gt;&gt; Unique code for various listings:

            mov     rax, 123456788abcdefh
            mov     bl, 4
            mov     bh, 16
            
            bextr   rdx, rax, rbx
            
            call    print
            byte    "Extracted bits: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.
                         
allDone:    leave
            pop     rdi
            pop     rsi
<span epub:type="pagebreak" title="725" id="Page_725"/>            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: <code>bextr</code> instruction example</p>
<p><a href="#listing12-2">Listing 12-2</a> produces the following output:</p>
<pre><code>C:\&gt;<b>build listing12-2</b>

C:\&gt;<b>echo off</b>
 Assembling: listing12-2.asm
c.cpp

C:\&gt;<b>listing12-2</b>
Calling Listing 12-2:
Extracted bits: bcde
Listing 12-2 terminated</code></pre>
<p>The BMI1 instruction set extension also includes an instruction that extracts the lowest-numbered set bit in a register: <code>blsi</code> (<em>extract lowest set isolated bit</em>). The syntax for this instruction is as follows:</p>
<pre><code>blsi <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>
blsi <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub></code></pre>
<p>The operands must be the same size and can be either 32 or 64 bits. This instruction locates the lowest set bit in the source operand (register or memory). It copies that bit to the destination register and zeroes out all other bits in the destination. If the source value is 0, <code>blsi</code> copies 0 to the destination register and sets the zero and carry flags. <a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a> is a simple demonstration of this instruction (note that I’ve eliminated the common code from <a href="#listing12-2">Listing 12-2</a>).</p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8, 12340000h
blsi    edx, r8
 
call    print
byte    "Extracted bit: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.</code></pre>
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: Simple demonstration of the <code>blsi</code> instruction</p>
<p>Inserting this into a shell sample program and running it produces the following output:</p>
<pre><code>Extracted bit: 40000</code></pre>
<p><span epub:type="pagebreak" title="726" id="Page_726"/>The BMI1 <code>andn</code> instruction is useful in conjunction with <code>blsi</code>. The <code>andn</code> (<em>and not</em>) instruction has the following generic syntax:</p>
<pre><code>andn <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src1</sub>, <var>reg</var><sub>src2</sub>
andn <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src1</sub>, <var>mem</var><sub>src2</sub></code></pre>
<p>The operands must all be the same size and must be 32 or 64 bits. This instruction logically ANDs an inverted copy of the value in <var>reg</var><span class="SubscriptLiteral">src1</span> with the third operand (the <var>src2</var> operand) and stores the result into the <var>reg</var><span class="SubscriptLiteral">dest</span> operand.</p>
<p>You can use the <code>andn</code> instruction immediately after a <code>blsi</code> instruction to remove the lowest-numbered bit from <code>blsi</code>’s source operand after extracting it. <a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a> demonstrates this operation (as usual, omitting the common code). </p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8, 12340000h
blsi    edx, r8
andn    r8, rdx, r8

; Output value 1 is in RDX (extracted bit),
; output value 2 in R8 (value with deleted bit).
            
call    print
byte    "Extracted bit: %x, result: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.</code></pre>
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: Extracting and removing the lowest set bit in an operand</p>
<p>Running this code produces the following output:</p>
<pre><code>Extracted bit: 40000, result: 12300000</code></pre>
<p>Extracting the LO bit and keeping the remaining bits (as was done with the <code>blsi</code> and <code>andn</code> instructions in <a href="#listing12-4">Listing 12-4</a>) are such a common operation that Intel created an instruction to specifically handle this task: <code>blsr</code> (<em>reset lowest set bit</em>). Here’s its generic syntax:</p>
<pre><code>blsr <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>
blsr <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub></code></pre>
<p>Both operands must be the same size and must be either 32 or 64 bits. This instruction gets the data from the source operand, sets the lowest-numbered set bit to 0, and copies the result to the destination register. If the source operand contains 0, this instruction copies 0 to the destination and sets the carry flag.</p>
<p><a href="#listing12-5" id="listinganchor12-5">Listing 12-5</a> demonstrates the usage of this instruction.</p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8, 12340000h
blsr    edx, r8

<span epub:type="pagebreak" title="727" id="Page_727"/>; Output value 1 is in RDX (extracted bit), resulting value.

call    print
byte    "Value with extracted bit: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.</code></pre>
<p class="CodeListingCaption"><a id="listing12-5">Listing 12-5</a>: <code>blsr</code> instruction example</p>
<p>Here’s the output from this code fragment (after inserting it into a test program shell):</p>
<pre><code>Value with extracted bit: 12300000</code></pre>
<p>Another useful BMI1 instruction is <code>blsmsk</code>. This instruction creates a bit mask by searching for the lowest-numbered set bit. Then it creates a bit mask consisting of all 1 bits up to and including the lowest set bit. The <code>blsmsk</code> instruction sets the remaining bits to 0. If the original value was 0, <code>blsmsk</code> sets all the bits in the destination register to 1 and sets the carry flag. Here’s the generic syntax for <code>blsmsk</code>:</p>
<pre><code>blsmsk <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>
blsmsk <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub></code></pre>
<p><a href="#listing12-6" id="listinganchor12-6">Listing 12-6</a> is a sample code fragment and the output it will produce.</p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8, 12340000h
blsmsk  edx, r8

; Output value 1 is in RDX (mask).

call    print
byte    "Mask: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.</code></pre>
<p class="CodeListingCaption"><a id="listing12-6">Listing 12-6</a>: <code>blsmsk</code> example</p>
<p>Here is the sample output:</p>
<pre><code>Mask: 7ffff</code></pre>
<p>Especially note that the mask the <code>blsmsk</code> instruction produces includes a 1 bit in the bit position holding the lowest-numbered set bit in the source file. Often, you will actually want a bit mask containing 1 bits up to, but not including, the lowest-numbered set bit. This is easy to achieve using the <code>blsi</code> and <code>dec</code> instructions, as shown in <a href="#listing12-7" id="listinganchor12-7">Listing 12-7</a>.</p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8, 12340000h
blsi    rdx, r8
dec     rdx

<span epub:type="pagebreak" title="728" id="Page_728"/>; Output value 1 is in RDX (mask).

call    print
byte    "Mask: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.</code></pre>
<p class="CodeListingCaption"><a id="listing12-7">Listing 12-7</a>: Creating a bit mask that doesn’t include the lowest-numbered set bit</p>
<p>Here’s the output:</p>
<pre><code>Mask: 3ffff</code></pre>
<p>The last of the BMI1 instructions is <code>tzcnt</code> (<em>trailing zero count</em>). This instruction has the following generic syntax:</p>
<pre><code>tzcnt <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>
tzcnt <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub></code></pre>
<p>As usual, the operands must both be the same size. The <code>tzcnt</code> instruction is unique among the BMI1 instructions insofar as it allows 16-, 32-, and 64-bit operands. </p>
<p>The <code>tzcnt</code> instruction counts the number of LO 0 bits in the source (starting at the LO bit and working up toward the HO bit). It stores the 0 bit count into the destination register. Conveniently, the count of 0 bits is also the bit index of the first set bit in the source operand. This instruction sets the carry flag if the source operand is 0 (in which case it also sets the destination register to the size of the operands). </p>
<p>To search for and extract 0 bits with <code>bextr</code>,<code> blsi</code>,<code> blsr</code>, and<code> blsmsk</code>, invert the source operand before executing these instructions. Likewise, to count the number of trailing set bits with <code>tzcnt</code>, first invert the source operand.<sup class="FootnoteReference"><a id="c12-footnoteref-4" href="#c12-footnote-4">4</a></sup></p>
<p>If you use <code>bextr</code>, <code>blsi</code>, <code>blsr</code>,<code> blsmsk</code>, <code>tzcnt</code>, or <code>andn</code> in your program, don’t forget to test for the presence of the BMI1 instruction set extensions. Not all x86-64 CPUs support these instructions.</p>
<h2 id="h1-501089c12-0006">	12.6	Coalescing Bit Sets and Distributing Bit Strings</h2>
<p class="BodyFirst">Inserting and extracting bit sets are only a little different from inserting and extracting bit strings if the shape of the bit set you’re inserting (or resulting bit set you’re extracting) is the same as the shape of the bit set in the main object. The <em>shape</em> of a bit set is the distribution of the bits in the set, ignoring the starting bit position of the set. A bit set that includes bits 0, 4, 5, 6, and 7 has the same shape as that of a bit set that includes bits 12, 16, 17, 18, and 19 because the distribution of the bits is the same.</p>
<p>The code to insert or extract this bit set is nearly identical to that of the previous section; the only difference is the mask value you use. For <span epub:type="pagebreak" title="729" id="Page_729"/>example, to insert this bit set starting at bit 0 in EAX into the corresponding bit set starting at position 12 in EBX, you could use the following code:</p>
<pre><code>and ebx, not 11110001000000000000b ; Mask out destination bits
shl eax, 12                        ; Move source bits into position
or  ebx, eax                       ; Merge the bit set into EBX</code></pre>
<p>However, suppose you have 5 bits in bit positions 0 through 4 in EAX and want to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to distribute the bits in EAX prior to logically ORing the values into EBX. Given that this particular bit set is made of two runs of 1 bits, the process is somewhat simplified. The following code distributes the bits in a sneaky fashion:</p>
<pre><code>and ebx, not 11110001000000000000b
and eax, 11110001000000000000b  ; Mask out destination bits
shl eax, 2    ; Spread out bits: 1 to 4 goes to 3 to 6 and 0 goes to 2
btr eax, 2    ; Bit 2 -&gt; carry and then clear bit 2
rcl eax, 13   ; Shift in carry and put bits into final position
or  ebx, eax  ; Merge the bit set into EBX</code></pre>
<p>This trick with the <code>btr</code> (<em>bit test and reset</em>) instruction worked well because we had only 1 bit out of place in the original source operand. Alas, had the bits all been in the wrong location relative to one another, this scheme wouldn’t be an efficient solution. We’ll see a more general solution in just a moment.</p>
<p>Extracting this bit set and collecting (<em>coalescing</em>) the bits into a bit string is not quite as easy. However, we still have some sneaky tricks we can pull. Consider the following code that extracts the bit set from EBX and places the result into bits 0 to 4 of EAX:</p>
<pre><code>mov eax, ebx 
and eax, 11110001000000000000b  ; Strip unwanted bits
shr eax, 5                      ; Put bit 12 into bit 7, and so on
shr ah, 3                       ; Move bits 11 to 14 to 8 to 11
shr eax, 7                      ; Move down to bit 0</code></pre>
<p>This code moves (original) bit 12 into bit position 7, the HO bit of AL. At the same time, it moves bits 16 to 19 down to bits 11 to 14 (bits 3 to 6 of AH). Then the code shifts bits 3 to 6 in AH down to bit 0. This positions the HO bits of the bit set so that they are adjacent to the bit remaining in AL. Finally, the code shifts all the bits down to bit 0. Again, this is not a general solution, but it shows a clever way to attack this problem if you think about it carefully.</p>
<p>The preceding coalescence and distribution algorithms apply only to their specific bit sets. A generalized solution (perhaps one that lets you specify a mask, then distributes or coalesces the bits accordingly) is going to be a bit more difficult. The following code demonstrates how to distribute the bits in a bit string according to the values in a bit mask:</p>
<pre><code>; EAX - Originally contains a value into which we 
;       insert bits from EBX.
; EBX - LO bits contain the values to insert into EAX.
<span epub:type="pagebreak" title="730" id="Page_730"/>; EDX - Bitmap with 1s indicating the bit positions in 
;       EAX to insert.
; CL -  Scratchpad register.

          mov cl, 32      ; Count number of bits we rotate
          jmp DistLoop

CopyToEAX:
          rcr ebx, 1      ; Don't use SHR, must preserve Z-flag
          rcr eax, 1 
          jz  Done 
DistLoop: dec cl 
          shr edx, 1 
          jc  CopyToEAX 
          ror eax, 1      ; Keep current bit in EAX
          jnz DistLoop 

Done:     ror eax, cl     ; Reposition remaining bits </code></pre>
<p>If we load EDX with 11001001b, this code will copy bits 0 to 3 to bits 0, 3, 6, and 7 in EAX. Notice the short-circuit test that checks whether we’ve exhausted the values in EDX (by checking for a 0 in EDX). The rotate instructions do not affect the zero flag, but the shift instructions do. Hence, the preceding <code>shr</code> instruction will set the zero flag when there are no more bits to distribute (when EDX becomes 0).</p>
<p>The general algorithm for coalescing bits is a tad more efficient than general distribution. Here’s the code that will extract bits from EBX via the bit mask in EDX and leave the result in EAX:</p>
<pre><code>; EAX - Destination register.
; EBX - Source register.
; EDX - Bitmap with 1s representing bits to copy to EAX.
; EBX and EDX are not preserved.

     xor eax, eax    ; Clear destination register 
     jmp ShiftLoop

ShiftInEAX:  
     rcl ebx, 1      ; EBX to EAX
     rcl eax, 1
ShiftLoop:   
     shl edx, 1      ; Check to see if we need to copy a bit
     jc  ShiftInEAX  ; If carry set, go copy the bit
     rcl ebx, 1      ; Current bit is uninteresting, skip it
     jnz ShiftLoop   ; Repeat as long as there are bits in EDX</code></pre>
<p>This sequence also takes advantage of a sneaky trait of the shift and rotate instructions: the shift instructions affect the zero flag, whereas the rotate instructions do not. Therefore, the <code>shl edx, 1</code> instruction sets the zero flag when EDX becomes 0 (after the shift). If the carry flag was also set, the code will make one additional pass through the loop in order to shift a bit into EAX, but the next time the code shifts EDX 1 bit to the left, <span epub:type="pagebreak" title="731" id="Page_731"/>EDX is still 0 and so the carry will be clear. On this iteration, the code falls out of the loop.</p>
<p>Another way to coalesce bits is via table lookup. By grabbing a byte of data at a time (so your tables don’t get too large), you can use that byte’s value as an index into a lookup table that coalesces all the bits down to bit 0. Finally, you can merge the bits at the low end of each byte together. This might produce a more efficient coalescing algorithm in certain cases. The implementation is left to you.</p>
<h2 id="h1-501089c12-0007">	12.7	Coalescing and Distributing Bit Strings Using BMI2 Instructions</h2>
<p class="BodyFirst">Intel’s BMI2 (<em>bit manipulation instructions, set 2</em>)<sup class="FootnoteReference"><a id="c12-footnoteref-5" href="#c12-footnote-5">5</a></sup> instruction set extensions include a handy set of instructions you can use to insert or extract arbitrary bit sets: <code>pdep</code> (<em>parallel bits deposit</em>) and <code>pext</code> (<em>parallel bits extract</em>). If these instructions are available on your CPU, they can handle many of the tasks presented with non-BMI instructions in this chapter. They are powerful instructions indeed.</p>
<p>These instructions have the following syntax:</p>
<pre><code>pdep <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>, <var>reg</var><sub>mask</sub>
pdep <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>, <var>mem</var><sub>mask</sub>
pext <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>, <var>reg</var><sub>mask</sub>
pext <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>, <var>mem</var><sub>mask</sub></code></pre>
<p>All operands must be the same size and must be 32 or 64 bits.</p>
<p>The <code>pext</code> instruction extracts an arbitrary bit string from the source (second) register and coalesces those bits to contiguous bit locations starting at bit 0 in the destination register. The third operand, the mask, controls which bits <code>pext</code> extracts from the source. </p>
<p>The mask operand contains 1 bits in the bit positions that <code>pext</code> will extract from the source register. <a href="#figure12-4" id="figureanchor12-4">Figure 12-4</a> shows how this bit mask works. For each 1 bit in the mask operand, the <code>pext</code> instruction copies the corresponding bit in the source register to the next available bit position (starting from bit 0) in the destination register.</p>
<figure>
<img src="image_fi/501089c12/f12004.png" alt="f12004" class=""/>
<figcaption><p><a id="figure12-4">Figure 12-4</a>: Bit mask for <span class="LiteralInCaption"><code>pext</code></span> instruction</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="732" id="Page_732"/><a href="#listing12-8" id="listinganchor12-8">Listing 12-8</a> is a sample program fragment and the output it produces demonstrating the <code>pext</code> instruction (as usual, this listing eliminates the common code).</p>
<pre><code>; &gt;&gt;&gt;&gt; Unique code for various listings.

mov     r8d, 12340000h
mov     r9d, 0F0f000Fh
pext    edx, r8d, r9d

; Output value 1 is in RDX (mask).

call    print
byte    "Extracted: %x", nl, 0

; &lt;&lt;&lt;&lt; End of unique code.
<span class="LiteralGray">------------------------------------------------------------------------------</span>
<span class="LiteralGray">Extracted: 240</span></code></pre>
<p class="CodeListingCaption"><a id="listing12-8">Listing 12-8</a>: <code>pext</code> instruction example</p>
<p>The <code>pdep</code> instruction does the converse of <code>pext</code>. It takes the contiguous set of bits starting with the LO bit of the source register operand and distributes those bits throughout the destination register by using the 1 bits in the mask operand to determine placement, as shown in <a href="#figure12-5" id="figureanchor12-5">Figure 12-5</a>. The <code>pdep</code> instruction sets all other bits in the destination register to 0.</p>
<figure>
<img src="image_fi/501089c12/f12005.png" alt="f12005" class=""/>
<figcaption><p><a id="figure12-5">Figure 12-5</a>: <span class="LiteralInCaption"><code>pdep</code></span> instruction operation</p></figcaption>
</figure>
<p><a href="#listing12-9" id="listinganchor12-9">Listing 12-9</a> is an example of the <code>pdep</code> instruction and the output it produces.</p>
<pre><code>mov     r8d, 1234h
mov     r9d, 0F0FF00Fh 
pdep    edx, r8d, r9d

; Output value 1 is in RDX (mask).
            
call    print
byte    "Distributed: %x", nl, 0
<span class="LiteralGray">------------------------------------------------------------------------------</span>
<span class="LiteralGray">Distributed: 1023004</span></code></pre>
<p class="CodeListingCaption"><a id="listing12-9">Listing 12-9</a>: <code>pdep</code> instruction example</p>
<p><span epub:type="pagebreak" title="733" id="Page_733"/>If you use the <code>pdep</code> or <code>pext</code> instructions in your program, don’t forget to test for the presence of the BMI2 instruction set extensions. Not all x86-64 CPUs support these instructions. See <span class="xref" itemid="xref_target_Listing 11-2 in Chapter 11"><a href="c11.xhtml#listing11-2">Listing 11-2</a> in Chapter 11</span> to see how to check for the presence of the BMI2 instruction set extensions.</p>
<h2 id="h1-501089c12-0008">	12.8	Packed Arrays of Bit Strings</h2>
<p class="BodyFirst">Though far less efficient, it is quite possible to create arrays of elements whose size is not a multiple of 8 bits. The drawback is that calculating the “address” of an array element and manipulating that array element involves a lot of extra work. In this section, we’ll take a look at a few examples of packing and unpacking array elements in an array whose elements are an arbitrary number of bits long.</p>
<p>Why would you want arrays of bit objects? The answer is simple: space. If an object consumes only 3 bits, you can get 2.67 times as many elements into the same space if you pack the data rather than allocating a whole byte for each object. For very large arrays, this can be a substantial savings. Of course, the cost of this space savings is speed: you have to execute extra instructions to pack and unpack the data, thus slowing down access to the data.</p>
<p>The calculation for locating the bit offset of an array element in a large block of bits is almost identical to the standard array access:</p>
<pre><code><var>element_address_in_bits</var> = 
<var>    base_address_in_bits</var> + <var>index</var> * <var>element_size_in_bits</var> </code></pre>
<p>Once you calculate the element’s address in bits, you need to convert it to a byte address (because we have to use byte addresses when accessing memory) and extract the specified element. Because the base address of an array element (almost) always starts on a byte boundary, we can use the following equations to simplify this task:</p>
b<pre><code><var>yte_of_1st_bit</var> = 
    <var>base_address</var> + (<var>index</var> * <var>element_size_in_bits</var>) / 8
 
<var>offset_to_1st_bit</var> = 
    (<var>index</var> * <var>element_size_in_bits</var>) % 8</code></pre>
<p>For example, suppose we have an array of 200 three-bit objects that we declare as follows:</p>
<pre><code>             .data
AO3Bobjects  byte (200 * 3)/8 + 2 dup (?)  ; "+2" handles truncation</code></pre>
<p>The constant expression in the preceding dimension reserves space for enough bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression adds 2 extra bytes at the end to ensure we don’t lose any odd bits<sup class="FootnoteReference"><a id="c12-footnoteref-6" href="#c12-footnote-6">6</a></sup> as well as to allow us to access 1 byte beyond the end of the array (when storing data to the array).</p>
<p><span epub:type="pagebreak" title="734" id="Page_734"/>Now suppose you want to access the <em>i</em>th 3-bit element of this array. You can extract these bits by using the following code:</p>
<pre><code>; Extract the <var>i</var>th group of 3 bits in AO3Bobjects 
; and leave this value in EAX.
 
xor  ecx, ecx             ; Put <var>i </var>/ 8 remainder here
mov  eax, i               ; Get the index into the array
lea  rax, [rax + rax * 2] ; RAX := RAX * 3 (3 bits/element)
shrd rcx, rax, 3          ; RAX / 8 -&gt; RAX and RAX mod 8 -&gt; RCX 
                          ; (HO bits)
shr  rax, 3               ; Remember, shrd doesn't modify EAX
rol  rcx, 3               ; Put remainder into LO 3 bits of RCX

; Okay, fetch the word containing the 3 bits we want to 
; extract. We have to fetch a word because the last bit or two 
; could wind up crossing the byte boundary (that is, bit offset 6 
; and 7 in the byte).

lea r8, AO3Bobjects
mov ax, [r8][rax * 1]
shr ax, cl                ; Move bits down to bit 0
and eax, 111b             ; Remove the other bits (incl HO RAX)</code></pre>
<p>Inserting an element into the array is a bit more difficult. In addition to computing the base address and bit offset of the array element, you also have to create a mask to clear out the bits in the destination where you’re going to insert the new data. <a href="#listing12-10" id="listinganchor12-10">Listing 12-10</a> inserts the LO 3 bits of EAX into the <em>i</em>th element of the <code>AO3Bobjects</code> array.</p>
<pre><code>; Listing 12-10
 
; Creating a bit mask with blsi and dec.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 12-10", 0

Masks       equ     this word
            word    not 0111b,            not 00111000b
            word    not 000111000000b,    not 1110b
            word    not 01110000b,        not 001110000000b
            word    not 00011100b,        not 11100000b
            
            .data
i           dword   5
AO3Bobjects byte    (200*3)/8 + 2 dup (?)   ; "+2" handles truncation

<span epub:type="pagebreak" title="735" id="Page_735"/>            include getTitle.inc
            include print.inc

            .code
            
; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56           ; Shadow storage

            mov     eax, 7            ; Value to store
            
            mov     ebx, i            ; Get the index into the array
            mov     ecx, ebx          ; Use LO 3 bits as index
            and     ecx, 111b         ; into Masks table
            lea     r8, Masks
            mov     dx, [r8][rcx * 2] ; Get bit mask
        
; Convert index into the array into a bit index.
; To do this, multiply the index by 3:
        
            lea     rbx, [rbx + rbx * 2]
        
; Divide by 8 to get the byte index into EBX
; and the bit index (the remainder) into ECX:
        
            shrd    ecx, ebx, 3
            shr     ebx, 3
            rol     ecx, 3
     
; Grab the bits and clear those we're inserting.

            lea     r8, AO3Bobjects
            and     dx, [r8][rbx * 1]

; Put our 3 bits in their proper location.

            shl     ax, cl

; Merge bits into destination.
                      
            or      dx, ax
             
; Store back into memory.
 
            mov     [r8][rbx * 1], dx
            
<span epub:type="pagebreak" title="736" id="Page_736"/>            mov     edx, dword ptr AO3Bobjects
            call    print
            byte    "value:%x", nl, 0
                                     
allDone:    leave
            pop     rdi
            pop     rsi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing12-10">Listing 12-10</a>: Storing the value 7 (111b) into an array of 3-bit elements</p>
<p>Inserting the code in <a href="#listing12-10">Listing 12-10</a> into a shell assembly file produces the following output:</p>
<pre><code>value:38000</code></pre>
<p>The <code>print</code> statement prints the first 32 bits of <code>AO3Bobjects</code>. Because each element is 3 bits, the array looks like </p>
<pre><code>000 000 000 000 000 111 000 000 000 000 00 ...</code></pre>
<p class="BodyContinued">where bit 0 is the leftmost bit. Flipping the 32 bits around to make them more readable, and grouping them in blocks of 4 bits (to make it easy to convert to hexadecimal), we get</p>
<pre><code>0000 0000 0000 0011 1000 0000 0000 0000</code></pre>
<p class="BodyContinued">which is 38000h.</p>
<p><a href="#listing12-10">Listing 12-10</a> uses a lookup table to generate the masks needed to clear out the appropriate position in the array. Each element of this array contains all 1s except for three 0s in the position we need to clear for a given bit offset (note the use of the <code>not</code> operator to invert the constants in the table).</p>
<h2 id="h1-501089c12-0009">	12.9	Searching for a Bit</h2>
<p class="BodyFirst">A common bit operation is to locate the end of a run of bits. A special case of this operation is to locate the first (or last) set or clear the bit in a 16-, 32-, or 64-bit value. In this section, we’ll explore ways to handle this special case.</p>
<p>The term <em>first set bit</em> means the first bit in a value, scanning from bit 0 toward the high-order bit, which contains a 1. A similar definition exists for the <em>first clear bit</em>. The <em>last set bit</em> is the first bit in a value, scanning from the high-order bit toward bit 0, which contains a 1. A similar definition exists for the <em>last clear bit</em>.</p>
<p>One obvious way to scan for the first or last bit is to use a shift instruction in a loop and count the number of iterations before you shift out a 1 (or 0) into the carry flag. The number of iterations specifies the position. <span epub:type="pagebreak" title="737" id="Page_737"/>Here’s some sample code that checks for the first set bit in EAX and returns that bit position in ECX:</p>
<pre><code>          mov ecx, -32  ; Count off the bit positions in ECX
TstLp:    shr eax, 1    ; Check to see if current bit
                        ; position contains a 1
          jc  Done      ; Exit loop if it does 
          inc ecx       ; Bump up our bit counter by 1
          jnz TstLp     ; Exit if we execute this loop 32 times

Done:     add cl, 32    ; Adjust loop counter so it holds 
                        ; the bit position

; At this point, CL contains the bit position of the 
; first set bit. CL contains 32 if EAX originally 
; contained 0 (no set bits). </code></pre>
<p>The only thing tricky about this code is that it runs the loop counter from –32 up to 0 rather than 32 down to 0. This makes it slightly easier to calculate the bit position after the loop terminates.</p>
<p>The drawback to this particular loop is that it’s expensive. This loop repeats as many as 32 times, depending on the original value in EAX. If the values you’re checking often have lots of 0s in the LO bits of EAX, this code runs rather slowly.</p>
<p>Searching for the first (or last) set bit is such a common operation that Intel added a couple of instructions specifically to accelerate this process. These instructions are <code>bsf</code> (<em>bit scan forward</em>) and <code>bsr</code> (<em>bit scan reverse</em>). Their syntax is as follows:</p>
<pre><code>bsr <var>dest</var><sub>reg</sub>, <var>reg</var><sub>src</sub> 
bsr <var>dest</var><sub>reg</sub>, <var>mem</var><sub>src</sub> 
bsf <var>dest</var><sub>reg</sub>, <var>reg</var><sub>src</sub> 
bsf <var>dest</var><sub>reg</sub>, <var>mem</var><sub>src</sub> </code></pre>
<p>The source and destination operands must be the same size (16, 32, or 64 bits). The destination operand has to be a register. The source operand can be a register or a memory location.</p>
<p>The <code>bsf</code> instruction scans for the first set bit (starting from bit position 0) in the source operand. The <code>bsr</code> instruction scans for the last set bit in the source operand by scanning from the HO bit toward the LO bit. If these instructions find a bit that is set in the source operand, they clear the zero flag and put the bit position into the destination register. If the source register contains 0 (that is, there are no set bits), then these instructions set the zero flag and leave an indeterminate value in the destination register. You should test the zero flag immediately after the execution of these instructions to validate the destination register’s value. Here’s an example:</p>
<pre><code>mov ebx, SomeValue  ; Value whose bits we want to check
bsf eax, ebx        ; Put position of first set bit in EAX
jz  NoBitsSet       ; Branch if SomeValue contains 0
<span epub:type="pagebreak" title="738" id="Page_738"/>mov FirstBit, eax   ; Save location of first set bit
    .
    .
    .</code></pre>
<p>You use the <code>bsr</code> instruction in an identical fashion except that it computes the bit position of the last set bit in an operand (the first set bit it finds when scanning from the HO bit toward the LO bit).</p>
<p>The x86-64 CPUs do not provide instructions to locate the first bit containing a 0. However, you can easily scan for a 0 bit by first inverting the source operand (or a copy of the source operand if you must preserve the source operand’s value) and then searching for the first 1 bit; this corresponds to the first 0 bit in the original operand value.</p>
<p>The <code>bsf</code> and <code>bsr</code> instructions are complex x86-64 instructions and may be slower than others. In some circumstances, it may be faster to locate the first set bit by using discrete instructions. However, because the execution time of these instructions varies widely from CPU to CPU, you should test the performance of these instructions prior to using them in time-critical code.</p>
<p>Note that the <code>bsf</code> and <code>bsr</code> instructions do not affect the source operand. A common operation is to extract (and clear) the first or last set bit you find in an operand. If the source operand is in a register, you can use the <code>btr</code> (or <code>btc</code>) instruction to clear the bit after you’ve found it. Here’s some code that achieves this result:</p>
<pre><code>          bsf ecx, eax       ; Locate first set bit in EAX
          jz  noBitFound     ; If we found a bit, clear it

          btr eax, ecx       ; Clear the bit we just found

noBitFound: </code></pre>
<p>At the end of this sequence, the zero flag indicates whether we found a bit (note that <code>btr</code> doesn’t affect the zero flag). </p>
<p>Because the <code>bsf</code> and <code>bsr</code> instructions support only 16-, 32-, and 64-bit operands, you will have to compute the first bit position of an 8-bit operand a little differently. There are a couple of reasonable approaches. First, you can zero-extend an 8-bit operand to 16 or 32 bits and then use the <code>bsf</code> or <code>bsr</code> instruction. Another alternative is to create a lookup table in which each entry contains the number of bits in the value you use as an index into the table; then you can use the <code>xlat</code> instruction to “compute” the first bit position in the value (you will have to handle the value 0 as a special case). Another solution is to use the shift algorithm appearing at the beginning of this section; for an 8-bit operand, this is not an entirely inefficient solution.</p>
<p>You can use <code>bsf</code> and <code>bsr</code> to determine the size of a run of bits, assuming that you have a single run of bits in your operand. Simply locate the first and last bits in the run (as in the previous example) and then compute the difference (plus 1) of the two values. Of course, this scheme is valid only if there are no intervening 0s between the first and last set bits in the value.</p>
<h2 id="h1-501089c12-0010"><span epub:type="pagebreak" title="739" id="Page_739"/>	12.10	Counting Bits</h2>
<p class="BodyFirst">The last example in the previous section demonstrates a specific case of a very general problem: counting bits. Unfortunately, that example has a severe limitation: it counts only a single run of 1 bits appearing in the source operand. This section discusses a more general solution to this problem.</p>
<p>Hardly a week goes by that someone doesn’t ask on one of the internet newsgroups how to count the number of bits in a register operand. This is a common request, undoubtedly because many assembly language course instructors assign this task as a project to their students as a way to teach them about the shift and rotate instructions, as follows:</p>
<pre><code>; BitCount1:
 
; Counts the bits in the EAX register, 
; returning the count in EBX.

          mov cl, 32    ; Count the 32 bits in EAX
          xor ebx, ebx  ; Accumulate the count here
CntLoop:  shr eax, 1    ; Shift bit out of EAX and into carry
          adc bl, 0     ; Add the carry into the EBX register
          dec cl        ; Repeat 32 times
          jnz CntLoop </code></pre>
<p>The “trick” is that this code uses the <code>adc</code> instruction to add the value of the carry flag into the BL register. Because the count is going to be less than 32, the result will fit comfortably into BL.</p>
<p>Tricky code or not, this instruction sequence is not particularly fast. The preceding loop always executes 32 times, so this code sequence executes 130 instructions (four instructions per iteration plus two extra instructions). </p>
<p>For a more efficient solution, use the <code>popcnt</code> instruction (<em>population count</em>, introduced in the SSE 4.1 instruction set), which counts the number of 1 bits in the source operand and stores the value into the destination operand:</p>
<pre><code>popcnt <var>reg</var><sub>dest</sub>, <var>reg</var><sub>src</sub>
popcnt <var>reg</var><sub>dest</sub>, <var>mem</var><sub>src</sub></code></pre>
<p>The operands must be the same size and must be 16, 32, or 64 bits.</p>
<h2 id="h1-501089c12-0011">	12.11	Reversing a Bit String</h2>
<p class="BodyFirst">Another common programming project instructors assign, and a useful function in its own right, is a program that reverses the bits in an operand. This program swaps the LO bit with the HO bit, bit 1 with the next-to-HO bit, and so on. The typical solution an instructor expects is the following:</p>
<pre><code>; Reverse the 32 bits in EAX, leaving the result in EBX: 

               mov cl, 32     ; Move current bit in EAX to 
RvsLoop:       shr eax, 1     ; the carry flag
                         
<span epub:type="pagebreak" title="740" id="Page_740"/>               rcl ebx, 1    ; Shift the bit back into 
                             ; EBX, backward
               dec cl  
               jnz RvsLoop </code></pre>
<p>As with the previous examples, this code suffers from repeating the loop 32 times, for a grand total of 129 instructions (for 32-bit operands, so double that for 64-bit operands). By unrolling the loop, you can get it down to 64 instructions, but this is still somewhat expensive.</p>
<p>The best solution to an optimization problem is often using a better algorithm rather than attempting to tweak your code by trying to choose faster instructions to speed it up. In the preceding section, for example, we were able to speed up counting the bits in a string by substituting a more complex algorithm for the simplistic “shift and count” algorithm. In the preceding example, the trick is to do as much work as possible in parallel.</p>
<p>Suppose that all we wanted to do was swap the even and odd bits in a 32-bit value. We can easily swap the even and odd bits in EAX by using the following code:</p>
<pre><code>mov edx, eax        ; Make a copy of the odd bits
shr eax, 1          ; Move the even bits to the odd positions
and edx, 55555555h  ; Isolate the odd bits
and eax, 55555555h  ; Isolate the even bits
shl edx, 1          ; Move the odd bits to even positions
or  eax, edx        ; Merge the bits and complete the swap</code></pre>
<p>Swapping the even and odd bits takes us part of the way to reversing all the bits in the number. After executing the preceding code sequence, you can swap adjacent pairs of bits to swap the bits in all the nibbles in the 32-bit value by using the following code:</p>
<pre><code>mov edx, eax        ; Make a copy of the odd-numbered bit pairs
shr eax, 2          ; Move the even bit pairs to the odd position
and edx, 33333333h  ; Isolate the odd pairs
and eax, 33333333h  ; Isolate the even pairs
shl edx, 2          ; Move the odd pairs to the even positions
or  eax, edx        ; Merge the bits and complete the swap</code></pre>
<p>After completing the preceding sequence, you swap the adjacent nibbles in the 32-bit register. Again, the only difference is the bit mask and the length of the shifts. Here’s the code:</p>
<pre><code>mov edx, eax        ; Make a copy of the odd-numbered nibbles
shr eax, 4          ; Move the even nibbles to the odd position
and edx, 0f0f0f0fh  ; Isolate the odd nibbles
and eax, 0f0f0f0fh  ; Isolate the even nibbles
shl edx, 4          ; Move the odd pairs to the even positions
or  eax, edx        ; Merge the bits and complete the swap</code></pre>
<p>You can probably see the pattern developing and can figure out that in the next two steps you have to swap the bytes and then the words in this <span epub:type="pagebreak" title="741" id="Page_741"/>object. You can use code like the preceding example, but there is a better way: use <code>bswap</code>. The <code>bswap</code> (<em>byte swap</em>) instruction uses the following syntax:</p>
<pre><code>bswap <var>reg</var><sub>32</sub> </code></pre>
<p>The <code>bswap</code> instruction swaps bytes 0 and 3 and bytes 1 and 2 in the specified 32-bit register, exactly what you want when reversing bits (and when converting data between little-endian and big-endian data formats, the principal use of this instruction). Rather than sticking in another 12 instructions to swap the bytes and then the words, you can simply use a <code>bswap eax</code> instruction to complete the job after the preceding instructions. The final code sequence is shown here:</p>
<pre><code>mov   edx, eax       ; Make a copy of the odd bits in the data
shr   eax, 1         ; Move the even bits to the odd positions
and   edx, 55555555h ; Isolate the odd bits
and   eax, 55555555h ; Isolate the even bits
shl   edx, 1         ; Move the odd bits to the even positions
or    eax, edx       ; Merge the bits and complete the swap

mov   edx, eax       ; Make a copy of the odd-numbered bit pairs
shr   eax, 2         ; Move the even bit pairs to the odd position
and   edx, 33333333h ; Isolate the odd pairs
and   eax, 33333333h ; Isolate the even pairs
shl   edx, 2         ; Move the odd pairs to the even positions
or    eax, edx       ; Merge the bits and complete the swap

mov   edx, eax       ; Make a copy of the odd-numbered nibbles
shr   eax, 4         ; Move the even nibbles to the odd position
and   edx, 0f0f0f0fh ; Isolate the odd nibbles
and   eax, 0f0f0f0fh ; Isolate the even nibbles
shl   edx, 4         ; Move the odd pairs to the even positions
or    eax,edx        ; Merge the bits and complete the swap

bswap eax            ; Swap the bytes and words</code></pre>
<p>This algorithm requires only 19 instructions and executes much faster than does the bit-shifting loop appearing earlier. Of course, this sequence does consume a little more memory. If you’re trying to save memory rather than clock cycles, the loop is probably a better solution.</p>
<h2 id="h1-501089c12-0012">	12.12	Merging Bit Strings</h2>
<p class="BodyFirst">Another common bit string operation is producing a single bit string by merging, or interleaving, bits from two different sources. The following example code sequence creates a 32-bit string by merging alternate bits from two 16-bit strings:</p>
<pre><code>; Merge two 16-bit strings into a single 32-bit string.
; AX - Source for even-numbered bits.
; BX - Source for odd-numbered bits.
<span epub:type="pagebreak" title="742" id="Page_742"/>; CL  - Scratch register.
; EDX - Destination register.

          mov  cl, 16 
MergeLp:  shrd edx, eax, 1     ; Shift a bit from EAX into EDX
          shrd edx, ebx, 1     ; Shift a bit from EBX into EDX
          dec  cl 
          jne  MergeLp; </code></pre>
<p>This particular example merges two 16-bit values together, alternating their bits in the result value. For a faster implementation of this code, unroll the loop to eliminate half the instructions.</p>
<p>With a few slight modifications, we can merge four 8-bit values together, or merge other bit sets from the source strings. For example, the following code copies bits 0 to 5 from EAX, then bits 0 to 4 from EBX, then bits 6 to 11 from EAX, then bits 5 to 15 from EBX, and finally bits 12 to 15 from EAX:</p>
<pre><code>shrd edx, eax, 6
shrd edx, ebx, 5
shrd edx, eax, 6
shrd edx, ebx, 11
shrd edx, eax, 4</code></pre>
<p>Of course, if you have BMI2 instructions available, you can also use the <code>pextr</code> instruction to extract various bits for insertion into another register.</p>
<h2 id="h1-501089c12-0013">	12.13	Extracting Bit Strings</h2>
<p class="BodyFirst">We can also extract and distribute bits in a bit string among multiple destinations. The following code takes the 32-bit value in EAX and distributes alternate bits among the BX and DX registers:</p>
<pre><code>           mov cl, 16   ; Count the loop iterations
ExtractLp: shr eax, 1   ; Extract even bits to (E)BX
           rcr ebx, 1 
           shr eax, 1   ; Extract odd bits to (E)DX
           rcr edx, 1 
           dec cl       ; Repeat 16 times
           jnz ExtractLp
           shr ebx, 16  ; Need to move the results from the HO
           shr edx, 16  ; bytes of EBX and EDX to the LO bytes</code></pre>
<p>This sequence executes 99 instructions (six inside the loop repeated 16 times plus three outside the loop). You can unroll the loop and pull other tricks, but it’s probably not worth the added complexity when it’s all said and done.</p>
<p><span epub:type="pagebreak" title="743" id="Page_743"/>If you have the BMI2 instruction set extensions available, you can also use the <code>pext</code> instruction to do this job efficiently:</p>
<pre><code>mov  ecx, 55555555h  ; Odd bit positions
pext edx, eax, ecx   ; Put odd bits into EDX
mov  ecx, 0aaaaaaaah ; Even bit positions
pext ebx, eax, ecx   ; Put even bits into EBX</code></pre>
<h2 id="h1-501089c12-0014">	12.14	Searching for a Bit Pattern</h2>
<p class="BodyFirst">Another bit-related operation you may need is the ability to search for a particular bit pattern in a string of bits. For example, you might want to locate the bit index of the first occurrence of <code>1011b</code> starting at some particular position in a bit string. In this section, we’ll explore some simple algorithms to accomplish this task.</p>
<p>To search for a particular bit pattern, we need to know four things: </p>
<ul>
<li>The pattern to search for (the <em>pattern</em>) </li>
<li>The length of the pattern we’re searching for </li>
<li>The bit string that we’re going to search through (the <em>source</em>) </li>
<li>The length of the bit string to search through </li>
</ul>
<p class="BodyContinued">The basic idea behind the search is to create a mask based on the length of the pattern and mask a copy of the source with this value. Then we can directly compare the pattern with the masked source for equality. If they are equal, you’re finished; if they’re not equal, increment a bit position counter, shift the source one position to the right, and try again. You repeat this operation <var>length</var><code>(</code><var>source</var><code>) - </code><var>length</var><code>(</code><var>pattern</var><code>)</code> times. The algorithm fails if it does not detect the bit pattern after this many attempts (because we will have exhausted all the bits in the source operand that could match the pattern’s length). Here’s a simple algorithm that searches for a 4-bit pattern throughout the EBX register:</p>
<pre><code>          mov cl, 28       ; 28 attempts because 32 - 4 = 28
                           ; (len(src) - len(pat))
          mov ch, 1111b    ; Mask for the comparison
          mov al, <var>pattern</var>  ; Pattern to search for
          and al, ch       ; Mask unnecessary bits in AL
          mov ebx, <var>source</var>  ; Get the source value
ScanLp:   mov dl, bl       ; Copy the LO 4 bits of EBX
          and dl, ch       ; Mask unwanted bits
          cmp al, dl       ; See if we match the pattern
          jz  Matched
          dec cl           ; Repeat specified number of times
          shr ebx, 1 
          jnz ScanLp 

; Do whatever needs to be done if we failed to 
; match the bit string. 

<span epub:type="pagebreak" title="744" id="Page_744"/>          jmp Done

Matched: 

; If we get to this point, we matched the bit string. 
; We can compute the position in the original source as 28 - CL.

Done: </code></pre>
<p>Bit-string scanning is a special case of string matching. <em>String matching</em> is a well-studied problem in computer science, and many of the algorithms you can use for string matching are applicable to bit-string matching as well. Such algorithms are beyond the scope of this chapter, but to give you a preview of how this works, you compute a function (like <code>xor</code> or <code>sub</code>) between the pattern and the current source bits and use the result as an index into a lookup table to determine how many bits you can skip. Such algorithms let you skip several bits rather than shifting only once for each iteration of the scanning loop (as is done by the previous algorithm).</p>
<h2 id="h1-501089c12-0015">	12.15	For More Information</h2>
<p class="BodyFirst">The AMD Athlon optimization guide contains useful algorithms for bit-based computations. To learn more about bit-searching algorithms, pick up a textbook on data structures and algorithms and study the section on string-matching algorithms.</p>
<p>Probably the ultimate book on bit twiddling is <em>Hacker’s Delight</em>, Second Edition, by Henry S. Warren (Addison-Wesley, 2012). While this book uses the C programming language for examples, almost all the concepts apply to assembly language programs as well.</p>
<h2 id="h1-501089c12-0016">	12.16	Test Yourself</h2>
<ol class="decimal">
<li value="1">What general instruction(s) would you use to clear bits in a register?</li>
<li value="2">What instruction could you use to clear a bit, specified by bit number, in a register?</li>
<li value="3">What general instruction would you use to set bits in a register?</li>
<li value="4">What instruction could you use to set a bit, specified by bit number, in a register?</li>
<li value="5">What general instruction would you use to invert bits in a register?</li>
<li value="6">What instruction could you use to invert a bit, specified by bit number, in a register? </li>
<li value="7">What general instruction would you use to test a bit (or group of bits) for 0 and 1 in a register?</li>
<li value="8">What instruction could you use to test a single bit, specified by bit number, in a register?</li>
<li value="9"><span epub:type="pagebreak" title="745" id="Page_745"/>What single instruction could you use to extract and coalesce a set of bits? </li>
<li value="10">What single instruction could you use to position and insert a set of bits in a register?</li>
<li value="11">What single instruction could you use to extract a bit substring from a larger bit string?</li>
<li value="12">What instruction allows you to search for the first set bit in a register? </li>
<li value="13">What instruction allows you to search for the last set bit in a register?</li>
<li value="14">How would you search for the first clear bit in a register?</li>
<li value="15">How would you search for the last clear bit in a register?</li>
<li value="16">What instruction can you use to count the number of bits in a register?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-1" href="#c12-footnoteref-1">1.</a></sup> Serial communications chips and other communications hardware that use parity for error checking normally compute the parity in hardware; you don’t have to use software for this purpose.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-2" href="#c12-footnoteref-2">2.</a></sup> See <span class="xref" itemid="xref_target_Listing 11-2 in Chapter 11"><a href="c11.xhtml#listing11-2">Listing 11-2</a> in Chapter 11</span> to see how to check for the presence of the BMI1 and BMI2 instruction set extensions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-3" href="#c12-footnoteref-3">3.</a></sup> This listing contains some common code that other listings in this chapter will share. The code unique to this listing appears between the <span class="LiteralFootnote"><code>; &gt;&gt;&gt;&gt;</code></span> and <span class="LiteralFootnote"><code>; &lt;&lt;&lt;&lt;</code></span> comments.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-4" href="#c12-footnoteref-4">4.</a></sup> Certain AMD processors include instructions for these operations. See the AMD literature for more details.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-5" href="#c12-footnoteref-5">5.</a></sup> See <span class="xref" itemid="xref_target_Listing 11-2 in Chapter 11"><a href="c11.xhtml#listing11-2">Listing 11-2</a> in Chapter 11</span> to see how to check for the presence of the BMI1 and BMI2 instruction set extensions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c12-footnote-6" href="#c12-footnoteref-6">6.</a></sup> That won’t happen in this example because 600 is evenly divisible by 8, but in general you can’t count on this; 2 extra bytes usually won’t hurt things.</p></aside>
</section>
</section>
</body></html>