- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 24 TEXT STRING SEARCHES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you’ve seen a number of searches, such as for files, directories,
    and even lost disk space. In this chapter, I’ll discuss the many ways of searching
    for text strings and possible applications for text searches. You’ll see searches
    for a single word, searches for one out of multiple possible words, and searches
    for a literal string containing multiple words. Another search flavor will look
    for a list of words and considers the search a success only if each and every
    word is found. I’ll show how to perform these searches against a file, multiple
    files, and other strings.
  prefs: []
  type: TYPE_NORMAL
- en: For performing these searches, I’ll compare and contrast two very different
    techniques. One is far more flexible, and the other executes much faster, so they’re
    both extremely useful. I’ll also discuss regular expressions and how you can use
    them to build some very impressive Batch searches.
  prefs: []
  type: TYPE_NORMAL
- en: Searching within a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate how to search each record in a file for a string, the first requirement
    is a file to search. In the real world, you might have a logfile containing tens
    of thousands of records with many clients interspersed; searching for a client
    name can extract all relevant entries for a more targeted report. Daily report
    files might each have totals at the end; a search on the Totals text can extract
    each of those trailer records from all of the report files in a certain directory.
    Better yet, you can search all files satisfying a file mask, maybe targeting files
    from the prior month or year.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this demonstration, I’ll use a much smaller (and I hope more interesting)
    input file, a file called *12Movies.txt* containing a not-so-random list of a
    dozen movies spanning three decades, organized by release date. Look closely for
    any commonalities with the titles. Here are its complete contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some are great movies, some not so great, and some I’ve never seen, but we’ll
    be using this file in many examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple String
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The findstr command is the primary Batch tool for finding a text string inside
    one or more files. Despite the abbreviation, coders refer to it as the *find string*
    command. You’ll soon see how versatile this command is, but I’ll start with a
    simple optionless command that searches for the word Little in the input file.
    The first argument is the search string, and the second argument is the file to
    be searched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command writes every record from the file containing the six consecutive
    letters in the search string to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the interpreter returns the first title even though it contains
    the search word appended with an s; the command isn’t searching for whole words.
    Also, this particular command sets the pseudo-environment variable errorlevel
    to 0, indicating that it found at least one instance of the search string. If
    it finds no matches, errorlevel takes on the value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, coders handle the output from this command in one of three ways.
    If you simply want to know whether one or more records exist, you need only interrogate
    errorlevel and move on. In other instances, you can redirect the list of returned
    records written to stdout to the console or an output file for later use or viewing.
    The last use is to programmatically process every returned record, which you can
    do by using a findstr command as input to a for /F command. For most of the upcoming
    examples, I’ll describe what’s written to stdout, but understand that the output
    has many different uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make a subtle change to the prior command and make the search string
    entirely lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This returns nothing because the findstr command performs case-sensitive searches,
    by default anyway, and every instance of the word in the file starts with an uppercase
    L. The other interesting result is that because the command returned nothing,
    1 is the value of errorlevel. Often, a case-sensitive search is exactly what you
    want; many other times, that’s exactly what you don’t want.
  prefs: []
  type: TYPE_NORMAL
- en: Customizations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fortunately, this command has a large number of options to customize each search.
    I’ll discuss many of them in this chapter, starting with a few options that change
    the behavior of the findstr command in simple yet powerful ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as the /i option invokes case-insensitivity of the if command, the same
    option works for the findstr command. (As mentioned in [Chapter 4](chapter4.xhtml),
    I use lowercase for this one option, but /I also works.) Notice the option and
    the odd capitalization of tHE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m not recommending a capitalization scheme such as this, but I do it here
    to unambiguously demonstrate the fact that the interpreter returns all four titles
    containing these three letters in this order, regardless of the case, as you can
    see in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful option is /E. With it, the command returns only the records
    it finds where the search string is at the *end* of the record. Consider this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only title returned is *Stuart Little*. Also notice this command uses multiple
    options for further customization; with the /i and /E options, it performs a case-insensitive
    search for records ending with the search string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the /B option returns only the records it finds where the search
    string is at the *beginning* of the record. You can team up this option with /i
    as well as the /N option, which prepends the *line number* to the returned record,
    delimited by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This findstr command returns the following four titles, all starting with big,
    case-insensitive, prepended with their corresponding line numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful option is /V, which negates the search logic. The following
    command is identical to the previous one, except it includes the /V option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The four records that were returned previously are now missing from the output,
    replaced with the other eight records not satisfying the search criteria. The
    line numbers are still at the front of each record because of the /N option, but
    the /V option alters the logic so that the output consists of all records *not*
    starting with big, case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Rounding out these options is /X, which finds only records that match the search
    string in their entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command returns a single title, the Tom Hanks film *Big*.
  prefs: []
  type: TYPE_NORMAL
- en: The one-character codes in the /i, /B, /E, and /N options are representative
    of their function, but /V, /X, and some others aren’t as obvious. Plan to make
    ample use of the help when working with the findstr command.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Words
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are multiple variants of a two-word search (when the search string has
    an embedded space). We can search for all records that have either word, both
    words, or a literal string of the two words separated by that space (or spaces).
    The findstr command handles all of them, although the variant searching for both
    words requires a little extra work. We can extrapolate these solutions to searches
    of more than two words.
  prefs: []
  type: TYPE_NORMAL
- en: Any Words in a List
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Instead of a one-word search string, the following findstr command has two
    words encased in double quotes. If you haven’t seen something like this before,
    you’re probably expecting it to return all titles with the word the followed by
    the word big, but that’s not the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In actuality, the double quotes encase the set of space-delimited search strings.
    The interpreter searches each record in the file for each word in the set of search
    strings, returning all records with at least one match. This command returns nine
    titles; all but three movies in the list contain either the word the or the word
    big, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding three specific words to the set of search strings returns all 12 titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The three additional words in the set of search strings are part of the words
    *Stuart*, *Shop*, and *Sunshine*, respectively, and each of those words is in
    one of the previously missing titles. Although, if you haven’t noticed yet, the
    two-word set of search strings, "big little", returns every record in the file
    more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A Literal String
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With a simple modification, you can alter the command searching for either
    of two words to search for a single string: the, followed by a space and big.
    The /C option defines a literal search string, and you must use it when the search
    string includes at least one space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen a case-insensitive search of *12Movies.txt*. In this example,
    I’ve inserted the /C: option in front of what’s now a literal search string encased
    in double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This findstr command returns just these two titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Both of these titles happen to start with the text, but a record with this literal
    string later in the title would’ve also been part of the output.
  prefs: []
  type: TYPE_NORMAL
- en: The literal search string doesn’t have to contain entire words. The following
    command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: returns the title *My Big Fat Greek Wedding*.
  prefs: []
  type: TYPE_NORMAL
- en: All Words in a List
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s just one movie title in the *12Movies.txt* file that contains two particular
    words of interest, Big and Little. Unfortunately, the findstr command cannot perform
    a single search to find all records containing both words, but with some ingenuity,
    you can meld two findstr commands together to get the job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This pipes the output of one findstr command—via the pipe character—to another
    findstr command (another application of the piping technique introduced in [Chapter
    12](chapter12.xhtml)). The first findstr command performs a case-insensitive search
    for the word big using the *12Movies.txt* file as its input. As you have seen
    by now, this command by itself writes seven titles to stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this isn’t a simple command. The interpreter writes the output, those seven
    records, to an unnamed temporary file and pipes, or feeds, it into the second
    findstr command, which is doing a case-insensitive search for the word little.
    Notice that I’m not defining an input file in the second command. It doesn’t need
    one, because its input is the output from the first findstr command. As the following
    output shows, of the seven titles that contain the word big, only one also contains
    the word little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The upshot is a search that returns only records containing both strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intermediate file is lost, but if you desire an audit trail of what transpired,
    you can redirect the output into a file. Then you can pipe a type command of that
    file into the second findstr command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The two commands find the same title, but now *BigMovies.txt* contains the seven
    records found with the first search string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this technique with any number of search strings. The following
    command again finds the one title, because it contains all four of the search
    strings, even if the third word is only a portion of a word in the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The trickiest part of this technique is making it readable. In this example,
    I’ve lined up all of the search strings, other than the first, by continuing the
    command on multiple lines with the trailing carets.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Multiple Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, I’ve performed the findstr command using a single input file,
    but you can search any number of files with a single invocation. The command accepts
    multiple files to search as additional arguments, and it also accepts file masks.
    The following command is looking for the miss text, regardless of the case, in
    the file we’ve been using and in any file that satisfies either of the two file
    masks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This example raises an issue of concern about the output because prior invocations
    have simply written each record found to stdout. That worked great when searching
    a single file, but when searching multiple files, this output would leave you
    no way of knowing the file of origin for each output record. The interpreter smartly
    detects the difference and outputs the path and filename with the record found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The command found *Little Miss Sunshine* in the *12Movies.txt* file as expected,
    and it also found the text in two records belonging to a file satisfying the trailing
    file mask, resulting in the last two lines of the output. The formatting leaves
    much to be desired. It’s hard to see where the filename ends and the record starts
    despite the colon delimiter. When writing the output to the console, the /A option
    highlights the path and filename to a color scheme of your choosing, but that
    obviously does nothing when you redirect the output to a file or pipe it to another
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The colon itself is an unfortunate choice for the delimiter because it’s often
    part of the path after the drive letter, as it is in this instance. If you want
    to parse this data, you could use a findstr command as input to a for /F command
    and delimit the output on the colon. But given this output, the path and filename
    would span the first two tokens with the actual record in the third. A delimiter
    that can’t be in a path or filename, such as a pipe, would’ve been a better idea,
    but you can still parse this with a little extra work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The /S option expands the search to include subdirectories. I often use it
    with wildcards to search all files in a directory tree or all files of a certain
    extension in a directory tree, but in the following example, I’m using an explicit
    filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter searches *C:\Batch\* and all of its subfolders for files named
    *12Movies.txt*. Then it searches each file found for records containing the search
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that I reintroduced the /N option mentioned previously. The output
    now contains the path and filename, the line number (delimited on either side
    with a colon), and the full record containing the search string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Two files in two directories have the same name, but the result of this command
    shows that their contents are quite different.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*When the findstr command doesn’t find any files that fit a file mask, it writes
    an error message to stderr saying it Cannot open the specific mask. If you have
    redirected both stdout and stderr to a trace file, the command intermingles the
    message with the desired output. If a mask might not be valid, suppressing stderr
    with the 2> nul syntax anticipates the possibility of the batveat and cleans up
    the output:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*The interpreter returns any records it finds in the valid file, but it sends
    the error message concerning the nonexistent directory to the nul file. This technique
    even works inside a routine or bat file with its stderr already redirected.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Auxiliary Search Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When your searches start to get more complex, you can more easily manage them
    with two auxiliary files, one that contains a list of search strings and another
    that contains a list of files to search.
  prefs: []
  type: TYPE_NORMAL
- en: File of Search Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I mentioned earlier how you can search for any of the strings in a list by
    encasing multiple space-delimited search strings in double quotes. That works
    great for a handful of strings, but when the list gets long enough to make a mess
    of the command, you can use the findstr command with a file containing the list
    of search strings. You define this file by entering it after the /G option, delimited
    by a colon. The following example performs case-sensitive searches for Little
    and four of its synonyms, and you can easily add many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I’m building the temporary file with hardcoded strings, but they could easily
    be variables or even come from user input, and because it’s a temporary file,
    I’m deleting it when I’m done with it. The output consists of all records containing
    at least one of these five strings, which in this case includes the six titles
    containing Little, plus *The Big Short*, with nothing found for the other three
    search strings.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is also helpful when the search criteria changes from execution
    to execution. You can generate a file dynamically in the code, or even update
    it manually, and you can run the same code with differing results.
  prefs: []
  type: TYPE_NORMAL
- en: File of Files to Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Taking this a step further, I’ll use the file just created containing the list
    of the search strings in tandem with another file containing the list of files
    to be searched. This *file of files (FOF)* is defined by the findstr command with
    the /F option. Similar to the /G option, the file comes after the option, delimited
    by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Oddly, you can use the /F option only when using the /G option.
  prefs: []
  type: TYPE_NORMAL
- en: If the list of files to search will be known only at the time of execution,
    you can build this FOF dynamically at runtime. This technique is also useful when
    you can’t easily define a set of files with a file mask. For instance, these options
    are ideal if you plan to search one of multiple sets of files, perhaps production
    or test sets of files partially named with a datestamp. You can also create the
    file of search strings with data entered by the user, perhaps a list of client
    names. If, however, the list of files to search is more consistent, you can use
    a static file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most compiled languages include a method that returns a boolean indicating whether
    a string is contained in part or in whole inside another string, because the need
    arises often in very disparate situations. In Batch, you can search a variable
    holding a path for a specific node or server name, or you might examine the path
    variable to see whether it holds a particular directory. You can even use this
    technique to validate user input, verifying that the response contains at least
    one word on a list.
  prefs: []
  type: TYPE_NORMAL
- en: There are two very different methods of finding out if a string contains another
    string. The makers of Batch designed the findstr command to search files, but
    the first method manipulates it to search a string. The second method is based
    on the text replacement syntax from [Chapter 5](chapter5.xhtml), and they each
    have significant advantages over the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**The **findstr** Method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding love can be difficult, but with the findstr command, finding the love
    string requires only a few lines of code. For this exercise, I’ll set the aString
    variable to one of two similar text strings giving advice to anyone planning a
    winter trip to one of two neighboring countries on the Adriatic Sea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I’ll step through a couple of upcoming code listings twice, with the variable
    set to each of these strings to demonstrate very different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you find love in either string? The findstr command can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To search aString for the love text, I employ the same piping technique used
    earlier, with the only difference being that instead of piping a multirecord file
    to the findstr command via a type command, I’m piping a variable via an echo command.
    In essence, I’m treating the contents of the variable as a single-record input
    file to the findstr command. The end result is that the command searches the string
    for the text.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the findstr command sets errorlevel to 0 when it finds the search
    string; otherwise, 1 is the value. If it’s 0, the code sets the bLove boolean
    to true; if not, the result is false.
  prefs: []
  type: TYPE_NORMAL
- en: First envision this logic with aString set to the Croatian string. The love
    text isn’t in the string, so the command returns 1, and we set the boolean to
    false. Now do the same with the string set to the Slovenian text. The love text
    is embedded in three different words in the short string—Bring g**love**s and
    a pul**love**r to S**love**nia. One or more matches sets errorlevel to 0, so we
    set the boolean to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice how easily we can convert this to a case-insensitive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Much of the flexibility present when searching a file is still available when
    searching a string. The options for targeting the beginning or ending of the string,
    negating the logic, and others work perfectly well in this context.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Text Replacement Method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind the text replacement method is as straightforward as its execution.
    The technique compares a resolved variable to itself with the search string removed.
    If they differ, we’ve found the search string; if they’re equal, we haven’t found
    the text. The following code uses this method to determine whether a string contains
    another string, in this case love, setting the same boolean from the prior example
    to true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The left side of the inequality is pedestrian by now, a resolved variable in
    double quotes. The if command compares it to "%aString:love=%", the same resolved
    variable, but with all instances of the love text replaced with null; notice that
    nothing comes between the equal sign and the terminating percent sign. The upshot
    is that if aString contains at least one instance of the love string, these two
    values differ, and we set the bLove boolean to true; if the search string isn’t
    inside the string we’re searching, the two values are identical, and we set bLove
    to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute this code with both possible values of aString. Assuming that
    it contains the Croatian text, the two values are identical because the love string
    isn’t to be found, and we set bLove to false. However, the text replacement syntax
    alters the Slovenian text by removing each of the three instances of the love
    string, resulting in this mess on the right side of the inequality: "Bring gs
    and a pulr to Snia." This clearly doesn’t equal the original text, so we set bLove
    to the value of true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delayed expansion makes this technique more generic, allowing you to use variables
    for both the search string and the string to search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now the search string and the string to search are variables, allowing you to
    determine both in the Batch code prior to performing this search.
  prefs: []
  type: TYPE_NORMAL
- en: When searching a string, both methods have a definitive place in the Batch universe.
    The biggest advantage of the findstr method is its flexibility, primarily its
    ability to perform case-sensitive searches, and you can use those options discussed
    earlier to easily customize any search. In contrast, the text replacement method
    is intrinsically case-insensitive because you can’t easily change the fact that
    the interpreter ignores the case of the text being changed.
  prefs: []
  type: TYPE_NORMAL
- en: The text replacement method has advantages of its own. First, I consider it
    a bit simpler to use. Neither method is complex, but an if command, even with
    delayed expansion, is even more straightforward than an echo piped to a findstr.
    But by far its primary advantage is performance.
  prefs: []
  type: TYPE_NORMAL
- en: When you call the findstr command, you’re actually calling a program, *findstr.exe*,
    and any program invocation involves more overhead than a simple comparison of
    two variables. They both happen in a fraction of a second, but the text replacement
    method happens in a much smaller fraction. You wouldn’t notice the distinction
    performing a handful of searches, but I tested both methods extensively and found
    the text replacement method to be more than 200 times faster than the findstr
    method. There are many variables to consider when testing performance and my testing
    is far from definitive, but it’s safe to say that a major advantage of the text
    replacement method is that it’s much faster.
  prefs: []
  type: TYPE_NORMAL
- en: In the final analysis, if your code is to perform a search repeatedly, say in
    a loop with possibly hundreds or even thousands of invocations, the replacement
    text method is the better choice. However, if efficiency isn’t a big concern or
    if you need a more complex search, even just a case-sensitive search, the findstr
    method is the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout this book I’ve more than hinted that Batch syntax can be esoteric
    and counterintuitive, even for someone who has coded in the language for many
    years. But somewhere out there someone of a contrarian bent is saying, “It isn’t
    that bad” or “Who among us hasn’t memorized all the options of the findstr command?”
    To this person I have two words: *regular expressions*, or *regex*.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are not unique to Batch. Many languages and editors use
    them as an incredibly powerful tool for searches. With regex, you can search for
    numeric values, non-numeric values, and very intricate patterns and ranges of
    characters. The /B and /E options of the findstr command allow you to search for
    text at the beginning or ending of a record, but regex allows you to do both in
    one command—that is, search for one string at the beginning and another string
    at the end of a record. Let’s see regex in action with a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Any Number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following findstr command using the regex option, denoted appropriately
    enough by /R, searches the *12Movies.txt* file to find all movies with at least
    one number in the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The regular expression [0-9] denotes all characters from 0 to 9, inclusive.
    Given the input file that we’ve been using throughout this chapter, the command
    returns just one title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were working with a more complete list of movies, the titles returned
    might include *2001: A Space Odyssey*, *12 Angry Men*, *The 12th Man*, and *Ocean’s
    11*, but not the remake *Ocean’s Eleven*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions also are effective when searching a string as opposed to
    a file. Consider the following example that uses negated logic (/V) for a regex
    (/R) search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The code prompts the user for a movie title without a number anywhere in the
    title. If they enter a typical movie sequel or a title such as *28 Days Later*,
    this logic prompts them to enter a different title until they finally abide by
    the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Searching with Complex Criteria
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a search that would be far more difficult without regex, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The leading caret isn’t an escape character in this context, but part of a string
    encased in double quotes. The caret is a regex indicator noting that the text
    after it is anchored to the beginning of the string, and the trailing dollar sign
    indicates the text before it is anchored to the end of the string. The 11 dots
    are wildcards, and the asterisk indicates that the wildcard just before it can
    be of any length, zero and up.
  prefs: []
  type: TYPE_NORMAL
- en: Putting this all together in a language that a non-regex-coder can understand,
    the search is looking for all records that start with The and end in Man, case-sensitive,
    with at least 10 characters, spaces included, between them.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute this command using a file containing a more complete list of
    movies, it might return the title *The Invisible Man* and even *The Amazing Spider-Man*.
    However, *The Amazing Spider-Man 2*, *The Music Man*, and the aforementioned *The
    12th Man* are out of the mix. (The first has a number appended to the title, and
    the other two are too short.)
  prefs: []
  type: TYPE_NORMAL
- en: To perform this same search without regex, you could pipe one findstr command
    using the /B option into another findstr command using the /E option, but you’d
    still need to filter out all of the titles with fewer than 10 characters between
    the two words; it’s possible, but oh so messy. Many other difficult to nearly
    impossible searches are more than possible with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of regular expressions commands its own book. I’ve demonstrated a
    couple of examples useful in Batch, but the next time one of your searches starts
    to get overly complex, look up the regex syntax for your problem in a book or
    on the internet, and give it a try with the findstr command and the /R option.
    Even experienced coders sometimes shy away from regex because of the complexity,
    but the power illustrated in these relatively simple examples is a window into
    other applications.
  prefs: []
  type: TYPE_NORMAL
- en: To make things a little more intriguing, Batch supports only a subset of the
    common regex functionality, so some regular expressions that work elsewhere don’t
    work in Batch. To state the obvious, rigorous testing is a must, with both positive
    and negative cases.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Record Count of a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hoarding may be a vice, but nothing ever gets truly thrown out in Batch. The
    copy command is useful for creating an empty file even though the xcopy and robocopy
    commands have long since superseded it for all copy-related functionality. Likewise,
    the find command is pretty much useless when compared to the findstr command,
    so I’ll forgo the discussion of how you would use it to perform a search. It does
    have one useful feature, however: getting the record count of a file. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This command performs a search for the null string between the double quotes,
    using *12Movies.txt* as its input. The /V option negates the search logic just
    as it does with the findstr command. It returns all records not containing the
    null string, which in effect returns every record in the file. The /C option gives
    the *count* of records returned, which is the number of records in the file since
    every record is returned, but what it writes to stdout is a bit more verbose than
    what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, and also oddly, the find command behaves differently when we
    pipe the input file into it via the type command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command succinctly writes the count, 12 in this instance, to stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture that value in a variable, we can execute the two piped commands
    as input to a for /F command, but we must escape the pipe before the find command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: (Notice the usebackq keyword and the back quotes encasing the input component
    of the for /F command, a combination that clearly shows command input.)
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like an awfully long walk to get a record count. Yes, with the
    use of escaping we are piping the output of one command (type) into a second command
    (find) and using its output as input to a third command (for) that has a code
    block containing a fourth command (set) that actually sets the variable. Phew.
    But it works and is elegant in its own special way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed many facets of Batch text searches. You learned
    how to perform searches for many different types of strings, how to search each
    record of a file, and how to search for one string inside another string.
  prefs: []
  type: TYPE_NORMAL
- en: I also compared and contrasted two different techniques for performing text
    searches. The findstr method is extremely powerful and flexible, and the text
    replacement method is easy, efficient, and lightning fast. You now know when to
    use each. I introduced regular expressions and demonstrated how immensely useful
    they are in complex searches. You even learned how to determine how many records
    are in a file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll introduce another fascinating and useful topic—code
    that writes code, specifically bat files that create other bat files.
  prefs: []
  type: TYPE_NORMAL
