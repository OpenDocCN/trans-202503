- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GENERATING
    SOUNDS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it’s time for something completely different! In this next project, you’ll
    create a song using JavaScript and the Web Audio API. You’ll also learn some general
    tips about sound synthesis and how electronic music is made.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce the Web Audio API and Tone.js, a JavaScript library
    built on top of it. This will be your first taste of the wide world of third-party
    JavaScript libraries, which are collections of prewritten code that you can harness
    to simplify complex tasks. Tone.js raises the level of abstraction compared with
    the Web Audio API, allowing you to think about and implement musical concepts
    in a more natural way. Once you’re familiar with how it works, in [Chapter 13](chapter13.xhtml)
    you’ll put everything you’ve learned to use to make a song that you can customize
    or even rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Web Audio API</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers the basics of the Web Audio API, which provides a way to
    create and manipulate sounds in the browser using JavaScript. Google Chrome introduced
    the Web Audio API in 2011, and soon after that it was released as a W3C standard
    (the W3C, or World Wide Web Consortium, is an organization that develops standards
    for the web). To use it, you create nodes and then connect them together. Each
    *node* represents some aspect of a sound—one node might generate a basic tone,
    a second node might set its volume, a third might apply an effect such as reverb
    or distortion to the tone, and so on. With this scheme, you can produce almost
    any kind of sound you might want.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As always, we’ll start with a simple HTML file. The file will give the user
    the ability to play a sound generated by the Web Audio API. Create a new directory
    called *music* and enter the content in [Listing 12-1](#Lis12-1) into a new file
    called *index.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring the Web Audio API</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing creates two visual elements: a Play button ❶ and a paragraph containing
    the text “Playing” ❷. The paragraph uses an inline style attribute, which allows
    us to add CSS declarations directly to the element from the HTML file. In this
    case, we’re setting display to none, which hides the element. Later, we’ll use
    JavaScript to remove the style and show the element when the audio is playing.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll start writing the JavaScript. In many browsers, including Google
    Chrome, the Web Audio API won’t play any sound until the user interacts with the
    page. We’re using the Play button as our interactive element, which will trigger
    our audio code. Because we only need the button to be clicked once, we’ll hide
    it after it’s been clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Create *script.js* in the same directory as the HTML file and add the content
    shown in [Listing 12-2](#Lis12-2). This code hides the Play button and shows the
    “Playing” text when the user clicks the button. Note that we’re not doing any
    Web Audio API code yet—this is just setting up the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Switching the
    visibility of the elements on a mouse click</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get references to the two elements using the document.querySelector
    method ❶. Then we add a click event listener to the Play button ❷. When the user
    clicks it, our event listener adds an inline style attribute of display: none
    to the button and sets the inline style of the paragraph to an empty string, effectively
    removing the inline style set as an attribute in the HTML file. The net effect
    of this code is that clicking the Play button will hide the button and show the
    paragraph. This has two purposes: it lets the user know that music should now
    be playing, and it removes the Play button so it can’t be clicked a second time.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone
    with the Web Audio API</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With our setup out of the way, we can now write some Web Audio API code. To
    get started, we’ll just generate a single tone, the audio equivalent of “Hello,
    world!” The code to generate the tone is shown in [Listing 12-3](#Lis12-3). As
    I mentioned earlier, the audio won’t play unless it’s triggered by a user event,
    such as a mouse click, so all the audio code lives inside the click handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Playing a single
    tone with the Web Audio API</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is create the *audio context* ❶. This is the object through
    which we interact with the Web Audio API, similar to the drawing context for the
    canvas element. Next, we create our first node, an oscillator ❷. In electronics
    and signal processing terms, an *oscillator* is a device that creates a signal
    that repeatedly goes up and down in a regular pattern. The default waveform a
    Web Audio API oscillator outputs is a sine wave, shown in [Figure 12-1](chapter12.xhtml#fig12-1).
    When the wave oscillates fast enough, and is connected to a speaker, it creates
    an audible tone. In this example, we’re setting the frequency to 440 Hertz (Hz),
    or 440 cycles per second. In other words, the oscillator is outputting a signal
    that transitions from 0 to 1 to –1 and back to 0 a total of 440 times every second.
    This means that one cycle of the wave lasts 1/440 of a second, or 2.27 ms. I used
    440 Hz here because it’s the standard reference pitch for tuning musical instruments.
    The frequency corresponds to the note A above middle C.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: One cycle of a
    sine wave</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a gain node ❸ and set its value to 0.5. In signal processing,
    *gain* refers to an increase or decrease in a signal’s amplitude, or its range
    of values. In practical terms, gain acts as a volume control. A gain of 2 doubles
    the amplitude, making the sound louder, a gain of 0.5 halves the amplitude, making
    the sound softer, and a gain of 1 (the default value of a gain node) has no effect
    on the amplitude. Applying a gain of 0.5 to the sine wave from [Figure 12-1](chapter12.xhtml#fig12-1)
    would produce a sine wave with a maximum value of 0.5 and a minimum value of –0.5,
    as shown in [Figure 12-2](chapter12.xhtml#fig12-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The sine wave
    from [Figure 12-1](chapter12.xhtml#fig12-1), with a gain of 0.5 applied</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we have two nodes: an oscillator node and a gain node. To actually apply
    the gain to the oscillator’s signal, we need to connect the nodes together. We
    link the output of the oscillator node to the input of the gain node using the
    oscillator node’s connect method ❹. Then, to be able to hear the result, we connect
    the output of the gain node to the main output, which is available to us through
    the audio context as ctx.destination. These connections mean that the oscillator
    signal is passed through the gain node and then passed to the output, which will
    ultimately go to your headphones or speakers, if the sound is turned on. [Figure
    12-3](chapter12.xhtml#fig12-3) illustrates these connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The graph of nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The oscillator node doesn’t actually create a signal until we tell it to. To
    do that, we call the start method on the oscillator, passing audioCtx .currentTime
    as an argument ❺. The currentTime property corresponds to the amount of time in
    seconds that the audio context has been active. By passing audioCtx.currentTime
    to the start method, we’re telling the oscillator to start playing immediately.
    Then we call the stop method, passing audioCtx .currentTime + 2. This tells the
    oscillator to stop two seconds after it started.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of all of this code is that when you load the *index.html* page in
    your browser and click the Play button, a tone of 440 Hz should play for two seconds.
    If you don’t hear anything, make sure sound is enabled on your computer and browser—for
    example, by playing a YouTube video. If it still doesn’t work, check the console
    to make sure there aren’t any errors.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that you just had to write a lot of code for a very simple
    example, and you’d be right! The Web Audio API is quite powerful, but you have
    to work at a very low level with extremely basic building blocks. To simplify
    things, next we’re going to shift our focus to a popular, higher-level audio library
    called Tone.js.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Library</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Tone.js library is built on top of the Web Audio API. It’s designed to make
    it easier to create music using the API. For example, instead of having to fiddle
    with oscillators and gain nodes, Tone.js lets you use electronic instruments with
    volume controls. Instead of using frequencies, you can use the names of musical
    notes. And instead of using seconds for controlling when events happen, you can
    use bars and beats.
  prefs: []
  type: TYPE_NORMAL
- en: The Tone.js website, [*https://<wbr>tonejs<wbr>.github<wbr>.io*](https://tonejs.github.io),
    provides details on installing and using the library. The easiest option is to
    use a prebuilt file hosted on a content delivery network (CDN) like [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com),
    which is what we’ll do here. This way all you have to do to access the library
    is reference a URL directly from a script element in your HTML file. There’s no
    need to download a copy of the library, as long as you have access to the internet
    while you’re working.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone
    with Tone.js</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s re-create our Web Audio API “Hello, world!” example using the Tone.js
    library instead. We can keep all the HTML the same, except for adding a new script
    tag for the library, as shown in [Listing 12-4](#Lis12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Including Tone.js
    in the</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We set the src of the new script element to an *unpkg.com* file containing the
    full Tone.js library as a single JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write the JavaScript. Since Tone.js uses the Web Audio API underneath,
    we still have the limitation that user input is required to start playing the
    audio. We therefore still need the click event handler, but everything else in
    *script.js* will change. [Listing 12-5](#Lis12-5) shows the updated JavaScript
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Playing a single
    tone with Tone.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is call Tone.start. This triggers the Tone.js
    library to start inside the click handler, ensuring that the browser will allow
    it to play audio. Next, we create a new Tone.Synth object. *Synth* is short for
    *synthesizer*, an electronic instrument, usually with a keyboard, that can generate
    (synthesize) all kinds of sounds. A Tone.Synth is a simple code version of such
    an instrument.
  prefs: []
  type: TYPE_NORMAL
- en: The Tone.Synth constructor takes an object as its argument that allows us to
    configure various aspects of the synthesizer. In this case, we’re telling the
    synth to use an oscillator that generates sine waves. We’re also giving the synth
    a simple amplitude envelope and a volume of -6. I’ll explain what these settings
    mean in the following section, but for now, this is what we need to match the
    Web Audio API oscillator from [Listing 12-3](#Lis12-3). After the constructor
    we chain the toDestination method, which connects the output of the synth to the
    audio context’s output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell the synth to play a single note using its triggerAttackRelease
    method. This method takes the note’s name, the duration, and the time at which
    to play the note. We’re passing "A4" for the note name, which is equivalent to
    440 Hz, and telling it to play for two seconds, starting immediately. When you
    reload your browser and click the Play button, you should hear the same sound
    as when you ran [Listing 12-3](#Lis12-3).
  prefs: []
  type: TYPE_NORMAL
- en: As you can hopefully see, using the Tone.js library simplifies the process of
    making music with the Web Audio API. Instead of having to create separate nodes
    for different aspects of a sound (pitch, gain, and so on), everything is unified
    under one Synth object. If you have any musical knowledge, you’ll also find that
    the library uses concepts much closer to your understanding than the API does,
    for example, by using note names instead of frequencies. As you learn more about
    Tone.js, you’ll see more examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding the
    Tone.Synth Options</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a closer look at the object we passed to the Tone.Synth constructor
    in [Listing 12-5](#Lis12-5). The first property, oscillator, defines the options
    for the oscillator generating the signal. In this case, we’re just setting the
    type of the oscillator to be a sine wave, using the type property.
  prefs: []
  type: TYPE_NORMAL
- en: The next property defines the options for the *amplitude envelope*, which determines
    how the volume of a note changes over the course of its duration. Most synthesizers,
    hardware and software, allow you to configure amplitude envelopes. The most common
    type of envelope is an *ADSR envelope*, short for *attack, decay, sustain, release*.
    The *attack* is the amount of time between the note being triggered (for example,
    when you press a key on a synthesizer) and the note reaching its maximum volume.
    The *decay* is the amount of time between the end of the attack and the sustain
    portion of the note. The *sustain* is a gain value that defines the volume the
    note will remain at after the attack and decay, for as long as the key is held
    down. Typically this is some fraction of the full volume achieved by the attack
    portion of the envelope. The *release* defines how long it will take for the note’s
    amplitude to get back down to zero after the key is released. [Figure 12-4](chapter12.xhtml#fig12-4)
    shows these different values graphically.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The parts of an
    ADSR envelope</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: ADSR envelopes are an approximation of how many real-world musical instruments
    work. For example, when you bow a violin, it takes some time for the note to get
    up to its full volume—that is, it has a long attack. By contrast, when you press
    a key on a piano, the attack is very short. Similarly, when you stop bowing a
    note on a violin it takes a little time for the string to stop vibrating, whereas
    the release of a piano note is more immediate. Synthetic ADSR envelopes are still
    pretty simplistic—they aren’t a perfect simulation of real-life instruments—but
    they add a lot of expressivity to what would otherwise just be a boring tone.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the ADSR envelope we’ve used for our synth is as boring as they come.
    We’ve set the attack, decay, and release values to 0 and the sustain to 1, meaning
    the tone is at full volume for its entire duration. This matches what we did with
    the simple Web Audio API oscillator from [Listing 12-3](#Lis12-3), and it’s part
    of why the resulting tone sounds so synthetic.
  prefs: []
  type: TYPE_NORMAL
- en: The final property of the synth options object, volume, sets the overall volume
    of the synthesizer in decibels (dB). Decibels are an alternative way to talk about
    gain, and in some ways they match the way we think about gain better. A setting
    of 0 decibels is equivalent to a gain of 1 (no change to the volume), –6 decibels
    is equivalent to a gain of 0.5, or half the volume, –12 decibels corresponds to
    a gain of 0.25, or a quarter of the volume, and so on; every +6 decibels doubles
    the volume, and every –6 decibels halves it. Our ears are attuned to the relative
    volume between sounds, so every time the level is halved or doubled, it sounds
    to us like it’s going down or up by a fixed amount. This “fixed amount” is a fixed
    number of decibels that are added or subtracted, which is why decibels can be
    easier to use for setting volume. In this case, we’re passing –6 dB to match the
    gain of 0.5 from [Listing 12-3](#Lis12-3).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what the options are, let’s try playing with them! First,
    we’ll modify the type of the oscillator. Currently the oscillator is set to generate
    a sine wave, but we’re going to switch to a square wave instead. [Figure 12-5](chapter12.xhtml#fig12-5)
    shows the waveform of a single cycle of a square wave.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: A square wave</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that a square wave has abrupt transitions between amplitude values, instead
    of the smooth curves of a sine wave. The code change to switch to a square wave
    oscillator is shown in [Listing 12-6](#Lis12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Changing the
    oscillator type to a square wave</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the code in your browser, you should hear a very different tone.
    The square wave is louder and brighter than the sine wave. Some other values you
    can try out for the oscillator type are "triangle" and "sawtooth". [Figure 12-6](chapter12.xhtml#fig12-6)
    shows the waveforms of these two.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: Sawtooth and triangle
    waves</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Think about how these other oscillator types differ from "sine" and "square".
    The distinctive sound of each oscillator is known as its *color*, or *timbre*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s try changing the envelope. We intentionally used a very basic envelope
    in [Listing 12-5](#Lis12-5) to match the Web Audio API example from [Listing 12-3](#Lis12-3),
    which had no envelope. Now we’ll set those values to something that sounds a little
    more musical, as shown in [Listing 12-7](#Lis12-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Changing the
    oscillator type to a square wave</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The values of attack, decay, and release are all given in seconds, while sustain
    is a number between 0 and 1 representing the amplitude level to be sustained at.
    Here we’re setting attack to 0.8 seconds, decay to 0.3 seconds, sustain to 0.8,
    and release to a whole second. When you reload the page and play the sound, you
    should hear the note slowly fade in to its max volume, then slightly reduce. After
    two seconds, the note is released and fades out over a second.
  prefs: []
  type: TYPE_NORMAL
- en: The final parameter to play with is the volume. As I explained earlier, every
    time you subtract 6 dB, the level is halved, and when you add 6 dB, it’s doubled.
    Try out some different values here, for example, –12, –18, or –24. You can also
    go the other way, up to 0 dB.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing More Notes
    in Sequence</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our synthesizer is currently playing only a single note, but we can easily play
    more notes. Note frequencies in Tone.js can be given in Hz or with note names,
    like A4, as we did in [Listing 12-5](#Lis12-5). These note names correspond to
    keys on a keyboard, as shown in [Figure 12-7](chapter12.xhtml#fig12-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_12-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: Note names on
    a keyboard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: C4 is known as *middle C* and is located near the middle of most piano keyboards.
    Each octave on the keyboard from each C to the B above is given a number. For
    example, the leftmost key in [Figure 12-7](chapter12.xhtml#fig12-7) is C3, and
    an octave above that is C4\. As mentioned previously, 440 Hz corresponds to A4,
    which is the A above C4\. The black notes are known as *accidentals* and are a
    semitone higher than the key to their left, or a semitone lower than the key to
    their right. For example, the black key to the right of C4 can be called C♯4 or
    D♭4 (♯ is the symbol for *sharp*, meaning a semitone higher, while ♭ is the symbol
    for *flat*, meaning a semitone lower). When writing note names in Tone.js, we
    use a hash mark (#) for sharp and the letter b for flat.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There are no black keys between B and C or E and F because these notes are
    only a semitone apart.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to play a major scale from A3 to A4, which consists of the notes
    A3, B3, C♯4, D4, E4, F♯4, G♯4, and A4\. Update your *script.js* to include the
    code in [Listing 12-8](#Lis12-8) to implement this scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Playing a scale</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to [Listing 12-5](#Lis12-5), except that we’re triggering
    multiple notes, one after the other. Notice we’ve updated the envelope to have
    a shorter attack and release ❶. The release, in particular, needs to be shorter
    so the end of each note doesn’t overlap with the start of the next.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, the second argument to triggerAttackRelease is the duration
    of the note in seconds, and the third argument is the time at which to play the
    note, also in seconds. The first note, A3, is played for 0.9 seconds, starting
    at time zero (that is, immediately). The 0.1-second release happens after the
    0.9-second duration, so each note will play for 1 second in total. The next note,
    B3, has the same duration, but the third argument of 1 means it will start a second
    later than the first note. The third note is programmed to start two seconds later
    than the first note, and so on for the rest of the notes. Play this in your browser,
    and you should hear a single octave of an A major scale.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing Multiple
    Notes at Once</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The synthesizer we’ve been using so far is a *monophonic synth*, meaning it
    can play only a single note at a time. To play multiple notes at once, we’ll need
    to create a *polyphonic synth* instead. In [Listing 12-9](#Lis12-9), we update
    the code to create a new polyphonic synth and play two or three notes at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Creating and
    playing a polyphonic synth</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we call new Tone.PolySynth instead of new Tone.Synth to create a polyphonic
    synth object. The Tone.PolySynth constructor takes two arguments: a monophonic
    synth (in this case, Tone.Synth) and an object with the options that would normally
    be passed to that monophonic synth’s constructor (in this case, the same synth
    options we passed to the Tone .Synth constructor in [Listing 12-8](#Lis12-8)).
    The polysynth then creates multiple monophonic synths with the specified settings,
    effectively allowing it to play multiple notes at once.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we play the same scale, but with additional simultaneous notes. This is
    achieved by passing an array of note names to the triggerAttackRelease method
    instead of a single note name—for example, we pass the array ["A3", "C#4"] to
    play A3 and C♯4 at the same time. By default, you can play a maximum of 32 notes
    with a polysynth.
  prefs: []
  type: TYPE_NORMAL
- en: When you play this example, you should hear a harmonized scale with a nice major
    chord at the end.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Transport</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve learned how to play notes, let’s look at how to make songs.
    Although you could program a whole song by specifying the timing of every single
    note, as you did to play a scale in the last few examples, this technique quickly
    gets tedious. Fortunately, Tone.js has a concept called the *transport* that makes
    writing songs much easier. The transport keeps track of the current position in
    the song, as measured in bars and beats. This lets you schedule notes to play
    at certain points in the song in a musically intuitive way. The transport also
    allows you to have looped sequences of notes that start playing at a certain point
    along the transport and repeat over and over until you tell them to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Western music tends to be structured around bars and beats, and it’s most common
    to have four beats in a bar. The speed of the music is given in *beats per minute
    (BPM)*, and in our examples we’ll be using the default Tone.js BPM of 120, which
    means a beat every 0.5 seconds. Beats are also known as *quarter notes* (because
    when there are four beats in a bar, one beat is a quarter of a bar). *Eighth notes*
    are half the duration of a quarter note, and *sixteenth notes* are half the duration
    of an eighth note, so there are four sixteenth notes per quarter note.
  prefs: []
  type: TYPE_NORMAL
- en: Positions along the transport are given as strings of three numbers separated
    by colons, like "0:0:0". The three numbers correspond to the current bar number,
    the current beat within that bar, and the current sixteenth note within that beat,
    respectively. Everything is zero-indexed. This means, for example, that "0:0:0"
    represents the beginning of the first bar, "1:1:0" represents the second beat
    of the second bar, and "6:3:2" refers to the third sixteenth note of the fourth
    beat in the seventh bar. We refer to these strings as *bars:quarters:sixteenths
    notation*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Loop</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Tone.js transport gives us an easy way to define musical loops, including
    when they start and when they finish. The simplest of these, Tone.Loop, defines
    a way to constantly produce new notes. Let’s try that out by playing a single
    note repeatedly every quarter note for four bars. Modify *script.js* with the
    code in [Listing 12-10](#Lis12-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: Looping</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a simple synth ❶. Notice we aren’t passing an object to
    define the oscillator, envelope, or volume options, so the synth will be created
    using the library’s default settings. Next, we create a new instance of Tone.Loop
    ❷, which has a constructor with two arguments. The first argument is some function
    that requires a time value, and the second argument is a duration indicating how
    often to call the function in the first argument. In this case, we pass the string
    "4n" as the second argument, which is Tone.js’s notation for a quarter note (“4n”
    is short for “1/4 note”). This means the loop will repeat every beat.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In our earlier listings we were passing numbers for durations, which give
    the duration in seconds. The advantage of using note length durations like "4n"
    for a quarter note or "16n" for a sixteenth note is that they will scale automatically
    if we change the BPM. For example, doubling the BPM will halve the duration of
    each quarter note.*'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the callback function we pass to Tone.Loop calls the triggerAttackRelease
    method on the synth to play the note C4 with a sixteenth note duration ❸. The
    third argument of the triggerAttackRelease method, time, represents the time to
    play a note. The Tone.Loop object will provide a new time value whenever it calls
    the callback function, filling it in with the appropriate location on the transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the start and stop methods on the loop returned by the Tone.Loop
    constructor ❹, passing the time when we want this loop to start and when we want
    it to stop, followed by a call to Tone.Transport.start, which starts the transport
    playing from the beginning. We start at "0:0:0", the beginning of the first bar,
    and stop at "4:0:0", the beginning of the fifth bar, meaning that this snippet
    will last four full bars with four beats each. Our loop repeats at every beat,
    playing one note each time, so we’ll play a total of 16 notes. Try reloading the
    page and see! You can use the musician’s trick of counting bars and beats like
    this: “*one* two three four, *two* two three four, *three* two three four, *four*
    two three four.” Notice that Tone.js doesn’t play a seventeenth note at time location
    "4:0:0" because the end of the loop isn’t inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-11](#Lis12-11) shows an alternative way of creating the same loop
    we wrote in [Listing 12-10](#Lis12-10). This time we chain the start and stop
    methods directly to the Tone.Loop constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-11: Looping with
    fewer lines of code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With this notation, we don’t need to create a variable to hold the Tone .Loop
    object, and we save a few lines of code by chaining the start and stop methods.
    We’ll be using this pattern in the rest of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Tone.Loop is basic, but it’s also quite versatile. You can run any arbitrary
    code in the callback, so you can do more than play the same note over and over.
    For example, you could choose to play a new random note each time. [Listing 12-12](#Lis12-12)
    shows how you could generate a short piece of music by randomly playing notes
    from a pentatonic, or five-note, scale (I chose a pentatonic scale here because
    any combination of notes in a pentatonic scale tends to sound pleasing).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-12: Using Tone.Loop
    to generate random music</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’re switching to a polysynth ❶ so we can play multiple notes
    at once. The notes array contains one octave of a C major pentatonic scale, including
    the C from the next octave ❷. Inside the Tone .Loop callback, we use a for loop
    to run some code three times. Each time around, we call Math.random() ❸, which
    returns a random number between 0 and 1, to determine whether to play a note or
    not. If the value is less than 0.5, we play a note. Otherwise, that note is skipped.
    The note name is determined by picking a random index into the notes array, using
    the code Math .floor(Math.random() * notes.length) ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The Tone.Loop object calls this code every eighth note ("8n") for eight bars
    ("0:0:0" to "8:0:0"). The effect of all this is that every eighth note, up to
    three notes from the array will be played (there’s no guarantee of uniqueness,
    so the same note could be played two or three times at once, causing that note
    to be louder). For each of the three notes, there’s a one in two chance it will
    be played, so overall there’s a one in eight chance that no notes will be played
    on any given eighth note.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Sequence</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section we’ll look at another Tone.js helper, called Tone.Sequence.
    This lets you provide a list of note names to be scheduled to play at regular
    intervals. You can repeat the whole sequence as many times as you want. As an
    example, we’ll create a repeating pattern of four notes: a G4 followed by three
    C4s. Update *script.js* with the code in [Listing 12-13](#Lis12-13).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-13: Creating a repeating
    sequence with Tone.Sequence</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to our first Tone.Loop example ([Listing 12-10](#Lis12-10)),
    but with two important changes. First, the callback function takes two arguments,
    time and note ❶, instead of a single time argument. Second, there’s an extra argument
    after the callback, which contains a list of notes ❷. Each time the callback is
    called, the next note in this list is passed as the note argument. It will keep
    cycling through the notes in the list over and over until it’s time to stop. The
    third argument to Tone.Sequence gives the duration between each callback ❸. In
    this case we’ve used "4n", which means that a new note will be played every quarter
    note.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this example, you should hear a pattern play for 4 bars, with
    4 beats per bar, making 16 notes in total. If we wrote out all the calls to synth.triggerAttackRelease
    manually, instead of relying on Tone.Sequence to automate them, they would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve just replaced the note and time arguments with what they would actually
    be for the first six calls of the callback. Notice how the second number is incrementing
    in the bars:quarters:sixteenths notation because of the "4n" we used as the duration
    between callbacks. (In practice, however, Tone.Sequence passes time as a number
    of seconds rather than using bars:quarters:sixteenths notation.)
  prefs: []
  type: TYPE_NORMAL
- en: If you want a sequence with some silent gaps (*rests* in musical terms), you
    can use null in place of a note name in the array of note names. Modify *script.js*
    with the code in [Listing 12-14](#Lis12-14) to see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-14: Adding rests
    with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">null</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a longer sequence of notes, with some nulls interspersed to insert
    pauses into the sequence. We’ve also changed the duration from "4n" to "8n", which
    means the notes will play twice as fast as before. When you play this updated
    example, you should hear a more interesting sequence of notes, including some
    rests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Part</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last of the transport helpers we’ll be looking at is Tone.Part. This is
    the most flexible of the helpers, as it allows us to specify the exact timing
    of every note played. With Tone.Part, instead of passing an array of note names,
    we pass an array of time/note pairs. For example, [["0:0:0", "C4"], ["0:1:0",
    "D4"], ["0:1:2", "E4"]] would play the three notes C4, D4, and E4 at the three
    times specified. This way, unlike with Tone.Loop and Tone.Sequence, the notes
    don’t have to be played at equal time intervals. Also, by default Tone.Part doesn’t
    loop, so the sequence of notes in the array is played only once. See the code
    in [Listing 12-15](#Lis12-15) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-15: Playing a melody
    with Tone.Part</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first change we’re making here is to the synth ❶. This time we’re back to
    using a polyphonic synth, so we can play multiple notes at the same time. Other
    than the synth being different, the body of the callback function is the same.
    We’re still calling synth.triggerAttackRelease and passing the note and time parameters,
    which Tone.Part will fill in automatically. Next comes the array of time/note
    pairs. You may notice that some of the notes are arrays themselves; for example,
    the first “note” in the list is ["C3", "E4"] ❷. This pair of notes will be passed
    to the triggerAttackRelease method unchanged and will have the effect of playing
    two notes at once, just like our other polyphonic synth examples.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call .start("0:0:0") ❸, which has the effect of playing this part
    immediately. If we used .start("1:0:0") instead, for example, then the melody
    would start after a bar’s pause. The times given for each time/note pair are relative
    to the time passed to the start method.
  prefs: []
  type: TYPE_NORMAL
- en: When you play this example, you should hear the beginning of “Mary Had a Little
    Lamb.”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making Drum Sounds</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most electronic music has some kind of drum beat. The drum sounds used to make
    the beat can come from audio files, or they can be synthesized. We’re going to
    be using the latter technique here. The core of a drum beat is built around three
    components: the kick drum (a “boom” sound), the snare drum (a “bah” sound), and
    the hi-hat (a “ti” sound). In this section, you’ll learn techniques for synthesizing
    those sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hi-Hat Synthesis</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A real-world hi-hat is made up of two cymbals facing each other. The top cymbal
    is connected to a pedal so the drummer can make the cymbals touch or move apart.
    We’re going for a closed (cymbals touching) sound here. When you hit closed hi-hats
    with a drum stick, they make a high-pitched noise that quickly fades away.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll approximate this by using a different kind of synth, a NoiseSynth, to
    generate white noise instead of notes with pitches. In signal processing, *white
    noise* is a random signal that has equal-level components at all frequencies.
    We’ll give the NoiseSynth an amplitude envelope that simulates the abrupt attacks
    of hitting the hi-hat with a stick. Finally, we’ll pass the noise through a *filter*—a
    device that allows through some frequencies while reducing the level of others—to
    remove the low frequencies and make it sound higher and more cymbal-like.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll set up the NoiseSynth and envelope, and play the hi-hat sound in
    a loop. Update your *script.js* with the code in [Listing 12-16](#Lis12-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-16: The beginnings
    of a hi-hat sound</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new NoiseSynth ❶, passing an amplitude envelope and a volume of
    –6 dB. The envelope has a very short attack (1/1000 of a second) and a longer
    decay (1/10 of a second), which is supposed to mimic the amplitude envelope of
    a hi-hat being struck. Because sustain and release are both set to 0, the sound
    will be over immediately after the initial attack and decay periods (0.001 + 0.1
    s). In particular, the sustain of 0 means the sound will sustain at 0 percent
    of its full volume, so even if the duration of the note is longer, you won’t hear
    anything after the attack and decay.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use Tone.Loop to play a continuous stream of eighth-note hi-hats for
    four bars ❷. Note that the triggerAttackRelease method on NoiseSynth doesn’t take
    a note name, because noise doesn’t have any particular pitch. You have to specify
    only the duration and the time when the note should be played.
  prefs: []
  type: TYPE_NORMAL
- en: When you play this example, you should hear a stream of hi-hat sounds. It doesn’t
    sound great yet, because we haven’t added the filter. We’ll do that in [Listing
    12-17](#Lis12-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-17: Applying a filter
    to the hi-hat sound</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use Tone.Filter to create a *bandpass filter* ❶. This kind of filter
    lets through (“passes”) only the frequencies at or around a frequency of your
    choice. In this case, we tell the filter to pass the band of frequencies around
    15,000 Hz, or 15 kHz, while eliminating all others. The human range of hearing
    is roughly 20 Hz to 20 kHz, so our filter lets through only parts of the noise
    that are very high in pitch.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 12-16](#Lis12-16), we used toDestination() on the NoiseSynth to
    connect it directly to the output. In [Listing 12-17](#Lis12-17), we’re instead
    connecting the filter to the output ❶, and then connecting the synth to the filter
    ❷. This means that the synth’s sound is run through the filter before being output
    through your speakers or headphones. As a result, when you play this example you
    should hear the same hi-hat sounds, but limited to high frequencies only, which
    sounds a bit more like a real hi-hat.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snare Synthesis</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section we’ll synthesize a snare drum. A snare drum has a series of
    wires (known as the *snare*) resting against the bottom drumhead that rattle against
    the drumhead when the drum is hit. This gives it a relatively complex sound, composed
    of some noise and some more pitched sound. To mimic this, we’ll use two separate
    sound sources: a noise synth and a regular synth with a fixed frequency. Both
    will have a short amplitude envelope to create a percussive feel, and we’ll also
    pass the noise component of the sound through a bandpass filter to make the snare
    lower than the hi-hat. We’ll create a new Snare class to encapsulate these details,
    as shown in [Listing 12-18](#Lis12-18).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-18: Synthesizing
    a snare drum</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, the Snare class has two methods, constructor and trigger AttackRelease.
    The constructor creates a filter and two synths. The trigger AttackRelease method
    calls the triggerAttackRelease methods on the two synths to play them simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we start by creating the filter ❶ and noise synth ❷. This
    is very similar to how we created the hi-hat, except we use a frequency of 5,000
    Hz for the bandpass filter, to reflect the lower sound of a snare drum. Next,
    we create the pitched synth ❸, which uses a similar amplitude envelope to the
    noise synth but with an even shorter attack to simulate the sound of a snare drum
    (in a real snare drum, the snares are triggered by the vibration of the drum skin,
    so they lag behind the sound of the drum slightly). The synth is configured with
    a sine wave oscillator. Since we’ll be playing the two synths simultaneously,
    we give each one a volume of –12, which results in an overall volume similar to
    the hi-hat.
  prefs: []
  type: TYPE_NORMAL
- en: The triggerAttackRelease method ❹ takes just a duration and a when parameter.
    These are passed to the underlying synths’ triggerAttackRelease methods. When
    we trigger the pitched synth, we give it a note name of "G3", which is the pitch
    I decided to tune the snare to. The inclusion of the pitched synth is subtle but
    makes the drum sound a bit more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate the class ❺, and finally we create a new Tone.Loop object
    ❻. This loop is four times as long as the hi-hat loop ("2n" instead of "8n", or
    a half note instead of an eighth note) and starts after one quarter note. This
    means there will be a snare hit on the second and fourth beats of every bar. When
    you play this example, you should hear the hi-hat every eighth note and the snare
    every two quarter notes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kick Synthesis</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last drum sound to synthesize is the kick drum. A kick drum is much larger
    than a snare drum, and it doesn’t have the rattling snare to make it sound noisy.
    The sound of a kick drum is fairly complex, but luckily Tone.js has a synth called
    a MembraneSynth that mimics it quite well. This synth takes a regular oscillator
    and lowers its frequency over a short period of time, which ends up sounding a
    lot like a kick drum when set up correctly. [Listing 12-19](#Lis12-19) shows how
    this is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-19: Synthesizing
    a kick drum</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The options for the MembraneSynth include pitchDecay ❶, which specifies in seconds
    how quickly the frequency should change, and octaves, which specifies how many
    octaves to drop the frequency in that time. In our loop ❷, we trigger the synth
    with a frequency of 50 Hz. This loop has the same "2n" duration as the snare loop,
    but starting at time zero, which means that the kick and snare sounds will alternate
    every quarter note, giving a classic rock drum beat. When you play this example,
    you might recognize it as the basic drum pattern of a lot of songs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverb</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Reverb* (short for *reverberation*) is an effect that makes music sound like
    it’s being played in a room or larger enclosed space. The random echoes that real-world
    sounds make as they bounce around the walls of a room are what give this reverb
    effect. Reverb makes each sound take a little time to die away, and it will make
    our drums sound a bit more realistic. We can add reverb with Tone.Reverb, as you’ll
    see in [Listing 12-20](#Lis12-20).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-20: Adding reverb</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we create our Reverb effect. The decay setting describes how long (in
    seconds) the reverberation will continue after the sound stops. The higher this
    number, the more echoey the effect. The wet setting specifies how much of the
    reverb sound is passed through compared with the original sound. In this case,
    0.3 means that the output of this effect will be 30 percent reverb and 70 percent
    the original sound. The higher the wet setting, the more prominent the reverb
    effect will be.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the changes in [Listing 12-20](#Lis12-20) replace any instances
    of toDestination() with connect(reverb). This way all the drum sounds are passed
    through the reverb effect before the reverb effect is sent to the output. When
    you play this example, the drums should sound more like they’re being played in
    a room. You can make the effect more pronounced by increasing the value of wet
    (to 0.6, say) or by increasing the decay in the Tone.Reverb settings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Drum Loop</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have our drum sounds set up, it would be nice to have an easier
    way to trigger them. Ideally, we would want to create a drum pattern by writing
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then we can let JavaScript do the work of converting that notation into code
    that Tone.js can understand. Here, each x represents a note, each dot (.) represents
    a silence, and each column represents an eighth note. For example, in the first
    eighth note the kick and hi-hat play, in the second only the hi-hat plays, in
    the third the snare and hi-hat play, and so on. The pattern shown here matches
    the drum beat we built up in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we’ll make a helper function that will convert a string
    of x’s and dots into an array of values that the Tone.Sequence transport helper
    can use. Recall that Tone.Sequence takes an array of note names and plays them
    repeatedly in sequence, with null being used for rests. Our function should convert
    dots to nulls, while leaving x’s the same.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since drum sounds don’t have note names, any string can actually represent
    a drum hit to Tone.Sequence (we’re just using x’s for convenience). All that matters
    is that it isn’t null.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-21](#Lis12-21) shows the definition of this function. Add it to
    your *script.js* file, before the current drum code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-21: The mkSequence
    helper function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The mkSequence function takes a string like "x…x…" and converts it to an array
    of strings and nulls, like ["x", null, null, null, "x", null, null, null], which
    is the format we need for Tone.Sequence. It splits the string into an array of
    individual characters using the split method and uses the array map method to
    create a new array by calling a function for each character. If the character
    is ".", then it replaces it with a null in the new array. Otherwise, it passes
    the character through unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create the strings that will be passed into this function, as shown
    in [Listing 12-22](#Lis12-22). Add this code after the mkSequence function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-22: Defining drumPattern</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’re storing the three strings in an object called drumPattern to keep them
    organized. I’ve added spaces to line up the strings so it’s easier to see the
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll use the helper and Tone.Sequence in place of our three existing
    calls to Tone.Loop, as shown in [Listing 12-23](#Lis12-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-23: Using mkSequence
    with Tone.Sequence</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in place
    of Tone.Loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we replace each of the Tone.Loop calls with the new Tone.Sequence calls.
    In each case we call mkSequence, passing one of the strings from our drumPattern
    object, which will create an array of x’s and nulls. The result of this call is
    passed to the Tone.Sequence helper, which we use to trigger the appropriate drum
    sounds. Again, Tone.Sequence will interpret any string, such as "x", as an appropriate
    note name for a drum hit, while the nulls represent silences. The last argument
    to Tone.Sequence, "8n", means that each dot or x in the drum pattern string represents
    an eighth note.
  prefs: []
  type: TYPE_NORMAL
- en: If you now reload the page, you should hear the same drum beat as before. This
    might seem like a lot of work to get the same output, but now we have a lot more
    flexibility to write different drum patterns, and we can easily modify them as
    we see fit. Try adding some extra snare or kick notes to the strings in drumPattern
    to see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Samples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important part of electronic music is *sampling*: using snippets of existing
    audio to build up a new piece of music. One common technique is to modify the
    playback speed of the samples to change their pitch, so a single sample can be
    used for multiple notes. If you’ve ever sped up a recording of someone’s voice
    to make them sound high-pitched like a chipmunk, or slowed it down to make them
    sound low-pitched like a giant, it’s the same principle.'
  prefs: []
  type: TYPE_NORMAL
- en: Tone.js makes it easy to work with samples with the Tone.Sampler instrument.
    This instrument acts a lot like the synths we’ve seen so far, in that it has a
    triggerAttackRelease method that lets you play a certain note at a certain time.
    The difference is that instead of using an oscillator or noise generator as a
    source, it plays a snippet of an audio file, possibly pitch-shifted to the requested
    pitch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any issues of copyright, I’ve sourced some samples from a free online
    sample database, [*https://<wbr>freesound<wbr>.org*](https://freesound.org). I’ve
    reuploaded them to Amazon S3 (Simple Storage Service) in such a way that you can
    access them directly from your code without having to download them (if you want
    to know the technical details, the files are in a public S3 bucket with CORS headers
    enabling access from any origin). The samples are of three different trumpet notes,
    and are found at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-c5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-c5.mp3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-d5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-d5.mp3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-f5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-f5.mp3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you enter any of these URLs into your web browser, the sample should play
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to load these samples into a new Tone.Sampler object. Tone.js
    lets you load all your samples from external URLs, such as our three S3 URLs,
    which we do in [Listing 12-24](#Lis12-24). Insert the new sampler code at the
    end of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-24: Creating a sampler</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create the sampler by passing a configuration object to the Tone.Sampler
    constructor. In this example, the configuration object contains five properties.
    The first property, urls, contains an object mapping note names to filenames.
    For example, we’re saying that the note name C5 corresponds to the filename *trumpet-c5.mp3*.
    Next, baseUrl defines the shared prefix of all the URLs, which saves us from having
    to write out the full URL for each sample. All the URLs are in the same S3 bucket,
    so we can use that as the base URL and then just provide the filenames in urls.
  prefs: []
  type: TYPE_NORMAL
- en: The sampler instrument doesn’t apply a full ADSR envelope when it plays samples,
    but it does allow you to set the attack (fade-in speed) and release (fade-out
    speed). We use an instant attack (because the sample already has its own attack),
    and a long release of one second. We also set volume to –24 dB so the sampler
    isn’t too loud. Finally, the onload property allows us to specify what happens
    once all the samples have been downloaded. In this example, we call triggerAttackRelease
    to play a three-note chord. Note that Tone.Sampler is by default polyphonic, so
    it can play multiple samples at once.
  prefs: []
  type: TYPE_NORMAL
- en: When you play this example, you’ll still hear the drums. Once the samples load,
    you should also hear a C major chord played by the trumpet sampler. One interesting
    thing to note here is that although we provided a sample for the note C5, we didn’t
    provide one for E5 or G5, the other pitches in the C major chord. When we tell
    the sampler to play these notes, it picks the closest provided sample and shifts
    its pitch by changing the playback speed. For instance, the closest sample to
    G5 has a pitch of F5, so this sample will be sped up slightly to sound like G5
    instead. As long as the note we’re trying to play isn’t too far away from one
    of the provided samples, it will sound fine. If we push it too far, however, the
    result won’t sound as realistic. For example, try raising the notes an octave
    by setting them to C6, E6, and G6 instead. They’ll start to sound a bit silly
    now. Also, because the samples are being played back twice as fast, they’re half
    the duration, so they won’t last the full bar they’re supposed to (the higher
    notes will finish earlier because they’re played back faster). You can also go
    the other way and set the notes to C4, E4, and G4\. This time the duration won’t
    be a problem, since the samples are being played slower in order to shift them
    down in pitch, but the notes still won’t sound as realistic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned about making sounds and music using the Web Audio
    API, and you saw how using a library like Tone.js can make your life much easier
    by hiding a lot of the lower-level details. You also learned a lot of tricks for
    sound synthesis and sampling using the Tone.js library. If some of the musical
    details went over your head, don’t worry. The most important thing here was getting
    used to working with a new JavaScript API and library. We’ll be putting all this
    to use in the next chapter, where we’ll write an actual song using the instruments
    created in this chapter!
  prefs: []
  type: TYPE_NORMAL
