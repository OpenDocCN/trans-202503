<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_155"/><span class="big">7</span><br/>SIMPLE CODE INJECTION TECHNIQUES FOR ELF</h2>&#13;
<p class="noindent">In this chapter, you’ll learn several techniques for injecting code into an existing ELF binary, allowing you to modify or augment the binary’s behavior. Although the techniques discussed in this chapter are convenient for making small modifications, they’re not very flexible. This chapter will demonstrate their limitations so you can understand the need for more comprehensive code modification techniques, which you’ll learn in <a href="ch09.xhtml#ch09">Chapter 9</a>.</p>&#13;
<h3 class="h3" id="ch07_1">7.1 Bare-Metal Binary Modification Using Hex Editing</h3>&#13;
<p class="noindent">The most straightforward way to modify an existing binary is by directly editing it using a <em>hex editor</em>, which is a program that represents the bytes of a binary file in hexadecimal format and allows you to edit these bytes. Usually, you’ll first use a disassembler to identify the code or data bytes you want to change and then use a hex editor to make the changes.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_156"/>The advantage of this approach is that it’s simple and requires only basic tools. The disadvantage is that it only allows in-place editing: you can change code or data bytes but not add anything new. Inserting a new byte causes all the bytes after it to shift to another address, which breaks references to the shifted bytes. It’s difficult (or even impossible) to correctly identify and fix all the broken references, because the relocation information needed for this is usually discarded after the linking phase. If the binary contains any padding bytes, dead code (such as unused functions), or unused data, you can overwrite those parts of the binary with something new. However, this approach is limited since most binaries don’t contain a lot of dead bytes that you can safely overwrite.</p>&#13;
<p class="indent">Still, in some cases hex editing may be all you need. For instance, malware uses anti-debugging techniques to check the environment it’s running in for signs of analysis software. If the malware suspects it’s being analyzed, it will refuse to run or attack the analysis environment. When you’re analyzing a malware sample and you suspect that it contains anti-debugging checks, you can disable them using hex editing to overwrite the checks with <span class="literal">nop</span> (do-nothing) instructions. Sometimes, you can even fix simple bugs in a program using a hex editor. To show you an example of this, I’ll use a hex editor called <span class="literal">hexedit</span>, an open source editor for Linux that comes preinstalled on the virtual machine, to fix an off-by-one bug in a simple program.</p>&#13;
<div class="box">&#13;
<h3 class="h3">Finding the Right Opcode</h3>&#13;
<p class="noindent">When you’re editing code in a binary, you need to know which values to insert, and for that, you need to know the format and hexadecimal encodings of the machine instructions. There are handy overviews online of the opcodes and operand formats for x86 instructions, such as <em><a href="http://ref.x86asm.net">http://ref.x86asm.net</a></em>. For more detailed information about how a given x86 instruction works, consult the official Intel manual.<em><sup>a</sup></em></p>&#13;
<p class="indent"><em>a</em>. <em><a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf</a></em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07_1_1"><em>7.1.1 Observing an Off-by-One Bug in Action</em></h4>&#13;
<p class="noindent"><em>Off-by-one bugs</em> typically occur in loops when the programmer uses an erroneous loop condition that causes the loop to read or write one too few or one too many bytes. The example program in <a href="ch07.xhtml#ch07list1">Listing 7-1</a> encrypts a file but accidentally leaves the last byte unencrypted because of an off-by-one bug. To fix this bug, I’ll first use <span class="literal">objdump</span> to disassemble the binary and locate the offending code. Then I’ll use <span class="literal">hexedit</span> to edit that code and remove the offby-one bug.</p>&#13;
<p class="listing1" id="ch07list1"><span epub:type="pagebreak" id="page_157"/><em>Listing 7-1:</em> xor_encrypt.c</p>&#13;
<p class="programs">   #include  &lt;stdio.h&gt;<br/>   #include  &lt;stdlib.h&gt;<br/>   #include  &lt;string.h&gt;<br/>   #include  &lt;stdarg.h&gt;<br/><br/>   void<br/>   die(char const *fmt, ...)<br/>   {<br/>     va_list args;<br/><br/>     va_start(args, fmt);<br/>     vfprintf(stderr, fmt, args);<br/>     va_end(args);<br/><br/>     exit(1);<br/>   }<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     FILE *f;<br/>     char *infile, *outfile;<br/>     unsigned char *key, *buf;<br/>     size_t i, j, n;<br/><br/>     if(argc != 4)<br/>       die("Usage: %s &lt;in file&gt; &lt;out file&gt; &lt;key&gt;\n", argv[0]);<br/><br/>     infile  = argv[1];<br/>     outfile = argv[2];<br/>     key     = (unsigned char*)argv[3];<br/><br/><span class="ent">➊</span>   f = fopen(infile, "rb");<br/>     if(!f) die("Failed to open file '%s'\n", infile);<br/><br/><span class="ent">➋</span>   fseek(f, 0, SEEK_END);<br/>     n = ftell(f);<br/>     fseek(f, 0, SEEK_SET);<br/><br/><span class="ent">➌</span>   buf = malloc(n);<br/>     if(!buf) die("Out of memory\n");<br/><br/><span class="ent">➍</span>   if(fread(buf, 1, n, f) != n)<br/>       die("Failed to read file '%s'\n", infile);<br/><br/><span class="ent">➎</span>   fclose(f);<span epub:type="pagebreak" id="page_158"/><br/><br/>     j = 0;<br/><span class="ent">➏</span>   for(i = 0; i &lt; n-1; i++) { /* Oops! An off-by-one error! */<br/>       buf[i] ^= key[j];<br/>       j = (j+1) % strlen(key);<br/>     }<br/><br/><span class="ent">➐</span>   f = fopen(outfile, "wb");<br/>    if(!f) die("Failed to open file '%s'\n", outfile);<br/><br/><span class="ent">➑</span>   if(fwrite(buf, 1, n, f) != n)<br/>       die("Failed to write file '%s'\n", outfile);<br/><br/><span class="ent">➒</span>   fclose(f);<br/><br/>     return 0;<br/>  }</p>&#13;
<p class="indent">After parsing its command line arguments, the program opens the input file to encrypt <span class="ent">➊</span>, determines the file size and stores it in a variable called <span class="literal">n</span> <span class="ent">➋</span>, allocates a buffer <span class="ent">➌</span> to store the file in, reads the entire file into the buffer <span class="ent">➍</span>, and then closes the file <span class="ent">➎</span>. If anything goes wrong along the way, the program calls the <span class="literal">die</span> function to print an appropriate error message and exit.</p>&#13;
<p class="indent">The bug is in the next part of the program, which encrypts the file bytes using a simple <span class="literal">xor</span>-based algorithm. The program enters a <span class="literal">for</span> loop to loop over the buffer containing all the file bytes and encrypts each byte by computing its <span class="literal">xor</span> with the provided key <span class="ent">➏</span>. Note the loop condition of the <span class="literal">for</span> loop: the loop starts at <span class="literal">i = 0</span> but only loops while <span class="literal">i &lt; n-1</span>. That means the last encrypted byte is at index <span class="literal">n-2</span> in the buffer, so the final byte (at index <span class="literal">n-1</span>) is left unencrypted! This is the off-by-one bug, which we’ll fix using a hex editor to edit the binary.</p>&#13;
<p class="indent">After encrypting the file buffer, the program opens an output file <span class="ent">➐</span>, writes the encrypted bytes to it <span class="ent">➑</span>, and finally closes the output file <span class="ent">➒</span>. <a href="ch07.xhtml#ch07list2">Listing 7-2</a> shows an example run of the program (compiled using the Makefile provided on the virtual machine) where you can observe the off-by-one bug in action.</p>&#13;
<p class="listing1" id="ch07list2"><em>Listing 7-2: Observing the off-by-one bug in the</em> <span class="codeitalic">xor_encrypt</span> <em>program</em></p>&#13;
<p class="programs"><span class="ent">➊</span>  $ <span class="codestrong1">./xor_encrypt xor_encrypt.c encrypted foobar</span><br/><span class="ent">➋</span>  $ <span class="codestrong1">xxd xor_encrypt.c | tail</span><br/>   000003c0: 6420 746f 206f 7065 6e20 6669 6c65 2027  d to open file '<br/>   000003d0: 2573 275c 6e22 2c20 6f75 7466 696c 6529  %s'\n", outfile)<br/>   000003e0: 3b0a 0a20 2069 6628 6677 7269 7465 2862  ;.. if(fwrite(b<br/>   000003f0: 7566 2c20 312c 206e 2c20 6629 2021 3d20  uf, 1, n, f) !=<br/>   00000400: 6e29 0a20 2020 2064 6965 2822 4661 696c  n).    die("Fail<br/><span epub:type="pagebreak" id="page_159"/>&#13;
   00000410: 6564 2074 6f20 7772 6974 6520 6669 6c65  ed to write file<br/>   00000420: 2027 2573 275c 6e22 2c20 6f75 7466 696c  '%s'\n", outfil<br/>   00000430: 6529 3b0a 0a20 2066 636c 6f73 6528 6629  e);.. fclose(f)<br/>   00000440: 3b0a 0a20 2072 6574 7572 6e20 303b 0a7d  ;..   return 0;.}<br/>   00000450: 0a<span class="ent">➌</span>0a                             ..<br/><span class="ent">➍</span>  $ <span class="codestrong1">xxd encrypted | tail</span><br/>   000003c0: 024f 1b0d 411d 160a 0142 071b 0a0a 4f45  .O..A....B....OE<br/>   000003d0: 4401 4133 0140 4d52 091a 1b04 081e 0346  D.A3.@MR.......F<br/>   000003e0: 5468 6b52 4606 094a 0705 1406 1b07 4910  ThkRF..J......I.<br/>   000003f0: 1309 4342 505e 4601 4342 075b 464e 5242  ..CBP<img src="Images/page_159_inline.jpg" alt="image"/>.CB.[FNRB<br/>   00000400: 0f5b 6c4f 4f42 4116 0f0a 4740 2713 0f03  .[lOOBA...G@'...<br/>   00000410: 0a06 4106 094f 1810 0806 034f 090b 0d17  ..A..O.....O....<br/>   00000420: 4648 4a11 462e 084d 4342 0e07 1209 060e  FHJ.F..MCB......<br/>   00000430: 045b 5d65 6542 4114 0503 0011 045a 0046  .[]eeBA......Z.F<br/>   00000440: 5468 6b52 461d 0a16 1400 084f 5f59 6b0f  ThkRF......O_Yk.<br/>   00000450: 6c<span class="ent">➎</span>0a                                    l.</p>&#13;
<p class="indent">In this example, I’ve used the <span class="literal">xor_encrypt</span> program to encrypt its own source file using the key <span class="literal">foobar</span>, writing the output to a file called <em>encrypted</em> <span class="ent">➊</span>. Using <span class="literal">xxd</span> to view the contents of the original source file <span class="ent">➋</span>, you can see that it ends with the byte <span class="literal">0x0a</span> <span class="ent">➌</span>. In the encrypted file, all bytes are garbled <span class="ent">➍</span>except the last one, which is the same as in the original file <span class="ent">➎</span>. This is because the off-by-one bug causes the last byte to be left unencrypted.</p>&#13;
<h4 class="h4" id="ch07_1_2"><em>7.1.2 Fixing the Off-by-One Bug</em></h4>&#13;
<p class="noindent">Now let’s take a look at how to fix the off-by-one bug in the binary. In all examples in this chapter, you can pretend you don’t have the source code of the binaries you’re editing, even though you really do. This is to simulate real-life cases where you’re forced to use binary modification techniques, such as when you’re working on a proprietary or malicious program or a program whose source code is lost.</p>&#13;
<h3 class="h3">Finding the Bytes That Cause the Bug</h3>&#13;
<p class="noindent">To fix the off-by-one bug, you need to change the loop condition so that it loops one more time to encrypt the last byte. Therefore, you first need to disassemble the binary and find the instructions responsible for enforcing the loop condition. <a href="ch07.xhtml#ch07list3">Listing 7-3</a> contains the relevant instructions as shown by <span class="literal">objdump</span>.</p>&#13;
<p class="listing1" id="ch07list3"><em>Listing 7-3: Disassembled code showing the off-by-one bug</em></p>&#13;
<p class="programs"><span class="codestrong1">  $ objdump -M intel -d xor_encrypt</span><br/>  ...<br/>  4007c2:  49 8d 45 ff             lea         rax,[r13-0x1]<br/>  4007c6:  31 d2                   xor         edx,edx<br/>  4007c8:  48 85 c0                test        rax,rax<br/>  4007cb:  4d 8d 24 06             lea         r12,[r14+rax*1]<br/>  4007cf:  74 2e                   je          4007ff &lt;main+0xdf&gt;<br/>  4007d1:  0f 1f 80 00 00 00 00    nop         DWORD PTR [rax+0x0]<br/><span class="ent">➊</span> 4007d8: 41 0f b6 04 17           movzx       eax,BYTE PTR [r15+rdx*1]<br/>  4007dd:  48 8d 6a 01             lea         rbp,[rdx+0x1]<br/>  4007e1:  4c 89 ff                mov         rdi,r15<br/>  4007e4:  30 03                   xor         BYTE PTR [rbx],al<br/>  4007e6:  48 83 c3 01            <span class="ent">➋</span>add         rbx,0x1<br/>  4007ea:  e8 a1 fe ff ff          call        400690 &lt;strlen@plt&gt;<br/>  4007ef:  31 d2                   xor         edx,edx<br/>  4007f1:  48 89 c1                mov         rcx,rax<br/>  4007f4:  48 89 e8                mov         rax,rbp<br/>  4007f7:  48 f7 f1                div         rcx<br/>  4007fa:  49 39 dc               <span class="ent">➌</span>cmp         r12,rbx<br/>  4007fd:  75 d9                  <span class="ent">➍</span>jne         4007d8 &lt;main+0xb8&gt;<br/>  4007ff:  48 8b 7c 24 08          mov         rdi,QWORD PTR [rsp+0x8]<br/>  400804:  be 66 0b 40 00          mov         esi,0x400b66<br/>...</p>&#13;
<p class="indent"><a id="page_160"/>The loop starts at address <span class="literal">0x4007d8</span> <span class="ent">➊</span>, and the loop counter (<span class="literal">i</span>) is contained in the <span class="literal">rbx</span> register. You can see the loop counter being incremented in each loop iteration <span class="ent">➋</span>. You can also see a <span class="literal">cmp</span> instruction <span class="ent">➌</span> that checks whether another loop iteration is needed. The <span class="literal">cmp</span> compares <span class="literal">i</span> (stored in <span class="literal">rbx</span>) to the value <span class="literal">n-1</span> (stored in <span class="literal">r12</span>). If another loop iteration is needed, the <span class="literal">jne</span> instruction <span class="ent">➍</span> jumps back to the start of the loop. If not, it falls through to the next instruction, ending the loop.</p>&#13;
<p class="indent">The <span class="literal">jne</span> instruction stands for “jump if not equal”<sup><a id="ch07fn_1a" href="footnote.xhtml#ch07fn_1">1</a></sup>: it jumps back to the start of the loop if <span class="literal">i</span> is not equal to <span class="literal">n-1</span> (as determined by the <span class="literal">cmp</span>). In other words, since <span class="literal">i</span> is incremented in each loop iteration, the loop will run while <span class="literal">i &lt; n-1</span>. But to fix the off-by-one bug, you want the loop to run while <span class="literal">i &lt;= n-1</span> so that it runs one more time.</p>&#13;
<h3 class="h3">Replacing the Offending Bytes</h3>&#13;
<p class="noindent">To implement this fix, you can use a hex editor to replace the opcode for the <span class="literal">jne</span> instruction, turning it into a different kind of jump. The <span class="literal">cmp</span> has <span class="literal">r12</span> (containing <span class="literal">n-1</span>) as its first operand, followed by <span class="literal">rbx</span> (containing <span class="literal">i</span>). Thus, you should use a <span class="literal">jae</span> (“jump if above or equal”) instruction so that the loop runs while <span class="literal">n-1 &gt;= i</span>, which is just another way of saying <span class="literal">i &lt;= n-1</span>. Now you can implement this fix using <span class="literal">hexedit</span>.</p>&#13;
<p class="indent">To follow along, go to the code folder for this chapter, run the Makefile, and then type <span class="literal">hexedit xor_encrypt</span> on the command line and press ENTER to open the <span class="literal">xor_encrypt</span> binary in the hex editor (it’s an interactive program). To find the specific bytes to modify, you can search for a byte pattern taken from a disassembler like <span class="literal">objdump</span>. In the case of <a href="ch07.xhtml#ch07list3">Listing 7-3</a>, you can see that the <span class="literal">jne</span> instruction you need to modify is encoded with the hexadecimal byte string <span class="literal">75d9</span>, so you’ll search for that pattern. In larger binaries, you’ll want <span epub:type="pagebreak" id="page_161"/>to use longer patterns, possibly including bytes from other instructions, to ensure uniqueness. To search for a pattern in <span class="literal">hexedit</span>, press the / key. This should open up a prompt like the one shown in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>, where you can enter the search pattern <span class="literal">75d9</span> and then press ENTER to start the search.</p>&#13;
<div class="image"><a id="ch07fig1"/><img src="Images/f161-01.jpg" alt="image" width="674" height="422"/></div>&#13;
<p class="fig-caption"><em>Figure 7-1: Searching for a byte string with</em> <span class="literal">hexedit</span></p>&#13;
<p class="indent">The search finds the pattern and moves the cursor to the first byte of the pattern. Referring to an x86 opcode reference or the Intel x86 manual, you can see that the <span class="literal">jne</span> instruction is encoded as an opcode byte (<span class="literal">0x75</span>) followed by a byte that encodes an offset to the jump location (<span class="literal">0xd9</span>). For these purposes, you just want to replace the <span class="literal">jne</span> opcode, <span class="literal">0x75</span>, with the opcode for a <span class="literal">jae</span> instruction, which is <span class="literal">0x73</span>, leaving the jump offset unchanged. Since the cursor is already on the byte you want to modify, all it takes to make the edit is to type the new byte value, <span class="literal">73</span>. As you type, <span class="literal">hexedit</span> highlights the modified byte value in boldface. Now, all that’s left is to save the modified binary by pressing CTRL-X to exit and then pressing Y to confirm the change. You’ve now fixed the off-by-one bug in the binary! Let’s confirm the change by using <span class="literal">objdump</span> again, as shown in <a href="ch07.xhtml#ch07list4">Listing 7-4</a>.</p>&#13;
<p class="listing1" id="ch07list4"><em>Listing 7-4: Disassembly showing the patch for the off-by-one bug</em></p>&#13;
<p class="programs"><span class="codestrong1">$ objdump -M intel -d xor_encrypt.fixed</span><br/>...<br/>4007c2:  49 8d 45 ff              lea         rax,[r13-0x1]<br/>4007c6:  31 d2                    xor         edx,edx<br/>4007c8:  48 85 c0                 test        rax,rax<br/>4007cb:  4d 8d 24 06              lea         r12,[r14+rax*1]<br/>4007cf:  74 2e                    je          4007ff &lt;main+0xdf&gt;<br/>4007d1:  0f 1f 80 00 00 00 00     nop         DWORD PTR [rax+0x0]<br/>4007d8:  41 0f b6 04 17           movzx       eax,BYTE PTR [r15+rdx*1]<br/>4007dd:  48 8d 6a 01              lea         rbp,[rdx+0x1]<br/>4007e1:  4c 89 ff                 mov         rdi,r15<br/>4007e4:  30 03                    xor         BYTE PTR [rbx],al<br/>4007e6:  48 83 c3 01              add         rbx,0x1<br/>4007ea:  e8 a1 fe ff ff           call        400690 &lt;strlen@plt&gt;<br/>4007ef:  31 d2                    xor         edx,edx<br/>4007f1:  48 89 c1                 mov         rcx,rax<br/>4007f4:  48 89 e8                 mov         rax,rbp<br/>4007f7:  48 f7 f1                 div         rcx<br/>4007fa:  49 39 dc                 cmp         r12,rbx<br/>4007fd:  73 d9                   <span class="ent">➊</span>jae         4007d8 &lt;main+0xb8&gt;<br/>4007ff:  48 8b 7c 24 08           mov         rdi,QWORD PTR [rsp+0x8]<br/>400804:  be 66 0b 40 00           mov         esi,0x400b66<br/>...</p>&#13;
<p class="indent"><a id="page_162"/>As you can see, the original <span class="literal">jne</span> instruction is now replaced by <span class="literal">jae</span> <span class="ent">➊</span>. To check that the fix works, let’s run the program again to see whether it encrypts the last byte. <a href="ch07.xhtml#ch07list5">Listing 7-5</a> shows the results.</p>&#13;
<p class="listing1" id="ch07list5"><em>Listing 7-5: Output of the fixed</em> <span class="codeitalic">xor_encrypt</span> <em>program</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">./xor_encrypt xor_encrypt.c encrypted foobar</span><br/><span class="ent">➋</span> $ <span class="codestrong1">xxd encrypted | tail</span><br/>  000003c0: 024f 1b0d 411d 160a 0142 071b 0a0a 4f45 .O..A....B....OE<br/>  000003d0: 4401 4133 0140 4d52 091a 1b04 081e 0346 D.A3.@MR.......F<br/>  000003e0: 5468 6b52 4606 094a 0705 1406 1b07 4910 ThkRF..J......I.<br/>  000003f0: 1309 4342 505e 4601 4342 075b 464e 5242 ..CBP<img src="Images/page_159_inline.jpg" alt="image" width="7" height="17"/>.CB.[FNRB<br/>  00000400: 0f5b 6c4f 4f42 4116 0f0a 4740 2713 0f03 .[lOOBA...G@'...<br/>  00000410: 0a06 4106 094f 1810 0806 034f 090b 0d17 ..A..O.....O....<br/>  00000420: 4648 4a11 462e 084d 4342 0e07 1209 060e FHJ.F..MCB......<br/>  00000430: 045b 5d65 6542 4114 0503 0011 045a 0046 .[]eeBA......Z.F<br/>  00000440: 5468 6b52 461d 0a16 1400 084f 5f59 6b0f ThkRF......O_Yk.<br/>  00000450: 6c<span class="ent">➌</span>65                                   le</p>&#13;
<p class="indent">As before, you run the <span class="literal">xor_encrypt</span> program to encrypt its own source code <span class="ent">➊</span>. Recall that in the original source file, the last byte’s value was <span class="literal">0x0a</span> (see <a href="ch07.xhtml#ch07list2">Listing 7-2</a>). Using <span class="literal">xxd</span> to inspect the encrypted file <span class="ent">➋</span>, you can see that even the last byte is now properly encrypted <span class="ent">➌</span>: it’s now <span class="literal">0x65</span> instead of <span class="literal">0x0a</span>.</p>&#13;
<p class="indent">You now know how to edit a binary using a hex editor! Although this example was simple, the procedure is the same for more complex binaries and edits.</p>&#13;
<h3 class="h3" id="ch07_2"><span epub:type="pagebreak" id="page_163"/>7.2 Modifying Shared Library Behavior Using LD_PRELOAD</h3>&#13;
<p class="noindent">Hex editing is a nice way of making modifications to your binaries because it requires only basic tools, and since the modifications are small, edited binaries usually have virtually no performance or code/data size overhead compared to the original. However, as you’ve seen in the example in the previous section, hex editing is also tedious, error-prone, and restrictive because you cannot add new code or data. If your goal is to modify the behavior of shared library functions, you can achieve this more easily using <span class="literal">LD_PRELOAD</span>.</p>&#13;
<p class="indent"><span class="literal">LD_PRELOAD</span> is the name of an environment variable that influences the behavior of the dynamic linker. It allows you to specify one or more libraries for the linker to load before any other library, including standard system libraries such as <em>libc.so</em>. If a preloaded library contains a function with the same name as a function in a library loaded later, the first function is the one that will be used at runtime. This allows you to <em>override</em> library functions (even standard library functions like <span class="literal">malloc</span> or <span class="literal">printf</span>) with your own versions of those functions. This is useful not only for binary modification but also for programs for which source code is available, because the ability to modify the behavior of a library function can save you the trouble of having to painstakingly modify all points in the source where that library function is used. Let’s look at an example of how <span class="literal">LD_PRELOAD</span> can be useful to modify a binary’s behavior.</p>&#13;
<h4 class="h4" id="ch07_2_1"><em>7.2.1 A Heap Overflow Vulnerability</em></h4>&#13;
<p class="noindent">The program I’ll be modifying in this example is <span class="literal">heapoverflow</span>, which contains a heap overflow vulnerability that you can fix using <span class="literal">LD_PRELOAD</span>. <a href="ch07.xhtml#ch07list6">Listing 7-6</a> shows the source for the program.</p>&#13;
<p class="listing1" id="ch07list6"><em>Listing 7-6:</em> heapoverflow.c</p>&#13;
<p class="programs">  #include &lt;stdio.h&gt;<br/>  #include &lt;stdlib.h&gt;<br/>  #include &lt;string.h&gt;<br/><br/>  int<br/>  main(int argc, char *argv[])<br/>  {<br/>    char *buf;<br/>    unsigned long len;<br/><br/>    if(argc != 3) {<br/>      printf("Usage: %s &lt;len&gt; &lt;string&gt;\n", argv[0]);<br/>      return 1;<br/>    }<br/><br/><span class="ent">➊</span>   len = strtoul(argv[1], NULL, 0);<br/>    printf("Allocating %lu bytes\n", len);<br/><br/><span class="ent">➋</span>   buf = malloc(len);<br/><br/>     if(buf &amp;&amp; len &gt; 0) {<br/>       memset(buf, 0, len);<br/><br/><span class="ent">➌</span>     strcpy(buf, argv[2]);<br/>       printf("%s\n", buf);<br/><br/><span class="ent">➍</span>     free(buf);<br/>    }<br/><br/>    return 0;<br/>  }</p>&#13;
<p class="indent"><a id="page_164"/>The <span class="literal">heapoverflow</span> program takes two command line arguments: a number and a string. It takes the given number, interpreting it as a buffer length <span class="ent">➊</span>, and then allocates a buffer of that size using <span class="literal">malloc</span> <span class="ent">➋</span>. Next, it uses <span class="literal">strcpy</span> <span class="ent">➌</span> to copy the given string into the buffer and then prints the buffer contents to the screen. Finally, it deallocates the buffer again using <span class="literal">free</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The overflow vulnerability is in the <span class="literal">strcpy</span> operation: since the length of the string is never checked, it may be too large to fit into the buffer. If that’s the case, the copy will result in a heap overflow, potentially corrupting other data on the heap and resulting in a crash or even exploitation of the program. But if the given string fits into the buffer, everything works fine, as you can see in <a href="ch07.xhtml#ch07list7">Listing 7-7</a>.</p>&#13;
<p class="listing1" id="ch07list7"><em>Listing 7-7: Behavior of the</em> <span class="codeitalic">heapoverflow</span> <em>program when given a benign input</em></p>&#13;
<p class="programs">$ <span class="codestrong1">./heapoverflow 13 'Hello world!'</span><br/>Allocating 13 bytes<br/>Hello world!</p>&#13;
<p class="indent">Here, I’ve told <span class="literal">heapoverflow</span> to allocate a 13-byte buffer and then copy the message “Hello world!” into it <span class="ent">➊</span>. The program allocates the requested buffer, copies the message into it, and prints it back to screen as expected, since the buffer is exactly large enough to hold the string, including its terminating <span class="literal">NULL</span> character. Let’s examine <a href="ch07.xhtml#ch07list8">Listing 7-8</a> to see what happens if you give a message that doesn’t fit into the buffer.</p>&#13;
<p class="listing1" id="ch07list8"><em>Listing 7-8: Crash of the</em> <span class="codeitalic">heapoverflow</span> <em>program when the input is too long</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">./heapoverflow 13 `perl -e 'print "A"x100'`</span><br/><span class="ent">➋</span> Allocating 13 bytes<br/><span class="ent">➌</span> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...<br/><span class="ent">➍</span> *** Error in `./heapoverflow': free(): invalid next size (fast): 0x0000000000a10420 ***<br/>  ======= Backtrace: =========<br/>  /lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f19129587e5]<br/>  /lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f191296137a]<br/>  /lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f191296553c]<span epub:type="pagebreak" id="page_165"/><br/>  ./heapoverflow[0x40063e]<br/>  /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f1912901830]<br/>  ./heapoverflow[0x400679]<br/>  ======= Memory map: ========<br/>  00400000-00401000 r-xp 00000000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow<br/>  00600000-00601000 r--p 00000000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow<br/>  00601000-00602000 rw-p 00001000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow<br/>  00a10000-00a31000 rw-p 00000000 00:00 0                 [heap]<br/>  7f190c000000-7f190c021000 rw-p 00000000 00:00 0<br/>  7f190c021000-7f1910000000 ---p 00000000 00:00 0<br/>  7f19126cb000-7f19126e1000 r-xp 00000000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>  7f19126e1000-7f19128e0000 ---p 00016000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>  7f19128e0000-7f19128e1000 rw-p 00015000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1<br/>  7f19128e1000-7f1912aa1000 r-xp 00000000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so<br/>  7f1912aa1000-7f1912ca1000 ---p 001c0000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so<br/>  7f1912ca1000-7f1912ca5000 r--p 001c0000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so<br/>  7f1912ca5000-7f1912ca7000 rw-p 001c4000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so<br/>  7f1912ca7000-7f1912cab000 rw-p 00000000 00:00 0<br/>  7f1912cab000-7f1912cd1000 r-xp 00000000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so<br/>  7f1912ea5000-7f1912ea8000 rw-p 00000000 00:00 0<br/>  7f1912ecd000-7f1912ed0000 rw-p 00000000 00:00 0<br/>  7f1912ed0000-7f1912ed1000 r--p 00025000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so<br/>  7f1912ed1000-7f1912ed2000 rw-p 00026000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so<br/>  7f1912ed2000-7f1912ed3000 rw-p 00000000 00:00 0<br/>  7ffe66fbb000-7ffe66fdc000 rw-p 00000000 00:00 0         [stack]<br/>  7ffe66ff3000-7ffe66ff5000 r--p 00000000 00:00 0         [vvar]<br/>  7ffe66ff5000-7ffe66ff7000 r-xp 00000000 00:00 0         [vdso]<br/>  ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]<br/><span class="ent">➎</span> Aborted (core dumped)</p>&#13;
<p class="indent">Again, I’ve told the program to allocate 13 bytes, but now the message is far too large to fit into the buffer: it’s a string consisting of 100 <em>A</em>s in a row <span class="ent">➊</span>. The program allocates the 13-byte buffer as earlier <span class="ent">➋</span> and then copies the message into it and prints it to screen <span class="ent">➌</span>. However, things go wrong when <span class="literal">free</span> is called <span class="ent">➍</span> to deallocate the buffer: the overflowing message has overwritten metadata on the heap that’s used by <span class="literal">malloc</span> and <span class="literal">free</span> to keep track of heap buffers. The corrupted heap metadata ultimately causes the program to crash <span class="ent">➎</span>. In the worst case, overflows like this can allow an attacker to take over the vulnerable program using a carefully crafted string for the overflow. Now let’s see how you can detect and prevent the overflow using <span class="literal">LD_PRELOAD</span>.</p>&#13;
<h4 class="h4" id="ch07_2_2"><em>7.2.2 Detecting the Heap Overflow</em></h4>&#13;
<p class="noindent">The key idea is to implement a shared library that overrides the <span class="literal">malloc</span> and <span class="literal">free</span> functions so that they internally keep track of the size of all allocated <span epub:type="pagebreak" id="page_166"/>buffers and also overrides <span class="literal">strcpy</span> so that it automatically checks whether the buffer is large enough for the string before copying anything. Note that for the sake of the example, this idea is oversimplified and should not be used in production settings. For example, it doesn’t take into account that buffer sizes can be changed using <span class="literal">realloc</span>, and it uses simple bookkeeping that can track only the last 1,024 allocated buffers. However, it should be enough to show how you can use <span class="literal">LD_PRELOAD</span> to solve real-world problems. <a href="ch07.xhtml#ch07list9">Listing 7-9</a> shows the code for the library (<em>heapcheck.c</em>) containing the alternative <span class="literal">malloc</span>/<span class="literal">free</span>/<span class="literal">strcpy</span> implementations.</p>&#13;
<p class="listing1" id="ch07list9"><em>Listing 7-9:</em> heapcheck.c</p>&#13;
<p class="programs">   #include  &lt;stdio.h&gt;<br/>   #include  &lt;stdlib.h&gt;<br/>   #include  &lt;string.h&gt;<br/>   #include  &lt;stdint.h&gt;<br/><span class="ent">➊</span> #include  &lt;dlfcn.h&gt;<br/><br/><span class="ent">➋</span> void* (*orig_malloc)(size_t);<br/>   void (*orig_free)(void*);<br/>   char* (*orig_strcpy)(char*, const char*);<br/><br/><span class="ent">➌</span> typedef struct {<br/>      uintptr_t addr;<br/>      size_t    size;<br/>    } alloc_t;<br/><br/>    #define MAX_ALLOCS 1024<br/><br/><span class="ent">➍</span> alloc_t allocs[MAX_ALLOCS];<br/>   unsigned alloc_idx = 0;<br/><br/><span class="ent">➎</span> void*<br/>   malloc(size_t s)<br/>   {<br/><span class="ent">➏</span>   if(!orig_malloc) orig_malloc = dlsym(RTLD_NEXT, "malloc");<br/><br/><span class="ent">➐</span>  void *ptr = orig_malloc(s);<br/>    if(ptr) {<br/>      allocs[alloc_idx].addr = (uintptr_t)ptr;<br/>      allocs[alloc_idx].size = s;<br/>      alloc_idx = (alloc_idx+1) % MAX_ALLOCS;<br/>    }<br/><br/>    return ptr;<br/>   }<br/><br/><span class="ent">➑</span> void<br/>   free(void *p)<br/>   {<br/>     if(!orig_free) orig_free = dlsym(RTLD_NEXT, "free");<br/><br/>     orig_free(p);<br/>     for(unsigned i = 0; i &lt; MAX_ALLOCS; i++) {<br/>       if(allocs[i].addr == (uintptr_t)p) {<br/>         allocs[i].addr = 0;<br/>         allocs[i].size = 0;<br/>         break;<br/>       }<br/>     }<br/>   }<br/><br/><span class="ent">➒</span> char*<br/>   strcpy(char *dst, const char *src)<br/>   {<br/>     if(!orig_strcpy) orig_strcpy = dlsym(RTLD_NEXT, "strcpy");<br/><br/>     for(unsigned i = 0; i &lt; MAX_ALLOCS; i++) {<br/>       if(allocs[i].addr == (uintptr_t)dst) {<br/><span class="ent">➓</span>       if(allocs[i].size &lt;= strlen(src)) {<br/>           printf("Bad idea! Aborting strcpy to prevent heap overflow\n");<br/>           exit(1);<br/>          }<br/>          break;<br/>        }<br/>      }<br/><br/>      return orig_strcpy(dst, src);<br/>   }</p>&#13;
<p class="indent"><a id="page_167"/>First, note the <em>dlfcn.h</em> header <span class="ent">➊</span>, which you’ll often include when writing libraries for use with <span class="literal">LD_PRELOAD</span> because it provides the <span class="literal">dlsym</span> function. You can use <span class="literal">dlsym</span> to get pointers to shared library functions. In this case, I’ll use it to get access to the original <span class="literal">malloc</span>, <span class="literal">free</span>, and <span class="literal">strcpy</span> functions to avoid having to reimplement them completely. There’s a set of global function pointers that keep track of these original functions as found by <span class="literal">dlsym</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">To keep track of the sizes of allocated buffers, I’ve defined a <span class="literal">struct</span> type called <span class="literal">alloc_t</span>, which can store the address and size of a buffer <span class="ent">➌</span>. I use a global circular array of these structures, called <span class="literal">allocs</span>, to keep track of the 1,024 most recent allocations <span class="ent">➍</span>.</p>&#13;
<p class="indent">Now, let’s take a look at the modified <span class="literal">malloc</span> function <span class="ent">➎</span>. The first thing it does is check whether the pointer to the original (<span class="literal">libc</span>) version of <span class="literal">malloc</span> <span epub:type="pagebreak" id="page_168"/>(which I call <span class="literal">orig_malloc</span>) is initialized yet. If not, it calls <span class="literal">dlsym</span> to look up this pointer <span class="ent">➏</span>.</p>&#13;
<p class="indent">Note that I use the <span class="literal">RTLD_NEXT</span> flag for <span class="literal">dlsym</span>, which causes <span class="literal">dlsym</span> to return a pointer to the next version of <span class="literal">malloc</span> in the chain of shared libraries. When you preload a library, it will be at the start of the chain. Thus, the<em> next</em> version of <span class="literal">malloc</span>, to which <span class="literal">dlsym</span> returns a pointer, will be the original <span class="literal">libc</span> version since <span class="literal">libc</span> is loaded later than your preloaded library.</p>&#13;
<p class="indent">Next, the modified <span class="literal">malloc</span> calls <span class="literal">orig_malloc</span> to do the actual allocation <span class="ent">➐</span> and then stores the address and size of the allocated buffer in the global <span class="literal">allocs</span> array. Now that this information is stored, <span class="literal">strcpy</span> can later check whether it’s safe to copy a string into a given buffer.</p>&#13;
<p class="indent">The new version of <span class="literal">free</span> is similar to the new <span class="literal">malloc</span>. It simply resolves and calls the original <span class="literal">free</span> (<span class="literal">orig_free</span>) and then invalidates the metadata for the freed buffer in the <span class="literal">allocs</span> array <span class="ent">➑</span>.</p>&#13;
<p class="indent">Finally, let’s look at the new <span class="literal">strcpy</span> <span class="ent">➒</span>. Again, it starts by resolving the original <span class="literal">strcpy</span> (<span class="literal">orig_strcpy</span>). However,<em> before</em> calling it, it checks whether the copy would be safe by searching the global <span class="literal">allocs</span> array for an entry that tells you the size of the destination buffer. If the metadata is found, <span class="literal">strcpy</span> checks whether the buffer would be large enough to accomodate the string <span class="ent">➓</span>. If so, it allows the copy. If not, it prints an error message and aborts the program to prevent an attacker from exploiting the vulnerability. Note that if no metadata is found because the destination buffer wasn’t one of the 1,024 most recent allocations, <span class="literal">strcpy</span> allows the copy. Practically, you would probably want to avoid this situation by using a more complex data structure for tracking the metadata, one that isn’t limited to 1,024 (or any hard limit) of allocations.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07list10">Listing 7-10</a> shows how to use the <em>heapcheck.so</em> library in practice.</p>&#13;
<p class="listing1" id="ch07list10"><em>Listing 7-10: Using the</em> heapcheck.so <em>library to prevent heap overflows</em></p>&#13;
<p class="programs">   $ <span class="ent">➊</span><span class="codestrong1">LD_PRELOAD=`pwd`/heapcheck.so ./heapoverflow 13 `perl -e 'print "A"x100'`</span><br/>   Allocating 13 bytes<br/><span class="ent">➋</span> Bad idea! Aborting strcpy to prevent heap overflow</p>&#13;
<p class="indent">Here, the important thing to note is the definition of the <span class="literal">LD_PRELOAD</span> environment variable <span class="ent">➊</span> when starting the <span class="literal">heapoverflow</span> program. This causes the linker to preload the specified library, <em>heapcheck.so</em>, which contains the modified <span class="literal">malloc</span>, <span class="literal">free</span>, and <span class="literal">strcpy</span> functions. Note that the paths given in <span class="literal">LD_PRELOAD</span> need to be absolute. If you use a relative path, the dynamic linker will fail to find the library, and the preload won’t happen.</p>&#13;
<p class="indent">The parameters to the <span class="literal">heapoverflow</span> program are the same as those in <a href="ch07.xhtml#ch07list8">Listing 7-8</a>: a 13-byte buffer and a 100-byte string. As you can see, now the heap overflow does not cause a crash. The modified <span class="literal">strcpy</span> successfully detects the unsafe copy, prints an error, and safely aborts the program <span class="ent">➋</span>, making the vulnerability impossible for an attacker to exploit.</p>&#13;
<p class="indent">If you look carefully at the Makefile for the <span class="literal">heapoverflow</span> program, you’ll note that I used <span class="literal">gcc</span>’s <span class="literal">-fno-builtin</span> flag to build the program. For essential functions like <span class="literal">malloc</span>, <span class="literal">gcc</span> sometimes uses built-in versions, which it statically <span epub:type="pagebreak" id="page_169"/>links into the compiled program. In this case, I used <span class="literal">-fno-builtin</span> to make sure that doesn’t happen because statically linked functions cannot be overridden using <span class="literal">LD_PRELOAD</span>.</p>&#13;
<h3 class="h3" id="ch07_3">7.3 Injecting a Code Section</h3>&#13;
<p class="noindent">The binary modification techniques you learned so far are pretty limited in their applicability. Hex editing is useful for small modifications, but you can’t add much (if any) new code or data. <span class="literal">LD_PRELOAD</span> allows you to easily add new code, but you can use it only to modify library calls. Before exploring more flexible binary modification techniques in <a href="ch09.xhtml#ch09">Chapter 9</a>, let’s explore how to inject a completely new code section into an ELF binary; this relatively simple trick is more flexible than those just discussed.</p>&#13;
<p class="indent">On the virtual machine, there’s a complete tool called <span class="literal">elfinject</span> that implements this code injection technique. Because the <span class="literal">elfinject</span> source code is pretty lengthy, I won’t go through it here, but I include an explanation of how <span class="literal">elfinject</span> is implemented in <a href="appb.xhtml">Appendix B</a> if you’re interested. The appendix also doubles as an introduction to <span class="literal">libelf</span>, a popular open source library for parsing ELF binaries. While you won’t need to know <span class="literal">libelf</span> to understand the rest of this book, it can be useful when implementing your own binary analysis tools, so I encourage you to read <a href="appb.xhtml">Appendix B</a>.</p>&#13;
<p class="indent">In this section, I’ll give you a high-level overview that explains the main steps involved in the code section injection technique. I’ll then show you how to use the <span class="literal">elfinject</span> tool provided on the virtual machine to inject a code section into an ELF binary.</p>&#13;
<h4 class="h4" id="ch07_3_1"><em>7.3.1 Injecting an ELF Section: A High-Level Overview</em></h4>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07fig2">Figure 7-2</a> shows the main steps needed to inject a new code section into an ELF. The left side of the figure shows an original (unmodified) ELF, while the right side shows the altered file with the new section added, called <span class="literal">.injected</span>.</p>&#13;
<p class="indent">To add a new section to an ELF binary, you first inject the bytes that the section will contain (step <span class="ent">➊</span> in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>) by appending them to the end of the binary. Next, you create a section header <span class="ent">➋</span> and a program header <span class="ent">➌</span> for the injected section.</p>&#13;
<p class="indent">As you may recall from <a href="ch02.xhtml#ch02">Chapter 2</a>, the program header table is usually located right after the executable header <span class="ent">➍</span>. Because of this, adding an extra program header would shift all of the sections and headers that come after it. To avoid the need for complex shifting, you can simply overwrite an existing one instead of adding a new program header, as shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>. This is what <span class="literal">elfinject</span> implements, and you can apply the same header-overwriting trick to avoid adding a new section header to the binary.<sup><a id="ch07fn_2a" href="footnote.xhtml#ch07fn_2">2</a></sup></p>&#13;
<div class="image"><a id="ch07fig2"/><img src="Images/f170-01.jpg" alt="image" width="695" height="544"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_170"/><em>Figure 7-2: Replacing</em> <span class="literal">.note.ABI-tag</span> <em>with an injected code section</em></p>&#13;
<h3 class="h3">Overwriting the PT_NOTE Segment</h3>&#13;
<p class="noindent">As you just saw, it’s easier to overwrite an existing section header and program header than to add completely new ones. But how do you know which headers you can safely overwrite without breaking the binary? One program header that you can always safely overwrite is the <span class="literal">PT_NOTE</span> header, which describes the <span class="literal">PT_NOTE</span> segment.</p>&#13;
<p class="indent">The <span class="literal">PT_NOTE</span> segment encompasses sections that contain auxiliary information about the binary. For example, it may tell you that it’s a GNU/Linux binary, what kernel version the binary expects, and so on. In the <span class="literal">/bin/ls</span> executable on the virtual machine in particular, the <span class="literal">PT_NOTE</span> segment contains this information in two sections called <span class="literal">.note.ABI-tag</span> and <span class="literal">.note.gnu.build-id</span>. If this information is missing, the loader simply assumes it’s a native binary, so it’s safe to overwrite the <span class="literal">PT_NOTE</span> header without fear of breaking the binary. This trick is commonly used by malicious parasites to infect binaries, but it also works for benign modifications.</p>&#13;
<p class="indent">Now, let’s consider the changes needed for step <span class="ent">➋</span> in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, where you overwrite one of the <span class="literal">.note.*</span> section headers to turn it into a header for your new code section (<span class="literal">.injected</span>). I’ll (arbitrarily) choose to overwrite the header for the <span class="literal">.note.ABI-tag</span> section. As you can see in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, I change the <span class="literal">sh_type</span> from <span class="literal">SHT_NOTE</span> to <span class="literal">SHT_PROGBITS</span> to denote that the header now describes a code section. Moreover, I change the <span class="literal">sh_addr</span>, <span class="literal">sh_offset</span>, and <span class="literal">sh_size</span> fields to describe the location and size of the new <span class="literal">.injected</span> section <span epub:type="pagebreak" id="page_171"/>instead of the now obsolete <span class="literal">.note.ABI-tag</span> section. Finally, I change the section alignment (<span class="literal">sh_addralign</span>) to 16 bytes to ensure that the code will be properly aligned when loaded into memory, and I add the <span class="literal">SHF_EXECINSTR</span> flag to the <span class="literal">sh_flags</span> field to mark the section as executable.</p>&#13;
<p class="indent">The changes for step <span class="ent">➌</span> are similar, except that here I change the <span class="literal">PT_NOTE</span> program header instead of a section header. Again, I change the header type by setting <span class="literal">p_type</span> to <span class="literal">PT_LOAD</span> to indicate that the header now describes a loadable segment instead of a <span class="literal">PT_NOTE</span> segment. This causes the loader to load the segment (which encompasses the new <span class="literal">.injected</span> section) into memory when the program starts. I also change the required address, offset, and size fields: <span class="literal">p_offset</span>, <span class="literal">p_vaddr</span> (and <span class="literal">p_paddr</span>, not shown), <span class="literal">p_filesz</span>, and <span class="literal">p_memsz</span>. I set <span class="literal">p_flags</span> to mark the segment as readable and executable, instead of just readable, and I fix the alignment (<span class="literal">p_align</span>).</p>&#13;
<p class="indent">Although it’s not shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, it’s nice to also update the string table to change the name of the old <span class="literal">.note.ABI-tag</span> section to something like <span class="literal">.injected</span> to reflect the fact that a new code section was added. I discuss this step in detail in <a href="appb.xhtml">Appendix B</a>.</p>&#13;
<h3 class="h3">Redirecting the ELF Entry Point</h3>&#13;
<p class="noindent">Step <span class="ent">➍</span> in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> is optional. In this step, I change the <span class="literal">e_entry</span> field in the ELF executable header to point to an address in the new <span class="literal">.injected</span> section, instead of the original entry point, which is usually somewhere in <span class="literal">.text</span>. You need to do this only if you want some code in the <span class="literal">.injected</span> section to run right at the start of the program. Otherwise, you can just leave the entry point as is, though in that case, the new injected code will never run unless you redirect some calls in the original <span class="literal">.text</span> section to injected code, use some of the injected code as constructors, or apply another method to reach the injected code. I’ll discuss more ways to call into the injected code in <a href="ch07.xhtml#ch07_4">Section 7.4</a>.</p>&#13;
<h4 class="h4" id="ch07_3_2"><em>7.3.2 Using elfinject to Inject an ELF Section</em></h4>&#13;
<p class="noindent">To make the <span class="literal">PT_NOTE</span> injection technique more concrete, let’s look at how to use the <span class="literal">elfinject</span> tool provided on the virtual machine. <a href="ch07.xhtml#ch07list11">Listing 7-11</a> shows how to use <span class="literal">elfinject</span> to inject a code section into a binary.</p>&#13;
<p class="listing1" id="ch07list11"><em>Listing 7-11:</em> <span class="codeitalic">elfinject</span> <em>usage</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">ls hello.bin</span><br/>   hello.bin<br/><span class="ent">➋</span> $ <span class="codestrong1">./elfinject</span><br/>   Usage: ./elfinject &lt;elf&gt; &lt;inject&gt; &lt;name&gt; &lt;addr&gt; &lt;entry&gt;<br/><br/>   Inject the file &lt;inject&gt; into the given &lt;elf&gt;, using<br/>   the given &lt;name&gt; and base &lt;addr&gt;. You can optionally specify<br/>   an offset to a new &lt;entry&gt; point (-1 if none)<br/><span class="ent">➌</span> $ <span class="codestrong1">cp /bin/ls .</span><br/><span class="ent">➍</span> $ <span class="codestrong1">./ls</span><br/><br/><span epub:type="pagebreak" id="page_172"/>&#13;
   elfinject elfinject.c hello.s     hello.bin   ls   Makefile<br/>   <span class="codestrong1">$ readelf --wide --headers ls</span><br/>   ...<br/><br/>   Section Headers:<br/>     [Nr] Name              Type            Address          Off    Size   ES  Flg Lk Inf Al<br/>     [ 0]                   NULL            0000000000000000 000000 000000 00       0   0  0<br/>     [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00    A  0   0  1<br/>     [ 2] <span class="ent">➎</span>.note.ABI-tag     NOTE           0000000000400254 000254 000020 00    A  0   0  4<br/>     [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00    A  0   0  4<br/>     [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 0000c0 00    A  5   0  8<br/>     [ 5] .dynsym           DYNSYM          0000000000400358 000358 000cd8 18    A  6   1  8<br/>     [ 6] .dynstr           STRTAB          0000000000401030 001030 0005dc 00    A  0   0  1<br/>     [ 7] .gnu.version      VERSYM          000000000040160c 00160c 000112 02    A  5   0  2<br/>     [ 8] .gnu.version_r    VERNEED         0000000000401720 001720 000070 00    A  6   1  8<br/>     [ 9] .rela.dyn         RELA            0000000000401790 001790 0000a8 18    A  5   0  8<br/>     [10] .rela.plt         RELA            0000000000401838 001838 000a80 18   AI  5  24  8<br/>     [11] .init             PROGBITS        00000000004022b8 0022b8 00001a 00   AX  0   0  4<br/>     [12] .plt              PROGBITS        00000000004022e0 0022e0 000710 10   AX  0   0 16<br/>     [13] .plt.got          PROGBITS        00000000004029f0 0029f0 000008 00   AX  0   0  8<br/>     [14] .text             PROGBITS        0000000000402a00 002a00 011259 00   AX  0   0 16<br/>     [15] .fini             PROGBITS        0000000000413c5c 013c5c 000009 00   AX  0   0  4<br/>     [16] .rodata           PROGBITS        0000000000413c80 013c80 006974 00    A  0   0 32<br/>     [17] .eh_frame_hdr     PROGBITS        000000000041a5f4 01a5f4 000804 00    A  0   0  4<br/>     [18] .eh_frame         PROGBITS        000000000041adf8 01adf8 002c6c 00    A  0   0  8<br/>     [19] .init_array       INIT_ARRAY      000000000061de00 01de00 000008 00   WA  0   0  8<br/>     [20] .fini_array       FINI_ARRAY      000000000061de08 01de08 000008 00   WA  0   0  8<br/>     [21] .jcr              PROGBITS        000000000061de10 01de10 000008 00   WA  0   0  8<br/>     [22] .dynamic          DYNAMIC         000000000061de18 01de18 0001e0 10   WA  6   0  8<br/>     [23] .got              PROGBITS        000000000061dff8 01dff8 000008 08   WA  0   0  8<br/>     [24] .got.plt          PROGBITS        000000000061e000 01e000 000398 08   WA  0   0  8<br/>     [25] .data             PROGBITS        000000000061e3a0 01e3a0 000260 00   WA  0   0 32<br/>     [26] .bss              NOBITS          000000000061e600 01e600 000d68 00   WA  0   0 32<br/>     [27] .gnu_debuglink    PROGBITS        0000000000000000 01e600 000034 00       0   0  1<br/>     [28] .shstrtab         STRTAB          0000000000000000 01e634 000102 00       0   0  1<br/>   Key to Flags:<br/>     W (write), A (alloc), X (execute), M (merge), S (strings), l (large)<br/>     I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)<br/>     O (extra OS processing required) o (OS specific), p (processor specific)<br/><br/>   Program Headers:<br/>     Type           Offset     VirtAddr             PhysAddr             FileSiz    MemSiz   Flg Align<br/>     PHDR           0x000040   0x0000000000400040   0x0000000000400040   0x0001f8   0x0001f8 R E 0x8<br/>     INTERP         0x000238   0x0000000000400238   0x0000000000400238   0x00001c   0x00001c R   0x1<br/>         [Requesting program   interpreter: /lib64/ld-linux-x86-64.so.2]<br/>     LOAD           0x000000   0x0000000000400000   0x0000000000400000   0x01da64   0x01da64 R E 0x200000<br/>     LOAD           0x01de00   0x000000000061de00   0x000000000061de00   0x000800   0x001568 RW  0x200000<br/><span epub:type="pagebreak" id="page_173"/>&#13;
     DYNAMIC        0x01de18   0x000000000061de18   0x000000000061de18   0x0001e0   0x0001e0 RW  0x8<br/><span class="ent">➏</span>   NOTE           0x000254   0x0000000000400254   0x0000000000400254   0x000044   0x000044  R   0x4<br/>     GNU_EH_FRAME   0x01a5f4   0x000000000041a5f4   0x000000000041a5f4   0x000804   0x000804  R   0x4<br/>     GNU_STACK      0x000000   0x0000000000000000   0x0000000000000000   0x000000   0x000000  RW  0x10<br/>     GNU_RELRO      0x01de00   0x000000000061de00   0x000000000061de00   0x000200   0x000200  R   0x1<br/><br/>   Section to Segment mapping:<br/>    Segment Sections...<br/>      00<br/>      01    .interp<br/>      02    .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version<br/>            .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata<br/>             .eh_frame_hdr .eh_frame<br/>      03    .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss<br/>      04    .dynamic<br/>      05    .note.ABI-tag .note.gnu.build-id<br/>      06    .eh_frame_hdr<br/>      07<br/>      08    .init_array .fini_array .jcr .dynamic .got<br/><span class="ent">➐</span>  <span class="codestrong1">$ ./elfinject ls hello.bin ".injected" 0x800000 0</span><br/>    <span class="codestrong1">$ readelf --wide --headers ls</span><br/>    ...<br/><br/>    Section Headers:<br/>      [Nr] Name              Type             Address          Off    Size   ES Flg Lk Inf Al<br/>      [ 0]                   NULL             0000000000000000 000000 000000 00      0   0   0<br/>      [ 1] .interp           PROGBITS         0000000000400238 000238 00001c 00   A  0   0   1<br/>      [ 2] .init             PROGBITS         00000000004022b8 0022b8 00001a 00  AX  0   0   4<br/>      [ 3] .note.gnu.build-id NOTE             0000000000400274 000274 000024 00   A  0   0   4<br/>      [ 4] .gnu.hash         GNU_HASH         0000000000400298 000298 0000c0 00   A  5   0   8<br/>      [ 5] .dynsym           DYNSYM           0000000000400358 000358 000cd8 18   A  6   1   8<br/>      [ 6] .dynstr           STRTAB           0000000000401030 001030 0005dc 00   A  0   0   1<br/>      [ 7] .gnu.version      VERSYM           000000000040160c 00160c 000112 02   A  5   0   2<br/>      [ 8] .gnu.version_r    VERNEED          0000000000401720 001720 000070 00   A  6   1   8<br/>      [ 9] .rela.dyn         RELA             0000000000401790 001790 0000a8 18   A  5   0   8<br/>      [10] .rela.plt         RELA             0000000000401838 001838 000a80 18  AI  5  24   8<br/>      [11] .plt              PROGBITS         00000000004022e0 0022e0 000710 10  AX  0   0   16<br/>      [12] .plt.got          PROGBITS         00000000004029f0 0029f0 000008 00  AX  0   0   8<br/>      [13] .text             PROGBITS         0000000000402a00 002a00 011259 00  AX  0   0   16<br/>      [14] .fini             PROGBITS         0000000000413c5c 013c5c 000009 00  AX  0   0   4<br/>      [15] .rodata           PROGBITS         0000000000413c80 013c80 006974 00   A  0   0   32<br/>      [16] .eh_frame_hdr     PROGBITS         000000000041a5f4 01a5f4 000804 00   A  0   0   4<br/>      [17] .eh_frame         PROGBITS         000000000041adf8 01adf8 002c6c 00   A  0   0   8<br/>      [18] .jcr              PROGBITS         000000000061de10 01de10 000008 00  WA  0   0   8<br/>      [19] .init_array       INIT_ARRAY       000000000061de00 01de00 000008 00  WA  0   0   8<br/>      [20] .fini_array       FINI_ARRAY       000000000061de08 01de08 000008 00  WA  0   0   8<br/>      [21] .got              PROGBITS         000000000061dff8 01dff8 000008 08  WA  0   0   8<br/><span epub:type="pagebreak" id="page_174"/>&#13;
      [22] .dynamic          DYNAMIC          000000000061de18 01de18 0001e0 10  WA  6   0   8<br/>      [23] .got.plt          PROGBITS         000000000061e000 01e000 000398 08  WA  0   0   8<br/>      [24] .data             PROGBITS         000000000061e3a0 01e3a0 000260 00  WA  0   0  32<br/>      [25] .gnu_debuglink    PROGBITS         0000000000000000 01e600 000034 00      0   0   1<br/>      [26] .bss              NOBITS           000000000061e600 01e600 000d68 00  WA  0   0  32<br/>      [27] <span class="ent">➑</span>.injected        PROGBITS         0000000000800e78 01f000 00003f 00  AX  0   0  16<br/>      [28] .shstrtab         STRTAB           0000000000000000 01e634 000102 00      0   0   1<br/>   Key to Flags:<br/>     W (write), A (alloc), X (execute), M (merge), S (strings), l (large)<br/>     I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)<br/>     O (extra OS processing required) o (OS specific), p (processor specific)<br/><br/>   Program Headers:<br/>   Type           Offset      VirtAddr           PhysAddr           FileSiz    MemSiz     Flg   Align<br/>   PHDR           0x000040    0x0000000000400040 0x0000000000400040 0x0001f8   0x0001f8   R E   0x8<br/>   INTERP         0x000238    0x0000000000400238 0x0000000000400238 0x00001c   0x00001c   R     0x1<br/>       [Requesting program    interpreter: /lib64/ld-linux-x86-64.so.2]<br/>   LOAD           0x000000    0x0000000000400000 0x0000000000400000 0x01da64   0x01da64   R E   0x200000<br/>   LOAD           0x01de00    0x000000000061de00 0x000000000061de00 0x000800   0x001568   RW    0x200000<br/>   DYNAMIC        0x01de18    0x000000000061de18 0x000000000061de18 0x0001e0   0x0001e0   RW    0x8<br/><span class="ent">➒</span> LOAD            0x01ee78   0x0000000000800e78 0x0000000000800e78 0x00003f   0x00003f   R E   0x1000<br/>   GNU_EH_FRAME   0x01a5f4    0x000000000041a5f4 0x000000000041a5f4 0x000804   0x000804   R     0x4<br/>   GNU_STACK      0x000000    0x0000000000000000 0x0000000000000000 0x000000   0x000000   RW    0x10<br/>   GNU_RELRO      0x01de00    0x000000000061de00 0x000000000061de00 0x000200   0x000200   R     0x1<br/><br/>   Section to Segment mapping:<br/>    Segment Sections...<br/>     00<br/>     01     .interp<br/>     02     .interp .init .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version<br/>            .gnu.version_r .rela.dyn .rela.plt .plt .plt.got .text .fini .rodata<br/>            .eh_frame_hdr .eh_frame<br/>     03     .jcr .init_array .fini_array .got .dynamic .got.plt .data .bss<br/>     04     .dynamic<br/>     05     .injected<br/>     06     .eh_frame_hdr<br/>     07<br/>     08     .jcr .init_array .fini_array .got .dynamic<br/><span class="ent">➓</span>  $ <span class="codestrong1">./ls</span><br/>   hello world!<br/>   elfinject elfinject.c hello.s hello.bin ls Makefile</p>&#13;
<p class="indent">In the code folder for this chapter on the virtual machine, you’ll see a file called <em>hello.bin</em> <span class="ent">➊</span>, which contains the new code you’ll inject in raw binary form (without any ELF headers). As you’ll see shortly, the code prints a <span class="literal">hello world!</span> message and then transfers control to the original entry point of the host binary, resuming normal execution of the binary. If you’re <span epub:type="pagebreak" id="page_175"/>interested, you can find the assembly instructions for the injected code in the file called <em>hello.s</em> or in <a href="ch07.xhtml#ch07_4">Section 7.4</a>.</p>&#13;
<p class="indent">Let’s now take a look at the <span class="literal">elfinject</span> usage <span class="ent">➋</span>. As you can see, <span class="literal">elfinject</span> expects five arguments: a path to a host binary, a path to an inject file, a name and an address for the injected section, and an offset to the entry point of the injected code (or −1 if it has no entry point). The inject file <em>hello.bin</em> is injected into the host binary, with the given name, address, and entry point.</p>&#13;
<p class="indent">I use a copy of <span class="literal">/bin/ls</span> as a host binary in this example <span class="ent">➌</span>. As you can see, <span class="literal">ls</span> behaves normally before the inject, printing a listing of the current directory <span class="ent">➍</span>. You can see with <span class="literal">readelf</span> that the binary contains a <span class="literal">.note.ABI-tag</span> section <span class="ent">➎</span> and a <span class="literal">PT_NOTE</span> segment <span class="ent">➏</span>, which the inject will overwrite.</p>&#13;
<p class="indent">Now, it’s time to inject some code. In the example, I use <span class="literal">elfinject</span> to inject the <em>hello.bin</em> file into the <span class="literal">ls</span> binary, using the name <span class="literal">.injected</span> and load address <span class="literal">0x800000</span> for the injected section (which <span class="literal">elfinject</span> appends to the end of the binary) <span class="ent">➐</span>. I use <span class="literal">0</span> as the entry point because the entry point of <em>hello.bin</em> is right at its start.</p>&#13;
<p class="indent">After <span class="literal">elfinject</span> completes successfully, <span class="literal">readelf</span> shows that the <span class="literal">ls</span> binary now contains a code section called <span class="literal">.injected</span> <span class="ent">➑</span> and a new executable segment of type <span class="literal">PT_LOAD</span> <span class="ent">➒</span> that contains this section. Also, the <span class="literal">.note.ABI-tag</span> section and <span class="literal">PT_NOTE</span> segment are gone because they have been overwritten. Looks like the inject succeeded!</p>&#13;
<p class="indent">Now, let’s check whether the injected code behaves as expected. Executing the modified <span class="literal">ls</span> binary <span class="ent">➓</span>, you can see that the binary now runs the injected code at startup, printing the <span class="literal">hello world!</span> message. The injected code then passes execution to the binary’s original entry point so that it resumes its normal behavior of printing a directory listing.</p>&#13;
<h3 class="h3" id="ch07_4">7.4 Calling Injected Code</h3>&#13;
<p class="noindent">In the previous section, you learned how to use <span class="literal">elfinject</span> to inject a new code section into an existing binary. To get the new code to execute, you modified the ELF entry point, causing the new code to run as soon as the loader transfers control to the binary. But you may not always want to use the injected code immediately when the binary starts. Sometimes, you’ll want to use the injected code for different reasons, such as substituting a replacement for an existing function.</p>&#13;
<p class="indent">In this section, I’ll discuss alternative techniques for transferring control to the injected code, other than modifying the ELF entry point. I’ll also recap the ELF entry point modification technique, this time using only a hex editor to change the entry point. This will let you redirect the entry point not only to code injected with <span class="literal">elfinject</span> but also to code that’s been inserted in other ways, for instance, by overwriting dead code like padding instructions. Note that all of the techniques discussed in this section are suitable for use with any code injection method, not just <span class="literal">PT_NOTE</span> overwriting.</p>&#13;
<h4 class="h4" id="ch07_4_1"><span epub:type="pagebreak" id="page_176"/><em>7.4.1 Entry Point Modification</em></h4>&#13;
<p class="noindent">First, let’s briefly recap the ELF entry point modification technique. In the following example, I’ll transfer control to a code section injected using <span class="literal">elfinject</span>, but instead of using <span class="literal">elfinject</span> to update the entry point itself, I’ll use a hex editor. This will show you how to generalize the technique to code injected in various ways.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07list12">Listing 7-12</a> shows the assembly instructions for the code I’ll inject. It’s the “hello world” example used in the previous section.</p>&#13;
<p class="listing1" id="ch07list12"><em>Listing 7-12:</em> hello.s</p>&#13;
<p class="programs"><span class="ent">➊</span> BITS 64<br/><br/>  SECTION .text<br/>  global main<br/><br/>  main:<br/><span class="ent">➋</span>   push   rax                 ; save all clobbered registers<br/>     push   rcx                ; (rcx and r11 destroyed by kernel)<br/>     push   rdx<br/>     push   rsi<br/>     push   rdi<br/>     push   r11<br/><br/><span class="ent">➌</span>    mov rax,1                 ;   sys_write<br/>     mov rdi,1                 ;   stdout<br/>     lea rsi,[rel $+hello-$]   ;   hello<br/>     mov rdx,[rel $+len-$]     ;   len<br/><span class="ent">➍</span>   syscall<br/><br/><span class="ent">➎</span>   pop   r11<br/>     pop   rdi<br/>     pop   rsi<br/>     pop   rdx<br/>     pop   rcx<br/>     pop   rax<br/><br/><span class="ent">➏</span>    push 0x4049a0             ; jump to original entry point<br/>     ret<br/><br/><span class="ent">➐</span> hello: db "hello world",33,10<br/><span class="ent">➑</span> len  : dd 13</p>&#13;
<p class="indent">The code is in Intel syntax, intended to be assembled with the <span class="literal">nasm</span> assembler in 64-bit mode <span class="ent">➊</span>. The first few assembly instructions save the <span class="literal">rax</span>, <span class="literal">rcx</span>, <span class="literal">rdx</span>, <span class="literal">rsi</span>, and <span class="literal">rdi</span> registers by pushing them onto the stack <span class="ent">➋</span>. These registers may be clobbered by the kernel, and you’ll want to restore them to <span epub:type="pagebreak" id="page_177"/>their original values after the injected code completes to avoid interfering with other code.</p>&#13;
<p class="indent">The next instructions set up the arguments for a <span class="literal">sys_write</span> system call <span class="ent">➌</span>, which will print <span class="literal">hello world!</span> to the screen. (You’ll find more information on all standard Linux system call numbers and arguments in the <span class="literal">syscall man</span> page.) For <span class="literal">sys_write</span>, the syscall number (which is placed in <span class="literal">rax</span>) is 1, and there are three arguments: the file descriptor to write to (1 for <span class="literal">stdout</span>), a pointer to the string to print, and the length of the string. Now that all the arguments are prepared, the <span class="literal">syscall</span> instruction <span class="ent">➍</span> invokes the actual system call, printing the string.</p>&#13;
<p class="indent">After invoking the <span class="literal">sys_write</span> system call, the code restores the registers to their previously saved state <span class="ent">➎</span>. It then pushes the address <span class="literal">0x4049a0</span> of the original entry point (which I found using <span class="literal">readelf</span>, as you’ll see shortly) and returns to that address, starting execution of the original program <span class="ent">➏</span>.</p>&#13;
<p class="indent">The “hello world” string <span class="ent">➐</span> is declared after the assembly instructions, along with an integer containing the length of the string <span class="ent">➑</span>, both of which are used for the <span class="literal">sys_write</span> system call.</p>&#13;
<p class="indent">To make the code suitable for injection, you need to assemble it into a raw binary file that contains nothing more than the binary encodings of the assembly instructions and data. This because you don’t want to create a full-fledged ELF binary that contains headers and other overhead not needed for the inject. To assemble <em>hello.s</em> into a raw binary file, you can use the <span class="literal">nasm</span> assembler’s <span class="literal">-f bin</span> option, as shown in <a href="ch07.xhtml#ch07list13">Listing 7-13</a>. The <em>Makefile</em> for this chapter comes with a <em>hello.bin</em> target that automatically runs this command.</p>&#13;
<p class="listing1" id="ch07list13"><em>Listing 7-13: Assembling</em> hello.s <em>into</em> hello.bin <em>using</em> <span class="codeitalic">nasm</span></p>&#13;
<p class="programs">$ <span class="codestrong1">nasm -f bin -o hello.bin hello.s</span></p>&#13;
<p class="indent">This creates the file <em>hello.bin</em>, which contains the raw binary instructions and data suitable for injection. Now let’s use <span class="literal">elfinject</span> to inject this file and redirect the ELF entry point using a hex editor so that the injected code runs on startup of the binary. <a href="ch07.xhtml#ch07list14">Listing 7-14</a> shows how to do this.</p>&#13;
<p class="listing1" id="ch07list14"><em>Listing 7-14: Calling injected code by overwriting the ELF entry point</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">cp /bin/ls ls.entry</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./elfinject ls.entry hello.bin ".injected" 0x800000 -1</span><br/>   $ <span class="codestrong1">readelf -h ./ls.entry</span><br/>   ELF Header:<br/>     Magic:    7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/>     Class:                              ELF64<br/>     Data:                               2's complement, little endian<br/>     Version:                            1 (current)<br/>     OS/ABI:                             UNIX - System V<br/>     ABI Version:                        0<br/>     Type:                               EXEC (Executable file)<br/>     Machine:                            Advanced Micro Devices X86-64<br/>     Version:                            0x1<br/>     Entry point address:                <span class="ent">➌</span>0x4049a0<br/>     Start of program headers:           64 (bytes into file)<br/>     Start of section headers:           124728 (bytes into file)<br/>     Flags:                              0x0<br/>     Size of this header:                64 (bytes)<br/>     Size of program headers:            56 (bytes)<br/>     Number of program headers:          9<br/>     Size of section headers:            64 (bytes)<br/>     Number of section headers:          29<br/>     Section header string table index:  28<br/>   $ <span class="codestrong1">readelf --wide -S code/chapter7/ls.entry</span><br/>   There are 29 section headers, starting at offset 0x1e738:<br/><br/>   Section Headers:<br/>     [Nr] Name               Type            Address          Off   Size ES Flg Lk Inf Al<br/>     ...<br/>     [27] .injected          PROGBITS        <span class="ent">➍</span>0000000000800e78 01ee78 00003f 00 AX 0 0 16<br/>     ...<br/><span class="ent">➎</span> $ <span class="codestrong1">./ls.entry</span><br/>   elfinject elfinject.c hello.s hello.bin ls Makefile<br/><span class="ent">➏</span> $ <span class="codestrong1">hexedit ./ls.entry</span><br/>   $ <span class="codestrong1">readelf -h ./ls.entry</span><br/>   ELF Header:<br/>     Magic:    7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/>     Class:                              ELF64<br/>     Data:                               2's complement, little endian<br/>     Version:                            1 (current)<br/>     OS/ABI:                             UNIX - System V<br/>     ABI Version:                        0<br/>     Type:                               EXEC (Executable file)<br/>     Machine:                            Advanced Micro Devices X86-64<br/>     Version:                            0x1<br/>     Entry point address:                <span class="ent">➐</span>0x800e78<br/>     Start of program headers:           64 (bytes into file)<br/>     Start of section headers:           124728 (bytes into file)<br/>     Flags:                              0x0<br/>     Size of this header:                64 (bytes)<br/>     Size of program headers:            56 (bytes)<br/>     Number of program headers:          9<br/>     Size of section headers:            64 (bytes)<br/>     Number of section headers:          29<br/>     Section header string table index:  28<br/><span class="ent">➑</span> $ <span class="codestrong1">./ls.entry</span><br/>   hello world!<br/>   elfinject elfinject.c hello.s hello.bin ls Makefile</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/><span epub:type="pagebreak" id="page_179"/>First, copy the <span class="literal">/bin/ls</span> binary into <span class="literal">ls.entry</span> <span class="ent">➊</span>. This will serve as a host binary for the inject. Then you can use <span class="literal">elfinject</span> to inject the just-prepared code into the binary with load address <span class="literal">0x800000</span> <span class="ent">➋</span>, exactly as discussed in <a href="ch07.xhtml#ch07_3_2">Section 7.3.2</a>, with one crucial difference: set the last <span class="literal">elfinject</span> argument to −1 so that <span class="literal">elfinject</span> leaves the entry point unmodified (because you’ll overwrite it manually).</p>&#13;
<p class="indent">With <span class="literal">readelf</span>, you can see the original entry point of the binary: <span class="literal">0x4049a0</span> <span class="ent">➌</span>. Note that this is the address that the injected code jumps to when it’s done printing the <span class="literal">hello world</span> message, as shown in <a href="ch07.xhtml#ch07list12">Listing 7-12</a>. You can also see with <span class="literal">readelf</span> that the injected section actually starts at the address <span class="literal">0x800e78</span> <span class="ent">➍</span> instead of the address <span class="literal">0x800000</span>. This is because <span class="literal">elfinject</span> slightly changed the address to meet the alignment requirements of the ELF format, as I discuss in more detail in <a href="appb.xhtml">Appendix B</a>. What’s important here is that <span class="literal">0x800e78</span> is the new address you’ll want to use to overwrite the entry point address with.</p>&#13;
<p class="indent">Because the entry point is still unmodified, if you run <span class="literal">ls.entry</span> now, it simply behaves like the normal <span class="literal">ls</span> command without the added “hello world” message at the start <span class="ent">➎</span>. To modify the entry point, you open up the <span class="literal">ls.entry</span> binary in <span class="literal">hexedit</span> <span class="ent">➏</span> and search for the original entry point address. Recall that you can open the search dialog in <span class="literal">hexedit</span> using the / key and then enter the address to search for. The address is stored in little-endian format, so you’ll need to search for the bytes <span class="literal">a04940</span> instead of <span class="literal">4049a0</span>. After you’ve found the entry point, overwrite it with the new one, again with the byte order reversed: <span class="literal">780e80</span>. Now, press CTRL-X to exit and press Y to save your changes.</p>&#13;
<p class="indent">You can now see with <span class="literal">readelf</span> that the entry point is updated to <span class="literal">0x800e78</span> <span class="ent">➐</span>, pointing to the start of the injected code. Now when you run <span class="literal">ls.entry</span>, it prints <span class="literal">hello world</span> before showing the directory listing <span class="ent">➑</span>. You’ve successfully overwritten the entry point!</p>&#13;
<h4 class="h4" id="ch07_4_2"><em>7.4.2 Hijacking Constructors and Destructors</em></h4>&#13;
<p class="noindent">Now let’s take a look at another way to ensure your injected code gets called once during the lifetime of the binary, either at the start or end of execution. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that x86 ELF binaries compiled with <span class="literal">gcc</span> contain sections called <span class="literal">.init_array</span> and <span class="literal">.fini_array</span>, which contain pointers to a series of constructors and destructors, respectively. By overwriting one of these pointers, you can cause the injected code to be invoked before or after the binary’s <span class="literal">main</span> function, depending on whether you overwrite a constructor or a destructor pointer.</p>&#13;
<p class="indent">Of course, after the injected code completes, you’ll want to transfer control back to the constructor or destructor that you hijacked. This requires some small changes to the injected code, as shown in <a href="ch07.xhtml#ch07list15">Listing 7-15</a>. In this listing, I assume you’ll pass control back to a specific constructor whose address you’ll find using <span class="literal">objdump</span>.</p>&#13;
<p class="listing1" id="ch07list15"><span epub:type="pagebreak" id="page_180"/><em>Listing 7-15:</em> hello-ctor.s</p>&#13;
<p class="programs">   BITS 64<br/><br/>   SECTION .text<br/>   global main<br/><br/>   main:<br/>     push   rax                 ; save all clobbered registers<br/>     push   rcx                 ; (rcx and r11 destroyed by kernel)<br/>     push   rdx<br/>     push   rsi<br/>     push   rdi<br/>     push   r11<br/><br/>     mov rax,1                  ; sys_write<br/>     mov rdi,1                  ; stdout<br/>     lea rsi,[rel $+hello-$]    ; hello<br/>     mov rdx,[rel $+len-$]      ; len<br/>     syscall<br/><br/>     pop   r11<br/>     pop   rdi<br/>     pop   rsi<br/>     pop   rdx<br/>     pop   rcx<br/>     pop   rax<br/><br/><span class="ent">➊</span>  push 0x404a70               ; jump to original constructor<br/>    ret<br/><br/>   hello: db "hello world",33,10<br/>   len : dd 13</p>&#13;
<p class="indent">The code shown in <a href="ch07.xhtml#ch07list15">Listing 7-15</a> is the same as the code in <a href="ch07.xhtml#ch07list12">Listing 7-12</a>, except that I’ve inserted the address of the hijacked constructor to return to <span class="ent">➊</span> instead of the entry point address. The command to assemble the code into a raw binary file is the same as discussed in the previous section. <a href="ch07.xhtml#ch07list16">Listing 7-16</a> shows how to inject the code into a binary and hijack a constructor.</p>&#13;
<p class="listing1" id="ch07list16"><em>Listing 7-16: Calling injected code by hijacking a constructor</em></p>&#13;
<p class="programs"><span class="ent">➊</span>   $ <span class="codestrong1">cp /bin/ls ls.ctor</span><br/><span class="ent">➋</span>   $ <span class="codestrong1">./elfinject ls.ctor hello-ctor.bin ".injected" 0x800000 -1</span><br/>    $ <span class="codestrong1">readelf --wide -S ls.ctor</span><br/>    There are 29 section headers, starting at offset 0x1e738:<br/><span epub:type="pagebreak" id="page_181"/>&#13;
    Section Headers:<br/>    [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al<br/>    [ 0]                   NULL            0000000000000000 000000 000000 00     0   0   0<br/>    [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A 0   0   1<br/>    [ 2] .init             PROGBITS        00000000004022b8 0022b8 00001a 00  AX 0   0   4<br/>    [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00   A 0   0   4<br/>    [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 0000c0 00   A 5   0   8<br/>    [ 5] .dynsym           DYNSYM          0000000000400358 000358 000cd8 18   A 6   1   8<br/>    [ 6] .dynstr           STRTAB          0000000000401030 001030 0005dc 00   A 0   0   1<br/>    [ 7] .gnu.version      VERSYM          000000000040160c 00160c 000112 02   A 5   0   2<br/>    [ 8] .gnu.version_r    VERNEED         0000000000401720 001720 000070 00   A 6   1   8<br/>    [ 9] .rela.dyn         RELA            0000000000401790 001790 0000a8 18   A 5   0   8<br/>    [10] .rela.plt         RELA            0000000000401838 001838 000a80 18  AI 5  24   8<br/>    [11] .plt              PROGBITS        00000000004022e0 0022e0 000710 10  AX 0   0   16<br/>    [12] .plt.got          PROGBITS        00000000004029f0 0029f0 000008 00  AX 0   0   8<br/>    [13] .text             PROGBITS        0000000000402a00 002a00 011259 00  AX 0   0   16<br/>    [14] .fini             PROGBITS        0000000000413c5c 013c5c 000009 00  AX 0   0   4<br/>    [15] .rodata           PROGBITS        0000000000413c80 013c80 006974 00   A 0   0   32<br/>    [16] .eh_frame_hdr     PROGBITS        000000000041a5f4 01a5f4 000804 00   A 0   0   4<br/>    [17] .eh_frame         PROGBITS        000000000041adf8 01adf8 002c6c 00   A 0   0   8<br/>    [18] .jcr              PROGBITS        000000000061de10 01de10 000008 00  WA 0   0   8<br/><span class="ent">➌</span>   [19] .init_array       INIT_ARRAY      000000000061de00 01de00 000008 00  WA 0   0   8<br/>    [20] .fini_array       FINI_ARRAY      000000000061de08 01de08 000008 00  WA 0   0   8<br/>    [21] .got              PROGBITS        000000000061dff8 01dff8 000008 08  WA 0   0   8<br/>    [22] .dynamic          DYNAMIC         000000000061de18 01de18 0001e0 10  WA 6   0   8<br/>    [23] .got.plt          PROGBITS        000000000061e000 01e000 000398 08  WA 0   0   8<br/>    [24] .data             PROGBITS        000000000061e3a0 01e3a0 000260 00  WA 0   0   32<br/>    [25] .gnu_debuglink    PROGBITS        0000000000000000 01e600 000034 00     0   0   1<br/>    [26] .bss              NOBITS          000000000061e600 01e600 000d68 00  WA 0   0   32<br/>    [27] .injected         PROGBITS        0000000000800e78 01ee78 00003f 00  AX 0   0   16<br/>    [28] .shstrtab         STRTAB          0000000000000000 01e634 000102 00     0   0   1<br/>  Key to Flags:<br/>    W (write), A (alloc), X (execute), M (merge), S (strings), l (large)<br/>    I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)<br/>    O (extra OS processing required) o (OS specific), p (processor specific)<br/>  $ <span class="codestrong1">objdump ls.ctor -s --section=.init_array</span><br/><br/><br/>  ls:     file format elf64-x86-64<br/><br/><br/><span epub:type="pagebreak" id="page_182"/>&#13;
  Contents of section .init_array:<br/>   61de00 <span class="ent">➍</span>704a4000 00000000                      pJ@.....<br/><span class="ent">➎</span> $ <span class="codestrong1">hexedit ls.ctor</span><br/>  $ <span class="codestrong1">objdump ls.ctor -s --section=.init_array</span><br/><br/>  ls.ctor:     file format elf64-x86-64<br/>  Contents of section .init_array:<br/>    61de00 <span class="ent">➏</span>780e8000 00000000                                 x.......<br/><span class="ent">➐</span> $ <span class="codestrong1">./ls.ctor</span><br/>  hello world!<br/>  elfinject elfinject.c hello.s hello.bin   ls Makefile</p>&#13;
<p class="indent">As before, you begin by copying <span class="literal">/bin/ls</span> <span class="ent">➊</span> and injecting the new code into the copy <span class="ent">➋</span>, without changing the entry point. Using <span class="literal">readelf</span>, you can see that the <span class="literal">.init_array</span> section exists <span class="ent">➌</span>.<sup><a id="ch07fn_3a" href="footnote.xhtml#ch07fn_3">3</a></sup> The <span class="literal">.fini_array</span> section is also there, but in this case I’m hijacking a constructor, not a destructor.</p>&#13;
<p class="indent">You can view the contents of <span class="literal">.init_array</span> using <span class="literal">objdump</span>, which reveals a single constructor function pointer with the value <span class="literal">0x404a70</span> (stored in little-endian format) <span class="ent">➍</span>. Now, you can use <span class="literal">hexedit</span> to search for this address and change it <span class="ent">➎</span> to the entry address <span class="literal">0x800e78</span> of your injected code.</p>&#13;
<p class="indent">After you do this, the single pointer in <span class="literal">.init_array</span> points to the injected code instead of the original constructor <span class="ent">➏</span>. Keep in mind that when this is done, the injected code transfers control back to the original constructor. After overwriting the constructor pointer, the updated <span class="literal">ls</span> binary starts by showing the “hello world” message and then prints a directory listing as normal <span class="ent">➐</span>. Using this technique, you can get code to run once at the start or termination of a binary without having to modify its entry point.</p>&#13;
<h4 class="h4" id="ch07_4_3"><em>7.4.3 Hijacking GOT Entries</em></h4>&#13;
<p class="noindent">Both of the techniques discussed so far—entry point modification and constructor/destructor hijacking—allow the injected code to run only once at startup or at termination of the binary. What if you want to invoke the injected function repeatedly, for instance, to replace an existing library function? I’ll now show you how to hijack a GOT entry to replace a library call with an injected function. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that the Global Offset Table (GOT) is a table containing pointers to shared library functions, used for dynamic linking. Overwriting one or more of these entries essentially gives you the same level of control as the <span class="literal">LD_PRELOAD</span> technique but without the need for an external library containing the new function, allowing you to keep the binary self-contained. Moreover, GOT hijacking is a suitable technique not only for persistent binary modification but also for exploiting a binary at runtime.</p>&#13;
<p class="indent">The GOT hijacking technique requires a slight modification to the injected code, as shown in <a href="ch07.xhtml#ch07list17">Listing 7-17</a>.</p>&#13;
<p class="listing1" id="ch07list17"><span epub:type="pagebreak" id="page_183"/><em>Listing 7-17:</em> hello-got.s</p>&#13;
<p class="programs">   BITS 64<br/><br/>   SECTION .text<br/>   global main<br/><br/>   main:<br/>     push   rax                ; save all clobbered registers<br/>     push   rcx                ; (rcx and r11 destroyed by kernel)<br/>     push   rdx<br/>     push   rsi<br/>     push   rdi<br/>     push   r11<br/><br/>     mov rax,1                 ; sys_write<br/>     mov rdi,1                 ; stdout<br/>     lea rsi,[rel $+hello-$]   ; hello<br/>     mov rdx,[rel $+len-$]     ; len<br/>     syscall<br/><br/>     pop   r11<br/>     pop   rdi<br/>     pop   rsi<br/>     pop   rdx<br/>     pop   rcx<br/>     pop   rax<br/><br/><span class="ent">➊</span>   ret                       ; return<br/><br/>   hello: db "hello world",33,10<br/>   len : dd 13</p>&#13;
<p class="indent">With GOT hijacking, you’re completely replacing a library function, so there’s no need to transfer control back to the original implementation when the injected code completes. Thus, <a href="ch07.xhtml#ch07list17">Listing 7-17</a> doesn’t contain any hard-coded address to which it transfers control at the end. Instead, it simply ends with a normal return <span class="ent">➊</span>.</p>&#13;
<p class="indent">Let’s take a look at how to implement the GOT hijacking technique in practice. <a href="ch07.xhtml#ch07list18">Listing 7-18</a> shows an example that replaces the GOT entry for the <span class="literal">fwrite_unlocked</span> library function in the <span class="literal">ls</span> binary with a pointer to the “hello world” function, as shown in <a href="ch07.xhtml#ch07list17">Listing 7-17</a>. The <span class="literal">fwrite_unlocked</span> function is the function that <span class="literal">ls</span> uses to print all of its messages to screen.</p>&#13;
<p class="listing1" id="ch07list18"><span epub:type="pagebreak" id="page_184"/><em>Listing 7-18: Calling injected code by hijacking a GOT entry</em></p>&#13;
<p class="programs"><span class="ent">➊</span>  $ <span class="codestrong1">cp /bin/ls ls.got</span><br/><span class="ent">➋</span>  $ <span class="codestrong1">./elfinject ls.got hello-got.bin ".injected" 0x800000 -1</span><br/>   $ <span class="codestrong1">objdump -M intel -d ls.got</span><br/>   ...<br/><span class="ent">➌</span>  0000000000402800 &lt;fwrite_unlocked@plt&gt;:<br/>    402800: ff 25 9a ba 21 00 jmp     QWORD PTR [rip+0x21ba9a] # <span class="ent">➍</span>61e2a0 &lt;_fini@@Base+0x20a644&gt;<br/>    402806: 68 51 00 00 00      push 0x51<br/>    40280b: e9 d0 fa ff ff      jmp   4022e0 &lt;_init@@Base+0x28&gt;<br/>   ...<br/>   <span class="codestrong1">$ objdump ls.got -s --section=.got.plt</span><br/><br/>   ls.got:           file format elf64-x86-64<br/><br/>   Contents of section .got.plt:<br/>   ...<br/>    61e290 e6274000 00000000 f6274000 00000000 .'@......'@.....<br/>    61e2a0 <span class="ent">➎</span>06284000 00000000 16284000 00000000 .(@......(@.....<br/>    61e2b0 26284000 00000000 36284000 00000000 &amp;(@.....6(@.....<br/>   ...<br/><span class="ent">➏</span>  $ <span class="codestrong1">hexedit ls.got</span><br/>   <span class="codestrong1">$ objdump ls.got -s --section=.got.plt</span><br/><br/>   ls.got:           file format elf64-x86-64<br/><br/>   Contents of section .got.plt:<br/>   ...<br/>   61e290 e6274000 00000000 f6274000 00000000 .'@......'@.....<br/>   61e2a0 <span class="ent">➐</span>780e8000 00000000 16284000 00000000 x........(@.....<br/>   61e2b0 26284000 00000000 36284000 00000000 &amp;(@.....6(@.....<br/>   ...<br/><span class="ent">➑</span> $ <span class="codestrong1">./ls.got</span><br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   ...</p>&#13;
<p class="indent">After creating a fresh copy of <span class="literal">ls</span> <span class="ent">➊</span> and injecting your code into it <span class="ent">➋</span>, you can use <span class="literal">objdump</span> to view the binary’s PLT entries (where the GOT entries are used) and find the one for <span class="literal">fwrite_unlocked</span> <span class="ent">➌</span>. It starts at address <span class="literal">0x402800</span>, and the GOT entry it uses is located at address <span class="literal">0x61e2a0</span> <span class="ent">➍</span>, which is in the <span class="literal">.got.plt</span> section.</p>&#13;
<p class="indent">Using <span class="literal">objdump</span> to view the <span class="literal">.got.plt</span> section, you can see the original address stored in the GOT entry <span class="ent">➎</span>: <span class="literal">402806</span> (encoded in little-endian format).</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_185"/>As explained in <a href="ch02.xhtml#ch02">Chapter 2</a>, this is the address of the next instruction in <span class="literal">fwrite_unlocked</span>’s PLT entry, which you want to overwrite with the address of your injected code. Thus, the next step is to start <span class="literal">hexedit</span>, search for the string <span class="literal">062840</span>, and replace it with the address <span class="literal">0x800e78</span> of your injected code <span class="ent">➏</span>, as usual. You confirm the changes by using <span class="literal">objdump</span> again to view the modified GOT entry <span class="ent">➐</span>.</p>&#13;
<p class="indent">After changing the GOT entry to point to your “hello world” function, the <span class="literal">ls</span> program now prints <span class="literal">hello world</span> every time it invokes <span class="literal">fwrite_unlocked</span> <span class="ent">➑</span>, replacing all of the usual <span class="literal">ls</span> output with copies of the <span class="literal">"hello world"</span> string. Of course, in real life, you’d want to replace <span class="literal">fwrite_unlocked</span> with a more useful function.</p>&#13;
<p class="indent">A benefit of GOT hijacking is that it’s not only straightforward but can also be easily done at runtime. This is because, unlike code sections, <span class="literal">.got.plt</span> is writable at runtime. As a result, GOT hijacking is a popular technique not only for static binary modifications, as I’ve demonstrated here, but also for exploits that aim to change the behavior of a running process.</p>&#13;
<h4 class="h4" id="ch07_4_4"><em>7.4.4 Hijacking PLT Entries</em></h4>&#13;
<p class="noindent">The next technique for calling injected code, PLT hijacking, is similar to GOT hijacking. Like GOT hijacking, PLT hijacking allows you to insert a replacement for an existing library function. The only difference is that instead of changing the function address stored in a GOT entry used by a PLT stub, you change the PLT stub itself. Because this technique involves changing the PLT, which is a code section, it’s not suitable for modifying a binary’s behavior at runtime. <a href="ch07.xhtml#ch07list19">Listing 7-19</a> shows how to use the PLT hijacking technique.</p>&#13;
<p class="listing1" id="ch07list19"><em>Listing 7-19: Calling injected code by hijacking a PLT entry</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">cp /bin/ls ls.plt</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./elfinject ls.plt hello-got.bin ".injected" 0x800000 -1</span><br/>   $ <span class="codestrong1">objdump -M intel -d ls.plt</span><br/>   ...<br/><span class="ent">➌</span> 0000000000402800 &lt;fwrite_unlocked@plt&gt;:<br/>     402800: <span class="ent">➍</span>ff 25 9a ba 21 00    jmp    QWORD PTR [rip+0x21ba9a] # 61e2a0 &lt;_fini@@Base+0x20a644&gt;<br/>     402806: 68 51 00 00 00       push  0x51<br/>     40280b: e9 d0 fa ff ff       jmp   4022e0 &lt;_init@@Base+0x28&gt;<br/>   ...<br/><span class="ent">➎</span> $ <span class="codestrong1">hexedit ls.plt</span><br/>   $ <span class="codestrong1">objdump -M intel -d ls.plt</span><br/>   ...<br/><span class="ent">➏</span> 0000000000402800 &lt;fwrite_unlocked@plt&gt;:<br/>     402800: e9 73 e6 3f 00     jmp    800e78 &lt;_end@@Base+0x1e1b10&gt;<br/>     402805: 00 68 51           add    BYTE PTR [rax+0x51],ch<br/>     402808: 00 00              add    BYTE PTR [rax],al<br/>     40280a: 00 e9              add    cl,ch<br/>     40280c: d0 fa              sar    dl,1<br/><span epub:type="pagebreak" id="page_186"/>     40280e: ff                 (bad)<br/>     40280f: ff                 .byte 0xff<br/>    ...<br/><span class="ent">➐</span> $ <span class="codestrong1">./ls.plt</span><br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   hello world!<br/>   ...</p>&#13;
<p class="indent">As before, start by creating a copy of the <span class="literal">ls</span> binary <span class="ent">➊</span> and injecting the new code into it <span class="ent">➋</span>. Note that this example uses the same code payload as for the GOT hijacking technique. As in the GOT hijacking example, you’ll replace the <span class="literal">fwrite_unlocked</span> library call with the “hello world” function.</p>&#13;
<p class="indent">Using <span class="literal">objdump</span>, take a look at the PLT entry for <span class="literal">fwrite_unlocked</span> <span class="ent">➌</span>. But this time, you’re not interested in the address of the GOT entry used by the PLT stub. Instead, look at the binary encoding of the first instruction of the PLT stub. As <span class="literal">objdump</span> shows, the encoding is <span class="literal">ff259aba2100</span> <span class="ent">➍</span>, corresponding to an indirect <span class="literal">jmp</span> instruction with an offset relative to the <span class="literal">rip</span> register. You can hijack the PLT entry by overwriting this instruction with another that jumps directly to the injected code.</p>&#13;
<p class="indent">Next, using <span class="literal">hexedit</span>, search for the byte sequence <span class="literal">ff259aba2100</span> corresponding to the first instruction of the PLT stub <span class="ent">➎</span>. Once you’ve found it, replace it with <span class="literal">e973e63f00</span>, which is the encoding for a direct <span class="literal">jmp</span> to address <span class="literal">0x800e78</span>, where the injected code resides. The first byte, <span class="literal">e9</span>, of the replacement string is the opcode for a direct <span class="literal">jmp</span>, and the next 4 bytes are an offset to the injected code, relative to the <span class="literal">jmp</span> instruction itself.</p>&#13;
<p class="indent">After completing the modifications, disassemble the PLT again, using <span class="literal">objdump</span> to verify the changes <span class="ent">➏</span>. As you can see, the first disassembled instruction of the <span class="literal">fwrite_unlocked</span> PLT entry now reads <span class="literal">jmp 800e78</span>: a direct jump to the injected code. After that, the disassembler shows a few bogus instructions resulting from the leftover bytes from the original PLT entry that you didn’t overwrite. The bogus instructions are no problem since the first instruction is the only one that will ever be executed anyway.</p>&#13;
<p class="indent">Now, let’s see whether the modifications worked. When you run the modified <span class="literal">ls</span> binary, you can see that the “hello world” message is printed for every invocation of the <span class="literal">fwrite_unlocked</span> function <span class="ent">➐</span> as expected, creating the same result as the GOT hijacking technique.</p>&#13;
<h4 class="h4" id="ch07_4_5"><em>7.4.5 Redirecting Direct and Indirect Calls</em></h4>&#13;
<p class="noindent">So far, you’ve learned how to run injected code at the start or end of a binary or when a library function is invoked. But when you want to use an injected function to replace a nonlibrary function, hijacking a GOT or PLT entry doesn’t work. In that case, you can use a disassembler to locate the calls you want to modify and then overwrite them, using a hex editor to replace them with calls to the injected function instead of the original. <span epub:type="pagebreak" id="page_187"/>The hex editing process is the same as for modifying a PLT entry, so I won’t repeat the steps here.</p>&#13;
<p class="indent">When redirecting an indirect call (as opposed to a direct one), the easiest way is to replace the indirect call with a direct one. However, this isn’t always possible since the encoding of the direct call may be longer than the encoding of the indirect call. In that case, you’ll first need to find the address of the indirectly called function that you want to replace, for instance, by using <span class="literal">gdb</span> to set a breakpoint on the indirect call instruction and inspecting the target address.</p>&#13;
<p class="indent">Once you know the address of the function to replace, you can use <span class="literal">objdump</span> or a hex editor to search for the address in the binary’s <span class="literal">.rodata</span> section. If you’re lucky, this may reveal a function pointer containing the target address. You can then use a hex editor to overwrite this function pointer, setting it to the address of the injected code. If you’re unlucky, the function pointer may be computed in some way at runtime, requiring more complex hex editing to replace the computed target with the address of the injected function.</p>&#13;
<h3 class="h3" id="ch07_5">7.5 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned how to modify ELF binaries using several simple techniques: hex editing, <span class="literal">LD_PRELOAD</span>, and ELF section injection. Because these techniques aren’t very flexible, they’re suitable only for making small changes to binaries. This chapter should have made clear to you that there’s a real need for more general and powerful binary modification techniques. Fortunately, these techniques do exist, and I’ll discuss them in <a href="ch09.xhtml#ch09">Chapter 9</a>!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch07_6">Exercises</p>&#13;
<p class="boxhead1">1. Changing the Date Format</p>&#13;
<p class="noindent">Create a copy of the <em>/bin/date</em> program and use <span class="literal">hexedit</span> to change the default date format string. You may want to use <span class="literal">strings</span> to look for the default format string.</p>&#13;
<p class="boxhead1">2. Limiting the Scope of ls</p>&#13;
<p class="noindent">Use the <span class="literal">LD_PRELOAD</span> technique to modify a copy of <em>/bin/ls</em> such that it will show directory listings only for paths within your home directory.</p>&#13;
<p class="boxhead1">3. An ELF Parasite</p>&#13;
<p class="noindent">Write your own ELF parasite and use <span class="literal">elfinject</span> to inject it into a program of your choice. See whether you can make the parasite fork off a child process that opens a backdoor. Bonus points if you can create a modified copy of <span class="literal">ps</span> that doesn’t show the parasite process in the process listing.<span epub:type="pagebreak" id="page_188"/></p>&#13;
</div>&#13;
</div></body></html>