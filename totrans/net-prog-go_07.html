<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_105" title="105"/>5</span><br/>&#13;
<span class="ChapterTitle">Unreliable UDP Communication</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Although most networking applications take advantage of TCP’s reliability and flow control, the less popular User Datagram Protocol (UDP) is nonetheless an important part of the TCP/IP stack. UDP is a simple protocol with minimal features. Some applications do not require TCP’s feature set and session overhead. Those applications, like domain name resolution services, opt to use UDP instead.</p>&#13;
<p>This chapter starts by comparing UDP to TCP, focusing on scenarios where UDP may be a better choice over TCP. Then, you’ll learn how to send and receive UDP packets in Go. Finally, you’ll learn why it’s best to limit the size of UDP packets you send across a network and how to determine an optimal packet size.</p>&#13;
<h2 id="h1-500884c05-0001"><span epub:type="pagebreak" id="Page_106" title="106"/>Using UDP: Simple and Unreliable</h2>&#13;
<p class="BodyFirst">UDP is unreliable because it does not include many of the mechanisms that make TCP so trustworthy. It provides little more than a socket address (an IP address and port). In fact, the protocol is so simple that RFC 768 describes the entire thing in about three pages. Unlike TCP, UDP does not provide session support or even confirm that the destination is accessible; it simply makes a best-effort attempt to deliver the packet. Recipients do not automatically acknowledge UDP packets, so UDP has no inherent delivery confirmation. UDP does not manage congestion, control data flow, or retransmit packets. Lastly, UDP does not guarantee that the destination receives packets in the order they originate. UDP is simply a conduit between applications and the IP layer. This simplicity is what makes UDP fast and attractive for some applications.</p>&#13;
<p>UDP has a few strengths over TCP. Whereas TCP must establish a session with each individual node in a group before it can transmit data, UDP can send a single packet to a group of nodes without duplicating the packet, a process known as <em>multicasting</em>. UDP is also capable of broadcasting packets to all members of a subnet since it doesn’t need to establish a session between each node.</p>&#13;
<p>UDP is ideal when missing packets aren’t detrimental to overall communication because the most recently received packets can take the place of earlier, dropped packets. Weather data is a good example of this. If you’re tracking a tornado in your area by streaming weather data to your phone, you aren’t as concerned about dropped packets indicating the tornado’s location two minutes ago if you’ve received packets giving you the tornado’s current location.</p>&#13;
<p>You should consider using UDP in your application if it doesn’t require all the features TCP provides. For most network applications, TCP is the right protocol choice. But UDP is an option if its speed and simplicity better fit your use case and the reliability trade-offs aren’t detrimental.</p>&#13;
<p>UDP’s packet structure consists of an 8-byte header and a payload. The header contains 2 bytes for the source port, 2 bytes for the destination port, 2 bytes for the packet length in bytes, and a 2-byte checksum. The minimum packet length is 8 bytes to account for the header and an empty payload. <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a> illustrates the organization of a UDP packet.</p>&#13;
<figure>&#13;
<img alt="f05001" src="image_fi/500884c05/f05001.png"/>&#13;
<figcaption><p><a id="figure5-1">Figure 5-1</a>: UDP packet header and payload</p></figcaption>&#13;
</figure>&#13;
<p>Although the maximum packet length is 65,535 bytes, application layer protocols often limit the packet length to avoid fragmentation, which we discuss in <span class="xref" itemid="xref_target_“Avoiding Fragmentation” on page 115">“Avoiding Fragmentation” on page 115</span>.</p>&#13;
<h2 id="h1-500884c05-0002"><span epub:type="pagebreak" id="Page_107" title="107"/>Sending and Receiving UDP Data</h2>&#13;
<p class="BodyFirst">When it comes to sending and receiving data, UDP is uncivilized compared to TCP. For example, let’s assume your neighbor baked you a pie and wants to give it to you. Using TCP to communicate is like your neighbor shouting a greeting from her window (her socket address) to your open window (your socket address). You hear her greeting and return a greeting of your own (the TCP handshake). Your neighbor then delivers your pie. You accept it and thankfully acknowledge the pie (the data transfer). You then both exchange farewells and go about your business (the termination). By contrast, using UDP to communicate is like your neighbor abruptly throwing the pie at your window, whether it’s open or not, and awaiting no confirmation that you received it.</p>&#13;
<p><span class="xref" itemid="xref_target_The section “Using the net.Conn Interface” on page 74">The section “Using the net.Conn Interface” on page 74</span> introduced the <code>net.Conn</code> interface for handling stream-oriented connections, such as TCP, between a client and a server. But this interface isn’t ideal for UDP connections because UDP is not a stream-oriented protocol. UDP does not maintain a session or involve a handshake process like TCP. UDP does not have the concept of acknowledgments, retransmissions, or flow control.</p>&#13;
<p>Instead, UDP primarily relies on the packet-oriented <code>net.PacketConn</code> interface. We’ll discuss a use case for <code>net.Conn</code> with UDP later in this chapter, but <code>net.PacketConn</code> is the better choice for most UDP applications.</p>&#13;
<h3 id="h2-500884c05-0001">Using a UDP Echo Server</h3>&#13;
<p class="BodyFirst">Sending and receiving UDP packets is a nearly identical process to sending and receiving TCP packets. But since UDP doesn’t have session support, you must be able to handle an additional return value, the sender’s address, when reading data from the connection object, as shown in <a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a>’s UDP echo server implementation.</p>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "context"&#13;
    "net"&#13;
)&#13;
&#13;
func echoServerUDP(<span class="CodeAnnotation">1</span>ctx context.Context, addr string) (net.Addr, error) {&#13;
    s, err := <span class="CodeAnnotation">2</span>net.ListenPacket("udp", addr)&#13;
    if err != nil {&#13;
        return nil, fmt.Errorf("binding to udp %s: %w", addr, err)&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">3</span> go func() {&#13;
        go func() {&#13;
            <span class="CodeAnnotationHang">4</span> &lt;-ctx.Done()&#13;
            _ = s.Close()&#13;
        }()&#13;
&#13;
        buf := make([]byte, 1024)&#13;
<span epub:type="pagebreak" id="Page_108" title="108"/>        for {&#13;
            n, <span class="CodeAnnotation">5</span>clientAddr, err := <span class="CodeAnnotation">6</span>s.ReadFrom(buf) // client to server&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
&#13;
            _, err = <span class="CodeAnnotation">7</span>s.WriteTo(buf[:n], <span class="CodeAnnotation">8</span>clientAddr) // server to client&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
    return s.LocalAddr(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: A simple UDP echo server implementation (<em>echo.go</em>)</p>&#13;
<p>This code allows you to spin up a UDP server that will echo any UDP packets it receives to the sender. You’ll make use of this code quite a bit in this chapter, so it behooves you to understand what’s happening here.</p>&#13;
<p>The function receives a context <span class="CodeAnnotation">1</span> to allow cancellation of the echo server by the caller and a string address in the familiar <em>host:port</em> format. It returns a <code>net.Addr</code> interface and an <code>error</code> interface. The caller uses the <code>net.Addr</code> interface to address messages to the echo server. The returned <code>error</code> interface is not <code>nil</code> if anything goes wrong while instantiating the echo server.</p>&#13;
<p>You create a UDP connection for your server with a call to <code>net.ListenPacket</code><span class="CodeAnnotation">2</span>, which returns a <code>net.PacketConn</code> interface and an <code>error</code> interface. The <code>net.ListenPacket</code> function is analogous to the <code>net.Listen</code> function you used to create a TCP listener in <span class="xref" itemid="xref_target_Chapters 3">Chapters 3</span> and <span class="xref" itemid="xref_target_4">4</span>, except <code>net.ListenPacket</code> exclusively returns a <code>net.PacketConn</code> interface.</p>&#13;
<p>A goroutine manages the asynchronous echoing of messages by your echo server <span class="CodeAnnotation">3</span>. A second goroutine blocks on the context’s <code>Done</code> channel <span class="CodeAnnotation">4</span>. Once the caller cancels the context, receiving on the <code>Done</code> channel unblocks and the server is closed, tearing down both this goroutine and the parent goroutine <span class="CodeAnnotation">3</span>.</p>&#13;
<p>To read from the UDP connection, you pass a byte slice to the <code>ReadFrom</code> method <span class="CodeAnnotation">6</span>. This returns the number of bytes read, the sender’s address, and an error interface. Notice there is no <code>Accept</code> method on your UDP connection as there is with the TCP-based listeners in the previous chapters. This is because UDP doesn’t use a handshake process. Here, you simply create a UDP connection listening to a UDP port and read any incoming messages. Since you don’t have the luxury of a proper introduction and an established session, you rely on the returned address <span class="CodeAnnotation">5</span> to determine which node sent you the message.</p>&#13;
<p>To write a UDP packet, you pass a byte slice and a destination address <span class="CodeAnnotation">8</span> to the connection’s <code>WriteTo</code> method <span class="CodeAnnotation">7</span>. The <code>WriteTo</code> method returns the number of bytes written and an error interface. Just as with reading data, you <span epub:type="pagebreak" id="Page_109" title="109"/>need to tell the <code>WriteTo</code> method where to send the packet, because you do not have an established session with a remote node. In <a href="#listing5-1">Listing 5-1</a>, you write the message to the original sender. But you could just as easily forward the message onto another node using your existing UDP connection object. You do not have to establish a new UDP connection object to forward on the message as you would if you were using TCP.</p>&#13;
<h3 id="h2-500884c05-0002">Receiving Data from the Echo Server</h3>&#13;
<p class="BodyFirst">Now that you are familiar with the UDP-based echo server, let’s have a look at some client code that interacts with the echo server. <a href="#listing5-2" id="listinganchor5-2">Listing 5-2</a> shows a simple interaction with the echo server.</p>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "net"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestEchoServerUDP(t *testing.T) {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    <span class="CodeAnnotationHang">1</span> serverAddr, err := echoServerUDP(ctx, "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer cancel()&#13;
&#13;
    <span class="CodeAnnotationHang">2</span> client, err := net.ListenPacket("udp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = client.Close() }()&#13;
&#13;
    msg := []byte("ping")&#13;
    _, err = <span class="CodeAnnotation">3</span>client.WriteTo(msg, serverAddr)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    n, <span class="CodeAnnotation">4</span>addr, err := <span class="CodeAnnotation">5</span>client.ReadFrom(buf)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    if addr.String() != serverAddr.String() {&#13;
        t.Fatalf("received reply from %q instead of %q", addr, serverAddr)&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_110" title="110"/>    if !bytes.Equal(msg, buf[:n]) {&#13;
        t.Errorf("expected reply %q; actual reply %q", msg, buf[:n])&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: Sending UDP packets to the echo server and receiving replies (<em>echo_test.go</em>)</p>&#13;
<p>You pass along a context and the address string to the <code>echoServer</code> function and receive the server’s address <span class="CodeAnnotation">1</span> object. You defer a call to the context’s <code>cancel</code> function, which signals the server to exit and close its goroutines. In a real-world application, using a context for cancellation of long-running processes is useful to make sure you aren’t leaking resources like memory or unnecessarily keeping files open.</p>&#13;
<p>You instantiate the client’s <code>net.PacketConn</code><span class="CodeAnnotation">2</span> in the same way that you instantiated the echo server’s <code>net.PacketConn</code>. The <code>net.ListenPacket</code> function creates the connection object for both the client and the server. Here, too, you need to tell the client where to send its message with each invocation of its <code>WriteTo</code> method <span class="CodeAnnotation">3</span>. After sending the message to the echo server, the client should immediately receive a message via its <code>ReadFrom</code> method <span class="CodeAnnotation">5</span>. You can examine the address <span class="CodeAnnotation">4</span> returned by the <code>ReadFrom</code> method to confirm that the echo server sent the message.</p>&#13;
<p>It’s important to note that the test in <a href="#listing5-2">Listing 5-2</a> can fail under certain circumstances. Even though you’re reading packets from and writing packets to a computer’s local network stack, the packets are still subject to all of the conditions that make UDP unreliable over inter-node networks. For example, full send or receive buffers, or the lack of available RAM, can result in dropped packets; large UDP packets may be subject to fragmentation (discussed later in this chapter); and operating systems using multiple threads to deliver UDP packets may deliver the packets out of order.</p>&#13;
<h3 id="h2-500884c05-0003">Every UDP Connection Is a Listener</h3>&#13;
<p class="BodyFirst">Recall from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> that Go’s <code>net</code> package distinguishes between a TCP connection object (<code>TCPConn</code>) and a TCP listener (<code>TCPListener</code>). The TCP listener is what accepts the connection and returns an object that represents the listener’s side of the connection so that the listener can then send a message to the client.</p>&#13;
<p>There is no UDP equivalent of the <code>TCPListener</code> because UDP lacks sessions. This means your code has a bit more accounting to do when it receives packets. You need to verify the sender’s address, because you can no longer trust that all incoming packets to a connection object are from the same sender.</p>&#13;
<p>The next few listings are part of a test that a single UDP connection object can receive packets from more than one sender. <a href="#listing5-3" id="listinganchor5-3">Listing 5-3</a> spins up an echo server and a client for the test.</p>&#13;
<span epub:type="pagebreak" id="Page_111" title="111"/><pre><code>package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "net"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestListenPacketUDP(t *testing.T) {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    <span class="CodeAnnotationHang">1</span> serverAddr, err := echoServerUDP(ctx, "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer cancel()&#13;
&#13;
    <span class="CodeAnnotationHang">2</span> client, err := net.ListenPacket("udp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = client.Close() }()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: Creating an echo server and client (<em>listen_packet_test.go</em>)</p>&#13;
<p>You start by creating the echo server <span class="CodeAnnotation">1</span> and client connection <span class="CodeAnnotation">2</span>. <a href="#listing5-4" id="listinganchor5-4">Listing 5-4</a> adds a second network connection to interact with the client.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> interloper, err := net.ListenPacket("udp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    interrupt := []byte("pardon me")&#13;
    <span class="CodeAnnotationHang">2</span> n, err := interloper.WriteTo(interrupt, client.LocalAddr())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    _ = interloper.Close()&#13;
&#13;
    if l := len(interrupt); l != n {&#13;
        t.Fatalf("wrote %d bytes of %d", n, l)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: Adding an interloper and interrupting the client with a message (<em>listen_packet_test.go</em>)</p>&#13;
<p>You then create a new UDP connection <span class="CodeAnnotation">1</span> meant to interlope on the client and echo server and interrupt the client <span class="CodeAnnotation">2</span>. This message should queue up in the client’s receive buffer.</p>&#13;
<p><span epub:type="pagebreak" id="Page_112" title="112"/>The client sends its ping message to the echo server and reconciles the replies in <a href="#listing5-5" id="listinganchor5-5">Listing 5-5</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    ping := []byte("ping")&#13;
    _, err = <span class="CodeAnnotation">1</span>client.WriteTo(ping, serverAddr)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    n, addr, err := <span class="CodeAnnotation">2</span>client.ReadFrom(buf)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    if !bytes.Equal(<span class="CodeAnnotation">3</span>interrupt, buf[:n]) {&#13;
        t.Errorf("expected reply %q; actual reply %q", interrupt, buf[:n])&#13;
    }&#13;
&#13;
    if addr.String() != interloper.LocalAddr().String() {&#13;
        t.Errorf("expected message from %q; actual sender is %q",&#13;
            interloper.LocalAddr(), addr)&#13;
    }&#13;
&#13;
    n, addr, err = client.ReadFrom(buf)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    if !bytes.Equal(<span class="CodeAnnotation">4</span>ping, buf[:n]) {&#13;
        t.Errorf("expected reply %q; actual reply %q", ping, buf[:n])&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">5</span> if addr.String() != serverAddr.String() {&#13;
        t.Errorf("expected message from %q; actual sender is %q",&#13;
            serverAddr, addr)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: Receiving UDP packets from multiple senders at once (<em>listen_packet_test.go</em>)</p>&#13;
<p>Meanwhile, the client writes a ping message to the echo server <span class="CodeAnnotation">1</span> and promptly reads an incoming message <span class="CodeAnnotation">2</span>. What’s unique about the UDP client connection is it first reads the interruption message from the interloping connection <span class="CodeAnnotation">3</span> and then the reply from the echo server <span class="CodeAnnotation">4</span>. Were this a TCP connection, the client would have never received the interloper’s message. As such, your code should always verify the sender of each packet it reads by evaluating the second return value <span class="CodeAnnotation">5</span> from the <code>ReadFrom</code> method, the sender’s address.</p>&#13;
<h3 id="h2-500884c05-0004"><span epub:type="pagebreak" id="Page_113" title="113"/>Using net.Conn in UDP</h3>&#13;
<p class="BodyFirst">You can establish a UDP connection that implements the <code>net.Conn</code> interface so that your code behaves indistinguishably from a TCP <code>net.Conn</code>. You do so by passing <code>udp</code> as the first argument to the <code>net.Dial</code> function used in the preceding two chapters. Using <code>net.Conn</code> with your UDP-based connections can prevent interlopers from sending you messages and eliminate the need to check the sender’s address on every reply you receive.</p>&#13;
<p><a href="#listing5-6" id="listinganchor5-6">Listing 5-6</a> creates the UDP-based <code>net.Conn</code> and demonstrates how <code>net.Conn</code> encapsulates the implementation details of UDP to emulate a stream-oriented network connection.</p>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "net"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestDialUDP(t *testing.T) {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    <span class="CodeAnnotationHang">1</span> serverAddr, err := echoServerUDP(ctx, "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer cancel()&#13;
&#13;
    client, err := <span class="CodeAnnotation">2</span>net.Dial("udp", serverAddr.String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = client.Close() }()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: Creating an echo server and client (<em>dial_test.go</em>)</p>&#13;
<p>The client side of a connection can leverage the stream-oriented functionality of <code>net.Conn</code> over UDP, but the UDP listener must still use <code>net.PacketConn</code>. You spawn an instance of the echo server <span class="CodeAnnotation">1</span> for the purpose of sending a reply to the client. You then dial the echo server over UDP by passing <code>udp</code> as the first argument to <code>net.Dial</code><span class="CodeAnnotation">2</span>. Unlike TCP, the echo server receives no traffic upon calling <code>net.Dial</code> because no handshake is necessary.</p>&#13;
<p><a href="#listing5-7" id="listinganchor5-7">Listing 5-7</a> interrupts the client by sending a message to it before the echo server sends its reply.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    interloper, err := net.ListenPacket("udp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_114" title="114"/>    interrupt := []byte("pardon me")&#13;
    <span class="CodeAnnotationHang">1</span> n, err := interloper.WriteTo(interrupt, client.LocalAddr())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    _ = interloper.Close()&#13;
&#13;
    if l := len(interrupt); l != n {&#13;
        t.Fatalf("wrote %d bytes of %d", n, l)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: Interrupting the client (<em>dial_test.go</em>)</p>&#13;
<p>Just as in <a href="#listing5-4">Listing 5-4</a>, you send a message to the client from an interloping connection <span class="CodeAnnotation">1</span>.</p>&#13;
<p><a href="#listing5-8" id="listinganchor5-8">Listing 5-8</a> details the difference between a UDP connection using <code>net.Conn</code> and one using <code>net.PacketConn</code>, as in <a href="#listing5-5">Listing 5-5</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    ping := []byte("ping")&#13;
    _, err = <span class="CodeAnnotation">1</span>client.Write(ping)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    n, err = <span class="CodeAnnotation">2</span>client.Read(buf)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    if !bytes.Equal(ping, buf[:n]) {&#13;
        t.Errorf("expected reply %q; actual reply %q", ping, buf[:n])&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>client.SetDeadline(time.Now().Add(time.Second))&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    _, err = <span class="CodeAnnotation">4</span>client.Read(buf)&#13;
    if err == nil {&#13;
        t.Fatal("unexpected packet")&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: Using <code>net.Conn</code> to manage UDP traffic (<em>dial_test.go</em>)</p>&#13;
<p>The client sends a ping message to the echo server by using <code>net.Conn</code>’s <code>Write</code> method <span class="CodeAnnotation">1</span>. The <code>net.Conn</code> client will write its messages to the address specified in the <code>net.Dial</code> call. You do not need to specify a destination address for every packet you send using the client connection. Likewise, you read packets using the client’s <code>Read</code> method <span class="CodeAnnotation">2</span>. The client reads packets only from <span epub:type="pagebreak" id="Page_115" title="115"/>the sender address specified in the <code>net.Dial</code> call, as you would expect using a stream-oriented connection object. The client never reads the message sent by the interloping connection. To make sure, you set an ample deadline <span class="CodeAnnotation">3</span> and attempt to read another message <span class="CodeAnnotation">4</span>.</p>&#13;
<p>For your purposes, using <code>net.Conn</code> over <code>net.PacketConn</code> may make your UDP connection code cleaner. Just be aware of the trade-offs. Using <code>net.Conn</code> with UDP does not offer the same functionality as you would expect when using <code>net.Conn</code> with TCP. For example, a UDP-based <code>net.Conn</code>’s <code>Write</code> method will not return an error if the destination failed to receive the packet. The onus is still on your application code to confirm delivery when using UDP.</p>&#13;
<h2 id="h1-500884c05-0003">Avoiding Fragmentation</h2>&#13;
<p class="BodyFirst"><em>Fragmentation</em> is a Layer 3 IP process of splitting a packet into smaller pieces suitable for efficient transmission over a network. All network media have packet size limitations known as the <em>maximum transmission unit (MTU)</em>. Packets larger than the medium’s maximum transmission unit require fragmentation so that each fragment is less than or equal to the medium’s MTU before nodes pass them over the medium. Once the fragments reach their destination, the operating system reassembles each packet and presents the packet to your application.</p>&#13;
<p>But fragments can corrupt or fail to reach their destination for one reason or another. This is a significant consideration if you’re using UDP because, unlike TCP, UDP does not gracefully recover from missing or corrupt data. If an operating system fails to receive even a single fragment, the sender must retransmit the entire UDP packet. As you can imagine, retransmitting large packets is woefully inefficient. Although there are numerous approaches to mitigating the effects of fragmentation, we’ll attempt to avoid it altogether. We’ll focus on a straightforward way to identify the MTU between your computer and a destination node, and then use those results to inform your choice of payload size to avoid fragmentation.</p>&#13;
<p>You can use the <code>ping</code> command to determine the MTU between your computer and a destination node. The <code>ping</code> command allows you to send an ICMP packet of a specific size with a flag set to inform nodes not to fragment it. If the packet reaches a node that needs to fragment the packet because of its size, the node will see the <em>do not fragment</em> flag and respond with an ICMP message informing you that the packet is too large.</p>&#13;
<p>The following example sends these pings over Ethernet, which has a minimum MTU of 46 bytes and a maximum MTU of 1,500 bytes, per its specification. If any hop between your computer and its destination has an MTU of less than 1,500 bytes, your packet will fragment. Let’s confirm that with the <code>ping</code> command on Linux (<a href="#listing5-9" id="listinganchor5-9">Listing 5-9</a>).</p>&#13;
<pre><code>$ <b>ping -M </b><span class="CodeAnnotation">1</span><b>do -s </b><span class="CodeAnnotation">2</span><b>1500 1.1.1.1</b>&#13;
PING 1.1.1.1 (1.1.1.1) 1500(<span class="CodeAnnotation">3</span>1528) bytes of data.&#13;
ping: sendmsg: <span class="CodeAnnotation">4</span>Message too long</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: Pinging 1.1.1.1 with a payload size of 1,500 bytes on Linux</p>&#13;
<p><span epub:type="pagebreak" id="Page_116" title="116"/>You set the <code>-M</code> flag <span class="CodeAnnotation">1</span> to <code>do</code>, which sets the prohibit fragmentation option, and set the <code>-s</code> flag <span class="CodeAnnotation">2</span> to <code>1500</code>, which sets a payload of 1,500 bytes. Since you aren’t accounting for the packet’s header size, this should exceed the Ethernet MTU. As expected, you get a notification that the packet needs fragmentation <span class="CodeAnnotation">4</span>. You also see that the total packet size is 1,528 bytes <span class="CodeAnnotation">3</span>. The extra 28 bytes is the sum of the 8-byte ICMP header and the 20-byte IP header. Any payload you specify should account for the overall header size as well.</p>&#13;
<p>As you can see, you never received a reply from 1.1.1.1 in <a href="#listing5-9">Listing 5-9</a> because the packet you sent was too big to traverse each hop without requiring fragmentation. Instead, the <code>ping</code> command informed you that your message was too long.</p>&#13;
<p>Let’s try again and subtract 28 bytes from the payload (<a href="#listing5-10" id="listinganchor5-10">Listing 5-10</a>).</p>&#13;
<pre><code>$ <b>ping -M do -s 1472 1.1.1.1</b>&#13;
PING 1.1.1.1 (1.1.1.1) 1472(1500) bytes of data.&#13;
1480 bytes from 1.1.1.1: icmp_seq=1 ttl=59 time=11.8 ms</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: Pinging 1.1.1.1 with a payload size of 1472 bytes on Linux</p>&#13;
<p>That’s more like it. You confirmed that the MTU between this computer and 1.1.1.1 over the internet is set to 1,500 bytes. This is the maximum packet size you can send on the network before it will require fragmentation. Thankfully, the UDP header is also 8 bytes, so the <code>ping</code> command gives accurate results despite using ICMP. Accounting for the headers, your maximum UDP payload size is 1,472 bytes to avoid fragmentation.</p>&#13;
<p>The equivalent <code>ping</code> command on Windows is the following:</p>&#13;
<pre><code>C:\&gt;<b>ping -f -l 1500 1.1.1.1</b></code></pre>&#13;
<p>The <code>-f</code> flag instructs nodes to not fragment the packet, and the <code>-l</code> flag sets the packet size to the given integer in bytes.</p>&#13;
<p>On macOS, the <code>ping</code> command looks like this:</p>&#13;
<pre><code>$ <b>ping -D -s 1500 1.1.1.1</b></code></pre>&#13;
<p>The <code>-D</code> flag sets the no fragmentation flag, and the <code>-s</code> flag specifies the payload size.</p>&#13;
<p>Keep in mind that the MTU from your computer may differ from the examples in this chapter because of MTU settings either on your network or between your computer and the destination you choose to ping. I recommend you experiment with the <code>ping</code> command to determine the MTU from your computer to various hosts on the internet and see if you find any differences.</p>&#13;
<h2 id="h1-500884c05-0004"><span epub:type="pagebreak" id="Page_117" title="117"/>What You’ve Learned</h2>&#13;
<p class="BodyFirst">UDP is a minimalistic, datagram-based protocol that favors speed over reliability by eschewing many of TCP’s flow control and reliability features. UDP is ideal when speed and simplicity are required and the potential for data loss is acceptable, such as with live video streaming.</p>&#13;
<p>Since UDP is not session based, there is no concept of a UDP listener that accepts a connection after establishing a session. Rather, you create a network connection by using <code>net.ListenPacket</code>, which returns a <code>net.PacketConn</code> interface. Your code can then read any incoming messages, or datagrams, from the <code>net.PacketConn</code> interface since every <code>net.PacketConn</code> listens for incoming messages.</p>&#13;
<p>Fragmentation is a serious consideration when using UDP. It’s important to avoid fragmentation of your UDP packets whenever possible to help ensure delivery. The <code>ping</code> command can help you derive the appropriate maximum transmission unit between your computer and your destination network. Since ICMP packet headers used by the <code>ping</code> command are the same size as UDP headers, you can use that knowledge to easily determine the payload size threshold at which fragmentation will occur. Aside from managing fragmentation by appropriately sizing your payloads, your code must manage acknowledgments and retransmissions to ensure reliability.</p>&#13;
</section>&#13;
</body></html>