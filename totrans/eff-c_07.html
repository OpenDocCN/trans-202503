<html><head></head><body>
<section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<span aria-label="137" epub:type="pagebreak" id="pg_137" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch7">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS AND STRINGS</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">Strings are such an important and useful data type that nearly every programming language implements them in some form. Often used to represent text, strings constitute most of the data exchanged between an end user and a program, including text input fields, command line arguments, environment variables, and console input.</p>
<p class="TX">In C, the string data type is modeled on the idea of a formal string (Hopcroft and Ullman 1979):</p>
<p class="Blockquote">Let <span class="blockquote_greek_NSSymbol"><span lang="el" xml:lang="el">Σ</span></span> be a non-empty finite set of characters, called the alphabet. A string over <span class="blockquote_greek_NSSymbol"><span lang="el" xml:lang="el">Σ</span></span> is any finite sequence of characters from <span class="blockquote_greek_NSSymbol"><span lang="el" xml:lang="el">Σ</span></span>. For example, if <span class="blockquote_greek_NSSymbol"><span lang="el" xml:lang="el">Σ</span></span> = {0, 1}, then 01011 is a string over <span class="blockquote_greek_NSSymbol"><span lang="el" xml:lang="el">Σ</span></span>.</p>
<p class="TX">In this chapter, we’ll talk about the various character sets, including ASCII and Unicode, that can be used to compose strings (the <i>alphabet</i> from the formal definition). We’ll cover how strings are represented and manipulated using the legacy functions from the C standard library, the <span aria-label="138" epub:type="pagebreak" id="pg_138" role="doc-pagebreak"/>bounds-checked interfaces, and POSIX and Windows application programming interfaces (APIs).</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-62"/><samp class="SANS_Futura_Std_Bold_B_11">Characters</samp></h2>
<p class="TNI">The characters that people use to communicate aren’t naturally understood by digital systems, which operate on bits. To process characters, digital systems use <i>character encodings</i> that assign unique integer values, referred to as <i>code points</i>, to designate specific characters. As you’ll see, there are multiple ways to encode the same notional character in your program. Common standards used by C implementations for encoding characters include Unicode, ASCII, Extended ASCII, ISO 8859-1 (Latin-1), Shift-JIS, and EBCDIC.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The C standard explicitly references Unicode and ASCII.</i></p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2" id="sec2"><span id="h2-82"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp></h3>
<p class="TNI">The <i>7-bit American Standard Code for Information Interchange</i>, better known as <i>7-bit ASCII</i>, specifies a set of 128 characters and their coded representation (ANSI X3.4-1986). Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp> and character <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> are control characters, such as null, backspace, horizontal tab, and DEL. Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp> are all printable characters such as letters, digits, and symbols.</p>
<p class="TX">We often refer to this standard with the updated name <i>US-ASCII</i> to clarify that this system was developed in the United States and focuses on the typographical symbols predominantly used in this country. Most modern character encoding schemes are based on US-ASCII, although they support many additional characters.</p>
<p class="TX">Characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> range are not defined by US-ASCII but are part of the 8-bit character encoding known as <i>Extended ASCII</i>. Numerous encodings for these ranges exist, and the actual mapping depends on the code page. A <i>code page</i> is a character encoding that maps a set of printable characters and control characters to unique numbers.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp></h3>
<p class="TNI"><i>Unicode</i> has become the universal character encoding standard for representing text in computer processing. It supports a much wider range of characters than ASCII does; the current Unicode Standard (Unicode 2023) encodes characters in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>, which amounts to a 21-bit code space. An individual Unicode value is expressed as <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp> followed by four or more hexadecimal digits in printed text. The Unicode characters <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp> are identical to those in US-ASCII, and the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> is identical to ISO 8859-1, consisting of characters from the Latin script used throughout the Americas, Western Europe, Oceania, and much of Africa.</p>
<p class="TX">Unicode organizes code points into <i>planes</i>, which are continuous groups of 65,536 code points. There are 17 planes, identified by the <span aria-label="139" epub:type="pagebreak" id="pg_139" role="doc-pagebreak"/>numbers 0 to 16. The most used characters, including those found in major, older encoding standards, have been placed into the first plane (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>), which is called the <i>basic multilingual plane (BMP)</i>, or Plane 0.</p>
<p class="TX">Unicode also specifies several <i>Unicode transformation formats (UTFs)</i>, which are character encoding formats that assign each Unicode scalar value to a unique code unit sequence. A <i>Unicode scalar value</i> is any Unicode code point except high-surrogate and low-surrogate code points. (Surrogate pairs are explained later in this section.) A <i>code unit</i> is the minimal bit combination that can represent encoded text for processing or interchange. The Unicode standard defines three UTFs to allow for code units of various sizes:</p>
<p class="RunInPara1"><b>UTF-8</b> Represents each character as a sequence of one to four 8-bit code units</p>
<p class="RunInPara"><b>UTF-16</b> Represents each character as a sequence of one or two 16-bit code units</p>
<p class="RunInPara2"><b>UTF-32</b> Represents each character as a single 32-bit code unit</p>
<p class="TX">The UTF-8 encoding is the dominant encoding for POSIX operating systems. It has the following desirable properties:</p>
<ul class="ul">
<li class="ListBullet">It encodes US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>. This means that files and strings that contain only 7-bit ASCII characters have the same encoding under both ASCII and UTF-8.</li>
<li class="ListBullet">Using a null byte to terminate a string (a topic we’ll discuss later) works the same as for an ASCII string.</li>
<li class="ListBullet">All currently defined Unicode code points can be encoded using between 1 and 4 bytes.</li>
<li class="ListBullet">Unicode allows character boundaries to be easily identified by scanning for well-defined bit patterns in either direction.</li>
</ul>
<p class="TX">On Windows, you can compile and link your programs with the Visual C++ <samp class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp> flag to set the source and execution character sets as UTF-8. You’ll also need to configure Windows to use Unicode UTF-8 for worldwide language support.</p>
<p class="TX">UTF-16 is currently the dominant encoding for Windows operating systems. Like UTF-8, UTF-16 is a variable-width encoding. As just mentioned, the BMP consists of characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>. Characters whose code points are greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp> are called <i>supplementary characters</i>. Supplementary characters are defined by a pair of code units called <i>surrogates</i>. The first code unit is from the high-surrogates range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>), and the second code unit is from the low-surrogates range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>).</p>
<p class="TX">Unlike other variable-length UTFs, UTF-32 is a fixed-length encoding. The main advantage of UTF-32 is that the Unicode code points can be directly indexed, meaning that you can find the <i>n</i>th code point in a sequence of code points in constant time. In contrast, a variable-length <span aria-label="140" epub:type="pagebreak" id="pg_140" role="doc-pagebreak"/>encoding requires accessing each code point to find the <i>n</i>th code point in a sequence.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Source and Execution Character Sets</samp></h3>
<p class="TNI">No universally accepted character encoding existed when C was originally standardized, so it was designed to work with a wide variety of character representations. Instead of specifying a character encoding like Java, each C implementation defines both a <i>source character set</i> in which source files are written and an <i>execution character set</i> used for character and string literals at compile time.</p>
<p class="TX">Both the source and execution character sets must contain encodings for the uppercase and lowercase letters of the Latin alphabet; the 10 decimal digits; 29 graphic characters; and the space, horizontal tab, vertical tab, form feed, and newline characters. The execution character set also includes alert, backspace, carriage return, and null characters.</p>
<p class="TX">Character conversion and classification functions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>) are evaluated at runtime, based on the locale-determined encoding in effect at the time of the call. A program’s <i>locale</i> defines its code sets, date and time formatting conventions, monetary conventions, decimal formatting conventions, and sort order.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Types</samp></h3>
<p class="TNI">C defines several data types to represent character data, some of which we have already seen. C offers the unadorned <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type to represent <i>narrow characters</i> (those that can be represented in as few as 8 bits) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type to represent <i>wide characters</i> (those that may require more than 8 bits).</p>
<section aria-labelledby="sec6" epub:type="division">

<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp></h4>
<p class="TNI">As I have already mentioned, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is an integer type, but each implementation defines whether it’s signed or unsigned. In portable code, you can assume neither.</p>
<p class="TX">Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type for character data (where signedness has no meaning) and not for integer data (where signedness is important). You can safely use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type to represent 7-bit character encodings, such as US-ASCII. For these encodings, the high-order bits are always 0, so you don’t have to be concerned about sign extension when a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and implementation defined as a signed type.</p>
<p class="TX">You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type to represent 8-bit character encodings, such as Extended ASCII, ISO/IEC 8859, EBCDIC, and UTF-8. These 8-bit character encodings can be problematic on implementations that define <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> as an 8-bit signed type. For example, the following code prints the string <samp class="SANS_TheSansMonoCd_W5Regular_11">end of file</samp> when an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> is detected:</p>

<pre><code>char c = 'ÿ';  // extended character
if (c == EOF) puts("end of file");</code></pre>
<p class="TX"><span aria-label="141" epub:type="pagebreak" id="pg_141" role="doc-pagebreak"/>Assuming the implementation-defined execution character set is ISO/IEC 8859-1, the Latin small letter y with diaeresis (<span class="accent">ÿ</span>) is defined to have the representation <samp class="SANS_TheSansMonoCd_W5Regular_11">255 (0xFF)</samp>. For implementations in which <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is defined as a signed type, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> will be sign-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, making the <span class="accent">ÿ</span> character indistinguishable from <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> because they have the same representation.</p>
<p class="TX">A similar problem occurs when using the character classification functions defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;ctype.h&gt;</samp>. These library functions accept a character argument as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. They return a nonzero value if the character belongs to the set of characters that the function’s description defines and zero if the value doesn’t belong to it. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp> function tests whether the character is a decimal-digit character in the current locale. Any argument value that isn’t a valid character or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> results in undefined behavior.</p>
<p class="TX">To avoid undefined behavior when invoking these functions, cast <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> before the integer promotions, as shown here:</p>

<pre><code>char c = 'ÿ';
if (isdigit((unsigned char)c)) {
  puts("c is a digit");
}</code></pre>
<p class="TX">The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is zero-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, eliminating the undefined behavior by ensuring that the resulting value is representable as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>. Note that the initialization of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> may result in a warning or error.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h4 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp></h4>
<p class="TNI">Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type for data that could be either <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> (a negative value) or character data interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and then converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Functions that read character data from a stream, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>, return the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. As we’ve seen, character-handling functions from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;ctype.h&gt;</samp> also accept this type because they might be passed the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> or related functions.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is an integer type added to C to process the characters of a large character set. It can be a signed or unsigned integer type, depending on the implementation, and it has an implementation-defined inclusive range of <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>. Most implementations define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to be either a 16- or 32-bit unsigned integer type, but implementations that don’t support localization may define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to have the same width as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. C does not permit a variable-length encoding for wide strings (despite UTF-16 being used this way in practice on Windows). Implementations can conditionally define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> as an integer constant of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp> (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>) to mean that the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is used to represent Unicode characters corresponding to the specified version of <span aria-label="142" epub:type="pagebreak" id="pg_142" role="doc-pagebreak"/>the standard. Implementations that chose a 16-bit type for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> cannot meet the requirements for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> for ISO/IEC 10646 editions more recent than Unicode 3.1. Consequently, the requirement for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> is either a <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type larger than 20 bits or a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> and a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> earlier than <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type can be used for encodings other than Unicode, such as wide EBCDIC.</p>
<p class="TX">Writing portable code using <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> can be difficult because of the range of implementation-defined behavior. For example, Windows uses a 16-bit unsigned integer type, while Linux typically uses a 32-bit unsigned integer type. Code that calculates the lengths and sizes of wide-character strings is error prone and must be performed with care.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t and char32_t</samp></h4>
<p class="TNI">Other languages (including Ada95, Java, TCL, Perl, Python, and C#) have data types for Unicode characters. C11 introduced the 16- and 32-bit character data types <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>, declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;uchar.h&gt;</samp>, to provide data types for UTF-16 and UTF-32 encodings, respectively. C doesn’t provide standard library functions for the new data types, except for one set of character conversion functions. Without library functions, these types have limited usefulness.</p>
<p class="TX">C defines two environment macros that indicate how characters represented in these types are encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> are UTF-16 encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> are UTF-32 encoded. If the macro isn’t defined, another implementation-defined encoding is used. Visual C++ does not define these macros, suggesting that you can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> on Windows for UTF-16.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h3 class="H2" id="sec10"><span id="h2-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Constants</samp></h3>
<p class="TNI">C allows you to specify <i>character constants</i>, also known as <i>character literals</i>, which are sequences of one or more characters enclosed in single quotes, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>. Character constants allow you to specify character values in the source code of your program. <a href="chapter7.xhtml#tab7-1">Table 7-1</a> shows the types of character constants that can be specified in C.</p>
<p class="TT" id="tab7-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Types of Character Constants</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">u8'a'</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">L'a'</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The unsigned type corresponding to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">u'a'</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">U'a'</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="143" epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/>The value of a character constant containing more than one character (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>) is implementation defined. So is the value of a source character that cannot be represented as a single code unit in the execution character set. The earlier example of <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp> is one such case. If the execution character set is UTF-8, the value might be <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp> to reflect the UTF-8 encoding of the two code units needed to represent the <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> code-point value. C23 adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix for character literals to represent a UTF-8 encoding. A UTF-8, UTF-16, or UTF-32 character constant cannot contain more than one character. The value must be representable with a single UTF-8, UTF-16, or UTF-32 code unit, respectively. Because UTF-8 encodes US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix can be used to create ASCII characters, even on implementations where the locale-dependent character encoding is some other encoding, such as EBCDIC.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2" id="sec11"><span id="h2-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Escape Sequences</samp></h3>
<p class="TNI">The single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>) and backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) have special meanings, so they cannot be directly represented as characters. Instead, to represent the single quote, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>, and to represent the backslash, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>. We can represent other characters, such as the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>), and arbitrary integer values by using the escape sequences shown in <a href="chapter7.xhtml#tab7-2">Table 7-2</a>.</p>
<p class="TT" id="tab7-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">Escape Sequences</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Character</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Single quote</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Double quote</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Question mark</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Backslash</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Alert</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Backspace</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Form feed</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Newline</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Carriage return</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Horizontal tab</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Vertical tab</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Octal character</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">up to three octal digits</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Hexadecimal character</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x hexidecimal digits</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The following nongraphical characters are represented by escape sequences consisting of the backslash followed by a lowercase letter: <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp> (alert), <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> (backspace), <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> (form feed), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> (newline), <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> (carriage return), <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> (horizontal tab), and <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> (vertical tab).</p>
<p class="TX"><span aria-label="144" epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>Octal digits can be incorporated into an octal escape sequence to construct a single character for a character constant or a single wide character for a wide-character constant. The numerical value of the octal integer specifies the value of the desired character or wide character. <i>A backslash followed by numbers is always interpreted as an octal value.</i> For example, you can represent the backspace character (8 decimal) as the octal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp> or, equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>.</p>
<p class="TX">You can also incorporate the hexadecimal digits that follow the <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp> to construct a single character or wide character for a character constant. The numerical value of the hexadecimal integer forms the value of the desired character or wide character. For example, you can represent the backspace character as the hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> or, equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h3 class="H2" id="sec12"><span id="h2-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp></h3>
<p class="TNI">Character encodings have evolved differently on various operating systems. Before UTF-8 emerged, Linux typically relied on various language-specific extensions of ASCII. The most popular of these were ISO 8859-1 and ISO 8859-2 in Europe, ISO 8859-7 in Greece, KOI-8/ISO 8859-5/CP1251 in Russia, EUC and Shift-JIS in Japan, and BIG5 in Taiwan. Linux distributors and application developers are phasing out these older legacy encodings in favor of UTF-8 to represent localized text strings (Kuhn 1999).</p>
<p class="TX">GCC has several flags that allow you to configure character sets. Here are a couple of flags you may find useful:</p>

<pre><code>-fexec-charset=<var>charset</var></code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> flag sets the execution character set that’s used to interpret string and character constants. The default is UTF-8. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> can be any encoding supported by the system’s <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp> library routine described later in this chapter. For example, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp> instructs GCC to interpret string constants hardcoded in source code, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> format strings, according to EBCDIC code page 1,047.</p>
<p class="TX">To select the wide-execution character set, used for wide-string and character constants, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp> flag:</p>

<pre><code>-fwide-exec-charset=<var>charset</var></code></pre>
<p class="TX">The default is UTF-32 or UTF-16, corresponding to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.</p>
<p class="TX">The input character set defaults to your system locale (or UTF-8 if the system locale is not configured). To overwrite the input character set used for translating the character set of the input file to the source character set used by GCC, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> flag:</p>

<pre><code>-finput-charset=<var>charset</var></code></pre>
<p class="TX"><span aria-label="145" epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>Clang has <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> but not <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>. Clang allows you to set <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> to UTF-8 only and rejects any attempt to set it to something else.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h3 class="H2" id="sec13"><span id="h2-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp></h3>
<p class="TNI">Support for character encodings in Windows has irregularly evolved. Programs developed for Windows can handle character encodings using either Unicode interfaces or interfaces that rely implicitly on locale-dependent character encodings. For most modern applications, you should choose the Unicode interfaces by default to ensure that the application behaves as you expect when processing text. Generally, this code will have better performance, as narrow strings passed to Windows library functions are frequently converted to Unicode strings.</p>
<section aria-labelledby="sec14" epub:type="division">

<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The main and wmain Entry Points</samp></h4>
<p class="TNI">Visual C++ supports two entry points to your program: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, which allows you to pass narrow-character arguments, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>, which allows you to pass wide-character arguments. You declare formal parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp> by using a similar format to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, as shown in <a href="chapter7.xhtml#tab7-3">Table 7-3</a>.</p>
<p class="TT" id="tab7-3"><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-3:</samp> <samp class="SANS_Futura_Std_Book_11">Windows Program Entry Point Declarations</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Narrow-character arguments</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Wide-character arguments</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp></p>
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char *envp[]);</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[],</samp></p>
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">          </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">For either entry point, the character encoding ultimately depends on the calling process. However, by convention, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function receives its optional arguments and environment as pointers to text encoded with the current Windows (also called ANSI) code page, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp> function receives UTF-16-encoded text.</p>
<p class="TX">When you run a program from a shell such as the command prompt, the shell’s command interpreter converts the arguments into the proper encoding for that entry point. A Windows process starts with a UTF-16-encoded command line. The startup code emitted by the compiler/linker calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp> function to convert the command line to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp> form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> or passes the command line arguments directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp> form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>. In a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, the results are then transcoded to the current Windows code page, which can vary from system to system. The ASCII character <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> is substituted for characters that lack representation in the current Windows code page.</p>
<p class="TX">The Windows console uses an original equipment manufacturer (OEM) code page when writing data to the console. The actual encoding used varies from system to system but is often different from the Windows code <span aria-label="146" epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>page. For example, on a US English version of Windows, the Windows code page may be Windows Latin 1, while the OEM code page may be DOS Latin US. In general, writing textual data to <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> requires the text to be converted to the OEM code page first, or requires setting the console’s output code page to match the encoding of the text being written out. Failure to do so may cause unexpected output to be printed to the console. However, even if you carefully match the character encodings between your program and the console, the console might still fail to display the characters as expected because of other factors, such as the current font selected for the console not having the appropriate glyphs required to represent the characters. Additionally, the Windows console has historically been unable to display characters outside of the Unicode BMP because it stores only a 16-bit value for character data for each cell.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Narrow vs. Wide Characters</samp></h4>
<p class="TNI">There are two versions of all system APIs in the Win32 software development kit (SDK): a narrow Windows (ANSI) version with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix and a wide-character version with a <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix:</p>

<pre><code>int SomeFuncA(LPSTR SomeString);
int SomeFuncW(LPWSTR SomeString);</code></pre>
<p class="TX">Determine whether your application is going to use wide (UTF-16) or narrow characters and then code accordingly. The best practice is to explicitly call the narrow- or wide-string version of each function and pass a string of the appropriate type:</p>

<pre><code>SomeFuncW(L"String");
SomeFuncA("String");</code></pre>
<p class="TX">Examples of actual functions from the Win32 SDK include the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp> functions.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h3 class="H2" id="sec16"><span id="h2-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Conversion</samp></h3>
<p class="TNI">Although international text is increasingly encoded in Unicode, it’s still encoded in language- or country-dependent character encodings, making it necessary to convert between these encodings. Windows still operates in locales with traditional, limited character encodings, such as IBM EBCDIC and ISO 8859-1. Programs frequently need to convert between the Unicode and traditional encoding schemes when performing input/output (I/O).</p>
<p class="TX">It’s not possible to convert all strings to each language- or country-dependent character encoding. This is obvious when the encoding is US-ASCII, which can’t represent characters requiring more than 7 bits of storage. Latin-1 will never encode the character <samp class="SANS_Source_Han_Serif_SC_Regular_11"><span lang="zh" xml:lang="zh">愛</span></samp> properly, and many kinds of non-Japanese letters and words cannot be converted to Shift-JIS without losing information.</p>
<section aria-labelledby="sec17" epub:type="division">
<span aria-label="147" epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/>
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">C Standard Library</samp></h4>
<p class="TNI">The C standard library provides a handful of functions to convert between narrow-code units (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>) and wide-code units (<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp> (multibyte to wide character), <samp class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp> (wide character to multibyte), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp> (multibyte restartable to wide character), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp> (wide-character restartable to multibyte) functions convert one code unit at a time, writing the result to an output object or buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp> (multibyte string to wide-character string), <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp> (wide-character string to multibyte string), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp> (multibyte-string restartable to multibyte string), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp> (wide-character-string restartable to wide-character string) functions convert a sequence of code units, writing the result to an output buffer.</p>
<p class="TX">Conversion functions need to store data to properly process a sequence of conversions between function calls. The <i>nonrestartable</i> forms store the state internally and are consequently unsuitable for multithreaded processing. The <i>restartable</i> versions have an additional parameter that’s a pointer to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> that describes the current conversion state of the associated multibyte character sequence. This object holds the state data that makes it possible to restart the conversion where it left off after another call to the function to perform an unrelated conversion. The <i>string</i> versions are for performing bulk conversions of multiple code units at once.</p>
<p class="TX">These functions have a few limitations. As discussed earlier, Windows uses 16-bit code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>. This can be a problem, because the C standard requires an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to be capable of representing any character in the current locale, and a 16-bit code unit can be too small to do so. C technically doesn’t allow you to use multiple objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to represent a single character. Consequently, the standard conversion functions may result in a loss of data. On the other hand, most POSIX implementations use 32-bit code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>, allowing the use of UTF-32. Because a single UTF-32 code unit can represent a whole code point, conversions using standard functions cannot lose or truncate data.</p>
<p class="TX">The C standards committee added the following functions to C11 to address the potential loss of data using standard conversion functions:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc16, c16rtomb </samp>Converts between a sequence of narrow-code units and one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> code units</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc32, c32rtomb </samp>Converts a sequence of narrow-code units to one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> code units</p>
<p class="TX">The first two functions convert between locale-dependent character encodings, represented as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, and UTF-16 data stored in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The second two functions convert between the locale-dependent encodings and UTF-32 data stored in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> encoded data (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The program shown in <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function to convert a UTF-8 input string to a UTF-16-encoded string.</p>
<span id="Lis7-1"/>
<pre><code>#include &lt;locale.h&gt;
<samp class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;uchar.h&gt;</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;stdio.h&gt;</samp>
<span aria-label="148" epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>#include &lt;wchar.h&gt;

static_assert(__STDC_UTF_16__ == 1, "UTF-16 is not supported"); <span aria-label="annotation1" class="codewide_CodeAnnotation">❶</span>

size_t utf8_to_utf16(size_t utf8_size, const char utf8[utf8_size], char16_t *utf16) {
  size_t code, utf8_idx = 0, utf16_idx = 0;
  mbstate_t state = {0};
  while ((code = <span aria-label="annotation2" class="codewide_CodeAnnotation">❷</span> mbrtoc16(&amp;utf16[utf16_idx],
    &amp;utf8[utf8_idx], utf8_size - utf8_idx, &amp;state))) {
    switch(code) {
    case (size_t)-1: // invalid code unit sequence detected
    case (size_t)-2: // code unit sequence missing elements
      return 0;
    case (size_t)-3: // high surrogate from a surrogate pair
      utf16_idx++;
      break;
    default:         // one value written
      utf16_idx++;
      utf8_idx += code;
    }
  }
  return utf16_idx + 1;
}

int main() {
  setlocale(LC_ALL, "es_MX.utf8"); <span aria-label="annotation3" class="codewide_CodeAnnotation">❸</span>
  char utf8[] = u8"I <samp class="SANS_DejaVu_Sans_Book_11">♥</samp> 🌮 s!";
  char16_t utf16[sizeof(utf8)]; // UTF-16 requires less code units than UTF-8
  size_t output_size = utf8_to_utf16(sizeof(utf8), utf8, utf16);
  printf("%s\nConverted to %zu UTF-16 code units: [", utf8, output_size);
  for (size_t x = 0; x &lt; output_size; ++x) {
    printf("%#x ", utf16[x]);
  }
  puts("]");
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Converting a UTF-8 string to a</samp> <samp class="I">char16_t</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">string with the</samp> <samp class="I">mbrtoc16</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setlocale</samp> function <span aria-label="annotation3" class="CodeAnnotation">❸</span> to set the multibyte character encoding to UTF-8 by passing an implementation-defined string. The static assertion <span aria-label="annotation1" class="CodeAnnotation">❶</span> ensures that the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp> has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. (Refer to <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> for more information on static assertions.) As a result, each call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function converts a single code point from a UTF-8 representation to a UTF-16 representation. If the resulting UTF-16 code unit is a high surrogate (from a surrogate pair), the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> object is updated to indicate that the next call to <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> will write out the low surrogate without considering the input string.</p>
<p class="TX">There is no string version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function, so we loop through a UTF-8 input string iteratively, calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function <span aria-label="annotation2" class="CodeAnnotation">❷</span> to convert it to a UTF-16 string. In the case of an encoding error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>, and if the code unit sequence is missing elements, <span aria-label="149" epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>. If either situation occurs, the loop terminates and the conversion ends.</p>
<p class="TX">A return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp> means that the function has output the high surrogate from a surrogate pair and then stored an indicator in the state parameter. The indicator is used the next time the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function is called so it can output the low surrogate from a surrogate pair to form a complete <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> sequence that represents a single code point. All restartable encoding conversion functions in the C standard behave similarly with the state parameter.</p>
<p class="TX">If the function returns anything other than <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf16_idx</samp> index is incremented and the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf8_idx</samp> index is increased by the number of code units read by the function, and the conversion of the string continues.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">libiconv</samp></h4>
<p class="TNI">GNU <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp> is a commonly used cross-platform, open source library for performing string-encoding conversions. It includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv_open</samp> function that allocates a conversion descriptor you can use to convert byte sequences from one character encoding to another. The documentation for this function (<i><a href="https://www.gnu.org/software/libiconv/">https://<wbr/>www<wbr/>.gnu<wbr/>.org<wbr/>/software<wbr/>/libiconv<wbr/>/</a></i>) defines strings you can use to identify a particular <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ISO−8859−1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHIFT_JIS</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">UTF−8</samp> to denote the locale-dependent character encoding.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h4 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Win32 Conversion APIs</samp></h4>
<p class="TNI">The Win32 SDK provides two functions for converting between wide- and narrow-character strings: <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp> function maps string data that’s encoded in an arbitrary character code page to a UTF-16 string. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharTo MultiByte</samp> function maps string data encoded in UTF-16 to an arbitrary character code page. Because UTF-16 data cannot be represented by all code pages, this function can specify a default character to use in place of any UTF-16 character that cannot be converted.</p>
</section>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h2 class="H1" id="sec20"><span id="h1-63"/><samp class="SANS_Futura_Std_Bold_B_11">Strings</samp></h2>
<p class="TNI">C doesn’t support a primitive string type and likely never will. Instead, it implements strings as arrays of characters. C has two types of strings: narrow and wide.</p>
<p class="TX">A <i>narrow string</i> has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. It consists of a contiguous sequence of characters that includes a terminating null character. A pointer to a string references its initial character. The size of a string is the number of bytes allocated to the backing array storage. The length of a string is the number of code units (bytes) preceding the first null character. In <a href="chapter7.xhtml#fig7-1">Figure 7-1</a>, the size of the string is 7, and the length of the string is 5. Elements of the backing array beyond the last element must not be accessed. Elements of the array that haven’t been initialized must not be read.<span aria-label="150" epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img5" id="fig7-1" src="../images/f07001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A sample narrow string</samp></p></figcaption>
</figure>
<p class="TX">A <i>wide string</i> has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>. It’s a contiguous sequence of wide characters that includes a terminating null wide character. A <i>pointer</i> to a wide string references its initial wide character. The <i>length</i> of a wide string is the number of code units preceding the first null wide character. <a href="chapter7.xhtml#fig7-2">Figure 7-2</a> illustrates both the UTF-16BE (big-endian) and UTF-16LE (little-endian) representations of <i>hello</i>. The size of the array is implementation defined. This array is 14 bytes and assumes an implementation that has an 8-bit byte and 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type. The length of this string is 5, as the number of characters has not changed.</p>
<figure class="IMG"><img alt="" class="img1" id="fig7-2" src="../images/f07002.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Sample UTF-16BE and UTF-16LE wide strings</samp></p></figcaption>
</figure>
<p class="TX">Elements of the backing array beyond the last element must not be accessed. Elements of the array that haven’t been initialized must not be read.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h2 class="H1" id="sec21"><span id="h1-64"/><samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp></h2>
<p class="TNI">A <i>character string literal</i> is a string constant represented by a sequence of zero or more multibyte characters enclosed in double quotes—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>. You can use various prefixes to declare string literals of different character types:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> string literal type, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">L"ABC"</samp></li>
<li class="ListBullet">UTF-8 string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">u8"ABC"</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">u"ABC"</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">U"ABC"</samp></li>
</ul>
<p class="TX">The C standard doesn’t mandate that an implementation use ASCII for string literals. However, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix to force a string literal to be UTF-8 encoded, and if all the characters in the literal are ASCII <span aria-label="151" epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>characters, the compiler will produce an ASCII string literal, even if the implementation would normally encode string literals in another encoding (for example, EBCDIC).</p>
<p class="TX">A string literal has a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> array type. Modifying a string literal is undefined behavior and prohibited by the CERT C rule STR30-C, “Do not attempt to modify string literals.” This is because these string literals may be stored in read-only memory, or multiple string literals may share the same memory, resulting in multiple strings being altered if one string is modified.</p>
<p class="TX">String literals often initialize array variables, which you can declare with an explicit bound that matches the number of characters in the string literal. Consider the following declaration:</p>

<pre><code>#define S_INIT "abc"
// <var>--snip--</var>
const char s[4] = S_INIT;</code></pre>
<p class="TX">The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is four, the exact size required to initialize the array to the string literal, including the space for a trailing null byte.</p>
<p class="TX">If you add another character to the string literal used to initialize the array, however, the meaning of the code changes substantially:</p>

<pre><code>#define S_INIT "abc<b>d</b>"
// <var>--snip--</var>
const char s[4] = S_INIT;</code></pre>
<p class="TX">The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> remains four, although the size of the string literal is now five. As a result, the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is initialized to the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcd"</samp> with the trailing null byte omitted. By design, this syntax allows you to initialize a character array and not a string. Therefore, it’s unlikely that your compiler will diagnose this declaration as an error.</p>
<p class="TX">There is some risk that if the string literal changes during maintenance, a string could unintentionally be changed to a character array with no terminating null character, particularly when the string literal is defined apart from the declaration, as in this example. If your intent is to always initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to a string, you should omit the array bound. If you don’t specify the bound of the array, the compiler will allocate sufficient space for the entire string literal, including the terminating null character:</p>

<pre><code>const char s[] = S_INIT;</code></pre>
<p class="TX">This approach simplifies maintenance because the size of the array can always be determined even if the size of the string literal changes.</p>
<p class="TX">The size of arrays declared using this syntax can be determined at compile time by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator:</p>

<pre><code>size_t size = sizeof(s);</code></pre>
<p class="TX"><span aria-label="152" epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/>If, instead, we declared this string as follows</p>

<pre><code>const char *foo = S_INIT;</code></pre>
<p class="Continued">we would need to invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function to get the length</p>

<pre><code>size_t length = strlen(foo) + 1U;</code></pre>
<p class="Continued">which may incur a runtime cost and is different from the size.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">

<h2 class="H1" id="sec22"><span id="h1-65"/><samp class="SANS_Futura_Std_Bold_B_11">String-Handling Functions</samp></h2>
<p class="TNI">Several approaches can be used to manage strings in C, the first of which are the C standard library functions. Narrow-string-handling functions are defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;string.h&gt;</samp> header file and wide-string-handling functions in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;wchar.h&gt;</samp>. These legacy string-handling functions have been associated in recent years with various security vulnerabilities. This is because they don’t check the size of the array (frequently lacking the information needed to perform such checks) and trust you to provide adequately sized character arrays to hold the output. While it’s possible to write safe, robust, and error-free code using these functions, they promote programming styles that can result in buffer overflows if a result is too large for the provided array. These functions aren’t inherently insecure but are prone to misuse and need to be used carefully (or not at all).</p>
<p class="TX">As a result, C11 introduced the normative (but optional) Annex K bounds-checking interfaces. This annex provides alternative library functions intended to promote safer, more secure programming by requiring you to provide the length of output buffers, for example, and validating that these buffers are adequately sized to contain the output from these functions. For instance, Annex K defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat_s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy_s</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat_s</samp> functions as close replacements for the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> functions.</p>
<section aria-labelledby="sec23" epub:type="division">

<h3 class="H2" id="sec23"><span id="h2-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">&lt;string.h&gt; and &lt;wchar.h&gt;</samp></h3>
<p class="TNI">The C standard library includes well-known functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>, and so forth, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> functions that you can use to copy and move strings, respectively. The C standard also provides a wide-character interface that operates on objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. (These function names are like the narrow-string function names, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">wcs</samp>, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> is added in front of the memory function names.) <a href="chapter7.xhtml#tab7-4">Table 7-4</a> gives some examples of narrow- and wide-character string functions. Refer to the C standard (ISO/IEC 9899:2024) or man pages for more information on how to use these functions.</p>
<p class="TT" id="tab7-4"><span aria-label="153" epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-4:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow- and Wide-String Functions</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Narrow (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Wide (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcscpy</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">String copy</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncpy</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncated, zero-filled copy</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wmemcpy</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Copies a specified number of nonoverlapping code units</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wmemmove</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Copies a specified number of (possibly overlapping) code units</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcscat</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Concatenates strings</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncat</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Concatenates strings with truncation</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strcmp</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcscmp</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Compares strings</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strncmp</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncmp</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Compares truncated strings</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strchr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcschr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Locates a character in a string</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strcspn</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcscspn</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Computes the length of a complementary string segment</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsdup</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Copies string into allocated storage</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncated copy into allocated storage</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strpbrk</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcspbrk</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a set of characters in a string</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strrchr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrchr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a character in a string</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strspn</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsspn</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Computes the length of a string segment</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strstr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Finds a substring</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strtok</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcstok</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">String tokenizer (modifies the string being tokenized)</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wmemchr</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Finds a code unit in memory</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Computes string length</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wmemset</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Fills memory with a specified code unit</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">but always performed</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">These string-handling functions are considered efficient because they leave memory management to the caller and can be used with both statically and dynamically allocated storage. In the next couple of sections, I’ll go into more detail on some of the more commonly used functions.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The wcsdup function listed in <a href="chapter7.xhtml#tab7-4">Table 7-4</a> is not a C standard library function but is defined by POSIX.</i></p>
<section aria-labelledby="sec24" epub:type="division">

<h4 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Size and Length</samp></h4>
<p class="TNI">As mentioned earlier in this chapter, strings have both a size (which is the number of bytes allocated to the backing array storage) and a length. You <span aria-label="154" epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/>can determine the size of a statically allocated backing array at compile time by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator:</p>

<pre><code>char str[100] = "Here comes the sun";
size_t str_size = sizeof(str); // str_size is 100</code></pre>
<p class="TX">You can compute the length of a string by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function:</p>

<pre><code>char str[100] = "Here comes the sun";
size_t str_len = strlen(str); // str_len is 18</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function computes the length of a wide string measured by the number of code units preceding the terminating null wide character:</p>

<pre><code>wchar_t str[100] = L"Here comes the sun";
size_t str_len = wcslen(str); // str_len is 18</code></pre>
<p class="TX">The length is a count of something, but what exactly is being counted can be unclear. Here are some of the things that <i>could</i> be counted when taking the length of a string:</p>
<p class="RunInPara1"><b>Bytes</b> Useful when allocating storage.</p>
<p class="RunInPara"><b>Code units</b> Number of individual code units used to represent the string. This length depends on encoding and can also be used to allocate memory.</p>
<p class="RunInPara"><b>Code points</b> Code points (characters) can take up multiple code units. This value is not useful when allocating storage.</p>
<p class="RunInPara2"><b>Extended grapheme cluster</b> A group of one or more Unicode scalar values that approximates a single user-perceived character. Many individual characters, such as <span class="runinpara_accent">é</span>, <samp class="SANS_Source_Han_Serif_TC_Regular_11"><span lang="ko" xml:lang="ko">김</span></samp>, and <samp class="SANS_Source_Han_Serif_SC_Regular_11"><img alt="" class="inline" src="../images/Flag_pg-154.jpg"/></samp>, may be constructed from multiple Unicode scalar values. Unicode’s boundary algorithms combine these code points into extended grapheme clusters.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> functions count code units. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function, this corresponds to the number of bytes. Determining the amount of storage required by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function is more complicated because the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is implementation defined. <a href="chapter7.xhtml#Lis7-2">Listing 7-2</a> contains examples of dynamically allocating storage for both narrow and wide strings.</p>
<span id="Lis7-2"/>
<pre><code>// narrow strings
char *str1 = "Here comes the sun";
char *str2 = malloc(strlen(str1) + 1);

// wide strings
wchar_t *wstr1 = L"Here comes the sun";
wchar_t *wstr2 = malloc((wcslen(wstr1) + 1) * sizeof(*wstr1));</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Dynamically allocating storage for narrow- and wide-string functions</samp></p>
<p class="TX">For narrow strings, we can determine the size of the string by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function to account for the terminating <span aria-label="155" epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/>null character. For wide strings, we can determine the size of the string by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function to account for the terminating null wide character and then multiply the sum by the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">str1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wstr1</samp> are declared as pointers (and not arrays), it’s not possible to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator to obtain their sizes.</p>
<p class="TX">Code point or extended grapheme cluster counts cannot be used for storage allocation because they consist of an unpredictable number of code units. (For an interesting exposition on string length, see “It’s Not Wrong that <samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp><samp class="SANS_AppleColorEmoji_black_Regular_11"><img alt="" class="inline" src="../images/manpalm.jpg"/></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">".length</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>” at <i><a href="https://hsivonen.fi/string-length/">https://<wbr/>hsivonen<wbr/>.fi<wbr/>/string<wbr/>-length<wbr/>/</a></i>.) Extended grapheme clusters are used to determine where to truncate a string, for example, because of a lack of storage. Truncation at extended grapheme cluster boundaries avoids slicing user-perceived characters.</p>
<p class="TX">Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function can be an expensive operation because it needs to traverse the length of the array looking for a null character. The following is a straightforward implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function:</p>

<pre><code>size_t strlen(const char * str) {
  const char *s;
  for (s = str; *s; ++s) {}
  return s - str;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function has no way of knowing the size of the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>. If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> with an invalid string that lacks a null character before the bound, the function will access the array beyond its end, resulting in undefined behavior. Passing a null pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> will also result in undefined behavior (a null-pointer dereference). This implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function also has undefined behavior for strings larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">PTRDIFF_MAX</samp>. You should refrain from creating such objects (in which case this implementation is fine).</p>
</section>
<section aria-labelledby="sec25" epub:type="division">

<h4 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy</samp></h4>
<p class="TNI">Calculating the size of dynamically allocated memory is not always easy. One approach is to store the size when allocating and reuse this value later. The code snippet in <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> function to make a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> by determining the length and then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to accommodate the terminating null character.</p>
<span id="Lis7-3"/>
<pre><code>char str[100] = "Here comes the sun";
size_t str_size = strlen(str) + 1;
char *dest = (char *)malloc(str_size);
if (dest) {
  strcpy(dest, str);
}
else {
  /* handle error */
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Copying a string</samp></p>
<p class="TX"><span aria-label="156" epub:type="pagebreak" id="pg_156" role="doc-pagebreak"/>We can then use the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">str_size</samp> to dynamically allocate the storage for the copy. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> function copies the string from the source string (<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>) to the destination string (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>), including the terminating null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> function returns the address of the beginning of the destination string, which is ignored in this example.</p>
<p class="TX">The following is a simple implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> function:</p>

<pre><code>char *strcpy(char *dest, const char *src) {
  char *save = dest;
  while ((*dest++ = *src++));
  return save;
}</code></pre>
<p class="TX">This code saves a pointer to the destination string in <samp class="SANS_TheSansMonoCd_W5Regular_11">save</samp> (to use as the return value) before copying all the bytes from the source to the destination array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop terminates when the first null byte is copied. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> doesn’t know the length of the source string or the size of the destination array, it assumes that all the function’s arguments have been validated by the caller, allowing the implementation to simply copy each byte from the source string to the destination array without performing any checks.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h4 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Argument Checking</samp></h4>
<p class="TNI">Argument checking can be performed by either the calling function or the called function. Redundant argument testing by both the caller and the callee is a largely discredited style of defensive programming. The usual discipline is to require validation on only one side of each interface.</p>
<p class="TX">The most time-efficient approach is for the caller to perform the check, because the caller should have a better understanding of the program state. In <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a>, we can see that the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> are valid without introducing further redundant tests: the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> references a statically allocated array that was properly initialized in the declaration, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> parameter is a valid non–null pointer referencing dynamically allocated storage of sufficient size to hold a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>, including the null character. Therefore, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> is safe, and the copy can be performed in a time-efficient manner. This approach to argument checking is commonly used by C standard library functions because it adheres to the “spirit of C,” in that it’s optimally efficient and trusts the programmer (to pass valid arguments).</p>
<p class="TX">The safer, more secure approach is for the callee to check the arguments. This approach is less error-prone because the library function implementer validates the arguments, so we no longer need to trust the programmer to pass valid ones. The function implementer is usually in a better position to understand which arguments need to be validated. If the input validation code is defective, the repair needs to be made in only one place. All the code to validate the arguments is in one place, so this approach can be more space efficient. However, because these tests run even when unnecessary, they can also be less time efficient. Frequently, the <span aria-label="157" epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>caller of these functions will place checks before suspect calls that may or may not already perform similar checks. This approach would also impose additional error handling on callees that don’t currently return error indications but would presumably need to if they validated arguments. For strings, the called function can’t always determine whether the argument is a valid null-terminated string or points to sufficient space to make a copy.</p>
<p class="TX">The lesson here is don’t assume that the C standard library functions validate arguments unless the standard explicitly requires them to.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">

<h4 class="H3" id="sec27"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">memcpy</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> characters from the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> into the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>:</p>

<pre><code>void *memcpy(void * restrict dest, const void * restrict src, size_t size);</code></pre>
<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> function instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> to copy strings when the size of the destination array is larger than or equal to the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, the source array contains a null character before the bound, and the string length is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">size - 1</samp> (so that the resulting string will be properly null terminated). The best advice is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> when copying a string and <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> when copying only raw, untyped memory. Also remember that the assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) operator can efficiently copy objects in many cases.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">

<h4 class="H3" id="sec28"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">memccpy</samp></h4>
<p class="TNI">Most of the C standard library’s string-handling functions return a pointer to the beginning of the string passed as an argument so that you can nest calls to string functions. For example, the following sequence of nested function calls constructs a full name using a Western naming order by copying, then concatenating, the constituent parts:</p>

<pre><code>strcat(strcat(strcat(strcat(strcpy(name, first), " "), middle), " "), last);</code></pre>
<p class="TX">However, piecing together the array <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> from its constituent substrings requires <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> to be scanned many more times than necessary; it would have been more useful for the string-handling functions to return pointers to the <i>end</i> of the modified string to eliminate this need for rescanning. C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function with a better interface design. POSIX environments should already provide this, but you may need to enable its declaration as follows:</p>

<pre><code>#define _XOPEN_SOURCE 700
#include &lt;string.h&gt;</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function has the following signature:</p>

<pre><code>void *memccpy(void * restrict s1, const void * restrict s2, int c, size_t n);</code></pre>
<p class="TX"><span aria-label="158" epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/>Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> function, <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> scans the source sequence for the first occurrence of a character specified by one of its arguments. The character can have any value, including zero. It copies (at most) the specified number of characters from the source to the destination, without writing beyond the end of the destination buffer. Finally, it returns a pointer just past the copy of the specified character if it exists.</p>
<p class="TX"><a href="chapter7.xhtml#Lis7-4">Listing 7-4</a> reimplements the preceding sequence of nested string-handling function calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function. This implementation is more performant and secure.</p>
<span id="Lis7-4"/>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

constexpr size_t name_size = 18U;

char *vstrcat(char *buff, size_t buff_length, ...) {
  char *ret = buff;
  va_list list;
  va_start(list, buff_length);
  const char *part = nullptr;
  size_t offset = 0;
  while ((part = va_arg(list, const char *))) {
  <span aria-label="annotation1" class="code_CodeAnnotation">❶</span> buff = (char *)memccpy(buff, part, '\0', buff_length - offset);
    if (buff == nullptr) {
      ret[0] = '\0';
      break;
    }
  <span aria-label="annotation2" class="code_CodeAnnotation">❷</span> offset = --buff - ret;
  }
  va_end(list);
  return ret;
}

int main() {
  char name[name_size] = "";
  char first[] = "Robert";
  char middle[] = "C.";
  char last[] = "Seacord";

  puts(vstrcat(
    name, sizeof(name), first, " ",
    middle, " ", last, nullptr
  ));
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: String concatenation with</samp> <samp class="I">memccpy</samp></p>
<p class="TX"><a href="chapter7.xhtml#Lis7-4">Listing 7-4</a> defines the variadic function <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp> that accepts a buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>) and buffer length (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>) as fixed arguments and a variable list of string arguments. A null pointer is used as the sentinel value to indicate the end of the variable-length argument list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function is <span aria-label="159" epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>invoked <span aria-label="annotation1" class="CodeAnnotation">❶</span> to concatenate each string to the buffer. As previously noted, <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> returns a pointer just past the copy of the specified character, which in this case is the null termination character <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>.</p>
<p class="TX">Instead of nesting calls, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> for each string argument passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp> and store the return value in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>. This allows you to concatenate directly to the end of the string instead of having to find the null termination character each time, making this solution more performant.</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> is a null pointer, we couldn’t copy the entire string. Instead of returning a partial name in this case, we return an empty string. This empty string can be printed or treated as an error condition.</p>
<p class="TX">Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function returns a pointer to the character <i>after</i> the copy of the null byte, we decrement <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> using the prefix decrement operator and then subtract the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> to obtain a new <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The size argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function (which it uses to prevent buffer overflow) is calculated by subtracting <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>. This is a more secure approach than nested function calls, which are always suspect because there is no way to check for an error.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">

<h4 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">memset, memset_s, and memset_explicit</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(unsigned char)c</samp> into each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:</p>

<pre><code>void *memset(void *s, int c, size_t n);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function is frequently used to clear memory—for example, to initialize memory allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to zero. However, in the following example, it’s used incorrectly:</p>

<pre><code>void check_password() {
  char pwd[64];
  if (get_password(pwd, sizeof(pwd))) {
    /* check password */
  }
  memset(pwd, 0, sizeof(pwd));
}</code></pre>
<p class="TX">One problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> function is that it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function to clear an automatic variable after it has been read for the last time. This is being done for security reasons to make sure that the sensitive information stored here is inaccessible. However, the compiler doesn’t know that and may perform a “dead store” optimization. This is when a compiler notices a write is not followed by a read, and just like this book, there is no sense in writing it if no one is going to read it. Consequently, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> function is likely to be removed by the compiler.</p>
<p class="TX">This problem was meant to be addressed in C11 by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> function from Annex K bounds-checking interfaces (discussed in the next section). Unfortunately, this function has not been implemented by any compiler mentioned in this book.</p>
<p class="TX"><span aria-label="160" epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>To solve this problem again, C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> function for making sensitive information inaccessible. In contrast to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function, the intention is that the memory store is always performed (that is, never elided), regardless of optimizations.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">

<h4 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is a flawed input function that accepts input without providing any way to specify the size of the destination array. For that reason, it cannot prevent buffer overflows. As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function was deprecated in C99 and eliminated from C11. However, it has been around for many years, and most libraries still provide an implementation for backward compatibility, so you may see it in the wild. You should <i>never</i> use this function, and you should replace any use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function you find in any code you’re maintaining.</p>
<p class="TX">Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is so bad, we’ll spend some time examining why it’s so awful. The function shown in <a href="chapter7.xhtml#Lis7-5">Listing 7-5</a> prompts the user to enter either <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> to indicate whether they’d like to continue.</p>
<span id="Lis7-5"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctypes.h&gt;

void get_y_or_n(void) {
  char response[8];
  puts("Continue? [y] n: ");
  gets(response);
  if (tolower(response[0]) == 'n') exit(EXIT_SUCCESS);
  return;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Misuse of the obsolete</samp> <samp class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">This function has undefined behavior if more than eight characters are entered at the prompt. This undefined behavior occurs because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function has no way of knowing how large the destination array is and will write beyond the end of the array object.</p>
<p class="TX"><a href="chapter7.xhtml#Lis7-6">Listing 7-6</a> shows a simplified implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function. As you can see, the caller of this function has no way to limit the number of characters read.</p>
<span id="Lis7-6"/>
<pre><code>char *gets(char *dest) {
  int c;
  char *p = dest;
  while ((c = getchar()) != EOF &amp;&amp; c != '\n') {
    *p++ = c;
  }
  *p = '\0';
  return dest;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: A</samp> <samp class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function implementation</samp></p>
<p class="TX"><span aria-label="161" epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function iterates reading a character at a time. The loop terminates if either an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> or newline <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp> character is read. Otherwise, the function will continue to write to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> array without concern for the boundaries of the object.</p>
<p class="TX"><a href="chapter7.xhtml#Lis7-7">Listing 7-7</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_y_or_n</samp> function from <a href="chapter7.xhtml#Lis7-5">Listing 7-5</a> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function inlined.</p>
<span id="Lis7-7"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void get_y_or_n(void) {
  char response[8];
  puts("Continue? [y] n: ");
  int c;
  char *p = response;
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> while ((c = getchar()) != EOF &amp;&amp; c != '\n') {
    *p++ = c;
  }
  *p = '\0';
  if (response[0] == 'n')
    exit(0);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: A poorly written</samp> <samp class="I">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>
<p class="TX">The size of the destination array is now available, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop <span aria-label="annotation1" class="CodeAnnotation">❶</span> doesn’t use this information. You should ensure that reaching the bound of the array is a loop termination condition when reading or writing to an array in a loop such as this one.</p>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">

<h3 class="H2" id="sec31"><span id="h2-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Annex K Bounds-Checking Interfaces</samp></h3>
<p class="TNI">C11 introduced the Annex K bounds-checking interfaces with alternative functions that verify that output buffers are large enough for the intended result and return a failure indicator if they aren’t. These functions are designed to prevent writing data past the end of an array and to null-terminate all string results. These string-handling functions leave memory management to the caller, and memory can be statically or dynamically allocated before the functions are invoked.</p>
<p class="TX">Microsoft created the C11 Annex K functions to help retrofit its legacy code base in response to numerous, well-publicized security incidents in the 1990s. These functions were then proposed to the C standards committee for standardization, published as ISO/IEC TR 24731-1 (ISO/IEC TR 24731-1:2007) and then later incorporated into C11 as an optional annex. Despite the improved usability and security provided by these functions, they aren’t yet widely implemented at the time of writing.</p>
<section aria-labelledby="sec32" epub:type="division">

<h4 class="H3" id="sec32"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets_s</samp></h4>
<p class="TNI">The Annex K bounds-checking interface has a <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function we can use to eliminate the undefined behavior caused by the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> in <a href="chapter7.xhtml#Lis7-5">Listing 7-5</a>, as shown in <a href="chapter7.xhtml#Lis7-8">Listing 7-8</a>.</p>
<span id="Lis7-8"/>
<pre><code><span aria-label="162" epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>#define __STDC_WANT_LIB_EXT1__ 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

void get_y_or_n(void) {
  char response[8];
  puts("Continue? [y] n: ");
  gets_s(response, sizeof(response));
  if (tolower(response[0]) == 'n') {
    exit(EXIT_SUCCESS);
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Use of the</samp> <samp class="I">gets_s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The two functions are similar, except that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function checks the array bounds. The default behavior when the maximum number of characters input is exceeded is implementation defined, but typically the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function is called. You can change this behavior via the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function, which I’ll explain further in “<span class="Xref">Runtime Constraints</span>” on <span class="Xref"><a href="#pg_163">page 163</a></span>.</p>
<p class="TX">You need to define <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_WANT_LIB_EXT1__</samp> as a macro that expands to the integer constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> before including the header files that define the bounds-checking interfaces to allow them to be used in your program. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function takes a size argument. Consequently, the revised function calculates the size of the destination array by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator and passes this value as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function. The implementation-defined behavior is the result of the runtime-constraint violation.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">

<h4 class="H3" id="sec33"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy_s</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function is a close replacement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> function defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;string.h&gt;</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function copies characters from a source string to a destination character array up to and including the terminating null character. Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> signature:</p>

<pre><code>errno_t strcpy_s(
  char * restrict s1, rsize_t s1max, const char * restrict s2
);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function has an extra argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp> that specifies the maximum length of the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp> type is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type except that functions that accept an argument of this type test to make sure that the value is not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function succeeds only when it can fully copy the source string to the destination without overflowing the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function verifies that the following runtime constraints aren’t violated:</p>
<ul class="ul">
<li class="ListBullet">Neither <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp> are null pointers.</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.</li>
<li class="ListBullet"><span aria-label="163" epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> does not equal zero.</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">strnlen_s(s2, s1max)</samp>.</li>
<li class="ListBullet">Copying does not take place between overlapping objects.</li>
</ul>
<p class="TX">To perform the string copy in a single pass, a <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function implementation retrieves a character (or characters) from the source string and copies it to the destination array until it has copied the entire string or the destination array is full. If it can’t copy the entire string and <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not zero, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function sets the first byte of the destination array to the null character, creating an empty string.</p>
</section>
<section aria-labelledby="sec34" epub:type="division">

<h4 class="H3" id="sec34"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Runtime Constraints</samp></h4>
<p class="TNI"><i>Runtime constraints</i> are violations of a function’s runtime requirements that the function will detect and diagnose by a call to a handler. If this handler returns, the functions will return a failure indicator to the caller.</p>
<p class="TX">The bounds-checking interfaces enforce runtime constraints by invoking a runtime-constraint handler, which may simply return. Alternatively, the runtime-constraint handler might print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> and/or abort the program. You can control which handler function is called via the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function and make the handler simply return as follows:</p>

<pre><code>int main(void) {
  constraint_handler_t oconstraint =
    set_constraint_handler_s(ignore_handler_s);
  get_y_or_n();
}</code></pre>
<p class="TX">If the handler returns, the function that identified the runtime-constraint violation and invoked the handler indicates a failure to its caller by using its return value.</p>
<p class="TX">The bounds-checking interface functions typically check the conditions either immediately upon entry or as they perform their tasks and gather sufficient information to determine whether a runtime constraint has been violated. The runtime constraints of the bounds-checking interfaces are conditions that would otherwise be undefined behavior for C standard library functions.</p>
<p class="TX">Implementations have a default constraint handler that they invoke if no calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function have been made. The default handler’s behavior may cause the program to exit or abort, but implementations are encouraged to provide reasonable behavior by default. This allows, for example, compilers customarily used to implement safety-critical systems to not abort by default. You must check the return value of calls to functions that can return and not simply assume their results are valid. Implementation-defined behavior can be eliminated by invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function before invoking any bounds-checking interfaces or using any mechanism that invokes a runtime-constraint handler.</p>
<p class="TX"><span aria-label="164" epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>Annex K provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions, which represent two common strategies for handling errors. The C implementation’s default handler need not be either of these handlers.</p>
</section>
</section>
<section aria-labelledby="sec35" epub:type="division">

<h3 class="H2" id="sec35"><span id="h2-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">POSIX</samp></h3>
<p class="TNI">POSIX also defines several string-handling functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> (IEEE Std 1003.1:2018), that provide another set of string-related APIs for POSIX-compliant platforms such as GNU/Linux and Unix (IEEE Std 1003.1:2018). Both functions were adopted into the C standard library by C23.</p>
<p class="TX">These replacement functions use dynamically allocated memory to ensure that buffer overflows don’t occur, and they implement a <i>callee allocates, caller frees</i> model. Each function ensures that enough memory is available (except when a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> fails). The <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function, for example, returns a pointer to a new string that contains a duplicate of the argument. The returned pointer should be passed to the C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function to reclaim the storage when it’s no longer needed.</p>
<p class="TX"><a href="chapter7.xhtml#Lis7-9">Listing 7-9</a> contains a code snippet that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function to make a copy of the string returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function.</p>
<span id="Lis7-9"/>
<pre><code>const char *temp = getenv("TMP");
if (temp != nullptr) {
  char *tmpvar = strdup(temp);
  if (tmpvar != nullptr) {
    printf("TMP = %s.\n", tmpvar);
    free(tmpvar);
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Copying a string using the</samp> <samp class="I">strdup</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function searches an environment list, provided by the host environment, for a string that matches the string referenced by a specified name (<samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp> in this example). Strings in this environment list are referred to as <i>environment variables</i> and provide an additional mechanism for communicating strings to a process. These strings don’t have a well-defined encoding but typically match the system encoding used for command line arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>.</p>
<p class="TX">The returned string (the value of the variable) may be overwritten by a subsequent call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function, so it’s a good idea to retrieve any environmental variable you need before creating any threads to eliminate the possibility of a race condition. If later use is anticipated, you should copy the string so the copy can be safely referenced as needed, as illustrated by the idiomatic example shown in <a href="chapter7.xhtml#Lis7-9">Listing 7-9</a>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> function is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> copies, at most, <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> bytes into the newly allocated memory (while <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> copies the entire string) and ensures that the newly created string is always properly terminated.</p>
<p class="TX"><span aria-label="165" epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>These POSIX functions can help prevent buffer overflows by automatically allocating storage for the resulting strings, but this requires introducing additional calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> when this storage is no longer needed. This means matching a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> to each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>, for example, which can be confusing to programmers who are more familiar with the behavior of the string functions defined by <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;string.h&gt;</samp>.</p>
</section>
<section aria-labelledby="sec36" epub:type="division">

<h3 class="H2" id="sec36"><span id="h2-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft</samp></h3>
<p class="TNI">Visual C++ provides all the string-handling functions defined by the C standard library up to C99 but doesn’t implement the full POSIX specification. However, sometimes the Microsoft implementation of these APIs differs from the requirements of a given standard or has a function name that conflicts with an identifier reservation in another standard. In these circumstances, Microsoft will often prefix the function name with an underscore. For instance, the POSIX function <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> isn’t available on Windows, but the function <samp class="SANS_TheSansMonoCd_W5Regular_11">_strdup</samp> is available and behaves the same way.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>For more information on Microsoft’s POSIX support, see</i> <span class="note_LinkURL"><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility">https://<wbr/>docs<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/cpp<wbr/>/c<wbr/>-runtime<wbr/>-library<wbr/>/compatibility</a></span><i>.</i></p>
<p class="TX">Visual C++ also supports many of the safe string-handling functions from Annex K and will diagnose the use of an unsafe variant unless you define <samp class="SANS_TheSansMonoCd_W5Regular_11">_CRT_SECURE_NO_WARNINGS</samp> prior to including the header file that declares the function. Unfortunately, Visual C++ does not conform to Annex K of the C standard, because Microsoft chose not to update its implementation based on changes to the APIs that occurred during the standardization process. For example, Visual C++ doesn’t provide the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function but instead retains an older function with similar behavior but an incompatible signature:</p>

<pre><code>_invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler)</code></pre>
<p class="TX">Microsoft also doesn’t define the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions, the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> function (which was not defined by ISO/IEC TR 24731-1), or the <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp> macro. Visual C++ also doesn’t treat overlapping source and destination sequences as runtime-constraint violations and instead has undefined behavior in such cases. “Bounds-Checking Interfaces: Field Experience and Future Directions” (Seacord 2019) provides additional information on all aspects of the bounds-checked interfaces, including Microsoft’s implementation.</p>
</section>
</section>
<section aria-labelledby="sec37" epub:type="division">

<h2 class="H1" id="sec37"><span id="h1-66"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about character encodings, such as ASCII and Unicode. You also learned about the various data types used to represent characters in C language programs, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>, and so forth. <span aria-label="166" epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>We then covered character conversion libraries, including C standard library functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp>, and Windows APIs.</p>
<p class="TX">In addition to characters, you also learned about strings and the legacy functions and bounds-checked interfaces defined in the C standard library for handling strings, as well as some POSIX- and Microsoft-specific functions.</p>
<p class="TX">Manipulating character and string data is a common programming task in C as well as a frequent source of errors. We outlined various approaches to handling these data types; you should determine which approach is best suited to your application and apply that approach consistently.</p>
<p class="TX">In the next chapter, you’ll learn about I/O, which, among other things, can be used to read and write characters and strings.</p>
</section>
</section>
</body></html>