- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REACT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REACT</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Developers can use the React library to create a full-stack application’s user
    interface. React is built upon the Node.js ecosystem, and as one of the most commonly
    used web frameworks, it currently forms the basis of more than percent of the
    most visited websites.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以使用 React 库来创建全栈应用程序的用户界面。React 基于 Node.js 生态系统构建，作为最常用的 Web 框架之一，目前它是超过百分之多少最受欢迎网站的基础。
- en: To work effectively with React, you must understand the syntax used to define
    the appearance of user interface elements and then combine these into React components
    that can dynamically update. This chapter covers everything you need to know to
    begin developing full-stack applications using this library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用 React，必须理解用于定义用户界面元素外观的语法，并将这些语法组合成可以动态更新的 React 组件。本章涵盖了开始使用此库开发全栈应用程序所需了解的所有内容。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Role of React</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">React 的作用</samp>
- en: Modern frontend architectures split an application’s user interface into small,
    self-contained, and reusable items. Some of these, such as headers, navigations,
    and logos, might appear only once per page, while others are repeated elements
    that form the page’s contents, such as headlines, buttons, and teasers. [Figure
    4-1](chapter4.xhtml#fig4-1) shows some of these items. React’s syntax embraces
    this pattern; the library focuses on building these independent components and,
    in doing so, helps us develop our applications more efficiently.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现代前端架构将应用程序的用户界面拆分成小的、独立的和可重用的项目。其中一些，如标题、导航和徽标，可能每个页面只出现一次，而其他一些则是重复出现的元素，形成页面的内容，如标题、按钮和广告。
    [图 4-1](chapter4.xhtml#fig4-1) 显示了其中的一些项目。React 的语法遵循这一模式；该库专注于构建这些独立的组件，并通过这样做，帮助我们更高效地开发应用程序。
- en: '![](../images/Figure4-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-1: User interface
    components</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 4-1：用户界面组件</samp>
- en: React uses a *declarative* programming paradigm, through which you create a
    user interface by describing the desired results instead of explicitly listing
    all the steps necessary to create it, as is done in *imperative* programming.
    A classic example of the declarative paradigm is HTML. Using HTML, you describe
    a web page’s elements, and the browser then renders the page. By contrast, you
    could use JavaScript to write an imperative program that creates each HTML element.
    In doing so, you would explicitly list the steps to build the website.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用*声明式*编程范式，通过这种方式，你可以通过描述期望的结果来创建用户界面，而不是像在*命令式*编程中那样明确列出创建它所需的所有步骤。声明式范式的经典例子是
    HTML。使用 HTML，你描述网页的元素，然后浏览器渲染页面。相比之下，你可以使用 JavaScript 编写一个命令式程序来创建每个 HTML 元素，在此过程中，你需要明确列出构建网站的步骤。
- en: 'In addition, these user interface components are *reactive*. This means two
    things: one, that they handle their own isolated states, and two, that each component
    updates the page’s HTML as soon as its state changes. Changes to the React code
    instantly affect a browser’s *document object model (DOM)*, which represents a
    website as a tree in which each HTML element is a node. The DOM also provides
    an API for each node and for the website in general, enabling scripts to modify
    a website or a specific node.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些用户界面组件是*响应式*的。这意味着两件事：一是它们处理自己独立的状态，二是每个组件在其状态变化后立即更新页面的 HTML。对 React 代码的修改会立刻影响浏览器的*文档对象模型（DOM）*，DOM
    将网站表示为一棵树，每个 HTML 元素都是一个节点。DOM 还为每个节点和网站本身提供 API，使得脚本能够修改网站或特定的节点。
- en: DOM operations, such as re-rendering a component, are expensive. To update the
    DOM, React uses a *virtual DOM*, which is an in-memory clone of the actual browser
    DOM that it later syncs with the real thing. This virtual DOM allows for incremental
    updates that reduce the number of costly operations on the browser. The virtual
    DOM is a crucial principle of React. React calculates the difference between the
    virtual DOM and the real DOM with every call to one of its render functions and
    then decides what to update. Usually, React performs batch updates to lower the
    performance impact further. This process of reconciliation lets React deliver
    fast and responsive user interfaces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DOM操作，如重新渲染一个组件，是比较昂贵的。为了更新DOM，React使用*虚拟DOM*，这是实际浏览器DOM的内存中克隆版本，稍后会与真实DOM进行同步。这个虚拟DOM允许增量更新，从而减少浏览器中耗费资源的操作次数。虚拟DOM是React的一个关键原则。React通过每次调用其渲染函数来计算虚拟DOM与真实DOM之间的差异，然后决定更新什么内容。通常，React会执行批量更新，以进一步降低性能影响。这个协调过程使React能够提供快速且响应迅速的用户界面。
- en: 'Although React is primarily a user interface library, developers can also use
    it to build single-page applications that don’t require middleware or a backend.
    These apps are nothing more than a view layer rendered in the browser. To some
    extent, they can be dynamic: for example, we can change the page’s language, open
    an image gallery, or toggle an element’s visibility. However, all of this occurs
    in the browser, with additional React modules, rather than on the server.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React主要是一个用户界面库，但开发者也可以用它来构建不需要中间件或后端的单页面应用。这些应用无非是一个在浏览器中渲染的视图层。它们在某种程度上是动态的：例如，我们可以更改页面的语言、打开图片画廊或切换某个元素的可见性。然而，所有这些都发生在浏览器中，通过额外的React模块，而不是在服务器上。
- en: We can also perform more advanced functionality, like updating the browser’s
    location to simulate the existence of distinct pages, purely in the browser, with
    React’s Router module. This module lets us define routes, similar to the ones
    we defined in our Express.js server, on the frontend. As soon as a user clicks
    an internal link, the routing component updates the view and changes the browser’s
    location. This makes it seem as though they’ve loaded another HTML page. In reality,
    we’ve just changed the current page’s contents. In doing so, we avoided another
    set of server requests, so the simulated page loads much more quickly. Also, because
    our JavaScript code controls the transition between pages, we can add effects
    and animations to these transitions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行更高级的功能，比如通过React的Router模块，仅在浏览器内更新浏览器的地址栏位置，以模拟不同页面的存在。这个模块允许我们在前端定义路由，类似于我们在Express.js服务器中定义的路由。一旦用户点击一个内部链接，路由组件就会更新视图并更改浏览器的地址。这让用户感觉他们加载了另一个HTML页面。实际上，我们只是更改了当前页面的内容。通过这样做，我们避免了另一轮服务器请求，因此模拟的页面加载得更快。此外，因为我们的JavaScript代码控制了页面之间的过渡，我们可以为这些过渡添加效果和动画。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up React</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置React</samp>
- en: Unlike, say, the basic Express.js server you created in [Exercise 1](chapter1.xhtml#Exe1)
    on page 13, which uses standard JavaScript and can run directly with Node.js,
    React relies on an advanced setup with a complete build toolchain. For example,
    it uses a custom JavaScript Syntax Extension (JSX) to describe HTML elements and
    TypeScript for static typing, both of which require a transpiler to convert the
    code to JavaScript. Therefore, the manual process for setting up React is quite
    complex.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在第13页的[练习1](chapter1.xhtml#Exe1)中创建的基本Express.js服务器不同，后者使用标准的JavaScript并可以直接在Node.js上运行，React依赖于一个完整的构建工具链进行高级设置。例如，它使用自定义的JavaScript语法扩展（JSX）来描述HTML元素，并使用TypeScript进行静态类型检查，这两者都需要一个转译器将代码转换为JavaScript。因此，React的手动设置过程相当复杂。
- en: Thus, we generally rely on other tools. In the case of a single-page application,
    we use a code generator, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>,
    to scaffold it. During this scaffolding process, <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    generates the boilerplate code for a new React application, as well as the build
    chain and folder structure for the project. It also provides a consistent project
    layout that helps us easily understand other React projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通常依赖其他工具。在单页应用的情况下，我们使用代码生成器，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    来搭建项目。在此搭建过程中，<samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    为新的 React 应用程序生成基础代码，以及项目的构建链和文件夹结构。它还提供了一个一致的项目布局，帮助我们轻松理解其他 React 项目。
- en: To run the examples in this chapter, one option is to scaffold a simple TypeScript
    React app with <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    by following the steps at [*https://<wbr>create<wbr>-react<wbr>-app<wbr>.dev<wbr>/docs<wbr>/getting<wbr>-started<wbr>/*](https://create-react-app.dev/docs/getting-started/).
    If you don’t want to create a dedicated project, you can instead run code using
    React with a TypeScript template in an online playground, such as [*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io)
    or [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com). The playgrounds
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> follow
    the same file structure. In both cases, you should save your code to the default
    *App.tsx* file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例，一种方法是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    创建一个简单的 TypeScript React 应用程序，按照 [*https://<wbr>create<wbr>-react<wbr>-app<wbr>.dev<wbr>/docs<wbr>/getting<wbr>-started<wbr>/*](https://create-react-app.dev/docs/getting-started/)
    上的步骤操作。如果你不想创建一个专门的项目，可以选择使用 React 和 TypeScript 模板，在在线游乐场中运行代码，例如 [*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io)
    或 [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com)。这些游乐场和 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    使用相同的文件结构。在这两种情况下，你应该将代码保存到默认的 *App.tsx* 文件中。
- en: For more complex apps, we’d use a complete web application framework such as
    Next.js, which provides the necessary setup out of the box. Covered in [Chapter
    5](chapter5.xhtml), Next.js is the most popular framework for full-stack web applications
    that use React. Internally, Next.js employs a variation of <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    for scaffolding. We’ll rely on it in future chapters to work with React.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的应用程序，我们将使用完整的 web 应用框架，例如 Next.js，它提供了开箱即用的必要设置。如 [第五章](chapter5.xhtml)
    中所述，Next.js 是最流行的用于 React 的全栈 web 应用框架。内部，Next.js 使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    的变种来进行搭建。我们将在后续章节中依赖它来处理 React。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The JavaScript Syntax Extension</samp>
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">JavaScript 语法扩展</samp>
- en: React uses JSX to define the appearance of user interface components. JSX is
    an extension of JavaScript that a transpiler must convert before the browser renders
    it to the DOM. While it has HTML-like syntax, it is more than a simple templating
    language. Instead, it allows us to use any JavaScript feature to describe React
    elements. For example, we can use JSX syntax inside conditional statements, assign
    it to variables, and return it from functions. The compiler will then embed any
    variable or valid JavaScript expression wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    into the HTML.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用 JSX 来定义用户界面组件的外观。JSX 是 JavaScript 的一种扩展，浏览器渲染到 DOM 之前，必须通过转译器进行转换。虽然它的语法类似于
    HTML，但它不仅仅是一个简单的模板语言。相反，它允许我们使用任何 JavaScript 特性来描述 React 元素。例如，我们可以在条件语句中使用 JSX
    语法，将其赋值给变量，并从函数中返回。编译器会将任何包裹在大括号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    中的变量或有效 JavaScript 表达式嵌入到 HTML 中。
- en: This logic allows us to, for instance, use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to loop over an array, check each item for a certain condition, pass the item
    to another function, and create a set of JSX elements based on the function’s
    return value, directly inside a page’s template. While this may sound abstract,
    we’ll use this pattern extensively when we create React components in the Food
    Finder application you’ll build in [Part II](part2.xhtml).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑使我们能够，例如，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    遍历数组，检查每个项是否满足某个条件，将该项传递给另一个函数，并根据该函数的返回值直接在页面模板中创建一组 JSX 元素。虽然这听起来有些抽象，但当我们在
    [第二部分](part2.xhtml) 中构建 Food Finder 应用程序时，将广泛使用这种模式来创建 React 组件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example JSX Expression</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个 JSX 表达式示例</samp>
- en: JSX expressions, like those in [Listing 4-1](chapter4.xhtml#Lis4-1), are the
    most essential part of the React user interfaces. This JavaScript code defines
    a JSX function expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">getElement</samp>,
    that takes one string as a parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 表达式，如 [列表 4-1](chapter4.xhtml#Lis4-1) 中的表达式，是 React 用户界面中最基本的部分。此 JavaScript
    代码定义了一个 JSX 函数表达式，<samp class="SANS_TheSansMonoCd_W5Regular_11">getElement</samp>，它接受一个字符串作为参数并返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: A minimal example of a JSX expression'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：一个简单的 JSX 表达式示例
- en: The entry point for each React application is the <samp class="SANS_TheSansMonoCd_W5Regular_11">App</samp>
    function. Like the *index.js* file of our Express.js server, this function is
    executed when the application starts. Here, we usually set up the global elements,
    such as stylesheets and the overall page layout.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 React 应用程序的入口点是 <samp class="SANS_TheSansMonoCd_W5Regular_11">App</samp>
    函数。就像我们的 Express.js 服务器的 *index.js* 文件一样，这个函数在应用程序启动时执行。在这里，我们通常会设置全局元素，如样式表和整体页面布局。
- en: React renders the function’s return value to the browser. In [Listing 4-1](chapter4.xhtml#Lis4-1),
    we immediately return an element. As the smallest building blocks of React user
    interfaces, *elements* describe what you’ll see on the screen, just as HTML elements
    do. Examples of elements include custom buttons, headlines, and images.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React 将函数的返回值渲染到浏览器中。在 [列表 4-1](chapter4.xhtml#Lis4-1) 中，我们立即返回一个元素。作为 React
    用户界面的最小构建块，*元素* 描述了你将在屏幕上看到的内容，正如 HTML 元素所做的那样。元素的例子包括自定义按钮、标题和图片。
- en: After importing the React package, we create the JSX element and store it in
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">element</samp> constant. At first
    glance, you might wonder why it isn’t wrapped in quotes, as it contains what appears
    to be a regular HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> element
    and looks like a string. The answer is that it isn’t a string but a JSX element
    from which the library creates HTML elements programmatically. As a result, the
    code will display a message about the weather to the page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 React 包之后，我们创建 JSX 元素并将其存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">element</samp>
    常量中。乍一看，你可能会想它为什么没有用引号括起来，因为它包含了一个看起来像普通 HTML 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    元素，并且看起来像一个字符串。答案是，它不是一个字符串，而是一个 JSX 元素，React 库通过它来程序化地创建 HTML 元素。因此，代码会在页面上显示一条关于天气的消息。
- en: As soon as we call the JSX expression, the React library transpiles it into
    a regular JavaScript function call and creates an HTML string from the JSX element
    displayed in the browser. In [Chapter 3](chapter3.xhtml), you learned that all
    valid JavaScript is also valid TypeScript. Hence, we can use JSX with TypeScript
    as well. JSX files use a .*jsx* (JavaScript) or *.tsx* (TypeScript) extension.
    Paste this code into the *App.tsx* file of the project you created, and the browser
    should render an <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML
    element with the text <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather
    is sunny</samp> either in the preview pane of the online playground or in your
    browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用 JSX 表达式，React 库会将其转译成一个常规的 JavaScript 函数调用，并从浏览器中显示的 JSX 元素创建一个 HTML
    字符串。在 [第 3 章](chapter3.xhtml) 中，你学到了所有有效的 JavaScript 也是有效的 TypeScript。因此，我们也可以将
    JSX 与 TypeScript 一起使用。JSX 文件使用 .*jsx*（JavaScript）或 *.tsx*（TypeScript）扩展名。将这段代码粘贴到你创建的项目的
    *App.tsx* 文件中，浏览器应该会在在线开发环境的预览窗格中或在浏览器中渲染一个带有文本 <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    weather is sunny</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    HTML 元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ReactDOM Package</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ReactDOM 包</samp>
- en: One easy way to work with elements is to use the ReactDOM package, which contains
    APIs for working with the DOM. Note that the elements you create aren’t browser
    DOM elements. Instead, they’re plain JavaScript objects that will be rendered,
    using React’s <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function,
    to the virtual DOM’s root element and then attached to the browser DOM.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与元素打交道的一种简单方法是使用 ReactDOM 包，它包含了用于处理 DOM 的 API。请注意，你创建的元素不是浏览器的 DOM 元素。相反，它们是普通的
    JavaScript 对象，使用 React 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp>
    函数渲染到虚拟 DOM 的根元素，并随后附加到浏览器的 DOM 上。
- en: 'React elements are *immutable*: once created, they cannot be changed. If you
    do alter any part of the element, React will create a new element and re-render
    the virtual DOM, then compare the virtual DOM with the browser DOM to decide whether
    the browser DOM needs an update. We’ll use JSX abstractions for these tasks; nonetheless,
    it’s good to understand how React works under the hood. If you want to dig deeper,
    consult the official documentation at [*https://<wbr>react<wbr>.dev<wbr>/learn*](https://react.dev/learn).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React 元素是*不可变的*：一旦创建，它们就不能更改。如果你修改了元素的任何部分，React 会创建一个新元素并重新渲染虚拟 DOM，然后将虚拟 DOM
    与浏览器 DOM 进行比较，决定浏览器 DOM 是否需要更新。我们将使用 JSX 抽象来完成这些任务；尽管如此，了解 React 如何在后台工作仍然是有益的。如果你想深入了解，可以查阅官方文档：[*https://react.dev/learn*](https://react.dev/learn)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Organizing Code into Components</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将代码组织成组件</samp>
- en: 'We mentioned that components are independent, reusable pieces of code built
    from React elements. Elements are objects that can contain other elements. Once
    rendered to the virtual or browser DOM, they create DOM nodes or whole DOM subtrees.
    Meanwhile, React *components* are classes or functions that output elements and
    render them to the virtual DOM. We will build a user interface using React components.
    For more information about this distinction, read the deep dive at the official
    React blog: [*https://<wbr>reactjs<wbr>.org<wbr>/blog<wbr>/2015<wbr>/12<wbr>/18<wbr>/react<wbr>-components<wbr>-elements<wbr>-and<wbr>-instances<wbr>.html*](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，组件是由 React 元素构建的独立、可重用的代码块。元素是可以包含其他元素的对象。一旦渲染到虚拟 DOM 或浏览器 DOM，它们会创建 DOM
    节点或整个 DOM 子树。同时，React 的*组件*是输出元素并将其渲染到虚拟 DOM 的类或函数。我们将使用 React 组件构建用户界面。关于这种区别的更多信息，请阅读官方
    React 博客中的深度文章：[*https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html*](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)。
- en: While other frameworks might separate a user interface’s code by technology,
    splitting it into HTML, CSS, and JavaScript files, React instead separates code
    into these logical building blocks. As a result, a single physical file contains
    all the information necessary for a component, regardless of underlying technologies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他框架可能会按照技术划分用户界面的代码，将其分为 HTML、CSS 和 JavaScript 文件，但 React 则将代码划分为这些逻辑构建块。因此，一个物理文件包含了组件所需的所有信息，而不管底层技术如何。
- en: More concretely, a React component is a JavaScript function that, by convention,
    starts with an uppercase letter. Furthermore, it takes a single object argument,
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>, and returns
    a React element. This <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument should never be modified inside the component and is considered immutable
    inside the React code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，React 组件是一个 JavaScript 函数，按照约定，它的名称以大写字母开头。此外，它接收一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    的对象参数，并返回一个 React 元素。这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    参数在组件内部不应被修改，在 React 代码中被视为不可变。
- en: '[Listing 4-2](chapter4.xhtml#Lis4-2) shows a basic React component that displays
    the same weather string as in the previous listings. In addition, we’ve added
    a custom interface and a click handler. The custom interface enables us to set
    an attribute on the JSX component and read its value in the TypeScript code. It’s
    a common way to pass values to a function component without a global state management
    library.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-2](chapter4.xhtml#Lis4-2)展示了一个基础的 React 组件，该组件显示与前面列表相同的天气字符串。此外，我们还添加了一个自定义接口和一个点击事件处理程序。自定义接口使我们能够在
    JSX 组件上设置属性，并在 TypeScript 代码中读取其值。这是将值传递给函数组件的一种常见方式，无需全局状态管理库。'
- en: Here, we simply pass the component the same string used in the previous listings
    and render it to the DOM, but for a real-world application, the weather string
    might be part of an API response. To get the weather data, a parent component
    might query the API and then send this data through the component’s attribute
    to the component’s code, or each component in the application would need to query
    the API to access that data, impacting the overall performance of the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将与前面列表中相同的字符串传递给组件，并将其渲染到 DOM 中，但在实际应用中，天气字符串可能是 API 响应的一部分。为了获取天气数据，父组件可能会查询
    API，然后通过组件的属性将数据传递给组件的代码，或者应用程序中的每个组件都需要查询 API 来访问数据，这会影响整个应用的性能。
- en: The click handler enables us to react to user interactions. In JSX, click handlers
    have the same names as in HTML, and we add them the way we might add inline DOM
    events. For example, to react to a user clicking an element, we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp>
    attribute with a callback function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击处理程序使我们能够对用户交互做出反应。在 JSX 中，点击处理程序与 HTML 中的名称相同，我们通过添加它们的方式，就像我们添加内联 DOM 事件一样。例如，为了响应用户点击一个元素，我们添加一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> 属性，并指定一个回调函数。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-2: A basic React component'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：一个基本的 React 组件
- en: First we create a custom interface for our new component’s properties. We’ll
    use this interface for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp>
    parameter later. Because we set a <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute on the component and define a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    property on the interface, we can access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>
    in our TypeScript code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为新组件的属性创建一个自定义接口。稍后我们将在组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp>
    参数中使用这个接口。因为我们在组件上设置了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    属性，并在接口上定义了匹配的 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性，所以我们可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp> 在 TypeScript
    代码中访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性的值。
- en: Then we create the event handler as an arrow function with one string parameter.
    We use an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event property
    similar to inline DOM events and assign a callback function, <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>.
    As soon as the user clicks the page’s headline, we display a simple alert box.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建事件处理器作为一个箭头函数，接受一个字符串参数。我们使用一个类似于内联 DOM 事件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp>
    事件属性，并分配一个回调函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>。一旦用户点击页面的标题，我们就会显示一个简单的警告框。
- en: Next, we define the component. As you can see, it’s a JSX expression that implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp> interface
    and returns a JSX element. Inside the component, we use an untagged template literal
    to create text and add the dynamic weather information with the value from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute, via <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>. Then we return the
    JSX element and, finally, return and render the weather component, setting <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sunny</samp> as the attribute’s value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义组件。如你所见，这是一个实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp>
    接口并返回 JSX 元素的 JSX 表达式。在组件内部，我们使用一个没有标签的模板字面量来创建文本，并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>
    动态添加来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性的天气信息。然后我们返回
    JSX 元素，最后返回并渲染天气组件，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sunny</samp>
    设置为该属性的值。
- en: Paste this code into the *App.tsx* file. The browser should render an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML element with the text <samp
    class="SANS_TheSansMonoCd_W5Regular_11">The weather is sunny</samp> in the preview
    pane. When you click the text, an alert box will display it once more. Change
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute to display different weather strings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码粘贴到 *App.tsx* 文件中。浏览器应在预览窗格中渲染一个带有文本 <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    weather is sunny</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    HTML 元素。当你点击文本时，一个警告框会再次显示它。更改 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    属性的值，以显示不同的天气字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Class Components</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写类组件</samp>
- en: 'There are two kinds of components in React: class components and function components.
    The component in [Listing 4-2](chapter4.xhtml#Lis4-2) is a *function component*,
    which borrows heavily from functional programming. In particular, these components
    follow the pattern of pure functions: they create some output (JSX elements) based
    on some input (the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument and the JSX component’s attributes). While we emphasize this type of
    component in this chapter, you should know the basics of class components too.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React 中有两种类型的组件：类组件和函数组件。[清单 4-2](chapter4.xhtml#Lis4-2) 中的组件是一个 *函数组件*，它大量借鉴了函数式编程的思想。特别是，这些组件遵循纯函数的模式：它们根据一些输入（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 参数和 JSX 组件的属性）创建一些输出（JSX
    元素）。尽管我们在本章中强调了这种类型的组件，但你也应该了解类组件的基础知识。
- en: 'A *class component* follows the typical patterns of object-oriented programming:
    it is defined as a class and inherits methods from its parent <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>
    class. Like all components, it has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    and returns a JSX element. Class components also have <samp class="SANS_TheSansMonoCd_W5Regular_11">constructor</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> functions, and
    you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> keyword
    to refer to the current component’s instance.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*类组件*遵循面向对象编程的典型模式：它被定义为一个类，并继承自其父类 <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>
    类。像所有组件一样，它有一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 的参数，并返回一个
    JSX 元素。类组件还具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">constructor</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> 函数，并且可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    关键字来引用当前组件的实例。'
- en: 'Of particular value, the internal property <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp>
    provides you an interface to store and access information about the component’s
    internal state, such as opened elements, the current image in an image gallery,
    or, as in the next example, a simple click counter. Of similar importance are
    the class’s *lifecycle* methods, which run during specific lifecycle steps: for
    example, whenever the component mounts, renders, updates, or unmounts. In [Listing
    4-3](chapter4.xhtml#Lis4-3), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>
    lifecycle method. React runs this method immediately after the component becomes
    part of the DOM. It is similar to the browser’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DOMReady</samp>
    event, with which you might already be familiar.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有价值的是，内部属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp>
    提供了一个接口，用于存储和访问有关组件内部状态的信息，例如打开的元素、图像画廊中的当前图像，或者像下一个示例中的简单点击计数器。类似重要的是类的 *生命周期*
    方法，这些方法在特定生命周期步骤中运行：例如，组件挂载、渲染、更新或卸载时。 在[清单 4-3](chapter4.xhtml#Lis4-3) 中，我们使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp> 生命周期方法。React
    在组件成为 DOM 的一部分后立即运行此方法。这类似于浏览器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DOMReady</samp>
    事件，您可能已经熟悉它。
- en: '[Listing 4-3](chapter4.xhtml#Lis4-3) shows the previously created weather component
    defined as a class component. To practice accessing the component’s state, we’ve
    added a counter that will count the clicks on the headline element. Because it
    records the internal component’s state, the counter resets on page reload. Paste
    this code into the *App.tsx* file and click the headline to count up.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](chapter4.xhtml#Lis4-3) 展示了之前创建的天气组件，它被定义为一个类组件。为了练习访问组件的状态，我们添加了一个计数器，用于统计点击标题元素的次数。因为它记录了组件的内部状态，所以计数器会在页面重新加载时重置。将此代码粘贴到
    *App.tsx* 文件中，点击标题即可进行计数。'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-3: A basic React class component'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：一个基本的 React 类组件
- en: First we define the custom interface to use for the component’s properties.
    We also define a type to use in the counter we’ll create later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个自定义接口来用于组件的属性。我们还定义了一个类型，以便在稍后创建计数器时使用。
- en: Next, we define the class component, extending the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>.
    Following object-oriented programming patterns, the constructor calls a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">super</samp> function and initializes
    the component’s state. We set our counter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    As soon as the browser mounts the component, it calls the lifecycle method <samp
    class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>, changing the
    component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. We modify the click
    handler to count the number of clicks instead of displaying an alert box, and
    we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function.
    Here we return the JSX elements that display the weather props and the current
    state as HTML.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义类组件，扩展基类 <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>。遵循面向对象编程模式，构造函数调用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> 函数并初始化了组件的状态。我们将计数器设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。一旦浏览器挂载组件，它就会调用生命周期方法 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>，将组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    变量更改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。我们修改点击处理程序以计算点击次数而不是显示警告框，并调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> 函数。在这里，我们返回显示天气属性和当前状态的
    JSX 元素作为 HTML。
- en: Finally, we return the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>,
    and React initializes it. The preview pane displays the string <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    weather is sunny, and the counter shows 1</samp>. We see from the number <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> that the lifecycle method was
    indeed called. Each click on the headline increases the number instantly, because
    of the reactive nature of the component’s state. As soon as the state changes,
    React re-renders the component and updates the view with the current value of
    the state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>，然后
    React 进行初始化。预览窗格显示字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather
    is sunny, and the counter shows 1</samp>。从数字 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    我们可以看出生命周期方法确实被调用了。每次点击标题都会立即增加数字，这是因为组件状态的响应性特性。状态一旦改变，React 就会重新渲染组件并更新视图显示当前状态值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providing Reusable
    Behavior with Hooks</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Hooks 提供可重用行为</samp>
- en: Function components can use *hooks* to provide reusable behaviors, such as for
    accessing a component’s state. Hooks are functions that offer simple and reusable
    interfaces to state and lifecycle features. [Listing 4-4](chapter4.xhtml#Lis4-4)
    shows the same weather component we created in [Listing 4-3](chapter4.xhtml#Lis4-3),
    this time written as a function component. It uses hooks instead of lifecycle
    methods to update the component’s counter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件可以使用 *hooks* 提供可重用的行为，例如访问组件的状态。Hooks 是提供简单和可重用接口以访问状态和生命周期特性的函数。[列表 4-4](chapter4.xhtml#Lis4-4)
    展示了我们在 [列表 4-3](chapter4.xhtml#Lis4-3) 中创建的同一个天气组件，这次是作为函数组件编写的。它使用 hooks 替代生命周期方法来更新组件的计数器。
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-4: A React function component that uses hooks'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：使用 hooks 的 React 函数组件
- en: 'We’ve added two new features to this component: an indicator of the component’s
    state and a way to run code as soon as we mount the component. Therefore, we use
    the two hooks, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>, by importing them
    as named imports from the React module, then adding them to the function component.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook replaces
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp> property from
    the class component, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hooks the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>
    lifecycle method. In addition, we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>
    from the previous example with a simple inline function to update the counter.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向这个组件添加了两个新特性：一个组件状态指示器和一种在组件挂载时立即运行代码的方式。因此，我们通过从 React 模块中以命名导入的方式，使用两个钩子：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>，然后将它们添加到函数组件中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> 钩子取代了类组件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp>
    属性，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> 则挂载了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp> 生命周期方法。此外，我们将前一个示例中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp> 替换为一个简单的内联函数来更新计数器。
- en: Each call to a hook produces an entirely isolated state, so we can use the same
    hook multiple times in the same component and trust that the state will update.
    This pattern keeps the hook callbacks small and focused. Also note that the runtime
    does not hoist hooks. They are called in the order in which we define them in
    the code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用钩子都会生成一个完全隔离的状态，因此我们可以在同一个组件中多次使用相同的钩子，并且可以放心地认为状态会更新。这个模式保持了钩子回调函数的简洁性和聚焦性。还要注意，运行时并不会提升钩子。它们会按我们在代码中定义的顺序被调用。
- en: When you compare [Listings 4-3](chapter4.xhtml#Lis4-3) and [4-4](chapter4.xhtml#Lis4-4),
    you should instantly see that the function component is more readable and easier
    to understand. For this reason, we’ll exclusively use function components in the
    rest of this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较[Listings 4-3](chapter4.xhtml#Lis4-3)和[4-4](chapter4.xhtml#Lis4-4)时，你应该能立刻看到，函数组件更具可读性且更易于理解。正因如此，我们将在本书的其余部分中专门使用函数组件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Built-in Hooks</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用内置钩子</samp>
- en: React provides a collection of built-in hooks. You’ve just seen the most common
    ones, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>. Another useful hook
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>, for sharing
    data among components. Other built-in hooks cover more specific use cases to enhance
    the performance of your application or handle specific edge cases. You can look
    them up as needed in the React documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一组内置钩子。你刚才看到的最常用的钩子是 <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>。另一个有用的钩子是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>，用于在组件之间共享数据。其他内置钩子涵盖了更具体的使用场景，用于提高应用程序性能或处理特定的边界情况。你可以根据需要查阅
    React 文档来了解更多。
- en: You can also create custom hooks whenever you need to break a monolithic component
    into smaller, reusable packages. Custom hooks follow a specific naming convention.
    They start with <samp class="SANS_TheSansMonoCd_W5Regular_11">use</samp>, followed
    by an action beginning with an uppercase letter. You should define only one functionality
    per hook to make it easily testable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要将一个庞大的组件拆分为更小、更可复用的模块时，你也可以创建自定义钩子。自定义钩子遵循特定的命名约定。它们以 <samp class="SANS_TheSansMonoCd_W5Regular_11">use</samp>
    开头，后面跟着一个以大写字母开头的动作。你应该为每个钩子定义一个功能，以便于测试。
- en: This section will guide you through the three most common hooks and the benefits
    of using them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将引导你了解三种最常见的钩子以及使用它们的好处。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Managing the Internal
    State with useState</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 useState 管理内部状态</samp>
- en: A pure function uses only the data that is available inside the function. Still,
    it can react to local state changes, such as the counter in the weather component
    we created. The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook is probably the most-used one for handling regional states. This internal
    component’s state is available only inside the component and is never exposed
    to the outside.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Because the component state is reactive, React re-renders the component as soon
    as we update its state, changing the value across the entire component. However,
    React guarantees that the state is stable and won’t change on re-renders.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook returns
    the reactive state variable and a setter function used to set the state, as shown
    in [Listing 4-5](chapter4.xhtml#Lis4-5).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useState</samp>
    hook viewed in isolation'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook with the default value. The hook itself returns the state variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp> and the setter function we
    need to modify the state variable’s value, because we cannot modify this variable
    directly. For example, to set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    we created in [Listing 4-5](chapter4.xhtml#Lis4-5) to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we need to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount</samp>
    function with the new value as a parameter, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount(1)</samp>.
    By convention, the setter function begins with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    followed by the state variable’s name.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Side Effects
    with useEffect</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pure functions should rely only on the data passed to them. When a function
    uses or modifies data outside its local scope, we call this a *side effect*. The
    simplest example of a side effect is modifying a global variable. This is considered
    a bad practice both in JavaScript and in functional programming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, our components need to interact with the “outside world”
    or have an external dependency. In these cases, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook, which handles side effects, providing an escape hatch from the functional
    aspect of the component. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    can manage dependencies, call APIs, and fetch data required for the component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: This hook runs after React mounts the component into the layout and the rendering
    process of the component is completed. It has an optional return object, which
    runs before the component is unmounted. You can use it for cleanup, for example,
    to remove event listeners.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: One way to use this hook is to observe and react to dependencies. To do this,
    we can pass it an optional array of dependencies. Any change to one of these dependencies
    would trigger a rerun of the hook. If the dependency array is empty, the hook
    won’t depend on any external value and never reruns. This is the case in our weather
    component, where <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    is executed only after mounting and unmounting the component. It has no external
    dependencies, so the dependency array remains empty and the hook runs only once.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个钩子的一种方法是观察并响应依赖关系。为此，我们可以传递一个可选的依赖项数组。任何依赖项的变化都会触发钩子的重新运行。如果依赖项数组为空，钩子将不依赖任何外部值并且永不重新运行。在我们的天气组件中就是这种情况，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> 仅在组件挂载和卸载后执行。它没有外部依赖项，因此依赖项数组保持为空，钩子只运行一次。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing Global Data
    with useContext and Context Providers</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 useContext 和上下文提供者共享全局数据</samp>
- en: Ideally, React’s function components would be pure functions that operate only
    on data passed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    parameter. Alas, a component might sometimes need to consume a shared, global
    state. In this case, React implements the *context provider* to share global data
    with a tree of child components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，React 的函数组件应为纯函数，仅操作通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    参数传递的数据。遗憾的是，组件有时可能需要消耗共享的全局状态。在这种情况下，React 实现了 *上下文提供者* 来与子组件树共享全局数据。
- en: The context provider wraps the child components, and we can access the shared
    data with the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    hook. As the context value changes, React automatically re-renders all child components.
    Thus, it is quite an expensive hook. You shouldn’t use it for datasets that change
    frequently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文提供者将子组件包裹起来，我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    钩子访问共享的数据。随着上下文值的变化，React 会自动重新渲染所有子组件。因此，这是一个相对昂贵的钩子。你不应该将其用于频繁变化的数据集。
- en: In the full-stack application you’ll build in [Part II](part2.xhtml), you’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> to share session
    data with child components. Shared contexts are also often employed to keep track
    of color schemes and themes. [Listing 4-6](chapter4.xhtml#Lis4-6) shows how to
    consume a theme through a context provider.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将在 [第二部分](part2.xhtml) 中构建的全栈应用中，你将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    来与子组件共享会话数据。共享上下文也经常用于跟踪颜色方案和主题。[清单 4-6](chapter4.xhtml#Lis4-6) 展示了如何通过上下文提供者来消费主题。
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-6: A complete context provider example'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-6：完整的上下文提供者示例
- en: First we import the necessary functions from the React package and use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">createContext</samp> function to initialize
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp>. Next, we
    create the parent component and name it <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>.
    This is the wrapper that holds the context provider and all child components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 React 包中导入必要的函数，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">createContext</samp>
    函数初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp>。接下来，我们创建父组件并命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>。这是一个包含上下文提供者和所有子组件的包装器。
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>,
    we create the local <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and
    set the stateful variable as the content the context provides. This enables us
    to change the variable in the context from inside a child component. Because we
    used a reactive stateful variable for the value, all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    variable will instantly update across all child components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp> 中，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> 创建局部 <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    变量，并将有状态的变量设置为上下文提供的内容。这使我们能够从子组件内部更改上下文中的变量。由于我们使用了反应式的有状态变量作为值，所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    变量的实例将在所有子组件中即时更新。
- en: We add a button element and toggle the value of the stateful variable between
    light and dark whenever a user clicks the button. Finally, we create the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp> component, which calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> hook to get
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> value provided
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp> to all
    child components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp>
    component uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    value for the HTML class and displays the current <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个按钮元素，并且每当用户点击按钮时，切换状态变量的值，在明亮和黑暗模式之间切换。最后，我们创建了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp>
    组件，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> 钩子来获取由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp> 提供的 <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    值，并将其传递给所有子组件。<samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp> 组件使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> 值来设置 HTML 类，并显示当前的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4: Create a Reactive User
    Interface for the Express.js Server</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 4：为 Express.js 服务器创建一个响应式用户界面</samp>
- en: Let’s use your new knowledge and our weather component to create a reactive
    user interface for the Express.js server. The new React component will allow us
    to update text on the web page by clicking it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用你学到的新知识和我们的天气组件，为 Express.js 服务器创建一个响应式用户界面。新的 React 组件将允许我们通过点击页面上的文本来更新网页内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding React to the
    Server</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将 React 添加到服务器</samp>
- en: First we’ll include React in our project. For experimentation purposes, you
    can add the React library and the stand-alone version of the Babel.js transpiler
    directly inside your HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp>
    tag. Be aware, however, that this technique is not suitable for production. Transpiling
    code in the browser is a slow process, and the JavaScript libraries we add here
    aren’t optimized. Using React with a skeleton Express.js server requires a decent
    number of tedious setup steps and a decent amount of maintenance. We’ll use Next.js
    in [Chapter 5](chapter5.xhtml) to simplify developing React applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在项目中包含 React。为了进行实验，你可以将 React 库和 Babel.js 转译器的独立版本直接添加到 HTML 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">head</samp> 标签中。不过要注意，这种方法不适合用于生产环境。因为在浏览器中转译代码是一个非常慢的过程，而且我们在这里添加的
    JavaScript 库并未进行优化。使用 React 和骨架 Express.js 服务器需要相当多的繁琐设置步骤和一定的维护工作。我们将在[第 5 章](chapter5.xhtml)中使用
    Next.js 来简化开发 React 应用程序的过程。
- en: Create a folder, named *public*, next to the *package.json* file and then create
    an empty file called *weather.html* inside it. Add the code in [Listing 4-7](chapter4.xhtml#Lis4-7),
    which contains our React example with the weather component. Later, we’ll create
    a new endpoint, */components/weather*, that directly returns the HTML file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *package.json* 文件旁边创建一个名为 *public* 的文件夹，然后在其中创建一个空的 *weather.html* 文件。添加 [列表
    4-7](chapter4.xhtml#Lis4-7) 中的代码，其中包含我们的 React 示例和天气组件。稍后，我们将创建一个新的端点 */components/weather*，直接返回该
    HTML 文件。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-7: The static file /public/weather.html renders React in the browser.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：静态文件 /public/weather.html 在浏览器中渲染 React。
- en: 'First we add three React scripts to the *weather.html* file: these are *react.development*,
    *react.dom.development*, and the stand-alone *babel.js*, which are all similar
    to the import of React we previously used in the *App.tsx* file. Then we add ReactDOM
    to let React interact with the DOM. The three files add a global property, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">React</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">window.object</samp>.
    We use this property as a global variable to reference React functions. The stand-alone
    Babel script adds the Babel.js transpiler, which we need to convert the code from
    JSX to JavaScript.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向 *weather.html* 文件中添加三个 React 脚本：它们分别是 *react.development*、*react.dom.development*
    和独立的 *babel.js*，这些都类似于我们之前在 *App.tsx* 文件中使用的 React 引入方式。然后我们添加 ReactDOM，以便 React
    能够与 DOM 进行交互。这三个文件会向 <samp class="SANS_TheSansMonoCd_W5Regular_11">window.object</samp>
    添加一个全局属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>。我们使用这个属性作为全局变量来引用
    React 函数。独立的 Babel 脚本添加了 Babel.js 转译器，我们需要它来将代码从 JSX 转换为 JavaScript。
- en: Next, we add the weather component’s code we developed previously. Instead of
    referencing the *App.tsx* file, we place app functions directly inside the HTML
    file and mark the script block as <samp class="SANS_TheSansMonoCd_W5Regular_11">text/babel</samp>.
    This type tells Babel to transpile the code inside the script tag into standard
    JavaScript.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加之前开发的天气组件代码。我们不再引用 *App.tsx* 文件，而是将应用函数直接放入 HTML 文件中，并将脚本块标记为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">text/babel</samp>。此类型告诉 Babel 将脚本标签中的代码转译为标准
    JavaScript。
- en: We make a few simple modifications to the weather component’s code. First we
    remove the type annotations, as they are allowed only in TypeScript files. Then,
    because we are using the browser environment, we prefix the hooks with their global
    property name, <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>. Finally,
    we use ReactDOM to create the React root container and render the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">App /></samp> component there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对天气组件的代码进行了几个简单的修改。首先，我们删除了类型注解，因为它们仅在 TypeScript 文件中允许使用。然后，由于我们使用的是浏览器环境，我们在钩子前添加了全局属性名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>。最后，我们使用 ReactDOM 创建
    React 根容器，并在那里渲染 <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">App
    /></samp> 组件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Endpoint
    for the Static HTML File</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为静态 HTML 文件创建端点</samp>
- en: The second file we’ll edit is the *index.ts* file in the root directory. We
    add the highlighted code in [Listing 4-8](chapter4.xhtml#Lis4-8) to add a new
    entry point, */components/weather*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编辑的第二个文件是根目录中的 *index.ts* 文件。我们将 [列表 4-8](chapter4.xhtml#Lis4-8) 中突出显示的代码添加到文件中，以添加新的入口点
    */components/weather*。
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-8: The refactored index.ts'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-8：重构后的 index.ts
- en: To load the static HTML file, import <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    from Node.js’s default path module. The path module provides all kinds of utilities
    for working with files and directories. In particular, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">join</samp>
    function to create a valid path that meets the operation system’s format.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载静态 HTML 文件，我们从 Node.js 的默认路径模块导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>。路径模块提供了用于处理文件和目录的各种工具。特别是，我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">join</samp> 函数来创建符合操作系统格式的有效路径。
- en: We use the default global <samp class="SANS_TheSansMonoCd_W5Regular_11">process.cwd</samp>
    function to get the current working directory, and from there, we create the path
    to our HTML file. Then we add the weather component’s entry point and set the
    response’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Content -Type</samp>
    header to *text/html*. Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sendFile</samp>
    function to send to the browser the *weather.html* file we created previously.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认的全局函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">process.cwd</samp>
    获取当前工作目录，并从那里创建到 HTML 文件的路径。然后，我们添加天气组件的入口点，并将响应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    头设置为 *text/html*。最后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sendFile</samp>
    函数将之前创建的 *weather.html* 文件发送到浏览器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Server</samp>
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行服务器</samp>
- en: 'We need to transpile the server code to JavaScript, so we run TSC with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将服务器代码转译为 JavaScript，因此我们在命令行中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>
    运行 TSC：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The generated files, *index.js* and *routes.js*, are similar to the previously
    created ones. TSC doesn’t touch the static HTML. The stand-alone Babel.js script
    converts the JSX code on runtime in the browser. Start the server from your command
    line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件 *index.js* 和 *routes.js* 与之前创建的文件类似。TSC 不会处理静态 HTML 文件。独立的 Babel.js 脚本在浏览器中运行时将
    JSX 代码转换。通过命令行启动服务器：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now visit *http://localhost:3000/components/weather-component* in your browser.
    You see the same text you saw when you rendered the weather component in the React
    playground, as in [Figure 4-2](chapter4.xhtml#fig4-2). As soon as you click the
    text, the click handler increases the reactive state variable, and the counter
    shows the new value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中访问 *http://localhost:3000/components/weather-component*。你会看到与在 React
    游乐场渲染天气组件时看到的相同文本，如 [图 4-2](chapter4.xhtml#fig4-2) 所示。一旦点击该文本，点击处理程序将增加响应式状态变量，计数器会显示新的值。
- en: '![](../images/Figure4-2.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-2: Browser response
    from the Node.js web server</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 4-2：来自 Node.js Web 服务器的浏览器响应</samp>
- en: You successfully created your first React application. To gain more experience
    with React, try adding a custom button component for the click counter, with a
    style attribute that uses a JSX expression to change the background color for
    odd and even counter values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你成功创建了你的第一个 React 应用。为了获得更多 React 经验，尝试为点击计数器添加一个自定义按钮组件，使用 style 属性，并通过 JSX
    表达式根据奇数和偶数计数值改变背景色。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: You should now have a solid foundation with which to create your React apps.
    JSX elements are the building blocks of React components that return JSX to be
    rendered as HTML in the DOM, via React’s virtual DOM. You also explored the difference
    between class components and modern function components, took a deep dive into
    React hooks, and used these hooks to build a function component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经有了坚实的基础，可以开始创建你的 React 应用了。JSX 元素是 React 组件的构建块，这些组件返回 JSX，通过 React 的虚拟
    DOM 渲染为 HTML 到 DOM 中。你还探讨了类组件和现代函数组件之间的区别，深入了解了 React hooks，并使用这些 hooks 构建了一个函数组件。
- en: If you want to explore React’s full potential, take a look at the React tutorials
    from W3Schools at [*https://<wbr>www<wbr>.w3schools<wbr>.com<wbr>/REACT<wbr>/DEFAULT<wbr>.ASP*](https://www.w3schools.com/REACT/DEFAULT.ASP)
    and those created by the React team at [*https://<wbr>react<wbr>.dev<wbr>/learn<wbr>/tutorial<wbr>-tic<wbr>-tac<wbr>-toe*](https://react.dev/learn/tutorial-tic-tac-toe).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索 React 的全部潜力，可以查看 W3Schools 提供的 React 教程，网址是 [*https://<wbr>www<wbr>.w3schools<wbr>.com<wbr>/REACT<wbr>/DEFAULT<wbr>.ASP*](https://www.w3schools.com/REACT/DEFAULT.ASP)，以及
    React 团队创建的教程，网址是 [*https://<wbr>react<wbr>.dev<wbr>/learn<wbr>/tutorial<wbr>-tic<wbr>-tac<wbr>-toe*](https://react.dev/learn/tutorial-tic-tac-toe)。
- en: In the next chapter, we’ll work with Next.js. Built on top of React, Next.js
    is a production-ready full-stack web development framework for single-page applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习 Next.js。Next.js 是基于 React 构建的，作为一个生产级的全栈网页开发框架，专为单页面应用而设计。
