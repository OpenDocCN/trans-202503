- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REACT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Developers can use the React library to create a full-stack application’s user
    interface. React is built upon the Node.js ecosystem, and as one of the most commonly
    used web frameworks, it currently forms the basis of more than percent of the
    most visited websites.
  prefs: []
  type: TYPE_NORMAL
- en: To work effectively with React, you must understand the syntax used to define
    the appearance of user interface elements and then combine these into React components
    that can dynamically update. This chapter covers everything you need to know to
    begin developing full-stack applications using this library.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Role of React</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern frontend architectures split an application’s user interface into small,
    self-contained, and reusable items. Some of these, such as headers, navigations,
    and logos, might appear only once per page, while others are repeated elements
    that form the page’s contents, such as headlines, buttons, and teasers. [Figure
    4-1](chapter4.xhtml#fig4-1) shows some of these items. React’s syntax embraces
    this pattern; the library focuses on building these independent components and,
    in doing so, helps us develop our applications more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-1: User interface
    components</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: React uses a *declarative* programming paradigm, through which you create a
    user interface by describing the desired results instead of explicitly listing
    all the steps necessary to create it, as is done in *imperative* programming.
    A classic example of the declarative paradigm is HTML. Using HTML, you describe
    a web page’s elements, and the browser then renders the page. By contrast, you
    could use JavaScript to write an imperative program that creates each HTML element.
    In doing so, you would explicitly list the steps to build the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, these user interface components are *reactive*. This means two
    things: one, that they handle their own isolated states, and two, that each component
    updates the page’s HTML as soon as its state changes. Changes to the React code
    instantly affect a browser’s *document object model (DOM)*, which represents a
    website as a tree in which each HTML element is a node. The DOM also provides
    an API for each node and for the website in general, enabling scripts to modify
    a website or a specific node.'
  prefs: []
  type: TYPE_NORMAL
- en: DOM operations, such as re-rendering a component, are expensive. To update the
    DOM, React uses a *virtual DOM*, which is an in-memory clone of the actual browser
    DOM that it later syncs with the real thing. This virtual DOM allows for incremental
    updates that reduce the number of costly operations on the browser. The virtual
    DOM is a crucial principle of React. React calculates the difference between the
    virtual DOM and the real DOM with every call to one of its render functions and
    then decides what to update. Usually, React performs batch updates to lower the
    performance impact further. This process of reconciliation lets React deliver
    fast and responsive user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although React is primarily a user interface library, developers can also use
    it to build single-page applications that don’t require middleware or a backend.
    These apps are nothing more than a view layer rendered in the browser. To some
    extent, they can be dynamic: for example, we can change the page’s language, open
    an image gallery, or toggle an element’s visibility. However, all of this occurs
    in the browser, with additional React modules, rather than on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also perform more advanced functionality, like updating the browser’s
    location to simulate the existence of distinct pages, purely in the browser, with
    React’s Router module. This module lets us define routes, similar to the ones
    we defined in our Express.js server, on the frontend. As soon as a user clicks
    an internal link, the routing component updates the view and changes the browser’s
    location. This makes it seem as though they’ve loaded another HTML page. In reality,
    we’ve just changed the current page’s contents. In doing so, we avoided another
    set of server requests, so the simulated page loads much more quickly. Also, because
    our JavaScript code controls the transition between pages, we can add effects
    and animations to these transitions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up React</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike, say, the basic Express.js server you created in [Exercise 1](chapter1.xhtml#Exe1)
    on page 13, which uses standard JavaScript and can run directly with Node.js,
    React relies on an advanced setup with a complete build toolchain. For example,
    it uses a custom JavaScript Syntax Extension (JSX) to describe HTML elements and
    TypeScript for static typing, both of which require a transpiler to convert the
    code to JavaScript. Therefore, the manual process for setting up React is quite
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we generally rely on other tools. In the case of a single-page application,
    we use a code generator, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>,
    to scaffold it. During this scaffolding process, <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    generates the boilerplate code for a new React application, as well as the build
    chain and folder structure for the project. It also provides a consistent project
    layout that helps us easily understand other React projects.
  prefs: []
  type: TYPE_NORMAL
- en: To run the examples in this chapter, one option is to scaffold a simple TypeScript
    React app with <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    by following the steps at [*https://<wbr>create<wbr>-react<wbr>-app<wbr>.dev<wbr>/docs<wbr>/getting<wbr>-started<wbr>/*](https://create-react-app.dev/docs/getting-started/).
    If you don’t want to create a dedicated project, you can instead run code using
    React with a TypeScript template in an online playground, such as [*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io)
    or [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com). The playgrounds
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> follow
    the same file structure. In both cases, you should save your code to the default
    *App.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex apps, we’d use a complete web application framework such as
    Next.js, which provides the necessary setup out of the box. Covered in [Chapter
    5](chapter5.xhtml), Next.js is the most popular framework for full-stack web applications
    that use React. Internally, Next.js employs a variation of <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>
    for scaffolding. We’ll rely on it in future chapters to work with React.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The JavaScript Syntax Extension</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React uses JSX to define the appearance of user interface components. JSX is
    an extension of JavaScript that a transpiler must convert before the browser renders
    it to the DOM. While it has HTML-like syntax, it is more than a simple templating
    language. Instead, it allows us to use any JavaScript feature to describe React
    elements. For example, we can use JSX syntax inside conditional statements, assign
    it to variables, and return it from functions. The compiler will then embed any
    variable or valid JavaScript expression wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    into the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This logic allows us to, for instance, use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to loop over an array, check each item for a certain condition, pass the item
    to another function, and create a set of JSX elements based on the function’s
    return value, directly inside a page’s template. While this may sound abstract,
    we’ll use this pattern extensively when we create React components in the Food
    Finder application you’ll build in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example JSX Expression</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JSX expressions, like those in [Listing 4-1](chapter4.xhtml#Lis4-1), are the
    most essential part of the React user interfaces. This JavaScript code defines
    a JSX function expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">getElement</samp>,
    that takes one string as a parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: A minimal example of a JSX expression'
  prefs: []
  type: TYPE_NORMAL
- en: The entry point for each React application is the <samp class="SANS_TheSansMonoCd_W5Regular_11">App</samp>
    function. Like the *index.js* file of our Express.js server, this function is
    executed when the application starts. Here, we usually set up the global elements,
    such as stylesheets and the overall page layout.
  prefs: []
  type: TYPE_NORMAL
- en: React renders the function’s return value to the browser. In [Listing 4-1](chapter4.xhtml#Lis4-1),
    we immediately return an element. As the smallest building blocks of React user
    interfaces, *elements* describe what you’ll see on the screen, just as HTML elements
    do. Examples of elements include custom buttons, headlines, and images.
  prefs: []
  type: TYPE_NORMAL
- en: After importing the React package, we create the JSX element and store it in
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">element</samp> constant. At first
    glance, you might wonder why it isn’t wrapped in quotes, as it contains what appears
    to be a regular HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> element
    and looks like a string. The answer is that it isn’t a string but a JSX element
    from which the library creates HTML elements programmatically. As a result, the
    code will display a message about the weather to the page.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we call the JSX expression, the React library transpiles it into
    a regular JavaScript function call and creates an HTML string from the JSX element
    displayed in the browser. In [Chapter 3](chapter3.xhtml), you learned that all
    valid JavaScript is also valid TypeScript. Hence, we can use JSX with TypeScript
    as well. JSX files use a .*jsx* (JavaScript) or *.tsx* (TypeScript) extension.
    Paste this code into the *App.tsx* file of the project you created, and the browser
    should render an <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML
    element with the text <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather
    is sunny</samp> either in the preview pane of the online playground or in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ReactDOM Package</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One easy way to work with elements is to use the ReactDOM package, which contains
    APIs for working with the DOM. Note that the elements you create aren’t browser
    DOM elements. Instead, they’re plain JavaScript objects that will be rendered,
    using React’s <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function,
    to the virtual DOM’s root element and then attached to the browser DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'React elements are *immutable*: once created, they cannot be changed. If you
    do alter any part of the element, React will create a new element and re-render
    the virtual DOM, then compare the virtual DOM with the browser DOM to decide whether
    the browser DOM needs an update. We’ll use JSX abstractions for these tasks; nonetheless,
    it’s good to understand how React works under the hood. If you want to dig deeper,
    consult the official documentation at [*https://<wbr>react<wbr>.dev<wbr>/learn*](https://react.dev/learn).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Organizing Code into Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned that components are independent, reusable pieces of code built
    from React elements. Elements are objects that can contain other elements. Once
    rendered to the virtual or browser DOM, they create DOM nodes or whole DOM subtrees.
    Meanwhile, React *components* are classes or functions that output elements and
    render them to the virtual DOM. We will build a user interface using React components.
    For more information about this distinction, read the deep dive at the official
    React blog: [*https://<wbr>reactjs<wbr>.org<wbr>/blog<wbr>/2015<wbr>/12<wbr>/18<wbr>/react<wbr>-components<wbr>-elements<wbr>-and<wbr>-instances<wbr>.html*](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html).'
  prefs: []
  type: TYPE_NORMAL
- en: While other frameworks might separate a user interface’s code by technology,
    splitting it into HTML, CSS, and JavaScript files, React instead separates code
    into these logical building blocks. As a result, a single physical file contains
    all the information necessary for a component, regardless of underlying technologies.
  prefs: []
  type: TYPE_NORMAL
- en: More concretely, a React component is a JavaScript function that, by convention,
    starts with an uppercase letter. Furthermore, it takes a single object argument,
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>, and returns
    a React element. This <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument should never be modified inside the component and is considered immutable
    inside the React code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-2](chapter4.xhtml#Lis4-2) shows a basic React component that displays
    the same weather string as in the previous listings. In addition, we’ve added
    a custom interface and a click handler. The custom interface enables us to set
    an attribute on the JSX component and read its value in the TypeScript code. It’s
    a common way to pass values to a function component without a global state management
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we simply pass the component the same string used in the previous listings
    and render it to the DOM, but for a real-world application, the weather string
    might be part of an API response. To get the weather data, a parent component
    might query the API and then send this data through the component’s attribute
    to the component’s code, or each component in the application would need to query
    the API to access that data, impacting the overall performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The click handler enables us to react to user interactions. In JSX, click handlers
    have the same names as in HTML, and we add them the way we might add inline DOM
    events. For example, to react to a user clicking an element, we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp>
    attribute with a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: A basic React component'
  prefs: []
  type: TYPE_NORMAL
- en: First we create a custom interface for our new component’s properties. We’ll
    use this interface for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp>
    parameter later. Because we set a <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute on the component and define a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    property on the interface, we can access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>
    in our TypeScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create the event handler as an arrow function with one string parameter.
    We use an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event property
    similar to inline DOM events and assign a callback function, <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>.
    As soon as the user clicks the page’s headline, we display a simple alert box.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the component. As you can see, it’s a JSX expression that implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp> interface
    and returns a JSX element. Inside the component, we use an untagged template literal
    to create text and add the dynamic weather information with the value from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute, via <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>. Then we return the
    JSX element and, finally, return and render the weather component, setting <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sunny</samp> as the attribute’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Paste this code into the *App.tsx* file. The browser should render an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML element with the text <samp
    class="SANS_TheSansMonoCd_W5Regular_11">The weather is sunny</samp> in the preview
    pane. When you click the text, an alert box will display it once more. Change
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    attribute to display different weather strings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Class Components</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two kinds of components in React: class components and function components.
    The component in [Listing 4-2](chapter4.xhtml#Lis4-2) is a *function component*,
    which borrows heavily from functional programming. In particular, these components
    follow the pattern of pure functions: they create some output (JSX elements) based
    on some input (the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument and the JSX component’s attributes). While we emphasize this type of
    component in this chapter, you should know the basics of class components too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *class component* follows the typical patterns of object-oriented programming:
    it is defined as a class and inherits methods from its parent <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>
    class. Like all components, it has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    and returns a JSX element. Class components also have <samp class="SANS_TheSansMonoCd_W5Regular_11">constructor</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> functions, and
    you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> keyword
    to refer to the current component’s instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of particular value, the internal property <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp>
    provides you an interface to store and access information about the component’s
    internal state, such as opened elements, the current image in an image gallery,
    or, as in the next example, a simple click counter. Of similar importance are
    the class’s *lifecycle* methods, which run during specific lifecycle steps: for
    example, whenever the component mounts, renders, updates, or unmounts. In [Listing
    4-3](chapter4.xhtml#Lis4-3), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>
    lifecycle method. React runs this method immediately after the component becomes
    part of the DOM. It is similar to the browser’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DOMReady</samp>
    event, with which you might already be familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-3](chapter4.xhtml#Lis4-3) shows the previously created weather component
    defined as a class component. To practice accessing the component’s state, we’ve
    added a counter that will count the clicks on the headline element. Because it
    records the internal component’s state, the counter resets on page reload. Paste
    this code into the *App.tsx* file and click the headline to count up.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: A basic React class component'
  prefs: []
  type: TYPE_NORMAL
- en: First we define the custom interface to use for the component’s properties.
    We also define a type to use in the counter we’ll create later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the class component, extending the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>.
    Following object-oriented programming patterns, the constructor calls a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">super</samp> function and initializes
    the component’s state. We set our counter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    As soon as the browser mounts the component, it calls the lifecycle method <samp
    class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>, changing the
    component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. We modify the click
    handler to count the number of clicks instead of displaying an alert box, and
    we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function.
    Here we return the JSX elements that display the weather props and the current
    state as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>,
    and React initializes it. The preview pane displays the string <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    weather is sunny, and the counter shows 1</samp>. We see from the number <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> that the lifecycle method was
    indeed called. Each click on the headline increases the number instantly, because
    of the reactive nature of the component’s state. As soon as the state changes,
    React re-renders the component and updates the view with the current value of
    the state.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providing Reusable
    Behavior with Hooks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Function components can use *hooks* to provide reusable behaviors, such as for
    accessing a component’s state. Hooks are functions that offer simple and reusable
    interfaces to state and lifecycle features. [Listing 4-4](chapter4.xhtml#Lis4-4)
    shows the same weather component we created in [Listing 4-3](chapter4.xhtml#Lis4-3),
    this time written as a function component. It uses hooks instead of lifecycle
    methods to update the component’s counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: A React function component that uses hooks'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added two new features to this component: an indicator of the component’s
    state and a way to run code as soon as we mount the component. Therefore, we use
    the two hooks, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>, by importing them
    as named imports from the React module, then adding them to the function component.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook replaces
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp> property from
    the class component, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hooks the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>
    lifecycle method. In addition, we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>
    from the previous example with a simple inline function to update the counter.'
  prefs: []
  type: TYPE_NORMAL
- en: Each call to a hook produces an entirely isolated state, so we can use the same
    hook multiple times in the same component and trust that the state will update.
    This pattern keeps the hook callbacks small and focused. Also note that the runtime
    does not hoist hooks. They are called in the order in which we define them in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: When you compare [Listings 4-3](chapter4.xhtml#Lis4-3) and [4-4](chapter4.xhtml#Lis4-4),
    you should instantly see that the function component is more readable and easier
    to understand. For this reason, we’ll exclusively use function components in the
    rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Built-in Hooks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React provides a collection of built-in hooks. You’ve just seen the most common
    ones, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>. Another useful hook
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>, for sharing
    data among components. Other built-in hooks cover more specific use cases to enhance
    the performance of your application or handle specific edge cases. You can look
    them up as needed in the React documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create custom hooks whenever you need to break a monolithic component
    into smaller, reusable packages. Custom hooks follow a specific naming convention.
    They start with <samp class="SANS_TheSansMonoCd_W5Regular_11">use</samp>, followed
    by an action beginning with an uppercase letter. You should define only one functionality
    per hook to make it easily testable.
  prefs: []
  type: TYPE_NORMAL
- en: This section will guide you through the three most common hooks and the benefits
    of using them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Managing the Internal
    State with useState</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A pure function uses only the data that is available inside the function. Still,
    it can react to local state changes, such as the counter in the weather component
    we created. The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook is probably the most-used one for handling regional states. This internal
    component’s state is available only inside the component and is never exposed
    to the outside.
  prefs: []
  type: TYPE_NORMAL
- en: Because the component state is reactive, React re-renders the component as soon
    as we update its state, changing the value across the entire component. However,
    React guarantees that the state is stable and won’t change on re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook returns
    the reactive state variable and a setter function used to set the state, as shown
    in [Listing 4-5](chapter4.xhtml#Lis4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useState</samp>
    hook viewed in isolation'
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook with the default value. The hook itself returns the state variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp> and the setter function we
    need to modify the state variable’s value, because we cannot modify this variable
    directly. For example, to set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    we created in [Listing 4-5](chapter4.xhtml#Lis4-5) to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we need to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount</samp>
    function with the new value as a parameter, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount(1)</samp>.
    By convention, the setter function begins with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    followed by the state variable’s name.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Side Effects
    with useEffect</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pure functions should rely only on the data passed to them. When a function
    uses or modifies data outside its local scope, we call this a *side effect*. The
    simplest example of a side effect is modifying a global variable. This is considered
    a bad practice both in JavaScript and in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, our components need to interact with the “outside world”
    or have an external dependency. In these cases, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook, which handles side effects, providing an escape hatch from the functional
    aspect of the component. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    can manage dependencies, call APIs, and fetch data required for the component.
  prefs: []
  type: TYPE_NORMAL
- en: This hook runs after React mounts the component into the layout and the rendering
    process of the component is completed. It has an optional return object, which
    runs before the component is unmounted. You can use it for cleanup, for example,
    to remove event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: One way to use this hook is to observe and react to dependencies. To do this,
    we can pass it an optional array of dependencies. Any change to one of these dependencies
    would trigger a rerun of the hook. If the dependency array is empty, the hook
    won’t depend on any external value and never reruns. This is the case in our weather
    component, where <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    is executed only after mounting and unmounting the component. It has no external
    dependencies, so the dependency array remains empty and the hook runs only once.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing Global Data
    with useContext and Context Providers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ideally, React’s function components would be pure functions that operate only
    on data passed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    parameter. Alas, a component might sometimes need to consume a shared, global
    state. In this case, React implements the *context provider* to share global data
    with a tree of child components.
  prefs: []
  type: TYPE_NORMAL
- en: The context provider wraps the child components, and we can access the shared
    data with the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    hook. As the context value changes, React automatically re-renders all child components.
    Thus, it is quite an expensive hook. You shouldn’t use it for datasets that change
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: In the full-stack application you’ll build in [Part II](part2.xhtml), you’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> to share session
    data with child components. Shared contexts are also often employed to keep track
    of color schemes and themes. [Listing 4-6](chapter4.xhtml#Lis4-6) shows how to
    consume a theme through a context provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: A complete context provider example'
  prefs: []
  type: TYPE_NORMAL
- en: First we import the necessary functions from the React package and use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">createContext</samp> function to initialize
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp>. Next, we
    create the parent component and name it <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>.
    This is the wrapper that holds the context provider and all child components.
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>,
    we create the local <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and
    set the stateful variable as the content the context provides. This enables us
    to change the variable in the context from inside a child component. Because we
    used a reactive stateful variable for the value, all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    variable will instantly update across all child components.
  prefs: []
  type: TYPE_NORMAL
- en: We add a button element and toggle the value of the stateful variable between
    light and dark whenever a user clicks the button. Finally, we create the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp> component, which calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> hook to get
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> value provided
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp> to all
    child components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp>
    component uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>
    value for the HTML class and displays the current <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4: Create a Reactive User
    Interface for the Express.js Server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use your new knowledge and our weather component to create a reactive
    user interface for the Express.js server. The new React component will allow us
    to update text on the web page by clicking it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding React to the
    Server</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we’ll include React in our project. For experimentation purposes, you
    can add the React library and the stand-alone version of the Babel.js transpiler
    directly inside your HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp>
    tag. Be aware, however, that this technique is not suitable for production. Transpiling
    code in the browser is a slow process, and the JavaScript libraries we add here
    aren’t optimized. Using React with a skeleton Express.js server requires a decent
    number of tedious setup steps and a decent amount of maintenance. We’ll use Next.js
    in [Chapter 5](chapter5.xhtml) to simplify developing React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder, named *public*, next to the *package.json* file and then create
    an empty file called *weather.html* inside it. Add the code in [Listing 4-7](chapter4.xhtml#Lis4-7),
    which contains our React example with the weather component. Later, we’ll create
    a new endpoint, */components/weather*, that directly returns the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: The static file /public/weather.html renders React in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we add three React scripts to the *weather.html* file: these are *react.development*,
    *react.dom.development*, and the stand-alone *babel.js*, which are all similar
    to the import of React we previously used in the *App.tsx* file. Then we add ReactDOM
    to let React interact with the DOM. The three files add a global property, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">React</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">window.object</samp>.
    We use this property as a global variable to reference React functions. The stand-alone
    Babel script adds the Babel.js transpiler, which we need to convert the code from
    JSX to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the weather component’s code we developed previously. Instead of
    referencing the *App.tsx* file, we place app functions directly inside the HTML
    file and mark the script block as <samp class="SANS_TheSansMonoCd_W5Regular_11">text/babel</samp>.
    This type tells Babel to transpile the code inside the script tag into standard
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We make a few simple modifications to the weather component’s code. First we
    remove the type annotations, as they are allowed only in TypeScript files. Then,
    because we are using the browser environment, we prefix the hooks with their global
    property name, <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>. Finally,
    we use ReactDOM to create the React root container and render the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">App /></samp> component there.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Endpoint
    for the Static HTML File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second file we’ll edit is the *index.ts* file in the root directory. We
    add the highlighted code in [Listing 4-8](chapter4.xhtml#Lis4-8) to add a new
    entry point, */components/weather*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: The refactored index.ts'
  prefs: []
  type: TYPE_NORMAL
- en: To load the static HTML file, import <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    from Node.js’s default path module. The path module provides all kinds of utilities
    for working with files and directories. In particular, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">join</samp>
    function to create a valid path that meets the operation system’s format.
  prefs: []
  type: TYPE_NORMAL
- en: We use the default global <samp class="SANS_TheSansMonoCd_W5Regular_11">process.cwd</samp>
    function to get the current working directory, and from there, we create the path
    to our HTML file. Then we add the weather component’s entry point and set the
    response’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Content -Type</samp>
    header to *text/html*. Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sendFile</samp>
    function to send to the browser the *weather.html* file we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Server</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to transpile the server code to JavaScript, so we run TSC with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated files, *index.js* and *routes.js*, are similar to the previously
    created ones. TSC doesn’t touch the static HTML. The stand-alone Babel.js script
    converts the JSX code on runtime in the browser. Start the server from your command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now visit *http://localhost:3000/components/weather-component* in your browser.
    You see the same text you saw when you rendered the weather component in the React
    playground, as in [Figure 4-2](chapter4.xhtml#fig4-2). As soon as you click the
    text, the click handler increases the reactive state variable, and the counter
    shows the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-2: Browser response
    from the Node.js web server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You successfully created your first React application. To gain more experience
    with React, try adding a custom button component for the click counter, with a
    style attribute that uses a JSX expression to change the background color for
    odd and even counter values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should now have a solid foundation with which to create your React apps.
    JSX elements are the building blocks of React components that return JSX to be
    rendered as HTML in the DOM, via React’s virtual DOM. You also explored the difference
    between class components and modern function components, took a deep dive into
    React hooks, and used these hooks to build a function component.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore React’s full potential, take a look at the React tutorials
    from W3Schools at [*https://<wbr>www<wbr>.w3schools<wbr>.com<wbr>/REACT<wbr>/DEFAULT<wbr>.ASP*](https://www.w3schools.com/REACT/DEFAULT.ASP)
    and those created by the React team at [*https://<wbr>react<wbr>.dev<wbr>/learn<wbr>/tutorial<wbr>-tic<wbr>-tac<wbr>-toe*](https://react.dev/learn/tutorial-tic-tac-toe).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll work with Next.js. Built on top of React, Next.js
    is a production-ready full-stack web development framework for single-page applications.
  prefs: []
  type: TYPE_NORMAL
