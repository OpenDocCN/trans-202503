<html><head></head><body><section class="chapter" epub:type="chapter" id="wireless_attacks" title="Chapter&#xA0;15.&#xA0;Wireless Attacks"><div class="titlepage"><div><div><h2 class="title">Chapter 15. Wireless Attacks</h2></div></div></div><p><a class="indexterm" id="iddle2090"/><a class="indexterm" id="iddle2503"/><a class="indexterm" id="iddle2506"/>In this chapter we’ll take a brief look at wireless security. So far we’ve looked at several ways to breach the security perimeter. But web application security, firewalls, security-awareness training, and so on can do nothing to protect an internal network if there’s an attacker sitting on a bench in front of the target organization’s building and the organization provides wireless access with weak encryption to the internal network.</p><div class="sect1" title="Setting Up"><div class="titlepage"><div><div><h2 class="title" id="setting_up" style="clear: both">Setting Up</h2></div></div></div><p>For the examples in this chapter, I’ll be using a Linksys WRT54G2 wireless router, but any router that supports WEP and WPA2 encryption will work. By default, my Linksys router has a web administration interface at <span class="emphasis"><em>http://192.168.20.1</em></span>, as shown in <a class="xref" href="ch15.xhtml#linksys_wrt54g2_web_interface" title="Figure 15-1. Linksys WRT54G2 web interface">Figure 15-1</a>. The default username and <a class="indexterm" id="iddle1570"/><a class="indexterm" id="iddle1616"/><a class="indexterm" id="iddle2507"/>password for the router is <span class="emphasis"><em>admin:admin</em></span>. The default credentials vary from device to device, but it’s common on penetration tests to find routing equipment that still uses the default credentials—a failing that could allow attackers to gain administrative control over the routers.</p><div class="note" title="Note"><h3 class="title"><a id="ch15note01"/>Note</h3><p>We won’t cover attacking networking devices in this book, but take a look at the administrative interfaces on any networking equipment you have. Attacker access to enterprise network devices can do significant damage and should not be overlooked.</p></div><div class="figure"><a id="linksys_wrt54g2_web_interface"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00148"/><img alt="Linksys WRT54G2 web interface" src="httpatomoreillycomsourcenostarchimages2030486.png.jpg"/></div></div><div class="figure-title">Figure 15-1. Linksys WRT54G2 web interface</div></div><p>I’ll also be using an Alfa Networks AWUS036H USB wireless card. This card, and similar Alfa USB models, are ideal for wireless security assessments, particularly when working with virtual machines. VMware doesn’t have drivers for wireless cards, but it is capable of USB passthrough, allowing us to use the wireless drivers built into Kali Linux from a virtual machine. The use of a USB wireless card will allow us to assess wireless networks from our virtual machine.</p><div class="sect2" title="Viewing Available Wireless Interfaces"><div class="titlepage"><div><div><h3 class="title" id="viewing_available_wireless_interfaces">Viewing Available Wireless Interfaces</h3></div></div></div><p>After attaching the Alfa wireless card to the Kali virtual machine, enter <span class="strong"><strong><code class="literal">iwconfig</code></strong></span> to see the wireless interfaces available on your virtual machine. Note in my case that the Alfa card is attached as <code class="literal">wlan0</code> ❶, as shown in <a class="xref" href="ch15.xhtml#kali_linux_wireless_interfaces" title="Example 15-1. Kali Linux wireless interfaces">Example 15-1</a>.</p><div class="example"><a id="kali_linux_wireless_interfaces"/><div class="example-title">Example 15-1. Kali Linux wireless interfaces</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>iwconfig</strong></span>&#13;
wlan0❶   IEEE 802.11bg  ESSID:off/any&#13;
          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm&#13;
          Retry  long limit:7   RTS thr:off   Fragment thr:off&#13;
          Encryption key:off&#13;
          Power Management:off&#13;
&#13;
lo        no wireless extensions.&#13;
&#13;
eth0      no wireless extensions.</pre></div></div></div><div class="sect2" title="Scan for Access Points"><div class="titlepage"><div><div><h3 class="title" id="scan_for_access_points">Scan for Access Points</h3></div></div></div><p><a class="indexterm" id="iddle1032"/><a class="indexterm" id="iddle1571"/><a class="indexterm" id="iddle2505"/><a class="indexterm" id="iddle2512"/>Now we can scan for nearby access points. The command <code class="literal">iwlist wlan0 scan</code> will scan for nearby access points using the <code class="literal">wlan0</code> interface, as shown in <a class="xref" href="ch15.xhtml#scanning_for_nearby_wireless_access_poin" title="Example 15-2. Scanning for nearby wireless access points">Example 15-2</a>.</p><div class="example"><a id="scanning_for_nearby_wireless_access_poin"/><div class="example-title">Example 15-2. Scanning for nearby wireless access points</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>iwlist wlan0 scan</strong></span>&#13;
  Cell 02 - Address: 00:23:69:F5:B4:2B❶&#13;
                    Channel:6❷&#13;
                    Frequency:2.437 GHz (Channel 6)&#13;
                    Quality=47/70  Signal level=-63 dBm&#13;
                    Encryption key:off❸&#13;
                    ESSID:"linksys"❹&#13;
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s&#13;
                              9 Mb/s; 14 Mb/s; 18 Mb/s&#13;
                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s&#13;
                    Mode:Master&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>From this initial scan we gather almost all the information we’ll need in order to attack the base station, as you’ll see later in the chapter. We have its MAC address ❶, the channel it’s broadcasting on ❷, we learn that it’s not using encryption at this time ❸, and we have its SSID ❹.</p></div></div><div class="sect1" title="Monitor Mode"><div class="titlepage"><div><div><h2 class="title" id="monitor_mode" style="clear: both">Monitor Mode</h2></div></div></div><p>Before proceeding, let’s put our Alfa card into <span class="emphasis"><em>monitor mode</em></span>. Much like promiscuous mode in Wireshark, monitor mode allows us to see additional wireless traffic on top of the traffic intended for our wireless card. We’ll use the <span class="emphasis"><em>Airmon-ng</em></span> script, part of the Aircrack-ng wireless assessment suite, to put the Alfa card into monitor mode. First, make sure that no running processes will interfere with monitor mode by entering <span class="strong"><strong><code class="literal">airmon-ng check</code></strong></span>, as shown in <a class="xref" href="ch15.xhtml#checking_for_interfering_processes" title="Example 15-3. Checking for interfering processes">Example 15-3</a>.</p><div class="example"><a id="checking_for_interfering_processes"/><div class="example-title">Example 15-3. Checking for interfering processes</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airmon-ng check</strong></span>&#13;
Found 2 processes that could cause trouble.&#13;
If airodump-ng, aireplay-ng or airtun-ng stops working after&#13;
a short period of time, you may want to kill (some of) them!&#13;
-e&#13;
PID     Name&#13;
2714    NetworkManager&#13;
5664    wpa_supplicant</pre></div></div><p><a class="indexterm" id="iddle1031"/><a class="indexterm" id="iddle1033"/><a class="indexterm" id="iddle1167"/><a class="indexterm" id="iddle2504"/>As you can see, Airmon found two running processes that could interfere. Depending on your wireless card and its drivers, you may or may not run into any trouble if you don’t kill off these programs. The card we’re using shouldn’t have trouble, but some USB wireless cards do. To kill all interfering processes in one step, enter <span class="strong"><strong><code class="literal">airmon-ng check kill</code></strong></span>, as shown in <a class="xref" href="ch15.xhtml#killing_interfering_processes" title="Example 15-4. Killing interfering processes">Example 15-4</a>.</p><div class="example"><a id="killing_interfering_processes"/><div class="example-title">Example 15-4. Killing interfering processes</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airmon-ng check kill</strong></span>&#13;
Found 2 processes that could cause trouble.&#13;
If airodump-ng, aireplay-ng or airtun-ng stops working after&#13;
a short period of time, you may want to kill (some of) them!&#13;
-e&#13;
PID     Name&#13;
2714    NetworkManager&#13;
5664    wpa_supplicant&#13;
Killing all those processes...</pre></div></div><p>Now enter <span class="strong"><strong><code class="literal">airmon-ng start wlan0</code></strong></span> to switch the wireless interface into monitor mode, as shown in <a class="xref" href="ch15.xhtml#putting_the_alfa_card_in_monitor_mode" title="Example 15-5. Putting the Alfa card in monitor mode">Example 15-5</a>. This will allow us to capture packets not intended for us. Airmon-ng creates the wireless interface <code class="literal">mon0</code> ❶.</p><div class="example"><a id="putting_the_alfa_card_in_monitor_mode"/><div class="example-title">Example 15-5. Putting the Alfa card in monitor mode</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airmon-ng start wlan0</strong></span>&#13;
Interface    Chipset             Driver&#13;
wlan0        Realtek RTL8187L    rtl8187 - [phy0]&#13;
             (monitor mode enabled on mon0) ❶</pre></div></div></div><div class="sect1" title="Capturing Packets"><div class="titlepage"><div><div><h2 class="title" id="capturing_packets" style="clear: both">Capturing Packets</h2></div></div></div><p>With our interface in monitor mode, let’s see what data we can gather using Airodump-ng from the Aircrack-ng suite. Airodump-ng is used to capture and save wireless packets. <a class="xref" href="ch15.xhtml#starting_a_packet_dump_with_airodump-ng" title="Example 15-6. Starting a packet dump with Airodump-ng">Example 15-6</a> shows how we tell Airodump-ng to use the wireless interface in monitor mode <code class="literal">mon0</code>.</p><div class="example"><a id="starting_a_packet_dump_with_airodump-ng"/><div class="example-title">Example 15-6. Starting a packet dump with Airodump-ng</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airodump-ng mon0 --channel 6</strong></span>&#13;
 CH  6 ][ Elapsed: 28 s ][ 2015-05-19 20:08&#13;
&#13;
 BSSID                 PWR    Beacons    #Data, #/s   CH   MB   ENC  CIPHER AUTH ESSID&#13;
&#13;
 00:23:69:F5:B4:2B❶   -30         53        2    0    6   54 . OPN❷             linksys❸&#13;
 BSSID               STATION               PWR   Rate    Lost    Frames   Probe&#13;
&#13;
 00:23:69:F5:B4:2B   70:56:81:B2:F0:53❹   -21   0       -54     42       19</pre></div></div><p><a class="indexterm" id="iddle1867"/><a class="indexterm" id="iddle2042"/><a class="indexterm" id="iddle2080"/><a class="indexterm" id="iddle2451"/><a class="indexterm" id="iddle2499"/><a class="indexterm" id="iddle2510"/><a class="indexterm" id="iddle2513"/>The Airodump-ng output gathers information about the wireless packets, including the base service set identification (BSSID), which is the base station’s MAC address ❶. We also see additional information such as the encryption algorithm used for wireless security ❷ and the Service Set Identification (SSID) ❸. Airodump-ng also picks up the MAC addresses of connected clients ❹ and the MAC address of my host machine attached to the wireless access point. (We’ll examine the other fields in the Airodump-ng output as we move through cracking wireless security later in the chapter.)</p><p>Now we know the Linksys access point is open, with no security.</p></div><div class="sect1" title="Open Wireless"><div class="titlepage"><div><div><h2 class="title" id="open_wireless" style="clear: both">Open Wireless</h2></div></div></div><p>Open wireless networks are a real disaster from a security perspective because anyone within antenna range of the access point can connect to that network. While open networks could require authentication after connection, and some do, many just let anyone connect.</p><p>Also, the wireless packets traveling through an open network are not encrypted, and anyone listening can see any data in plaintext. Sensitive data may be secured by protocols like SSL, but that’s not always the case. For instance, FTP traffic on an open wireless network is completely unencrypted, including login information, and we don’t even need to use ARP or DNS cache poisoning to capture the packets. Any wireless card in monitor mode will be able to see the unencrypted traffic.</p><p>Now let’s look at attacking networks that deploy various security protocols that keep unwanted entities from connecting to the network and intercepting traffic.</p></div><div class="sect1" title="Wired Equivalent Privacy"><div class="titlepage"><div><div><h2 class="title" id="wired_equivalent_privacy" style="clear: both">Wired Equivalent Privacy</h2></div></div></div><p>Many routers that come with encryption enabled use older encryption called <span class="emphasis"><em>wired equivalent privacy (WEP)</em></span> by default. The fundamental problem with WEP is that flaws in its algorithm make it possible for an attacker to recover any WEP key. WEP uses the Rivest Cipher 4 (RC4) stream cipher and a pre-shared key. Anyone who wants to connect to the network can use the same key, made up of a string of hexadecimal digits, for both encryption and decryption. The plaintext (unencrypted) data undergoes an exclusive or (XOR) bitwise operation with the keystream to create encrypted ciphertext.</p><p><a class="indexterm" id="iddle1112"/><a class="indexterm" id="iddle1513"/><a class="indexterm" id="iddle1568"/>The bitwise XOR operation has four possibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>0 XOR 0 = 0</p></li><li class="listitem"><p>1 XOR 0 = 1</p></li><li class="listitem"><p>0 XOR 1 = 1</p></li><li class="listitem"><p>1 XOR 1 = 0</p></li></ul></div><p>The zeros and ones in the bitstream in <a class="xref" href="ch15.xhtml#wep_encryption" title="Figure 15-2. WEP encryption">Figure 15-2</a> and <a class="xref" href="ch15.xhtml#wep_decryption" title="Figure 15-3. WEP decryption">Figure 15-3</a> can represent any data being sent over the network. <a class="xref" href="ch15.xhtml#wep_encryption" title="Figure 15-2. WEP encryption">Figure 15-2</a> shows how the plaintext is XORed with the keystream to create the ciphertext.</p><div class="figure"><a id="wep_encryption"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00149"/><img alt="WEP encryption" src="httpatomoreillycomsourcenostarchimages2030488.png"/></div></div><div class="figure-title">Figure 15-2. WEP encryption</div></div><p>When decrypted, the same keystream is XORed against the ciphertext to restore the original plaintext, as shown in <a class="xref" href="ch15.xhtml#wep_decryption" title="Figure 15-3. WEP decryption">Figure 15-3</a>.</p><div class="figure"><a id="wep_decryption"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00150"/><img alt="WEP decryption" src="httpatomoreillycomsourcenostarchimages2030490.png"/></div></div><div class="figure-title">Figure 15-3. WEP decryption</div></div><p>The shared WEP key can be either 64 or 148 bits. In either case, an initialization vector (IV) makes up the first 24 bits of the key to add randomness, making the effective key length really only 40 or 104 bits. Adding randomness with an IV is common in cryptographic systems because if the same key is used repeatedly, attackers can examine the resulting ciphertext for patterns and potentially break the encryption.</p><div class="note" title="Note"><h3 class="title"><a id="ch15note02"/>Note</h3><p><a class="indexterm" id="iddle1600"/><a class="indexterm" id="iddle1993"/><a class="indexterm" id="iddle2009"/>Cryptanalysts often find that randomness is not correctly implemented in cryptographic algorithms, as is the case with WEP. For starters, WEP’s 24 bits of randomization is minimal by modern cryptographic standards.</p></div><p>The IV and key are concatenated, then run through a key-scheduling algorithm (KSA) and a pseudorandom number generator (PRNG) to create the keystream. (I’ll skip the math here.) Next, an integrity check value (ICV) is computed and concatenated with the plaintext before encryption in order to prevent attackers from intercepting the ciphertexts, flipping some bits, and changing the resulting decrypted plaintext to something malicious or, at least, misleading. The plaintext is then XORed with the keystream (as shown in <a class="xref" href="ch15.xhtml#wep_encryption" title="Figure 15-2. WEP encryption">Figure 15-2</a>). The resulting packet is made up of the IV, the ICV, the ciphertext, and a two-bit key ID, as shown in <a class="xref" href="ch15.xhtml#wep_encryption-id00041" title="Figure 15-4. WEP encryption">Figure 15-4</a>.</p><div class="figure"><a id="wep_encryption-id00041"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00151"/><img alt="WEP encryption" src="httpatomoreillycomsourcenostarchimages2030492.png.jpg"/></div></div><div class="figure-title">Figure 15-4. WEP encryption</div></div><p><a class="indexterm" id="iddle1217"/><a class="indexterm" id="iddle1242"/><a class="indexterm" id="iddle2502"/>Decryption is similar, as shown in <a class="xref" href="ch15.xhtml#wep_decryption-id00042" title="Figure 15-5. WEP decryption">Figure 15-5</a>. The IV and key (denoted by the key ID), stored in plaintext as part of the packet, are concatenated and run through the same key-scheduling algorithm and pseudorandom number generators to create a keystream identical to the one used for encryption. The ciphertext is then XORed with the keystream to reveal the plaintext and the ICV. Finally, the decrypted ICV is compared with the plaintext ICV value appended to the packet. If the values don’t match, the packet is thrown out.</p><div class="figure"><a id="wep_decryption-id00042"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00152"/><img alt="WEP decryption" src="httpatomoreillycomsourcenostarchimages2030494.png.jpg"/></div></div><div class="figure-title">Figure 15-5. WEP decryption</div></div><div class="sect2" title="WEP Weaknesses"><div class="titlepage"><div><div><h3 class="title" id="wep_weaknesses">WEP Weaknesses</h3></div></div></div><p>Unfortunately, WEP has some inherent problems that allow an attacker to recover a key or alter legitimate packets. In fact, every WEP key is recoverable by an attacker armed with enough ciphertexts encrypted with the same shared key. The only cryptosystem that is truly secure is a random one-time pad, which uses a specific key only once. The main trouble with WEP is that the 24-bit IV doesn’t introduce enough randomness; it has at most 2<sup>24</sup> (that is, 16,777,216) values.</p><p>There is no standard way for wireless cards and access points to compute IVs, and in practice, the IV space used may be even smaller. Either way, given enough packets, IVs will be reused, and the same value (static key concatenated with the IV) will be used to generate the ciphertext. By passively listening for traffic (or better yet, injecting traffic into the network to force more packets and, thus, more IVs to be generated), an attacker can gather enough packets to perform cryptanalysis and recover the key.</p><p>Similarly, the ICV that attempts to keep attackers from intercepting the encrypted message, flipping bits, and changing the resulting plaintext is insufficient. Unfortunately, weaknesses in the ICV implementation Cyclic Redundancy Check 32 (CRC-32) may allow attackers to craft the correct ICV for a modified message. Because CRC-32 is a linear algorithm, flipping a specific bit in the ciphertext has a deterministic result on the resulting ICV, and an attacker with knowledge of how CRC-32 is calculated could cause a modified message to be accepted. Thus, the ICV implementation, like the IV, is not considered sound by modern cryptographic standards.</p><p>We can use the Aircrack-ng suite to recover the shared key from a wireless network secured with WEP. Again, the math behind the cryptographic attacks is beyond the scope of this book. Luckily, we have tools that will take care of the hard stuff if we can capture the required traffic.</p></div><div class="sect2" title="Cracking WEP Keys with Aircrack-ng"><div class="titlepage"><div><div><h3 class="title" id="cracking_wep_keys_with_aircrack-ng">Cracking WEP Keys with Aircrack-ng</h3></div></div></div><p><a class="indexterm" id="iddle1027"/><a class="indexterm" id="iddle1034"/><a class="indexterm" id="iddle1083"/><a class="indexterm" id="iddle1394"/><a class="indexterm" id="iddle2501"/>There are multiple ways to crack WEP keys, including the fake authentication attack, fragmentation attack, chopchop attack, caffé latte attack, and PTW attack. We’ll take a closer look at the fake authentication attack, which requires at least one legitimate client connected to the access point.</p><p>We’ll use the host system to simulate an attached client. First, change the wireless security on your router to WEP (see your user guide if you need help), and then make sure your wireless card is in monitor mode so that you can capture traffic from the network without first authenticating.</p><p>Now to see what data we can collect using the Airodump-ng tool from Aircrack-ng. Tell Airodump-ng to use the wireless interface in monitor mode <code class="literal">mon0</code>, as shown in <a class="xref" href="ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi" title="Example 15-7. Airodump-ng capture for WEP cryptanalysis">Example 15-7</a>, and use the <code class="literal">-w</code> flag to save all packets to a file.</p><div class="example"><a id="airodump-ng_capture_for_wep_cryptanalysi"/><div class="example-title">Example 15-7. Airodump-ng capture for WEP cryptanalysis</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airodump-ng -w book mon0 --channel 6</strong></span>&#13;
 CH  6 ][ Elapsed: 20 s ][ 2015-03-06 19:08&#13;
 BSSID                 PWR    Beacons    #Data, #/s   CH    MB   ENC    CIPHER AUTH ESSID&#13;
 00:23:69:F5:B4:2B❶   -53         22         6   0    6❷  54 . WEP❸  WEP         linksys❹&#13;
 BSSID                 STATION               PWR   Rate    Lost    Frames   Probe&#13;
 00:23:69:F5:B4:2B     70:56:81:B2:F0:53     -26   54-54      0         6</pre></div></div><p>This initial scan gathers all the information we need to begin a WEP attack against the base station. Here we have the BSSID ❶, wireless channel ❷, encryption algorithm ❸, and the SSID ❹. We’ll use this information to gather the packets to crack the WEP key. Your own setup’s information is likely different, of course, but here’s what we’ll work with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Base Station MAC Address</strong></span>: 00:23:69:F5:B4:2B</p></li><li class="listitem"><p><span class="strong"><strong>SSID</strong></span>: linksys</p></li><li class="listitem"><p><span class="strong"><strong>Channel</strong></span>: 6</p></li></ul></div><div class="sect3" title="Injecting Packets"><div class="titlepage"><div><div><h4 class="title" id="injecting_packets">Injecting Packets</h4></div></div></div><p>Although the Airodump-ng output in <a class="xref" href="ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi" title="Example 15-7. Airodump-ng capture for WEP cryptanalysis">Example 15-7</a> shows some traffic from the access point, to crack a 64-bit WEP key, we need about 250,000 IVs, and for a 148-bit WEP key, about 1,500,000. Rather than idly listen for packets, we’ll capture and retransmit packets to the access point to generate unique IVs quickly. We need to authenticate, because if our MAC address isn’t authenticated with the access point, any packets we send will be dropped, and we’ll receive a deauthentication request. We’ll use Aireplay-ng to fake authentication with the access point and trick it into responding to our injected packets.</p><p>When using fake authentication, we tell the access point we’re ready to prove we know the WEP key, as shown in <a class="xref" href="ch15.xhtml#fake_authentication_with_aireplay-ng" title="Example 15-8. Fake authentication with Aireplay-ng">Example 15-8</a>. Of course, because we don’t know the key yet, we don’t send it, but our MAC address is now on the list of clients that can send packets to the access point, hence the fake authentication.</p><div class="example"><a id="fake_authentication_with_aireplay-ng"/><div class="example-title">Example 15-8. Fake authentication with Aireplay-ng</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>aireplay-ng -1 0 -e linksys -a 00:23:69:F5:B4:2B -h 00:C0:CA:1B:69:AA mon0</strong></span>&#13;
20:02:56  Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6&#13;
&#13;
20:02:56  Sending Authentication Request (Open System) [ACK]&#13;
20:02:56  Authentication successful&#13;
20:02:56  Sending Association Request [ACK]&#13;
20:02:56  Association successful :-) (AID: 1) ❶</pre></div></div><p><a class="indexterm" id="iddle1030"/><a class="indexterm" id="iddle1075"/><a class="indexterm" id="iddle1514"/><a class="indexterm" id="iddle1569"/>We fake authentication using the following flags with their associated data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong><code class="literal">-1</code></strong></span> tells Aireplay-ng to fake authentication.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">0</code></strong></span> is the retransmission time.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-e</code></strong></span> is the SSID; in my case <code class="literal">linksys</code>.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-a</code></strong></span> is the MAC address of the access point we want to authenticate with.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-h</code></strong></span> is the MAC address of our card (which should be on a sticker on the device).</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">mon0</code></strong></span> is the interface to use for the fake authentication.</p></li></ul></div><p>After sending the Aireplay-ng request, you should receive a smiley face and indication that authentication was successful ❶.</p></div><div class="sect3" title="Generating IVs with the ARP Request Relay Attack"><div class="titlepage"><div><div><h4 class="title" id="generating_ivs_with_the_arp_request_rela">Generating IVs with the ARP Request Relay Attack</h4></div></div></div><p>With the base station willing to accept packets from us, we can capture and rebroadcast legitimate packets. While the access point won’t allow us to send traffic without first sending the WEP key to authenticate, we can rebroadcast traffic from properly authenticated clients.</p><p>We’ll use the attack technique known as <span class="emphasis"><em>ARP Request Replay</em></span> to generate IVs quickly by having Aireplay-ng listen for an ARP request and then retransmit it back to the base station. (When the access point receives an ARP request, it rebroadcasts it with a new IV.) Aireplay-ng will rebroadcast the same ARP packet repeatedly, and each time it’s broadcast, it will have a new IV.</p><p><a class="xref" href="ch15.xhtml#rebroadcasting_arp_packets_with_aireplay" title="Example 15-9. Rebroadcasting ARP packets with Aireplay-ng">Example 15-9</a> shows the attack in action. Aireplay-ng reads packets looking for an ARP request. You won’t see any data until Aireplay-ng sees an ARP request it can rebroadcast. We will see that next.</p><div class="example"><a id="rebroadcasting_arp_packets_with_aireplay"/><div class="example-title">Example 15-9. Rebroadcasting ARP packets with Aireplay-ng</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>aireplay-ng -3 -b 00:23:69:F5:B4:2B -h 00:C0:CA:1B:69:AA mon0</strong></span>&#13;
20:14:21  Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6&#13;
Saving ARP requests in replay_arp-1142-201521.cap&#13;
You should also start airodump-ng to capture replies.&#13;
Read 541 packets (got 0 ARP requests and 0 ACKs), sent 0 packets...(0 pps)</pre></div></div><p><a class="indexterm" id="iddle1074"/>We use these options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong><code class="literal">-3</code></strong></span> performs the ARP request replay attack.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-b</code></strong></span> is the base station MAC address.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-h</code></strong></span> is our Alfa card MAC address.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">mon0</code></strong></span> is the interface.</p></li></ul></div></div><div class="sect3" title="Generating an ARP Request"><div class="titlepage"><div><div><h4 class="title" id="generating_an_arp_request">Generating an ARP Request</h4></div></div></div><p>Unfortunately, as you can see in <a class="xref" href="ch15.xhtml#rebroadcasting_arp_packets_with_aireplay" title="Example 15-9. Rebroadcasting ARP packets with Aireplay-ng">Example 15-9</a>, we don’t see any ARP requests. To generate an ARP request, we’ll use the host system as a simulated client by pinging an IP address on the network from the connected host system. Aireplay-ng will see the ARP request and retransmit it to the access point over and over.</p><p>As you can see in the Airodump-ng screen, shown in <a class="xref" href="ch15.xhtml#ivs_being_captured_in_airodump-ng" title="Example 15-10. IVs being captured in Airodump-ng">Example 15-10</a>, the <code class="literal">#Data</code> ❶ number, indicating captured IVs, increases rapidly as Aireplay-ng continues to retransmit the ARP packet, causing the access point to generate more IVs. (If your <code class="literal">aireplay-ng -3</code> says <code class="literal">"Got adeauth/disassoc"</code> or something similar and your <code class="literal">#Data</code> number is not quickly rising, run the fake association command from <a class="xref" href="ch15.xhtml#fake_authentication_with_aireplay-ng" title="Example 15-8. Fake authentication with Aireplay-ng">Example 15-8</a> again to reassociate with the access point. Your <code class="literal">#Data</code> field should again start rising rapidly.)</p><div class="example"><a id="ivs_being_captured_in_airodump-ng"/><div class="example-title">Example 15-10. IVs being captured in Airodump-ng</div><div class="example-contents"><pre class="programlisting">CH  6 ][ Elapsed: 14 mins ][ 2015-11-22 20:31&#13;
&#13;
BSSID               PWR  RXQ  Beacons    #Data, #/s    CH   MB   ENC    CIPHER AUTH ESSID&#13;
&#13;
00:23:69:F5:B4:2B   -63   92     5740    85143❶ 389     6   54 . WEP    WEP   OPN  linksys</pre></div></div></div><div class="sect3" title="Cracking the Key"><div class="titlepage"><div><div><h4 class="title" id="cracking_the_key">Cracking the Key</h4></div></div></div><p>Remember, we need about 250,000 IVs to crack a 64-bit WEP key. As long as you remain associated with the base station, as shown in <a class="xref" href="ch15.xhtml#fake_authentication_with_aireplay-ng" title="Example 15-8. Fake authentication with Aireplay-ng">Example 15-8</a>, (rerunning the command if it becomes necessary) and have generated an ARP request on the network, it should only take a few minutes to collect enough IVs. Once we’ve gathered enough IVs, we can use Aircrack-ng to do the math to turn the collected IVs into the correct WEP key. <a class="xref" href="ch15.xhtml#recovering_the_wep_key_with_aircrack-ng" title="Example 15-11. Recovering the WEP key with Aircrack-ng">Example 15-11</a> shows how we crack the key by using the <code class="literal">-b</code> flag and providing the filename we used in Airodump-ng followed by <code class="literal">*.cap</code> ❶. This tells Aircrack-ng to read from all .<span class="emphasis"><em>cap</em></span> files saved by Airodump-ng.</p><div class="example"><a id="recovering_the_wep_key_with_aircrack-ng"/><div class="example-title">Example 15-11. Recovering the WEP key with Aircrack-ng</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>aircrack-ng -b 00:23:69:F5:B4:2B book*.cap</strong></span>❶&#13;
Opening book-01.cap&#13;
Attack will be restarted every 5000 captured ivs.&#13;
Starting PTW attack with 239400 ivs.&#13;
KEY FOUND! [ 2C:85:8B:B6:31 ] ❷&#13;
Decrypted correctly: 100%</pre></div></div><p><a class="indexterm" id="iddle1650"/><a class="indexterm" id="iddle1722"/><a class="indexterm" id="iddle2286"/><a class="indexterm" id="iddle2308"/><a class="indexterm" id="iddle2456"/><a class="indexterm" id="iddle2458"/><a class="indexterm" id="iddle2500"/><a class="indexterm" id="iddle2508"/><a class="indexterm" id="iddle2522"/>After a few seconds of analysis Aircrack-ng returns the correct key ❷. We can now authenticate with the network. If this were a pentest client’s network, we could now directly attack any systems on the network.</p></div><div class="sect3" title="Challenges with WEP Cracking"><div class="titlepage"><div><div><h4 class="title" id="challenges_with_wep_cracking">Challenges with WEP Cracking</h4></div></div></div><p>As with many topics discussed in this book, information about wireless attacks could fill a book, and I’ve shown you only one attack. One thing to keep in mind when attacking WEP is that clients may use filters in an attempt to thwart attacks like this. For example, access points could use MAC filtering to allow only wireless cards with certain MAC addresses to connect, and if your Alfa card isn’t on the list, your fake authentication attempt will fail. To bypass MAC filtering, you could use a tool like MAC Changer in Kali to spoof a MAC address and create an accepted value. Keep in mind that WEP keys are always crackable if we can gather enough packets, and for security reasons, WEP encryption should not be used in production.</p><p>It’s worth noting that the Wifite tool, installed by default in Kali Linux, behaves as a wrapper around the Aircrack-ng suite and will automate the process of attacking wireless networks, including cracking WEP. But while you are learning how Wi-Fi attacks work, it is better to walk through the process step by step instead of using an automation wrapper.</p><p>We now turn our attention to the stronger wireless encryption protocols, WPA and WPA2.</p></div></div></div><div class="sect1" title="Wi-Fi Protected Access"><div class="titlepage"><div><div><h2 class="title" id="wi-fi_protected_access" style="clear: both">Wi-Fi Protected Access</h2></div></div></div><p>As weaknesses in WEP came to light, a more robust wireless security system was needed and a new system (which ultimately became WPA2) was built to replace WEP. However, the creation of a secure cryptographic system for wireless took time, and in the meantime, additional security was needed that was compatible with deployed wireless hardware. Thus, <span class="emphasis"><em>Wi-Fi Protected Access (WPA)</em></span>, also known as <span class="emphasis"><em>Temporal Key Integrity Protocol (TKIP)</em></span>, was born.</p><p>WPA uses the same underlying algorithm as WEP (RC4) but seeks to address WEP’s weaknesses by adding keystream randomness to IVs and integrity to ICV. Unlike WEP, which uses a 40 or 104-bit key combined with weak IVs for each packet, WPA generates a 148-bit key for each packet to ensure that each packet is encrypted with a unique keystream.</p><p>Additionally, WPA replaces WEP’s weak CRC-32 message integrity check with a message authentication code (MAC) algorithm called <span class="emphasis"><em>Michael</em></span>, to prevent attackers from easily calculating the resulting changes to the ICV when a bit is flipped. Though both WPA and even WPA2 have their weaknesses, the most common vulnerability (which we’ll exploit later in this chapter) is the use of weak passphrases.</p></div><div class="sect1" title="WPA2"><div class="titlepage"><div><div><h2 class="title" id="wpa2" style="clear: both">WPA2</h2></div></div></div><p><a class="indexterm" id="iddle1170"/><a class="indexterm" id="iddle1208"/><a class="indexterm" id="iddle1334"/><a class="indexterm" id="iddle1415"/><a class="indexterm" id="iddle1931"/><a class="indexterm" id="iddle2031"/><a class="indexterm" id="iddle2054"/><a class="indexterm" id="iddle2511"/><a class="indexterm" id="iddle2523"/><a class="indexterm" id="iddle2526"/><a class="indexterm" id="iddle2528"/>WPA2 was built from the ground up to provide a secure encryption system for wireless networks. It implements an encryption protocol built specifically for wireless security called <span class="emphasis"><em>Counter Mode with Cipher Block Chaining Message Authentication Code Protocol (CCMP)</em></span>. CCMP is built on the Advanced Encryption Standard (AES).</p><p>WPA and WPA2 support both personal and enterprise setups. WPA/WPA2 personal uses a pre-shared key, similar to WEP. WPA/WPA2 enterprise adds an additional element called a <span class="emphasis"><em>Remote Authentication Dial-In User Service (RADIUS) server</em></span> to manage client authentication.</p><div class="sect2" title="The Enterprise Connection Process"><div class="titlepage"><div><div><h3 class="title" id="enterprise_connection_process">The Enterprise Connection Process</h3></div></div></div><p>In WPA/WPA2 enterprise networks, the client connection process comprises four steps, as shown in <a class="xref" href="ch15.xhtml#wpasoliduswpa2_enterprise_connection" title="Figure 15-6. WPA/WPA2 enterprise connection">Figure 15-6</a>. First the client and the access point agree on mutually supported security protocols. Then, based on the authentication protocol chosen, the access point and the RADIUS server exchange messages to generate a master key. Once a master key is generated, a message that authentication was successful is sent to the access point and passed on to the client, and the master key is sent to the access point. The access point and the client exchange and verify keys for mutual authentication, message encryption, and message integrity via a four-way handshake, as discussed in <a class="xref" href="ch15.xhtml#four-way_handshake" title="The Four-Way Handshake">The Four-Way Handshake</a> on this page. Following key exchange, traffic between the client and the access point is secured with WPA or WPA2.</p><div class="figure"><a id="wpasoliduswpa2_enterprise_connection"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00153"/><img alt="WPA/WPA2 enterprise connection" src="httpatomoreillycomsourcenostarchimages2030496.png.jpg"/></div></div><div class="figure-title">Figure 15-6. WPA/WPA2 enterprise connection</div></div></div><div class="sect2" title="The Personal Connection Process"><div class="titlepage"><div><div><h3 class="title" id="personal_connection_process">The Personal Connection Process</h3></div></div></div><p>The WPA/WPA2 personal connection process is slightly simpler than the enterprise one: No RADIUS server is required, and the entire process is between the access point and the client. No authentication or master key step occurs, and instead of a RADIUS server and master key, WPA/WPA2 personal use pre-shared keys, which are generated using pre-shared passphrases.</p><p>The WPA/WPA2 personal passphrase that you enter when you connect to a secured network is static, whereas enterprise setups use dynamic keys generated by the RADIUS server. Enterprise setups are more secure, but most personal networks and even most small businesses lack RADIUS servers.</p></div><div class="sect2" title="The Four-Way Handshake"><div class="titlepage"><div><div><h3 class="title" id="four-way_handshake">The Four-Way Handshake</h3></div></div></div><p><a class="indexterm" id="iddle1416"/><a class="indexterm" id="iddle1455"/><a class="indexterm" id="iddle1877"/><a class="indexterm" id="iddle1878"/><a class="indexterm" id="iddle1921"/><a class="indexterm" id="iddle1948"/><a class="indexterm" id="iddle2011"/><a class="indexterm" id="iddle2527"/>In the first phase of the connection between an access point and supplicant (client), a pairwise master key (PMK), which is static throughout the entire session, is created. This is not the key that will be used for encryption itself, but it will be used during the second phase, where a four-way handshake will take place between access point and client, with the purpose of establishing a channel of communication and exchanging the encryption keys used for further data communication, as shown in <a class="xref" href="ch15.xhtml#wpasoliduswpa2_four-way_handshake" title="Figure 15-7. WPA/WPA2 four-way handshake">Figure 15-7</a>.</p><div class="figure"><a id="wpasoliduswpa2_four-way_handshake"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00154"/><img alt="WPA/WPA2 four-way handshake" src="httpatomoreillycomsourcenostarchimages2030498.png.jpg"/></div></div><div class="figure-title">Figure 15-7. WPA/WPA2 four-way handshake</div></div><p>This PMK is generated from the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The passphrase (pre-shared key, or PSK)</p></li><li class="listitem"><p>The access point’s SSID</p></li><li class="listitem"><p>The SSID length</p></li><li class="listitem"><p>The number of hashing iterations (4096)</p></li><li class="listitem"><p>The resulting length in bits (256) of the generated shared key (PMK)</p></li></ul></div><p>These values are fed into a hashing algorithm called PBKDF2, which creates a 256-bit shared key (PMK). While your passphrase (PSK) may be <span class="emphasis"><em>GeorgiaIsAwesome</em></span>, this is not the PMK that will be used in a second phase. That said, anyone who knows the passphrase and the access point’s SSID can use the PBKDF2 algorithm to generate the correct PMK. During the four-way handshake, a pairwise transient key (PTK) is created and used to encrypt traffic between the access point and the client; a group transient key (GTK) is exchanged and used to encrypt broadcast traffic. The PTK is made up of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The shared key (the PMK)</p></li><li class="listitem"><p>A random number (nonce) from the access point (ANonce)</p></li><li class="listitem"><p>A nonce from the client (SNonce)</p></li><li class="listitem"><p>The MAC address of the client</p></li><li class="listitem"><p>The MAC address of the access point</p></li></ul></div><p>These values are fed into the PBKDF2 hashing algorithm to create the PTK.</p><p>To generate the PTK, the access point and the client exchange MAC addresses and nonces (random values). The static shared key (PMK) is never sent over the air, because both the access point and the client know the passphrase (PSK) and, thus, can generate the shared key independently.</p><p><a class="indexterm" id="iddle1028"/><a class="indexterm" id="iddle1681"/><a class="indexterm" id="iddle1721"/><a class="indexterm" id="iddle1880"/><a class="indexterm" id="iddle2524"/>The shared nonces and MAC addresses are used by both the client and the access point to generate the PTK. In the first step of the four-way handshake, the access point sends its nonce (ANonce). Next, the client chooses a nonce, generates the PTK, and sends its nonce (SNonce) to the access point. (The <span class="emphasis"><em>S</em></span> in SNonce stands for supplicant, another name for the client in a wireless setup.)</p><p>In addition to sending its nonce, the client sends a message integrity code (MIC) to guard against forgery attacks. In order to compute the correct MIC, the passphrase used to generate the pre-shared key must be correct, or the PTK will be wrong. The access point independently generates the PTK based on the SNonce and MAC address sent by the client, then checks the MIC sent by the client. If it’s correct, the client has authenticated successfully, and the access point sends over the GTK plus the MIC to the client.</p><p>In the fourth part of the handshake, the client acknowledges the GTK.</p></div><div class="sect2" title="Cracking WPA/WPA2 Keys"><div class="titlepage"><div><div><h3 class="title" id="cracking_wpasoliduswpa2_keys">Cracking WPA/WPA2 Keys</h3></div></div></div><p>Unlike WEP, the cryptographic algorithms used in WPA and WPA2 are robust enough to stop attackers from recovering the key simply by capturing enough traffic and performing cryptanalysis. The Achilles’ heel in WPA/WPA2 personal networks lies in the quality of the pre-shared key (passphrase) used. If the Windows <span class="emphasis"><em>Administrator</em></span> password you found during post exploitation is the same as the WPA or WPA2 personal passphrase or the passphrase is written on a whiteboard in the front office of the organization, it’s game over.</p><p>To try to guess a weak password, we first need to capture the four-way handshake for analysis. Recall that given the correct passphrase and the SSID of the access point, the PBKDF2 hashing algorithm can be used to generate the shared key (PMK). Given the PMK, we still need the ANonce, SNonce, and the MAC addresses of the access point and client to calculate the PTK. Of course, the PTK will differ for each client, because the nonces will differ in each four-way handshake, but if we can capture a four-way handshake from any legitimate client, we can use its MAC addresses and nonces to calculate the PTK for a given passphrase. For example, we can use the SSID and the passphrase <span class="emphasis"><em>password</em></span> to generate a PMK, then combine the generated PMK with the captured nonces and MAC addresses to calculate a PTK. If the MICs comes out like the ones in the captured handshake, we know that <span class="emphasis"><em>password</em></span> is the correct passphrase. This technique can be applied to a wordlist of possible passphrases to try to guess the correct passphrase. Luckily, if we can capture a four-way handshake and supply a wordlist, we have Aircrack-ng to take care of all the math.</p><div class="sect3" title="Using Aircrack-ng to Crack WPA/WPA2 Keys"><div class="titlepage"><div><div><h4 class="title" id="using_aircrack-ng_to_crack_wpasoliduswpa">Using Aircrack-ng to Crack WPA/WPA2 Keys</h4></div></div></div><p>To use Aircrack-ng to crack WPA/WPA2, first set up your wireless access point for WPA2 personal. Choose a pre-shared key (passphrase) and then connect your host system to your access point to simulate a real client.</p><p><a class="indexterm" id="iddle1029"/><a class="indexterm" id="iddle1179"/><a class="indexterm" id="iddle1417"/>To use a wordlist to try to guess the WPA2 pre-shared key (passphrase), we need to capture the four-way handshake. Enter <span class="strong"><strong><code class="literal">airodump-ng -c 6</code></strong></span> for the channel, <span class="strong"><strong><code class="literal">--bssid</code></strong></span> with the base station MAC address, <span class="strong"><strong><code class="literal">-w</code></strong></span> to specify the filename for output (use a different filename than you used in the WEP cracking example), and <span class="strong"><strong><code class="literal">mon0</code></strong></span> for the monitor interface, as shown in <a class="xref" href="ch15.xhtml#airodump-ng_for_wpa2_cracking" title="Example 15-12. Airodump-ng for WPA2 cracking">Example 15-12</a>.</p><div class="example"><a id="airodump-ng_for_wpa2_cracking"/><div class="example-title">Example 15-12. Airodump-ng for WPA2 cracking</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>airodump-ng -c 6 --bssid 00:23:69:F5:B4:2B -w pentestbook2 mon0</strong></span>&#13;
&#13;
 CH  6 ][ Elapsed: 4 s ][ 2015-05-19 16:31&#13;
&#13;
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH E&#13;
&#13;
 00:23:69:F5:B4:2B  -43 100       66      157   17   6  54 . WPA2 CCMP   PSK  l&#13;
&#13;
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe&#13;
&#13;
 00:23:69:F5:B4:2B  70:56:81:B2:F0:53  -33   54-54     15       168 ❶</pre></div></div><p>As you can see the host is connected ❶. To capture a four-way handshake, we can either wait for another wireless client to sign on or speed up the process by kicking a client off the network and forcing it to reconnect.</p><p>To force a client to reconnect, use Aireplay-ng to send a message to a connected client telling it that it is no longer connected to the access point. When the client reauthenticates, we’ll capture the four-way handshake between the client and access point. The Aireplay-ng options we’ll need are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong><code class="literal">-0</code></strong></span> means deauthentication.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">1</code></strong></span> is the number of deauthentication requests to send.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-a 00:14:6C:7E:40:80</code></strong></span> is the MAC address of the base station.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">-c 00:0F:B5:FD:FB:C2</code></strong></span> is the MAC address of the client to deauthenticate.</p></li></ul></div><p><a class="xref" href="ch15.xhtml#sending_a_deauthentication_request_to_a" title="Example 15-13. Sending a deauthentication request to a client">Example 15-13</a> shows the <code class="literal">aireplay-ng</code> command and the deauthentication request.</p><div class="example"><a id="sending_a_deauthentication_request_to_a"/><div class="example-title">Example 15-13. Sending a deauthentication request to a client</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>aireplay-ng -0 1 -a 00:23:69:F5:B4:2B -c 70:56:81:B2:F0:53 mon0</strong></span>&#13;
16:35:11  Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6&#13;
16:35:14  Sending 64 directed DeAuth. STMAC: [70:56:81:B2:F0:53] [24|66 ACKs]</pre></div></div><p>Now we return to the Airodump-ng window, as shown in <a class="xref" href="ch15.xhtml#wpa2_handshake_captured_in_airodump-ng" title="Example 15-14. WPA2 handshake captured in Airodump-ng">Example 15-14</a>.</p><div class="example"><a id="wpa2_handshake_captured_in_airodump-ng"/><div class="example-title">Example 15-14. WPA2 handshake captured in Airodump-ng</div><div class="example-contents"><pre class="programlisting">CH  6 ][ Elapsed: 2 mins ][ 2015-11-23 17:10 ][ WPA handshake: 00:23:69:F5:B4:2B ❶&#13;
&#13;
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID&#13;
&#13;
 00:23:69:F5:B4:2B  -51 100      774      363   18   6  54 . WPA2 CCMP   PSK  linksys&#13;
&#13;
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe&#13;
&#13;
 00:23:69:F5:B4:2B  70:56:81:B2:F0:53  -29   1 - 1     47       457</pre></div></div><p><a class="indexterm" id="iddle1418"/><a class="indexterm" id="iddle2519"/>If the Airodump-ng capture sees a four-way handshake with a client, it records it in the first line of the captured output ❶.</p><p>Once you’ve captured the WPA2 handshake, close Airodump-ng, and open the <span class="emphasis"><em>.cap</em></span> file in Wireshark with File4Open4<span class="emphasis"><em>filename.cap</em></span>. Once in Wireshark, filter for the <code class="literal">eapol</code> protocol to see the four packets that make up the handshake, as shown in <a class="xref" href="ch15.xhtml#wpa2_handshake_packets_in_wireshark" title="Figure 15-8. WPA2 handshake packets in Wireshark">Figure 15-8</a>.</p><div class="figure"><a id="wpa2_handshake_packets_in_wireshark"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00155"/><img alt="WPA2 handshake packets in Wireshark" src="httpatomoreillycomsourcenostarchimages2030500.png.jpg"/></div></div><div class="figure-title">Figure 15-8. WPA2 handshake packets in Wireshark</div></div><div class="note" title="Note"><h3 class="title"><a id="ch15note03"/>Note</h3><p>Sometimes Aircrack-ng will claim that the handshake has been captured, but when you look at the packets in Wireshark, you will see you do not have all four messages. If this is the case, run the deauthentication attack again, as you will need all four messages to attempt to guess the correct key.</p></div><p>Now we create a wordlist like the ones we used in <a class="xref" href="ch09.xhtml" title="Chapter 9. Password Attacks">Chapter 9</a>, making sure that the correct WPA2 key is included in the list. The success of our attack against WPA2 is contingent on our ability to compare the hashed values for our passphrase with the values in the handshake.</p><p>Once we have the handshake, we can do the rest of the calculations to recover the key offline; we no longer need to be in range of the access point or send it any packets. Next we use Aircrack-ng to test the keys in the wordlist, specifying a list with the <code class="literal">-w</code> option, as shown in <a class="xref" href="ch15.xhtml#recovering_a_wpa2_key_with_aircrack-ng" title="Example 15-15. Recovering a WPA2 key with Aircrack-ng">Example 15-15</a>. Otherwise, the command is identical to cracking the WEP key. If the correct key is in the wordlist, it will be recovered with Aircrack-ng.</p><div class="example"><a id="recovering_a_wpa2_key_with_aircrack-ng"/><div class="example-title">Example 15-15. Recovering a WPA2 key with Aircrack-ng</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>aircrack-ng -w password.lst -b 00:23:69:F5:B4:2B pentestbook2*.cap</strong></span>&#13;
Opening pentestbook2-01.cap&#13;
&#13;
Reading packets, please wait...&#13;
&#13;
                                 Aircrack-ng 1.2 beta2&#13;
&#13;
                   [00:00:00] 1 keys tested (178.09 k/s)&#13;
&#13;
                       KEY FOUND! [ GeorgiaIsAwesome ] ❶&#13;
&#13;
      Master Key     : 2F 8B 26 97 23 D7 06 FE 00 DB 5E 98 E3 8A C1 ED&#13;
                       9D D9 50 8E 42 EE F7 04 A0 75 C4 9B 6A 19 F5 23&#13;
&#13;
      Transient Key  : 4F 0A 3B C1 1F 66 B6 DF 2F F9 99 FF 2F 05 89 5E&#13;
                       49 22 DA 71 33 A0 6B CF 2F D3 BE DB 3F E1 DB 17&#13;
                       B7 36 08 AB 9C E6 E5 15 5D 3F EA C7 69 E8 F8 22&#13;
                       80 9B EF C7 4E 60 D7 9C 37 B9 7D D3 5C A0 9E 8C&#13;
&#13;
      EAPOL HMAC     : 91 97 7A CF 28 B3 09 97 68 15 69 78 E2 A5 37 54</pre></div></div><p><a class="indexterm" id="iddle1140"/><a class="indexterm" id="iddle1269"/><a class="indexterm" id="iddle1603"/><a class="indexterm" id="iddle2457"/><a class="indexterm" id="iddle2459"/><a class="indexterm" id="iddle2509"/><a class="indexterm" id="iddle2525"/><a class="indexterm" id="iddle2529"/>As you can see, the correct key is in our wordlist and is recovered ❶. This sort of dictionary attack against WPA/WPA2 can be prevented by using a strong passphrase, as discussed in <a class="xref" href="ch09.xhtml" title="Chapter 9. Password Attacks">Chapter 9</a>.</p><p>Aircrack-ng is just one suite of tools for cracking wireless. It is ideal for beginners, because starting different tools for each step of the process will help you become familiar with how these attacks work. Other widely used Wi-Fi auditing tools that you may encounter are Kismet and Wifite.</p></div></div></div><div class="sect1" title="Wi-Fi Protected Setup"><div class="titlepage"><div><div><h2 class="title" id="wi-fi_protected_setup" style="clear: both">Wi-Fi Protected Setup</h2></div></div></div><p><span class="emphasis"><em>Wi-Fi Protected Setup (WPS)</em></span> was designed to allow users to attach their devices to secure networks with an eight-digit pin instead of a potentially long and complicated passphrase. When the correct pin is supplied, the access point sends over the passphrase.</p><div class="sect2" title="Problems with WPS"><div class="titlepage"><div><div><h3 class="title" id="problems_with_wps">Problems with WPS</h3></div></div></div><p>The last digit of the pin is a checksum for the previous seven digits, so the keyspace should be 10<sup>7</sup>, or 10,000,000 possible pins. However, when a pin is sent to the access point by the client, the validity of the first four digits and second four digits is reported separately. The first four digits are all in play, so there are 10,000 possibilities. Of the second four digits, only the first three are in play (1000 possible guesses), so it would take at most 11,000 guesses to brute-force the correct WPS pin. This decreases the time required to brute-force to under four hours. The only way to fix this issue is to disable WPS on the access point.</p></div><div class="sect2" title="Cracking WPS with Bully"><div class="titlepage"><div><div><h3 class="title" id="cracking_wps_with_bully">Cracking WPS with Bully</h3></div></div></div><p><a class="indexterm" id="iddle1147"/>Kali provides tools that you can use to implement a brute-force attack against WPS. One such tool is Bully. We can use Bully to brute-force the WPS pin as well as test a specific pin. To use Bully we need the SSID, MAC address, and channel of the access point, which we found with <code class="literal">iwlist</code> at the beginning of this chapter. Use the <code class="literal">-b</code> flag to specify the MAC address, the <code class="literal">-e</code> flag for the SSID, and the <code class="literal">-c</code> flag for the channel, as shown here.</p><a id="pro_id00190"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>bully mon0 -b 00:23:69:F5:B4:2B -e linksys -c 6</strong></span></pre><p>Bully should be able to brute-force the pin in around four hours and recover the correct pre-shared PIN. WPS is enabled by default on many wireless access points and may be an easier way in than guessing a strong WPA/WPA2 passphrase.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00043" style="clear: both">Summary</h2></div></div></div><p>Wireless security is an often-overlooked piece of an organization’s security posture. Time and money are put into securing the perimeter, deploying the latest firewalls and intrusion-prevention systems, but all this is for naught if an attacker can just sit at the coffee shop across the street with a strong antenna and join your corporate network. Wireless connections may save corporations from lawsuits by distracted employees tripping over Ethernet wires, but they introduce potential security vulnerabilities and should be audited regularly. In this chapter, we used Aircrack-ng to recover WEP and WPA2 personal wireless keys by eavesdropping on and injecting traffic into a wireless network, and we used Bully to brute-force a WPS pin.</p></div></section></body></html>