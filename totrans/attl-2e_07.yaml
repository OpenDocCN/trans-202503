- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BUILDING LIBRARIES WITH LIBTOOL
  prefs: []
  type: TYPE_NORMAL
- en: '*The years teach much which the days never know.'
  prefs: []
  type: TYPE_NORMAL
- en: — Ralph Waldo Emerson, “Experience”*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After too many bad experiences building shared libraries for multiple platforms
    without the help of GNU Libtool, I have come to two conclusions. First, the person
    who invented the concept of shared libraries should be given a raise . . . and
    a bonus. Second, the person who decided that shared library management interfaces
    and naming conventions should be left to the implementation should be flogged.
  prefs: []
  type: TYPE_NORMAL
- en: The very existence of Libtool stands as a witness to the truth of this sentiment.
    Libtool exists for only one reason—to provide a standardized, abstract interface
    for developers who want to create and access shared libraries in a portable manner.
    It abstracts both the shared-library build process and the programming interfaces
    used to dynamically load and access shared libraries at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Libtool package concept was designed, and initial implementation was done,
    by Gordon Matzigkeit in March of 1996\. Before this time, there was no standard,
    cross-platform mechanism for building shared libraries. Autoconf and Automake
    worked great for building portable projects across many platforms—as long as you
    didn’t try to build a shared library. Once you started down this path, however,
    your code and build system would become littered with conditional constructs for
    shared-library management. This was a monumental effort because, as we shall see,
    building shared libraries is significantly different among some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Thomas Tanner began contributing in November of 1998 with his cross-platform
    abstraction for shared-library dynamic loading—*ltdl*. Other contributors since
    that time include Alexandre Oliva, Ossama Othman, Robert Boehne, Scott James Remnant,
    Peter O’Gorman, and Ralf Wildenhues. Currently, the Libtool package is maintained
    by Gary V. Vaughn (who has also been contributing to Libtool since 1998) and Bob
    Friesenhahn (whose excellent suggestions have been incorporated since 1998).
  prefs: []
  type: TYPE_NORMAL
- en: Before I get into a discussion of the proper use of Libtool, I’ll spend a few
    paragraphs on the features and functionality that shared libraries provide so
    you understand the scope of the material I’m covering here.
  prefs: []
  type: TYPE_NORMAL
- en: The Benefits of Shared Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shared libraries provide a way to deploy reusable chunks of functionality in
    a convenient package. You can load shared libraries into a process address space
    either automatically at program load time, by using the operating system loader,
    or manually via code in the application itself. The point at which an application
    binds functionality from a shared library is very flexible, and the developer
    determines it based on the program’s design and the end user’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces between the program executable and the modules defined as shared
    libraries must be reasonably well designed because shared-library interfaces must
    be well specified. This rigorous specification promotes good design practices.
    When you use shared libraries, the system essentially forces you to be a better
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries may be (as the name implies) shared among processes. This sharing
    is very literal. The code segments for a shared library can be loaded once into
    physical memory pages. Those same memory pages can then be mapped into the process
    address spaces of multiple programs at once. The data pages must, of course, be
    unique for each process, but global data segments are often small compared to
    the code segments of a shared library. This is true efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to update shared libraries during program upgrades. Even if the base
    program doesn’t change between two revisions of a software package, you can replace
    an old version of a shared library with a new one, as long as the new version’s
    interfaces have not been changed. If interfaces *have* changed, two versions of
    the same shared library may reside together within the same directory, because
    the versioning schemes used by shared libraries (and supported by Libtool) on
    various platforms allow multiple versions of a library to be named differently
    in the filesystem but treated as the same library by the operating system loader.
    Older programs will continue to use older versions of the library, while newer
    programs are free to use the newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: If a software package specifies a well-defined plug-in interface, then shared
    libraries can be used to implement user-configurable loadable functionality. This
    means that additional functionality can become available to a program after it
    has been released, and third-party developers can even add functionality to your
    program, if you publish a document describing your plug-in interface specification
    (or if they’re smart enough to figure it out on their own).
  prefs: []
  type: TYPE_NORMAL
- en: There are a few widely known examples of these types of systems. Eclipse, for
    instance, is almost a pure plug-in framework. The base executable supports little
    more than a well-defined plug-in interface. Most of the functionality in an Eclipse
    application comes from library functions. Eclipse is written in Java and uses
    Java class libraries and *.jar* files, but the principle is the same, regardless
    of the language or platform.
  prefs: []
  type: TYPE_NORMAL
- en: How Shared Libraries Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specifics of how POSIX-compliant operating systems implement shared libraries
    vary from platform to platform, but the general idea is the same. Shared libraries
    provide chunks of executable code that the operating system can load into a program’s
    address space and execute. The following discussion applies to shared-library
    references that the linker resolves when a program is built and the operating
    system loader resolves when the program is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: While the object (*.o*) files produced by compilers do contain executable code,
    they cannot be executed by themselves from the command line. This is because they’re
    incomplete, containing symbolic references or *links* to external entities (functions
    and global data items) that must be patched up. This patching is done by using
    a tool designed to manage such links to combine the complete set of object files
    containing such references.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dynamic Linking at Load Time*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a program executable image is being built, the linker (formally called a
    *link editor*) maintains a table of symbols—function entry points and global data
    addresses. Each symbol referenced within the accumulating body of object code
    is added to this table as the linker finds it. As symbol definitions are located,
    the linker resolves symbol references in the table to their addresses in the code.
    At the end of the linking process, all object files (or simply *objects*) containing
    referenced symbol definitions are linked together and become part of the program
    executable image.
  prefs: []
  type: TYPE_NORMAL
- en: Objects found in static libraries (also called archives) that contain no referenced
    symbol definitions are discarded, but objects linked explicitly are added to the
    binary image even if they contain no referenced symbol definitions. If there are
    outstanding references in the symbol table after all the objects have been analyzed,
    the linker exits with an error message. On success, the final executable image
    may be loaded and executed by a user. The image is now entirely self-contained,
    depending on no external binary code.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that all undefined references are resolved during the linking process,
    if the list of objects to be linked contains one or more shared libraries, the
    linker will build the executable image from all *nonshared* objects specified
    on the linker command line. This includes all individual object files (*.o*) and
    all objects contained in static library archives (*.a*). However, the linker will
    add two tables to the binary image header. The first is the outstanding *external
    reference table*—a table of references to symbol definitions found only in shared
    libraries during the linking process. The second is the *shared-library table*,
    containing the list of shared-library names and versions in which the outstanding
    undefined references were found.
  prefs: []
  type: TYPE_NORMAL
- en: When the operating system loader attempts to load the program, it must resolve
    the remaining outstanding references in the external reference table to symbols
    imported from the shared libraries named in the shared-library table. If the loader
    can’t resolve all of the references, then a load error occurs, and the process
    is terminated with an operating system error message. Note that these external
    symbols are not tied to a specific shared library. As long as they’re found in
    any one of the searched libraries in the shared-library table, they’re accepted.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This process differs slightly from the way a Windows operating system loader
    resolves symbols in dynamic link libraries (DLLs). On Windows, the linker ties
    a particular symbol to a specifically named DLL at program build time.^([1](footnote.xhtml#ch07fn1))*'
  prefs: []
  type: TYPE_NORMAL
- en: Using free-floating external references has both pros and cons. On some operating
    systems, unbound symbols can be satisfied by a library specified by the user.
    That is, a user can entirely replace a library (or a portion of a library) at
    runtime by simply preloading one that contains the same symbols. On BSD and Linux-based
    systems, for example, a user can use the `LD_PRELOAD` environment variable to
    inject a shared library into a process address space. Since the loader loads these
    libraries before any other libraries, the loader will locate symbols in the preloaded
    libraries when it tries to resolve external references. The program author’s intended
    libraries will not even be checked because the symbols provided by these libraries
    have already been resolved by the preloaded libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the Linux `df` utility is executed with an environment
    containing the `LD_PRELOAD` variable. This variable has been set to a path referring
    to a library that presumably contains a heap manager that’s compatible with the
    C *malloc* interface. This technique can be used to debug memory problems in your
    programs. By preloading your own heap manager, you can capture memory allocations
    in a log file—in order to debug memory block overruns, for instance. This sort
    of technique is used by such widely known debugging aids as the *Valgrind* package.^([2](footnote.xhtml#ch07fn2))
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `LD_PRELOAD` environment variable is set on the same command line
    used to execute the `df` program. This shell code causes only the `df` child process
    environment to contain the `LD_PRELOAD` variable, set to the specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, free-floating symbols can also lead to problems. For instance,
    two libraries can provide the same symbol name, and the dynamic loader can inadvertently
    bind an executable to a symbol from the wrong library. At best, this will cause
    a program crash when the wrong arguments are passed to the mismatched function.
    At worst, it can present security risks because the mismatched function might
    be used to capture passwords and security credentials passed by the unsuspecting
    program.
  prefs: []
  type: TYPE_NORMAL
- en: C-language symbols do not include parameter information, so it’s rather likely
    that symbols will clash in this manner. C++ symbols are a bit safer, in that the
    entire function signature (minus the return type) is encoded into the symbol name.
    However, even C++ is not immune to hackers who purposely replace security functions
    with their own versions of those functions (assuming, of course, that they have
    access to your runtime shared-library search path).
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Dynamic Linking at Runtime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The operating system loader can also use a very late form of binding, often
    referred to as *lazy binding*. In this situation, the external reference table
    entries in the program header are initialized so that they refer to code within
    the dynamic loader itself.
  prefs: []
  type: TYPE_NORMAL
- en: When a program first calls a *lazy entry*, the call is routed to the loader,
    which will then (potentially) load the proper shared library, determine the actual
    address of the function, reset the entry point in the jump table, and, finally,
    redirect the processor to the shared-library function (which is now available).
    The next time this happens, the jump table entry will have already been correctly
    initialized, and the program will jump directly to the called function. This is
    very efficient both because the overhead for the jump after fix-up is no more
    than a normal indirect function call and because the cost of the initial load
    and link is amortized over many calls to the function during the lifetime of the
    process.^([3](footnote.xhtml#ch07fn3))
  prefs: []
  type: TYPE_NORMAL
- en: This lazy binding mechanism makes program startup very fast because shared libraries
    whose symbols are not bound until they’re needed aren’t even loaded until the
    application program first references them. But, consider this—the program may
    *never* reference them. And that means they may never be loaded, saving both time
    and space. A good example of this sort of situation might be a word processor
    with a thesaurus feature implemented in a shared library. How often do you use
    your thesaurus? If the program is using automatic dynamic linking, chances are
    that the shared library containing the thesaurus code will never be loaded in
    most word-processing sessions.
  prefs: []
  type: TYPE_NORMAL
- en: As good as this system appears to be, there can be problems. While using automatic
    runtime dynamic linking can give you faster load times, better performance, and
    more efficient use of space, it can also cause your application to terminate abruptly
    and without warning. In the event that the loader can’t find the requested symbol—perhaps
    the required library is missing—it has no recourse except to abort the process.
  prefs: []
  type: TYPE_NORMAL
- en: Why not ensure that all symbols exist when the program is loaded? Because if
    the loader resolved all symbols at load time, it might as well populate the jump
    table entries at that point, too. After all, it had to load all the libraries
    to ensure that the symbols actually exist, so this would entirely defeat the purpose
    of using lazy binding. Furthermore, even if the loader did check all external
    references when the program was first started, there’s nothing to stop someone
    from deleting one or more of these libraries before the program uses them, while
    the program is still running.^([4](footnote.xhtml#ch07fn4)) Thus, even the pre-check
    is defeated.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of this story is that there’s no free lunch. If you don’t want to
    pay the insurance premium for longer up-front load times and more space consumed
    (even if you may never really need it), then you may have to take the hit of a
    missing symbol at runtime, causing a program crash.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Dynamic Linking at Runtime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One possible solution to the aforementioned problem is to take personal responsibility
    for some of the system loader’s work. Then, when things don’t go right, you have
    a little more control over the outcome. In the case of the thesaurus module, was
    it really necessary to terminate the program if the thesaurus library could not
    be loaded or didn’t provide the correct symbols? Of course not—but the operating
    system loader can’t know that. Only the software programmer can make such judgment
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: When a program manages dynamic linking manually at runtime, the linker is left
    out of the equation entirely, and the program doesn’t call any exported shared-library
    functions directly. Rather, shared-library functions are referenced through function
    pointers that the program itself populates at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works: A program calls an operating system function (`dlopen`)
    to manually load a shared library into its own process address space. This function
    returns a *handle*, or an opaque value representing the loaded library. The program
    then calls another loader function (`dlsym`) to import a symbol from the library
    to which the handle refers. If all goes well, the operating system returns the
    address of the requested function or data item from the desired library. The program
    may then call the function, or access the global data item, through this pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: If something goes wrong in this process—the symbol isn’t found within the library
    or the library isn’t found—then it becomes the responsibility of the program to
    define the results, perhaps by displaying an error message indicating that the
    program was not configured correctly. In the preceding example of the word processor,
    a simple dialog indicating that the thesaurus is unavailable would be entirely
    sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: This is a little nicer than the way automatic dynamic runtime linking works;
    while the loader has no option but to abort, the application has a higher-level
    perspective and can handle the problem much more gracefully. The drawback, of
    course, is that you as the programmer have to manage the process of loading libraries
    and importing symbols within your application code. However, this process is not
    very difficult, as I’ll demonstrate in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using Libtool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An entire book could be written about the details of shared libraries and how
    they’re implemented on various systems. The short primer you just read should
    suffice for our immediate needs, so I’ll now move on to how you can use Libtool
    to make a package maintainer’s life a little easier.
  prefs: []
  type: TYPE_NORMAL
- en: The Libtool project was designed to extend Automake, but you can use it independently
    within hand-coded makefiles, as well. As of this writing, the latest version of
    Libtool, and the one I’m using in the examples here, is version 2.4.6.
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstracting the Build Process*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s look at how Libtool helps during the build process. Libtool provides
    a script (*ltmain.sh*) that `config.status` consumes in a Libtool-enabled project.
    The `config.status` script converts `configure` test results and the `ltmain.sh`
    script into a custom version of the `libtool` script, specifically tailored to
    your project.^([5](footnote.xhtml#ch07fn5)) Your project’s makefiles then use
    this `libtool` script to build the shared libraries listed in any Automake product
    list variables defined with the Libtool-specific `LTLIBRARIES` primary. The `libtool`
    script is really just a fancy wrapper around the compiler, linker, and other tools.
    You should ship the `ltmain.sh` script in a distribution archive, as part of your
    build system. Automake-generated rules ensure that this happens properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `libtool` script insulates the author of the build system from the nuances
    of building shared libraries on different platforms. This script accepts a well-defined
    set of options, converting them to appropriate platform- and linker-specific options
    on the target platform and toolset. Thus, the maintainer doesn’t need to worry
    about the specifics of building shared libraries on each platform—they only need
    to understand the available `libtool` script options. These options are well specified
    in the *GNU Libtool Manual*,^([6](footnote.xhtml#ch07fn6)) and I’ll cover many
    of them in this chapter and the next.
  prefs: []
  type: TYPE_NORMAL
- en: On systems that don’t support shared libraries at all, the `libtool` script
    uses appropriate commands and options to build and link only static archive libraries.
    Furthermore, the maintainer doesn’t have to worry about the differences between
    building shared libraries and building static libraries when using Libtool. You
    can emulate building your package on a static-only system by using the `--disable-shared`
    option on the `configure` command line for your Libtool-enabled project. This
    option causes Libtool to assume that shared libraries cannot be built on the target
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstraction at Runtime*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also use Libtool to abstract the programming interfaces the operating
    system supplies for loading libraries and importing symbols. If you’ve ever dynamically
    loaded a library on a Linux system, you’re familiar with the standard POSIX shared-library
    API, including the `dlopen`, `dlsym`, and `dlclose` functions. A system-level
    shared library, usually called simply *dl*, provides these functions. This translates
    to a binary image file named *libdl.so* (or something similar on systems that
    use different library-naming conventions).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not all Unix systems that support shared libraries provide the
    *libdl.so* library or functions using these names. To address these differences,
    Libtool provides a shared library called *ltdl*, which exports a clean, portable,
    library-management interface that is very similar to the POSIX *dl* interface.
    The use of this library is optional, of course, but it is highly recommended because
    it provides more than just a common API across shared-library platforms—it also
    provides an abstraction for manual dynamic linking between shared-library and
    non-shared-library platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '*What?! How can that work?!* On systems that don’t support shared libraries,
    Libtool actually creates internal symbol tables within the executable that contain
    all the symbols you would otherwise find within shared libraries (on systems that
    support shared libraries). By using such symbol tables on these platforms, the
    `lt_dlopen` and `lt_dlsym` functions can make your code appear to be loading libraries
    and importing symbols, when in fact, the library load function does nothing more
    than return a handle to the appropriate internal symbol table, and the import
    function merely returns the address of code that has been statically linked into
    the program itself. On these systems, a project’s shared-library code is linked
    directly into the programs that would normally load them at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Libtool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to make use of the latest version of Libtool while developing your
    packages, you may find that you either have to download, build, and install it
    manually or look for an updated *libtool* package from your distribution provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Downloading, building, and installing Libtool is really trivial, as you’ll
    see here. However, you should check the GNU Libtool website^([7](footnote.xhtml#ch07fn7))
    before executing these steps in order to ensure you’re getting the most recent
    package. I’ve reproduced the basic steps here from [Chapter 1](ch01.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that the default installation location (as with most of the GNU packages)
    is */usr/local*. If you wish to install Libtool into the */usr* hierarchy, you’ll
    need to use the `--prefix=/usr` option on the `configure` command line. The recommended
    practice is to install distribution-provided packages into the */usr* hierarchy
    and user-built packages into the */usr/local* tree, but if you’re trying to get
    a hand-built version of Libtool to interoperate with distribution-provided versions
    of Autoconf and Automake, you may have to install Libtool into the */usr* hierarchy.
    The simplest way to avoid problems with package interdependencies is to install
    hand-built versions of all three packages into */usr/local* or, better still,
    into a directory within your home directory, which you can then add to your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Shared Libraries to Jupiter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that I’ve presented the requisite background information, let’s take a look
    at how we might add a Libtool shared library to the Jupiter project. First, let’s
    consider what functionality we could add to Jupiter using a shared library. Perhaps
    we want to provide our users with some library functionality that their own applications
    could use. Or we might have several applications in a package that need to share
    the same functionality. A shared library is a great tool for both of these scenarios
    because you get to reuse code and save memory—the cost of the memory used by shared
    code is amortized across multiple applications, both internal and external to
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a shared library to Jupiter that provides Jupiter’s printing functionality.
    We can do this by having the new shared library call into the *libjupcommon.a*
    static library. Remember that calling a routine in a static library has the same
    effect as linking the object code for the called routine right into the calling
    program. The called routine ultimately becomes an integral part of the calling
    binary image (program or shared library).^([8](footnote.xhtml#ch07fn8))
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we’ll provide a public header file from the Jupiter project that
    will allow external applications to call this same functionality. This allows
    other applications to display stuff in the same quaint manner that the `jupiter`
    program does. (This would be significantly cooler if we were doing something useful
    in Jupiter, but you get the idea.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the LTLIBRARIES Primary*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Automake has built-in support for Libtool; it’s the Automake package, rather
    than the Libtool package, that provides the `LTLIBRARIES` primary. Libtool doesn’t
    really qualify as a pure Automake extension but rather is more of an add-on package
    for Automake, where Automake provides the necessary infrastructure for this specific
    add-on package. You can’t access Automake’s `LTLIBRARIES` primary functionality
    without Libtool because the use of this primary generates `make` rules that call
    the `libtool` script.
  prefs: []
  type: TYPE_NORMAL
- en: Libtool ships separately, rather than as part of Automake, because you can use
    Libtool quite effectively independently of Automake. If you want to try Libtool
    by itself, I’ll refer you to the *GNU Libtool Manual*; the opening chapters describe
    the use of the `libtool` script as a stand-alone product. It’s as simple as modifying
    your makefile commands so that the compiler, linker, and librarian are called
    through the `libtool` script, and then modifying some of your command line parameters
    as required by Libtool.
  prefs: []
  type: TYPE_NORMAL
- en: '*Public Include Directories*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A project subdirectory named *include* should only contain public header files—those
    that expose a public interface in your project. We’re now going to add just such
    a header file to the Jupiter project, so we’ll create a directory called *include*
    in the project root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had multiple shared libraries, we’d have a choice to make: do we create
    separate *include* directories, one in each library source directory, or do we
    add a single, top-level *include* directory? I usually use the following rule
    of thumb to make my decision: If the libraries are designed to work together as
    a group, and if consuming applications generally use the libraries together, then
    I use a single, top-level *include* directory. If, on the other hand, the libraries
    can be effectively used independently, and if they offer fairly autonomous sets
    of functionality, then I provide individual *include* directories in the libraries’
    own directories.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it doesn’t really matter much because the header files for these
    libraries will be installed in directory structures that are entirely different
    from the ones where they exist within your project. In fact, you should make sure
    you don’t inadvertently use the same filename for public headers in two different
    libraries in your project—if you do, you’ll have problems installing these files.
    They generally end up all together in the `$(prefix)`*/include* directory, although
    you can override this default by using either the `includedir` variable or the
    `pkginclude` prefix in your *Makefile.am* files.
  prefs: []
  type: TYPE_NORMAL
- en: The `includedir` variable allows you to specify where you want your header files
    to be installed by defining the exact value of Automake’s `$(includedir)` variable,
    the usual value of which is `$(prefix)`*/include*. The use of the `pkginclude`
    prefix indicates to Automake that you want your header files to be in a private,
    package-specific directory, beneath the directory indicated by `$(includedir)`,
    called `$(includedir)`*/*`$(PACKAGE)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also add another root-level directory (*libjup*) for Jupiter’s new shared
    library, *libjupiter*. These changes require you to add references to the new
    directories to the top-level *Makefile.am* file’s `SUBDIRS` variable and then
    add corresponding *Makefile* references to the `AC_CONFIG_FILES` macro in *configure.ac*.
    Since we’re going to make major changes to our project, we’d better clean up the
    work area before we start. Then we’ll create the directories and add a new *Makefile.am*
    file to the new *include* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 7.0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The *include* directory’s *Makefile.am* file is trivial—it contains only a single
    line, in which an Automake `HEADERS` primary refers to the public header file
    *libjupiter.h*. Note at ➊ that we’re using the `include` prefix on this primary.
    You’ll recall that this prefix indicates that files specified in this primary
    are destined to be installed in the `$(includedir)` directory (for example, */usr/(local/)include*).
    The `HEADERS` primary is similar to the `DATA` primary in that it specifies a
    set of files that are to be treated simply as data to be installed without modification
    or preprocessing. The only really tangible difference is that the `HEADERS` primary
    restricts the possible installation locations to those that make sense for header
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The *libjup/Makefile.am* file is a bit more complex, containing four lines as
    opposed to just one. This file is shown in [Listing 7-1](ch07.xhtml#ch07ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1:* libjup/Makefile.am: *The initial version of this file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze this file, line by line. The line at ➊ is the primary specification,
    and it contains the usual prefix for libraries: `lib`. The products this prefix
    references will be installed in the `$(libdir)` directory. (We could have also
    used the `pkglib` prefix to indicate that we wanted our libraries installed into
    `$(libdir)`*/jupiter*.) Here, we’re using the `LTLIBRARIES` primary rather than
    the original `LIBRARIES` primary. The use of `LTLIBRARIES` tells Automake to generate
    rules that use the `libtool` script rather than calling the compiler (and possibly
    the librarian) directly to generate the products.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ lists the sources that are to be used for the first (and only)
    product.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ indicates a set of C-preprocessor flags that are to be used on
    the compiler command line for locating the associated shared-library header files.
    These options indicate that the preprocessor should search the top-level *include*
    and *common* directories for header files referenced in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The last line (at ➍) indicates a set of linker options for this product. In
    this case, we’re specifying that the *libjupcommon.a* static library should be
    linked into (that is, become part of) the *libjupiter.so* shared library.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The more experienced Autotools library developer will notice a subtle flaw
    in this* Makefile.am *file. Here’s a hint: it’s related to linking Libtool libraries
    against non-Libtool libraries. This concept presents a major stumbling block for
    many newcomers, so I’ve written the initial version of this file to illustrate
    the error. Not to worry, however—we’ll correct the flaw later in this chapter
    as we work through this issue in a logical fashion*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important concept regarding the `*_LIBADD` variables that you should
    strive to understand completely: Libraries that are consumed within, and yet built
    as part of, the same project should be referenced internally using relative paths,
    via either parent directory references or the `$(``top_builddir``)` variable,
    within the *build* directory hierarchy. Libraries that are external to a project
    generally don’t need to be referenced explicitly at all, because the project’s
    `configure` script should already have added appropriate `-L` and `-l` options
    for those libraries into the `$(LIBS)` environment variable when it processed
    the code generated by the `AC_CHECK_LIB` or `AC_SEARCH_LIBS` macro.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll hook these new directories into the project’s build system. To do
    so, we need to modify the top-level *Makefile.am* and *configure.ac* files. These
    changes are shown in [Listings 7-2](ch07.xhtml#ch07ex2) and [7-3](ch07.xhtml#ch07ex3),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2:* Makefile.am: *Adding* include *and* libjup *to the `SUBDIRS`
    variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3:* configure.ac: *Adding the* include *and* libjup *directory makefiles*'
  prefs: []
  type: TYPE_NORMAL
- en: Three unrelated changes were required in *configure.ac*. The first is the addition
    at ➊ of the Libtool setup macros `LT_PREREQ` and `LT_INIT`. The `LT_PREREQ` macro
    works just like Autoconf’s `AC_PREREQ` macro (used a few lines higher). It indicates
    the earliest version of Libtool that can correctly process this project. You should
    choose the lowest reasonable values for the arguments in these macros because
    higher values needlessly restrict you and your co-maintainers to more recent versions
    of the Autotools.^([9](footnote.xhtml#ch07fn9)) The `LT_INIT` macro initializes
    the Libtool system for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The second change is just as interesting. I removed the `AC_PROG_RANLIB` macro
    invocation after the line at ➋. (And after all we went through to put it there
    in the first place!) Because Libtool is now building all of the project libraries,
    and because it understands all aspects of the library build process, we no longer
    need to instruct Autoconf to make sure `ranlib` is available. In fact, if you
    leave this macro in, you’ll get a warning when you execute `autoreconf -i`.
  prefs: []
  type: TYPE_NORMAL
- en: The last change is found at ➌ in the argument to `AC_CONFIG_FILES`, where we’ve
    added references to the two new *Makefile.am* files we added to the *include*
    and *libjup* directories.
  prefs: []
  type: TYPE_NORMAL
- en: '*Customizing Libtool with LT_INIT Options*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can specify default values for enabling or disabling static and shared
    libraries in the argument list passed into `LT_INIT`. The `LT_INIT` macro accepts
    a single, optional argument: a whitespace-separated list of keywords. The following
    are the most important keywords allowed in this list, along with an explanation
    of their proper use.'
  prefs: []
  type: TYPE_NORMAL
- en: dlopen
  prefs: []
  type: TYPE_NORMAL
- en: 'This option enables checking for `dlopen` support. The *GNU Libtool Manual*
    states that this option should be used if the package makes use of the `-dlopen`
    and `-dlpreopen` flags in `libtool`; otherwise `libtool` will assume that the
    system does not support *dl-opening*. There’s only one reason for using the `-dlopen`
    or `-dlpreopen` flag: you intend to dynamically load and import shared-library
    functionality at runtime within your project’s source code. Additionally, these
    two options do very little unless you intend to use the *ltdl* library (rather
    than directly using the *dl* library) to manage your runtime dynamic linking.
    Thus, you should use this option only if you intend to use the *ltdl* library.'
  prefs: []
  type: TYPE_NORMAL
- en: win32-dll
  prefs: []
  type: TYPE_NORMAL
- en: Use this option if your library is properly ported to a Windows DLL using `__declspec(dllimport)`
    and `__declspec(dllexport)`. If your library properly uses these keywords to import
    and export symbols for Windows DLLs, and you don’t use this option, then Libtool
    will only build static libraries on Windows. We’ll cover this topic in more detail
    in [Chapter 17](ch17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: aix-soname=aix|svr4|both
  prefs: []
  type: TYPE_NORMAL
- en: Adds the flags `--with-aix-soname` to `configure`’s command line. Prior to version
    2.4.4, Libtool always behaved as if `aix-soname` were set to `aix`. If you build
    shared libraries on AIX often, you’ll understand the meaning of this option. If
    you wish to learn more, read Section 5.4.1 of the *GNU Libtool Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: disable-fast-install
  prefs: []
  type: TYPE_NORMAL
- en: This option changes the default behavior for `LT_INIT` to disable optimization
    for fast installation on systems where it matters. The concept of fast installation
    exists because uninstalled programs and libraries may need to be executed from
    within the build tree (during `make check`, for example). On some systems, installation
    location affects the final linked binary image, so Libtool must either relink
    programs and libraries on these systems when `make install` is executed or else
    relink programs and libraries for `make check`. Libtool chooses to relink for
    `make check` by default, allowing the original binaries to be installed quickly
    without relinking during `make install`. The user can override this default, depending
    on platform support, by specifying `--enable-fast-install` to `configure`.
  prefs: []
  type: TYPE_NORMAL
- en: shared and disable-shared
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating shared libraries.
    The effects of the `shared` option are default behavior on all systems where Libtool
    knows how to create shared libraries. The user may override the default shared
    library-generation behavior by specifying either `--disable-shared` or `--enable-shared`
    on the `configure` command line.
  prefs: []
  type: TYPE_NORMAL
- en: static and disable-static
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating static libraries.
    The effects of the `static` option are default behavior on all systems where shared
    libraries have been disabled and on most systems where shared libraries have been
    enabled. If shared libraries are enabled, the user may override this default by
    specifying `--``disable-static` on the `configure` command line. Libtool will
    always generate static libraries on systems without shared libraries. Hence, you
    can’t (effectively) use the `disable-shared` and `disable-static` arguments to
    `LT_INIT` or the `--disable-shared` and `--disable-static` command line options
    for `configure` at the same time. (Note, however, that you may use the `shared`
    and `static` `LT_INIT` options or the `--enable-shared` and `--enable-static`
    command line options together.)
  prefs: []
  type: TYPE_NORMAL
- en: pic-only and no-pic
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating and using PIC object
    code. The user may override the defaults set by these options by specifying `--without-pic`
    or `--with-pic` on the `configure` command line. I’ll discuss the meaning of PIC
    object code in “So What Is PIC, Anyway?” on [page 200](ch07.xhtml#page_200).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished setting up the build system for the new library, we
    can move on to discussing the source code. [Listing 7-4](ch07.xhtml#ch07ex4) shows
    the contents of the new *jup_print.c* source file that’s referenced in the second
    line of *libjup/Makefile.am*. [Listing 7-5](ch07.xhtml#ch07ex5) shows the contents
    of the new *include/libjupiter.h* library header file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4:* libjup/jup_print.c: *The initial contents of the shared-library
    source file*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5:* include/libjupiter.h: *The initial contents of the shared-library
    public header file*'
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to another general software-engineering principle. I’ve heard
    it called by many names, but the one I tend to use the most is the *DRY principle*—the
    acronym stands for *don’t repeat yourself*. C function prototypes are very useful
    because, when used correctly, they enforce the fact that the public’s view of
    a function is identical to the package maintainer’s view. All too often I’ve seen
    source files that don’t include their corresponding header files. It’s easy to
    make a small change in a function or prototype and then not duplicate it in the
    other location—unless you’ve included the public header file within the source
    file. When you do this consistently, the compiler catches any inconsistencies
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include the static library header file (*jupcommon.h*) because
    we call its function (*print_routine*) from within the public library function.
    You may have also noticed that I placed *config.h* first, immediately followed
    by the public header file—there’s a good reason for this. I’ve already stated
    in [Chapter 6](ch06.xhtml) that *config.h* should always come first in every source
    file. Normally, I’d say the public header file should come first, but public header
    files should be written so that their functionality is never modified by *config.h*,
    so, technically, it should not matter if the public header file comes before or
    after *config.h*. For example, using a compiler-mode dependent type like `off_t`
    in a public header file will cause the application binary interface (ABI) to change
    not only from one platform to another (not necessarily a bad thing) but also on
    the same platform from one use to another, based on the compilation environment
    set up by consumer code (not a good thing). The fact is, you should write your
    public header files in such a way that it doesn’t really matter whether you include
    them before or after *config.h*; they should be purposely designed so they do
    not depend on anything that *can* be configured by *config.h*. For a more complete
    treatise on this topic, see “Item 1: Keeping Private Details out of Public Interfaces”
    on [page 499](ch18.xhtml#page_499).'
  prefs: []
  type: TYPE_NORMAL
- en: By placing the public header file first in the source file (after *config.h*),
    we ensure that the use of this header file doesn’t depend on definitions in any
    internal header files in the project. For instance, let’s say the public header
    file has a hidden dependency on some construct (such as a type definition, structure,
    or preprocessor definition) defined in an internal header like *jupcommon.h*.
    If we include the public header file after *jupcommon.h*, the dependency would
    be hidden when the compiler begins to process the public header file, because
    the required construct is already available in the *translation unit* (the source
    file combined with all of the included header files).
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to make one final point about the contents of [Listing 7-5](ch07.xhtml#ch07ex5).
    The preprocessor conditional construct is commonly called an *include guard*.
    It is a mechanism for preventing your header files from inadvertently being included
    multiple times within the same translation unit. I use include guards routinely
    in all my header files, and it’s good practice to do so. A good optimizing compiler
    (`gcc`, for instance—specifically, its preprocessor) will recognize include guards
    in header files and skip the file entirely on subsequent inclusions within the
    same translation unit.^([10](footnote.xhtml#ch07fn10))
  prefs: []
  type: TYPE_NORMAL
- en: Since a public header file will be consumed by foreign source code, it’s even
    more critical that you use include guards religiously in these header files. While
    you can control your own code base, you have no say over the code that one of
    your library consumers writes. What I’m advocating here is that you assume you’re
    the best programmer you know, and everyone else is a little below your skill level.
    You can do this nicely by not mentioning it to anyone, but you should *act* like
    it’s a fact when you write your public header files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll modify the Jupiter application’s `main` function so that it calls
    into the shared library instead of the common static library. These changes are
    shown in [Listing 7-6](ch07.xhtml#ch07ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6:* src/main.c: *Changing `main` to call the shared-library function*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve changed the print function from `print_routine`, found in the static
    library, to `jupiter_print`, as provided by the new shared library. We’ve also
    changed the header file included at the top from *libjupcommon.h* to *libjupiter.h*.
  prefs: []
  type: TYPE_NORMAL
- en: My choices of names for the public function and header file were arbitrary but
    based on a desire to provide a clean, rational, and informational public interface.
    The name *libjupiter.h* very clearly indicates that this header file specifies
    the public interface for *libjupiter.so*. I try to name library interface functions
    to make it clear that they are part of an interface. How you choose to name your
    public interface members—files, functions, structures, type definitions, preprocessor
    definitions, global data, and so on—is up to you, but you should consider using
    a similar philosophy. Remember, the goal is to provide a great end-user experience.
    Intuitive naming should be a significant part of your strategy. For example, it
    is a good general practice to choose a common prefix for your program and library
    symbols.^([11](footnote.xhtml#ch07fn11))
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must also modify the *src/Makefile.am* file to use our new shared
    library rather than the *libjupcommon.a* static library. These changes are shown
    in [Listing 7-7](ch07.xhtml#ch07ex7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7:* src/Makefile.am: *Adding shared-library references to the src
    directory makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve changed the `jupiter_CPPFLAGS` statement at ➊ so that it refers
    to the new top-level *include* directory rather than the *common* directory. We’ve
    also changed the `jupiter_LDADD` statement at ➋ so that it refers to the new Libtool
    shared-library object rather than the *libjupcommon.a* static library. All else
    remains the same. The syntax for referring to a Libtool library is identical to
    that for referring to an older, static library—only the library extension is different.
    The Libtool library extension *.la* stands for *libtool archive*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a step back for a moment. Do we actually need to make this change?
    No, of course not. The `jupiter` application will continue to work just fine the
    way we originally wrote it. Linking the code for the static library’s `print_routine`
    directly into the application works just as well as calling the new shared-library
    routine (which ultimately contains the same code, anyway). In fact, there is slightly
    more overhead in calling a shared-library routine because of the extra level of
    indirection when calling through a shared-library jump table.
  prefs: []
  type: TYPE_NORMAL
- en: In a real project, you might actually leave it the way it was. Because both
    public entry points, `main` and `jupiter_print`, call exactly the same function
    (`print_routine`) in *libjupcommon.a*, their functionality is identical. Why add
    even the slight overhead of a call through the public interface? Well, one reason
    is that you can take advantage of shared code. By using the shared-library function,
    you’re not duplicating code—either on disk or in memory. This is the DRY principle
    at work.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is to exercise the interface you’re providing for users of your
    shared library. You’ll catch bugs in your public interfaces more quickly if your
    project code uses your shared libraries exactly the way you expect other programs
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you might now consider simply moving the code from the static
    library into the shared library, thereby removing the need for the static library
    entirely. However, I’m going to beg your indulgence with my contrived example.
    In a more complex project, I might very well have a need for this sort of configuration.
    Common code is often gathered together into static convenience libraries, and
    more often than not, only a portion of this common code is reused in shared libraries.
    I’m going to leave it the way it is here for the sake of its educational value.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reconfigure and Build*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ve added Libtool—a major new component—to our project build system,
    we’ll add the `-i` option to the `autoreconf` command line to ensure that all
    of the proper auxiliary files are installed into the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because we completely removed all generated and copied files from our project
    directory, most of these notifications have to do with replacing files we’ve already
    discussed. However, there are a few noteworthy exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the comments from `libtoolize` at ➊. Most of them are simply suggesting
    that we move to the new Autotools convention of adding M4 macro files to a directory
    called *m4* in the project root directory. We’re going to ignore these comments
    for now, but in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml), we’ll actually
    do this for a real project.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see at ➋, it appears that the addition of Libtool has caused a few
    new files to be added to our project—namely, the *config.guess* and *config.sub*
    files. Another new file was added in the section at ➊ called *ltmain.sh*. The
    `configure` script uses *ltmain.sh* to build a project-specific version of `libtool`
    for the Jupiter project. I’ll describe the `config.guess` and `config.sub` scripts
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and execute `configure` and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that Libtool adds *significant* overhead to the configuration
    process. I’ve only shown a few of the output lines here that are new since we
    added Libtool. All we’ve added to the *configure.ac* file is the reference to
    the `LT_INIT` macro, but we’ve nearly doubled our `configure` output. This should
    give you some idea of the number of system characteristics that must be examined
    to create portable shared libraries. Fortunately, Libtool does a lot of the work
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the `make` command and see what sort of output we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We seem to have some errors to fix. The first point of interest is that `libtool`
    is being executed at ➊ with a `--mode=compile` option, which causes `libtool`
    to act as a wrapper script around a somewhat modified version of a standard `gcc`
    command line. You can see the effects of this statement in the next two compiler
    command lines at ➋ and ➌. *Two compiler commands?* That’s right. It appears that
    `libtool` is running the compiler twice against our source file.
  prefs: []
  type: TYPE_NORMAL
- en: A careful comparison of these two command lines shows that the first command
    is using two additional flags, `-fPIC` and `-DPIC`. The first line also appears
    to be directing the output file to a *.libs* subdirectory, whereas the second
    line is saving it in the current directory. Finally, both the `stdout` and `stderr`
    output streams are redirected to */dev/null* in the second line.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Occasionally, you may run into a situation where a source file compiles fine
    in the first compilation but fails in the second due to a PIC-related source code
    error. These sorts of problems are rare, but they can be a real pain when they
    occur because *`make`* halts the build with an error but doesn’t give you any
    error messages to explain the problem! When you see this situation, simply pass
    the *`-no-suppress`* flag in the *`CFLAGS`* variable on the *`make`* command line
    in order to tell Libtool not to redirect output from the second compilation to*
    /dev/null.'
  prefs: []
  type: TYPE_NORMAL
- en: This double-compile feature has caused a fair amount of anxiety on the Libtool
    mailing list over the years. Mostly, this is due to a lack of understanding of
    what Libtool is trying to do and why it’s necessary. Using Libtool’s various `configure`
    script command line options, you can force a single compilation, but doing so
    brings a certain loss of functionality, which I’ll explain here shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ renames the dependency file from **.Tpo* to **.Plo*. You might
    recall from [Chapters 3](ch03.xhtml) and [6](ch06.xhtml) that dependency files
    contain `make` rules that declare dependencies between source files and referenced
    header files. The C preprocessor generates these rules when you use the `-MT`
    compiler option. However, the overarching concept to understand here is that one
    Libtool command may (and often does) execute a group of shell commands.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ is another call to the `libtool` script, this time using the `--mode=link`
    option. This option generates a call to execute the compiler in *link mode*, passing
    all of the libraries and linker options specified in the *Makefile.am* file.
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, we come to the first problem—a portability warning about linking a shared
    library against a static library. Specifically, this warning is about linking
    a Libtool shared library against a non-Libtool static library. Notice that this
    is not an error. Were it not for additional errors we’ll encounter later, the
    library would be built in spite of this warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the portability warning, `libtool` attempts to link the requested objects
    together into a shared library named *libjupiter.so.0.0.0* . But here the script
    runs into the real problem: at ➐, a linker error indicates that somewhere from
    within *libjupcommon.a*—and more specifically, within *print.o*—an `x86_64` object
    relocation cannot be performed because the original source file (*print.c*) was
    apparently not compiled correctly. The linker is kind enough to tell us exactly
    what we need to do to fix the problem (highlighted in the example): we need to
    compile the source code using a `-fPIC` compiler option.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you were to encounter this error and didn’t know anything about the
    `-fPIC` option, you’d be wise to open the man page for `gcc` and study it before
    inserting compiler and linker options willy-nilly until the warning or error disappears
    (unfortunately, a common practice of inexperienced programmers). Software engineers
    should understand the meaning and nuances of every command line option used by
    the tools in their build systems. Otherwise, they don’t really know what they
    have when their build completes. It may work the way it should, but if it does,
    it’s by luck rather than by design. Good engineers know their tools, and the best
    way to learn is to study error messages and their fixes until the problem is well
    understood, before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: '*So What Is PIC, Anyway?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When operating systems create new process address spaces, they typically load
    program-executable images at the same memory address. This magic address is system
    specific. Compilers and linkers understand this, and they know what the magic
    address is on any given system. Therefore, when they generate internal references
    to function calls or global data, they can generate those references as *absolute*
    addresses. If you were somehow able to load the executable at a different location
    in the process virtual address space, it would simply not work properly because
    the absolute addresses within the code would not be correct. At the very least,
    the program would crash when the processor jumped to the wrong location during
    a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Figure 7-1](ch07.xhtml#ch07fig1) for a moment. Assume we have a system
    whose magic executable load address is `0x10000000`; this diagram depicts two
    process address spaces within that system. In the process on the left, an executable
    image is loaded correctly at address `0x10000000`. At some point in the code,
    a `jmp` instruction tells the processor to transfer control to the absolute address
    `0x10001000`, where it continues executing instructions in another area of the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Absolute addressing in executable images*'
  prefs: []
  type: TYPE_NORMAL
- en: In the process on the right, the program is loaded incorrectly at address `0x20000000`.
    When that same branch instruction is encountered, the processor jumps to address
    `0x10001000` because that address is hardcoded into the program image. This, of
    course, fails—often spectacularly by crashing, but sometimes with more subtle
    and dastardly ramifications.
  prefs: []
  type: TYPE_NORMAL
- en: That’s how things work for program images. However, when a *shared library*
    is built for certain types of hardware (AMD64 included), neither the compiler
    nor the linker knows beforehand where the library will be loaded. This is because
    many libraries may be loaded into a process and the order in which they are loaded
    depends on how the *executable* is built, not the library. Furthermore, who’s
    to say which library owns location A and which one owns location B? The fact is,
    a library may be loaded *anywhere* into the process address space where there
    is space for it at the time it’s loaded. Only the operating system loader knows
    where it will finally reside—and even then, it only knows just before the library
    is actually loaded.^([12](footnote.xhtml#ch07fn12))
  prefs: []
  type: TYPE_NORMAL
- en: As a result, shared libraries can only be built from a special class of object
    files called PIC objects. *PIC* is an acronym that stands for *position-independent
    code*, and it implies that references within the object code are not absolute
    but *relative*. When you use the `-fPIC` option on the compiler command line,
    the compiler will use somewhat less efficient relative addressing in branching
    instructions. Such position-independent code may be loaded anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) depicts the concept of relative addressing
    as used when generating PIC objects. With relative addressing, addresses work
    correctly regardless of where the image is loaded because they’re always encoded
    relative to the current instruction pointer. In [Figure 7-2](ch07.xhtml#ch07fig2),
    the diagrams indicate a shared library loaded at the same addresses as those in
    [Figure 7-1](ch07.xhtml#ch07fig1) (that is, `0x10000000` and `0x20000000`). In
    both cases, the dollar sign used in the `jmp` instruction represents the current
    instruction pointer (`IP`), so `$ + 0xC74` tells the processor that it should
    jump to the instruction starting `0xC74` bytes ahead of the current position of
    the instruction pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Relative addressing in shared-library images*'
  prefs: []
  type: TYPE_NORMAL
- en: There are various nuances to generating and using position-independent code,
    and you should become familiar with all of them before using them so you can choose
    the option that is most appropriate for your situation. For example, the GNU C
    compiler also supports a `-fpic` option (lowercase), which uses a slightly quicker
    but more limited mechanism to generate relocatable object code.^([13](footnote.xhtml#ch07fn13))
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixing the Jupiter PIC Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From what we now understand, one way to fix our linker error is to add the `-fPIC`
    option to the compiler command line for the source files that comprise the *libjupcommon.a*
    static library. [Listing 7-8](ch07.xhtml#ch07ex8) illustrates the changes required
    to the *common/Makefile.am* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8:* common/Makefile.am: *Changes required for generation of PIC
    objects in a static library*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let’s retry the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have a shared library built properly with position-independent code,
    as per system requirements. However, we still have that strange warning at ➊ about
    the portability of linking a Libtool library against a static library. The problem
    here is not in *what* we’re doing but rather *how* we’re doing it. You see, the
    concept of PIC does not apply to all hardware architectures. Some CPUs don’t support
    any form of absolute addressing in their instruction sets. As a result, native
    compilers for these platforms don’t support a `-fPIC` option—it has no meaning
    for them. Unknown options may be silently ignored, but in most cases, compilers
    stop on unknown options with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: If we tried, for example, to compile this code on an IBM RS/6000 system using
    the native IBM compiler, it would hiccup when it came to the `-fPIC` option on
    the linker command line. This is because it doesn’t make sense to support such
    an option on a system where all code is generated as position-independent code.
  prefs: []
  type: TYPE_NORMAL
- en: One way we could get around this problem would be to make the `-fPIC` option
    conditional in *Makefile.am*, based on the target system and the tools we’re using.
    But that’s exactly the sort of problem that Libtool was designed to address! We’d
    have to account for all the different Libtool target system types and tool sets
    in order to handle the entire set of conditions that Libtool already handles.
    Additionally, some systems and compilers may require different command line options
    to accomplish the same goal.
  prefs: []
  type: TYPE_NORMAL
- en: The way around this portability problem, then, is to let Libtool generate the
    static library, as well. Libtool makes a distinction between static libraries
    that are installed as part of a developer package and static libraries that are
    only used internally within a project. It calls such internal static libraries
    *convenience* libraries, and whether or not a convenience library is generated
    depends on the prefix used with the `LTLIBRARIES` primary. If the `noinst` prefix
    is used, then Libtool assumes we want a convenience library, because there’s no
    point in generating a shared library that will never be installed. Thus, convenience
    libraries are always generated as non-installed static archives, which have no
    value unless they’re linked to other code within the project.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for distinguishing between convenience libraries and other forms
    of static libraries is that convenience libraries are always built, whereas installed
    static libraries are only built if the `--enable-static` option is specified on
    the `configure` command line—or, conversely, if the `--disable-static` option
    is *not* specified and the default library type has been set to `static`. The
    conversion from an older static library to a newer Libtool convenience library
    is simple enough—all we have to do is add `LT` to the primary name and remove
    the `-fPIC` option and the `CFLAGS` variable (since there were no other options
    being used in that variable). Note also that I’ve changed the library extension
    from *.a* to *.la*. Don’t forget to change the prefix on the `SOURCES` variable
    to reflect the new name of the library—*libjupcommon.la*. These changes are highlighted
    in [Listings 7-9](ch07.xhtml#ch07ex9) and [7-10](ch07.xhtml#ch07ex10).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 7.1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9:* common/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10:* libjup/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we try to build, here’s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see at ➋ that the common library is now built as a static convenience
    library because the `ar` utility builds *libjupcommon.a*. Libtool also seems to
    be building files with new and different extensions—a closer look will reveal
    extensions such as *.la* and *.lo* (check the line at ➊). If you examine these
    files, you’ll find that they’re actually descriptive text files containing object
    and library metadata. [Listing 7-11](ch07.xhtml#ch07ex11) shows the partial contents
    of *common/libjupcommon.la*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-11:* common/libjupcommon.la: *Textual metadata found in a library
    archive* (.la ) *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The various fields in these files help the linker—or rather the `libtool` wrapper
    script—to determine certain options that the maintainer would otherwise have to
    remember and manually pass to the linker on the command line. For instance, the
    library’s shared and static names are documented at ➊ and ➋ here, as well as any
    library dependencies required by these libraries (at ➌).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is a convenience library, so the shared library name is empty*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this library, we can see that *libjupcommon.a* depends on the *pthreads*
    library. But, by using Libtool, we don’t have to pass a `-lpthread` option on
    the `libtool` command line because `libtool` can detect from the contents of this
    metadata file (specifically, the line at ➌) that the linker will need this option,
    and it passes the option for us.
  prefs: []
  type: TYPE_NORMAL
- en: Making these files human readable was a minor stroke of genius, as they can
    tell us a lot about Libtool libraries at a glance. These files are designed to
    be installed on an end user’s machine with their associated binaries, and, in
    fact, the `make install` rules that Automake generates for Libtool libraries do
    just this.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distros today are leaning toward filtering out *.la* files from official
    builds of library projects—that is, they don’t install them into the */usr* directory
    structure because *.la* files are only useful during builds where packages are
    referencing Libtool libraries within a project directory structure. Since the
    distro provider has already pre-built everything for you and you won’t be building
    those packages yourself, they just take up space (albeit, not very much). When
    you link against a library (Libtool or otherwise) that’s installed on your system
    in the */usr* directory structure, you’re using one of the `AC_CHECK`/`SEARCH`
    macros to find the library and link against the *.a* or *.so* file directly, so
    the *.la* file isn’t used in that case either.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I outlined the basic rationale for shared libraries. As an
    exercise, we added a shared library to Jupiter that incorporates functionality
    from the convenience library we created earlier. We began with a more or less
    intuitive approach to incorporating a static library into a Libtool shared library,
    and in the process we discovered a more portable and correct way to do this using
    Libtool convenience libraries.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other packages in the Autotools toolchain, Libtool gives you a lot
    of functionality and flexibility. But as you’ve probably noticed, with this degree
    of functionality and flexibility comes a price—complexity. The size of Jupiter’s
    configuration script increased dramatically with the addition of Libtool, and
    the time required to compile and link our project increased accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to continue our discussion of Libtool by looking
    at library-versioning issues and Libtool’s solution to the portability problems
    presented by manual dynamic runtime library management.
  prefs: []
  type: TYPE_NORMAL
