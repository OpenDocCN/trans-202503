- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: BUILDING LIBRARIES WITH LIBTOOL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LIBTOOL 构建库
- en: '*The years teach much which the days never know.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*岁月教会了许多白日无法知道的事。*'
- en: — Ralph Waldo Emerson, “Experience”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——拉尔夫·沃尔多·爱默生，《经验》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: After too many bad experiences building shared libraries for multiple platforms
    without the help of GNU Libtool, I have come to two conclusions. First, the person
    who invented the concept of shared libraries should be given a raise . . . and
    a bonus. Second, the person who decided that shared library management interfaces
    and naming conventions should be left to the implementation should be flogged.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 GNU Libtool 帮助的情况下，经历了太多在多个平台上构建共享库的糟糕经验后，我得出了两个结论。首先，应该给发明共享库概念的人加薪……并且发放奖金。其次，应该对决定将共享库管理接口和命名约定留给实现的人进行鞭打。
- en: The very existence of Libtool stands as a witness to the truth of this sentiment.
    Libtool exists for only one reason—to provide a standardized, abstract interface
    for developers who want to create and access shared libraries in a portable manner.
    It abstracts both the shared-library build process and the programming interfaces
    used to dynamically load and access shared libraries at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 的存在本身就是这句话真理的见证。Libtool 存在的唯一原因是——为那些希望以可移植方式创建和访问共享库的开发者提供一个标准化、抽象的接口。它抽象了共享库构建过程和在运行时动态加载与访问共享库所用的编程接口。
- en: The Libtool package concept was designed, and initial implementation was done,
    by Gordon Matzigkeit in March of 1996\. Before this time, there was no standard,
    cross-platform mechanism for building shared libraries. Autoconf and Automake
    worked great for building portable projects across many platforms—as long as you
    didn’t try to build a shared library. Once you started down this path, however,
    your code and build system would become littered with conditional constructs for
    shared-library management. This was a monumental effort because, as we shall see,
    building shared libraries is significantly different among some platforms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 包概念是由 Gordon Matzigkeit 在 1996 年 3 月设计并初步实现的。在此之前，没有标准的跨平台机制用于构建共享库。Autoconf
    和 Automake 在构建可移植项目时表现得非常好——只要你不尝试构建共享库。然而，一旦你开始这条路，你的代码和构建系统就会充满用于共享库管理的条件构造。这是一个巨大的工程，因为，正如我们将看到的，构建共享库在某些平台上有显著不同。
- en: Thomas Tanner began contributing in November of 1998 with his cross-platform
    abstraction for shared-library dynamic loading—*ltdl*. Other contributors since
    that time include Alexandre Oliva, Ossama Othman, Robert Boehne, Scott James Remnant,
    Peter O’Gorman, and Ralf Wildenhues. Currently, the Libtool package is maintained
    by Gary V. Vaughn (who has also been contributing to Libtool since 1998) and Bob
    Friesenhahn (whose excellent suggestions have been incorporated since 1998).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Thomas Tanner 从 1998 年 11 月开始贡献了他的跨平台抽象用于共享库动态加载——*ltdl*。自那时以来，其他贡献者包括 Alexandre
    Oliva、Ossama Othman、Robert Boehne、Scott James Remnant、Peter O’Gorman 和 Ralf Wildenhues。目前，Libtool
    包由 Gary V. Vaughn（自 1998 年以来一直在贡献）和 Bob Friesenhahn（自 1998 年以来他的优秀建议被采纳）维护。
- en: Before I get into a discussion of the proper use of Libtool, I’ll spend a few
    paragraphs on the features and functionality that shared libraries provide so
    you understand the scope of the material I’m covering here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始讨论 Libtool 的正确使用之前，我会用几段话介绍共享库所提供的功能和特性，以便你理解我所涉及内容的范围。
- en: The Benefits of Shared Libraries
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享库的好处
- en: Shared libraries provide a way to deploy reusable chunks of functionality in
    a convenient package. You can load shared libraries into a process address space
    either automatically at program load time, by using the operating system loader,
    or manually via code in the application itself. The point at which an application
    binds functionality from a shared library is very flexible, and the developer
    determines it based on the program’s design and the end user’s needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库提供了一种以方便的方式部署可重用功能块的方式。你可以通过操作系统加载器在程序加载时自动将共享库加载到进程地址空间中，或者通过应用程序本身的代码手动加载。应用程序从共享库绑定功能的时机非常灵活，开发者可以根据程序设计和最终用户需求来确定这一点。
- en: The interfaces between the program executable and the modules defined as shared
    libraries must be reasonably well designed because shared-library interfaces must
    be well specified. This rigorous specification promotes good design practices.
    When you use shared libraries, the system essentially forces you to be a better
    programmer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可执行文件和定义为共享库的模块之间的接口必须设计得合理，因为共享库接口必须有明确的规范。这种严格的规范促进了良好的设计实践。当你使用共享库时，系统本质上迫使你成为一个更好的程序员。
- en: Shared libraries may be (as the name implies) shared among processes. This sharing
    is very literal. The code segments for a shared library can be loaded once into
    physical memory pages. Those same memory pages can then be mapped into the process
    address spaces of multiple programs at once. The data pages must, of course, be
    unique for each process, but global data segments are often small compared to
    the code segments of a shared library. This is true efficiency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库可能（正如名字所示）在进程之间共享。这种共享非常字面化。共享库的代码段可以一次加载到物理内存页中。这些相同的内存页可以同时映射到多个程序的进程地址空间中。当然，数据页必须对于每个进程是唯一的，但全局数据段通常比共享库的代码段要小得多。这才是真正的高效。
- en: It is easy to update shared libraries during program upgrades. Even if the base
    program doesn’t change between two revisions of a software package, you can replace
    an old version of a shared library with a new one, as long as the new version’s
    interfaces have not been changed. If interfaces *have* changed, two versions of
    the same shared library may reside together within the same directory, because
    the versioning schemes used by shared libraries (and supported by Libtool) on
    various platforms allow multiple versions of a library to be named differently
    in the filesystem but treated as the same library by the operating system loader.
    Older programs will continue to use older versions of the library, while newer
    programs are free to use the newer versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序升级过程中，更新共享库非常简单。即使基础程序在软件包的两个版本之间没有变化，只要新版本的接口没有发生变化，你就可以用新的共享库版本替换旧版本。如果接口*发生了*变化，同一个共享库的两个版本可能会共存在同一个目录中，因为共享库使用的版本控制机制（并且被
    Libtool 支持）允许在不同平台上，同一库的多个版本可以在文件系统中有不同的命名，但操作系统加载器将其视为同一个库。旧程序将继续使用旧版本的库，而新程序可以自由地使用新版本。
- en: If a software package specifies a well-defined plug-in interface, then shared
    libraries can be used to implement user-configurable loadable functionality. This
    means that additional functionality can become available to a program after it
    has been released, and third-party developers can even add functionality to your
    program, if you publish a document describing your plug-in interface specification
    (or if they’re smart enough to figure it out on their own).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个软件包定义了一个明确的插件接口，那么共享库可以用来实现用户可配置的可加载功能。这意味着，在程序发布后，额外的功能可以变得可用，第三方开发者甚至可以为你的程序添加功能，前提是你发布了描述插件接口规范的文档（或者他们足够聪明，能够自己弄明白）。
- en: There are a few widely known examples of these types of systems. Eclipse, for
    instance, is almost a pure plug-in framework. The base executable supports little
    more than a well-defined plug-in interface. Most of the functionality in an Eclipse
    application comes from library functions. Eclipse is written in Java and uses
    Java class libraries and *.jar* files, but the principle is the same, regardless
    of the language or platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些广为人知的这类系统示例。例如，Eclipse 几乎是一个纯粹的插件框架。基础可执行文件支持的功能仅仅是一个明确的插件接口。Eclipse 应用程序中的大部分功能来自于库函数。Eclipse
    是用 Java 编写的，使用 Java 类库和 *.jar* 文件，但这一原理是相同的，无论语言或平台如何。
- en: How Shared Libraries Work
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享库是如何工作的
- en: The specifics of how POSIX-compliant operating systems implement shared libraries
    vary from platform to platform, but the general idea is the same. Shared libraries
    provide chunks of executable code that the operating system can load into a program’s
    address space and execute. The following discussion applies to shared-library
    references that the linker resolves when a program is built and the operating
    system loader resolves when the program is loaded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 兼容操作系统实现共享库的具体方式因平台而异，但基本思路是相同的。共享库提供了操作系统可以加载到程序地址空间并执行的可执行代码块。以下讨论适用于链接器在构建程序时解析的共享库引用以及操作系统加载器在加载程序时解析的引用。
- en: While the object (*.o*) files produced by compilers do contain executable code,
    they cannot be executed by themselves from the command line. This is because they’re
    incomplete, containing symbolic references or *links* to external entities (functions
    and global data items) that must be patched up. This patching is done by using
    a tool designed to manage such links to combine the complete set of object files
    containing such references.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译器生成的目标文件（*.o*）包含可执行代码，但它们不能直接从命令行执行。这是因为它们是不完整的，包含了指向外部实体（函数和全局数据项）的符号引用或*链接*，这些需要修补。这个修补过程是通过使用专门的工具来管理这些链接，以便将包含这些引用的目标文件集合起来。
- en: '*Dynamic Linking at Load Time*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*动态链接时加载*'
- en: As a program executable image is being built, the linker (formally called a
    *link editor*) maintains a table of symbols—function entry points and global data
    addresses. Each symbol referenced within the accumulating body of object code
    is added to this table as the linker finds it. As symbol definitions are located,
    the linker resolves symbol references in the table to their addresses in the code.
    At the end of the linking process, all object files (or simply *objects*) containing
    referenced symbol definitions are linked together and become part of the program
    executable image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建程序可执行映像时，链接器（正式称为*链接编辑器*）维护一个符号表——函数入口点和全局数据地址。链接器在发现每个符号时，都会将其添加到符号表中。随着符号定义的找到，链接器将符号表中的符号引用解析为代码中的地址。在链接过程结束时，所有包含引用符号定义的目标文件（或简称*目标文件*）会被链接在一起，并成为程序可执行映像的一部分。
- en: Objects found in static libraries (also called archives) that contain no referenced
    symbol definitions are discarded, but objects linked explicitly are added to the
    binary image even if they contain no referenced symbol definitions. If there are
    outstanding references in the symbol table after all the objects have been analyzed,
    the linker exits with an error message. On success, the final executable image
    may be loaded and executed by a user. The image is now entirely self-contained,
    depending on no external binary code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态库中（也称为档案）找到的、没有引用符号定义的目标文件将被丢弃，但显式链接的目标文件会被添加到二进制映像中，即使它们没有引用符号定义。如果在分析完所有目标文件后，符号表中仍有未解决的引用，链接器将退出并显示错误信息。若成功，最终的可执行映像可以被用户加载并执行。此时，映像已经完全自包含，不再依赖任何外部二进制代码。
- en: Assuming that all undefined references are resolved during the linking process,
    if the list of objects to be linked contains one or more shared libraries, the
    linker will build the executable image from all *nonshared* objects specified
    on the linker command line. This includes all individual object files (*.o*) and
    all objects contained in static library archives (*.a*). However, the linker will
    add two tables to the binary image header. The first is the outstanding *external
    reference table*—a table of references to symbol definitions found only in shared
    libraries during the linking process. The second is the *shared-library table*,
    containing the list of shared-library names and versions in which the outstanding
    undefined references were found.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有未定义的引用都在链接过程中解决，如果要链接的目标文件列表包含一个或多个共享库，链接器将从命令行上指定的所有*非共享*目标文件中构建可执行映像。这包括所有单独的目标文件（*.o*）和所有包含在静态库档案（*.a*）中的目标文件。然而，链接器将向二进制映像头部添加两个表。第一个是未解决的*外部引用表*——一个在链接过程中只在共享库中找到的符号定义的引用表。第二个是*共享库表*，包含在未解决的未定义引用中找到的共享库名称和版本的列表。
- en: When the operating system loader attempts to load the program, it must resolve
    the remaining outstanding references in the external reference table to symbols
    imported from the shared libraries named in the shared-library table. If the loader
    can’t resolve all of the references, then a load error occurs, and the process
    is terminated with an operating system error message. Note that these external
    symbols are not tied to a specific shared library. As long as they’re found in
    any one of the searched libraries in the shared-library table, they’re accepted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统加载程序时，加载器必须解析外部引用表中剩余的未解决引用，这些引用指向共享库表中列出的共享库中的符号。如果加载器无法解决所有引用，则会发生加载错误，进程将终止并显示操作系统错误信息。请注意，这些外部符号并不绑定到特定的共享库。只要它们出现在共享库表中搜索到的任何一个库中，就会被接受。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This process differs slightly from the way a Windows operating system loader
    resolves symbols in dynamic link libraries (DLLs). On Windows, the linker ties
    a particular symbol to a specifically named DLL at program build time.^([1](footnote.xhtml#ch07fn1))*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个过程与Windows操作系统加载器解析动态链接库（DLL）中的符号的方式略有不同。在Windows中，链接器会在程序构建时将特定符号与特定命名的DLL绑定。^([1](footnote.xhtml#ch07fn1))*'
- en: Using free-floating external references has both pros and cons. On some operating
    systems, unbound symbols can be satisfied by a library specified by the user.
    That is, a user can entirely replace a library (or a portion of a library) at
    runtime by simply preloading one that contains the same symbols. On BSD and Linux-based
    systems, for example, a user can use the `LD_PRELOAD` environment variable to
    inject a shared library into a process address space. Since the loader loads these
    libraries before any other libraries, the loader will locate symbols in the preloaded
    libraries when it tries to resolve external references. The program author’s intended
    libraries will not even be checked because the symbols provided by these libraries
    have already been resolved by the preloaded libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自由浮动的外部引用有其利弊。在某些操作系统中，未绑定的符号可以由用户指定的库来满足。也就是说，用户可以通过简单地预加载一个包含相同符号的库，在运行时完全替换一个库（或库的一部分）。例如，在基于BSD和Linux的系统中，用户可以使用`LD_PRELOAD`环境变量将一个共享库注入到进程的地址空间中。由于加载器在任何其他库之前加载这些库，因此当加载器尝试解析外部引用时，会首先在预加载的库中查找符号。程序作者预期的库甚至不会被检查，因为这些库提供的符号已经被预加载的库解决。
- en: In the following example, the Linux `df` utility is executed with an environment
    containing the `LD_PRELOAD` variable. This variable has been set to a path referring
    to a library that presumably contains a heap manager that’s compatible with the
    C *malloc* interface. This technique can be used to debug memory problems in your
    programs. By preloading your own heap manager, you can capture memory allocations
    in a log file—in order to debug memory block overruns, for instance. This sort
    of technique is used by such widely known debugging aids as the *Valgrind* package.^([2](footnote.xhtml#ch07fn2))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，Linux的`df`工具在包含`LD_PRELOAD`变量的环境中执行。这个变量被设置为指向一个库的路径，这个库假定包含一个与C的*malloc*接口兼容的堆管理器。这个技术可以用于调试程序中的内存问题。通过预加载你自己的堆管理器，你可以在日志文件中捕获内存分配——例如调试内存块溢出问题。这种技术被像*Valgrind*工具包等广为人知的调试工具所使用。^([2](footnote.xhtml#ch07fn2))
- en: 'Here, the `LD_PRELOAD` environment variable is set on the same command line
    used to execute the `df` program. This shell code causes only the `df` child process
    environment to contain the `LD_PRELOAD` variable, set to the specified value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LD_PRELOAD`环境变量设置在与执行`df`程序相同的命令行中。此shell代码会使只有`df`子进程的环境包含`LD_PRELOAD`变量，并将其设置为指定的值：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, free-floating symbols can also lead to problems. For instance,
    two libraries can provide the same symbol name, and the dynamic loader can inadvertently
    bind an executable to a symbol from the wrong library. At best, this will cause
    a program crash when the wrong arguments are passed to the mismatched function.
    At worst, it can present security risks because the mismatched function might
    be used to capture passwords and security credentials passed by the unsuspecting
    program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，自由浮动符号也可能引发问题。例如，两个库可能提供相同的符号名称，而动态加载器可能不小心将可执行文件绑定到错误库中的符号上。最好的情况下，这将导致程序崩溃，当错误的参数被传递给不匹配的函数时。最坏的情况是，它可能带来安全风险，因为不匹配的函数可能会用来捕获未经怀疑的程序传递的密码和安全凭证。
- en: C-language symbols do not include parameter information, so it’s rather likely
    that symbols will clash in this manner. C++ symbols are a bit safer, in that the
    entire function signature (minus the return type) is encoded into the symbol name.
    However, even C++ is not immune to hackers who purposely replace security functions
    with their own versions of those functions (assuming, of course, that they have
    access to your runtime shared-library search path).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C语言符号不包含参数信息，因此符号发生冲突的可能性较大。C++符号稍微安全一些，因为整个函数签名（不包括返回类型）会被编码进符号名称中。然而，即便是C++也不能免疫黑客故意将安全函数替换为他们自己版本的函数（当然，前提是黑客能够访问你的运行时共享库搜索路径）。
- en: Automatic Dynamic Linking at Runtime
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行时自动动态链接
- en: The operating system loader can also use a very late form of binding, often
    referred to as *lazy binding*. In this situation, the external reference table
    entries in the program header are initialized so that they refer to code within
    the dynamic loader itself.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统加载器还可以使用一种非常晚期的绑定形式，通常称为*懒绑定*。在这种情况下，程序头中的外部引用表条目被初始化，使它们引用动态加载器本身中的代码。
- en: When a program first calls a *lazy entry*, the call is routed to the loader,
    which will then (potentially) load the proper shared library, determine the actual
    address of the function, reset the entry point in the jump table, and, finally,
    redirect the processor to the shared-library function (which is now available).
    The next time this happens, the jump table entry will have already been correctly
    initialized, and the program will jump directly to the called function. This is
    very efficient both because the overhead for the jump after fix-up is no more
    than a normal indirect function call and because the cost of the initial load
    and link is amortized over many calls to the function during the lifetime of the
    process.^([3](footnote.xhtml#ch07fn3))
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序首次调用*懒惰入口*时，调用会被路由到加载器，加载器将（可能）加载正确的共享库，确定函数的实际地址，重置跳转表中的入口点，最后将处理器重定向到共享库中的函数（现在可用）。下次发生这种情况时，跳转表条目将已经正确初始化，程序将直接跳转到被调用的函数。这是非常高效的，因为修正后的跳转开销与正常的间接函数调用相当，而且初始加载和链接的成本会在整个进程生命周期中通过多次调用该函数得到摊销。^([3](footnote.xhtml#ch07fn3))
- en: This lazy binding mechanism makes program startup very fast because shared libraries
    whose symbols are not bound until they’re needed aren’t even loaded until the
    application program first references them. But, consider this—the program may
    *never* reference them. And that means they may never be loaded, saving both time
    and space. A good example of this sort of situation might be a word processor
    with a thesaurus feature implemented in a shared library. How often do you use
    your thesaurus? If the program is using automatic dynamic linking, chances are
    that the shared library containing the thesaurus code will never be loaded in
    most word-processing sessions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种懒绑定机制使得程序启动非常快，因为共享库的符号直到需要时才会绑定，甚至在应用程序首次引用它们之前，这些库根本不会被加载。但请考虑一下——程序*可能永远*不会引用它们。这意味着这些库可能永远不会被加载，从而节省了时间和空间。一个很好的例子可能是一个带有同义词库功能的文字处理器，它是通过共享库实现的。你有多频繁使用同义词库？如果程序使用的是自动动态链接，通常情况下，包含同义词库代码的共享库在大多数文字处理过程中可能永远不会被加载。
- en: As good as this system appears to be, there can be problems. While using automatic
    runtime dynamic linking can give you faster load times, better performance, and
    more efficient use of space, it can also cause your application to terminate abruptly
    and without warning. In the event that the loader can’t find the requested symbol—perhaps
    the required library is missing—it has no recourse except to abort the process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个系统看起来非常好，但也可能存在一些问题。虽然使用自动运行时动态链接可以提高加载速度、提升性能并更有效地利用空间，但它也可能导致应用程序突然终止且没有任何警告。如果加载器无法找到请求的符号——可能是缺少所需的库——它除了中止进程之外别无他法。
- en: Why not ensure that all symbols exist when the program is loaded? Because if
    the loader resolved all symbols at load time, it might as well populate the jump
    table entries at that point, too. After all, it had to load all the libraries
    to ensure that the symbols actually exist, so this would entirely defeat the purpose
    of using lazy binding. Furthermore, even if the loader did check all external
    references when the program was first started, there’s nothing to stop someone
    from deleting one or more of these libraries before the program uses them, while
    the program is still running.^([4](footnote.xhtml#ch07fn4)) Thus, even the pre-check
    is defeated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在程序加载时确保所有符号都存在呢？因为如果加载器在加载时解决了所有符号，它也许还会在那个时候填充跳转表条目。毕竟，它必须加载所有库以确保符号确实存在，因此这将完全违背使用懒绑定的初衷。此外，即使加载器在程序首次启动时检查了所有外部引用，也没有什么能阻止某人在程序使用这些库之前删除一个或多个这些库，而程序仍在运行中。^([4](footnote.xhtml#ch07fn4))因此，甚至预检查也被打破了。
- en: The moral of this story is that there’s no free lunch. If you don’t want to
    pay the insurance premium for longer up-front load times and more space consumed
    (even if you may never really need it), then you may have to take the hit of a
    missing symbol at runtime, causing a program crash.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是：没有免费的午餐。如果你不想为较长的前期加载时间和更多的空间消耗支付保险费（即使你可能永远不需要它），那么你可能不得不承担在运行时缺少符号的风险，导致程序崩溃。
- en: Manual Dynamic Linking at Runtime
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行时手动动态链接
- en: One possible solution to the aforementioned problem is to take personal responsibility
    for some of the system loader’s work. Then, when things don’t go right, you have
    a little more control over the outcome. In the case of the thesaurus module, was
    it really necessary to terminate the program if the thesaurus library could not
    be loaded or didn’t provide the correct symbols? Of course not—but the operating
    system loader can’t know that. Only the software programmer can make such judgment
    calls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述问题的一个可能方法是让程序对系统加载器的一部分工作负责。这样，当事情出错时，程序对结果有更多的控制权。在词库模块的例子中，如果无法加载词库或词库没有提供正确的符号，真的有必要终止程序吗？当然没有——但是操作系统加载器无法知道这一点，只有软件程序员能做出这样的判断。
- en: When a program manages dynamic linking manually at runtime, the linker is left
    out of the equation entirely, and the program doesn’t call any exported shared-library
    functions directly. Rather, shared-library functions are referenced through function
    pointers that the program itself populates at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在运行时手动管理动态链接时，链接器完全不参与其中，程序不会直接调用任何导出的共享库函数。相反，共享库函数通过程序在运行时填充的函数指针进行引用。
- en: 'Here’s how it works: A program calls an operating system function (`dlopen`)
    to manually load a shared library into its own process address space. This function
    returns a *handle*, or an opaque value representing the loaded library. The program
    then calls another loader function (`dlsym`) to import a symbol from the library
    to which the handle refers. If all goes well, the operating system returns the
    address of the requested function or data item from the desired library. The program
    may then call the function, or access the global data item, through this pointer.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：一个程序调用操作系统的函数（`dlopen`）手动将共享库加载到它自己的进程地址空间中。这个函数返回一个*句柄*，即一个表示已加载库的不透明值。程序接着调用另一个加载函数（`dlsym`）从句柄所指向的库中导入一个符号。如果一切顺利，操作系统会返回所请求的函数或数据项的地址。然后，程序可以通过这个指针调用函数或访问全局数据项。
- en: If something goes wrong in this process—the symbol isn’t found within the library
    or the library isn’t found—then it becomes the responsibility of the program to
    define the results, perhaps by displaying an error message indicating that the
    program was not configured correctly. In the preceding example of the word processor,
    a simple dialog indicating that the thesaurus is unavailable would be entirely
    sufficient.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个过程中出了问题——符号在库中找不到或库找不到——那么就由程序来定义结果，可能通过显示错误信息来提示程序配置不正确。在前面的文字处理器例子中，一个简单的对话框提示词库不可用就完全足够了。
- en: This is a little nicer than the way automatic dynamic runtime linking works;
    while the loader has no option but to abort, the application has a higher-level
    perspective and can handle the problem much more gracefully. The drawback, of
    course, is that you as the programmer have to manage the process of loading libraries
    and importing symbols within your application code. However, this process is not
    very difficult, as I’ll demonstrate in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这比自动动态运行时链接方式稍好一些；虽然加载器别无选择只能中止，但应用程序有更高层次的视角，可以更优雅地处理问题。当然，缺点是作为程序员的你必须在应用程序代码中管理加载库和导入符号的过程。不过，这个过程并不困难，正如我将在下一章中演示的那样。
- en: Using Libtool
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Libtool
- en: An entire book could be written about the details of shared libraries and how
    they’re implemented on various systems. The short primer you just read should
    suffice for our immediate needs, so I’ll now move on to how you can use Libtool
    to make a package maintainer’s life a little easier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共享库及其在各种系统中实现的细节，可以写一本完整的书。你刚刚阅读的简短入门内容已经足够满足我们的眼前需求，现在我将继续讲解如何使用 Libtool
    让包维护者的工作变得更轻松。
- en: The Libtool project was designed to extend Automake, but you can use it independently
    within hand-coded makefiles, as well. As of this writing, the latest version of
    Libtool, and the one I’m using in the examples here, is version 2.4.6.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 项目的设计初衷是扩展 Automake，但你也可以在手动编写的 Makefile 中独立使用它。截止目前，Libtool 的最新版本是
    2.4.6，也是我在此示例中使用的版本。
- en: '*Abstracting the Build Process*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建过程抽象*'
- en: First, let’s look at how Libtool helps during the build process. Libtool provides
    a script (*ltmain.sh*) that `config.status` consumes in a Libtool-enabled project.
    The `config.status` script converts `configure` test results and the `ltmain.sh`
    script into a custom version of the `libtool` script, specifically tailored to
    your project.^([5](footnote.xhtml#ch07fn5)) Your project’s makefiles then use
    this `libtool` script to build the shared libraries listed in any Automake product
    list variables defined with the Libtool-specific `LTLIBRARIES` primary. The `libtool`
    script is really just a fancy wrapper around the compiler, linker, and other tools.
    You should ship the `ltmain.sh` script in a distribution archive, as part of your
    build system. Automake-generated rules ensure that this happens properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下 Libtool 如何在构建过程中提供帮助。Libtool 提供了一个脚本（*ltmain.sh*），`config.status`
    会在 Libtool 启用项目中使用。`config.status` 脚本将 `configure` 测试结果和 `ltmain.sh` 脚本转化为一个定制版的
    `libtool` 脚本，专门为你的项目量身定制。^([5](footnote.xhtml#ch07fn5)) 然后，你项目的 Makefile 使用这个
    `libtool` 脚本来构建任何在 Automake 产品列表变量中列出的共享库，这些变量是通过 Libtool 特定的 `LTLIBRARIES` 主项定义的。`libtool`
    脚本实际上只是编译器、链接器和其他工具的一个华丽包装。你应该在发布归档中随项目一起提供 `ltmain.sh` 脚本，作为构建系统的一部分。Automake
    生成的规则会确保这一过程正确执行。
- en: The `libtool` script insulates the author of the build system from the nuances
    of building shared libraries on different platforms. This script accepts a well-defined
    set of options, converting them to appropriate platform- and linker-specific options
    on the target platform and toolset. Thus, the maintainer doesn’t need to worry
    about the specifics of building shared libraries on each platform—they only need
    to understand the available `libtool` script options. These options are well specified
    in the *GNU Libtool Manual*,^([6](footnote.xhtml#ch07fn6)) and I’ll cover many
    of them in this chapter and the next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`libtool` 脚本将构建系统的作者与在不同平台上构建共享库的细节隔离开来。此脚本接受一组明确定义的选项，将它们转换为目标平台和工具集上特定的、适当的平台和链接器选项。因此，维护者无需担心在每个平台上构建共享库的具体细节——他们只需了解可用的
    `libtool` 脚本选项。这些选项在*GNU Libtool Manual*中有详细说明，^([6](footnote.xhtml#ch07fn6))
    我将在本章和下一章中讲解其中的许多选项。'
- en: On systems that don’t support shared libraries at all, the `libtool` script
    uses appropriate commands and options to build and link only static archive libraries.
    Furthermore, the maintainer doesn’t have to worry about the differences between
    building shared libraries and building static libraries when using Libtool. You
    can emulate building your package on a static-only system by using the `--disable-shared`
    option on the `configure` command line for your Libtool-enabled project. This
    option causes Libtool to assume that shared libraries cannot be built on the target
    system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持共享库的系统上，`libtool` 脚本使用适当的命令和选项来构建和链接仅静态归档库。此外，维护者在使用 Libtool 时，无需担心构建共享库和构建静态库之间的差异。你可以通过在
    Libtool 启用项目的 `configure` 命令行上使用 `--disable-shared` 选项来模拟在仅静态系统上构建你的包。此选项会使 Libtool
    假定目标系统无法构建共享库。
- en: '*Abstraction at Runtime*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*运行时抽象*'
- en: You can also use Libtool to abstract the programming interfaces the operating
    system supplies for loading libraries and importing symbols. If you’ve ever dynamically
    loaded a library on a Linux system, you’re familiar with the standard POSIX shared-library
    API, including the `dlopen`, `dlsym`, and `dlclose` functions. A system-level
    shared library, usually called simply *dl*, provides these functions. This translates
    to a binary image file named *libdl.so* (or something similar on systems that
    use different library-naming conventions).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Libtool 抽象操作系统提供的库加载和符号导入的编程接口。如果你曾在 Linux 系统上动态加载过一个库，那么你就熟悉标准的 POSIX
    共享库 API，包括 `dlopen`、`dlsym` 和 `dlclose` 函数。系统级共享库，通常简称为 *dl*，提供了这些函数。这通常会转化为一个名为
    *libdl.so* 的二进制镜像文件（在使用不同库命名约定的系统中，名称可能不同）。
- en: Unfortunately, not all Unix systems that support shared libraries provide the
    *libdl.so* library or functions using these names. To address these differences,
    Libtool provides a shared library called *ltdl*, which exports a clean, portable,
    library-management interface that is very similar to the POSIX *dl* interface.
    The use of this library is optional, of course, but it is highly recommended because
    it provides more than just a common API across shared-library platforms—it also
    provides an abstraction for manual dynamic linking between shared-library and
    non-shared-library platforms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有支持共享库的 Unix 系统都提供名为 *libdl.so* 的库或函数。为了解决这些差异，Libtool 提供了一个名为 *ltdl*
    的共享库，它导出了一个清晰、可移植的库管理接口，类似于 POSIX *dl* 接口。使用这个库是可选的，但强烈建议使用，因为它不仅在共享库平台之间提供了一个通用的
    API，还为共享库与非共享库平台之间的手动动态链接提供了一个抽象层。
- en: '*What?! How can that work?!* On systems that don’t support shared libraries,
    Libtool actually creates internal symbol tables within the executable that contain
    all the symbols you would otherwise find within shared libraries (on systems that
    support shared libraries). By using such symbol tables on these platforms, the
    `lt_dlopen` and `lt_dlsym` functions can make your code appear to be loading libraries
    and importing symbols, when in fact, the library load function does nothing more
    than return a handle to the appropriate internal symbol table, and the import
    function merely returns the address of code that has been statically linked into
    the program itself. On these systems, a project’s shared-library code is linked
    directly into the programs that would normally load them at runtime.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么？！这怎么可能工作？！* 在不支持共享库的系统上，Libtool 实际上在可执行文件内部创建了符号表，包含所有原本会在共享库中找到的符号（在支持共享库的系统上）。通过在这些平台上使用这些符号表，`lt_dlopen`
    和 `lt_dlsym` 函数可以让你的代码看起来像是加载了库并导入了符号，实际上，库加载函数只是返回一个指向相应内部符号表的句柄，而导入函数仅返回已静态链接到程序本身的代码地址。在这些系统上，项目的共享库代码会直接链接到通常在运行时加载它们的程序中。'
- en: Installing Libtool
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Libtool
- en: If you want to make use of the latest version of Libtool while developing your
    packages, you may find that you either have to download, build, and install it
    manually or look for an updated *libtool* package from your distribution provider.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在开发你的软件包时使用 Libtool 的最新版本，你可能会发现你需要手动下载、构建并安装它，或者寻找分发提供商提供的更新版 *libtool*
    包。
- en: 'Downloading, building, and installing Libtool is really trivial, as you’ll
    see here. However, you should check the GNU Libtool website^([7](footnote.xhtml#ch07fn7))
    before executing these steps in order to ensure you’re getting the most recent
    package. I’ve reproduced the basic steps here from [Chapter 1](ch01.xhtml):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下载、构建和安装 Libtool 实际上非常简单，正如你在这里看到的那样。然而，在执行这些步骤之前，你应该检查一下 GNU Libtool 网站^([7](footnote.xhtml#ch07fn7))，以确保你获得的是最新的软件包。我已经从[第
    1 章](ch01.xhtml)中复制了基本步骤：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be aware that the default installation location (as with most of the GNU packages)
    is */usr/local*. If you wish to install Libtool into the */usr* hierarchy, you’ll
    need to use the `--prefix=/usr` option on the `configure` command line. The recommended
    practice is to install distribution-provided packages into the */usr* hierarchy
    and user-built packages into the */usr/local* tree, but if you’re trying to get
    a hand-built version of Libtool to interoperate with distribution-provided versions
    of Autoconf and Automake, you may have to install Libtool into the */usr* hierarchy.
    The simplest way to avoid problems with package interdependencies is to install
    hand-built versions of all three packages into */usr/local* or, better still,
    into a directory within your home directory, which you can then add to your `PATH`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认的安装位置（与大多数 GNU 包一样）是 */usr/local*。如果你希望将 Libtool 安装到 */usr* 目录下，你需要在 `configure`
    命令行中使用 `--prefix=/usr` 选项。推荐的做法是将分发提供的软件包安装到 */usr* 目录下，将用户自行构建的软件包安装到 */usr/local*
    目录下，但如果你想让手工构建的 Libtool 版本与分发提供的 Autoconf 和 Automake 版本兼容，你可能需要将 Libtool 安装到 */usr*
    目录下。避免软件包相互依赖问题的最简单方法是将所有三个软件包的手工构建版本安装到 */usr/local*，或者更好的是，安装到你家目录下的某个目录，并将该目录添加到你的
    `PATH` 中。
- en: Adding Shared Libraries to Jupiter
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将共享库添加到 Jupiter
- en: Now that I’ve presented the requisite background information, let’s take a look
    at how we might add a Libtool shared library to the Jupiter project. First, let’s
    consider what functionality we could add to Jupiter using a shared library. Perhaps
    we want to provide our users with some library functionality that their own applications
    could use. Or we might have several applications in a package that need to share
    the same functionality. A shared library is a great tool for both of these scenarios
    because you get to reuse code and save memory—the cost of the memory used by shared
    code is amortized across multiple applications, both internal and external to
    the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了必要的背景信息，接下来我们来看看如何将 Libtool 共享库添加到 Jupiter 项目中。首先，让我们考虑使用共享库可以为 Jupiter
    添加哪些功能。也许我们想为用户提供一些库功能，供他们自己的应用程序使用。或者我们可能有一个包含多个应用程序的包，这些应用程序需要共享相同的功能。共享库对于这两种场景都是一个很好的工具，因为它可以让你重用代码并节省内存——共享代码使用的内存成本会在多个应用程序中摊销，这些应用程序可以是项目内部的，也可以是外部的。
- en: Let’s add a shared library to Jupiter that provides Jupiter’s printing functionality.
    We can do this by having the new shared library call into the *libjupcommon.a*
    static library. Remember that calling a routine in a static library has the same
    effect as linking the object code for the called routine right into the calling
    program. The called routine ultimately becomes an integral part of the calling
    binary image (program or shared library).^([8](footnote.xhtml#ch07fn8))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 Jupiter 添加一个提供打印功能的共享库。我们可以通过让新的共享库调用 *libjupcommon.a* 静态库来实现这一点。记住，调用静态库中的例程与将被调用的例程的目标代码直接链接到调用程序中是一样的。被调用的例程最终会成为调用的二进制镜像（程序或共享库）的一个不可分割的部分。^([8](footnote.xhtml#ch07fn8))
- en: Additionally, we’ll provide a public header file from the Jupiter project that
    will allow external applications to call this same functionality. This allows
    other applications to display stuff in the same quaint manner that the `jupiter`
    program does. (This would be significantly cooler if we were doing something useful
    in Jupiter, but you get the idea.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将提供一个来自 Jupiter 项目的公共头文件，允许外部应用程序调用相同的功能。这样，其他应用程序就可以以与 `jupiter` 程序相同的方式显示内容。（如果我们在
    Jupiter 中做一些更有用的事情，这样会显得更酷，但你明白我的意思。）
- en: '*Using the LTLIBRARIES Primary*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用 LTLIBRARIES 主体*'
- en: Automake has built-in support for Libtool; it’s the Automake package, rather
    than the Libtool package, that provides the `LTLIBRARIES` primary. Libtool doesn’t
    really qualify as a pure Automake extension but rather is more of an add-on package
    for Automake, where Automake provides the necessary infrastructure for this specific
    add-on package. You can’t access Automake’s `LTLIBRARIES` primary functionality
    without Libtool because the use of this primary generates `make` rules that call
    the `libtool` script.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 内置对 Libtool 的支持；提供 `LTLIBRARIES` 主体的是 Automake 包，而不是 Libtool 包。Libtool
    并不完全算是一个纯粹的 Automake 扩展，它更像是 Automake 的一个附加包，Automake 为这个特定的附加包提供必要的基础设施。没有 Libtool，你无法访问
    Automake 的 `LTLIBRARIES` 主体功能，因为使用这个主体会生成调用 `libtool` 脚本的 `make` 规则。
- en: Libtool ships separately, rather than as part of Automake, because you can use
    Libtool quite effectively independently of Automake. If you want to try Libtool
    by itself, I’ll refer you to the *GNU Libtool Manual*; the opening chapters describe
    the use of the `libtool` script as a stand-alone product. It’s as simple as modifying
    your makefile commands so that the compiler, linker, and librarian are called
    through the `libtool` script, and then modifying some of your command line parameters
    as required by Libtool.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 单独发布，而不是作为 Automake 的一部分，因为你可以相当有效地独立使用 Libtool。如果你想单独尝试 Libtool，我会把你引导到*GNU
    Libtool 手册*；手册的开头几章描述了如何将 `libtool` 脚本作为独立产品使用。只需要修改你的 makefile 命令，使得编译器、链接器和库管理器通过
    `libtool` 脚本调用，然后根据 Libtool 的要求修改一些命令行参数，就能实现这一点。
- en: '*Public Include Directories*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*公共包含目录*'
- en: A project subdirectory named *include* should only contain public header files—those
    that expose a public interface in your project. We’re now going to add just such
    a header file to the Jupiter project, so we’ll create a directory called *include*
    in the project root directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 *include* 的项目子目录应只包含公共头文件——那些在你的项目中暴露公共接口的文件。我们现在将向 Jupiter 项目中添加这样一个头文件，所以我们将在项目根目录下创建一个名为
    *include* 的目录。
- en: 'If we had multiple shared libraries, we’d have a choice to make: do we create
    separate *include* directories, one in each library source directory, or do we
    add a single, top-level *include* directory? I usually use the following rule
    of thumb to make my decision: If the libraries are designed to work together as
    a group, and if consuming applications generally use the libraries together, then
    I use a single, top-level *include* directory. If, on the other hand, the libraries
    can be effectively used independently, and if they offer fairly autonomous sets
    of functionality, then I provide individual *include* directories in the libraries’
    own directories.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个共享库，我们需要做出选择：是为每个库的源目录创建单独的 *include* 目录，还是添加一个单一的顶层 *include* 目录？我通常使用以下经验法则来做决定：如果这些库是作为一个组一起工作的，并且如果使用这些库的应用程序通常会一起使用它们，那么我会使用一个单一的顶层
    *include* 目录。另一方面，如果这些库可以独立使用，并且它们提供的功能集相对独立，那么我会在各自的库目录中提供单独的 *include* 目录。
- en: In the end, it doesn’t really matter much because the header files for these
    libraries will be installed in directory structures that are entirely different
    from the ones where they exist within your project. In fact, you should make sure
    you don’t inadvertently use the same filename for public headers in two different
    libraries in your project—if you do, you’ll have problems installing these files.
    They generally end up all together in the `$(prefix)`*/include* directory, although
    you can override this default by using either the `includedir` variable or the
    `pkginclude` prefix in your *Makefile.am* files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这其实并不重要，因为这些库的头文件将安装在与你项目中存在的目录结构完全不同的目录中。事实上，你应该确保不会在项目中的两个不同库中不小心使用相同的公共头文件名——如果这样做，你将遇到安装这些文件的问题。它们通常会全部放在
    `$(prefix)`*/include* 目录中，尽管你可以通过在 *Makefile.am* 文件中使用 `includedir` 变量或 `pkginclude`
    前缀来覆盖这个默认设置。
- en: The `includedir` variable allows you to specify where you want your header files
    to be installed by defining the exact value of Automake’s `$(includedir)` variable,
    the usual value of which is `$(prefix)`*/include*. The use of the `pkginclude`
    prefix indicates to Automake that you want your header files to be in a private,
    package-specific directory, beneath the directory indicated by `$(includedir)`,
    called `$(includedir)`*/*`$(PACKAGE)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`includedir` 变量允许你通过定义 Automake 的 `$(includedir)` 变量的确切值来指定你希望将头文件安装到哪里，通常该值是
    `$(prefix)`*/include*。使用 `pkginclude` 前缀表示你希望将头文件放在 `$(includedir)` 目录下的一个私有的、特定于包的子目录中，目录名称为
    `$(includedir)`*/*`$(PACKAGE)`。'
- en: 'We’ll also add another root-level directory (*libjup*) for Jupiter’s new shared
    library, *libjupiter*. These changes require you to add references to the new
    directories to the top-level *Makefile.am* file’s `SUBDIRS` variable and then
    add corresponding *Makefile* references to the `AC_CONFIG_FILES` macro in *configure.ac*.
    Since we’re going to make major changes to our project, we’d better clean up the
    work area before we start. Then we’ll create the directories and add a new *Makefile.am*
    file to the new *include* directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为 Jupiter 的新共享库 *libjupiter* 添加另一个根目录（*libjup*）。这些更改要求你将新目录的引用添加到顶层 *Makefile.am*
    文件的 `SUBDIRS` 变量中，然后在 *configure.ac* 文件中的 `AC_CONFIG_FILES` 宏中添加相应的 *Makefile*
    引用。由于我们将对项目进行重大更改，最好在开始之前清理一下工作区。然后我们将创建目录并将新的 *Makefile.am* 文件添加到新的 *include*
    目录中：
- en: Git tag 7.0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 7.0
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *include* directory’s *Makefile.am* file is trivial—it contains only a single
    line, in which an Automake `HEADERS` primary refers to the public header file
    *libjupiter.h*. Note at ➊ that we’re using the `include` prefix on this primary.
    You’ll recall that this prefix indicates that files specified in this primary
    are destined to be installed in the `$(includedir)` directory (for example, */usr/(local/)include*).
    The `HEADERS` primary is similar to the `DATA` primary in that it specifies a
    set of files that are to be treated simply as data to be installed without modification
    or preprocessing. The only really tangible difference is that the `HEADERS` primary
    restricts the possible installation locations to those that make sense for header
    files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*include* 目录下的 *Makefile.am* 文件非常简单—它仅包含一行，其中一个 Automake 的 `HEADERS` 主体引用了公共头文件
    *libjupiter.h*。注意在 ➊ 处我们在这个主体前使用了 `include` 前缀。你会记得，这个前缀表示在这个主体中指定的文件将被安装到 `$(includedir)`
    目录中（例如，*/usr/(local/)include*）。`HEADERS` 主体类似于 `DATA` 主体，因为它指定了一组文件，这些文件将被当作数据安装，而无需修改或预处理。唯一真正的区别在于，`HEADERS`
    主体将安装位置限制在那些适合头文件的位置。'
- en: The *libjup/Makefile.am* file is a bit more complex, containing four lines as
    opposed to just one. This file is shown in [Listing 7-1](ch07.xhtml#ch07ex1).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*libjup/Makefile.am* 文件比简单的单行文件更复杂，包含了四行内容。该文件显示在[清单7-1](ch07.xhtml#ch07ex1)中。'
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-1:* libjup/Makefile.am: *The initial version of this file*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-1:* libjup/Makefile.am: *该文件的初始版本*'
- en: 'Let’s analyze this file, line by line. The line at ➊ is the primary specification,
    and it contains the usual prefix for libraries: `lib`. The products this prefix
    references will be installed in the `$(libdir)` directory. (We could have also
    used the `pkglib` prefix to indicate that we wanted our libraries installed into
    `$(libdir)`*/jupiter*.) Here, we’re using the `LTLIBRARIES` primary rather than
    the original `LIBRARIES` primary. The use of `LTLIBRARIES` tells Automake to generate
    rules that use the `libtool` script rather than calling the compiler (and possibly
    the librarian) directly to generate the products.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个文件。➊行是主规格，它包含了库文件的常见前缀：`lib`。这个前缀所引用的产品将被安装到 `$(libdir)` 目录中。（我们也可以使用
    `pkglib` 前缀，表示我们希望将库文件安装到 `$(libdir)`*/jupiter*。）这里，我们使用了 `LTLIBRARIES` 主体，而不是原始的
    `LIBRARIES` 主体。使用 `LTLIBRARIES` 告诉 Automake 生成使用 `libtool` 脚本的规则，而不是直接调用编译器（以及可能的图书馆管理员）来生成产品。
- en: The line at ➋ lists the sources that are to be used for the first (and only)
    product.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ➋行列出了用于第一个（也是唯一）产品的源文件。
- en: The line at ➌ indicates a set of C-preprocessor flags that are to be used on
    the compiler command line for locating the associated shared-library header files.
    These options indicate that the preprocessor should search the top-level *include*
    and *common* directories for header files referenced in the source code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ➌行表示一组 C 预处理器标志，这些标志将在编译器命令行上使用，用于查找相关的共享库头文件。这些选项指示预处理器应在顶层的 *include* 和 *common*
    目录中搜索源代码中引用的头文件。
- en: The last line (at ➍) indicates a set of linker options for this product. In
    this case, we’re specifying that the *libjupcommon.a* static library should be
    linked into (that is, become part of) the *libjupiter.so* shared library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行（在 ➍ 处）表示此产品的链接器选项。在这种情况下，我们指定应该将 *libjupcommon.a* 静态库链接到（即，成为）*libjupiter.so*
    共享库的一部分。
- en: '**NOTE**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The more experienced Autotools library developer will notice a subtle flaw
    in this* Makefile.am *file. Here’s a hint: it’s related to linking Libtool libraries
    against non-Libtool libraries. This concept presents a major stumbling block for
    many newcomers, so I’ve written the initial version of this file to illustrate
    the error. Not to worry, however—we’ll correct the flaw later in this chapter
    as we work through this issue in a logical fashion*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*更有经验的 Autotools 库开发人员会注意到这个* Makefile.am *文件中的一个微妙缺陷。这里有个提示：它与将 Libtool 库链接到非
    Libtool 库有关。这个概念对于许多新人来说是一个主要的绊脚石，所以我在编写这个文件的初始版本时有意展示了这个错误。不过不用担心—我们将在本章稍后通过合乎逻辑的方式解决这个问题时修正这个缺陷。*'
- en: 'There is an important concept regarding the `*_LIBADD` variables that you should
    strive to understand completely: Libraries that are consumed within, and yet built
    as part of, the same project should be referenced internally using relative paths,
    via either parent directory references or the `$(``top_builddir``)` variable,
    within the *build* directory hierarchy. Libraries that are external to a project
    generally don’t need to be referenced explicitly at all, because the project’s
    `configure` script should already have added appropriate `-L` and `-l` options
    for those libraries into the `$(LIBS)` environment variable when it processed
    the code generated by the `AC_CHECK_LIB` or `AC_SEARCH_LIBS` macro.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于 `*_LIBADD` 变量的重要概念，你应该努力完全理解：在同一项目中作为一部分构建并被使用的库，应通过相对路径在 *build* 目录层次结构中内部引用，使用父目录引用或
    `$(``top_builddir``)` 变量。外部项目的库通常不需要显式引用，因为项目的 `configure` 脚本在处理由 `AC_CHECK_LIB`
    或 `AC_SEARCH_LIBS` 宏生成的代码时，应该已经将适当的 `-L` 和 `-l` 选项添加到 `$(LIBS)` 环境变量中。
- en: Next, we’ll hook these new directories into the project’s build system. To do
    so, we need to modify the top-level *Makefile.am* and *configure.ac* files. These
    changes are shown in [Listings 7-2](ch07.xhtml#ch07ex2) and [7-3](ch07.xhtml#ch07ex3),
    respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把这些新目录接入项目的构建系统。为此，我们需要修改顶层的 *Makefile.am* 和 *configure.ac* 文件。这些更改分别显示在[清单
    7-2](ch07.xhtml#ch07ex2)和[7-3](ch07.xhtml#ch07ex3)中。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-2:* Makefile.am: *Adding* include *and* libjup *to the `SUBDIRS`
    variable*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2:* Makefile.am: *将* include *和* libjup *添加到 `SUBDIRS` 变量中*'
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-3:* configure.ac: *Adding the* include *and* libjup *directory makefiles*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3:* configure.ac: *添加* include *和* libjup *目录的 makefile*'
- en: Three unrelated changes were required in *configure.ac*. The first is the addition
    at ➊ of the Libtool setup macros `LT_PREREQ` and `LT_INIT`. The `LT_PREREQ` macro
    works just like Autoconf’s `AC_PREREQ` macro (used a few lines higher). It indicates
    the earliest version of Libtool that can correctly process this project. You should
    choose the lowest reasonable values for the arguments in these macros because
    higher values needlessly restrict you and your co-maintainers to more recent versions
    of the Autotools.^([9](footnote.xhtml#ch07fn9)) The `LT_INIT` macro initializes
    the Libtool system for this project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *configure.ac* 中做了三个不相关的更改。第一个是在 ➊ 位置添加了 Libtool 设置宏 `LT_PREREQ` 和 `LT_INIT`。`LT_PREREQ`
    宏的作用类似于 Autoconf 的 `AC_PREREQ` 宏（用于前几行）。它指示能够正确处理此项目的 Libtool 最早版本。你应选择这些宏参数中的最低合理值，因为较高的值会不必要地限制你和你的共同维护者使用更新版本的
    Autotools。^([9](footnote.xhtml#ch07fn9)) `LT_INIT` 宏用于为该项目初始化 Libtool 系统。
- en: The second change is just as interesting. I removed the `AC_PROG_RANLIB` macro
    invocation after the line at ➋. (And after all we went through to put it there
    in the first place!) Because Libtool is now building all of the project libraries,
    and because it understands all aspects of the library build process, we no longer
    need to instruct Autoconf to make sure `ranlib` is available. In fact, if you
    leave this macro in, you’ll get a warning when you execute `autoreconf -i`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改同样很有趣。我在 ➋ 位置的行之后移除了 `AC_PROG_RANLIB` 宏的调用。（而且这还是我们最初为了将它放进去而做的所有努力！）因为
    Libtool 现在正在构建项目中的所有库，并且它理解库构建过程的各个方面，所以我们不再需要指示 Autoconf 确保 `ranlib` 可用。事实上，如果你保留这个宏，当你执行
    `autoreconf -i` 时会收到一个警告。
- en: The last change is found at ➌ in the argument to `AC_CONFIG_FILES`, where we’ve
    added references to the two new *Makefile.am* files we added to the *include*
    and *libjup* directories.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改出现在 ➌ 位置的 `AC_CONFIG_FILES` 参数中，在那里我们已添加对我们在 *include* 和 *libjup* 目录中添加的两个新
    *Makefile.am* 文件的引用。
- en: '*Customizing Libtool with LT_INIT Options*'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用 LT_INIT 选项定制 Libtool*'
- en: 'You can specify default values for enabling or disabling static and shared
    libraries in the argument list passed into `LT_INIT`. The `LT_INIT` macro accepts
    a single, optional argument: a whitespace-separated list of keywords. The following
    are the most important keywords allowed in this list, along with an explanation
    of their proper use.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在传递给 `LT_INIT` 的参数列表中指定启用或禁用静态库和共享库的默认值。`LT_INIT` 宏接受一个单一的可选参数：一个由空格分隔的关键字列表。以下是此列表中允许的最重要的关键字，并附有它们正确使用的说明。
- en: dlopen
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: dlopen
- en: 'This option enables checking for `dlopen` support. The *GNU Libtool Manual*
    states that this option should be used if the package makes use of the `-dlopen`
    and `-dlpreopen` flags in `libtool`; otherwise `libtool` will assume that the
    system does not support *dl-opening*. There’s only one reason for using the `-dlopen`
    or `-dlpreopen` flag: you intend to dynamically load and import shared-library
    functionality at runtime within your project’s source code. Additionally, these
    two options do very little unless you intend to use the *ltdl* library (rather
    than directly using the *dl* library) to manage your runtime dynamic linking.
    Thus, you should use this option only if you intend to use the *ltdl* library.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项启用对`dlopen`支持的检查。《*GNU Libtool Manual*》指出，如果软件包使用了`libtool`中的`-dlopen`和`-dlpreopen`标志，则应使用此选项；否则，`libtool`将假定系统不支持*dl-opening*。使用`-dlopen`或`-dlpreopen`标志的唯一原因是：你打算在项目的源代码中动态加载和导入共享库的功能。此外，除非你打算使用*ltdl*库（而不是直接使用*dl*库）来管理运行时的动态链接，否则这两个选项几乎没有作用。因此，只有在你打算使用*ltdl*库时，才应使用此选项。
- en: win32-dll
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: win32-dll
- en: Use this option if your library is properly ported to a Windows DLL using `__declspec(dllimport)`
    and `__declspec(dllexport)`. If your library properly uses these keywords to import
    and export symbols for Windows DLLs, and you don’t use this option, then Libtool
    will only build static libraries on Windows. We’ll cover this topic in more detail
    in [Chapter 17](ch17.xhtml).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的库已经正确移植到Windows DLL，使用了`__declspec(dllimport)`和`__declspec(dllexport)`，则使用此选项。如果你的库正确地使用这些关键字来导入和导出Windows
    DLL的符号，而你没有使用此选项，那么Libtool只会在Windows上构建静态库。我们将在[第17章](ch17.xhtml)中更详细地讨论这个主题。
- en: aix-soname=aix|svr4|both
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: aix-soname=aix|svr4|both
- en: Adds the flags `--with-aix-soname` to `configure`’s command line. Prior to version
    2.4.4, Libtool always behaved as if `aix-soname` were set to `aix`. If you build
    shared libraries on AIX often, you’ll understand the meaning of this option. If
    you wish to learn more, read Section 5.4.1 of the *GNU Libtool Manual*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 向`configure`的命令行添加`--with-aix-soname`标志。在版本2.4.4之前，Libtool总是表现得像是将`aix-soname`设置为`aix`。如果你经常在AIX上构建共享库，你会理解这个选项的含义。如果你想了解更多内容，请阅读《*GNU
    Libtool Manual*》的第5.4.1节。
- en: disable-fast-install
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: disable-fast-install
- en: This option changes the default behavior for `LT_INIT` to disable optimization
    for fast installation on systems where it matters. The concept of fast installation
    exists because uninstalled programs and libraries may need to be executed from
    within the build tree (during `make check`, for example). On some systems, installation
    location affects the final linked binary image, so Libtool must either relink
    programs and libraries on these systems when `make install` is executed or else
    relink programs and libraries for `make check`. Libtool chooses to relink for
    `make check` by default, allowing the original binaries to be installed quickly
    without relinking during `make install`. The user can override this default, depending
    on platform support, by specifying `--enable-fast-install` to `configure`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项会改变`LT_INIT`的默认行为，以禁用针对需要时的快速安装优化。快速安装的概念存在是因为未安装的程序和库可能需要在构建树内执行（例如在`make
    check`期间）。在某些系统中，安装位置会影响最终链接的二进制文件，因此当执行`make install`时，Libtool必须重新链接这些系统上的程序和库，或者在`make
    check`时重新链接程序和库。默认情况下，Libtool选择在`make check`时重新链接，允许原始二进制文件快速安装，而无需在`make install`期间重新链接。用户可以根据平台支持通过在`configure`中指定`--enable-fast-install`来覆盖此默认行为。
- en: shared and disable-shared
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: shared 和 disable-shared
- en: These two options change the default behavior for creating shared libraries.
    The effects of the `shared` option are default behavior on all systems where Libtool
    knows how to create shared libraries. The user may override the default shared
    library-generation behavior by specifying either `--disable-shared` or `--enable-shared`
    on the `configure` command line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项会改变创建共享库的默认行为。`shared`选项的效果是在所有Libtool知道如何创建共享库的系统中都是默认行为。用户可以通过在`configure`命令行中指定`--disable-shared`或`--enable-shared`来覆盖默认的共享库生成行为。
- en: static and disable-static
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: static 和 disable-static
- en: These two options change the default behavior for creating static libraries.
    The effects of the `static` option are default behavior on all systems where shared
    libraries have been disabled and on most systems where shared libraries have been
    enabled. If shared libraries are enabled, the user may override this default by
    specifying `--``disable-static` on the `configure` command line. Libtool will
    always generate static libraries on systems without shared libraries. Hence, you
    can’t (effectively) use the `disable-shared` and `disable-static` arguments to
    `LT_INIT` or the `--disable-shared` and `--disable-static` command line options
    for `configure` at the same time. (Note, however, that you may use the `shared`
    and `static` `LT_INIT` options or the `--enable-shared` and `--enable-static`
    command line options together.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项会改变创建静态库的默认行为。`static` 选项的效果是，在禁用共享库的所有系统以及大多数启用了共享库的系统上，都是默认行为。如果启用了共享库，用户可以通过在
    `configure` 命令行中指定 `--disable-static` 来覆盖此默认设置。对于没有共享库的系统，Libtool 会始终生成静态库。因此，你不能同时使用
    `LT_INIT` 的 `disable-shared` 和 `disable-static` 参数，或者 `configure` 的 `--disable-shared`
    和 `--disable-static` 命令行选项。（但是，请注意，你可以同时使用 `shared` 和 `static` 的 `LT_INIT` 选项，或者
    `--enable-shared` 和 `--enable-static` 的命令行选项。）
- en: pic-only and no-pic
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pic-only 和 no-pic
- en: These two options change the default behavior for creating and using PIC object
    code. The user may override the defaults set by these options by specifying `--without-pic`
    or `--with-pic` on the `configure` command line. I’ll discuss the meaning of PIC
    object code in “So What Is PIC, Anyway?” on [page 200](ch07.xhtml#page_200).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项会改变创建和使用 PIC 对象代码的默认行为。用户可以通过在 `configure` 命令行中指定 `--without-pic` 或 `--with-pic`
    来覆盖这些选项设置的默认值。我将在《那么，究竟什么是 PIC？》一节中讨论 PIC 对象代码的含义，参见[第 200 页](ch07.xhtml#page_200)。
- en: Now that we’ve finished setting up the build system for the new library, we
    can move on to discussing the source code. [Listing 7-4](ch07.xhtml#ch07ex4) shows
    the contents of the new *jup_print.c* source file that’s referenced in the second
    line of *libjup/Makefile.am*. [Listing 7-5](ch07.xhtml#ch07ex5) shows the contents
    of the new *include/libjupiter.h* library header file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了新库的构建系统设置，可以开始讨论源代码。[清单 7-4](ch07.xhtml#ch07ex4) 显示了在 *libjup/Makefile.am*
    第二行中引用的新的 *jup_print.c* 源文件的内容。[清单 7-5](ch07.xhtml#ch07ex5) 显示了新的 *include/libjupiter.h*
    库头文件的内容。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-4:* libjup/jup_print.c: *The initial contents of the shared-library
    source file*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4:* libjup/jup_print.c：*共享库源文件的初始内容*'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-5:* include/libjupiter.h: *The initial contents of the shared-library
    public header file*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5:* include/libjupiter.h：*共享库公共头文件的初始内容*'
- en: This leads us to another general software-engineering principle. I’ve heard
    it called by many names, but the one I tend to use the most is the *DRY principle*—the
    acronym stands for *don’t repeat yourself*. C function prototypes are very useful
    because, when used correctly, they enforce the fact that the public’s view of
    a function is identical to the package maintainer’s view. All too often I’ve seen
    source files that don’t include their corresponding header files. It’s easy to
    make a small change in a function or prototype and then not duplicate it in the
    other location—unless you’ve included the public header file within the source
    file. When you do this consistently, the compiler catches any inconsistencies
    for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个软件工程的通用原则。我听到过许多不同的说法，但我通常使用的一个是*DRY 原则*——这个缩写代表*不要重复自己*。C 函数原型非常有用，因为当正确使用时，它们能够确保公众对函数的理解与包维护者的理解一致。我常常看到一些源文件没有包含相应的头文件。很容易在函数或原型中做出小改动，而忘记在另一个位置也进行相同的修改——除非你在源文件中包含了公共头文件。只要你始终这样做，编译器就会帮你捕捉到任何不一致之处。
- en: 'We also need to include the static library header file (*jupcommon.h*) because
    we call its function (*print_routine*) from within the public library function.
    You may have also noticed that I placed *config.h* first, immediately followed
    by the public header file—there’s a good reason for this. I’ve already stated
    in [Chapter 6](ch06.xhtml) that *config.h* should always come first in every source
    file. Normally, I’d say the public header file should come first, but public header
    files should be written so that their functionality is never modified by *config.h*,
    so, technically, it should not matter if the public header file comes before or
    after *config.h*. For example, using a compiler-mode dependent type like `off_t`
    in a public header file will cause the application binary interface (ABI) to change
    not only from one platform to another (not necessarily a bad thing) but also on
    the same platform from one use to another, based on the compilation environment
    set up by consumer code (not a good thing). The fact is, you should write your
    public header files in such a way that it doesn’t really matter whether you include
    them before or after *config.h*; they should be purposely designed so they do
    not depend on anything that *can* be configured by *config.h*. For a more complete
    treatise on this topic, see “Item 1: Keeping Private Details out of Public Interfaces”
    on [page 499](ch18.xhtml#page_499).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包含静态库头文件（*jupcommon.h*），因为我们在公共库函数中调用了它的函数（*print_routine*）。你可能也注意到，我将*config.h*放在最前面，紧接着是公共头文件——这么做是有原因的。我在[第6章](ch06.xhtml)中已经提到过，*config.h*应该始终排在每个源文件的最前面。通常情况下，我会说公共头文件应该排在最前面，但公共头文件应该写成这样，它们的功能不应被*config.h*修改。因此，从技术上讲，公共头文件在*config.h*之前或之后包含并不重要。例如，在公共头文件中使用像`off_t`这样的编译器模式相关类型，会导致应用程序二进制接口（ABI）不仅在不同平台之间发生变化（这不一定是坏事），还会在同一平台上根据消费代码设置的编译环境而发生变化（这就不好了）。事实上，你应该以一种方式编写公共头文件，使得无论是在*config.h*之前还是之后包含它们，都不重要；它们应该被特别设计成不依赖于*config.h*可以配置的任何内容。关于这一主题的更详细讨论，请参见[第18章，第1项：将私有细节从公共接口中剔除](ch18.xhtml#page_499)。
- en: By placing the public header file first in the source file (after *config.h*),
    we ensure that the use of this header file doesn’t depend on definitions in any
    internal header files in the project. For instance, let’s say the public header
    file has a hidden dependency on some construct (such as a type definition, structure,
    or preprocessor definition) defined in an internal header like *jupcommon.h*.
    If we include the public header file after *jupcommon.h*, the dependency would
    be hidden when the compiler begins to process the public header file, because
    the required construct is already available in the *translation unit* (the source
    file combined with all of the included header files).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将公共头文件放在源文件的最前面（在*config.h*之后），我们可以确保该公共头文件的使用不依赖于项目中任何内部头文件中的定义。例如，假设公共头文件隐含依赖于某些在内部头文件（如*jupcommon.h*）中定义的构造（如类型定义、结构体或预处理器定义）。如果我们在包含*jupcommon.h*之后再包含公共头文件，那么当编译器开始处理公共头文件时，这个依赖就会被隐藏，因为所需的构造已经在*翻译单元*（源文件与所有已包含的头文件组合）中可用。
- en: I’d like to make one final point about the contents of [Listing 7-5](ch07.xhtml#ch07ex5).
    The preprocessor conditional construct is commonly called an *include guard*.
    It is a mechanism for preventing your header files from inadvertently being included
    multiple times within the same translation unit. I use include guards routinely
    in all my header files, and it’s good practice to do so. A good optimizing compiler
    (`gcc`, for instance—specifically, its preprocessor) will recognize include guards
    in header files and skip the file entirely on subsequent inclusions within the
    same translation unit.^([10](footnote.xhtml#ch07fn10))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我想最后再谈谈[清单7-5](ch07.xhtml#ch07ex5)中的内容。预处理器条件构造通常被称为*包含保护*。它是一种机制，用于防止你的头文件在同一个翻译单元中被意外地多次包含。我在所有的头文件中都常规使用包含保护，养成这样的习惯是很好的做法。一个优秀的优化编译器（例如`gcc`，特别是它的预处理器）会识别头文件中的包含保护，并在后续的包含中完全跳过该文件，在同一个翻译单元中避免重复包含。[10](footnote.xhtml#ch07fn10)
- en: Since a public header file will be consumed by foreign source code, it’s even
    more critical that you use include guards religiously in these header files. While
    you can control your own code base, you have no say over the code that one of
    your library consumers writes. What I’m advocating here is that you assume you’re
    the best programmer you know, and everyone else is a little below your skill level.
    You can do this nicely by not mentioning it to anyone, but you should *act* like
    it’s a fact when you write your public header files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于公共头文件将被外部源代码使用，因此在这些头文件中严格使用包含保护是至关重要的。虽然你可以控制自己的代码库，但你无法控制你的库消费者编写的代码。我在这里提倡的是，你应该假设自己是最好的程序员，其他人稍微低于你的技术水平。你可以通过不向任何人提及这一点来巧妙地做到这一点，但在编写公共头文件时，你应该*表现得*像这是一条事实。
- en: Next, we’ll modify the Jupiter application’s `main` function so that it calls
    into the shared library instead of the common static library. These changes are
    shown in [Listing 7-6](ch07.xhtml#ch07ex6).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 Jupiter 应用程序的 `main` 函数，使其调用共享库中的函数，而不是调用常见的静态库。这些更改显示在[列表 7-6](ch07.xhtml#ch07ex6)中。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-6:* src/main.c: *Changing `main` to call the shared-library function*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6:* src/main.c: *将 `main` 改为调用共享库函数*'
- en: Here, we’ve changed the print function from `print_routine`, found in the static
    library, to `jupiter_print`, as provided by the new shared library. We’ve also
    changed the header file included at the top from *libjupcommon.h* to *libjupiter.h*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将打印函数从静态库中的 `print_routine` 改为新共享库提供的 `jupiter_print`。我们还将顶部包含的头文件从 *libjupcommon.h*
    改为 *libjupiter.h*。
- en: My choices of names for the public function and header file were arbitrary but
    based on a desire to provide a clean, rational, and informational public interface.
    The name *libjupiter.h* very clearly indicates that this header file specifies
    the public interface for *libjupiter.so*. I try to name library interface functions
    to make it clear that they are part of an interface. How you choose to name your
    public interface members—files, functions, structures, type definitions, preprocessor
    definitions, global data, and so on—is up to you, but you should consider using
    a similar philosophy. Remember, the goal is to provide a great end-user experience.
    Intuitive naming should be a significant part of your strategy. For example, it
    is a good general practice to choose a common prefix for your program and library
    symbols.^([11](footnote.xhtml#ch07fn11))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我对公共函数和头文件的命名选择是随意的，但基于提供一个干净、合理和信息丰富的公共接口的考虑。名称 *libjupiter.h* 很清楚地表明该头文件指定了
    *libjupiter.so* 的公共接口。我尽量将库接口函数命名为清晰地表明它们是接口的一部分。如何选择公共接口成员的名称——文件、函数、结构、类型定义、预处理器定义、全局数据等等——取决于你，但你应该考虑使用类似的理念。记住，目标是提供一个良好的终端用户体验。直观的命名应该是你策略的一个重要部分。例如，选择一个通用的前缀来命名程序和库符号是一种良好的通用实践。^([11](footnote.xhtml#ch07fn11))
- en: Finally, we must also modify the *src/Makefile.am* file to use our new shared
    library rather than the *libjupcommon.a* static library. These changes are shown
    in [Listing 7-7](ch07.xhtml#ch07ex7).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还必须修改 *src/Makefile.am* 文件，以便使用新的共享库，而不是 *libjupcommon.a* 静态库。这些更改显示在[列表
    7-7](ch07.xhtml#ch07ex7)中。
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-7:* src/Makefile.am: *Adding shared-library references to the src
    directory makefile*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7:* src/Makefile.am: *向 src 目录的 Makefile 添加共享库引用*'
- en: Here, we’ve changed the `jupiter_CPPFLAGS` statement at ➊ so that it refers
    to the new top-level *include* directory rather than the *common* directory. We’ve
    also changed the `jupiter_LDADD` statement at ➋ so that it refers to the new Libtool
    shared-library object rather than the *libjupcommon.a* static library. All else
    remains the same. The syntax for referring to a Libtool library is identical to
    that for referring to an older, static library—only the library extension is different.
    The Libtool library extension *.la* stands for *libtool archive*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经在 ➊ 修改了 `jupiter_CPPFLAGS` 语句，使其引用新的顶级*include*目录，而不是*common*目录。我们还在
    ➋ 修改了 `jupiter_LDADD` 语句，使其引用新的 Libtool 共享库对象，而不是*libjupcommon.a*静态库。其余部分保持不变。引用
    Libtool 库的语法与引用较旧的静态库的语法相同——只是库扩展名不同。Libtool 库扩展名 *.la* 代表 *libtool 存档*。
- en: Let’s take a step back for a moment. Do we actually need to make this change?
    No, of course not. The `jupiter` application will continue to work just fine the
    way we originally wrote it. Linking the code for the static library’s `print_routine`
    directly into the application works just as well as calling the new shared-library
    routine (which ultimately contains the same code, anyway). In fact, there is slightly
    more overhead in calling a shared-library routine because of the extra level of
    indirection when calling through a shared-library jump table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，想一想。我们真的需要做这个改动吗？不，当然不需要。`jupiter`应用程序将继续像最初编写时一样正常工作。直接将静态库中的`print_routine`代码链接到应用程序中，与调用新的共享库例程（最终包含相同的代码）一样有效。事实上，调用共享库例程的开销稍微大一些，因为调用共享库跳转表时会增加一个额外的间接层。
- en: In a real project, you might actually leave it the way it was. Because both
    public entry points, `main` and `jupiter_print`, call exactly the same function
    (`print_routine`) in *libjupcommon.a*, their functionality is identical. Why add
    even the slight overhead of a call through the public interface? Well, one reason
    is that you can take advantage of shared code. By using the shared-library function,
    you’re not duplicating code—either on disk or in memory. This is the DRY principle
    at work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的项目中，你可能会选择保持原样。因为两个公共入口点，`main`和`jupiter_print`，调用的是完全相同的函数（`print_routine`），该函数位于*libjupcommon.a*中，它们的功能是相同的。为什么还要通过公共接口调用，即使有一点点额外的开销呢？其中一个原因是你可以利用共享代码。通过使用共享库函数，你不会重复代码——无论是在磁盘上还是在内存中。这正是DRY原则的体现。
- en: Another reason is to exercise the interface you’re providing for users of your
    shared library. You’ll catch bugs in your public interfaces more quickly if your
    project code uses your shared libraries exactly the way you expect other programs
    to use them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是锻炼你为共享库用户提供的接口。如果你的项目代码以你期望的方式使用共享库，你会更快地发现公共接口中的错误。
- en: In this situation, you might now consider simply moving the code from the static
    library into the shared library, thereby removing the need for the static library
    entirely. However, I’m going to beg your indulgence with my contrived example.
    In a more complex project, I might very well have a need for this sort of configuration.
    Common code is often gathered together into static convenience libraries, and
    more often than not, only a portion of this common code is reused in shared libraries.
    I’m going to leave it the way it is here for the sake of its educational value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能现在会考虑直接将静态库中的代码移动到共享库中，从而完全去除静态库的需求。然而，我请求你宽容地看待我的这一人为示例。在一个更复杂的项目中，我很可能需要这种配置。常见代码通常会被集中到静态便利库中，而且更多时候，这些公共代码只有一部分会在共享库中重复使用。为了教学目的，我将保持原样。
- en: '*Reconfigure and Build*'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*重新配置并构建*'
- en: 'Since we’ve added Libtool—a major new component—to our project build system,
    we’ll add the `-i` option to the `autoreconf` command line to ensure that all
    of the proper auxiliary files are installed into the project root directory:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们向项目构建系统中添加了Libtool这一重要新组件，我们将向`autoreconf`命令行添加`-i`选项，以确保所有必要的辅助文件都安装到项目根目录中：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we completely removed all generated and copied files from our project
    directory, most of these notifications have to do with replacing files we’ve already
    discussed. However, there are a few noteworthy exceptions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已完全移除了项目目录中的所有生成和复制的文件，所以这些通知大多数与替换我们之前讨论过的文件有关。然而，也有一些值得注意的例外。
- en: First, notice the comments from `libtoolize` at ➊. Most of them are simply suggesting
    that we move to the new Autotools convention of adding M4 macro files to a directory
    called *m4* in the project root directory. We’re going to ignore these comments
    for now, but in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml), we’ll actually
    do this for a real project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到来自`libtoolize`的评论，见➊。它们大多数只是建议我们转向新的Autotools约定，将M4宏文件添加到项目根目录中的*m4*目录中。我们暂时忽略这些评论，但在[第14章](ch14.xhtml)和[第15章](ch15.xhtml)中，我们将实际为一个真实项目做这件事。
- en: As you can see at ➋, it appears that the addition of Libtool has caused a few
    new files to be added to our project—namely, the *config.guess* and *config.sub*
    files. Another new file was added in the section at ➊ called *ltmain.sh*. The
    `configure` script uses *ltmain.sh* to build a project-specific version of `libtool`
    for the Jupiter project. I’ll describe the `config.guess` and `config.sub` scripts
    later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 ➋ 处所见，Libtool 的添加似乎导致了几个新文件被添加到我们的项目中——即*config.guess* 和 *config.sub* 文件。在
    ➊ 处的部分又添加了一个新文件，名为*ltmain.sh*。`configure`脚本使用*ltmain.sh*为 Jupiter 项目构建一个项目特定的`libtool`版本。稍后我会介绍`config.guess`和`config.sub`脚本。
- en: 'Let’s go ahead and execute `configure` and see what happens:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续执行`configure`，看看会发生什么：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to note is that Libtool adds *significant* overhead to the configuration
    process. I’ve only shown a few of the output lines here that are new since we
    added Libtool. All we’ve added to the *configure.ac* file is the reference to
    the `LT_INIT` macro, but we’ve nearly doubled our `configure` output. This should
    give you some idea of the number of system characteristics that must be examined
    to create portable shared libraries. Fortunately, Libtool does a lot of the work
    for you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，Libtool 为配置过程添加了*显著的*开销。我这里只展示了自从添加了 Libtool 之后新增的几行输出。我们在*configure.ac*文件中所做的唯一修改是添加了对`LT_INIT`宏的引用，但我们几乎将`configure`的输出量翻了一倍。这应该能让你对创建可移植共享库所需检查的系统特性数量有一些了解。幸运的是，Libtool
    为你做了大量工作。
- en: 'Now, let’s run the `make` command and see what sort of output we get:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`make`命令，看看我们会得到什么样的输出：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We seem to have some errors to fix. The first point of interest is that `libtool`
    is being executed at ➊ with a `--mode=compile` option, which causes `libtool`
    to act as a wrapper script around a somewhat modified version of a standard `gcc`
    command line. You can see the effects of this statement in the next two compiler
    command lines at ➋ and ➌. *Two compiler commands?* That’s right. It appears that
    `libtool` is running the compiler twice against our source file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎有一些错误需要修复。第一个值得注意的问题是，在 ➊ 处执行了`libtool`，并使用了`--mode=compile`选项，这使得`libtool`充当了一个包装脚本，围绕标准`gcc`命令行的某个修改版进行操作。你可以在接下来的两行编译命令中看到这一点，分别在
    ➋ 和 ➌ 处。*两个编译命令？* 没错。看起来 Libtool 正在针对我们的源文件执行两次编译。
- en: A careful comparison of these two command lines shows that the first command
    is using two additional flags, `-fPIC` and `-DPIC`. The first line also appears
    to be directing the output file to a *.libs* subdirectory, whereas the second
    line is saving it in the current directory. Finally, both the `stdout` and `stderr`
    output streams are redirected to */dev/null* in the second line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行命令的仔细对比表明，第一条命令使用了两个额外的标志，`-fPIC` 和 `-DPIC`。第一行似乎还将输出文件定向到一个*.libs*子目录，而第二行则将其保存在当前目录中。最后，第二行将`stdout`和`stderr`输出流重定向到*/dev/null*。
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Occasionally, you may run into a situation where a source file compiles fine
    in the first compilation but fails in the second due to a PIC-related source code
    error. These sorts of problems are rare, but they can be a real pain when they
    occur because *`make`* halts the build with an error but doesn’t give you any
    error messages to explain the problem! When you see this situation, simply pass
    the *`-no-suppress`* flag in the *`CFLAGS`* variable on the *`make`* command line
    in order to tell Libtool not to redirect output from the second compilation to*
    /dev/null.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时，你可能会遇到一种情况，某个源文件在第一次编译时能够正常编译，但由于与 PIC 相关的源代码错误，在第二次编译时失败。这类问题虽然很少见，但一旦发生会让人头疼，因为*`make`*
    会因错误而停止构建，却没有给出任何错误信息来解释问题！遇到这种情况时，只需在*`make`*命令行的*`CFLAGS`*变量中传递*`-no-suppress`*标志，告诉
    Libtool 不要将第二次编译的输出重定向到*/dev/null*。'
- en: This double-compile feature has caused a fair amount of anxiety on the Libtool
    mailing list over the years. Mostly, this is due to a lack of understanding of
    what Libtool is trying to do and why it’s necessary. Using Libtool’s various `configure`
    script command line options, you can force a single compilation, but doing so
    brings a certain loss of functionality, which I’ll explain here shortly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个双重编译特性多年来在 Libtool 邮件列表上引起了不少焦虑。大多数原因是人们对 Libtool 尝试做的事情以及为什么它是必要的缺乏理解。通过使用
    Libtool 的各种`configure`脚本命令行选项，你可以强制执行单次编译，但这样做会带来一定的功能丧失，我将在稍后解释这一点。
- en: The line at ➍ renames the dependency file from **.Tpo* to **.Plo*. You might
    recall from [Chapters 3](ch03.xhtml) and [6](ch06.xhtml) that dependency files
    contain `make` rules that declare dependencies between source files and referenced
    header files. The C preprocessor generates these rules when you use the `-MT`
    compiler option. However, the overarching concept to understand here is that one
    Libtool command may (and often does) execute a group of shell commands.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 行将依赖文件从**.Tpo*重命名为**.Plo*。你可能还记得[第 3 章](ch03.xhtml)和[第 6 章](ch06.xhtml)，依赖文件包含`make`规则，这些规则声明了源文件和引用的头文件之间的依赖关系。当你使用`-MT`编译器选项时，C
    预处理器会生成这些规则。但是，这里要理解的首要概念是，一个 Libtool 命令可能（并且经常）执行一组 shell 命令。
- en: The line at ➎ is another call to the `libtool` script, this time using the `--mode=link`
    option. This option generates a call to execute the compiler in *link mode*, passing
    all of the libraries and linker options specified in the *Makefile.am* file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 行是另一个对`libtool`脚本的调用，这次使用`--mode=link`选项。此选项生成一个调用，以在*链接模式*下执行编译器，并传递在*Makefile.am*文件中指定的所有库和链接器选项。
- en: At ➏, we come to the first problem—a portability warning about linking a shared
    library against a static library. Specifically, this warning is about linking
    a Libtool shared library against a non-Libtool static library. Notice that this
    is not an error. Were it not for additional errors we’ll encounter later, the
    library would be built in spite of this warning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏，我们遇到了第一个问题——关于将共享库与静态库链接的可移植性警告。具体来说，此警告是关于将 Libtool 共享库与非 Libtool 静态库链接。请注意，这不是错误。如果不是因为我们稍后会遇到的其他错误，那么尽管有此警告，仍会构建该库。
- en: 'After the portability warning, `libtool` attempts to link the requested objects
    together into a shared library named *libjupiter.so.0.0.0* . But here the script
    runs into the real problem: at ➐, a linker error indicates that somewhere from
    within *libjupcommon.a*—and more specifically, within *print.o*—an `x86_64` object
    relocation cannot be performed because the original source file (*print.c*) was
    apparently not compiled correctly. The linker is kind enough to tell us exactly
    what we need to do to fix the problem (highlighted in the example): we need to
    compile the source code using a `-fPIC` compiler option.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在可移植性警告之后，`libtool`尝试将请求的对象链接到名为*libjupiter.so.0.0.0*的共享库中。但是在这里，脚本遇到了真正的问题：在
    ➐，链接器错误表明从*libjupcommon.a*内部的某个地方——更具体地说，在*print.o*内部——无法执行`x86_64`对象重定位，因为原始源文件
    (*print.c*) 显然没有正确编译。链接器非常友好地告诉我们解决问题需要做什么（在示例中突出显示）：我们需要使用`-fPIC`编译器选项编译源代码。
- en: Now, if you were to encounter this error and didn’t know anything about the
    `-fPIC` option, you’d be wise to open the man page for `gcc` and study it before
    inserting compiler and linker options willy-nilly until the warning or error disappears
    (unfortunately, a common practice of inexperienced programmers). Software engineers
    should understand the meaning and nuances of every command line option used by
    the tools in their build systems. Otherwise, they don’t really know what they
    have when their build completes. It may work the way it should, but if it does,
    it’s by luck rather than by design. Good engineers know their tools, and the best
    way to learn is to study error messages and their fixes until the problem is well
    understood, before moving on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在遇到了这个错误，并且对`-fPIC`选项一无所知，明智的做法是打开`gcc`的手册页，并在随意插入编译器和链接器选项直到警告或错误消失之前仔细研究它（不幸的是，这是缺乏经验的程序员的常见做法）。软件工程师应该理解他们的构建系统中使用的工具的每个命令行选项的含义和细微差别。否则，他们并不真正知道他们的构建完成时得到了什么。它可能会按预期工作，但如果是这样，那也是靠运气而不是靠设计。优秀的工程师了解他们的工具，最好的学习方法是在继续前进之前，研究错误消息及其修复方法，直到完全理解问题为止。
- en: '*So What Is PIC, Anyway?*'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*那么，PIC 到底是什么？*'
- en: When operating systems create new process address spaces, they typically load
    program-executable images at the same memory address. This magic address is system
    specific. Compilers and linkers understand this, and they know what the magic
    address is on any given system. Therefore, when they generate internal references
    to function calls or global data, they can generate those references as *absolute*
    addresses. If you were somehow able to load the executable at a different location
    in the process virtual address space, it would simply not work properly because
    the absolute addresses within the code would not be correct. At the very least,
    the program would crash when the processor jumped to the wrong location during
    a function call.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统创建新的进程地址空间时，它们通常会将程序的可执行镜像加载到相同的内存地址。这个神奇的地址是系统特定的。编译器和链接器理解这一点，并且知道在任何给定的系统中，神奇的地址是什么。因此，当它们生成对函数调用或全局数据的内部引用时，它们可以将这些引用生成*绝对*地址。如果你以某种方式将可执行文件加载到进程虚拟地址空间的不同位置，它将无法正常工作，因为代码中的绝对地址将不正确。至少，当处理器在函数调用时跳转到错误的位置时，程序将崩溃。
- en: Consider [Figure 7-1](ch07.xhtml#ch07fig1) for a moment. Assume we have a system
    whose magic executable load address is `0x10000000`; this diagram depicts two
    process address spaces within that system. In the process on the left, an executable
    image is loaded correctly at address `0x10000000`. At some point in the code,
    a `jmp` instruction tells the processor to transfer control to the absolute address
    `0x10001000`, where it continues executing instructions in another area of the
    program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑一下[图 7-1](ch07.xhtml#ch07fig1)。假设我们有一个系统，其神奇的可执行加载地址是`0x10000000`；该图描绘了系统中的两个进程地址空间。在左边的进程中，可执行镜像正确加载到地址`0x10000000`。在代码的某个点，`jmp`指令告诉处理器将控制转移到绝对地址`0x10001000`，并在程序的另一区域继续执行指令。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Absolute addressing in executable images*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：可执行镜像中的绝对寻址*'
- en: In the process on the right, the program is loaded incorrectly at address `0x20000000`.
    When that same branch instruction is encountered, the processor jumps to address
    `0x10001000` because that address is hardcoded into the program image. This, of
    course, fails—often spectacularly by crashing, but sometimes with more subtle
    and dastardly ramifications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在右边的进程中，程序被错误地加载到地址`0x20000000`。当遇到相同的分支指令时，处理器会跳转到地址`0x10001000`，因为该地址是硬编码在程序镜像中的。当然，这会失败——通常是通过崩溃的方式，或者有时会带来更微妙且狡猾的后果。
- en: That’s how things work for program images. However, when a *shared library*
    is built for certain types of hardware (AMD64 included), neither the compiler
    nor the linker knows beforehand where the library will be loaded. This is because
    many libraries may be loaded into a process and the order in which they are loaded
    depends on how the *executable* is built, not the library. Furthermore, who’s
    to say which library owns location A and which one owns location B? The fact is,
    a library may be loaded *anywhere* into the process address space where there
    is space for it at the time it’s loaded. Only the operating system loader knows
    where it will finally reside—and even then, it only knows just before the library
    is actually loaded.^([12](footnote.xhtml#ch07fn12))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序镜像的工作方式。然而，当为某些类型的硬件（包括AMD64）构建*共享库*时，编译器和链接器都无法事先知道库将被加载到哪里。这是因为许多库可能会被加载到一个进程中，而它们的加载顺序取决于*可执行文件*的构建方式，而不是库本身。此外，谁能说清楚哪个库拥有位置A，哪个库拥有位置B呢？事实上，库可能会被加载到进程地址空间中的*任何地方*，只要在它被加载时有足够的空间。只有操作系统加载器知道它最终会驻留在哪里——即使如此，它也只会在库被实际加载之前才知道这个位置。^([12](footnote.xhtml#ch07fn12))
- en: As a result, shared libraries can only be built from a special class of object
    files called PIC objects. *PIC* is an acronym that stands for *position-independent
    code*, and it implies that references within the object code are not absolute
    but *relative*. When you use the `-fPIC` option on the compiler command line,
    the compiler will use somewhat less efficient relative addressing in branching
    instructions. Such position-independent code may be loaded anywhere.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，共享库只能由一种特殊类型的目标文件——称为PIC对象——构建。*PIC*是*位置无关代码*（position-independent code）的缩写，这意味着对象代码中的引用不是绝对的，而是*相对的*。当你在编译器命令行中使用`-fPIC`选项时，编译器会在分支指令中使用效率较低的相对寻址。这种位置无关的代码可以加载到任何地方。
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) depicts the concept of relative addressing
    as used when generating PIC objects. With relative addressing, addresses work
    correctly regardless of where the image is loaded because they’re always encoded
    relative to the current instruction pointer. In [Figure 7-2](ch07.xhtml#ch07fig2),
    the diagrams indicate a shared library loaded at the same addresses as those in
    [Figure 7-1](ch07.xhtml#ch07fig1) (that is, `0x10000000` and `0x20000000`). In
    both cases, the dollar sign used in the `jmp` instruction represents the current
    instruction pointer (`IP`), so `$ + 0xC74` tells the processor that it should
    jump to the instruction starting `0xC74` bytes ahead of the current position of
    the instruction pointer.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig2) 展示了生成 PIC 对象时使用的相对寻址概念。使用相对寻址时，地址无论图像加载到哪里都能正确工作，因为它们始终是相对于当前指令指针进行编码的。在
    [图 7-2](ch07.xhtml#ch07fig2) 中，图示表示共享库与 [图 7-1](ch07.xhtml#ch07fig1) 中的地址相同加载（即，`0x10000000`
    和 `0x20000000`）。在这两种情况下，`jmp` 指令中使用的美元符号代表当前的指令指针（`IP`），因此 `$ + 0xC74` 告诉处理器，它应该跳转到当前指令指针位置前进
    `0xC74` 字节处的指令。'
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig02.jpg)'
- en: '*Figure 7-2: Relative addressing in shared-library images*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：共享库图像中的相对寻址*'
- en: There are various nuances to generating and using position-independent code,
    and you should become familiar with all of them before using them so you can choose
    the option that is most appropriate for your situation. For example, the GNU C
    compiler also supports a `-fpic` option (lowercase), which uses a slightly quicker
    but more limited mechanism to generate relocatable object code.^([13](footnote.xhtml#ch07fn13))
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 生成和使用位置无关代码有各种细节，你应该在使用之前熟悉它们，以便能够选择最适合你情况的选项。例如，GNU C 编译器也支持 `-fpic` 选项（小写），它使用稍微更快但功能更有限的机制生成可重定位目标代码。^([13](footnote.xhtml#ch07fn13))
- en: '*Fixing the Jupiter PIC Problem*'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*修复 Jupiter PIC 问题*'
- en: From what we now understand, one way to fix our linker error is to add the `-fPIC`
    option to the compiler command line for the source files that comprise the *libjupcommon.a*
    static library. [Listing 7-8](ch07.xhtml#ch07ex8) illustrates the changes required
    to the *common/Makefile.am* file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们现在的理解，修复链接器错误的一种方法是将 `-fPIC` 选项添加到编译器命令行中，针对构成 *libjupcommon.a* 静态库的源文件。[清单
    7-8](ch07.xhtml#ch07ex8) 展示了对 *common/Makefile.am* 文件所需的更改。
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-8:* common/Makefile.am: *Changes required for generation of PIC
    objects in a static library*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：* common/Makefile.am：*生成静态库中 PIC 对象所需的更改*'
- en: 'And now let’s retry the build:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新尝试构建：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a shared library built properly with position-independent code,
    as per system requirements. However, we still have that strange warning at ➊ about
    the portability of linking a Libtool library against a static library. The problem
    here is not in *what* we’re doing but rather *how* we’re doing it. You see, the
    concept of PIC does not apply to all hardware architectures. Some CPUs don’t support
    any form of absolute addressing in their instruction sets. As a result, native
    compilers for these platforms don’t support a `-fPIC` option—it has no meaning
    for them. Unknown options may be silently ignored, but in most cases, compilers
    stop on unknown options with an error message.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经根据系统要求，成功构建了一个正确的共享库，并且它包含了位置无关代码。然而，我们仍然在 ➊ 处看到那个关于将 Libtool 库与静态库链接的移植性问题的奇怪警告。这里的问题不在于我们做了什么，而是我们是如何做的。你看，PIC
    的概念并不适用于所有硬件架构。一些 CPU 的指令集不支持任何形式的绝对寻址。因此，这些平台的本地编译器不支持 `-fPIC` 选项——对它们来说没有意义。未知选项可能会被悄悄忽略，但在大多数情况下，编译器会因为未知选项而停止，并给出错误信息。
- en: If we tried, for example, to compile this code on an IBM RS/6000 system using
    the native IBM compiler, it would hiccup when it came to the `-fPIC` option on
    the linker command line. This is because it doesn’t make sense to support such
    an option on a system where all code is generated as position-independent code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在 IBM RS/6000 系统上使用原生 IBM 编译器编译这段代码，遇到链接器命令行中的 `-fPIC` 选项时，它会出现问题。因为在一个所有代码都是生成位置无关代码的系统上，支持这种选项是没有意义的。
- en: One way we could get around this problem would be to make the `-fPIC` option
    conditional in *Makefile.am*, based on the target system and the tools we’re using.
    But that’s exactly the sort of problem that Libtool was designed to address! We’d
    have to account for all the different Libtool target system types and tool sets
    in order to handle the entire set of conditions that Libtool already handles.
    Additionally, some systems and compilers may require different command line options
    to accomplish the same goal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使 `-fPIC` 选项在 *Makefile.am* 中根据目标系统和所使用的工具而变化来解决这个问题。但这正是 Libtool 设计的目的！我们需要考虑所有不同的
    Libtool 目标系统类型和工具集，以便处理 Libtool 已经处理的所有条件。此外，一些系统和编译器可能需要不同的命令行选项来实现相同的目标。
- en: The way around this portability problem, then, is to let Libtool generate the
    static library, as well. Libtool makes a distinction between static libraries
    that are installed as part of a developer package and static libraries that are
    only used internally within a project. It calls such internal static libraries
    *convenience* libraries, and whether or not a convenience library is generated
    depends on the prefix used with the `LTLIBRARIES` primary. If the `noinst` prefix
    is used, then Libtool assumes we want a convenience library, because there’s no
    point in generating a shared library that will never be installed. Thus, convenience
    libraries are always generated as non-installed static archives, which have no
    value unless they’re linked to other code within the project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个可移植性问题，方法是让 Libtool 也生成静态库。Libtool 区分了作为开发者包一部分安装的静态库和仅在项目内部使用的静态库。它将这些内部静态库称为*便利*库，是否生成便利库取决于与
    `LTLIBRARIES` 主命令一起使用的前缀。如果使用了 `noinst` 前缀，Libtool 会认为我们想要一个便利库，因为生成一个永远不会安装的共享库是没有意义的。因此，便利库总是作为未安装的静态归档生成，除非它们被链接到项目中的其他代码，否则没有任何价值。
- en: The reason for distinguishing between convenience libraries and other forms
    of static libraries is that convenience libraries are always built, whereas installed
    static libraries are only built if the `--enable-static` option is specified on
    the `configure` command line—or, conversely, if the `--disable-static` option
    is *not* specified and the default library type has been set to `static`. The
    conversion from an older static library to a newer Libtool convenience library
    is simple enough—all we have to do is add `LT` to the primary name and remove
    the `-fPIC` option and the `CFLAGS` variable (since there were no other options
    being used in that variable). Note also that I’ve changed the library extension
    from *.a* to *.la*. Don’t forget to change the prefix on the `SOURCES` variable
    to reflect the new name of the library—*libjupcommon.la*. These changes are highlighted
    in [Listings 7-9](ch07.xhtml#ch07ex9) and [7-10](ch07.xhtml#ch07ex10).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 区分便利库和其他形式的静态库的原因是，便利库总是构建的，而安装的静态库仅在 `configure` 命令行中指定了 `--enable-static`
    选项时才会构建——或者反过来，如果没有指定 `--disable-static` 选项，并且默认库类型已经设置为 `static`。从旧的静态库转换到新的
    Libtool 便利库非常简单——我们只需要在主命名中添加 `LT`，然后删除 `-fPIC` 选项和 `CFLAGS` 变量（因为在该变量中没有使用其他选项）。还要注意，我已将库扩展名从
    *.a* 更改为 *.la*。别忘了将 `SOURCES` 变量中的前缀更改为反映新库名——*libjupcommon.la*。这些更改在 [示例 7-9](ch07.xhtml#ch07ex9)
    和 [7-10](ch07.xhtml#ch07ex10) 中突出显示。
- en: Git tag 7.1
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 7.1
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-9:* common/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-9:* common/Makefile.am: *从静态库更改为 Libtool 静态库*'
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-10:* libjup/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-10:* libjup/Makefile.am: *从静态库更改为 Libtool 静态库*'
- en: 'Now when we try to build, here’s what we get:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试构建时，得到的是：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see at ➋ that the common library is now built as a static convenience
    library because the `ar` utility builds *libjupcommon.a*. Libtool also seems to
    be building files with new and different extensions—a closer look will reveal
    extensions such as *.la* and *.lo* (check the line at ➊). If you examine these
    files, you’ll find that they’re actually descriptive text files containing object
    and library metadata. [Listing 7-11](ch07.xhtml#ch07ex11) shows the partial contents
    of *common/libjupcommon.la*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在➋处看到，公共库现在作为静态便利库构建，因为`ar`工具构建了*libjupcommon.a*。Libtool似乎也在构建具有新扩展名的文件——更仔细观察会发现扩展名如*.la*和*.lo*（查看➊处的行）。如果你检查这些文件，你会发现它们实际上是包含对象和库元数据的描述性文本文件。[列表
    7-11](ch07.xhtml#ch07ex11)展示了*common/libjupcommon.la*的部分内容。
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-11:* common/libjupcommon.la: *Textual metadata found in a library
    archive* (.la ) *file*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-11:* common/libjupcommon.la: *库归档文件中的文本元数据*（.la）*文件*'
- en: The various fields in these files help the linker—or rather the `libtool` wrapper
    script—to determine certain options that the maintainer would otherwise have to
    remember and manually pass to the linker on the command line. For instance, the
    library’s shared and static names are documented at ➊ and ➋ here, as well as any
    library dependencies required by these libraries (at ➌).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的各个字段帮助链接器——或者更准确地说，`libtool`包装脚本——确定一些选项，否则维护者必须记住并手动传递给链接器。例如，库的共享和静态名称在这里的➊和➋处进行了记录，还有这些库所需的任何库依赖项（在➌处）。
- en: '**NOTE**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a convenience library, so the shared library name is empty*.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个便利库，所以共享库名称为空*。'
- en: In this library, we can see that *libjupcommon.a* depends on the *pthreads*
    library. But, by using Libtool, we don’t have to pass a `-lpthread` option on
    the `libtool` command line because `libtool` can detect from the contents of this
    metadata file (specifically, the line at ➌) that the linker will need this option,
    and it passes the option for us.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个库中，我们可以看到*libjupcommon.a*依赖于*pthreads*库。但是，通过使用Libtool，我们不需要在`libtool`命令行上传递`-lpthread`选项，因为`libtool`可以从这个元数据文件的内容中（特别是➌处的行）检测到链接器需要这个选项，并且会为我们传递这个选项。
- en: Making these files human readable was a minor stroke of genius, as they can
    tell us a lot about Libtool libraries at a glance. These files are designed to
    be installed on an end user’s machine with their associated binaries, and, in
    fact, the `make install` rules that Automake generates for Libtool libraries do
    just this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使这些文件对人类可读是一项小小的天才之举，因为它们可以让我们一眼看出有关Libtool库的很多信息。这些文件被设计为与相关的二进制文件一起安装到最终用户的机器上，事实上，Automake为Libtool库生成的`make
    install`规则正是这样做的。
- en: Most Linux distros today are leaning toward filtering out *.la* files from official
    builds of library projects—that is, they don’t install them into the */usr* directory
    structure because *.la* files are only useful during builds where packages are
    referencing Libtool libraries within a project directory structure. Since the
    distro provider has already pre-built everything for you and you won’t be building
    those packages yourself, they just take up space (albeit, not very much). When
    you link against a library (Libtool or otherwise) that’s installed on your system
    in the */usr* directory structure, you’re using one of the `AC_CHECK`/`SEARCH`
    macros to find the library and link against the *.a* or *.so* file directly, so
    the *.la* file isn’t used in that case either.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数Linux发行版倾向于从库项目的官方构建中筛选出*.la*文件——也就是说，它们不会将其安装到*/usr*目录结构中，因为*.la*文件仅在包引用Libtool库并且位于项目目录结构中的构建过程中有用。由于发行版提供者已经为你预先构建好了所有内容，并且你自己不会构建这些包，它们只是占用了空间（尽管不多）。当你在系统中安装的库（无论是Libtool还是其他库）中进行链接时，实际上是使用`AC_CHECK`/`SEARCH`宏来查找库并直接链接*.a*或*.so*文件，因此在这种情况下也不会使用*.la*文件。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I outlined the basic rationale for shared libraries. As an
    exercise, we added a shared library to Jupiter that incorporates functionality
    from the convenience library we created earlier. We began with a more or less
    intuitive approach to incorporating a static library into a Libtool shared library,
    and in the process we discovered a more portable and correct way to do this using
    Libtool convenience libraries.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我概述了共享库的基本原理。作为练习，我们向Jupiter中添加了一个共享库，该共享库集成了我们之前创建的便利库中的功能。我们从一种或多或少直观的方法开始，将静态库集成到Libtool共享库中，在此过程中我们发现了使用Libtool便利库实现这一点的更具可移植性和正确性的方法。
- en: As with the other packages in the Autotools toolchain, Libtool gives you a lot
    of functionality and flexibility. But as you’ve probably noticed, with this degree
    of functionality and flexibility comes a price—complexity. The size of Jupiter’s
    configuration script increased dramatically with the addition of Libtool, and
    the time required to compile and link our project increased accordingly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Autotools 工具链中的其他软件包一样，Libtool 为你提供了丰富的功能和灵活性。但正如你可能已经注意到的，功能和灵活性的提升也带来了代价——复杂性。随着
    Libtool 的加入，Jupiter 的配置脚本大小大幅增加，编译和链接我们项目所需的时间也相应增加。
- en: In the next chapter, we’re going to continue our discussion of Libtool by looking
    at library-versioning issues and Libtool’s solution to the portability problems
    presented by manual dynamic runtime library management.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续讨论 Libtool，重点讲解库版本问题以及 Libtool 如何解决手动动态运行时库管理带来的可移植性问题。
