- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: BUILDING LIBRARIES WITH LIBTOOL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LIBTOOL 构建库
- en: '*The years teach much which the days never know.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*岁月教会了许多白日无法知道的事。*'
- en: — Ralph Waldo Emerson, “Experience”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——拉尔夫·沃尔多·爱默生，《经验》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: After too many bad experiences building shared libraries for multiple platforms
    without the help of GNU Libtool, I have come to two conclusions. First, the person
    who invented the concept of shared libraries should be given a raise . . . and
    a bonus. Second, the person who decided that shared library management interfaces
    and naming conventions should be left to the implementation should be flogged.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 GNU Libtool 帮助的情况下，经历了太多在多个平台上构建共享库的糟糕经验后，我得出了两个结论。首先，应该给发明共享库概念的人加薪……并且发放奖金。其次，应该对决定将共享库管理接口和命名约定留给实现的人进行鞭打。
- en: The very existence of Libtool stands as a witness to the truth of this sentiment.
    Libtool exists for only one reason—to provide a standardized, abstract interface
    for developers who want to create and access shared libraries in a portable manner.
    It abstracts both the shared-library build process and the programming interfaces
    used to dynamically load and access shared libraries at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 的存在本身就是这句话真理的见证。Libtool 存在的唯一原因是——为那些希望以可移植方式创建和访问共享库的开发者提供一个标准化、抽象的接口。它抽象了共享库构建过程和在运行时动态加载与访问共享库所用的编程接口。
- en: The Libtool package concept was designed, and initial implementation was done,
    by Gordon Matzigkeit in March of 1996\. Before this time, there was no standard,
    cross-platform mechanism for building shared libraries. Autoconf and Automake
    worked great for building portable projects across many platforms—as long as you
    didn’t try to build a shared library. Once you started down this path, however,
    your code and build system would become littered with conditional constructs for
    shared-library management. This was a monumental effort because, as we shall see,
    building shared libraries is significantly different among some platforms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 包概念是由 Gordon Matzigkeit 在 1996 年 3 月设计并初步实现的。在此之前，没有标准的跨平台机制用于构建共享库。Autoconf
    和 Automake 在构建可移植项目时表现得非常好——只要你不尝试构建共享库。然而，一旦你开始这条路，你的代码和构建系统就会充满用于共享库管理的条件构造。这是一个巨大的工程，因为，正如我们将看到的，构建共享库在某些平台上有显著不同。
- en: Thomas Tanner began contributing in November of 1998 with his cross-platform
    abstraction for shared-library dynamic loading—*ltdl*. Other contributors since
    that time include Alexandre Oliva, Ossama Othman, Robert Boehne, Scott James Remnant,
    Peter O’Gorman, and Ralf Wildenhues. Currently, the Libtool package is maintained
    by Gary V. Vaughn (who has also been contributing to Libtool since 1998) and Bob
    Friesenhahn (whose excellent suggestions have been incorporated since 1998).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Thomas Tanner 从 1998 年 11 月开始贡献了他的跨平台抽象用于共享库动态加载——*ltdl*。自那时以来，其他贡献者包括 Alexandre
    Oliva、Ossama Othman、Robert Boehne、Scott James Remnant、Peter O’Gorman 和 Ralf Wildenhues。目前，Libtool
    包由 Gary V. Vaughn（自 1998 年以来一直在贡献）和 Bob Friesenhahn（自 1998 年以来他的优秀建议被采纳）维护。
- en: Before I get into a discussion of the proper use of Libtool, I’ll spend a few
    paragraphs on the features and functionality that shared libraries provide so
    you understand the scope of the material I’m covering here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始讨论 Libtool 的正确使用之前，我会用几段话介绍共享库所提供的功能和特性，以便你理解我所涉及内容的范围。
- en: The Benefits of Shared Libraries
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享库的好处
- en: Shared libraries provide a way to deploy reusable chunks of functionality in
    a convenient package. You can load shared libraries into a process address space
    either automatically at program load time, by using the operating system loader,
    or manually via code in the application itself. The point at which an application
    binds functionality from a shared library is very flexible, and the developer
    determines it based on the program’s design and the end user’s needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库提供了一种以方便的方式部署可重用功能块的方式。你可以通过操作系统加载器在程序加载时自动将共享库加载到进程地址空间中，或者通过应用程序本身的代码手动加载。应用程序从共享库绑定功能的时机非常灵活，开发者可以根据程序设计和最终用户需求来确定这一点。
- en: The interfaces between the program executable and the modules defined as shared
    libraries must be reasonably well designed because shared-library interfaces must
    be well specified. This rigorous specification promotes good design practices.
    When you use shared libraries, the system essentially forces you to be a better
    programmer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可执行文件和定义为共享库的模块之间的接口必须设计得合理，因为共享库接口必须有明确的规范。这种严格的规范促进了良好的设计实践。当你使用共享库时，系统本质上迫使你成为一个更好的程序员。
- en: Shared libraries may be (as the name implies) shared among processes. This sharing
    is very literal. The code segments for a shared library can be loaded once into
    physical memory pages. Those same memory pages can then be mapped into the process
    address spaces of multiple programs at once. The data pages must, of course, be
    unique for each process, but global data segments are often small compared to
    the code segments of a shared library. This is true efficiency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库可能（正如名字所示）在进程之间共享。这种共享非常字面化。共享库的代码段可以一次加载到物理内存页中。这些相同的内存页可以同时映射到多个程序的进程地址空间中。当然，数据页必须对于每个进程是唯一的，但全局数据段通常比共享库的代码段要小得多。这才是真正的高效。
- en: It is easy to update shared libraries during program upgrades. Even if the base
    program doesn’t change between two revisions of a software package, you can replace
    an old version of a shared library with a new one, as long as the new version’s
    interfaces have not been changed. If interfaces *have* changed, two versions of
    the same shared library may reside together within the same directory, because
    the versioning schemes used by shared libraries (and supported by Libtool) on
    various platforms allow multiple versions of a library to be named differently
    in the filesystem but treated as the same library by the operating system loader.
    Older programs will continue to use older versions of the library, while newer
    programs are free to use the newer versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序升级过程中，更新共享库非常简单。即使基础程序在软件包的两个版本之间没有变化，只要新版本的接口没有发生变化，你就可以用新的共享库版本替换旧版本。如果接口*发生了*变化，同一个共享库的两个版本可能会共存在同一个目录中，因为共享库使用的版本控制机制（并且被
    Libtool 支持）允许在不同平台上，同一库的多个版本可以在文件系统中有不同的命名，但操作系统加载器将其视为同一个库。旧程序将继续使用旧版本的库，而新程序可以自由地使用新版本。
- en: If a software package specifies a well-defined plug-in interface, then shared
    libraries can be used to implement user-configurable loadable functionality. This
    means that additional functionality can become available to a program after it
    has been released, and third-party developers can even add functionality to your
    program, if you publish a document describing your plug-in interface specification
    (or if they’re smart enough to figure it out on their own).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个软件包定义了一个明确的插件接口，那么共享库可以用来实现用户可配置的可加载功能。这意味着，在程序发布后，额外的功能可以变得可用，第三方开发者甚至可以为你的程序添加功能，前提是你发布了描述插件接口规范的文档（或者他们足够聪明，能够自己弄明白）。
- en: There are a few widely known examples of these types of systems. Eclipse, for
    instance, is almost a pure plug-in framework. The base executable supports little
    more than a well-defined plug-in interface. Most of the functionality in an Eclipse
    application comes from library functions. Eclipse is written in Java and uses
    Java class libraries and *.jar* files, but the principle is the same, regardless
    of the language or platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些广为人知的这类系统示例。例如，Eclipse 几乎是一个纯粹的插件框架。基础可执行文件支持的功能仅仅是一个明确的插件接口。Eclipse 应用程序中的大部分功能来自于库函数。Eclipse
    是用 Java 编写的，使用 Java 类库和 *.jar* 文件，但这一原理是相同的，无论语言或平台如何。
- en: How Shared Libraries Work
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享库是如何工作的
- en: The specifics of how POSIX-compliant operating systems implement shared libraries
    vary from platform to platform, but the general idea is the same. Shared libraries
    provide chunks of executable code that the operating system can load into a program’s
    address space and execute. The following discussion applies to shared-library
    references that the linker resolves when a program is built and the operating
    system loader resolves when the program is loaded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 兼容操作系统实现共享库的具体方式因平台而异，但基本思路是相同的。共享库提供了操作系统可以加载到程序地址空间并执行的可执行代码块。以下讨论适用于链接器在构建程序时解析的共享库引用以及操作系统加载器在加载程序时解析的引用。
- en: While the object (*.o*) files produced by compilers do contain executable code,
    they cannot be executed by themselves from the command line. This is because they’re
    incomplete, containing symbolic references or *links* to external entities (functions
    and global data items) that must be patched up. This patching is done by using
    a tool designed to manage such links to combine the complete set of object files
    containing such references.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译器生成的目标文件（*.o*）包含可执行代码，但它们不能直接从命令行执行。这是因为它们是不完整的，包含了指向外部实体（函数和全局数据项）的符号引用或*链接*，这些需要修补。这个修补过程是通过使用专门的工具来管理这些链接，以便将包含这些引用的目标文件集合起来。
- en: '*Dynamic Linking at Load Time*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*动态链接时加载*'
- en: As a program executable image is being built, the linker (formally called a
    *link editor*) maintains a table of symbols—function entry points and global data
    addresses. Each symbol referenced within the accumulating body of object code
    is added to this table as the linker finds it. As symbol definitions are located,
    the linker resolves symbol references in the table to their addresses in the code.
    At the end of the linking process, all object files (or simply *objects*) containing
    referenced symbol definitions are linked together and become part of the program
    executable image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建程序可执行映像时，链接器（正式称为*链接编辑器*）维护一个符号表——函数入口点和全局数据地址。链接器在发现每个符号时，都会将其添加到符号表中。随着符号定义的找到，链接器将符号表中的符号引用解析为代码中的地址。在链接过程结束时，所有包含引用符号定义的目标文件（或简称*目标文件*）会被链接在一起，并成为程序可执行映像的一部分。
- en: Objects found in static libraries (also called archives) that contain no referenced
    symbol definitions are discarded, but objects linked explicitly are added to the
    binary image even if they contain no referenced symbol definitions. If there are
    outstanding references in the symbol table after all the objects have been analyzed,
    the linker exits with an error message. On success, the final executable image
    may be loaded and executed by a user. The image is now entirely self-contained,
    depending on no external binary code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态库中（也称为档案）找到的、没有引用符号定义的目标文件将被丢弃，但显式链接的目标文件会被添加到二进制映像中，即使它们没有引用符号定义。如果在分析完所有目标文件后，符号表中仍有未解决的引用，链接器将退出并显示错误信息。若成功，最终的可执行映像可以被用户加载并执行。此时，映像已经完全自包含，不再依赖任何外部二进制代码。
- en: Assuming that all undefined references are resolved during the linking process,
    if the list of objects to be linked contains one or more shared libraries, the
    linker will build the executable image from all *nonshared* objects specified
    on the linker command line. This includes all individual object files (*.o*) and
    all objects contained in static library archives (*.a*). However, the linker will
    add two tables to the binary image header. The first is the outstanding *external
    reference table*—a table of references to symbol definitions found only in shared
    libraries during the linking process. The second is the *shared-library table*,
    containing the list of shared-library names and versions in which the outstanding
    undefined references were found.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有未定义的引用都在链接过程中解决，如果要链接的目标文件列表包含一个或多个共享库，链接器将从命令行上指定的所有*非共享*目标文件中构建可执行映像。这包括所有单独的目标文件（*.o*）和所有包含在静态库档案（*.a*）中的目标文件。然而，链接器将向二进制映像头部添加两个表。第一个是未解决的*外部引用表*——一个在链接过程中只在共享库中找到的符号定义的引用表。第二个是*共享库表*，包含在未解决的未定义引用中找到的共享库名称和版本的列表。
- en: When the operating system loader attempts to load the program, it must resolve
    the remaining outstanding references in the external reference table to symbols
    imported from the shared libraries named in the shared-library table. If the loader
    can’t resolve all of the references, then a load error occurs, and the process
    is terminated with an operating system error message. Note that these external
    symbols are not tied to a specific shared library. As long as they’re found in
    any one of the searched libraries in the shared-library table, they’re accepted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统加载程序时，加载器必须解析外部引用表中剩余的未解决引用，这些引用指向共享库表中列出的共享库中的符号。如果加载器无法解决所有引用，则会发生加载错误，进程将终止并显示操作系统错误信息。请注意，这些外部符号并不绑定到特定的共享库。只要它们出现在共享库表中搜索到的任何一个库中，就会被接受。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This process differs slightly from the way a Windows operating system loader
    resolves symbols in dynamic link libraries (DLLs). On Windows, the linker ties
    a particular symbol to a specifically named DLL at program build time.^([1](footnote.xhtml#ch07fn1))*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个过程与Windows操作系统加载器解析动态链接库（DLL）中的符号的方式略有不同。在Windows中，链接器会在程序构建时将特定符号与特定命名的DLL绑定。^([1](footnote.xhtml#ch07fn1))*'
- en: Using free-floating external references has both pros and cons. On some operating
    systems, unbound symbols can be satisfied by a library specified by the user.
    That is, a user can entirely replace a library (or a portion of a library) at
    runtime by simply preloading one that contains the same symbols. On BSD and Linux-based
    systems, for example, a user can use the `LD_PRELOAD` environment variable to
    inject a shared library into a process address space. Since the loader loads these
    libraries before any other libraries, the loader will locate symbols in the preloaded
    libraries when it tries to resolve external references. The program author’s intended
    libraries will not even be checked because the symbols provided by these libraries
    have already been resolved by the preloaded libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自由浮动的外部引用有其利弊。在某些操作系统中，未绑定的符号可以由用户指定的库来满足。也就是说，用户可以通过简单地预加载一个包含相同符号的库，在运行时完全替换一个库（或库的一部分）。例如，在基于BSD和Linux的系统中，用户可以使用`LD_PRELOAD`环境变量将一个共享库注入到进程的地址空间中。由于加载器在任何其他库之前加载这些库，因此当加载器尝试解析外部引用时，会首先在预加载的库中查找符号。程序作者预期的库甚至不会被检查，因为这些库提供的符号已经被预加载的库解决。
- en: In the following example, the Linux `df` utility is executed with an environment
    containing the `LD_PRELOAD` variable. This variable has been set to a path referring
    to a library that presumably contains a heap manager that’s compatible with the
    C *malloc* interface. This technique can be used to debug memory problems in your
    programs. By preloading your own heap manager, you can capture memory allocations
    in a log file—in order to debug memory block overruns, for instance. This sort
    of technique is used by such widely known debugging aids as the *Valgrind* package.^([2](footnote.xhtml#ch07fn2))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，Linux的`df`工具在包含`LD_PRELOAD`变量的环境中执行。这个变量被设置为指向一个库的路径，这个库假定包含一个与C的*malloc*接口兼容的堆管理器。这个技术可以用于调试程序中的内存问题。通过预加载你自己的堆管理器，你可以在日志文件中捕获内存分配——例如调试内存块溢出问题。这种技术被像*Valgrind*工具包等广为人知的调试工具所使用。^([2](footnote.xhtml#ch07fn2))
- en: 'Here, the `LD_PRELOAD` environment variable is set on the same command line
    used to execute the `df` program. This shell code causes only the `df` child process
    environment to contain the `LD_PRELOAD` variable, set to the specified value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LD_PRELOAD`环境变量设置在与执行`df`程序相同的命令行中。此shell代码会使只有`df`子进程的环境包含`LD_PRELOAD`变量，并将其设置为指定的值：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, free-floating symbols can also lead to problems. For instance,
    two libraries can provide the same symbol name, and the dynamic loader can inadvertently
    bind an executable to a symbol from the wrong library. At best, this will cause
    a program crash when the wrong arguments are passed to the mismatched function.
    At worst, it can present security risks because the mismatched function might
    be used to capture passwords and security credentials passed by the unsuspecting
    program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，自由浮动符号也可能引发问题。例如，两个库可能提供相同的符号名称，而动态加载器可能不小心将可执行文件绑定到错误库中的符号上。最好的情况下，这将导致程序崩溃，当错误的参数被传递给不匹配的函数时。最坏的情况是，它可能带来安全风险，因为不匹配的函数可能会用来捕获未经怀疑的程序传递的密码和安全凭证。
- en: C-language symbols do not include parameter information, so it’s rather likely
    that symbols will clash in this manner. C++ symbols are a bit safer, in that the
    entire function signature (minus the return type) is encoded into the symbol name.
    However, even C++ is not immune to hackers who purposely replace security functions
    with their own versions of those functions (assuming, of course, that they have
    access to your runtime shared-library search path).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C语言符号不包含参数信息，因此符号发生冲突的可能性较大。C++符号稍微安全一些，因为整个函数签名（不包括返回类型）会被编码进符号名称中。然而，即便是C++也不能免疫黑客故意将安全函数替换为他们自己版本的函数（当然，前提是黑客能够访问你的运行时共享库搜索路径）。
- en: Automatic Dynamic Linking at Runtime
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行时自动动态链接
- en: The operating system loader can also use a very late form of binding, often
    referred to as *lazy binding*. In this situation, the external reference table
    entries in the program header are initialized so that they refer to code within
    the dynamic loader itself.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统加载器还可以使用一种非常晚期的绑定形式，通常称为*懒绑定*。在这种情况下，程序头中的外部引用表条目被初始化，使它们引用动态加载器本身中的代码。
- en: When a program first calls a *lazy entry*, the call is routed to the loader,
    which will then (potentially) load the proper shared library, determine the actual
    address of the function, reset the entry point in the jump table, and, finally,
    redirect the processor to the shared-library function (which is now available).
    The next time this happens, the jump table entry will have already been correctly
    initialized, and the program will jump directly to the called function. This is
    very efficient both because the overhead for the jump after fix-up is no more
    than a normal indirect function call and because the cost of the initial load
    and link is amortized over many calls to the function during the lifetime of the
    process.^([3](footnote.xhtml#ch07fn3))
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序首次调用*懒惰入口*时，调用会被路由到加载器，加载器将（可能）加载正确的共享库，确定函数的实际地址，重置跳转表中的入口点，最后将处理器重定向到共享库中的函数（现在可用）。下次发生这种情况时，跳转表条目将已经正确初始化，程序将直接跳转到被调用的函数。这是非常高效的，因为修正后的跳转开销与正常的间接函数调用相当，而且初始加载和链接的成本会在整个进程生命周期中通过多次调用该函数得到摊销。^([3](footnote.xhtml#ch07fn3))
- en: This lazy binding mechanism makes program startup very fast because shared libraries
    whose symbols are not bound until they’re needed aren’t even loaded until the
    application program first references them. But, consider this—the program may
    *never* reference them. And that means they may never be loaded, saving both time
    and space. A good example of this sort of situation might be a word processor
    with a thesaurus feature implemented in a shared library. How often do you use
    your thesaurus? If the program is using automatic dynamic linking, chances are
    that the shared library containing the thesaurus code will never be loaded in
    most word-processing sessions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种懒绑定机制使得程序启动非常快，因为共享库的符号直到需要时才会绑定，甚至在应用程序首次引用它们之前，这些库根本不会被加载。但请考虑一下——程序*可能永远*不会引用它们。这意味着这些库可能永远不会被加载，从而节省了时间和空间。一个很好的例子可能是一个带有同义词库功能的文字处理器，它是通过共享库实现的。你有多频繁使用同义词库？如果程序使用的是自动动态链接，通常情况下，包含同义词库代码的共享库在大多数文字处理过程中可能永远不会被加载。
- en: As good as this system appears to be, there can be problems. While using automatic
    runtime dynamic linking can give you faster load times, better performance, and
    more efficient use of space, it can also cause your application to terminate abruptly
    and without warning. In the event that the loader can’t find the requested symbol—perhaps
    the required library is missing—it has no recourse except to abort the process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个系统看起来非常好，但也可能存在一些问题。虽然使用自动运行时动态链接可以提高加载速度、提升性能并更有效地利用空间，但它也可能导致应用程序突然终止且没有任何警告。如果加载器无法找到请求的符号——可能是缺少所需的库——它除了中止进程之外别无他法。
- en: Why not ensure that all symbols exist when the program is loaded? Because if
    the loader resolved all symbols at load time, it might as well populate the jump
    table entries at that point, too. After all, it had to load all the libraries
    to ensure that the symbols actually exist, so this would entirely defeat the purpose
    of using lazy binding. Furthermore, even if the loader did check all external
    references when the program was first started, there’s nothing to stop someone
    from deleting one or more of these libraries before the program uses them, while
    the program is still running.^([4](footnote.xhtml#ch07fn4)) Thus, even the pre-check
    is defeated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在程序加载时确保所有符号都存在呢？因为如果加载器在加载时解决了所有符号，它也许还会在那个时候填充跳转表条目。毕竟，它必须加载所有库以确保符号确实存在，因此这将完全违背使用懒绑定的初衷。此外，即使加载器在程序首次启动时检查了所有外部引用，也没有什么能阻止某人在程序使用这些库之前删除一个或多个这些库，而程序仍在运行中。^([4](footnote.xhtml#ch07fn4))因此，甚至预检查也被打破了。
- en: The moral of this story is that there’s no free lunch. If you don’t want to
    pay the insurance premium for longer up-front load times and more space consumed
    (even if you may never really need it), then you may have to take the hit of a
    missing symbol at runtime, causing a program crash.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是：没有免费的午餐。如果你不想为较长的前期加载时间和更多的空间消耗支付保险费（即使你可能永远不需要它），那么你可能不得不承担在运行时缺少符号的风险，导致程序崩溃。
- en: Manual Dynamic Linking at Runtime
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行时手动动态链接
- en: One possible solution to the aforementioned problem is to take personal responsibility
    for some of the system loader’s work. Then, when things don’t go right, you have
    a little more control over the outcome. In the case of the thesaurus module, was
    it really necessary to terminate the program if the thesaurus library could not
    be loaded or didn’t provide the correct symbols? Of course not—but the operating
    system loader can’t know that. Only the software programmer can make such judgment
    calls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述问题的一个可能方法是让程序对系统加载器的一部分工作负责。这样，当事情出错时，程序对结果有更多的控制权。在词库模块的例子中，如果无法加载词库或词库没有提供正确的符号，真的有必要终止程序吗？当然没有——但是操作系统加载器无法知道这一点，只有软件程序员能做出这样的判断。
- en: When a program manages dynamic linking manually at runtime, the linker is left
    out of the equation entirely, and the program doesn’t call any exported shared-library
    functions directly. Rather, shared-library functions are referenced through function
    pointers that the program itself populates at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在运行时手动管理动态链接时，链接器完全不参与其中，程序不会直接调用任何导出的共享库函数。相反，共享库函数通过程序在运行时填充的函数指针进行引用。
- en: 'Here’s how it works: A program calls an operating system function (`dlopen`)
    to manually load a shared library into its own process address space. This function
    returns a *handle*, or an opaque value representing the loaded library. The program
    then calls another loader function (`dlsym`) to import a symbol from the library
    to which the handle refers. If all goes well, the operating system returns the
    address of the requested function or data item from the desired library. The program
    may then call the function, or access the global data item, through this pointer.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：一个程序调用操作系统的函数（`dlopen`）手动将共享库加载到它自己的进程地址空间中。这个函数返回一个*句柄*，即一个表示已加载库的不透明值。程序接着调用另一个加载函数（`dlsym`）从句柄所指向的库中导入一个符号。如果一切顺利，操作系统会返回所请求的函数或数据项的地址。然后，程序可以通过这个指针调用函数或访问全局数据项。
- en: If something goes wrong in this process—the symbol isn’t found within the library
    or the library isn’t found—then it becomes the responsibility of the program to
    define the results, perhaps by displaying an error message indicating that the
    program was not configured correctly. In the preceding example of the word processor,
    a simple dialog indicating that the thesaurus is unavailable would be entirely
    sufficient.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个过程中出了问题——符号在库中找不到或库找不到——那么就由程序来定义结果，可能通过显示错误信息来提示程序配置不正确。在前面的文字处理器例子中，一个简单的对话框提示词库不可用就完全足够了。
- en: This is a little nicer than the way automatic dynamic runtime linking works;
    while the loader has no option but to abort, the application has a higher-level
    perspective and can handle the problem much more gracefully. The drawback, of
    course, is that you as the programmer have to manage the process of loading libraries
    and importing symbols within your application code. However, this process is not
    very difficult, as I’ll demonstrate in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这比自动动态运行时链接方式稍好一些；虽然加载器别无选择只能中止，但应用程序有更高层次的视角，可以更优雅地处理问题。当然，缺点是作为程序员的你必须在应用程序代码中管理加载库和导入符号的过程。不过，这个过程并不困难，正如我将在下一章中演示的那样。
- en: Using Libtool
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Libtool
- en: An entire book could be written about the details of shared libraries and how
    they’re implemented on various systems. The short primer you just read should
    suffice for our immediate needs, so I’ll now move on to how you can use Libtool
    to make a package maintainer’s life a little easier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共享库及其在各种系统中实现的细节，可以写一本完整的书。你刚刚阅读的简短入门内容已经足够满足我们的眼前需求，现在我将继续讲解如何使用 Libtool
    让包维护者的工作变得更轻松。
- en: The Libtool project was designed to extend Automake, but you can use it independently
    within hand-coded makefiles, as well. As of this writing, the latest version of
    Libtool, and the one I’m using in the examples here, is version 2.4.6.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstracting the Build Process*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s look at how Libtool helps during the build process. Libtool provides
    a script (*ltmain.sh*) that `config.status` consumes in a Libtool-enabled project.
    The `config.status` script converts `configure` test results and the `ltmain.sh`
    script into a custom version of the `libtool` script, specifically tailored to
    your project.^([5](footnote.xhtml#ch07fn5)) Your project’s makefiles then use
    this `libtool` script to build the shared libraries listed in any Automake product
    list variables defined with the Libtool-specific `LTLIBRARIES` primary. The `libtool`
    script is really just a fancy wrapper around the compiler, linker, and other tools.
    You should ship the `ltmain.sh` script in a distribution archive, as part of your
    build system. Automake-generated rules ensure that this happens properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The `libtool` script insulates the author of the build system from the nuances
    of building shared libraries on different platforms. This script accepts a well-defined
    set of options, converting them to appropriate platform- and linker-specific options
    on the target platform and toolset. Thus, the maintainer doesn’t need to worry
    about the specifics of building shared libraries on each platform—they only need
    to understand the available `libtool` script options. These options are well specified
    in the *GNU Libtool Manual*,^([6](footnote.xhtml#ch07fn6)) and I’ll cover many
    of them in this chapter and the next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: On systems that don’t support shared libraries at all, the `libtool` script
    uses appropriate commands and options to build and link only static archive libraries.
    Furthermore, the maintainer doesn’t have to worry about the differences between
    building shared libraries and building static libraries when using Libtool. You
    can emulate building your package on a static-only system by using the `--disable-shared`
    option on the `configure` command line for your Libtool-enabled project. This
    option causes Libtool to assume that shared libraries cannot be built on the target
    system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstraction at Runtime*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also use Libtool to abstract the programming interfaces the operating
    system supplies for loading libraries and importing symbols. If you’ve ever dynamically
    loaded a library on a Linux system, you’re familiar with the standard POSIX shared-library
    API, including the `dlopen`, `dlsym`, and `dlclose` functions. A system-level
    shared library, usually called simply *dl*, provides these functions. This translates
    to a binary image file named *libdl.so* (or something similar on systems that
    use different library-naming conventions).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not all Unix systems that support shared libraries provide the
    *libdl.so* library or functions using these names. To address these differences,
    Libtool provides a shared library called *ltdl*, which exports a clean, portable,
    library-management interface that is very similar to the POSIX *dl* interface.
    The use of this library is optional, of course, but it is highly recommended because
    it provides more than just a common API across shared-library platforms—it also
    provides an abstraction for manual dynamic linking between shared-library and
    non-shared-library platforms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*What?! How can that work?!* On systems that don’t support shared libraries,
    Libtool actually creates internal symbol tables within the executable that contain
    all the symbols you would otherwise find within shared libraries (on systems that
    support shared libraries). By using such symbol tables on these platforms, the
    `lt_dlopen` and `lt_dlsym` functions can make your code appear to be loading libraries
    and importing symbols, when in fact, the library load function does nothing more
    than return a handle to the appropriate internal symbol table, and the import
    function merely returns the address of code that has been statically linked into
    the program itself. On these systems, a project’s shared-library code is linked
    directly into the programs that would normally load them at runtime.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Installing Libtool
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to make use of the latest version of Libtool while developing your
    packages, you may find that you either have to download, build, and install it
    manually or look for an updated *libtool* package from your distribution provider.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Downloading, building, and installing Libtool is really trivial, as you’ll
    see here. However, you should check the GNU Libtool website^([7](footnote.xhtml#ch07fn7))
    before executing these steps in order to ensure you’re getting the most recent
    package. I’ve reproduced the basic steps here from [Chapter 1](ch01.xhtml):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be aware that the default installation location (as with most of the GNU packages)
    is */usr/local*. If you wish to install Libtool into the */usr* hierarchy, you’ll
    need to use the `--prefix=/usr` option on the `configure` command line. The recommended
    practice is to install distribution-provided packages into the */usr* hierarchy
    and user-built packages into the */usr/local* tree, but if you’re trying to get
    a hand-built version of Libtool to interoperate with distribution-provided versions
    of Autoconf and Automake, you may have to install Libtool into the */usr* hierarchy.
    The simplest way to avoid problems with package interdependencies is to install
    hand-built versions of all three packages into */usr/local* or, better still,
    into a directory within your home directory, which you can then add to your `PATH`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Adding Shared Libraries to Jupiter
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that I’ve presented the requisite background information, let’s take a look
    at how we might add a Libtool shared library to the Jupiter project. First, let’s
    consider what functionality we could add to Jupiter using a shared library. Perhaps
    we want to provide our users with some library functionality that their own applications
    could use. Or we might have several applications in a package that need to share
    the same functionality. A shared library is a great tool for both of these scenarios
    because you get to reuse code and save memory—the cost of the memory used by shared
    code is amortized across multiple applications, both internal and external to
    the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a shared library to Jupiter that provides Jupiter’s printing functionality.
    We can do this by having the new shared library call into the *libjupcommon.a*
    static library. Remember that calling a routine in a static library has the same
    effect as linking the object code for the called routine right into the calling
    program. The called routine ultimately becomes an integral part of the calling
    binary image (program or shared library).^([8](footnote.xhtml#ch07fn8))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we’ll provide a public header file from the Jupiter project that
    will allow external applications to call this same functionality. This allows
    other applications to display stuff in the same quaint manner that the `jupiter`
    program does. (This would be significantly cooler if we were doing something useful
    in Jupiter, but you get the idea.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the LTLIBRARIES Primary*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Automake has built-in support for Libtool; it’s the Automake package, rather
    than the Libtool package, that provides the `LTLIBRARIES` primary. Libtool doesn’t
    really qualify as a pure Automake extension but rather is more of an add-on package
    for Automake, where Automake provides the necessary infrastructure for this specific
    add-on package. You can’t access Automake’s `LTLIBRARIES` primary functionality
    without Libtool because the use of this primary generates `make` rules that call
    the `libtool` script.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Libtool ships separately, rather than as part of Automake, because you can use
    Libtool quite effectively independently of Automake. If you want to try Libtool
    by itself, I’ll refer you to the *GNU Libtool Manual*; the opening chapters describe
    the use of the `libtool` script as a stand-alone product. It’s as simple as modifying
    your makefile commands so that the compiler, linker, and librarian are called
    through the `libtool` script, and then modifying some of your command line parameters
    as required by Libtool.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '*Public Include Directories*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A project subdirectory named *include* should only contain public header files—those
    that expose a public interface in your project. We’re now going to add just such
    a header file to the Jupiter project, so we’ll create a directory called *include*
    in the project root directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had multiple shared libraries, we’d have a choice to make: do we create
    separate *include* directories, one in each library source directory, or do we
    add a single, top-level *include* directory? I usually use the following rule
    of thumb to make my decision: If the libraries are designed to work together as
    a group, and if consuming applications generally use the libraries together, then
    I use a single, top-level *include* directory. If, on the other hand, the libraries
    can be effectively used independently, and if they offer fairly autonomous sets
    of functionality, then I provide individual *include* directories in the libraries’
    own directories.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it doesn’t really matter much because the header files for these
    libraries will be installed in directory structures that are entirely different
    from the ones where they exist within your project. In fact, you should make sure
    you don’t inadvertently use the same filename for public headers in two different
    libraries in your project—if you do, you’ll have problems installing these files.
    They generally end up all together in the `$(prefix)`*/include* directory, although
    you can override this default by using either the `includedir` variable or the
    `pkginclude` prefix in your *Makefile.am* files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The `includedir` variable allows you to specify where you want your header files
    to be installed by defining the exact value of Automake’s `$(includedir)` variable,
    the usual value of which is `$(prefix)`*/include*. The use of the `pkginclude`
    prefix indicates to Automake that you want your header files to be in a private,
    package-specific directory, beneath the directory indicated by `$(includedir)`,
    called `$(includedir)`*/*`$(PACKAGE)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also add another root-level directory (*libjup*) for Jupiter’s new shared
    library, *libjupiter*. These changes require you to add references to the new
    directories to the top-level *Makefile.am* file’s `SUBDIRS` variable and then
    add corresponding *Makefile* references to the `AC_CONFIG_FILES` macro in *configure.ac*.
    Since we’re going to make major changes to our project, we’d better clean up the
    work area before we start. Then we’ll create the directories and add a new *Makefile.am*
    file to the new *include* directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 7.0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *include* directory’s *Makefile.am* file is trivial—it contains only a single
    line, in which an Automake `HEADERS` primary refers to the public header file
    *libjupiter.h*. Note at ➊ that we’re using the `include` prefix on this primary.
    You’ll recall that this prefix indicates that files specified in this primary
    are destined to be installed in the `$(includedir)` directory (for example, */usr/(local/)include*).
    The `HEADERS` primary is similar to the `DATA` primary in that it specifies a
    set of files that are to be treated simply as data to be installed without modification
    or preprocessing. The only really tangible difference is that the `HEADERS` primary
    restricts the possible installation locations to those that make sense for header
    files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The *libjup/Makefile.am* file is a bit more complex, containing four lines as
    opposed to just one. This file is shown in [Listing 7-1](ch07.xhtml#ch07ex1).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-1:* libjup/Makefile.am: *The initial version of this file*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze this file, line by line. The line at ➊ is the primary specification,
    and it contains the usual prefix for libraries: `lib`. The products this prefix
    references will be installed in the `$(libdir)` directory. (We could have also
    used the `pkglib` prefix to indicate that we wanted our libraries installed into
    `$(libdir)`*/jupiter*.) Here, we’re using the `LTLIBRARIES` primary rather than
    the original `LIBRARIES` primary. The use of `LTLIBRARIES` tells Automake to generate
    rules that use the `libtool` script rather than calling the compiler (and possibly
    the librarian) directly to generate the products.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ lists the sources that are to be used for the first (and only)
    product.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ indicates a set of C-preprocessor flags that are to be used on
    the compiler command line for locating the associated shared-library header files.
    These options indicate that the preprocessor should search the top-level *include*
    and *common* directories for header files referenced in the source code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The last line (at ➍) indicates a set of linker options for this product. In
    this case, we’re specifying that the *libjupcommon.a* static library should be
    linked into (that is, become part of) the *libjupiter.so* shared library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*The more experienced Autotools library developer will notice a subtle flaw
    in this* Makefile.am *file. Here’s a hint: it’s related to linking Libtool libraries
    against non-Libtool libraries. This concept presents a major stumbling block for
    many newcomers, so I’ve written the initial version of this file to illustrate
    the error. Not to worry, however—we’ll correct the flaw later in this chapter
    as we work through this issue in a logical fashion*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important concept regarding the `*_LIBADD` variables that you should
    strive to understand completely: Libraries that are consumed within, and yet built
    as part of, the same project should be referenced internally using relative paths,
    via either parent directory references or the `$(``top_builddir``)` variable,
    within the *build* directory hierarchy. Libraries that are external to a project
    generally don’t need to be referenced explicitly at all, because the project’s
    `configure` script should already have added appropriate `-L` and `-l` options
    for those libraries into the `$(LIBS)` environment variable when it processed
    the code generated by the `AC_CHECK_LIB` or `AC_SEARCH_LIBS` macro.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll hook these new directories into the project’s build system. To do
    so, we need to modify the top-level *Makefile.am* and *configure.ac* files. These
    changes are shown in [Listings 7-2](ch07.xhtml#ch07ex2) and [7-3](ch07.xhtml#ch07ex3),
    respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-2:* Makefile.am: *Adding* include *and* libjup *to the `SUBDIRS`
    variable*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-3:* configure.ac: *Adding the* include *and* libjup *directory makefiles*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Three unrelated changes were required in *configure.ac*. The first is the addition
    at ➊ of the Libtool setup macros `LT_PREREQ` and `LT_INIT`. The `LT_PREREQ` macro
    works just like Autoconf’s `AC_PREREQ` macro (used a few lines higher). It indicates
    the earliest version of Libtool that can correctly process this project. You should
    choose the lowest reasonable values for the arguments in these macros because
    higher values needlessly restrict you and your co-maintainers to more recent versions
    of the Autotools.^([9](footnote.xhtml#ch07fn9)) The `LT_INIT` macro initializes
    the Libtool system for this project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The second change is just as interesting. I removed the `AC_PROG_RANLIB` macro
    invocation after the line at ➋. (And after all we went through to put it there
    in the first place!) Because Libtool is now building all of the project libraries,
    and because it understands all aspects of the library build process, we no longer
    need to instruct Autoconf to make sure `ranlib` is available. In fact, if you
    leave this macro in, you’ll get a warning when you execute `autoreconf -i`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The last change is found at ➌ in the argument to `AC_CONFIG_FILES`, where we’ve
    added references to the two new *Makefile.am* files we added to the *include*
    and *libjup* directories.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Customizing Libtool with LT_INIT Options*'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can specify default values for enabling or disabling static and shared
    libraries in the argument list passed into `LT_INIT`. The `LT_INIT` macro accepts
    a single, optional argument: a whitespace-separated list of keywords. The following
    are the most important keywords allowed in this list, along with an explanation
    of their proper use.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: dlopen
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This option enables checking for `dlopen` support. The *GNU Libtool Manual*
    states that this option should be used if the package makes use of the `-dlopen`
    and `-dlpreopen` flags in `libtool`; otherwise `libtool` will assume that the
    system does not support *dl-opening*. There’s only one reason for using the `-dlopen`
    or `-dlpreopen` flag: you intend to dynamically load and import shared-library
    functionality at runtime within your project’s source code. Additionally, these
    two options do very little unless you intend to use the *ltdl* library (rather
    than directly using the *dl* library) to manage your runtime dynamic linking.
    Thus, you should use this option only if you intend to use the *ltdl* library.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: win32-dll
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Use this option if your library is properly ported to a Windows DLL using `__declspec(dllimport)`
    and `__declspec(dllexport)`. If your library properly uses these keywords to import
    and export symbols for Windows DLLs, and you don’t use this option, then Libtool
    will only build static libraries on Windows. We’ll cover this topic in more detail
    in [Chapter 17](ch17.xhtml).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: aix-soname=aix|svr4|both
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Adds the flags `--with-aix-soname` to `configure`’s command line. Prior to version
    2.4.4, Libtool always behaved as if `aix-soname` were set to `aix`. If you build
    shared libraries on AIX often, you’ll understand the meaning of this option. If
    you wish to learn more, read Section 5.4.1 of the *GNU Libtool Manual*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: disable-fast-install
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This option changes the default behavior for `LT_INIT` to disable optimization
    for fast installation on systems where it matters. The concept of fast installation
    exists because uninstalled programs and libraries may need to be executed from
    within the build tree (during `make check`, for example). On some systems, installation
    location affects the final linked binary image, so Libtool must either relink
    programs and libraries on these systems when `make install` is executed or else
    relink programs and libraries for `make check`. Libtool chooses to relink for
    `make check` by default, allowing the original binaries to be installed quickly
    without relinking during `make install`. The user can override this default, depending
    on platform support, by specifying `--enable-fast-install` to `configure`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: shared and disable-shared
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating shared libraries.
    The effects of the `shared` option are default behavior on all systems where Libtool
    knows how to create shared libraries. The user may override the default shared
    library-generation behavior by specifying either `--disable-shared` or `--enable-shared`
    on the `configure` command line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: static and disable-static
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating static libraries.
    The effects of the `static` option are default behavior on all systems where shared
    libraries have been disabled and on most systems where shared libraries have been
    enabled. If shared libraries are enabled, the user may override this default by
    specifying `--``disable-static` on the `configure` command line. Libtool will
    always generate static libraries on systems without shared libraries. Hence, you
    can’t (effectively) use the `disable-shared` and `disable-static` arguments to
    `LT_INIT` or the `--disable-shared` and `--disable-static` command line options
    for `configure` at the same time. (Note, however, that you may use the `shared`
    and `static` `LT_INIT` options or the `--enable-shared` and `--enable-static`
    command line options together.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: pic-only and no-pic
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: These two options change the default behavior for creating and using PIC object
    code. The user may override the defaults set by these options by specifying `--without-pic`
    or `--with-pic` on the `configure` command line. I’ll discuss the meaning of PIC
    object code in “So What Is PIC, Anyway?” on [page 200](ch07.xhtml#page_200).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished setting up the build system for the new library, we
    can move on to discussing the source code. [Listing 7-4](ch07.xhtml#ch07ex4) shows
    the contents of the new *jup_print.c* source file that’s referenced in the second
    line of *libjup/Makefile.am*. [Listing 7-5](ch07.xhtml#ch07ex5) shows the contents
    of the new *include/libjupiter.h* library header file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-4:* libjup/jup_print.c: *The initial contents of the shared-library
    source file*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-5:* include/libjupiter.h: *The initial contents of the shared-library
    public header file*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to another general software-engineering principle. I’ve heard
    it called by many names, but the one I tend to use the most is the *DRY principle*—the
    acronym stands for *don’t repeat yourself*. C function prototypes are very useful
    because, when used correctly, they enforce the fact that the public’s view of
    a function is identical to the package maintainer’s view. All too often I’ve seen
    source files that don’t include their corresponding header files. It’s easy to
    make a small change in a function or prototype and then not duplicate it in the
    other location—unless you’ve included the public header file within the source
    file. When you do this consistently, the compiler catches any inconsistencies
    for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include the static library header file (*jupcommon.h*) because
    we call its function (*print_routine*) from within the public library function.
    You may have also noticed that I placed *config.h* first, immediately followed
    by the public header file—there’s a good reason for this. I’ve already stated
    in [Chapter 6](ch06.xhtml) that *config.h* should always come first in every source
    file. Normally, I’d say the public header file should come first, but public header
    files should be written so that their functionality is never modified by *config.h*,
    so, technically, it should not matter if the public header file comes before or
    after *config.h*. For example, using a compiler-mode dependent type like `off_t`
    in a public header file will cause the application binary interface (ABI) to change
    not only from one platform to another (not necessarily a bad thing) but also on
    the same platform from one use to another, based on the compilation environment
    set up by consumer code (not a good thing). The fact is, you should write your
    public header files in such a way that it doesn’t really matter whether you include
    them before or after *config.h*; they should be purposely designed so they do
    not depend on anything that *can* be configured by *config.h*. For a more complete
    treatise on this topic, see “Item 1: Keeping Private Details out of Public Interfaces”
    on [page 499](ch18.xhtml#page_499).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: By placing the public header file first in the source file (after *config.h*),
    we ensure that the use of this header file doesn’t depend on definitions in any
    internal header files in the project. For instance, let’s say the public header
    file has a hidden dependency on some construct (such as a type definition, structure,
    or preprocessor definition) defined in an internal header like *jupcommon.h*.
    If we include the public header file after *jupcommon.h*, the dependency would
    be hidden when the compiler begins to process the public header file, because
    the required construct is already available in the *translation unit* (the source
    file combined with all of the included header files).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to make one final point about the contents of [Listing 7-5](ch07.xhtml#ch07ex5).
    The preprocessor conditional construct is commonly called an *include guard*.
    It is a mechanism for preventing your header files from inadvertently being included
    multiple times within the same translation unit. I use include guards routinely
    in all my header files, and it’s good practice to do so. A good optimizing compiler
    (`gcc`, for instance—specifically, its preprocessor) will recognize include guards
    in header files and skip the file entirely on subsequent inclusions within the
    same translation unit.^([10](footnote.xhtml#ch07fn10))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Since a public header file will be consumed by foreign source code, it’s even
    more critical that you use include guards religiously in these header files. While
    you can control your own code base, you have no say over the code that one of
    your library consumers writes. What I’m advocating here is that you assume you’re
    the best programmer you know, and everyone else is a little below your skill level.
    You can do this nicely by not mentioning it to anyone, but you should *act* like
    it’s a fact when you write your public header files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll modify the Jupiter application’s `main` function so that it calls
    into the shared library instead of the common static library. These changes are
    shown in [Listing 7-6](ch07.xhtml#ch07ex6).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-6:* src/main.c: *Changing `main` to call the shared-library function*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve changed the print function from `print_routine`, found in the static
    library, to `jupiter_print`, as provided by the new shared library. We’ve also
    changed the header file included at the top from *libjupcommon.h* to *libjupiter.h*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: My choices of names for the public function and header file were arbitrary but
    based on a desire to provide a clean, rational, and informational public interface.
    The name *libjupiter.h* very clearly indicates that this header file specifies
    the public interface for *libjupiter.so*. I try to name library interface functions
    to make it clear that they are part of an interface. How you choose to name your
    public interface members—files, functions, structures, type definitions, preprocessor
    definitions, global data, and so on—is up to you, but you should consider using
    a similar philosophy. Remember, the goal is to provide a great end-user experience.
    Intuitive naming should be a significant part of your strategy. For example, it
    is a good general practice to choose a common prefix for your program and library
    symbols.^([11](footnote.xhtml#ch07fn11))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must also modify the *src/Makefile.am* file to use our new shared
    library rather than the *libjupcommon.a* static library. These changes are shown
    in [Listing 7-7](ch07.xhtml#ch07ex7).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-7:* src/Makefile.am: *Adding shared-library references to the src
    directory makefile*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve changed the `jupiter_CPPFLAGS` statement at ➊ so that it refers
    to the new top-level *include* directory rather than the *common* directory. We’ve
    also changed the `jupiter_LDADD` statement at ➋ so that it refers to the new Libtool
    shared-library object rather than the *libjupcommon.a* static library. All else
    remains the same. The syntax for referring to a Libtool library is identical to
    that for referring to an older, static library—only the library extension is different.
    The Libtool library extension *.la* stands for *libtool archive*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a step back for a moment. Do we actually need to make this change?
    No, of course not. The `jupiter` application will continue to work just fine the
    way we originally wrote it. Linking the code for the static library’s `print_routine`
    directly into the application works just as well as calling the new shared-library
    routine (which ultimately contains the same code, anyway). In fact, there is slightly
    more overhead in calling a shared-library routine because of the extra level of
    indirection when calling through a shared-library jump table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In a real project, you might actually leave it the way it was. Because both
    public entry points, `main` and `jupiter_print`, call exactly the same function
    (`print_routine`) in *libjupcommon.a*, their functionality is identical. Why add
    even the slight overhead of a call through the public interface? Well, one reason
    is that you can take advantage of shared code. By using the shared-library function,
    you’re not duplicating code—either on disk or in memory. This is the DRY principle
    at work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is to exercise the interface you’re providing for users of your
    shared library. You’ll catch bugs in your public interfaces more quickly if your
    project code uses your shared libraries exactly the way you expect other programs
    to use them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you might now consider simply moving the code from the static
    library into the shared library, thereby removing the need for the static library
    entirely. However, I’m going to beg your indulgence with my contrived example.
    In a more complex project, I might very well have a need for this sort of configuration.
    Common code is often gathered together into static convenience libraries, and
    more often than not, only a portion of this common code is reused in shared libraries.
    I’m going to leave it the way it is here for the sake of its educational value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '*Reconfigure and Build*'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we’ve added Libtool—a major new component—to our project build system,
    we’ll add the `-i` option to the `autoreconf` command line to ensure that all
    of the proper auxiliary files are installed into the project root directory:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we completely removed all generated and copied files from our project
    directory, most of these notifications have to do with replacing files we’ve already
    discussed. However, there are a few noteworthy exceptions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the comments from `libtoolize` at ➊. Most of them are simply suggesting
    that we move to the new Autotools convention of adding M4 macro files to a directory
    called *m4* in the project root directory. We’re going to ignore these comments
    for now, but in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml), we’ll actually
    do this for a real project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: As you can see at ➋, it appears that the addition of Libtool has caused a few
    new files to be added to our project—namely, the *config.guess* and *config.sub*
    files. Another new file was added in the section at ➊ called *ltmain.sh*. The
    `configure` script uses *ltmain.sh* to build a project-specific version of `libtool`
    for the Jupiter project. I’ll describe the `config.guess` and `config.sub` scripts
    later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and execute `configure` and see what happens:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to note is that Libtool adds *significant* overhead to the configuration
    process. I’ve only shown a few of the output lines here that are new since we
    added Libtool. All we’ve added to the *configure.ac* file is the reference to
    the `LT_INIT` macro, but we’ve nearly doubled our `configure` output. This should
    give you some idea of the number of system characteristics that must be examined
    to create portable shared libraries. Fortunately, Libtool does a lot of the work
    for you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the `make` command and see what sort of output we get:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We seem to have some errors to fix. The first point of interest is that `libtool`
    is being executed at ➊ with a `--mode=compile` option, which causes `libtool`
    to act as a wrapper script around a somewhat modified version of a standard `gcc`
    command line. You can see the effects of this statement in the next two compiler
    command lines at ➋ and ➌. *Two compiler commands?* That’s right. It appears that
    `libtool` is running the compiler twice against our source file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: A careful comparison of these two command lines shows that the first command
    is using two additional flags, `-fPIC` and `-DPIC`. The first line also appears
    to be directing the output file to a *.libs* subdirectory, whereas the second
    line is saving it in the current directory. Finally, both the `stdout` and `stderr`
    output streams are redirected to */dev/null* in the second line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*Occasionally, you may run into a situation where a source file compiles fine
    in the first compilation but fails in the second due to a PIC-related source code
    error. These sorts of problems are rare, but they can be a real pain when they
    occur because *`make`* halts the build with an error but doesn’t give you any
    error messages to explain the problem! When you see this situation, simply pass
    the *`-no-suppress`* flag in the *`CFLAGS`* variable on the *`make`* command line
    in order to tell Libtool not to redirect output from the second compilation to*
    /dev/null.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: This double-compile feature has caused a fair amount of anxiety on the Libtool
    mailing list over the years. Mostly, this is due to a lack of understanding of
    what Libtool is trying to do and why it’s necessary. Using Libtool’s various `configure`
    script command line options, you can force a single compilation, but doing so
    brings a certain loss of functionality, which I’ll explain here shortly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ renames the dependency file from **.Tpo* to **.Plo*. You might
    recall from [Chapters 3](ch03.xhtml) and [6](ch06.xhtml) that dependency files
    contain `make` rules that declare dependencies between source files and referenced
    header files. The C preprocessor generates these rules when you use the `-MT`
    compiler option. However, the overarching concept to understand here is that one
    Libtool command may (and often does) execute a group of shell commands.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ is another call to the `libtool` script, this time using the `--mode=link`
    option. This option generates a call to execute the compiler in *link mode*, passing
    all of the libraries and linker options specified in the *Makefile.am* file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, we come to the first problem—a portability warning about linking a shared
    library against a static library. Specifically, this warning is about linking
    a Libtool shared library against a non-Libtool static library. Notice that this
    is not an error. Were it not for additional errors we’ll encounter later, the
    library would be built in spite of this warning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'After the portability warning, `libtool` attempts to link the requested objects
    together into a shared library named *libjupiter.so.0.0.0* . But here the script
    runs into the real problem: at ➐, a linker error indicates that somewhere from
    within *libjupcommon.a*—and more specifically, within *print.o*—an `x86_64` object
    relocation cannot be performed because the original source file (*print.c*) was
    apparently not compiled correctly. The linker is kind enough to tell us exactly
    what we need to do to fix the problem (highlighted in the example): we need to
    compile the source code using a `-fPIC` compiler option.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you were to encounter this error and didn’t know anything about the
    `-fPIC` option, you’d be wise to open the man page for `gcc` and study it before
    inserting compiler and linker options willy-nilly until the warning or error disappears
    (unfortunately, a common practice of inexperienced programmers). Software engineers
    should understand the meaning and nuances of every command line option used by
    the tools in their build systems. Otherwise, they don’t really know what they
    have when their build completes. It may work the way it should, but if it does,
    it’s by luck rather than by design. Good engineers know their tools, and the best
    way to learn is to study error messages and their fixes until the problem is well
    understood, before moving on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*So What Is PIC, Anyway?*'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When operating systems create new process address spaces, they typically load
    program-executable images at the same memory address. This magic address is system
    specific. Compilers and linkers understand this, and they know what the magic
    address is on any given system. Therefore, when they generate internal references
    to function calls or global data, they can generate those references as *absolute*
    addresses. If you were somehow able to load the executable at a different location
    in the process virtual address space, it would simply not work properly because
    the absolute addresses within the code would not be correct. At the very least,
    the program would crash when the processor jumped to the wrong location during
    a function call.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Figure 7-1](ch07.xhtml#ch07fig1) for a moment. Assume we have a system
    whose magic executable load address is `0x10000000`; this diagram depicts two
    process address spaces within that system. In the process on the left, an executable
    image is loaded correctly at address `0x10000000`. At some point in the code,
    a `jmp` instruction tells the processor to transfer control to the absolute address
    `0x10001000`, where it continues executing instructions in another area of the
    program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Absolute addressing in executable images*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In the process on the right, the program is loaded incorrectly at address `0x20000000`.
    When that same branch instruction is encountered, the processor jumps to address
    `0x10001000` because that address is hardcoded into the program image. This, of
    course, fails—often spectacularly by crashing, but sometimes with more subtle
    and dastardly ramifications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: That’s how things work for program images. However, when a *shared library*
    is built for certain types of hardware (AMD64 included), neither the compiler
    nor the linker knows beforehand where the library will be loaded. This is because
    many libraries may be loaded into a process and the order in which they are loaded
    depends on how the *executable* is built, not the library. Furthermore, who’s
    to say which library owns location A and which one owns location B? The fact is,
    a library may be loaded *anywhere* into the process address space where there
    is space for it at the time it’s loaded. Only the operating system loader knows
    where it will finally reside—and even then, it only knows just before the library
    is actually loaded.^([12](footnote.xhtml#ch07fn12))
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: As a result, shared libraries can only be built from a special class of object
    files called PIC objects. *PIC* is an acronym that stands for *position-independent
    code*, and it implies that references within the object code are not absolute
    but *relative*. When you use the `-fPIC` option on the compiler command line,
    the compiler will use somewhat less efficient relative addressing in branching
    instructions. Such position-independent code may be loaded anywhere.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) depicts the concept of relative addressing
    as used when generating PIC objects. With relative addressing, addresses work
    correctly regardless of where the image is loaded because they’re always encoded
    relative to the current instruction pointer. In [Figure 7-2](ch07.xhtml#ch07fig2),
    the diagrams indicate a shared library loaded at the same addresses as those in
    [Figure 7-1](ch07.xhtml#ch07fig1) (that is, `0x10000000` and `0x20000000`). In
    both cases, the dollar sign used in the `jmp` instruction represents the current
    instruction pointer (`IP`), so `$ + 0xC74` tells the processor that it should
    jump to the instruction starting `0xC74` bytes ahead of the current position of
    the instruction pointer.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Relative addressing in shared-library images*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: There are various nuances to generating and using position-independent code,
    and you should become familiar with all of them before using them so you can choose
    the option that is most appropriate for your situation. For example, the GNU C
    compiler also supports a `-fpic` option (lowercase), which uses a slightly quicker
    but more limited mechanism to generate relocatable object code.^([13](footnote.xhtml#ch07fn13))
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixing the Jupiter PIC Problem*'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From what we now understand, one way to fix our linker error is to add the `-fPIC`
    option to the compiler command line for the source files that comprise the *libjupcommon.a*
    static library. [Listing 7-8](ch07.xhtml#ch07ex8) illustrates the changes required
    to the *common/Makefile.am* file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-8:* common/Makefile.am: *Changes required for generation of PIC
    objects in a static library*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let’s retry the build:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a shared library built properly with position-independent code,
    as per system requirements. However, we still have that strange warning at ➊ about
    the portability of linking a Libtool library against a static library. The problem
    here is not in *what* we’re doing but rather *how* we’re doing it. You see, the
    concept of PIC does not apply to all hardware architectures. Some CPUs don’t support
    any form of absolute addressing in their instruction sets. As a result, native
    compilers for these platforms don’t support a `-fPIC` option—it has no meaning
    for them. Unknown options may be silently ignored, but in most cases, compilers
    stop on unknown options with an error message.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: If we tried, for example, to compile this code on an IBM RS/6000 system using
    the native IBM compiler, it would hiccup when it came to the `-fPIC` option on
    the linker command line. This is because it doesn’t make sense to support such
    an option on a system where all code is generated as position-independent code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: One way we could get around this problem would be to make the `-fPIC` option
    conditional in *Makefile.am*, based on the target system and the tools we’re using.
    But that’s exactly the sort of problem that Libtool was designed to address! We’d
    have to account for all the different Libtool target system types and tool sets
    in order to handle the entire set of conditions that Libtool already handles.
    Additionally, some systems and compilers may require different command line options
    to accomplish the same goal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The way around this portability problem, then, is to let Libtool generate the
    static library, as well. Libtool makes a distinction between static libraries
    that are installed as part of a developer package and static libraries that are
    only used internally within a project. It calls such internal static libraries
    *convenience* libraries, and whether or not a convenience library is generated
    depends on the prefix used with the `LTLIBRARIES` primary. If the `noinst` prefix
    is used, then Libtool assumes we want a convenience library, because there’s no
    point in generating a shared library that will never be installed. Thus, convenience
    libraries are always generated as non-installed static archives, which have no
    value unless they’re linked to other code within the project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The reason for distinguishing between convenience libraries and other forms
    of static libraries is that convenience libraries are always built, whereas installed
    static libraries are only built if the `--enable-static` option is specified on
    the `configure` command line—or, conversely, if the `--disable-static` option
    is *not* specified and the default library type has been set to `static`. The
    conversion from an older static library to a newer Libtool convenience library
    is simple enough—all we have to do is add `LT` to the primary name and remove
    the `-fPIC` option and the `CFLAGS` variable (since there were no other options
    being used in that variable). Note also that I’ve changed the library extension
    from *.a* to *.la*. Don’t forget to change the prefix on the `SOURCES` variable
    to reflect the new name of the library—*libjupcommon.la*. These changes are highlighted
    in [Listings 7-9](ch07.xhtml#ch07ex9) and [7-10](ch07.xhtml#ch07ex10).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 7.1
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-9:* common/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-10:* libjup/Makefile.am: *Changing from a static library to a Libtool
    static library*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we try to build, here’s what we get:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see at ➋ that the common library is now built as a static convenience
    library because the `ar` utility builds *libjupcommon.a*. Libtool also seems to
    be building files with new and different extensions—a closer look will reveal
    extensions such as *.la* and *.lo* (check the line at ➊). If you examine these
    files, you’ll find that they’re actually descriptive text files containing object
    and library metadata. [Listing 7-11](ch07.xhtml#ch07ex11) shows the partial contents
    of *common/libjupcommon.la*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-11:* common/libjupcommon.la: *Textual metadata found in a library
    archive* (.la ) *file*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The various fields in these files help the linker—or rather the `libtool` wrapper
    script—to determine certain options that the maintainer would otherwise have to
    remember and manually pass to the linker on the command line. For instance, the
    library’s shared and static names are documented at ➊ and ➋ here, as well as any
    library dependencies required by these libraries (at ➌).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*This is a convenience library, so the shared library name is empty*.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In this library, we can see that *libjupcommon.a* depends on the *pthreads*
    library. But, by using Libtool, we don’t have to pass a `-lpthread` option on
    the `libtool` command line because `libtool` can detect from the contents of this
    metadata file (specifically, the line at ➌) that the linker will need this option,
    and it passes the option for us.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Making these files human readable was a minor stroke of genius, as they can
    tell us a lot about Libtool libraries at a glance. These files are designed to
    be installed on an end user’s machine with their associated binaries, and, in
    fact, the `make install` rules that Automake generates for Libtool libraries do
    just this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distros today are leaning toward filtering out *.la* files from official
    builds of library projects—that is, they don’t install them into the */usr* directory
    structure because *.la* files are only useful during builds where packages are
    referencing Libtool libraries within a project directory structure. Since the
    distro provider has already pre-built everything for you and you won’t be building
    those packages yourself, they just take up space (albeit, not very much). When
    you link against a library (Libtool or otherwise) that’s installed on your system
    in the */usr* directory structure, you’re using one of the `AC_CHECK`/`SEARCH`
    macros to find the library and link against the *.a* or *.so* file directly, so
    the *.la* file isn’t used in that case either.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I outlined the basic rationale for shared libraries. As an
    exercise, we added a shared library to Jupiter that incorporates functionality
    from the convenience library we created earlier. We began with a more or less
    intuitive approach to incorporating a static library into a Libtool shared library,
    and in the process we discovered a more portable and correct way to do this using
    Libtool convenience libraries.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: As with the other packages in the Autotools toolchain, Libtool gives you a lot
    of functionality and flexibility. But as you’ve probably noticed, with this degree
    of functionality and flexibility comes a price—complexity. The size of Jupiter’s
    configuration script increased dramatically with the addition of Libtool, and
    the time required to compile and link our project increased accordingly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to continue our discussion of Libtool by looking
    at library-versioning issues and Libtool’s solution to the portability problems
    presented by manual dynamic runtime library management.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
