<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>10 NUMBERS AND MATH</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch10">
<span class="CN"><span aria-label=" Page 205. " epub:type="pagebreak" id="pg_205" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NUMBERS AND MATH</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">Throughout this book, I’ve been saying that FPGAs are good at performing mathematical computations quickly. I’ve also been saying that FPGAs are good at doing tasks in parallel, and that the combination of these two assets—fast math done in parallel—is one of their killer features. In low-level Verilog or VHDL code, however, working with numbers and math is full of pitfalls.</p>
<p class="TX">In this chapter, we’ll explore exactly how FPGAs manage mathematical calculations so you can avoid those pitfalls. To understand the details of how operations like addition, subtraction, multiplication, and division work, we also need to understand how to represent numbers, both positive and negative, with or without decimals, inside your FPGA. It’s time for a journey in the wonderful world of computer arithmetic.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-129"/><span aria-label=" Page 206. " epub:type="pagebreak" id="pg_206" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Numerical Data Types</samp></h2>
<p class="TNI1">There are many ways to represent numbers in Verilog or VHDL, as is true with all programming languages. For example, if you want to store only whole numbers, you can use an integer data type, but if you need to store fractional numbers, you’ll need a data type that can represent decimals. Choosing the right type for the data you’re trying to represent is critical in any programming language. If you assign data to the wrong type, you’ll either get compiler errors or, worse, a design that behaves strangely. For example, trying to assign a decimal number to an integer data type could truncate the fractional component, causing an unintended rounding operation.</p>
<p class="TX">Additionally, you don’t want to use more resources than necessary. For example, you could create every signal with a 64-bit-wide data type, but that’s clearly overkill if all you need is a counter that goes from 0 to 7. FPGAs provide even more granular control over data types than you get with most other programming languages. For example, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">uint8_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">uint16_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp> data types, which create data widths of 8, 16, and 32 bits, respectively, but there’s nothing in between. In Verilog and VHDL, by contrast, you can create a signal that’s 9 bits wide, 15 bits wide, 23 bits wide, or any other number. We’ll explore recommendations for sizing signals later in this chapter.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-130"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Representing Signed vs. Unsigned Values</samp></h3>
<p class="TNI1">When you’re working with numbers, you need to know if they’re positive or negative. Sometimes, such as if you’re counting clock cycles to keep track of time, you’ll know the values will all be positive. In this case, you can store the numbers using an <i>unsigned</i> data type; the sign (positive or negative) isn’t specified and is assumed to be positive. Other times, you’ll need to work with negative numbers: for example, when you’re reading temperature values, where the sign of the numbers might vary. In these cases you’ll need to use a <i>signed</i> data type, where the positive or negative sign is specified.</p>
<p class="TX">By default, signals in Verilog and VHDL are unsigned. For example, if we need a counter that counts from 0 to 7, we can declare a signal like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [2:0] counter;</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : std_logic_vector(2 downto 0);</samp> in VHDL. We’ve used code like this throughout the book. It will create a 3-bit register, and since it’s unsigned by default, the values on the register will all be interpreted as positive. If we want <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> to represent negative numbers as well as positive ones, we’d have to explicitly declare it to be signed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword. In Verilog we would write <samp class="SANS_TheSansMonoCd_W5Regular_11">reg signed [2:0] counter;</samp>, and in VHDL we would use <samp class="SANS_TheSansMonoCd_W5Regular_11">signal counter : signed(2 downto 0);</samp>.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>To access the signed keyword in VHDL, you need to use the numeric_std package, which you can do by adding the line use ieee.numeric_std.all; at the top of your file. You may see some code that uses the std_logic_arith package instead, but this isn’t an official IEEE-supported library and I don’t recommend using it. It’s easier to make mistakes with this package than with numeric_std.</i></p>
<p class="TX"><span aria-label=" Page 207. " epub:type="pagebreak" id="pg_207" role="doc-pagebreak"/>Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword explicitly tells the tools that this 3-bit-wide register can represent negative and positive values. But which values can we actually represent with it? <a href="#tab10-1">Table 10-1</a> compares the values represented by a 3-bit unsigned register and a 3-bit signed register. (We’ll discuss how to determine the signed values in the next section.)</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab10-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">3-Bit Unsigned vs. Signed Decimal Values</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned decimal value</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signed decimal value</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–4</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–1</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Notice that when a register is declared as signed, we lose some numbers on the positive end of the range (4, 5, 6, and 7 in this case) but gain some numbers on the negative end (–1, –2, –3, and –4). The range of numbers that can be represented by an unsigned register is 0 to 2<i><sup>N</sup></i> <span class="symbol">−</span> 1, where <i>N</i> is the number of bits available. For this 3-bit register, we can represent from 0 to 2<sup>3</sup> <span class="symbol">−</span> 1 = 7 if the register is unsigned. On the other hand, the range of numbers that can be represented by a signed register is –2<sup>(</sup><i><sup>N</sup></i><sup>–1)</sup> to 2<sup>(</sup><i><sup>N</sup></i><sup>–1)</sup> <span class="symbol">−</span> 1. In this case, that gives us –2<sup>(3–1)</sup> to 2<sup>(3–1)</sup> <span class="symbol">−</span> 1, or = –4 to 3. The data is still 3 bits of binary data, but <i>what that binary data represents</i> is different.</p>
<p class="TX">Another feature to notice in <a href="#tab10-1">Table 10-1</a> is that the values that are negative all have a 1 in the most significant bit position. In fact, the most significant bit in a signed number is the <i>sign bit</i>, which indicates whether the number being represented is positive or negative. For signed binary numbers, a 0 in the sign bit tells you that the number is positive, while a 1 in the sign bit tells you that the number is negative.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-131"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Taking the Two’s Complement</samp></h3>
<p class="TNI1">How do you know what decimal value a negatively signed binary number is supposed to represent? You take its <i>two’s complement</i>, a mathematical operation where you invert the number’s bits and then add 1. For example, take the binary number <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>. If this were an unsigned number, we’d interpret it as 5 in decimal, but if it’s a signed number, the 1 in the sign bit tells us that the represented value should be negative, so we have to take the two’s complement. First, we invert <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, which gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>. Then we add 1, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>, which is 3 in decimal. Finally, we apply the negative sign to get –3. Look back at <a href="#tab10-1">Table 10-1</a> and you’ll see that’s what we have in the row for <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.</p>
<p class="NOTE"><span aria-label=" Page 208. " epub:type="pagebreak" id="pg_208" role="doc-pagebreak"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>An alternative to the invert-and-add-one method is to start at the right-most (least significant) bit, move left until you get to the first 1, then invert all the remaining bits to the left of that 1. For example, 100010 100 becomes 011101 100. The three bolded bits, up to and including the first 1 from the right, remain the same, while the others are inverted. In decimal, 011101100 is 236; applying the negative sign, we know that 100010100 represents –236. This method avoids the need for addition and can be simpler for long numbers.</i></p>
<p class="TX">We can also take a two’s complement to go in the other direction, converting a negative decimal number into its signed binary representation. For example, how would we represent –1 in binary using 3 bits? First, strip away the negative sign to get 1, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> in binary. Then invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>, and add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>. Again, check <a href="#tab10-1">Table 10-1</a> and you’ll see that this is the correct result.</p>
<p class="TX">Taking the two’s complement is a useful trick us humans can use to better understand how to interpret signed numbers, but this invert-and-add-one logic <i>isn’t something an FPGA actually does</i> when working with negative values. The data is binary 1s and 0s whether a number is signed or unsigned. It’s just the <i>representation</i> of those 1s and 0s that makes a difference. When you have a 3-bit unsigned signal set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, that represents the decimal value 5. When you have a 3-bit signed signal set to <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, that represents the decimal value –3. The FPGA doesn’t have to invert and add bits anywhere to know that. It just needs to know that the signal is of a signed data type. This is an important point and will become clearer as we explore mathematical operations in binary.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-132"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sizing Signals Appropriately</samp></h3>
<p class="TNI1">When you write Verilog or VHDL code working with signed and unsigned data types, you must ensure that you properly size the signals you’re creating. If you try to store too large of a number in too small of a signal, you’ll get data loss. As we just discussed, for example, the value of a 3-bit unsigned counter maxes out at 7. If you try to increment it again from 7, it won’t go to 8; it’ll actually go back to 0. This is sometimes called <i>wraparound</i>, and if you’re not expecting it, you’ll end up losing count. As you’ll see later in the chapter, ensuring your signals are large enough to handle your data is particularly important when the signals are for holding the results of mathematical operations.</p>
<p class="TX">To avoid data loss you might be tempted to make all your signals larger than they need to be, but there’s a downside to this, too: you’ll end up using more of your FPGA’s precious resources than are needed. This may be less of a problem than you think, though. If the synthesis tools are smart enough, they might detect that your possible range of values is smaller than the signal you’ve created and remove the upper bits that are unused to conserve resources. If the tools did this to our <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> register, for example, we’d see a warning saying something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pruning register counter</samp> in the synthesis report. Getting a warning like this isn’t usually a problem, but it might indicate code you could revisit and size differently.</p>
<p class="TX"><span aria-label=" Page 209. " epub:type="pagebreak" id="pg_209" role="doc-pagebreak"/>As a rule of thumb, you should aim to size your signals to the values you expect them to store, but know that making them too large is a much better solution than making them too small. Of course, you have to remember that the maximum value you can represent with a given number of bits varies depending on whether the values are signed or unsigned. For comparison, <a href="#tab10-2">Table 10-2</a> summarizes the ranges of possible unsigned and signed values you can represent using between 2 and 8 bits.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab10-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">N-bit Sizing for Unsigned and Signed Data Types</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Width</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Min integer</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Min binary</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Max integer</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Max binary</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">15</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–8</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">31</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–16</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">15</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">63</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">111111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–32</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">31</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0000000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">127</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1111111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–64</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1000000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">63</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0111111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">8</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">255</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">8</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–128</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">127</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Starting at a width of 2 bits, we can represent the numbers 0 to 3 unsigned, or –2 to 1 signed. At a width of 8 bits, we can represent 0 to 255 unsigned, or –128 to 127 signed.</p>
<p class="TX">One way to bypass the sizing dilemma is to size your signals dynamically, instead of setting them to a fixed width. We’ve seen some examples of this throughout the book. For instance, if you need to index into something 32 words deep but that depth could change in the future, you could write something like <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [$clog2(DEPTH)-1:0] index;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">reg [4:0] index;</samp> in Verilog, or <samp class="SANS_TheSansMonoCd_W5Regular_11">signal index : integer range 0 to DEPTH-1;</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">signal index : std_logic_vector(4 downto 0);</samp> in VHDL. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> is a parameter/generic that can be changed on the fly. Using it will generate a signal of the exact bit width you need, wide enough to index into all possible values from <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>, with no extra headroom. In this case, you would set <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>, but if your indexing requirement were to grow to some larger value (say 1,024), the code won’t break; all you’ll have to do is change <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>. By contrast, if you arbitrarily say that <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> will be fixed to 8 bits wide (which has a maximum value of 255, as you can see in <a href="#tab10-2">Table 10-2</a>), then your code might break in the future if your requirements grow beyond that range.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-133"/><span aria-label=" Page 210. " epub:type="pagebreak" id="pg_210" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between Types in VHDL</samp></h3>
<p class="TNI1">VHDL has many numeric data types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, where binary values are interpreted as positive or negative decimal numbers; <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp>, where you can type numbers directly into the code; and <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>, where by default binary values aren’t interpreted as anything other than binary values. Because VHDL is strongly typed, you’ll often need to convert between these different data types when you’re working with numbers. Before we do any math, let’s look at some examples of how to implement common VHDL type conversions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> package (not the unofficial <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_arith</samp>).</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Verilog users don’t need to worry about performing these conversions, since Verilog is loosely typed. VHDL users should consult this section as needed for reference.</i></p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Unsigned or Signed to Integer</samp></h4>
<p class="TNI1">This example illustrates how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> type to the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type. For simplicity, we’re assuming the signals are all 4 bits wide, but the conversion will work for any bit width:</p>
<pre><code>signal in1  : unsigned(3 downto 0);
signal in2  : signed(3 downto 0);
signal out1 : integer;
signal out2 : integer;
out1 &lt;= to_integer(in1);
out2 &lt;= to_integer(in2);</code></pre>
<p class="TX">For these conversions, all we need to do is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> package. We already know the width and the sign of the input, so the output will be sized automatically. This works whether the input is unsigned (as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in1</samp>) or signed (as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in2</samp>).</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">From Integer to Unsigned, Signed, or std_logic_vector</samp></h4>
<p class="TNI1">This example shows how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type to one of the other types. Again, we’re assuming 4-bit signals:</p>
<pre><code>signal in1  : integer;
signal out1 : unsigned(3 downto 0);
signal out2 : signed(3 downto 0);
signal out3 : std_logic_vector(3 downto 0);
signal out4 : std_logic_vector(3 downto 0);
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> out1 &lt;= to_unsigned(in1, out1'length);
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> out2 &lt;= to_signed(in1, out2'length);
-- Positive integers:
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> out3 &lt;= std_logic_vector(to_unsigned(in1, out3'length));
-- Negative integers:
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> out4 &lt;= std_logic_vector(to_signed(in1, out4'length));</code></pre>
<p class="TX"><span aria-label=" Page 211. " epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/>Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_unsigned()</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">to_signed()</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span> functions from <samp class="SANS_TheSansMonoCd_W5Regular_11">numeric_std</samp> to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> type. In addition to the value to be converted, these functions require the width of the output signal as an argument. Rather than entering the width manually, we get it by applying <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp>, a VHDL attribute, to the output signal. This keeps the code flexible; if the width changes, the conversion code doesn’t have to.</p>
<p class="TX">To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>, we have to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> if the integer is positive <span aria-label="annotation3" class="CodeAnnotation">❸</span>, or to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> if the integer is negative <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Then, once we have an unsigned or signed value of the proper width, we cast it using <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector()</samp>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">From std_logic_vector to Unsigned, Signed, or Integer</samp></h4>
<p class="TNI1">Finally, here’s how to convert from the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> type to one of the other numeric types:</p>
<pre><code>signal in1  : std_logic_vector(3 downto 0);
signal out1 : unsigned(3 downto 0);
signal out2 : signed(3 downto 0);
signal out3 : integer;
signal out4 : integer;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> out1 &lt;= unsigned(in1);
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> out2 &lt;= signed(in1);
-- Demonstrates the unsigned case:
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> out3 &lt;= to_integer(unsigned(in1));
-- Demonstrates the signed case:
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> out4 &lt;= to_integer(signed(in1));</code></pre>
<p class="TX">To get to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, we use a simple cast. However, VHDL needs to know if the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> is unsigned or signed before converting to the <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> type. We perform the appropriate cast using <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned()</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span> or <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_integer()</samp> function to do the final conversion.</p>
</section>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h-134"/><samp class="SANS_Futura_Std_Bold_B_11">Performing Mathematical Operations</samp></h2>
<p class="TNI1">Now we’ll consider how basic addition, subtraction, multiplication, and division operations are performed within an FPGA, and how to implement them in Verilog and VHDL. I’ll suggest some rules that, if followed, will help you avoid many of the commit pitfalls when working with binary math. The best way to explore these concepts is through examples. To that end, we’ll create a large testbench that you can run in a simulator tool like EDA Playground. The testbench will execute dozens of different math equations, illustrating how binary math operations should be carried out and how they can go awry.</p>
<p class="TX">In general, when working with numbers and manipulating them with algebraic operations, testbenches are a very powerful tool. Hidden math issues in your code can manifest themselves in strange ways. Testbenches allow you to stress your design by running through a large range of possible <span aria-label=" Page 212. " epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>inputs, to see how the code works. I find it valuable to inject data into my testbenches that stress the math operations over a wide range of values, including minimum and maximum inputs. This helps ensure a design is robust.</p>
<p class="TX">Before we do any math, let’s set up our testbench, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp>, by declaring all the necessary inputs and outputs, as well as some helper functions in the VHDL version. This setup code provides the skeleton for the examples that follow throughout the rest of the chapter. The code for each example will go where the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is shown in the setup code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Math_Examples();
  reg unsigned [3:0] i1_u4, i2_u4, o_u4;
  reg signed   [3:0] i1_s4, i2_s4, o_s4;
  reg unsigned [4:0] o_u5, i2_u5;
  reg signed   [4:0] o_s5, i1_s5, i2_s5;
  reg unsigned [5:0] o_u6;
  reg unsigned [7:0] o_u8, i_u8;
  reg signed   [7:0] o_s8;
  initial begin
     <var>--snip--</var>
     $finish();
  end
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.env.finish;
entity Math_Examples is
end entity Math_Examples;
architecture test of Math_Examples is
  -- Takes input unsigned, returns string for printing
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> function str(val : in unsigned) return string is
  begin
    return to_string(to_integer(val));
  end function str;
  -- Takes input signed, returns string for printing
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> function str(val : in signed) return string is
  begin
    return to_string(to_integer(val));
  end function str;<span aria-label=" Page 213. " epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>
  -- Takes input real, returns string for printing
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> function str(val : in real) return string is
  begin
    return to_string(val, "%2.3f");
  end function str;
begin
  process is
    variable i1_u4, i2_u4, o_u4 : unsigned(3 downto 0);
    variable i1_u5, i2_u5, o_u5 : unsigned(4 downto 0);
    variable i1_s4, i2_s4, o_s4 : signed(3 downto 0);
    variable i1_s5, i2_s5, o_s5 : signed(4 downto 0);
    variable i1_u6, i2_u6, o_u6 : unsigned(5 downto 0);
    variable i1_u8, i2_u8, o_u8 : unsigned(7 downto 0);
    variable i1_s8, i2_s8, o_s8 : signed(7 downto 0);
    variable real1, real2, real3 : real;
  begin
    <var>--snip--</var>
    wait for 1 ns;
    finish;
    end process;
end test;</code></pre>
<p class="TX">The skeleton for this testbench sets up a single <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> (in VHDL) block that runs once through. We’ll fill in this block with examples later in the chapter. Notice that we’ve declared a number of signals using <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp> (in Verilog) and <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp> (in VHDL). This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp> keyword in VHDL: we need it so we can write blocking assignment statements in the testbench. See <span class="Xref">“Blocking vs. Non-Blocking Assignments” on page 214</span> for more information.</p>
<p class="TX">The examples in this chapter use a common naming scheme to quickly identify the data types and widths of the signals so you don’t have to keep looking back at the signal definitions. The prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> indicates an input to a math equation, while <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp> indicates an output, the result of the math equation. In addition, we have the suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">_u</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">_s</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> represents unsigned, <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> represents signed, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> represents the bit width of the signal. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_s4</samp> is a 4-bit-wide signed output. Establishing a scheme like this that makes it easier to remember data types and widths can be very helpful in your code, especially if there are many values in a single file.</p>
<p class="TX">Notice in the VHDL that we declare a custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">str()</samp>, to help convert the outputs of our equations to strings for printing. This will save us a lot of typing in the examples later on. We actually define the function in three different ways, depending on the data type involved—because VHDL is strongly typed, we need to define all the supported function inputs so that the compiler knows which one to use. The first definition <span aria-label="annotation1" class="CodeAnnotation">❶</span> converts an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> value, the second <span aria-label="annotation2" class="CodeAnnotation">❷</span> converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> value, and the third <span aria-label="annotation3" class="CodeAnnotation">❸</span> converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp> value. This is an example of function <i>overloading</i>, <span aria-label=" Page 214. " epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/>a programming technique where a single function can have multiple implementations. Overloading is a somewhat advanced VHDL concept, but it’s very useful. You can even overload normal VHDL operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> with any implementation that you need, though I don’t recommend doing so.</p>
<p class="TX">Now that we have our testbench set up, we’re ready to start exploring math operations.</p>
<aside aria-labelledby="box1" class="box">
<h3 class="BoxTitle" id="box1"><samp class="SANS_Dogma_OT_Bold_B_11">BLOCKING VS. NON-BLOCKING ASSIGNMENTS</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Up to this point, we have been assigning all signals within our</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> <samp class="SANS_Futura_Std_Book_11">blocks with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp><samp class="SANS_Futura_Std_Book_11">, which is a non-blocking assignment. As we discussed in <a href="chapter4.xhtml">Chapter 4</a>, this means that these statements execute at the same instant in time. Non-blocking assignments are what allow us to write several statements one after the other that will all execute on the same clock edge. These assignments are key to FPGA design; they are how we can write operations that occur in parallel, instead of serially. Remember, flip-flops that share the same clock are all updated on the same clock edge, all at once.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">There’s also such a thing as a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">blocking assignment</samp><samp class="SANS_Futura_Std_Book_11">, however, written with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_Futura_Std_Book_11">in Verilog or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_Futura_Std_Book_11">for VHDL variables, where the next line of code won’t execute until the current line is finished running. Blocking assignments are probably familiar if you have experience with conventional programming languages. We’re used to the idea that when we write two lines of code in a language like C or Python, the second line won’t execute until the first line is done. In FPGA design, however, non-blocking assignments are the norm. They’re the preferred way to generate sequential logic (flip-flops). When in doubt, stick to non-blocking assignments in your</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> <samp class="SANS_Futura_Std_Book_11">blocks.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">An exception is if you’re writing a testbench, where blocking assignments are useful when data needs to be updated at an exact point during the simulation, especially for printing. To see why, consider this Verilog testbench code:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">int test = 0;</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">initial begin</samp>
  <samp class="SANS_TheSansMonoCd_W5Regular_11">test &lt;= 7;</samp>
  <samp class="SANS_TheSansMonoCd_W5Regular_11">$display("value is %d\n", test);</samp></code></pre>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">We change the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_Futura_Std_Book_11">from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp><samp class="SANS_Futura_Std_Book_11">, then use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">$display</samp> <samp class="SANS_Futura_Std_Book_11">to print it out. But what value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_Futura_Std_Book_11">will be printed to the console? It’s actually going to be</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">, not</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp><samp class="SANS_Futura_Std_Book_11">. The line</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7;</samp> <samp class="SANS_Futura_Std_Book_11">uses a non-blocking assignment, so it happens at the same time as the printing. Therefore, the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_Futura_Std_Book_11">won’t have updated yet when</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">$display</samp> <samp class="SANS_Futura_Std_Book_11">reads that value for printing. We can fix this issue by using a blocking assignment instead:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">int test = 0;</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">initial begin</samp>
  <samp class="SANS_TheSansMonoCd_W5Regular_11">test = 7;</samp>
  <samp class="SANS_TheSansMonoCd_W5Regular_11">$display("value is %d\n", test);</samp></code></pre>
<p class="BoxBody"><span aria-label=" Page 215. " epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">Thanks to the blocking assignment (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7;</samp><samp class="SANS_Futura_Std_Book_11">), the simulation will wait to execute the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">$display</samp> <samp class="SANS_Futura_Std_Book_11">line until the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_Futura_Std_Book_11">has been updated. The value will now print out as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp><samp class="SANS_Futura_Std_Book_11">, which is probably what was intended.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Another way you can fix this issue is to add a small delay between the non-blocking assignment and the next line, like this:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">test &lt;= 7;</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">#1;</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">$display("value is %d\n", test);</samp></code></pre>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The short delay (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#1</samp><samp class="SANS_Futura_Std_Book_11">) provides enough simulation time for the non- blocking assignment to complete before printing, so the value will be displayed as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In the testbench examples throughout this chapter, we’ll be updating and then printing out a lot of values. Rather than add a bunch of small delays throughout the testbench, we’ll use blocking assignments to ensure the values are updated before printing. Keep in mind that (as mentioned previously) to use the blocking assignment in VHDL, we need to declare values using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">variable</samp> <samp class="SANS_Futura_Std_Book_11">keyword rather than the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp> <samp class="SANS_Futura_Std_Book_11">keyword.</samp></p>
</aside>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-135"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition</samp></h3>
<p class="TNI1">Adding binary data works the same way you were taught to add numbers in elementary school: you add them one digit at a time, working from right to left. For example, here’s how to add the binary numbers <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>:</p>
<pre><code><b>  </b>0010
+ 1000
------
 01010</code></pre>
<p class="TX">To arrive at the result, you simply go digit by digit, starting with the least significant bit, adding the digits in that column together. If you get 1 + 1 = 10 in a column, then you write 0 at the bottom of the column and carry the 1 to the next digit to the left.</p>
<p class="TX">Notice that the result of adding two 4-bit numbers together is 5 bits wide. This is our first rule of FPGA math:</p>
<p class="EX"><b>Rule #1</b>  When adding, the result should be at least 1 bit bigger than the biggest input.</p>
<p class="BodyContinued">The extra bit is needed in the case where adding the most significant bit requires a carry operation. Without the extra bit, we’d be truncating the result, which could produce an incorrect answer. In our first example, <span aria-label=" Page 216. " epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>dropping the most significant bit wouldn’t make a difference, but consider this example where having that extra bit is critical:</p>
<pre><code>  1001
+ 1011
------
 10100</code></pre>
<p class="TX">Here, the most significant bit of the result is a 1. Had we just assumed that the output width would be the same as the input widths, then we would have dropped this bit and gotten the wrong answer. Our result would have been <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">10100</samp>.</p>
<p class="TX">Perhaps you’ve noticed that I haven’t explicitly said what these binary numbers represent yet, and whether they’re positive or negative. For example, is <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> unsigned and equal to 9, or is it signed and equal to the two’s complement of 9, which is –7 (invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0110</samp>, then add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>)? The reason I haven’t specified this is because the representation of the binary data ultimately doesn’t affect how the math is performed, as long as the inputs and outputs are sized appropriately. Whether <samp class="SANS_TheSansMonoCd_W5Regular_11">1001</samp> represents +9 or –7, the addition operation will be performed the same way. Of course, we care if the result is positive or negative, but the implementation of the addition doesn’t change depending on whether the data types are signed or unsigned. Let’s revisit our first example and consider what happens when we assign it various signed and unsigned combinations. Here’s the example again:</p>
<pre><code>  0010
+ 1000
------
 01010</code></pre>
<p class="TX">If both addition inputs are declared as unsigned types, then we have 2 + 8 = 10. Pretty simple. If both addition inputs are declared as signed, then the first input is still 2, but the second input is –8. (Invert the bits to get <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>, add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, and apply the negative sign to get –8.) So now we have 2 + –8, which should equal –6, but the result, <samp class="SANS_TheSansMonoCd_W5Regular_11">01010</samp>, is still 10. Something isn’t right here!</p>
<p class="TX">The problem is that we’re not performing sign extension on the inputs. <i>Sign extension</i> is the operation of increasing the number of bits of a binary number while preserving the number’s sign and value. This operation is required when the inputs are signed. Without it, we’ll get an incorrect answer, as you’ve just seen. To perform sign extension on a signed value, simply replicate the most significant bit. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0010</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">00010</samp>. Let’s try that math again, this time first applying sign extension to our inputs:</p>
<pre><code><b>  </b>00010
+ 11000
-------
  11010</code></pre>
<p class="TX"><span aria-label=" Page 217. " epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>Our inputs are still 2 and –8. (For the latter, invert the bits of <samp class="SANS_TheSansMonoCd_W5Regular_11">11000</samp> to get <samp class="SANS_TheSansMonoCd_W5Regular_11">00111</samp>, add 1 to get <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>, and apply the negative sign to get –8.) The answer, <samp class="SANS_TheSansMonoCd_W5Regular_11">11010</samp>, is the signed equivalent of –6, which is exactly what we want. Sign extension was the critical step to ensure we got the expected answer.</p>
<p class="TX">Sign extension is useful for unsigned values, too. In fact, since VHDL is strongly typed, the inputs and outputs to an addition operation must all have exactly the same width. You can’t, for example, add two 4-bit inputs to produce a 5-bit output; everything must be 5 bits. That means we should revisit Rule #1 and add a small modification:</p>
<p class="EX"><b>Rule #1 (modification #1)</b>  When adding, the result should be at least 1 bit bigger than the biggest input, <i>before sign extension</i>. Once sign extension is applied, the input and output widths should match exactly.</p>
<p class="TX">For unsigned values, sign extension simply means adding a 0 as the new most significant bit. For example, unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">01000</samp>. The good news for those of you using Verilog is that the code performs sign extension automatically when you’re adding numbers. If you’re using VHDL, however, you’ll need to sign-extend your inputs manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp> function, as you’ll see in the coming examples. Both approaches have their pros and cons. Verilog is easier if you know what you’re doing, as there’s less to worry about, but it also leaves more room for mistakes (for example, trying to store data in too small a signal). VHDL’s extra steps can be more confusing for beginners, and it generates cryptic errors when the rules aren’t followed. On the other hand, VHDL ensures that you’ve matched widths and types every step along the way, so there’s less room for error in the end.</p>
<p class="TX">Let’s summarize what we’ve learned with a few code examples. Add this code to your testbench where you saw the <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> earlier:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // Unsigned + Unsigned = Unsigned (Rule #1 violation)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u4  = i1_u4 + i2_u4;
   $display("Ex01: %2d + %2d = %3d", i1_u4, i2_u4, o_u4);
   // Signed + Signed = Signed (Rule #1 violation)
   i1_s4 = 4'b1001; // dec -7
   i2_s4 = 4'b1011; // dec -5
   o_s4<b>  </b>= i1_s4 + i2_s4;
   $display("Ex02: %2d + %2d = %3d", i1_s4, i2_s4, o_s4);
   // Unsigned + Unsigned = Unsigned (Rule #1 fix)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u5  = i1_u4 + i2_u4;
   $display("Ex03: %2d + %2d = %3d", i1_u4, i2_u4, o_u5);
   // Signed + Signed = Signed (Rule #1 fix)
   i1_s4 = 4'b1001; // dec -7
   i2_s4 = 4'b1011; // dec -5
   o_s5  = i1_s4 + i2_s4;
   $display("Ex04: %2d + %2d = %3d", i1_s4, i2_s4, o_s5);</code></pre>
<p class="Label"><span aria-label=" Page 218. " epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- Unsigned + Unsigned = Unsigned (Rule #1 violation)
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u4  := i1_u4 + i2_u4;
   report "Ex01: " &amp; str(i1_u4) &amp; " + " &amp; str(i2_u4) &amp; " = " &amp; str(o_u4);
   -- Signed + Signed = Signed (Rule #1 violation)
   i1_s4 := "1001"; -- dec -7
   i2_s4 := "1011"; -- dec -5
   o_s4  := i1_s4 + i2_s4;
   report "Ex02: " &amp; str(i1_s4) &amp; " + " &amp; str(i2_s4) &amp; " = " &amp; str(o_s4);
   -- Unsigned + Unsigned = Unsigned (Rule #1 fix)
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   <span aria-label="annotation1" class="CodeAnnotationHang">❶</span> i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
   report "Ex03: " &amp; str(i1_u5) &amp; " + " &amp; str(i2_u5) &amp; " = " &amp; str(o_u5);
   -- Signed + Signed = Signed (Rule #1 Fix)
   i1_s4 := "1001"; -- dec -7
   i2_s4 := "1011"; -- dec -5
   i1_s5 := resize(i1_s4, i1_s5'length);
   i2_s5 := resize(i2_s4, i2_s5'length);
   o_s5  := i1_s5 + i2_s5;
   report "Ex04: " &amp; str(i1_s5) &amp; " + " &amp; str(i2_s5) &amp; " = " &amp; str(o_s5);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex01:  9 + 11 =   4
# Ex02: -7 + -5 =   4
# Ex03:  9 + 11 =  20
# Ex04: -7 + -5 = -12</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex01: 9 + 11 = 4
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex02: -7 + -5 = 4
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex03: 9 + 11 = 20
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex04: -7 + -5 = -12
#    Time: 0 ns  Iteration: 0   Instance: /math_examples</code></pre>
<p class="TX">First, we have two situations (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>) where Rule #1 isn’t followed. We’re using 4-bit inputs and storing the result in a 4-bit output, and we’re not performing any sign extension. In both of these examples, we get the wrong answer. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex01</samp>, we add two unsigned numbers, 9 and 11, but get 4 as a result. The problem here is that we’re dropping the most significant bit, which would be worth 16. (Indeed, 4 + 16 = 20, which is the answer we <span aria-label=" Page 219. " epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/>should be getting.) In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex02</samp>, we add two signed numbers representing negative values, and again we get the wrong answer.</p>
<p class="TX">The fix is to store the result in a 5-bit output, which we do in both <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex03</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex04</samp>. We’ve satisfied Rule #1, so the math works correctly. Notice that in the Verilog version, the sign extension happens automatically: we can simply assign 4-bit inputs to a 5-bit output, for example by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">o_u5</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i2_u4;</samp>. In VHDL, however, we must explicitly match input and output widths, while preserving the sign and value of each input. To do this, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">resize()</samp> function <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We use the VHDL tick attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">'length</samp> to reference the length of the output signal, as we did when we were performing type conversions. Again, this is more flexible than hardcoding the desired width by writing something like <samp class="SANS_TheSansMonoCd_W5Regular_11">resize(i1_u4, 5)</samp>.</p>
<p class="TX">Another tip for performing successful addition operations is to never mix signed and unsigned values. Your inputs and outputs should be of the same type; otherwise you might get an incorrect answer. This brings us to our second rule of FPGA math:</p>
<p class="EX"><b>Rule #2</b>  Match types among inputs and outputs.</p>
<p class="TX">With VHDL, it’s easy to follow Rule #2 because it will throw an error if you try to do a math operation where one input is signed and the other is unsigned. For example, say you write this in your testbench to try to add a 4-bit unsigned value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i1_u4</samp>) to a 4-bit signed value (<samp class="SANS_TheSansMonoCd_W5Regular_11">i2_s4</samp>):</p>
<pre><code><b>  </b>o_u4 := i1_u4 + i2_s4;</code></pre>
<p class="TX">You’ll end up with an error message indicating the tool doesn’t know how to interpret the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator given those inputs:</p>
<pre><code>** Error: testbench.vhd(49): (vcom-1581) No feasible entries for infix
operator '+'.</code></pre>
<p class="TX">Verilog is much more lenient. It will happily let you perform that math operation, and it won’t tell you that it’s actually treating your signed input as unsigned. This can very possibly result in the wrong answer, so be careful to always match your data types in Verilog.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-136"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subtraction</samp></h3>
<p class="TNI1">Subtraction isn’t that different from addition. After all, subtraction is just an addition operation where one of the inputs is negative. In this sense, we’ve been doing subtraction all along; 2 + –8 is the same as 2 – 8. Likewise, you can think of something like 5 – 3 as 5 + –3 and approach it like an addition operation.</p>
<p class="TX">There’s one thing to be careful with when subtracting two numbers, though: while you <i>could</i> use subtraction with unsigned inputs and outputs, I wouldn’t recommend it. What happens if the result should be negative? For <span aria-label=" Page 220. " epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/>example, 3 – 5 = –2, but if you try to store –2 into an unsigned data type, you won’t get the correct result. This brings us to our next rule:</p>
<p class="EX"><b>Rule #3</b>  When subtracting, use signed inputs and outputs.</p>
<p class="TX">Even if you don’t think the result of a subtraction will produce a negative number, you should use signed data types to be safe.</p>
<p class="TX">Because subtraction is really just negative addition, subtraction carries the same risk that you could truncate the result if the output isn’t sized appropriately. Again, it’s better to size up the output by 1 bit and to sign-extend your inputs before performing the math operation. This gives us a further modified Rule #1:</p>
<p class="EX"><b>Rule #1 (modification #2)</b>  When adding <i>or subtracting</i>, the result should be at least 1 bit bigger than the biggest input, before sign extension. Once sign extension is applied, the input and output widths should match exactly.</p>
<p class="TX">With those two rules in place, let’s extend our <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> testbench to take a look at some subtraction operations in Verilog and VHDL:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>    // Unsigned - Unsigned = Unsigned (bad)
    i1_u4 = 4'b1001; // dec 9
    i2_u4 = 4'b1011; // dec 11
    o_u5  = i1_u4 - i2_u4;
    $display("Ex05: %2d - %2d = %3d", i1_u4, i2_u4, o_u5);
    // Signed - Signed = Signed (fix)
    i1_u4 = 4'b1001; // dec 9
    i2_u4 = 4'b1011; // dec 11
 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> i1_s5 = i1_u4;
    i2_s5 = i2_u4;
    o_s5  = i1_s5 - i2_s5;
    $display("Ex06: %2d - %2d = %3d", i1_s5, i2_s5, o_s5);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>    -- Unsigned - Unsigned = Unsigned (bad)
    i1_u4 := "1001"; -- dec 9
    i2_u4 := "1011"; -- dec 11
    i1_u5 := resize(i1_u4, i1_u5'length);
    i2_u5 := resize(i2_u4, i2_u5'length);
    o_u5<b>  </b>:= i1_u5 - i2_u5;
    report "Ex05: " &amp; str(i1_u5) &amp; " - " &amp; str(i2_u5) &amp; " = " &amp; str(o_u5);
    -- Signed - Signed = Signed (fix)
    i1_u4 := "1001"; -- dec 9
    i2_u4 := "1011"; -- dec 11
 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> i1_s5 := signed(resize(i1_u4, i1_s5'length));
    i2_s5 := signed(resize(i2_u4, i2_s5'length));
    o_s5<b>  </b>:= i1_s5 - i2_s5;
    report "Ex06: " &amp; str(i1_s5) &amp; " - " &amp; str(i2_s5) &amp; " = " &amp; str(o_s5);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><span aria-label=" Page 221. " epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex05: 9 - 11 = 30
# Ex06: 9 - 11 = -2</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex05: 9 - 11 = 30
#    Time: 0 ns<b>  </b>Iteration: 0  Instance: /math_examples
# ** Note: Ex06: 9 - 11 = -2
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex05</samp>, we’re trying to calculate 9 – 11 but we get a result of 30, clearly the wrong answer. The problem here is that we’re using unsigned types for subtraction, which is a violation of Rule #3. We fix this in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex06</samp> by converting the input values from unsigned to signed data types. We also perform sign extension in the process, going from 4-bit inputs to 5-bit inputs. In the Verilog code, we handle the conversion by simply assigning the 4-bit unsigned signals to 5-bit signed signals <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Verilog takes care of the details automatically. VHDL makes us jump through a few more hoops. We first resize the input, which will sign-extend it, but the result of the resize operation is still an unsigned type, so we then explicitly cast it to a signed data type using <samp class="SANS_TheSansMonoCd_W5Regular_11">signed()</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This is safe to do because we’ve already resized the signal, so the most significant bit will be 0. Therefore, the value after converting to a signed type won’t be changed.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-137"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication</samp></h3>
<p class="TNI1">Multiplication also works similarly to addition; after all, a multiplication operation is just a series of repeated addition operations (4 <span class="symbol">×</span> 3 = 4 + 4 + 4). The first thing to consider when multiplying two inputs together is how to properly size the output bit width. This brings us to our next rule:</p>
<p class="EX"><b>Rule #4</b>  When multiplying, the output bit width must be at least the sum of the input bit widths (before sign extension).</p>
<p class="TX">This rule holds true for both signed and unsigned numbers. For example, say we’re trying to multiply the unsigned inputs <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> (equivalent to 7 <span class="symbol">×</span> 3). According to Rule #4, the output should be 3 + 2 = 5 bits wide. You can try out the multiplication yourself to confirm this, using the same technique you learned in school for multiplying multidigit numbers—multiply each digit individually and add the results together:</p>
<pre><code>   111
×   11
------
   111
+ 1110
------
 10101</code></pre>
<p class="TX">The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp> (equivalent to 21), is indeed 5 bits wide, which is what we expected. But what happens to this same multiplication if we treat our inputs and outputs as signed, rather than unsigned? In this case, we would <span aria-label=" Page 222. " epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/>have the equivalent of –1 <span class="symbol">×</span> –1 in decimal, which should produce a result of +1, but signed <samp class="SANS_TheSansMonoCd_W5Regular_11">10101</samp> in binary is equal to –11 in decimal. What’s wrong here?</p>
<p class="TX">The problem is that we didn’t sign-extend our inputs to match the width of our output (5 bits) before multiplying. If we do that, our inputs both become <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>, and the multiplication looks like this:</p>
<pre><code>      11111
 ×    11111
-----------
      11111
     111110
    1111100
   11111000
+ 111110000
-----------
<b>  </b>000000001</code></pre>
<p class="TX">Now we’re getting <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp>, or really <samp class="SANS_TheSansMonoCd_W5Regular_11">00001</samp> once we truncate the result to be 5 bits wide, which is +1 in decimal. Sign extension gives us the result we expect. Unlike with addition and subtraction, however, you don’t actually need to perform this sign extension manually when multiplying numbers using Verilog or VHDL. The tools will handle this automatically; you simply need to size the output signal correctly.</p>
<p class="TX">VHDL helps with this too: it won’t even let you compile the code if you disobey Rule #4 and fail to size the output of a multiplication correctly. With Verilog, you’ll need to be more careful. It won’t warn you if the output is the wrong size, and you could get an unexpected result. Let’s add some examples of this to our <samp class="SANS_TheSansMonoCd_W5Regular_11">Math_Examples</samp> testbench:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // Unsigned * Unsigned = Unsigned (Rule #4 violation)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u4  = i1_u4 * i2_u4;
   $display("Ex07: %2d * %2d = %3d", i1_u4, i2_u4, o_u4);
   // Signed * Signed = Signed (Rule #4 violation)
   i1_s4 = 4'b1000; // dec -8
   i2_s4 = 4'b0111; // dec 7
   o_s4  = i1_s4 * i2_s4;
   $display("Ex08: %2d * %2d = %3d", i1_s4, i2_s4, o_s4);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- Unsigned * Unsigned = Unsigned
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u4  := i1_u4 * i2_u4;
   report "Ex07: " &amp; str(i1_u4) &amp; " * " &amp; str(i2_u4) &amp; " = " &amp; str(o_u4);
   -- Signed * Signed = Signed
   i1_s4 := "1000"; -- dec -8
   i2_s4 := "0111"; -- dec 7<span aria-label=" Page 223. " epub:type="pagebreak" id="pg_223" role="doc-pagebreak"/>
   o_s4  := i1_s4 * i2_s4;
   report "Ex08: " &amp; str(i1_s4) &amp; " * " &amp; str(i2_s4) &amp; " = " &amp; str(o_s4);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex07:  9 * 11 =  3
# Ex08: -8 *  7 = -8</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>** Error (suppressible): testbench.vhd(89): (vcom-1272) Length of expected
is 4; length of actual is 8.</code></pre>
<p class="TX">Verilog allows us to perform the math operation despite the fact that we’re disobeying Rule #4 by multiplying 4 bits by 4 bits and storing the result in a 4-bit output. This produces incorrect results for both unsigned (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp>) and signed (<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp>) input values. VHDL, on the other hand, won’t even build this code; we get a nice descriptive error telling us that the tool is trying to assign an 8-bit-wide result to a 4-bit-wide variable, which isn’t permitted. Let’s add a few more examples to our testbench that fix these issues:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // Unsigned * Unsigned = Unsigned (Rule #4 fix)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u8  = i1_u4 * i2_u4;
   $display("Ex09: %2d * %2d = %3d", i1_u4, i2_u4, o_u8);
   // Signed * Signed = Signed (Rule #4 fix)
   i1_s4 = 4'b1000; // dec -8
   i2_s4 = 4'b0111; // dec 7
   o_s8  = i1_s4 * i2_s4;
   $display("Ex10: %2d * %2d = %3d", i1_s4, i2_s4, o_s8);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- Unsigned * Unsigned = Unsigned
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u8  := i1_u4 * i2_u4;
   report "Ex09: " &amp; str(i1_u4) &amp; " * " &amp; str(i2_u4) &amp; " = " &amp; str(o_u8);
   -- Signed * Signed = Signed
   i1_s4 := "1000"; -- dec -8
   i2_s4 := "0111"; -- dec 7
   o_s8  := i1_s4 * i2_s4;
   report "Ex10: " &amp; str(i1_s4) &amp; " * " &amp; str(i2_s4) &amp; " = " &amp; str(o_s8);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex09:  9 * 11 =  99
# Ex10: -8 *  7 = -56</code></pre>
<p class="Label"><span aria-label=" Page 224. " epub:type="pagebreak" id="pg_224" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex09: 9 * 11 = 99
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex10: -8 * 7 = -56
#    Time: 0 ns  Iteration: 0   Instance: /math_examples</code></pre>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex09</samp>, we correct the problem in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex07</samp> by storing the output of multiplying two unsigned 4-bit values into an 8-bit signal. Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex10</samp> corrects the issue from <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex08</samp> with signed values. Notice that we never have to sign-extend the inputs, in either Verilog or VHDL. The tools handle this automatically.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-138"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication by Powers of 2</samp></h3>
<p class="TNI1">There’s a trick that we can use when multiplying numbers by a power of 2 (for example, 2, 4, 8, 16, 32, …). Rather than instantiating a bunch of multiplication logic, we can simply instantiate a shift register and perform a shift left operation. Shifting left by <i>N</i> bits is equivalent to multiplying by 2<i><sup>N</sup></i>. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp> (3 in binary) shifted left 2 bits gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp> (12 in binary). It’s the same as calculating 3 <span class="symbol">×</span> 4, or 3 <span class="symbol">×</span> 2<sup>2</sup>. This trick works for both signed and unsigned numbers. Let’s try it out in our testbench:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   i_u8 = 3;
   o_u8 = i_u8 &lt;&lt; 1;
   $display("Ex11: %d * 2 = %d",  i_u8, o_u8);
   o_u8 = i_u8 &lt;&lt; 2;
   $display("Ex12: %d * 4 = %d",  i_u8, o_u8);
   o_u8 = i_u8 &lt;&lt; 4;
   $display("Ex13: %d * 16 = %d", i_u8, o_u8);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   i1_u8 := to_unsigned(3, i1_u8'length);
   o_u8 := shift_left(i1_u8, 1);
   report "Ex11: " &amp; str(i1_u8) &amp; " * 2 = "  &amp; str(o_u8);
   o_u8 := shift_left(i1_u8, 2);
   report "Ex12: " &amp; str(i1_u8) &amp; " * 4 = "  &amp; str(o_u8);
   o_u8 := shift_left(i1_u8, 4);
   report "Ex13: " &amp; str(i1_u8) &amp; " * 16 = " &amp; str(o_u8);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex11:  3 * 2 =  6
# Ex12:  3 * 4 = 12
# Ex13:  3 * 16 = 48</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex11: 3 * 2 = 6
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex12: 3 * 4 = 12
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex13: 3 * 16 = 48
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX"><span aria-label=" Page 225. " epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>We start with the decimal value 3 and shift left by 1, 2, and 4 bits to multiply it by 2, 4, and 16, respectively. In Verilog we perform the shift using the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</samp> operator, and in VHDL we use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_left()</samp>. Both take as an argument the number of bit positions to shift.</p>
<p class="TX">Shifting left is a simple and quick trick to save FPGA resources, but you don’t necessarily need to write it out explicitly. It’s likely that if you hardcode a multiplication by a power of 2, the synthesis tools will be smart enough to figure out that a left shift would take fewer resources.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-139"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Division</samp></h3>
<p class="TNI1">Unfortunately, division isn’t nearly as simple an operation as addition, subtraction, or multiplication. Division comes with all sorts of messy complications, like remainders and fractions. In general, it’s a good idea to avoid division inside your FPGA if you can. It’s a resource-intensive operation, especially if you need that operation to run at high clock rates.</p>
<p class="TX">I once worked on a project that needed to add a division operation to an FPGA in the field. The FPGA was a very old part, and it simply couldn’t fit it within the available resources. To accommodate the division operation we ended up having to upgrade to a higher-resource FPGA of the same family, which increased the cost of the hardware by over $1 million. I always think of that one extra operation as the million-dollar divide!</p>
<p class="TX">If you <i>must</i> divide numbers, there are a few ways to make the operation less resource-intensive. These include restricting yourself to dividing by powers of 2, using a precalculated table of answers, or breaking up the operation across multiple clock cycles.</p>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Powers of 2</samp></h4>
<p class="TNI1">My best suggestion for reducing the overhead of dividing numbers inside an FPGA is to make the divisor a power of 2. Similar to how multiplication by a power of 2 can be efficiently performed with a shift left operation, division by a power of 2 can be performed efficiently with a shift right operation. Shifting right by <i>N</i> bits is equivalent to dividing by 2<i><sup>N</sup></i>. Let’s look at a few examples of this:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   i_u8 = 128;
   o_u8 = i_u8 &gt;&gt; 1;
   $display("Ex14: %d / 2 = %d",  i_u8, o_u8);
   o_u8 = i_u8 &gt;&gt; 2;
   $display("Ex15: %d / 4 = %d",  i_u8, o_u8);
   o_u8 = i_u8 &gt;&gt; 4;
   $display("Ex16: %d / 16 = %d", i_u8, o_u8);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   i1_u8 := to_unsigned(128, i1_u8'length);
   o_u8 := shift_right(i1_u8, 1);
   report "Ex14: " &amp; str(i1_u8) &amp; " / 2 = "  &amp; str(o_u8);
   o_u8 := shift_right(i1_u8, 2);
   report "Ex15: " &amp; str(i1_u8) &amp; " / 4 = "  &amp; str(o_u8);
   o_u8 := shift_right(i1_u8, 4);
   report "Ex16: " &amp; str(i1_u8) &amp; " / 16 = " &amp; str(o_u8);</code></pre>
<p class="TX"><span aria-label=" Page 226. " epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/>Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex14: 128 / 2 = 64
# Ex15: 128 / 4 = 32
# Ex16: 128 / 16 =  8</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex14: 128 / 2 = 64
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex15: 128 / 4 = 32
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex16: 128 / 16 = 8
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ex14</samp> performs a shift right by 1, which in Verilog uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</samp> operator and in VHDL uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">shift_right()</samp> function. This accomplishes a single divide by 2. To divide by 4, shift right by 2 bit positions, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex15</samp>. Likewise, a right shift by 4 divides by 16, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex16</samp>.</p>
<p class="TX">What happens when we don’t have a number that’s cleanly divisible by the power of 2 serving as the divisor? In this case, shifting right effectively accomplishes a division that’s rounded down to the nearest integer. The next few examples illustrate how this works:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   i_u8 = 15;
   o_u8 = i_u8 &gt;&gt; 1;
   $display("Ex17: %d / 2 = %d", i_u8, o_u8);
   o_u8 = i_u8 &gt;&gt; 2;
   $display("Ex18: %d / 4 = %d", i_u8, o_u8);
   o_u8 = i_u8 &gt;&gt; 3;
   $display("Ex19: %d / 8 = %d", i_u8, o_u8);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   i1_u8 := to_unsigned(15, i1_u8'length);
   o_u8 := shift_right(i1_u8, 1);
   report "Ex17: " &amp; str(i1_u8) &amp; " / 2 = " &amp; str(o_u8);
   o_u8 := shift_right(i1_u8, 2);
   report "Ex18: " &amp; str(i1_u8) &amp; " / 4 = " &amp; str(o_u8);
   o_u8 := shift_right(i1_u8, 3);
   report "Ex19: " &amp; str(i1_u8) &amp; " / 8 = " &amp; str(o_u8);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex17: 15 / 2 =  7
# Ex18: 15 / 4 =  3
# Ex19: 15 / 8 =  1</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex17: 15 / 2 = 7
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex18: 15 / 4 = 3
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex19: 15 / 8 = 1</code></pre>
<p class="TX"><span aria-label=" Page 227. " epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex17</samp>, we try to perform 15 / 2. This should give us 7.5, but we have no way to represent the .5 part, so we end up rounding down to 7 instead. Thinking of this as a shift right, we went from <samp class="SANS_TheSansMonoCd_W5Regular_11">00001111</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">00000111</samp>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex18</samp>, we try to take 15 / 4, which should be 3.75, but we drop the decimal places and just get 3. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex19</samp> we get 15 / 8 = 1. This rounding might cause a problem if you’re not expecting it, so be aware that this can happen when performing shift right operations.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using a Precalculated Table</samp></h4>
<p class="TNI1">Another option for dividing two numbers is to precalculate the result for all possible input combinations. For example, if we’re trying to divide any number 1 through 7 by any other number 1 through 7, we could create something like <a href="#tab10-3">Table 10-3</a> inside the FPGA.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab10-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Precalculated Table for Full Range of Division Inputs</samp></p>
</caption>
<thead>
<tr class="table">
<td class="table TCH"/>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">4</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">5</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">6</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">7</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.50</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.33</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.25</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.20</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.17</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.14</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.67</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.40</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.33</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.29</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.75</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.60</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.43</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.33</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.80</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.67</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.57</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.67</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.25</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.83</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.71</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.20</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.86</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">7</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7.00</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3.50</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.33</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.75</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.40</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.17</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">For this example, let’s assume that each row represents a possible dividend, and each column represents a possible divisor. The value at the intersection of a given dividend and divisor is the corresponding quotient. As an example, to find the value in decimal for the fraction 5/6, go to row 5, then over to column 6 to get the value 0.83. To implement this in Verilog or VHDL, we could store this two-dimensional table in a 2D array. (You saw how 2D arrays work in the state machine project in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.) The row input values provide one index, the column input values provide the second index, and the quotient is the value at those two indices. We’re not actually performing any math here; we’re just indexing into the correct result, which has been precalculated and stored in memory.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If you’re wondering how to represent decimal values like 0.50 and 0.33 inside an FPGA, good question! We’ll explore this topic shortly.</i></p>
<p class="TX">As the range of possible inputs grows, of course, we’ll need a larger and larger table to store the possible outputs. Eventually, a single table could take up an entire block RAM, which are often 16Kb in size. Using a precalculated table in a block RAM guarantees that a single division calculation will take a single clock cycle, since we only need one clock cycle <span aria-label=" Page 228. " epub:type="pagebreak" id="pg_228" role="doc-pagebreak"/>to read from the memory (as you learned when we discussed RAM back in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). However, we can’t read from multiple locations in the memory on the same clock cycle, so if we needed to do two divisions simultaneously, on the exact same clock cycle, we would need to instantiate a second copy of the precalculated table in another block RAM.</p>
<p class="TX">Block RAMs are usually valuable resources, so taking up a bunch of them for concurrent divisions doesn’t scale very well. If the design will allow us to run the different divisions in consecutive clock cycles, rather than simultaneously, we could instead use a single table and time-share it. Time sharing a single resource would require arbitration of that resource, as we discussed in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. We would have to create some arbiter that would only allow access to the block RAM table by one module at a time.</p>
<p class="TX">The solutions discussed up to this point assume we have just one clock cycle to get the result of a division operation. However, if we can wait multiple clock cycles for the result of a division operation, that allows us to use another option.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Multiple Clock Cycles</samp></h4>
<p class="TNI1">Another way to ease the burden of the synthesis tools when it comes to division is to create an algorithm that performs division in more than a single clock cycle, using simpler math operations such as addition and subtraction. At its heart, division is about calculating how many times one number fits into another number. You can accomplish this, for example, by adding the divisor to itself over and over until you’ve passed the value of the dividend, while counting the number of times you had to run that loop. Then you subtract the dividend to get the remainder.</p>
<p class="TX">There are various other techniques for performing division using simpler math operations. (Specific implementations are beyond the scope of this book; search the web for <i>division algorithms on FPGAs</i> if you want to learn more.) But of course, these methods only work if you’re able to wait multiple clock cycles for the result. Using multiple clock cycles to produce a result is a bit different in this context than the pipelining example we discussed in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, where we broke up a complex math operation across multiple clock cycles to meet timing. In that case, we were still able to get a result every clock cycle, but the outputs were delayed a few clock cycles from the inputs.</p>
<p class="TX">In this case, we don’t know how many clock cycles the division algorithm will take to provide a result, so we can’t rely on a result each clock cycle. Ultimately, it’s a question of trading lower resource utilization for more clock cycles. If you really need to get the result of a division operation on every single clock cycle, you’ll have to use one of the previously discussed division techniques.</p>
</section>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h2 class="H1" id="sec18"><span id="h-140"/><samp class="SANS_Futura_Std_Bold_B_11">How FPGAs Implement Math Operations</samp></h2>
<p class="TNI1">With all the operations we’ve discussed so far, we’ve only looked at how the math works, without really considering how the operations are <span aria-label=" Page 229. " epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>implemented inside an FPGA. There are various FPGA components that may be involved, depending on the specific operation performed. If you take an introductory digital electronics course, you might learn about <i>half adders</i> and <i>full adders</i>, digital circuits that combine various logic gates (like XOR and AND) to perform addition operations. It’s a fascinating subject, but in the end you might be frustrated to find that you don’t need to know how these circuits work to be able to do math with modern FPGA code. You’ll never need to instantiate a full adder component by manually typing out all the necessary logic operations if you’re just adding two numbers together. Instead, you just use the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator in Verilog or VHDL, like you would in any other programming language, and trust the synthesis tools to handle the implementation.</p>
<p class="TX">The tools will likely place addition and subtraction operations into basic LUTs. For multiplication, the tools will use flip-flops for the shift left approach, or LUTs or DSP blocks (if available) for more complicated calculations. As discussed in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, DSP blocks are useful for accelerating large multiply–accumulate operations without utilizing a lot of LUT logic. Finally, division will require registers for the shift right approach, block RAMs for the precalculated table approach, or LUTs.</p>
<p class="TX">There’s more to math than just addition, subtraction, multiplication, and division, however. Look at your calculator and consider all the operations we haven’t discussed: sine, cosine, square root, and more. It’s certainly possible to run these operations on an FPGA, but it gets complicated and is beyond the scope of this book. If you’re interested in learning more, there are dedicated algorithms that you can instantiate for these, such as a Coordinate Rotation Digital Computer (CORDIC). Search GitHub for <i>FPGA CORDIC</i> and you’ll find many examples.</p>
<p class="TX">In addition to actually implementing more complicated math operations on your FPGA, if you have the option it might be worth sending the inputs to a dedicated processor to perform the calculations, and then returning the result back to the FPGA logic. We’ll discuss floating- versus fixed-point arithmetic in the next section, but processors are much more capable of performing floating-point arithmetic than FPGAs. This processor can be a dedicated component external to the FPGA, or it can be internal to the FPGA itself. If it’s internal, it’s referred to as either a hard-core processor or a soft-core processor, depending on if it’s a dedicated piece of silicon or not.</p>
<p class="TX">Many modern FPGAs have internal hard ARM cores. This type of component with FPGA logic and a dedicated processor is often referred to as a <i>system on a chip (SoC)</i>. You can send the operations from the FPGA LUT/flip-flop logic into the ARM core for processing, and it will perform whatever operation is required and return the result. This solution is more about handling data than performing math, since you’ll likely need to set up FIFOs for each of the inputs and outputs. Working with a separate processor is an advanced topic, but it can be very valuable in higher-end applications.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h2 class="H1" id="sec19"><span id="h-141"/><span aria-label=" Page 230. " epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Working with Decimals</samp></h2>
<p class="TNI1">So far we’ve been working with integers, but there are many applications where you’ll need your FPGA to operate on numbers with a decimal component. In this section, we’ll examine how to do math using non-integers. To begin with, we need to consider how fractional numbers are actually represented using binary digits. There are two possible systems to choose from: floating point and fixed point.</p>
<p class="TX">The vast majority of mathematical operations within electronic devices use <i>floating-point</i> arithmetic, since most CPUs are designed to handle floating-point numbers. The key to floating point is that the <i>radix</i> (the decimal separator) “floats,” depending on how much precision is needed. We won’t go into detail about how exactly this works, but the bottom line is that with 32 bits you can represent an enormous range of values, with varying precision; you can represent very small numbers with high precision, or very large numbers with less precision. <i>Fixed-point</i> arithmetic, on the other hand, has a fixed radix, meaning there are a fixed number of integer places and a fixed number of decimal places.</p>
<p class="TX">FPGAs <i>can</i> perform floating-point operations, but they often require more resources than fixed-point operations. Most FPGA math is therefore done with fixed-point arithmetic, so that will be our focus for the rest of the chapter.</p>
<p class="TX">To illustrate how fixed-point representation works, let’s take an example. Say we have 3 bits allotted for representing a number inside our FPGA. We’ve been assuming up to this point that each bit change will be worth one integer value. For example, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> means that we go from 1 to 2. But we’ve just arbitrarily decided that each bit is worth one integer. We could just as easily decide that a single bit is worth something else, for example 0.5. In that case, <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> would be equivalent to 0.5, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp> would be 1.0, <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> would be 1.5, and so on. We now have a fixed-point system where the rightmost bit represents the decimal component of the number and the other two bits represent the integer component. We can also interpret the bits in other ways to give us different fixed-point representations. <a href="#tab10-4">Table 10-4</a> shows the most common decimal interpretations of 3 unsigned bits.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab10-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">3-Bit Unsigned Fixed-Point Possibilities</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">U3.0</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">U2.1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">U1.2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">U0.3</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.25</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.125</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.250</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.75</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.375</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.500</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.25</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.625</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.750</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3.5</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.75</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.875</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 231. " epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/>The headings in <a href="#tab10-4">Table 10-4</a> use a modified version of <i>Q notation</i>, which is a way to specify the parameters of a binary fixed-point number format. In Q notation, for example, Q1.2 indicates that 1 bit is being used for the integer portion of a number and 2 bits are being used for the fractional portion. Standard Q notation assumes the values are signed; however, in FPGAs it’s very common to have unsigned and signed values. That’s why I prefer a notation that specifies if the values are signed (S) or unsigned (U) using the leading character. Thus, S3.1 indicates a signed value with 3 integer bits and 1 fractional bit, and U4.8 indicates an unsigned value with 4 integer bits and 8 fractional bits.</p>
<p class="TX">In <a href="#tab10-4">Table 10-4</a>, the U3.0 column is what we’re used to; all 3 bits are allotted to the integer portion of the number, so we only have whole numbers. Let’s consider the next column, U2.1. It’s unsigned, with 2 bits for the integer component and 1 bit for the decimal component. This means the integer part can be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, and the decimal part can be in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To figure out what possible values that represents, simply take the original U3.0 value and divide it by 2. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> is 7 in U3.0, but in U2.1 it’s 3.5 (7 / 2 = 3.5). In general, when there are <i>N</i> bits allotted to the fractional portion of the number, you divide the integer representation by 2<i><sup>N</sup></i> to determine the fixed-point value. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> in U0.3 is 7 / 2<sup>3</sup> = 7 / 8 = 0.875.</p>
<p class="TX">In <a href="#tab10-4">Table 10-4</a> we treated all the values as unsigned. <a href="#tab10-5">Table 10-5</a> shows the most common possibilities for interpreting the same 3 bits when we use signed data types.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab10-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">3-Bit Signed Fixed-Point Possibilities</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Bits</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">S3.0</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">S2.1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">S1.2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">S0.3</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.25</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.125</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.250</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.75</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0.375</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–2.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–1.00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.500</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–1.5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.75</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.375</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–1.0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.50</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.250</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–</samp><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.5</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.25</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">–0.125</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The S3.0 column shows the same signed whole number values we saw earlier in the chapter, in <a href="#tab10-1">Table 10-1</a>. We can generate the remaining columns by dividing the values in the S3.0 column by 2 for S2.1, by 4 for S1.2, and by 8 for S0.3.</p>
<p class="TX">Here’s the critical thing about working with fixed-point numbers: when you’re performing operations on binary data, the behavior of the binary operation doesn’t change based on its representation. Addition, subtraction, multiplication, and division all work exactly the same way as before, when we were treating the numbers as integers. However, there are a few more rules that need to be established to get the correct answer with fixed-point values.</p>
<p class="TX"><span aria-label=" Page 232. " epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>You’ll notice for the remainder of this chapter that I make an effort to keep track of the decimals in the code examples. I find it very helpful to add comments recording the width of the math operations in my Verilog or VHDL code. For example, when adding two 3-bit numbers together to get a 4-bit result, I’ll include a comment like <samp class="SANS_TheSansMonoCd_W5Regular_11">// U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">U2.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">U3.1</samp> so I know the decimal and integer widths. This is particularly useful when there are several math operations chained one after another, where the widths along the way might be changing.</p>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding and Subtracting with Fixed Point</samp></h3>
<p class="TNI1">When performing addition or subtraction with fixed-point decimals, the actual process doesn’t change. The data is still just binary. There’s another rule that we must apply when we have decimals involved, however:</p>
<p class="EX"><b>Rule #5</b>  When adding or subtracting, the decimal widths must match.</p>
<p class="TX">The number of places to the right of the decimal point determines the value, or <i>weight</i>, of each bit, so if you try to add or subtract two inputs with different decimal bit widths—for example, a U3.1 input and a U4.0 input—you’ll get a wrong answer. We can see that in the following code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // U3.1 + U4.0 = U4.1 (Rule #5 violation)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
   o_u5  = i1_u4 + i2_u4;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> $display("Ex20: %2.3f + %2.3f = %2.3f", i1_u4/2.0, i2_u4, o_u5/2.0);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- U3.1 + U4.0 = U4.1 (Rule #5 violation)
   i1_u4 := "0011";
   i2_u4 := "0011";
   i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> real1 := real(to_integer(i1_u5)) / 2.0;
   real2 := real(to_integer(i2_u5));
   real3 := real(to_integer(o_u5)) / 2.0;
   report "Ex20: " &amp; str(real1) &amp; " + " &amp; str(real2) &amp; " = " &amp; str(real3);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex20: 1.500 + 3.000 = 3.000</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex20: 1.500 + 3.000 = 3.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ex20</samp> shows the effect of not obeying Rule #5. Here we’re attempting to add a U3.1 to a U4.0. This is going to cause a problem because the weight <span aria-label=" Page 233. " epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/>of the bits being added together isn’t matched. Indeed, the printout tells us that 1.5 + 3 = 3, so something has clearly gone wrong.</p>
<p class="TX">Notice that we’ve divided the input U3.1 and the output U5.1 by 2.0 to print out these fixed-point values correctly <span aria-label="annotation1" class="CodeAnnotation">❶</span>. For Verilog, we can simply do the division on the unsigned input and use <samp class="SANS_TheSansMonoCd_W5Regular_11">%f</samp> to format the result like a float. In VHDL, the conversion is a bit more complicated. First we need to switch to the <samp class="SANS_TheSansMonoCd_W5Regular_11">real</samp> data type, which is used for numbers with decimals, and then we can divide by 2.0 for printing.</p>
<p class="TX">To fix this example, we need to adjust one of the inputs so it has the same number of decimal bits as the other input. We can either change the first input from U3.1 to U4.0 to match the second input, or change the second input from U4.0 to U4.1. In the following code, we try both options:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // Convert U3.1 to U4.0
   // U4.0 + U4.0 = U5.0 (Rule #5 fix, using truncation)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> i1_u4 = i1_u4 &gt;&gt; 1; // Convert U3.1 to U4.0 by dropping decimal
   o_u5  = i1_u4 + i2_u4;
   $display("Ex21: %2.3f + %2.3f = %2.3f", i1_u4, i2_u4, o_u5);
   // Or Convert U4.0 to U4.1
   // U3.1 + U4.1 = U5.1 (Rule #5 fix, using expansion)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> i2_u5 = i2_u4 &lt;&lt; 1;
   o_u6  = i1_u4 + i2_u5;
   $display("Ex22: %2.3f + %2.3f = %2.3f", i1_u4/2.0, i2_u5/2.0, o_u6/2.0);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- Convert U3.1 to U4.0
   -- U4.0 + U4.0 = U5.0 (Rule #5 fix, using truncation)
    i1_u4 := "0011";
   i2_u4 := "0011";
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> i1_u4 := shift_right(i1_u4, 1); -- Convert U3.1 to U4.0
   i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
   real1 := real(to_integer(i1_u5));
   real2 := real(to_integer(i2_u5));
   real3 := real(to_integer(o_u5));
   report "Ex21: " &amp; str(real1) &amp; " + " &amp; str(real2) &amp; " = " &amp; str(real3);
   -- Or Convert U4.0 to U4.1
   -- U3.1 + U4.1 = U5.1 (Rule #4 fix, using expansion)
   i1_u4 := "0011";
   i2_u4 := "0011";
   i1_u6 := resize(i1_u4, i1_u6'length); -- expand for adding
   i2_u6 := resize(i2_u4, i2_u6'length); -- expand for adding
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> i2_u6 := shift_left(i2_u6, 1); -- Convert 4.0 to 4.1
   o_u6  := i1_u6 + i2_u6;<span aria-label=" Page 234. " epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>
   real1 := real(to_integer(i1_u6)) / 2.0;
   real2 := real(to_integer(i2_u6)) / 2.0;
   real3 := real(to_integer(o_u6)) / 2.0;
   report "Ex22: " &amp; str(real1) &amp; " + " &amp; str(real2) &amp; " = " &amp; str(real3);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex21: 1.000 + 3.000 = 4.000
# Ex22: 1.500 + 3.000 = 4.500</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex21: 1.000 + 3.000 = 4.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex22: 1.500 + 3.000 = 4.500
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex21</samp>, we convert the U3.1 to a U4.0, effectively dropping the decimal point. We do this using a 1-bit shift to the right <span aria-label="annotation1" class="CodeAnnotation">❶</span>. But consider the effect of this: we’re eliminating the least significant bit, and if that bit has a 1 in it, then we’re dropping that data. Essentially, we’re performing a rounding operation to the next lowest integer. We can see that our first input was originally 1.5, but after dropping the decimal point it’s 1.0. The math is correct, 1.0 + 3.0 = 4.0, but we’ve truncated our input.</p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ex22</samp> shows a better solution that retains the precision of all inputs. Rather than shifting the first input to the right, we shift the second input to the left <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This pads the least significant bit with a 0, converting our second input from U4.0 to U4.1. Notice that this means the second input now occupies a total of 5 bits. We need to be sure to resize it, or we could end up losing the data in the most significant bit during the shift left. Additionally, our output now has to be 6 bits so we don’t violate Rule #1.</p>
<p class="TX">Now that the decimal widths of the two inputs are matched with no loss of precision, we’re able to successfully calculate that 1.5 + 3.0 = 4.5. Expanding your inputs to match is the best solution if you don’t want to round any of the decimal values.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Subtracting fixed-point numbers works with all the same rules as addition, so we won’t consider an example here. Follow the rules introduced in this chapter, and your subtraction operations will work as expected.</i></p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H2" id="sec21"><span id="h-143"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplying with Fixed Point</samp></h3>
<p class="TNI1">Multiplication with fixed-point numbers doesn’t require any shifting to match the decimal widths. Instead, we can simply multiply the two inputs together as they are, provided we keep track of the input widths and size the output appropriately. We already have a rule for multiplication:</p>
<p class="EX"><b>Rule #4</b>  When multiplying, the output bit width must be at least the sum of the input bit widths (before sign extension).</p>
<p class="BodyContinued">Now we need to add another rule to account for fixed-point numbers:</p>
<p class="EX"><span aria-label=" Page 235. " epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/><b>Rule #6</b>  When multiplying fixed-point numbers, add the integer component bit widths and the decimal component bit widths of your inputs separately to get the output format.</p>
<p class="TX">For example, if you’re trying to multiply a U3.5 by a U1.7, the result is formatted as a U4.12. We determine this by adding the integer components (3 + 1 = 4) and the decimal components (5 + 7 = 12), and putting them together to get the output width format. It works the same way for signed values, so S3.0 <span class="symbol">×</span> S2.4 = S5.4. Notice that we’re still obeying Rule #4 as well, since the output width will be the sum of the input widths. It’s just that the integer and decimal components are treated separately.</p>
<p class="TX">Let’s take a look at some examples in Verilog and VHDL:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>   // U2.2 * U3.1 = U5.3
   i1_u4 = 4'b0101;
   i2_u4 = 4'b1011;
   o_u8  = i1_u4 * i2_u4;
   $display("Ex23: %2.3f * %2.3f = %2.3f", i1_u4/4.0, i2_u4/2.0, o_u8/8.0);
   // S2.2 * S4.0 = S6.2
   i1_s4 = 4'b0110;
   i2_s4 = 4'b1010;
   o_s8  = i1_s4 * i2_s4;
   $display("Ex24: %2.3f * %2.3f = %2.3f", i1_s4/4.0, i2_s4, o_s8/4.0);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>   -- U2.2 * U3.1 = U5.3
   i1_u4 := "0101";
   i2_u4 := "1011";
   o_u8  := i1_u4 * i2_u4;
   real1 := real(to_integer(i1_u4)) / 4.0;
   real2 := real(to_integer(i2_u4)) / 2.0;
   real3 := real(to_integer(o_u8))  / 8.0;
   report "Ex23: " &amp; str(real1) &amp; " * " &amp; str(real2) &amp; " = " &amp; str(real3);
   -- S2.2 * S4.0 = S6.2
   i1_s4 := "0110";
   i2_s4 := "1010";
   o_s8  := i1_s4 * i2_s4;
   real1 := real(to_integer(i1_s4)) / 4.0;
   real2 := real(to_integer(i2_s4));
   real3 := real(to_integer(o_s8))  / 4.0;
   report "Ex24: " &amp; str(real1) &amp; " * " &amp; str(real2) &amp; " = " &amp; str(real3);</code></pre>
<p class="TX">Here’s the output:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code># Ex23: 1.250 * 5.500 = 6.875
# Ex24: 1.500 * -6.000 = -9.000</code></pre>
<p class="Label"><span aria-label=" Page 236. " epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code># ** Note: Ex23: 1.250 * 5.500 = 6.875
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex24: 1.500 * -6.000 = -9.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples</code></pre>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex23</samp>, we’re multiplying a U2.2 by a U3.1 to get a result that’s a U5.3. We can see in the printout that the answer is correct: 1.25 <span class="symbol">×</span> 5.5 = 6.875. As with the addition examples, notice that we have to divide the values to print them out correctly. We divide the U2.2 by 4, the U3.1 by 2, and the U5.3 by 8. In <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex24</samp>, we use the same technique to multiply signed values. We’re multiplying 1.5 by –6.0 to get –9.0, which is represented with S2.2 <span class="symbol">×</span> S4.0 = S6.2.</p>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h2 class="H1" id="sec22"><span id="h-144"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">Since FPGAs are known for being able to perform many calculations at fast clock rates and in parallel, many common FPGA applications call for using addition, subtraction, multiplication, and division. Inside your FPGA, these operations may involve LUTs, shift registers, or DSP blocks. More important than knowing exactly how the operations are implemented, however, is understanding how the inputs and outputs are stored and what those binary digits represent when you’re writing your Verilog or VHDL code. Are they signed or unsigned? Integers or fixed point?</p>
<p class="TX">Over the course of this chapter, we’ve developed a set of rules for successfully performing FPGA math operations and interpreting the results. They are:</p>
<p class="EX"><b>Rule #1</b>  When adding or subtracting, the result should be at least 1 bit bigger than the biggest input, before sign extension. Once sign extension is applied, the input and output widths should match exactly.</p>
<p class="EX"><b>Rule #2</b>  Match types among inputs and outputs.</p>
<p class="EX"><b>Rule #3</b>  When subtracting, use signed inputs and outputs.</p>
<p class="EX"><b>Rule #4</b>  When multiplying, the output bit width must be at least the sum of the input bit widths (before sign extension).</p>
<p class="EX"><b>Rule #5</b>  When adding or subtracting, the decimal widths must match.</p>
<p class="EX"><b>Rule #6</b>  When multiplying fixed-point numbers, add the integer component bit widths and the decimal component bit widths of your inputs separately to get the output format.</p>
<p class="TX">These rules don’t capture every nuance of performing math in FPGAs, but they cover the major details that you need to get right. If you follow these six rules, it’s much more likely that you’ll get the correct answer from your calculations. Whenever you’re working with math, adding tests will help to ensure things are working as you expect.</p>
</section>
</section>
</body>
</html>