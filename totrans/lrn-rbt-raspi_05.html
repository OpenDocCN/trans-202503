<html><head></head><body>
<h2 class="h2a" id="ch05">5<br/><span epub:type="pagebreak" id="page_103"/>AVOIDING OBSTACLES</h2>&#13;
<p class="startpara">NOW YOU CAN CONTROL HOW YOUR ROBOT MOVES, AND THAT’S PRETTY COOL! BUT WOULDN’T IT BE COOLER STILL TO GET YOUR ROBOT TO CONTROL ITSELF?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>You may have noticed that your little two-wheeler is quite vulnerable to all kinds of hazards while it’s running around the floor. Crashing into walls and other objects can be very annoying and even dangerous to your hardware. In this chapter, I’ll show you how to enable your robot to autonomously detect and avoid obstacles. We’ll cover the theory behind obstacle detection and how to use the sensor you’ll need.</p>&#13;
<h3 class="h3" id="ch05lev1sec1">OBSTACLE DETECTION</h3>&#13;
<p class="noindent">In order for your robot to avoid obstacles, it will first need to be able to sense them. In electronics we use specialized sensors for this purpose. There’s a variety of ways to implement obstacle detection using sensors. At the hobbyist level, there are two main approaches: digital detection and analog detection. Digital detection is excellent at sensing obstacles within a certain range, but it can’t determine the distance to that obstacle. Analog detection, on the other hand, can do both, so that’s what we’ll use here to make our robot extra intelligent.</p>&#13;
<h4 class="h4" id="ch05lev2sec1">Using Ultrasonic Sensors for Analog Object Detection</h4>&#13;
<p class="noindent">The HC-SR04 ultrasonic sensor (seen in <a href="ch05.xhtml#ch05fig1">Figure 5-1</a>) uses ultrasonic sound to determine the distance between the sensor and an object. The sensor works in much the same way that bat and dolphin sonar works in the natural world, and submarine sonar works in the not-so-natural world.</p>&#13;
<div class="image" id="ch05fig1"><img alt="image" src="../images/f104-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-1</strong> The HC-SR04 ultrasonic distance sensor</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>Sound can be modeled as a wave with varying wavelength. Only a small range of the sound spectrum is audible to the human ear. Any sound waves with a frequency above this range (20 kHz+) are <em>ultrasound</em> waves. Ultrasonic distance sensors are designed to sense object proximity using ultrasound reflection. A sonar system like this sends out waves that bounce off obstacles. A receiver then detects the returning sound waves. Ultrasound is accurate within short distances (around a few meters) and is inaudible to humans.</p>&#13;
<h4 class="h4" id="ch05lev2sec2">Understanding How the HC-SR04 Works</h4>&#13;
<p class="noindent">A basic ultrasonic distance sensor like the HC-SR04 is made up of a transmitter, a receiver, and some circuitry. The transmitter and the receiver are the speaker-like protrusions resembling eyes in <a href="ch05.xhtml#ch05fig1">Figure 5-1</a>.</p>&#13;
<p class="indent">To determine a distance, the transmitter emits a high-frequency ultrasonic sound. This sound will bounce off any nearby solid objects and be reflected. The “bounce-back” is detected and picked up by the receiver on the HC-SR04.</p>&#13;
<p class="indent">Sound travels through air at a constant speed. At room temperature (20º C/68 ºF) a sound wave will travel at approximately 343 m/s (meters per second). While this is fast, it’s not instantaneous, which means there’s a small time difference between when the sound is emitted and when the bounce-back is received. Therefore, we can measure the distance by timing how long the signal takes to bounce back to the sensor.</p>&#13;
<p class="indent">The relationship between speed, distance, and time can be summarized as follows:</p>&#13;
<div class="image"><img alt="Image" src="../images/eq105-01.jpg"/></div>&#13;
<p class="indent">The speed of an object in meters per second is equal to the distance that object has traveled in meters divided by the time it has taken to move that far in seconds. We’ll use this equation to figure out the distance. We know the speed of sound is constant at 343 m/s, and we can measure how long the sound wave takes to bounce off an object, which is the time. If you rearrange the equation to solve for distance, you get:</p>&#13;
<div class="image"><img alt="Image" src="../images/eq105-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_106"/>This isn’t quite the full story, however. The ultrasonic pulse is emitted, bounces off an object, and is received by the HC-SR04, as shown in <a href="ch05.xhtml#ch05fig2">Figure 5-2</a>, meaning the sound wave is actually traveling <em>double</em> the distance from the sensor to the object.</p>&#13;
<div class="image" id="ch05fig2"><img alt="image" src="../images/f106-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-2</strong> The HC-SR04 distance-measuring process</p>&#13;
<p class="indent">That means we need to divide the time recorded by the ultrasonic distance sensor in half, which results in the following equation:</p>&#13;
<div class="image"><img alt="image" src="../images/eq106-01.jpg"/></div>&#13;
<p class="indent">We have our method, so let’s try it out.</p>&#13;
<h3 class="h3" id="ch05lev1sec2">MEASURING A SHORT DISTANCE</h3>&#13;
<p class="noindent">Now that you understand the mathematics and theory behind ultrasonic distance measurement, it’s time to put everything into practice and measure some distances!</p>&#13;
<h4 class="h4" id="ch05lev2sec3">The Parts List</h4>&#13;
<p class="noindent">In addition to the breadboard you already have on your Raspberry Pi robot, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent">An HC-SR04 ultrasonic sensor</li>&#13;
<li class="noindent">A 1 kΩ resistor</li>&#13;
<li class="noindent">A 2 kΩ resistor</li>&#13;
<li class="noindent">Jumper wires</li>&#13;
</ul>&#13;
<p class="indent">Inexpensive HC-SR04 sensors are widely available through the usual online retailers. Just search “HC-SR04;” you shouldn’t have to spend more than a few dollars on one.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_107"/>Any digital system has two logic states: low voltage (0) and high voltage (1). This was first introduced in <a href="ch04.xhtml">Chapter 4</a> when explaining PWM. Usually, the low voltage is just ground, 0 V; however, the high voltage can change from system to system. This means that some systems require a 5 V signal to trigger a high voltage, while others may require only 3.3 V, for example. This just so happens to be the situation we are in! The HC-SR04 requires 5 V, whereas your Raspberry Pi operates on 3.3 V logic. Notice in <a href="ch05.xhtml#ch05fig3">Figure 5-3</a> that there are four pins on the ultrasonic sensor: <em>Vcc</em> for power, <em>Trig</em> for the trigger pulse, <em>Echo</em> for the echo pulse, and finally <em>Gnd</em> for ground.</p>&#13;
<div class="image" id="ch05fig3"><img alt="image" src="../images/f107-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-3</strong> A close-up of the pins on an HC-SR04 module</p>&#13;
<p class="indent">You’ll need to power the module using a 5 V source on the Vcc pin. When the HC-SR04 receives the bounce-back pulse, the Echo pin is set to a 5 V logic high, but if we were to connect this directly to the Raspberry Pi, the high voltage would cause serious damage. To avoid this, you’ll need to lower the sensor output voltage to something your Raspberry Pi can handle—that’s where the 1 kΩ and 2 kΩ resistors come in handy. We’re going to use them to build a <em>voltage divider</em>.</p>&#13;
<h4 class="h4" id="ch05lev2sec4">Reducing Voltage with Voltage Dividers</h4>&#13;
<p class="noindent">A <em>voltage divider</em> is a simple circuit that turns a larger voltage into a smaller one. The voltage divider takes an input voltage and uses two resistors in series to reduce and output that voltage. You use different values of resistors to make the output voltage a certain fraction of the input voltage.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>The voltage divider circuit is shown in <a href="ch05.xhtml#ch05fig4">Figure 5-4</a>. Notice that the output voltage is drawn from between the two resistors.</p>&#13;
<div class="image" id="ch05fig4"><img alt="image" src="../images/f108-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-4</strong> A voltage divider circuit</p>&#13;
<p class="indent">As with most electronics, we use an equation to mathematically relate the two resistors (<em>R</em><sub>1</sub> and <em>R</em><sub>2</sub>) to the input and output voltages (<em>V</em><sub>in</sub> and <em>V</em><sub>out</sub>). Physicists don’t mince words, so the equation is simply called the <em>voltage divider equation</em>:</p>&#13;
<div class="image"><img alt="image" src="../images/eq108-01.jpg"/></div>&#13;
<p class="indent">Using this equation, you can work out the exact <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> resistor values you need to create the desired output voltage. The size of <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> is actually irrelevant; what matters instead is the <em>ratio</em> of <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub>. For example, if <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> are equal, then the output voltage will be half the input voltage.</p>&#13;
<div class="note">&#13;
<p class="note-warning">WARNING</p>&#13;
<p class="note-warning1"><em>No matter what resistor values you end up with, it’s always better to have an output voltage that is lower than the target, rather than higher. This is because a lower voltage will not harm your Raspberry Pi or other electronics, whereas a voltage that is too high, even by a small margin, may do so.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s use this equation to work out what resistor values we need for the distance sensor on our robot. You know that the input voltage is 5 V, and the desired output voltage is 3.3 V, so we have two unknowns in the equation: <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub>. You can pick a common resistor value for one and that gives us just one unknown, which is much easier to work out. Let’s choose 1 kΩ for <em>R</em><sub>1</sub>. By rearranging the equation to solve for <em>R</em><sub>2</sub>, you get:</p>&#13;
<div class="image"><img alt="image" src="../images/eq108-02.jpg"/></div>&#13;
<p class="indent">If you plug in the numbers that you know, <em>R</em><sub>2</sub> works out like this:</p>&#13;
<div class="image"><img alt="image" src="../images/eq108-03.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>Finding a resistor with the exact value 1941.176471 Ω is going to be very tricky! So instead we’ll just pick the nearest common resistor value. In our case, a 2 kΩ or 2.2 kΩ resistor will suffice. If in doubt, try to find a resistor that’s nearest, but slightly <em>lower</em> than, the value you need. You can always put your two resistor values back into the equation to work out the output voltage with that pair if you want to double-check.</p>&#13;
<h4 class="h4" id="ch05lev2sec5">Wiring Up Your HC-SR04</h4>&#13;
<p class="noindent">Now that you have all your necessary components, you can wire up your distance sensor. As always, ensure your Pi and robot’s power are disconnected before you start fiddling around with the wiring and connecting new things.</p>&#13;
<p class="indent">Rather than plug the HC-SR04 module directly into a breadboard, we’ll connect it using long jumper wires so you can position the distance sensor anywhere on your robot. Using your build from the previous chapter that has the motors wired up, follow these instructions, but don’t attach the sensor to the robot chassis just yet:</p>&#13;
<ol>&#13;
<li class="noindent">Use a long jumper wire to connect the Vcc pin of your HC-SR04 to the Pi’s +5 V power rail on your breadboard.</li>&#13;
<li><p class="noindent">Use another long jumper wire to connect the Gnd pin of your HC-SR04 to the ground rail on your breadboard. At this point your wiring should look like <a href="ch05.xhtml#ch05fig5">Figure 5-5</a>.</p>&#13;
<div class="image" id="ch05fig5"><img alt="image" src="../images/f109-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-5</strong> HC-SR04 module connected to +5 V and ground. The motor controller chip and motors are omitted from the diagram, but you should keep them connected to your circuit. The orange stripes represent the area the L293D chip and its wiring takes up.</p></li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_110"/>Next, use a wire to connect the Trig pin of your HC-SR04 directly to physical pin 16 on your Raspberry Pi. Pin 16 on the Pi is also called BCM 23.</li>&#13;
<li><p class="noindent">Then attach a jumper wire from the Echo pin of your sensor to a new row on your breadboard. Connect a 1 kΩ resistor by putting one leg of the resistor into the same row as the Echo pin and the other leg of the resistor into a different, unused row of your breadboard. At this point your wiring should look like <a href="ch05.xhtml#ch05fig6">Figure 5-6</a>.</p>&#13;
<div class="image" id="ch05fig6"><img alt="image" src="../images/f110-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-6</strong> The Trig pin of the HC-SR04 connected to BCM 23 and the Echo pin connected to a 1 kΩ resistor</p></li>&#13;
<li class="noindent">Wire up physical pin 18 (BCM 24) of your Raspberry Pi to the row with the other leg of the 1 kΩ resistor you just connected.</li>&#13;
<li class="noindent">Finally, place one leg of your 2 kΩ/2.2 kΩ resistor in the row with the 1 kΩ resistor and jumper wire to your Pi’s BCM 24 pin, and place the other leg of this resistor in a ground rail. The complete circuit on your breadboard should look something like <a href="ch05.xhtml#ch05fig7">Figure 5-7</a>.</li>&#13;
</ol>&#13;
<p class="indent"><a href="ch05.xhtml#ch05fig8">Figure 5-8</a> shows a circuit diagram of the final outcome.</p>&#13;
<div class="image" id="ch05fig7"><img alt="image" src="../images/f111-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-7</strong> The completed breadboard diagram with the HC-SR04 and voltage divider in place</p>&#13;
<div class="image" id="ch05fig8"><img alt="image" src="../images/f111-02.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-8</strong> A circuit diagram of the HC-SR04 connected to a Raspberry Pi</p>&#13;
<h4 class="h4" id="ch05lev2sec6"><span epub:type="pagebreak" id="page_111"/><span epub:type="pagebreak" id="page_112"/>Programming Your Raspberry Pi to Read Distance</h4>&#13;
<p class="noindent">With your ultrasonic distance sensor now wired up, it’s time to delve into some more Python code to use the sensor. Boot up your Raspberry Pi from a wall outlet, log in, and locate the <em>robot</em> folder you’re saving your programs in. Create a new program called <em>distance_test.py</em> with this command:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">nano distance_test.py</span></p>&#13;
<p class="indent">In this project, we’ll still use the GPIO Zero Python library, but we’ll move away from the built-in functions and objects. Instead, I’ll show you how to program and operate the HC-SR04 entirely from scratch!</p>&#13;
<p class="indent">The code in <a href="ch05.xhtml#ch05list1">Listing 5-1</a> will send out a signal, also known as a <em>ping</em>, and then read and print out the distance of the first object the signal meets. Save this code into the <em>distance_test.py</em> you have already open. Try to use your programming skills to read through and decipher it before moving on to my explanation!</p>&#13;
<p class="programs">&#13;
   <span class="p-blue">import</span> gpiozero<br/>   <span class="p-blue">import</span> time<br/><br/><span class="ent">➊</span> TRIG = 23<br/>   ECHO = 24<br/><br/><span class="ent">➋</span> trigger = gpiozero.OutputDevice(TRIG)<br/>   echo = gpiozero.DigitalInputDevice(ECHO)<br/><br/><span class="ent">➌</span> trigger.on()<br/>   time.sleep(0.00001)<br/>   trigger.off()<br/><br/><span class="ent">➍</span> <span class="p-blue">while</span> echo.is_active == <span class="p-purple">False</span>:<br/>       pulse_start = time.time()<br/><br/><span class="ent">➎</span> <span class="p-blue">while</span> echo.is_active == <span class="p-purple">True</span>:<br/>       pulse_end = time.time()<br/><br/><span class="ent">➏</span> pulse_duration = pulse_end - pulse_start<br/><br/><span class="ent">➐</span> distance = 34300 * (pulse_duration/2)<br/><br/>  round_distance = round(distance,1)<br/><br/>  <span class="p-blue">print</span>(<span class="green">"Distance: "</span>, round_distance)</p>&#13;
<p class="listing" id="ch05list1"><strong>LISTING 5-1</strong> Program to measure a single distance</p>&#13;
<p class="indent">As usual, we begin by importing the <span class="literal">gpiozero</span> and <span class="literal">time</span> libraries for use throughout the code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>At <span class="ent">➊</span> and on the following line, we create two variables, <span class="literal">TRIG</span> and <span class="literal">ECHO</span>, which simply store the pin number that the Trig and Echo pins are connected to, respectively. We capitalize these variables to indicate that they are <em>constants</em>—variables whose values we want to keep the same for the duration of the program.</p>&#13;
<p class="indent">Capitalizing constants is a programming convention that tells you, and anyone else reading the code, that these values are not changed throughout the execution of the program. It’s worth stressing that because this is a convention, it’s merely a practice that most programmers do, not one enforced by Python. The code would work equally well if these were lowercase, or even a mixture of cases.</p>&#13;
<p class="indent">The following two lines <span class="ent">➋</span> set up the GPIO pins connected to the Trig and Echo pins of the HC-SR04. We set up the <span class="literal">trigger</span> variable to be an output, since it’s sending out a ping, and <span class="literal">echo</span> as an input, since it’s receiving a ping.</p>&#13;
<p class="indent">To trigger the ping, the HC-SR04 sensor needs a quick 10 µs (1 µs is a millionth of a second: 0.000001 s) pulse that takes place in the next chunk of code <span class="ent">➌</span>.</p>&#13;
<p class="indent">When the ping has been sent out by the transmitter, the program must wait for the ping to clear the receiver before it starts listening for the echo. This is because the transmitter and the receiver on the HC-SR04 are close together, so in the microseconds after transmission, the sensor can hear the outgoing pulse. We don’t want to record the outgoing pulse accidentally, so we tell the program to wait until it hears the echo <em>and not</em> the original ping. You can think of this as if you and a friend were standing next to each other in a large room and you wanted to listen for an echo. If you were to shout “Hello!” your friend would hear you <em>before</em> you heard the echo from the room. This sort of effect is what we must avoid when using the HC-SR04.</p>&#13;
<p class="indent">The next section of the code is responsible for making sure we pick up the echo. The <span class="literal">while</span> loop <span class="ent">➍</span> with the condition <span class="literal">echo.is_active == False</span><span class="literal"/> repeats until the outgoing pulse is no longer heard by the sensor. The program then stores the exact time the pulse clears the receiver in a new variable called <span class="literal">pulse_start</span>.</p>&#13;
<p class="indent">With the outgoing pulse now out of the way, the <span class="literal">while</span> loop with the condition <span class="literal">echo.is_active == True</span> <span class="ent">➎</span> catches the echo when it returns to the sensor. A second variable called <span class="literal">pulse_end</span> is created and is used to record the exact time of the bounce-back pulse.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>Then we simply subtract the time the ping was sent out from the time it was received to work out how long it took to return. We store the result in a variable called <span class="literal">pulse_duration</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Arguably the most important part of this program is at <span class="ent">➐</span> where we work out the distance from the time it has taken for the ping to return. We apply the earlier equation to the values we’ve collected in the program:</p>&#13;
<div class="image"><img alt="image" src="../images/eq114-01.jpg"/></div>&#13;
<p class="indent">Rather than use the 343 m/s figure that is the speed of sound, we multiply it by 100 to give us a distance value in centimeters, which is much more relevant to the sorts of distances your robot will be dealing with.</p>&#13;
<p class="indent">Finally, in the last few lines of the program, we round the distance value to one decimal place and then output it to the terminal.</p>&#13;
<h4 class="h4" id="ch05lev2sec7">Running Your Program: Measure a Short Distance</h4>&#13;
<p class="noindent">Now that you have the code finished, it’s time to test out the ultrasonic distance sensor and its accuracy.</p>&#13;
<p class="indent">Place your HC-SR04 parallel to a surface, like a table. Then place a fairly small solid object in front of the sensor and measure the distance with a ruler. In <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>, I’m using an upright box. My box is roughly 20 cm away from my HC-SR04.</p>&#13;
<div class="image" id="ch05fig9"><img alt="image" src="../images/f114-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-9</strong> My HC-SR04 test setup</p>&#13;
<p class="indent">As ever, to run your program, enter:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 distance_test.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>After a short period, a single distance reading should print to your terminal and the program will end. For me this looks like the following:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 button.py</span><br/><span class="p-dark-blue">Distance: 20.1</span></p>&#13;
<p class="indent">Your HC-SR04 should have successfully measured the space between itself and the object! Mine was pretty accurate, but you shouldn’t expect 100 percent accuracy with these readings.</p>&#13;
<p class="indent">If your reading was off by a large margin, try running the program again to see if that output was just an outlier. If you’re still getting wrong readings, check the numbers and equations in your program: are the values correct and have you applied the math in the right way? If the program hangs (does nothing) and never finishes executing, check that your wiring is correct and refer to the instructions earlier in the chapter. Your program may also hang if it never receives an echo. This could be because the distance you’re trying to measure is out of range. However, for indoor use you shouldn’t have any problems.</p>&#13;
<p class="indent">Finally, if you’re still having issues, consult the code and make sure it’s exactly the same as the program in <a href="ch05.xhtml#ch05list1">Listing 5-1</a>. As usual, you can grab the exact code examples from <a href="https://nostarch.com/raspirobots/"><em>https://nostarch.com/raspirobots/</em></a>.</p>&#13;
<h3 class="h3" id="ch05lev1sec3">MAKE YOUR ROBOT AVOID OBSTACLES</h3>&#13;
<p class="noindent">Now that you have mastered measuring individual distances with an ultrasonic distance sensor, you can mount the sensor onto your robot and write a new program that will use the HC-SR04 to avoid obstacles.</p>&#13;
<p class="indent">By the end of this project, you’ll have a fully autonomous obstacle-avoider! The aim here is to make sure your Raspberry Pi robot gets no closer than 15 cm to any object before it takes evasive action.</p>&#13;
<h4 class="h4" id="ch05lev2sec8">Mounting Your HC-SR04 Ultrasonic Sensor</h4>&#13;
<p class="noindent">The best place to mount your distance sensor is on the front of the robot in a location that is as central as possible. I recommend using sticky tack or double-sided tape to affix it. The module can sense distance only in a direct straight line, so don’t mount it too high above the floor or your robot is likely to crash into low-lying obstacles.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>I have mounted my HC-SR04 on the front stabilizer, as shown in <a href="ch05.xhtml#ch05fig10">Figure 5-10</a>. The sensor is about a centimeter off the ground. Note that the orientation of your sensor also doesn’t matter: mine is upside down!</p>&#13;
<div class="image" id="ch05fig10"><img alt="image" src="../images/f116-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-10</strong> My HC-SR04 mounted to the front of my robot</p>&#13;
<h4 class="h4" id="ch05lev2sec9">Programming Your Robot to Avoid Obstacles</h4>&#13;
<p class="noindent">To create the obstacle avoidance program, we’ll borrow heavily from the prior section’s code but set the distance sensor to constantly scan for upcoming obstacles.</p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch05list1">Listing 5-1</a>, we worked out how to measure a single distance in 10 lines of code. In our next program, we’ll need to repeat the code continuously to get a constantly refreshing distance from your robot to any upcoming obstacles. We could write out the code every time we need to use it, but that sounds time-consuming and dull, and we don’t even know how many times we’d need to write it out. Instead, there is a way to package up code so you can use it whenever and wherever you need it. Packaging up code like this creates what is known as a <em>function</em>.</p>&#13;
<p class="indent">A Python function is a block of organized, reusable code that performs an action. Let’s try it out: enter the code for the obstacle avoidance program in <a href="ch05.xhtml#ch05list2">Listing 5-2</a> and save it as <em>obstacle_avoider.py</em> on your Raspberry Pi.</p>&#13;
<p class="programs">   <span class="p-blue">import</span> gpiozero<br/>   <span class="p-blue">import</span> time<br/><br/><span class="ent">➊</span> TRIG = 23<br/>   ECHO = 24<br/><br/>   trigger = gpiozero.OutputDevice(TRIG)<br/>   echo = gpiozero.DigitalInputDevice(ECHO)<br/><br/><span class="ent">➋</span> robot = gpiozero.Robot(left=(17,18), right=(27,22))<br/><br/><span class="ent">➌</span> <span class="p-blue">def</span> <span class="p-dark-blue">get_distance</span>(trigger, echo):<br/><span class="ent">➍</span>     trigger.on()<br/>       time.sleep(0.00001)<br/>       trigger.off()<br/><br/>       <span class="p-blue">while</span> echo.is_active == <span class="p-purple">False</span>:<br/>           pulse_start = time.time()<br/><br/>       <span class="p-blue">while</span> echo.is_active == <span class="p-purple">True</span>:<br/>           pulse_end = time.time()<br/><br/>       pulse_duration = pulse_end - pulse_start<br/><br/>       distance = 34300 * (pulse_duration/2)<br/><br/>       round_distance = round(distance,1)<br/><br/><span class="ent">➎</span>     <span class="p-blue">return</span>(round_distance)<br/><br/>   <span class="p-blue">while</span><span class="p-orange"> </span><span class="p-purple">True</span>:<br/><span class="ent">➏</span>     dist = get_distance(trigger,echo)<br/><span class="ent">➐</span>     if dist &lt;= 15:<br/>          robot.right(0.3)<br/>          time.sleep(0.25)<br/><span class="ent">➑</span>     <span class="p-blue">else</span>:<br/>          robot.forward(0.3)<br/>          time.sleep(0.1)</p>&#13;
<p class="listing" id="ch05list2"><strong>LISTING 5-2</strong> Obstacle avoidance program</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>This program begins by importing the necessary libraries. Then, you identify <span class="ent">➊</span> and set up <span class="ent">➋</span> the Trig and Echo pins of the HC-SR04 like you did in <a href="ch05.xhtml#ch05list1">Listing 5-1</a>. This also initializes the robot for use.</p>&#13;
<p class="indent">At <span class="ent">➌</span>, you meet your first Python function, which is organized into a code block. To start a function block, you use the keyword <span class="literal">def</span>. This is short for <em>define</em>, as you are defining what the block of code should do.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>After <span class="literal">def</span>, you enter the name of the function, which, like a variable, can be called anything (provided it doesn’t start with a number). It is best to keep your function names short and to the point. The purpose of this function is to trigger the sensor and return a distance measurement, so I’ve called this function <span class="literal">get_distance()</span>.</p>&#13;
<p class="indent">Parentheses follow a function name, and the contents of such parentheses are referred to as the function’s <em>parameters</em> or <em>arguments</em>. These parameters allow us to pass information into a function for later use. In our case, we pass the trigger and echo pin information we set up earlier, so that the function is able to activate and use the HC-SR04 distance sensor.</p>&#13;
<p class="indent">As with <span class="literal">while</span> and <span class="literal">for</span> loops, you need to indent the code inside the function so Python knows what code belongs to the function. The indented code begins at <span class="ent">➍</span> and extends to <span class="ent">➎</span>, and it is <em>exactly</em> the same as the code you used to get a distance reading in <a href="ch05.xhtml#ch05list1">Listing 5-1</a>.</p>&#13;
<p class="indent">At <span class="ent">➎</span> the code <em>returns</em> the final output of the function: the distance reading. Returning information just means that the output of that function is handed back to the program whenever the function is called. This output could then be printed to the terminal, set to a variable, or manipulated in any way you, as the coder, desire!</p>&#13;
<p class="indent">We then start an infinite <span class="literal">while</span> loop. First we call the <span class="literal">get_distance()</span> function and store its result in the variable <span class="literal">dist</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Next, we introduce the crucial obstacle-avoiding logic with a conditional <span class="literal">if</span> statement <span class="ent">➐</span>. This line translates to: “if the distance between the sensor and an obstacle is less than 15 cm, do the following.” If the condition is true, the two lines inside the statement run and turn the robot slowly right for a quarter of a second.</p>&#13;
<p class="indent">Finally, the code at <span class="ent">➑</span> deals with any other scenario. If an obstacle is further than 15 cm away, the robot proceeds forward slowly for a tenth of a second. Obstacle-avoiding programs usually work better when the robot is moving at a slower speed, so we set the robot at 30 percent of its full speed with the <span class="literal">(0.3)</span> argument here. If you find this is too slow or too fast for your particular build, feel free to increase or decrease the values inside the parentheses of the motor commands.</p>&#13;
<h4 class="h4" id="ch05lev2sec10">Running Your Program: Make Your Robot Avoid Obstacles</h4>&#13;
<p class="noindent">Now that the final piece of code is finished, I recommend clearing a suitably large area and then strategically placing obstacles at the correct height for your ultrasonic distance sensor. Take a look at <a href="ch05.xhtml#ch05fig11">Figure 5-11</a> for the course I quickly created for my robot.</p>&#13;
<div class="image" id="ch05fig11"><img alt="image" src="../images/f119-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 5-11</strong> My robot facing down some looming upright folders</p>&#13;
<p class="indent">Run your program with the command:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 obstacle_avoider.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>Your robot should spring to life and proceed forward until it reaches its first obstacle, at which point it should turn until the obstacle is clear and then continue on its path.</p>&#13;
<p class="indent">Another fun experiment would be to stand in front of your robot and watch it scuttle away from you, no matter how many times you move your feet to be in front of it!</p>&#13;
<p class="indent">As ever, kill the robot with the command <span class="small">CTRL</span>-C.</p>&#13;
<h4 class="h4" id="ch05lev2sec11">Challenge Yourself: Improve the Obstacle Avoidance Program</h4>&#13;
<p class="noindent">Our method of obstacle avoidance here leaves a lot of room for improvement!</p>&#13;
<p class="indent">As mentioned, the HC-SR04 is able to detect distance only in a single straight line, so your robot could miss obstacles that are directly in front of it but too low or too high for it to sense.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>Having just one distance sensor is also a limitation. Your robot can detect only obstacles that are straight ahead, so it could easily turn right or left into another obstacle! The more distance sensors you use, the more information the robot has and therefore the more intelligent the running code can be.</p>&#13;
<p class="indent">Try to tweak the program in <a href="ch05.xhtml#ch05list2">Listing 5-2</a> to make your robot avoid obstacles as efficiently as possible with one sensor. You could edit the minimum distance before evasive maneuvers are taken (the default is 15 cm). Or, you could edit the amount of time the motors are on for each evasion or the direction you turn. Try out different values in these variables and figure out what works best.</p>&#13;
<p class="indent">When you feel you’ve improved the program as much as you can, you could grab a second ultrasonic HC-SR04 module, wire it up to more of your Pi’s GPIO pins just as before, and customize your code to use this new source of data in addition to the first HC-SR04. If you’re using two sensors, a good place to mount them is on the front corners of your robot, rather than just facing forward.</p>&#13;
<p class="indent">If you’re still feeling adventurous, you could try a third distance sensor to build an even better picture of the environment your robot is in!</p>&#13;
<h3 class="h3" id="ch05lev1sec4">SUMMARY</h3>&#13;
<p class="noindent">In this chapter we’ve covered everything from the theory behind ultrasonic distance measurement to programming using functions. You’ve put all of this together to turn your robot into a fully autonomous obstacle-avoiding machine.</p>&#13;
<p class="indent">In the next chapter, I’ll show you how to make your robot unique by adding programmable RGB LEDs and sound effects!</p>&#13;
</body></html>