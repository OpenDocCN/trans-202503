<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label="346"/>&#13;
<figure class="co-img"><img id="fig-pg346" class="img60" src="../images/pg347.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-35.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_347" aria-label="347"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">POINTERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">So far, you’ve implemented only <i>arithmetic types</i>. These types have a lot in common; they all support the same basic mathematical operations, and you can always implicitly convert from one type to another. In the rest of <span class="chapterintro_Xref-1"><a href="part2.xhtml">Part II</a></span>, we’ll add several non-arithmetic types, like pointers, arrays, and structures. These types are quite different both from the arithmetic types and from each other. They don’t support ordinary arithmetic. Instead, each type supports its own distinct set of operations.</p>&#13;
<p class="TX">In this chapter, you’ll implement <i>pointer types</i>, which represent memory addresses. You’ll also add two new operators for working with pointers: the address operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, and the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. You’ll learn how to parse complex type specifiers and how to detect several new kinds of type errors. During TACKY and assembly generation, you’ll add a few new <span role="doc-pagebreak" epub:type="pagebreak" id="pg_348" aria-label="348"/>constructs to read from and write to locations in memory. You’ll continue to build on these changes as you add more non-arithmetic types in later chapters.</p>&#13;
<p class="TX">First, let’s discuss a few key concepts that I’ll refer to throughout this chapter: objects, values, and lvalue conversion.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-120"/><samp class="SANS_Futura_Std_Bold_B_11">Objects and Values</samp></h3>&#13;
<p class="TNI">Objects and values have come up in earlier chapters, but I never precisely defined either term or explained how they differ from each other. You can think of a <i>value</i> as a sequence of bits with a type. For example, the bits</p>&#13;
<pre><code>11111111111111111111111111111111</code></pre>&#13;
<p class="BodyContinued">with the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. So far, we’ve encountered only integer and floating-point values.</p>&#13;
<p class="TX">An <i>object</i> is a location in memory that contains a value. Variables are the only objects we’ve seen so far. From the programmer’s perspective, every object has a memory address, which is fixed throughout its lifetime, and a value, which you can update using an assignment expression. (In practice, some objects may be stored in registers rather than memory, and you can’t update every object’s value, but we can ignore those exceptions for now.)</p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter5.xhtml">Chapter 5</a></span>, I described an lvalue as an expression that can appear on the left side of an assignment expression. Now we can use the more precise definition from section 6.3.2.1, paragraph 1, of the C standard: “An lvalue is an expression … that potentially designates an object.” (Note that an lvalue is <i>not</i> a value, in spite of its name; it’s an expression.) Evaluating a non-lvalue expression produces a value. Evaluating an lvalue, on the other hand, “determin[es] the identity of the designated object,” according to section 5.1.2.3, paragraph 2, of the standard. If an expression designates an object, you can assign to it. Otherwise, you can’t.</p>&#13;
<p class="TX">When you use an object in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, you’re actually using its current value. But when you assign to an object, you don’t care about its current value, which you’re just going to overwrite; you care about its location, which you’re trying to write to. In other words, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, you sometimes treat it like a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and sometimes like a container where you can store a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The C standard refers to the first case, where you use an object’s value in an expression, as <i>lvalue conversion</i>. This is a “conversion” in the sense that you’re converting an lvalue, which designates an object, into an ordinary value. If an lvalue appears as the left operand of an assignment expression or as the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator, it doesn’t undergo lvalue conversion. If it appears anywhere else in an expression, it does. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an lvalue in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;x</samp>, but it’s not an lvalue in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(x)</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. In later chapters, we’ll encounter other expressions that aren’t lvalue converted.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_349" aria-label="349"/>This terminology lets us talk about pointers without getting hopelessly confused. Now we can discuss precisely what operations pointers support.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-121"/><samp class="SANS_Futura_Std_Bold_B_11">Operations on Pointers</samp></h3>&#13;
<p class="TNI">In this section I’ll introduce the address operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, which gets a pointer to an object, and the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, which you use to access an object through a pointer. I’ll also discuss casting and comparing pointers, plus one special case involving the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator. I won’t talk about pointer addition or subtraction yet; we’ll implement those in the next chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Address and Dereference Operations</samp></h4>&#13;
<p class="TNI">To see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operations work, let’s walk through the program in <a href="chapter14.xhtml#list14-1">Listing 14-1</a>. We’ll pay special attention to which expressions in this program designate objects and which ones result in values.</p>&#13;
<a id="list14-1"/>&#13;
<pre><code>int main(void) {&#13;
    int x = 0;&#13;
    int *ptr = &amp;x;&#13;
    *ptr = 4;&#13;
    return *ptr;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: A simple program using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">&amp;</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">*</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operations</samp></p>&#13;
<p class="TX">We start by declaring a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an object, it has an address, although that address won’t be the same every time you run the program. Let’s say that, during one run of <a href="chapter14.xhtml#list14-1">Listing 14-1</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> winds up at memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. It also has a value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. Since the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we’ll interpret its value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> too.</p>&#13;
<p class="TX">Next, we declare the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which is also an object. The type of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, or “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” which represents the address of an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> has an address; let’s say it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b940</samp>. It also has a value: the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;x</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator takes the address of its operand, which implies that its operand must designate an object with an address. In other words, the operand must be an lvalue. The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator, however, is not an object; it’s a value of pointer type.</p>&#13;
<p class="TX">In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;x</samp>, the operand is the lvalue <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. Evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;x</samp> results in the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>, which is the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp><span class="Annotation-Reference">.</span> We assign this value to the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, just like we can assign any value to a variable with a compatible type. To help us keep things straight, <a href="#fig14-1">Figure 14-1</a> shows the contents of the stack at this point in the program.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_350" aria-label="350"/>&#13;
<figure class="IMG"><img id="fig14-1" class="img50" src="../images/fig14-1.jpg" alt="" width="589" height="375"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The addresses and initial values of the objects declared in <a href="chapter14.xhtml#list14-1">Listing 14-1</a> <a href="description-36.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As this figure shows, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> is both the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. I said earlier that a value is a sequence of bits with a type; the type of the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> because it’s the address of an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>&#13;
<p class="TX">On the next line of <a href="chapter14.xhtml#list14-1">Listing 14-1</a>, we have the assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which consists of several subexpressions. On the right, we have the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>; on the left, we have the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, itself part of the dereference expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>. The constant isn’t particularly interesting, but the other two subexpressions are. The innermost of these expressions, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, designates an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. We don’t assign to it or take its address; we just read its value. Therefore, we implicitly lvalue convert it, which results in a <i>value</i> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. We use this value in a dereference expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>. A dereference expression is an lvalue, so its result is an object. In this case, it’s the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>, since that’s the value being dereferenced. Because we’re assigning to the object <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>, rather than using its value, it doesn’t undergo lvalue conversion. <a href="#fig14-2">Figure 14-2</a> shows the contents of the stack after this statement.</p>&#13;
<figure class="IMG"><img id="fig14-2" class="img50" src="../images/fig14-2.jpg" alt="" width="591" height="376"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The contents of the stack after assignment through a dereferenced pointer <a href="description-37.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> one more time in the final <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. Once again, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> is the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. This time, however, we aren’t assigning to this object or applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator to it. Therefore, we perform lvalue conversion, which results in the object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_351" aria-label="351"/>Now that you understand how <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operate on objects and values, let’s talk about conversions to and from pointer types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Null Pointers and Type Conversions</samp></h4>&#13;
<p class="TNI">An integer constant expression whose value is 0, called a <i>null pointer constant</i>, can be converted implicitly to any pointer type. The result of this conversion is a <i>null pointer</i>:</p>&#13;
<pre><code>int *null = 0;</code></pre>&#13;
<p class="TX">Because a null pointer is not a valid memory address, the result of dereferencing it is undefined. In practice, dereferencing a null pointer will likely crash your program. The C standard permits constant expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">(long) 0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">10 - 10</samp> as null pointer constants, but we’ll support only constant literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0ul</samp>. (This is the same limitation we placed on static initializers in <span class="Xref-1"><a href="chapter10.xhtml">Chapter 10</a></span>.)</p>&#13;
<p class="TX">With the exception of null pointer constants, it’s illegal to implicitly convert integers to pointers or vice versa. Consider this code snippet:</p>&#13;
<pre><code>int x = 0;&#13;
int *ptr = x;</code></pre>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it’s illegal to assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. For the same reason, it’s illegal to assign a nonzero constant to a pointer:</p>&#13;
<pre><code>int *ptr1 = 3;&#13;
int *ptr2 = 0x7ffeee67b938;</code></pre>&#13;
<p class="TX">These declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> are both illegal because <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> are integers, not pointers. Note that the type of an expression has nothing to do with whether its value is a valid memory address. Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> happens to be a valid address, the constant expression <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> is still a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> rather than a pointer.</p>&#13;
<p class="TX">It’s also illegal to implicitly convert from one pointer type to another (with the exception of conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, which I’ll introduce in <span class="Xref-1"><a href="chapter17.xhtml">Chapter 17</a></span>). For example, you can’t implicitly convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double *</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long *</samp>:</p>&#13;
<pre><code>double *d = 0;&#13;
long *l = d;</code></pre>&#13;
<p class="TX">GCC warns about the implicit conversions in the previous three code snippets, but it still compiles them. We’ll take a stricter approach and treat these implicit conversions as errors.</p>&#13;
<p class="TX">On the other hand, <i>explicit</i> casts between pointer types, and between pointer and integer types, are legal. <a href="chapter14.xhtml#list14-2">Listing 14-2</a> shows an example of an explicit cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double *</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp>.</p>&#13;
<a id="list14-2"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_352" aria-label="352"/>double negative_zero = -0.0;&#13;
double *d = &amp;negative_zero;&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> unsigned long *l = (unsigned long *) d;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: An explicit pointer type conversion</samp></p>&#13;
<p class="TX">After the explicit cast and assignment <span class="CodeAnnotation" aria-label="annotation1">❶</span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> contain the same memory address, interpreted as two different pointer types.</p>&#13;
<p class="TX">One important caveat is that dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> after this cast would result in undefined behavior. With a few exceptions, if we declare an object with some type (called its <i>effective type</i>) and then access it using an expression of a different type, the result is undefined. In other words, casting from one pointer type to another is always legal, but using the result of that cast expression may not be. In <a href="chapter14.xhtml#list14-2">Listing 14-2</a>, the effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">negative_zero</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so we can’t access it with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*l</samp>, which has type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. The complete set of rules about which types of expressions you can use to access an object—unofficially called the <i>strict aliasing rules</i>—are spelled out in section 6.5, paragraphs 6–7, of the C standard. Luckily, since we don’t need to detect undefined behavior or handle it gracefully, we can ignore these rules; our implementation will happily compile programs that violate them.</p>&#13;
<p class="TX">Finally, you can explicitly cast between pointer types and integer types. When you cast a null pointer constant to a pointer type, the result is a null pointer. When you cast any other integer to a pointer type, or any pointer to an integer type, the result is implementation-defined. On an x64 system, memory addresses are unsigned 64-bit integers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. Therefore, if you convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to a pointer (or vice versa), its value won’t change. Casting any other integer type to or from a pointer type has the same effect as casting to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. For example, if you cast a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> with value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to a pointer type, it will result in the largest representable memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>. This address is unlikely to hold a valid object, so dereferencing it will probably result in undefined behavior.</p>&#13;
<p class="TX">Casting a pointer type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a pointer type is illegal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-122"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Comparisons</samp></h4>&#13;
<p class="TNI">You can compare pointers of the same type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> operators. Two non-null pointers compare equal if they point to the same object (or just past the end of the same array, once we implement arrays). They compare unequal otherwise. A pointer to a valid object always compares unequal to a null pointer, and two null pointers always compare equal to each other. You can also use a pointer in any construct that compares an expression to zero, including logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> expressions; the condition in a conditional expression; and the controlling condition in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement or loop. In each of these cases, a null pointer counts as zero, and any non-null pointer is nonzero.</p>&#13;
<p class="TX">You can also compare pointers using the other relational operators, like <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, but we won’t support that yet. This sort of pointer comparison is most <span role="doc-pagebreak" epub:type="pagebreak" id="pg_353" aria-label="353"/>useful when you’re working with pointers to array elements, so we’ll implement it when we add arrays in the next chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-123"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">&amp; Operations on Dereferenced Pointers</samp></h4>&#13;
<p class="TNI">We saw earlier that the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator must be an lvalue. Since a dereferenced pointer is an lvalue, you can take its address with this operator, like we do in <a href="chapter14.xhtml#list14-3">Listing 14-3</a>.</p>&#13;
<a id="list14-3"/>&#13;
<pre><code>int *ptr = &amp;var;&#13;
int *ptr2 = &amp;*ptr;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Taking the address of a dereferenced pointer</samp></p>&#13;
<p class="TX">The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;*ptr</samp> is valid, but it’s not very useful. The inner expression designates the object stored at some address, and the outer expression takes the address of that object. You just end up with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which is the address you dereferenced to begin with.</p>&#13;
<p class="TX">In fact, the C standard treats <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> as a special case: section 6.5.3.2, paragraph 3, states that “neither [the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator] nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an lvalue.” In other words, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> is always the value of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp>. Usually, like in <a href="chapter14.xhtml#list14-3">Listing 14-3</a>, it doesn’t matter whether we evaluate the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operators; we end up with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> either way. The one exception is when <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> is not a valid memory address, like in <a href="chapter14.xhtml#list14-4">Listing 14-4</a>.</p>&#13;
<a id="list14-4"/>&#13;
<pre><code>int *null_ptr = 0;&#13;
int *ptr2 = &amp;*null_ptr;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Taking the address of a dereferenced null pointer</samp></p>&#13;
<p class="TX">Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> would usually cause a runtime error. However, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> expressions in <a href="chapter14.xhtml#list14-4">Listing 14-4</a> aren’t evaluated, this code is equivalent to:</p>&#13;
<pre><code>int *null_ptr = 0;&#13;
int *ptr2 = null_ptr;</code></pre>&#13;
<p class="TX">Therefore, <a href="chapter14.xhtml#list14-4">Listing 14-4</a> runs without error; it initializes both <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> as null pointers.</p>&#13;
<p class="TX">Now that we’re experts on pointer semantics, let’s start on the lexer!</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-122"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">In this chapter, you’ll add a single token:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">&amp;</samp> An ampersand, the address operator</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_354" aria-label="354"/>You already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> token to support multiplication. If you implemented the bitwise operators for extra credit in <span class="Xref-1"><a href="chapter3.xhtml">Chapter 3</a></span>, you’ve already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> token too, so you won’t need to modify the lexer at all.</p>&#13;
<aside class="box" aria-label="box-34"><p class="BoxTitle" id="box-34"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should successfully lex every test case in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-123"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Next, we’ll add pointer types and the two new pointer operators to the AST. A pointer type is constructed recursively from the type of the object it points to; <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp> are all valid types. You can also declare pointers to pointers, so <samp class="SANS_TheSansMonoCd_W5Regular_11">int **</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long ***</samp>, and so on are valid types as well. Therefore, the AST defines pointer types recursively:</p>&#13;
<pre><code>type = Int | Long | UInt | ULong | Double&#13;
     | FunType(type* params, type ret)&#13;
     <b>| Pointer(type referenced)</b></code></pre>&#13;
<p class="TX">In C, types that are built up from simpler types are called <i>derived types</i>. Pointer types and function types are both derived types. The array and structure types we’ll implement in later chapters are derived types too. The type that a pointer points to is its <i>referenced type</i>. For example, the referenced type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>&#13;
<p class="TX">We’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node to represent the dereference and address operators:</p>&#13;
<pre><code>exp = <var>--snip--</var>&#13;
    | Dereference(exp)&#13;
    | AddrOf(exp)</code></pre>&#13;
<p class="TX">Syntactically, these are both unary operators, so you can extend <samp class="SANS_TheSansMonoCd_W5Regular_11">unary _operator</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> if you want. But I think it’s easier to make them distinct expressions because we’ll handle these quite differently from the other unary operators during type checking and TACKY generation. <a href="chapter14.xhtml#list14-5">Listing 14-5</a> shows the updated AST, with this chapter’s additions bolded.</p>&#13;
<a id="list14-5"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init, type var_type, storage_class?)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_355" aria-label="355"/>function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
type = Int | Long | UInt | ULong | Double&#13;
     | FunType(type* params, type ret)&#13;
     <b>| Pointer(type referenced)</b>&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
    <b>| Dereference(exp)</b>&#13;
    <b>| AddrOf(exp)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int)&#13;
      | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The abstract syntax tree with pointer types and the dereference and address operators</samp></p>&#13;
<p class="TX">Next, we’ll update the grammar and figure out how to parse it. We can parse the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operators like any other unary operator, so we add them to the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt;</samp> grammar rule:</p>&#13;
<pre><code>&lt;unop&gt; ::= "-" | "~" | "!" <b>| "*" | "&amp;"</b></code></pre>&#13;
<p class="TX">Parsing pointer types in declarations and cast expressions is more challenging. We need an approach that we can extend to handle derived types in general, not just pointers; otherwise, we’ll have to completely rewrite it to deal with arrays in the next chapter. We’ll start by updating the parser to support derived types in declarations. Then, we’ll handle derived types in cast expressions.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_356" aria-label="356"/>&#13;
<h4 class="H2" id="sec9"><span id="h2-124"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Declarations</samp></h4>&#13;
<p class="TNI">A function or variable declaration consists of three parts: a list of specifiers, a declarator, and an optional initializer or function body. You already know what initializers and function bodies look like, so I won’t talk about them here. The specifiers are also familiar from earlier chapters: they include storage class specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, which determine the identifier’s storage class and linkage, and type specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which determine what I’ll call its <i>basic type</i>. The basic type is either the type of the identifier or the starting point for deriving its type. (This particular term doesn’t appear in the C standard, but it sometimes shows up in other discussions of C declarations.) The <i>declarator</i> is everything else: it indicates the identifier being declared and the sequence of derivations we’ll apply to the basic type. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">*var</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(int a)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">foo[3]</samp> are all declarators.</p>&#13;
<p class="TX">The simplest declarator is an identifier:</p>&#13;
<pre><code>int var;</code></pre>&#13;
<p class="TX">Here, the basic type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and the declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, so it declares a variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This declaration doesn’t include any type derivations.</p>&#13;
<p class="TX">To derive a new type, we nest a declarator like <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> inside another declarator:</p>&#13;
<pre><code>int *(var);</code></pre>&#13;
<p class="TX">Here, we have a pointer declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>, which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>. A pointer declarator takes some type <i>t</i> and derives the type “pointer to <i>t</i>,” so this declaration declares <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> with the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Note that C’s syntax allows us to wrap any declarator in parentheses. I’ve wrapped <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> in parentheses to make the nesting here explicit, but the declaration has the same meaning if we omit them:</p>&#13;
<pre><code>int *var;</code></pre>&#13;
<p class="TX">We use multiple layers of nested declarators to specify multiple type derivations; these are applied from the outside in to determine the final type. The innermost declarator is always a plain identifier. Here’s an example with three nested declarators:</p>&#13;
<pre><code>int *(*(var));</code></pre>&#13;
<p class="TX">The full declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*(var))</samp>, which contains <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>, which contains <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>. As in the previous example, the parentheses in this declarator have no effect; I’ve just included them for clarity.</p>&#13;
<p class="TX">Let’s walk through the type derivations here. Working from the outside in, we start with the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Next, we see a pointer declarator, so we derive the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Then, we see another pointer declarator, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_357" aria-label="357"/>so we derive “pointer to pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Finally, we encounter the identifier, which completes the declaration but doesn’t add any type information. We end up with a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> whose type is “pointer to pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”</p>&#13;
<p class="TX">The other two kinds of declarators are <i>function declarators</i>, which we already support, and <i>array declarators</i>, which we’ll add in the next chapter. A function declarator takes a type <i>t</i> and derives the type “function returning <i>t</i>.” Let’s break down a function declaration:</p>&#13;
<pre><code>int foo(void);</code></pre>&#13;
<p class="TX">The full declarator here is <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(void)</samp>, which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Parenthesizing each declarator gives us the following equivalent declaration:</p>&#13;
<pre><code>int ((foo)(void));</code></pre>&#13;
<p class="TX">We start with the basic type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The outer declarator tells us to derive the type “function returning <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” and the inner declarator indicates that we’re declaring the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Of course, a function declarator also declares the function’s parameters. Each parameter, much like a declaration, includes a basic type and a declarator:</p>&#13;
<pre><code>int foo(int a, int *b);</code></pre>&#13;
<p class="TX">As we already know, a parameter list of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">(void)</samp> is a special case: it declares that the function has no parameters.</p>&#13;
<p class="TX">Finally, an array declarator starts with type <i>t</i> and derives the type “array of <i>n</i> elements of type <i>t</i>.” For example, the following code includes the declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[3]</samp>, which has a nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>:</p>&#13;
<pre><code>int arr[3];</code></pre>&#13;
<p class="TX">This declares that <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is an array of three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>&#13;
<p class="TX">More complicated declarations can include a mix of nested pointer, array, and function declarators. The function and array declarators, which we indicate with postfix expressions, have higher precedence than the pointer declarator, so</p>&#13;
<pre><code>int *arr[3];</code></pre>&#13;
<p class="BodyContinued">is equivalent to:</p>&#13;
<pre><code>int *(arr[3]);</code></pre>&#13;
<p class="TX">To interpret this declaration, we start with <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, apply the outer pointer declarator to derive “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” apply the inner array declarator to derive “array of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” and end with the innermost <span role="doc-pagebreak" epub:type="pagebreak" id="pg_358" aria-label="358"/>declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. To declare a pointer to an array instead, we override this precedence with parentheses:</p>&#13;
<pre><code>int (*arr)[3];</code></pre>&#13;
<p class="TX">Along the same lines, this declaration declares a pointer to a function with a single parameter:</p>&#13;
<pre><code>int (*fptr)(int a);</code></pre>&#13;
<p class="TX">Function pointers are legal in C, but we won’t implement them in this book. You can also nest declarators to specify types that are straight-up illegal. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo(void)(void);</samp> declares a function that returns a function that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This declaration is syntactically well formed but semantically invalid; a function can’t return another function.</p>&#13;
<p class="TX">Now that you understand the basic syntax of declarators, we’re ready to write grammar rules for them. For the full description of declarators, see section 6.7.6 of the C standard. I also recommend “Reading C Type Declarations” by Steve Friedl, which describes their syntax in a more comprehensible way than the standard does (<i><a href="http://unixwiz.net/techtips/reading-cdecl.html">http://<wbr/>unixwiz<wbr/>.net<wbr/>/techtips<wbr/>/reading<wbr/>-cdecl<wbr/>.html</a></i>).</p>&#13;
<p class="TX">Since declarators have several precedence levels, we need several grammar rules to define their syntax. At the highest precedence level, a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;simple-declarator&gt;</samp> is a single identifier or parenthesized declarator:</p>&#13;
<pre><code>&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"</code></pre>&#13;
<p class="TX">At the next precedence level, we have what the C grammar calls <i>direct declarators</i>, including function and array declarators. We support only function declarators in this chapter:</p>&#13;
<pre><code>&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;param-list&gt;]&#13;
&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"&#13;
&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;</code></pre>&#13;
<p class="TX">In the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;direct-declarator&gt;</samp>, a direct declarator may be either a simple declarator or a function declarator, indicated by the presence of a parameter list. Notice that we’ve changed <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp> a bit from previous chapters, refactoring this symbol to include the parentheses around the parameter list and moving the definition of a single parameter into a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param&gt;</samp> symbol. Most importantly, the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param&gt;</samp> now includes a declarator instead of a plain identifier. This lets us parse parameters with pointer types (and eventually with array types as well). Finally, we’ll define a top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator&gt;</samp> that includes pointer declarators:</p>&#13;
<pre><code>&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_359" aria-label="359"/>Unfortunately, this grammar doesn’t really correspond with our AST definition. One minor problem is that it allows us to specify types we don’t support, including function pointers, functions that return functions, and functions that take other functions as arguments. A more serious problem is that in our grammar, type derivations are applied from the outside in, but in the AST definition, they’re applied from the inside out. Let’s revisit a declaration we looked at earlier:</p>&#13;
<pre><code>int (*arr)[3];</code></pre>&#13;
<p class="TX">We want to parse this declaration and construct the type “pointer to array of three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” What happens if we try to construct this type using recursive descent parsing? First, we’ll encounter the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Then, we’ll see an open parenthesis, which indicates the start of a direct declarator. Inside that direct declarator, we’ll find a pointer declarator—and then we’ll be stuck. We should derive a pointer type, but a pointer to what? The basic type we’ve seen so far is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, but “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>” is incorrect. Because type derivations are applied from the outside in, we ought to derive the array type first. But we can’t, because the parser has to consume the inner, parenthesized declarator before it can reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> that specifies the array type.</p>&#13;
<p class="TX">We get stuck here because the order in which we can recognize grammar symbols doesn’t match the order in which we apply type derivations. When we parse a declaration, we can’t derive its type as we go. Instead, we’ll first parse each declarator to a one-off representation that more closely mirrors the grammar, like the one in <a href="chapter14.xhtml#list14-6">Listing 14-6</a>.</p>&#13;
<a id="list14-6"/>&#13;
<pre><code>declarator = Ident(identifier)&#13;
           | PointerDeclarator(declarator)&#13;
           | FunDeclarator(param_info* params, declarator)&#13;
param_info = Param(type, declarator)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Representing the syntax of a declarator</samp></p>&#13;
<p class="TX">We can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> construct with standard recursive descent parsing, following the grammar rules we just introduced.</p>&#13;
<p class="TX">The next step is to traverse that <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> and derive all the information we’ll use to construct an AST node: the declaration’s type, its identifier, and the identifiers of any parameters. At every layer, we’ll apply the appropriate type derivation, then recursively handle the inner declarator. <a href="chapter14.xhtml#list14-7">Listing 14-7</a> presents the pseudocode for this step.</p>&#13;
<a id="list14-7"/>&#13;
<pre><code>process_declarator(declarator, base_type):&#13;
    match declarator with&#13;
    | Ident(name) -&gt; return (name, base_type, []) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    | PointerDeclarator(d) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        derived_type = Pointer(base_type)&#13;
        return process_declarator(d, derived_type)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_360" aria-label="360"/>    | FunDeclarator(params, d) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        match d with&#13;
        | Ident(name) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            param_names = []&#13;
            param_types = []&#13;
            for Param(p_base_type, p_declarator) in params: <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
                param_name, param_t, _ = process_declarator(p_declarator, p_base_type)&#13;
                if param_t is a function type:&#13;
                    fail("Function pointers in parameters aren't supported")&#13;
                param_names.append(param_name)&#13;
                param_types.append(param_t)&#13;
&#13;
            derived_type = FunType(param_types, base_type)&#13;
            return (name, derived_type, param_names)&#13;
        | _ -&gt; fail("Can't apply additional type derivations to a function type")</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Deriving type and identifier information from a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">declarator</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> function takes two arguments. The first is the declarator itself. The second, <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>, is the type we’ve derived so far. Initially, this will be the basic type indicated by the list of specifiers at the start of the declaration. For example, if we were processing the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">double **fun(int x)</samp>, we’d start with a <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp> of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> will be a tuple of three values: the declaration’s identifier, its derived type, and the names of any parameters. If the declaration declares a variable, or if it declares a function with no parameters, the list of parameter names will be empty. Using these three values, we’ll be able to construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST node.</p>&#13;
<p class="TX">Let’s walk through how to extract these values from a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> construct. In the simplest case, the declarator is an identifier <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We don’t need to apply any type derivations or introduce any parameters, so we return the identifier, the unchanged <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>, and an empty list of parameter names. For example, while processing the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int x;</samp>, we’d immediately reach this case and return <samp class="SANS_TheSansMonoCd_W5Regular_11">("x", Int, [])</samp>.</p>&#13;
<p class="TX">In the second case, we handle pointer declarators <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In this case, we derive a pointer type from <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> recursively on the type we just derived and the inner declarator that still needs to be processed.</p>&#13;
<p class="TX">In the last case, we handle function declarators <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This case is a little different because the inner declarator must be a plain identifier. If it’s another function declarator, we’ll end up with a function that returns a function, which isn’t legal. If it’s a pointer declarator, we’ll end up with a function pointer, which we aren’t implementing. Therefore, we validate that the inner declarator is a plain identifier instead of parsing it recursively <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Assuming the inner declarator is valid, the next step is figuring out the function type and parameter names. We’ll iterate over the parameters in the declarator, recursively calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> to get the type and name of each one <span class="CodeAnnotation" aria-label="annotation5">❺</span>. While we’re at it, we’ll validate that none of these function parameters are functions themselves. (The C standard actually lets you declare parameters with function type, but it requires the compiler to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_361" aria-label="361"/>implicitly adjust them to function pointer type. Since we don’t support function pointers, we’ll reject them.) Once we’ve handled every parameter, we construct the whole function type and return all the relevant information about this declaration.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#list14-8">Listing 14-8</a> shows how to put all the pieces together to parse an entire declaration.</p>&#13;
<a id="list14-8"/>&#13;
<pre><code>parse_declaration(tokens):&#13;
    specifiers = parse_specifier_list(tokens)&#13;
    base_type, storage_class = parse_type_and_storage_class(specifiers)&#13;
    declarator = parse_declarator(tokens)&#13;
    name, decl_type, params = process_declarator(declarator, base_type)&#13;
    if decl_type is a function type:&#13;
<var>        &lt;construct function_declaration&gt;</var>&#13;
    else:&#13;
<var>        &lt;construct variable_declaration&gt;</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Parsing an entire declaration</samp></p>&#13;
<p class="TX">We first determine the declaration’s base type in the usual way: we consume a list of specifiers from <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>, then convert those specifiers to a type and storage class. Next, we parse the declarator, and then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">process _declarator</samp> to determine its complete type and name. Finally, we examine the resulting type to determine whether it’s a function or variable declaration and parse the rest of the declaration accordingly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-125"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type Names</samp></h4>&#13;
<p class="TNI">Pointer types can also appear in cast expressions:</p>&#13;
<pre><code>int *result_of_cast = (int *) exp;</code></pre>&#13;
<p class="TX">But you can’t use a declarator in a cast expression, because a declarator must contain an identifier. C syntax solves this problem with <i>abstract declarators</i>, which are declarators without identifiers. We’ll add abstract pointer declarators now and abstract array declarators in the next chapter. (We won’t need abstract function declarators, because they’re used only to specify function pointers.)</p>&#13;
<p class="TX">An abstract declarator might be a sequence of one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> tokens, indicating a sequence of pointer type derivations:</p>&#13;
<pre><code>(int ***) exp;</code></pre>&#13;
<p class="TX">Abstract declarators can be parenthesized, like their non-abstract counterparts:</p>&#13;
<pre><code>(int (*)) exp;</code></pre>&#13;
<p class="TX">And an outer abstract declarator can contain an inner parenthesized one:</p>&#13;
<pre><code>(int *(*)) exp;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_362" aria-label="362"/>The parentheses are pointless at the moment. They’ll be more useful when we add arrays in the next chapter. For example, the expression</p>&#13;
<pre><code>(int *[3]) exp;</code></pre>&#13;
<p class="BodyContinued">casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to an array of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> because the abstract array declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp> is parsed with higher precedence. This cast expression is illegal because you can’t cast expressions to array type. On the other hand, this expression is fine:</p>&#13;
<pre><code>(int (*)[3]) exp;</code></pre>&#13;
<p class="TX">This casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to a pointer to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> elements; the parenthesized pointer declarator has higher precedence, so the array declarator is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> first.</p>&#13;
<p class="TX">We define abstract declarators using two grammar rules:</p>&#13;
<pre><code>&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]&#13;
                        | &lt;direct-abstract-declarator&gt;&#13;
&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")"</code></pre>&#13;
<p class="TX">An <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;abstract-declarator&gt;</samp>, like a regular <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator&gt;</samp>, consists of either a pointer declarator or a direct declarator. The key difference between the two is that in an abstract pointer declarator, the inner declarator is optional. In other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> by itself is a valid abstract declarator but not a valid regular declarator.</p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;direct-abstract-declarator&gt;</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;abstract-declarator&gt;</samp> wrapped in parentheses. In the next chapter, this symbol will cover abstract array declarators too. We’ll parse abstract declarators to a one-off <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp> structure, like we did with normal declarators. <a href="chapter14.xhtml#list14-9">Listing 14-9</a> defines this structure.</p>&#13;
<a id="list14-9"/>&#13;
<pre><code>abstract_declarator = AbstractPointer(abstract_declarator)&#13;
                    | AbstractBase</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Representing the syntax of an abstract declarator</samp></p>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractBase</samp> represents the base case, where a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> token isn’t followed by an inner declarator. For example, we’d parse the abstract declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*)</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractPointer(AbstractPointer(AbstractBase))</samp>. At the moment, <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract _declarator</samp> just tells us how many layers of pointer indirection we found (two, in this example). This is a fairly elaborate way to convey a single number, but it lays the groundwork for array declarators in the next chapter.</p>&#13;
<p class="TX">The type name in a cast expression is a sequence of type specifiers followed by an optional abstract declarator, all wrapped in parentheses:</p>&#13;
<pre><code>&lt;factor&gt; ::=<var> --snip--</var>&#13;
           | "(" {&lt;type-specifier&gt;}+<b> [&lt;abstract-declarator&gt;] </b>")" &lt;factor&gt;&#13;
           |<var> --snip--</var></code></pre>&#13;
<p class="TX">To handle cast expressions, you’ll need a <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract_declarator</samp> function, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> from <a href="chapter14.xhtml#list14-7">Listing 14-7</a>, to convert a basic <span role="doc-pagebreak" epub:type="pagebreak" id="pg_363" aria-label="363"/>type and an <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp> into a derived type. This function will be simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>; it won’t deal with function declarators and it will return only a type, not an identifier or a list of parameters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-126"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp></h4>&#13;
<p class="TNI">We’ve covered every change we’ll make to the parser. <a href="chapter14.xhtml#list14-10">Listing 14-10</a> shows the full grammar, with this chapter’s changes bolded.</p>&#13;
<a id="list14-10"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+<b> &lt;declarator&gt; </b>["=" &lt;exp&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+<b> &lt;declarator&gt; </b>(&lt;block&gt; | ";")&#13;
<b>&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;</b>&#13;
<b>&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;param-list&gt;]</b>&#13;
<b>&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"</b>&#13;
<b>&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;</b>&#13;
<b>&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"</b>&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" | "double"&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;const&gt; | &lt;identifier&gt;&#13;
           | "(" {&lt;type-specifier&gt;}+<b> [&lt;abstract-declarator&gt;] </b>")" &lt;factor&gt;&#13;
           | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
<b>&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]</b>&#13;
<b>                        | &lt;direct-abstract-declarator&gt;</b>&#13;
<b>&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")"</b>&#13;
&lt;unop&gt; ::= "-" | "~" | "!" <b>| "*" | "&amp;"</b>&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; | &lt;double&gt;&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
&lt;double&gt; ::= ? A floating-point constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: The grammar with pointer types and the dereference and address operators</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_364" aria-label="364"/>We’ve made three major changes to the grammar. First, we’re using the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;declarator&gt;</samp> symbol instead of simple identifiers in function, variable, and parameter declarations. Second, we use the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;abstract -declarator&gt;</samp> symbol to specify pointer types in cast expressions. Third, we’ve added the new unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operators.</p>&#13;
<aside class="box" aria-label="box-35"><p class="BoxTitle" id="box-35"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_14/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">validate that your compiler rejects malformed declarators and abstract declarators. They don’t test whether your compiler rejects function pointers. If you want to be really ambitious and implement function pointers on your own, you can still use these tests.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-124"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">On to semantic analysis! We’ll extend the type checker to validate expressions that involve pointers and infer the types of these expressions. The identifier resolution pass will change a little bit too; we’ll move one piece of validation from this pass into the type checker.</p>&#13;
<p class="TX">We need to detect three kinds of type errors:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Applying an operator to a type it doesn’t support. For example, you can’t multiply or divide pointers, and you can’t dereference arithmetic values.</li>&#13;
<li class="NL">Operating on values of two incompatible types. This includes errors like trying to compare a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We run into this kind of error because C generally doesn’t allow implicit conversions to and from pointer types, the way it does for arithmetic types.</li>&#13;
<li class="NL">Not using an lvalue where one is required. We already require the left side of an assignment expression to be an lvalue. Now we’ll require the operand of an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression to be an lvalue too. We’ll also expand our definition of lvalue to include dereferenced pointers as well as variables.</li>&#13;
</ol>&#13;
<p class="TX">This third kind of error is the one we currently handle during identifier resolution. Remove this validation from the identifier resolution pass now; you’ll add it to the type checker in a moment. (While you’re at it, make sure the identifier resolution pass traverses the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_365" aria-label="365"/>and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions.) Next, we’ll update the logic to type check expressions.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-127"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Pointer Expressions</samp></h4>&#13;
<p class="TNI">We need to tweak how we type check almost every expression we support. Let’s start with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions. Then, we’ll update the type checking logic for our existing constructs.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dereference and AddrOf Expressions</samp></h5>&#13;
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression must take an operand of pointer type. It produces a result with its operand’s referenced type (the type it points to). <a href="chapter14.xhtml#list14-11">Listing 14-11</a> demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression and annotate it with the correct result type.</p>&#13;
<a id="list14-11"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Dereference(inner) -&gt;&#13;
        typed_inner = typecheck_exp(inner, symbols)&#13;
        match get_type(typed_inner) with&#13;
        | Pointer(referenced_t) -&gt;&#13;
            deref_exp = Dereference(typed_inner)&#13;
            return set_type(deref_exp, referenced_t)&#13;
        | _ -&gt; fail("Cannot dereference non-pointer")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Type checking a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp></p>&#13;
<p class="TX">We start by type checking the expression’s operand, as usual. Then, we look up the operand’s type. If it’s a pointer to some type, <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp>, we set <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp> as the result type of the whole expression. Otherwise, we throw an error.</p>&#13;
<p class="TX">To type check an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression, we first check that its operand is an lvalue (that is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression). Then, we record its result type, which is a pointer to the type of its operand. <a href="chapter14.xhtml#list14-12">Listing 14-12</a> demonstrates how to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>.</p>&#13;
<a id="list14-12"/>&#13;
<pre><code>    | AddrOf(inner) -&gt;&#13;
        if inner is an lvalue:&#13;
            typed_inner = typecheck_exp(inner, symbols)&#13;
            referenced_t = get_type(typed_inner)&#13;
            addr_exp = AddrOf(typed_inner)&#13;
            return set_type(addr_exp, Pointer(referenced_t))&#13;
        else:&#13;
            fail("Can't take the address of a non-lvalue!")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: Type checking an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp></p>&#13;
<p class="TX">Next, we’ll type check pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>. (We’ll deal with other pointer comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_366" aria-label="366"/>the other relational operators in <span class="Xref-1"><a href="chapter15.xhtml">Chapter 15</a></span>.) We’ll also handle conditional expressions, which follow similar typing rules.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparisons and Conditional Expressions</samp></h5>&#13;
<p class="TNI">As you learned in earlier chapters, both operands in a comparison must have the same type, or at least be implicitly converted to the same type. However, we can’t perform implicit conversions to or from pointer types. Therefore, if either operand to an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> operation is a pointer, we require the types of both operands to be the same. At the moment, null pointer constants are the one exception to this rule; they’re the only expressions that we can implicitly convert to a pointer type. (Once we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we’ll also permit implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and other pointer types.)</p>&#13;
<p class="TX">For example, this code snippet compares a pointer to a null pointer constant:</p>&#13;
<pre><code>double *d = get_pointer();&#13;
return d == 0;</code></pre>&#13;
<p class="TX">When we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> in this example, we implicitly cast <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to a null pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double *</samp>. <a href="chapter14.xhtml#list14-13">Listing 14-13</a> defines a helper function to identify null pointer constants.</p>&#13;
<a id="list14-13"/>&#13;
<pre><code>is_null_pointer_constant(e):&#13;
    match e with&#13;
    | Constant(c) -&gt;&#13;
        match c with&#13;
        | ConstInt(0) -&gt; return True&#13;
        | ConstUInt(0) -&gt; return True&#13;
        | ConstLong(0) -&gt; return True&#13;
        | ConstULong(0) -&gt; return True&#13;
        | _ -&gt; return False&#13;
    | _ -&gt; return False</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Checking whether an expression is a null pointer constant</samp></p>&#13;
<p class="TX">This function captures our three requirements for an expression to count as a null pointer constant: it must be a constant literal, it must be an integer, and its value must be 0. (Remember that we’re defining null pointer constants more narrowly than the C standard does; the standard permits more complex constant expressions as well as constant literals.)</p>&#13;
<p class="TX"><a href="chapter14.xhtml#list14-14">Listing 14-14</a> defines another helper function to determine whether two expressions, at least one of which results in a pointer, have compatible types.</p>&#13;
<a id="list14-14"/>&#13;
<pre><code>get_common_pointer_type(e1, e2):&#13;
    e1_t = get_type(e1)&#13;
    e2_t = get_type(e2)&#13;
    if e1_t == e2_t:&#13;
        return e1_t&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_367" aria-label="367"/>    else if is_null_pointer_constant(e1):&#13;
        return e2_t&#13;
    else if is_null_pointer_constant(e2):&#13;
        return e1_t&#13;
    else:&#13;
        fail("Expressions have incompatible types")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Getting the common type of two expressions, where at least one has pointer type</samp></p>&#13;
<p class="TX">When an expression that operates on pointers expects both its operands to have the same type, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> will determine what that type should be. If its arguments have different types and neither of them is a null pointer constant, they’re incompatible, so we throw an error.</p>&#13;
<p class="TX">Now that we’ve defined <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>, we’re finally ready to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expressions. <a href="chapter14.xhtml#list14-15">Listing 14-15</a> demonstrates how to type check an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expression; we’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> the same way.</p>&#13;
<a id="list14-15"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Binary(Equal, e1, e2) -&gt;&#13;
        typed_e1 = typecheck_exp(e1, symbols)&#13;
        typed_e2 = typecheck_exp(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 or t2 is a pointer type:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> common_type = get_common_pointer_type(typed_e1, typed_e2)&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> common_type = get_common_type(t1, t2)&#13;
        converted_e1 = convert_to(typed_e1, common_type)&#13;
        converted_e2 = convert_to(typed_e2, common_type)&#13;
        equality_exp = Binary(Equal, converted_e1, converted_e2)&#13;
        return set_type(equality_exp, Int)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Type checking an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp></p>&#13;
<p class="TX">This follows the usual pattern for type checking comparisons: we type check both operands, find their common type, convert them both to that type, and then set the type of the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>. The key change from earlier chapters is how we find the common type. If either operand is a pointer, we use the helper function that we just defined <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, we’ll stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">When we convert two operands to a common pointer type, we’ll see one of three possible outcomes:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Both operands already have the same type, so neither <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> call has any effect.</li>&#13;
<li class="NL">One operand is a null pointer constant, which we implicitly convert to the other operand’s type.</li>&#13;
<li class="NL">The operands have incompatible types, so <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> throws an error.</li>&#13;
</ol>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_368" aria-label="368"/>We’ll use similar logic to type check conditional expressions. The second and third operands in the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause2&gt;</samp> are subject to the same type constraints as the operands in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expression. If either one is a pointer, we’ll validate both operands and find their common type using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>, then convert them to that type. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp> expression can be either a pointer or an arithmetic value, since we can compare it to zero either way.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assignment and Conversion as if by Assignment</samp></h5>&#13;
<p class="TNI">Next, we’ll handle assignment expressions. We first validate that the left-hand side of an assignment expression is an lvalue. Then, we convert the value on the right side of the expression to the type of the object on the left, or fail if the conversion is illegal. What the C standard calls type conversion “as if by assignment” turns up in a few places, not just in assignment expressions, so we’ll write yet another helper function to handle it. <a href="chapter14.xhtml#list14-16">Listing 14-16</a> defines this helper function.</p>&#13;
<a id="list14-16"/>&#13;
<pre><code>convert_by_assignment(e, target_type):&#13;
    if get_type(e) == target_type:&#13;
        return e&#13;
    if get_type(e) is arithmetic and target_type is arithmetic:&#13;
        return convert_to(e, target_type)&#13;
    if is_null_pointer_constant(e) and target_type is a pointer type:&#13;
        return convert_to(e, target_type)&#13;
    else:&#13;
        fail("Cannot convert type for assignment")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Converting an expression to a target type as if by assignment</samp></p>&#13;
<p class="TX">The rules here are unsurprising: we can assign a value to an object of the same type, we can implicitly convert any arithmetic type to any other arithmetic type, and we can implicitly convert a null pointer constant to any pointer type. Otherwise, we’ll raise an error.</p>&#13;
<p class="TX">We’ll use this helper function to convert the right side of assignment expressions and in a few other spots too. To type check a function call, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> to convert each argument to the type of the corresponding parameter. We’ll also use it to convert variable initializers to the correct type and to detect initializers with invalid types, like the following:</p>&#13;
<pre><code>int *d = 2.0;</code></pre>&#13;
<p class="TX">Finally, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> to convert the value in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement to the function’s return type and detect functions that return the wrong type, like <a href="chapter14.xhtml#list14-17">Listing 14-17</a>.</p>&#13;
<a id="list14-17"/>&#13;
<pre><code>int *bad_pointer(void) {&#13;
    return 2.0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: A function that returns a value with an incompatible type</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_369" aria-label="369"/>Later, when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we’ll extend both <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> to accept implicit conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Expressions</samp></h5>&#13;
<p class="TNI">We still need to deal with cast expressions, unary operators, and binary operators besides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>. Let’s start with casts. As you learned earlier, it’s illegal to cast a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a pointer. If your type checker encounters this kind of cast, it should throw an error. Otherwise, it can handle casts to and from pointer types exactly like any other cast expression.</p>&#13;
<p class="TX">Next, we’ll handle unary operators. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> operator to a pointer is illegal, since negating or taking the bitwise complement of a memory address won’t produce a meaningful result. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> operator to a pointer is fine, since it makes sense to compare a memory address to zero.</p>&#13;
<p class="TX">Binary operators deal with pointers in several different ways. First, we have the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp> operators. The type checking logic for these operators won’t change. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>, they both accept pointers. Since they don’t convert their operands to a common type, they can operate on any combination of pointer and arithmetic operands.</p>&#13;
<p class="TX">The arithmetic <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp> operators, on the other hand, don’t accept pointers. Applying any of these to an operand of pointer type should produce an error. Pointer addition and subtraction are legal, as are pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, but we won’t implement them until the next chapter. They won’t come up in this chapter’s tests. For now, your compiler can either assume it will never see these expressions or explicitly reject them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-128"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking Static Pointer Initializers in the Symbol Table</samp></h4>&#13;
<p class="TNI">Now let’s talk about static initializers. Static variables of pointer type, like non-static variables, can be initialized to null pointers:</p>&#13;
<pre><code>static int *ptr = 0;</code></pre>&#13;
<p class="TX">We therefore need a way to represent a null pointer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> in the symbol table. Rather than defining a dedicated construct for null pointers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp> initializer, since pointers are unsigned 64-bit integers.</p>&#13;
<p class="TX">It’s also legal to initialize static variables of pointer type with the address of other static variables:</p>&#13;
<pre><code>static int a;&#13;
static int *a_ptr = &amp;a;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_370" aria-label="370"/>However, our implementation won’t support this sort of static initializer; we’ve already decided that constant literals are the only static initializers we’ll accept.</p>&#13;
<aside class="box" aria-label="box-36"><p class="BoxTitle" id="box-36"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your type checker, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_14/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">cover all the type errors we discussed in this section, including invalid implicit type conversions, explicit casts between pointer types and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp><samp class="SANS_Futura_Std_Book_11">, using pointers in arithmetic operations that don’t support them, dereferencing things that aren’t pointers, and taking the address of or assigning to things that aren’t lvalues. They don’t cover the operations that we’re going to implement in the next chapter, like pointer addition, subtraction, and the remaining relational operators.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-125"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We’ll introduce three new TACKY instructions that operate on pointers in this chapter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, corresponds to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> operator in the AST:</p>&#13;
<pre><code>GetAddress(val src, val dst)</code></pre>&#13;
<p class="TX">This instruction copies the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>—which must be a variable, not a constant—into <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>. We’ll also add two instructions to dereference pointers:</p>&#13;
<pre><code>Load(val src_ptr, val dst)&#13;
Store(val src, val dst_ptr)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction takes a memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">src_ptr</samp>, as its source operand. It retrieves the current value at that memory address and copies it to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction takes a memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp>, as its destination operand and writes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> to that address. <a href="chapter14.xhtml#list14-18">Listing 14-18</a> defines the complete TACKY IR, with the three new instructions bolded.</p>&#13;
<a id="list14-18"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init init)&#13;
instruction = Return(val)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_371" aria-label="371"/>            | DoubleToInt(val src, val dst)&#13;
            | DoubleToUInt(val src, val dst)&#13;
            | IntToDouble(val src, val dst)&#13;
            | UIntToDouble(val src, val dst)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            <b>| GetAddress(val src, val dst)</b>&#13;
            <b>| Load(val src_ptr, val dst)</b>&#13;
            <b>| Store(val src, val dst_ptr)</b>&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Adding pointer operations to TACKY</samp></p>&#13;
<p class="TX">It’s tricky to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to TACKY, because these conversions depend on context. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression can be used in one of three ways: you can lvalue convert it, assign to it, or take its address. We’ll produce different TACKY instructions in each of these three cases. Similarly, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> one way if its operand is a variable and a different way if its operand is a dereferenced pointer. First, let’s see what instructions we should generate in each case. Then, I’ll present a strategy for TACKY conversion that minimizes the number of special cases we need to handle.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-129"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Operations in TACKY</samp></h4>&#13;
<p class="TNI">To dereference a pointer and then lvalue convert the result, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. In this case, we can translate the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> to <a href="chapter14.xhtml#list14-19">Listing 14-19</a>.</p>&#13;
<a id="list14-19"/>&#13;
<pre><code><var>&lt;instructions for exp&gt;</var>&#13;
ptr =<var> &lt;result of exp&gt;</var>&#13;
result = Load(ptr)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: The TACKY implementation of a pointer dereference that undergoes lvalue conversion</samp></p>&#13;
<p class="TX">We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> when we want to assign to a dereferenced pointer instead of lvalue converting it. We’ll translate an assignment expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;left&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;right&gt;</samp> to <a href="chapter14.xhtml#list14-20">Listing 14-20</a>.</p>&#13;
<a id="list14-20"/>&#13;
<pre><code><var>&lt;instructions for left&gt;</var>&#13;
ptr =<var> &lt;result of left&gt;</var>&#13;
<var>&lt;instructions for right&gt;</var>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_372" aria-label="372"/>result =<var> &lt;result of right&gt;</var>&#13;
Store(result, ptr)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: The TACKY implementation of a pointer dereference on the left-hand side of an assignment expression</samp></p>&#13;
<p class="TX">We first calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which is the address of some object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>, which is the value we want to assign to that object. Then, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> to perform the assignment. Note that the single <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction here implements both the deference and assignment operations from the original expression.</p>&#13;
<p class="TX">Finally, let’s consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression. If its operand is a variable, we’ll get a pointer to it with <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>. Therefore, we’ll translate <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;var</samp> to:</p>&#13;
<pre><code>result = GetAddress(var)</code></pre>&#13;
<p class="TX">But if the operand is a dereferenced pointer, neither the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> nor the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression is evaluated. When we see an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp>, we’ll translate only the inner <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp> to TACKY.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-130"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Strategy for TACKY Conversion</samp></h4>&#13;
<p class="TNI">To manage all these different cases, we’ll use two different functions to convert expressions to TACKY. The first is our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> function. This function will no longer return a TACKY operand. Instead, it will return a new construct, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>, which represents an expression result that hasn’t been lvalue converted. The second function, <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>, will call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, lvalue convert the result (if it’s an lvalue rather than a constant), and return it as a TACKY operand. In most contexts, we’ll process expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>. But to process expressions that shouldn’t be lvalue converted—like the left-hand side of assignment expressions—we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> directly.</p>&#13;
<p class="TX">First, let’s define <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>:</p>&#13;
<pre><code>exp_result = PlainOperand(val) | DereferencedPointer(val)</code></pre>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> represents the object designated by a dereferenced pointer, as the name suggests. It takes a single argument: a TACKY operand of pointer type. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp> represents an ordinary constant or variable. Its argument is a TACKY operand of any type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp> construct isn’t a TACKY operand itself, so it doesn’t appear in TACKY instructions. It just helps us process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> and assignment expressions, which operate on objects instead of values. For each of these expressions, we’ll generate different instructions depending on whether its operand is a dereferenced pointer or a normal variable. In later chapters, we’ll add more operators that dereference pointers, like array subscripting and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator to access structure members. At that point, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> constructor will be especially useful because it will let us represent the results of all of these different operators in a uniform way.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_373" aria-label="373"/>Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>. We’ll make a couple of changes throughout this function. First, wherever we currently call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively on a subexpression—except on the left-hand side of an assignment expression— we’ll instead call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>. This function will convert the subexpression to TACKY and then lvalue convert the result. Second, wherever we currently return a TACKY operand, we’ll wrap that operand in a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp> constructor. <a href="chapter14.xhtml#list14-21">Listing 14-21</a> shows how to handle unary expressions, with this chapter’s changes bolded.</p>&#13;
<a id="list14-21"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Unary(op, inner) -&gt;&#13;
        src = <b>emit_tacky_and_convert</b>(inner, instructions, symbols)&#13;
        dst = make_tacky_variable(get_type(e), symbols)&#13;
        tacky_op = convert_unop(op)&#13;
        instructions.append(Unary(tacky_op, src, dst))&#13;
        return <b>PlainOperand</b>(dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Translating a unary expression to TACKY</samp></p>&#13;
<p class="TX">We’ll make the same changes for every kind of expression that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> currently handles.</p>&#13;
<p class="TX">Next, let’s deal with <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expressions. <a href="chapter14.xhtml#list14-22">Listing 14-22</a> demonstrates how to handle these in <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>.</p>&#13;
<a id="list14-22"/>&#13;
<pre><code>    | Dereference(inner) -&gt;&#13;
        result = emit_tacky_and_convert(inner, instructions, symbols)&#13;
        return DereferencedPointer(result)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Translating a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp></p>&#13;
<p class="TX">To process this expression, we first process and lvalue convert its operand. This produces a TACKY operand of pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>. Then, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> to represent the object <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> points to.</p>&#13;
<p class="TX">After <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>, we either assign to it, get its address, or lvalue convert it. <a href="chapter14.xhtml#list14-23">Listing 14-23</a> illustrates how to handle assignment.</p>&#13;
<a id="list14-23"/>&#13;
<pre><code>    | Assignment(left, right) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> lval = emit_tacky(left, instructions, symbols)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> rval = emit_tacky_and_convert(right, instructions, symbols)&#13;
        match lval with&#13;
        | PlainOperand(obj) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> instructions.append(Copy(rval, obj))&#13;
            return lval&#13;
        | DereferencedPointer(ptr) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> instructions.append(Store(rval, ptr))&#13;
            return PlainOperand(rval)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Translating an assignment expression to TACKY</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_374" aria-label="374"/>We don’t lvalue convert the left side of the assignment expression <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but we do lvalue convert the right side <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the left side is a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, like in earlier chapters <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction to write to the location that the inner pointer indicates <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Note that even when we assign through a pointer, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp> as the result. That’s because the result of an assignment expression is the value stored in the object on the left-hand side, not the object itself.</p>&#13;
<p class="TX">We use a similar pattern to process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>. <a href="chapter14.xhtml#list14-24">Listing 14-24</a> gives the pseudocode.</p>&#13;
<a id="list14-24"/>&#13;
<pre><code>    | AddrOf(inner) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> v = emit_tacky(inner, instructions, symbols)&#13;
        match v with&#13;
        | PlainOperand(obj) -&gt;&#13;
            dst = make_tacky_variable(get_type(e), symbols)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> instructions.append(GetAddress(obj, dst))&#13;
            return PlainOperand(dst)&#13;
        | DereferencedPointer(ptr) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return PlainOperand(ptr)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Translating an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp></p>&#13;
<p class="TX">We process the expression’s operand without lvalue converting it <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then pattern match on the result to decide how to proceed. If it’s a normal value, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it’s a dereferenced pointer, we drop the dereference and return the pointer <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Finally, in <a href="chapter14.xhtml#list14-25">Listing 14-25</a>, we define <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>, which performs lvalue conversions.</p>&#13;
<a id="list14-25"/>&#13;
<pre><code>emit_tacky_and_convert(e, instructions, symbols):&#13;
    result = emit_tacky(e, instructions, symbols)&#13;
    match result with&#13;
    | PlainOperand(val) -&gt; return val&#13;
    | DereferencedPointer(ptr) -&gt;&#13;
        dst = make_tacky_variable(get_type(e), symbols)&#13;
        instructions.append(Load(ptr, dst))&#13;
        return dst</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: Translating an expression to TACKY and performing lvalue conversion</samp></p>&#13;
<p class="TX">To lvalue convert a dereferenced pointer, we’ll retrieve its value with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. Other operands can be returned as is, without emitting any extra instructions. A <i>full expression</i>, which isn’t part of another expression, always undergoes lvalue conversion. That means you should use <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and _convert</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, to process a full expression and get its result. For example, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp> to process the controlling expressions in loops and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.</p>&#13;
<p class="TX">The results of some full expressions—specifically, expression statements and the first and third clauses in <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop headers—are not used. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_375" aria-label="375"/>As an optimization, you can process these expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, which saves you an unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction.</p>&#13;
<p class="TX">To wrap up this section, we’ll implement casts to and from pointer types. For the purposes of casting, we treat pointer types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. For example, we cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to any pointer type with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> instruction and from a pointer type to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>. The TACKY implementations of other expressions, like logical operations and comparisons, won’t change.</p>&#13;
<aside class="box" aria-label="box-37"><p class="BoxTitle" id="box-37"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h1-126"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">In the previous section, we added <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions that allow us to read from and write to memory. This means that TACKY has finally caught up with assembly, which we’ve been using to read from and write to memory since <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span>. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>, for example, identifies a location in memory, which we can read or write with a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.</p>&#13;
<p class="TX">There’s nothing special about RBP, though; we can access memory through an address stored in any register. Here’s how to read the value from an address stored in the RAX register and copy it into RCX:</p>&#13;
<pre><code>movq    (%rax), %rcx</code></pre>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp>.</p>&#13;
<p class="TX">The assembly AST will change slightly to handle operands like <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp>. First, we’ll add the RBP register to the AST:</p>&#13;
<pre><code>reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP |<b> BP</b> |<var> --snip--</var></code></pre>&#13;
<p class="TX">Then, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand, which lets us access memory at some offset from the address in RBP, with a more generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand, which can use a base address stored in any register:</p>&#13;
<pre><code> operand = Imm(int) | Reg(reg) | Pseudo(identifier) | <b>Memory(reg, int)</b> | Data(identifier)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_376" aria-label="376"/>This makes converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction to assembly very simple. We’ll translate</p>&#13;
<pre><code>Load(ptr, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(Quadword, ptr, Reg(AX))&#13;
Mov(<var>&lt;dst type&gt;</var>, Memory(AX, 0), dst)</code></pre>&#13;
<p class="TX">In the first instruction, we move the memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to a register. In the second instruction, we move the value stored at that address, which we access with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand, to the destination. In this example, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> into RAX, but any general-purpose register will do (aside from R10, R11, or a callee-saved register).</p>&#13;
<p class="TX">Along the same lines, we’ll translate</p>&#13;
<pre><code>Store(src, ptr)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(Quadword, ptr, Reg(AX))&#13;
Mov(<var>&lt;src type&gt;</var>, src, Memory(AX, 0))</code></pre>&#13;
<p class="TX">Note that when we copy a pointer into a register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> operand type, since pointers are 8 bytes. But when we copy a value to or from the memory location that a pointer indicates, the value’s type determines the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.</p>&#13;
<p class="TX">We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> using a new assembly instruction: <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>, which is short for <i>load effective address</i>. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea src, dst</samp> copies the <i>address</i> of its source (which must be a memory operand) to its destination. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">lea (%rbp), %rax</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov %rbp, %rax</samp>. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> to get RIP-relative addresses, so</p>&#13;
<pre><code>lea    x(%rip), %rax</code></pre>&#13;
<p class="BodyContinued">stores the address of the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the RAX register.</p>&#13;
<p class="TX">With this new instruction, converting <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> to assembly is straightforward. We’ll translate</p>&#13;
<pre><code>GetAddress(src, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Lea(src, dst)</code></pre>&#13;
<p class="TX">As I mentioned earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> here must be a memory operand, not a constant or register, for obvious reasons. At the moment, we’re guaranteed to satisfy this constraint; we map every pseudoregister to a memory address, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_377" aria-label="377"/>and the type checker catches any attempts to take the address of a constant. But in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, when we implement register allocation, we’ll store some variables in registers instead of in memory. At that point, it will take some extra work to make sure that <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> never tries to load the address of a register.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#list14-26">Listing 14-26</a> defines the whole assembly AST, including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction.</p>&#13;
<a id="list14-26"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = Longword | Quadword | Double&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init init)&#13;
          | StaticConstant(identifier name, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(operand src, operand dst)&#13;
            | MovZeroExtend(operand src, operand dst)&#13;
            <b>| Lea(operand src, operand dst)</b>&#13;
            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not | Shr&#13;
binary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | <b>Memory(reg, int)</b> | Data(identifier)&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP |<b> BP</b>&#13;
    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: The assembly AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Memory</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operand,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BP</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">register, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Lea</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp></p>&#13;
<p class="TX">When we translate other TACKY instructions to assembly, we’ll treat pointer types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. We’ll convert pointer types to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> assembly type, compare pointers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, pass return values of pointer type in the RAX register, and pass parameters of pointer type in the same general-purpose registers as integer parameters.</p>&#13;
<p class="TX">We’ll also make one entirely mechanical change: everywhere we previously used an operand of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;i&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(BP,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;i&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> instead. <a href="chapter14.xhtml#tab14-1">Tables 14-1</a> through <a href="chapter14.xhtml#tab14-3">14-3</a> summarize this chapter’s updates to the conversion from TACKY to assembly; as usual, new constructs and changes to the conversions for existing constructs are bolded.</p>&#13;
<p class="TT" id="tab14-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_378" aria-label="378"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global, params,&#13;
          instructions)</samp></code></pre></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global,</samp> &#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">       </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;first int param type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DI),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">               &lt;first int param&gt;)</samp>,&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;second int param type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(SI),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">               &lt;second int param&gt;),&#13;
           &lt;copy next four integer parameters from registers&gt;,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(Double, Reg(XMM0),</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> &lt;first double param&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),&#13;
          Mov(Double, Reg(XMM1),</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> &lt;second double param&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">           &lt;copy next six double parameters from registers&gt;,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;first stack param type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
<samp class="SANS_Futura_Std_Heavy_B_11"> Memory(BP, 16)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">               &lt;first stack param&gt;)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">,          Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;second stack param type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
<samp class="SANS_Futura_Std_Heavy_B_11"> Memory(BP, 24),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">               &lt;second stack param&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">           &lt;copy remaining parameters from stack&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+&#13;
         instructions)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab14-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Load(ptr, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, 0), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Store(src, ptr)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, src, Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, 0))</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">GetAddress(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Lea(src, dst)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab14-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Pointer(referenced_t)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Quadword</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Next, we’ll update the pseudoregister replacement and instruction fix-up passes.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-131"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters with Memory Operands</samp></h4>&#13;
<p class="TNI">We’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand instead of the old <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand throughout this pass. We’ll also extend this pass to replace pseudoregisters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction. We won’t make any other changes. When we converted TACKY pointer variables to pseudoregisters, we assigned them the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> assembly type; now we’ll allocate stack space for them like any other <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-132"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the lea and push Instructions</samp></h4>&#13;
<p class="TNI">The destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction must be a register; we’ll rewrite it in the usual fashion. We’ll also add a new rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_379" aria-label="379"/>As I mentioned in the previous chapter, it’s illegal to <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> an XMM register, so we’ll rewrite an instruction like</p>&#13;
<pre><code>pushq   %xmm0</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>subq    $8, %rsp&#13;
movsd   %xmm0, (%rsp)</code></pre>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction decrements the stack pointer by 8 bytes, then moves its operand to the top of the stack. When we can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, we’ll perform the same operation in two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rsp)</samp> operand designates the memory location at the top of the stack.</p>&#13;
<p class="TX">Because we don’t generate any <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions that operate on XMM registers, this rewrite rule isn’t strictly necessary yet. It will become necessary once we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>; then, values that we currently store in memory might be assigned to XMM registers instead.</p>&#13;
<aside class="box" aria-label="box-38"><p class="BoxTitle" id="box-38"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-127"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Our final task will be to update the code emission stage to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register. <a href="chapter14.xhtml#tab14-4">Tables 14-4</a> and <a href="chapter14.xhtml#tab14-5">14-5</a> summarize how to print out these new constructs. (I haven’t bolded new constructs and changes in these tables, because all three of these constructs are entirely new.)</p>&#13;
<p class="TT" id="tab14-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Lea(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">leaq</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab14-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 14-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BP)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%rbp</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(reg, int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;reg&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_380" aria-label="380"/>We’ll always use the 8-byte aliases for the base register in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand and the destination register in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction, because memory addresses are 8-byte integers.</p>&#13;
<p class="TX">When the offset in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand is zero, you can either print it or omit it; <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp> are equally valid.</p>&#13;
<aside class="box" aria-label="box-39"><p class="BoxTitle" id="box-39"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 14</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1" id="sec26"><span id="h1-128"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you added support for pointers to your compiler. You learned how to parse complex declarators into derived types and how to type check operations on pointers. During TACKY generation, you established a uniform way to process pointer dereference expressions, regardless of how they’re used. On the backend, you took the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand that accessed memory relative to the address in RBP and tweaked it to work with addresses stored in any register.</p>&#13;
<p class="TX">In the next chapter, you’ll implement arrays, your first non-scalar type. You’ll also implement array subscripting and pointer arithmetic and explore the ways in which they’re equivalent. Because pointers and arrays are so closely related, the concepts, techniques, and instructions introduced in this chapter will be crucial in the next chapter too.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>