- en: '**25**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**25**'
- en: '**DEFINING COLORS AND PLOTTING IN HIGHER DIMENSIONS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义颜色和在高维度中绘制图形**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: Now that you’ve mastered some fundamental visualization skills, you can go beyond
    the standard *x*- and *y*-axes by, for example, coloring points according to some
    additional value or variable or adding a *z*-axis for constructing a 3D plot.
    Higher-dimensional plots like this allow you to visually explore your data or
    models using more variables than would be possible otherwise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了一些基本的可视化技巧，你可以通过给点着色来超越标准的*x*和*y*坐标轴，依据某些附加的值或变量，或者添加一个*z*轴来构建3D图表。像这样的高维度图表允许你使用比其他方式更多的变量来直观地探索你的数据或模型。
- en: 'In this chapter, you’ll get into more detail when it comes to handling colors
    and color palettes in R, and then you’ll look at four new plots: 3D scatterplots,
    contour plots, pixel image plots, and perspective plots.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入了解如何在R中处理颜色和调色板，然后你将看到四种新的图表类型：3D散点图、等高线图、像素图和透视图。
- en: '**25.1 Representing and Using Color**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.1 表示和使用颜色**'
- en: Color plays a key role in many plots. As you’ve already seen, color can be used
    purely for aesthetic enhancement, or it can be a critical aid to interpreting
    your data/models by distinguishing between values and variables. Before learning
    about some more complicated data and model visualization tools, it’s useful to
    understand a little about how R formally represents and handles colors. In this
    section, you’ll examine common ways to create and represent specific colors and
    how to define and use a cohesive collection of colors; the latter is referred
    to as a *palette*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色在许多图表中起着关键作用。正如你已经看到的，颜色不仅可以纯粹用于美学增强，也可以通过区分不同的值和变量，成为解读数据/模型的重要工具。在学习一些更复杂的数据和模型可视化工具之前，了解R如何正式表示和处理颜色是很有用的。在本节中，你将学习常见的创建和表示特定颜色的方法，以及如何定义和使用一组协调一致的颜色；后一种方法称为*调色板*。
- en: '***25.1.1 Red-Green-Blue Hexadecimal Color Codes***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.1 红绿蓝十六进制颜色代码***'
- en: When specifying colors in plots, your instruction to R so far has been given
    either in the form of an integer value from `1` to `8` or as a character string
    (see the relevant comments in [Section 7.2.3](ch07.xhtml#ch07lev2sec65)). For
    programming purposes, you need a more objective representation of these colors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定图表中的颜色时，你迄今为止给R的指令通常是通过一个从`1`到`8`的整数值，或者是字符字符串的形式（请参见[第7.2.3节](ch07.xhtml#ch07lev2sec65)中的相关注释）。为了编程目的，你需要这些颜色的更客观的表示方式。
- en: One of the most common methods of color specification is to specify different
    *saturations* or *intensities* of three primaries—red, green, and blue (RGB)—which
    are then mixed to form the resulting target color. Each primary component of the
    standard RGB system is assigned an integer from 0 to 255 (inclusive). Such mixtures
    are therefore able to form a total of 256³ = 16,777,216 possible colors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的颜色指定方法之一是指定三种原色——红色、绿色和蓝色（RGB）的不同*饱和度*或*强度*，然后将它们混合形成最终的目标颜色。标准RGB系统中的每个原色分量都被赋予一个从0到255（包含）的整数。因此，这样的混合可以形成256³
    = 16,777,216种可能的颜色。
- en: You always express these values in (R, G, B) order; the result is commonly referred
    to as a *triplet*. For example, (0,0,0) represents pure black, (255,255,255) represents
    pure white, and (0,255,0) is full green.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是按（R，G，B）的顺序来表示这些值；结果通常称为*三元组*。例如，（0,0,0）代表纯黑色，（255,255,255）代表纯白色，（0,255,0）代表纯绿色。
- en: 'The `col` argument lets you select one of eight colors when you supply it an
    integer from 1 to 8\. You can find these eight colors with the following call:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`col`参数允许你在输入从1到8的整数时，选择八种颜色中的一种。你可以通过以下调用来找到这八种颜色：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are but a small subset of the 650+ named colors that you can list by
    entering `colors()` at the R prompt. All of these named colors can also be expressed
    in the standard RGB format. To find the RGB values for a color, supply the desired
    color names as a vector of character strings to the built-in `col2rgb` function.
    Here’s an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你通过在R提示符下输入`colors()`命令可以列出的650多个命名颜色的一个小子集。所有这些命名颜色也可以用标准RGB格式表示。要查找颜色的RGB值，只需将所需的颜色名称作为字符向量传递给内置的`col2rgb`函数。以下是一个示例：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result is a matrix of RGB values, with each column representing one of your
    specified colors. This is what R actually means, in an RGB sense, when you ask
    it to plot these colors using the corresponding character string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个RGB值矩阵，每一列代表你指定的颜色之一。这就是R在RGB意义上，当你请求它用相应的字符字符串绘制这些颜色时的实际含义。
- en: 'These RGB triplets are frequently expressed as *hexadecimals*, a numeric coding
    system often used in computing. In R, a hexadecimal, or *hex code*, is a character
    string with a `#` followed by six alphanumeric characters: valid characters are
    the letters *A* through *F* and the digits 0 through 9\. The first pair of characters
    represents the red component, and the second and third pairs represent green and
    blue, respectively. If you have or create one or more RGB triplets, you can turn
    them into hex codes for R to use in any subsequent plotting through the `rgb`
    function. This command takes a matrix of RGB values, though note that it expects
    each (R, G, B) color to be a row of that matrix (as opposed to the columns provided
    from a call to, say, `col2rgb`).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些RGB三元组通常表示为*十六进制数*，这是一种在计算机中常用的数字编码系统。在R中，十六进制或*十六进制代码*是一个字符字符串，前面跟着一个`#`，后面是六个字母数字字符：有效字符是字母*A*到*F*和数字0到9。第一个字符对表示红色分量，第二和第三个字符对分别表示绿色和蓝色。如果你有或创建一个或多个RGB三元组，你可以通过`rgb`函数将它们转换为R可以在后续绘图中使用的十六进制代码。这个命令接受一个RGB值的矩阵，但请注意，它期望每个(R,
    G, B)颜色是该矩阵的行（而不是例如通过`col2rgb`调用时提供的列）。
- en: 'You’ll also need to tell `rgb` that your maximum color value, as per the standard
    RGB format, is 255 (since by default it scales this and uses 1). The following
    code performs a matrix transpose (refer to [Section 3.3](ch03.xhtml#ch03lev1sec14))
    on the result of the previous call to `col2rgb`, putting my three colors as RGB
    triplets in the required form as rows, and specifies the `maxColorValue` accordingly:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要告诉`rgb`，根据标准的RGB格式，你的最大颜色值是255（因为默认情况下，它将此值缩放并使用1）。以下代码对之前调用`col2rgb`的结果执行矩阵转置（参见[第3.3节](ch03.xhtml#ch03lev1sec14)），将我的三种颜色作为RGB三元组以行的形式放入所需的格式，并相应地指定`maxColorValue`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output tells you the hexadecimal codes for the RGB values R refers to with
    the names `"black"`, `"green3"`, and `"pink"`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会告诉你R所指的RGB值对应的十六进制代码，分别为“black”，“green3”和“pink”。
- en: I won’t go into the specifics of converting a standard RGB triplet to a hexadecimal
    here because it’s beyond the scope of this book, but it’s important to know that
    R represents any colors you create using RGB triplets as hex codes, so you should
    be able to at least recognize a hexadecimal when you’re working with colors and
    color palettes in plotting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细讲解如何将标准的RGB三元组转换为十六进制，因为这超出了本书的范围，但了解R代表你使用RGB三元组创建的任何颜色作为十六进制代码是很重要的，所以当你在绘制图形时，至少应该能够识别十六进制代码。
- en: 'For an even more colorful exploration, let’s write a modest little function
    to plot points in individual colors and label them appropriately with RGB triplets
    and corresponding hex codes. Consider the following in the editor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更丰富的探索，让我们写一个简单的函数，用单独的颜色绘制点，并用RGB三元组和相应的十六进制代码为其加上标签。请在编辑器中参考以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function `pcol` takes one argument, `cols`, intended to be a character vector
    of color names recognized by R. When you execute `pcol`, it opens a new graphics
    device and equalizes the figure margin settings to be one line on each side. A
    plot is begun, fully suppressed except for a box. This is so you can use `locator`
    (see [Section 23.3](ch23.xhtml#ch23lev1sec78)) to place points in the plot region,
    implemented in a `for` loop, one after the other. Each point represents one of
    the `cols`, and after its coordinates are returned from `locator`, `points` puts
    down a large dot of the color at hand, with `text` providing annotation to the
    right of each point achieved using `paste` (refer to [Section 4.2](ch04.xhtml#ch04lev1sec17)).
    This annotation includes the R color name, the RGB triplet, and the hex code on
    top of one another; the latter two are found using `col2rgb` and `rgb` exactly
    as demonstrated earlier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The following code sets up the device, first storing 14 valid R color names
    (chosen randomly) in the character vector `mycols`. After exhausting these with
    mouse clicks in different areas of the plot region, the execution is complete.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When I execute `pcol` as shown here, I click through the 14 points, producing
    rough columns on my graphics device. [Figure 25-1](ch25.xhtml#ch25fig1) shows
    the result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-1: Various named R colors alongside their corresponding RGB triplets
    and hex codes.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In essence, you can obtain any color you want (in other words, far more than
    the named ones that are built into R) by specifying an RGB value and obtaining
    its hex code. These hexadecimals can be supplied as is to any of the traditional
    R graphics functions where you specify color (commonly to a `col` argument). You’ll
    see this as the chapter progresses. Naturally, you can also assign a hex code
    or a vector of hex codes (for example, if you’re creating your own custom colors)
    to a new object in your R workspace so you can use it in subsequent plotting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.2 Built-in Palettes***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Being able to implement your own RGB colors is most useful when you need many
    colors, the collection of which is referred to as a *palette*. You’ll typically
    need a palette when color is used to describe something on a continuum, like the
    various shades of blue used for the height measurements in [Figure 24-6](ch24.xhtml#ch24fig6)
    on [page 621](ch24.xhtml#page_621).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of color palettes built into the base R installation. These
    are defined by the functions `rainbow`, `heat.colors`, `terrain.colors`, `topo.colors`,
    `cm.colors`, `gray.colors`, and `gray`. With the exception of `gray`, you directly
    specify the number of colors you want, and they’ll be returned as a character
    vector of hex codes representing an equally spaced sequence over the entire color
    range of that particular palette.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easiest to see this in action with a visualization. The following code
    generates exactly 600 colors from each palette:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that instead of a single integer, `gray` expects a numeric vector of values
    between 0 (total black) and 1 (total white) to provide a grayscale. Its counterpart
    function, `gray.colors`, works the same as the other built-in palettes but defaults
    to a slightly narrower visual range between the extremes of black and white. These
    can be reset using the optional arguments `start` and `end`, which you’ll see
    shortly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`gray`期望的是一个介于0（完全黑）和1（完全白）之间的数值向量来提供灰度，而不是一个单一的整数。它的对应函数`gray.colors`的工作原理与其它内置调色板相同，但默认的视觉范围稍微窄一些，位于黑与白之间的极限。这些可以通过可选参数`start`和`end`来重置，稍后你会看到。
- en: The next code chunk uses skills from [Chapter 23](ch23.xhtml#ch23) to initialize
    a new plot and uses vector repetition to place 600 points for each palette in
    a single call to `points`, coloring them appropriately as per the vectors of hex
    codes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块使用了[第 23 章](ch23.xhtml#ch23)中的技巧，初始化了一个新的图形，并使用向量重复将600个点放置到`points`函数的一次调用中，根据十六进制代码向量为这些点着色。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 25-2](ch25.xhtml#ch25fig2) shows the result.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-2](ch25.xhtml#ch25fig2)展示了结果。'
- en: '![image](../images/f25-02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-02.jpg)'
- en: '*Figure 25-2: Showcasing the color ranges of the built-in palettes, with default
    limits used in* `gray.colors`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-2：展示了内置调色板的颜色范围，使用的是`gray.colors`的默认限制。*'
- en: For more information, access the help files `?gray.colors` and `?gray` for the
    respective grayscale palettes, with the others all appearing under `?rainbow`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问帮助文件`?gray.colors`和`?gray`，了解各自的灰度调色板，其它的则都在`?rainbow`中。
- en: '***25.1.3 Custom Palettes***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.3 自定义调色板***'
- en: You’re not restricted to the ready-to-use color designs. The function `colorRampPalette`
    allows you to create your own palettes; you supply two or more desired key colors
    to an argument of the same name, and it creates a palette that transitions between
    them. The result of a call to `colorRampPalette` is itself a function—one that
    behaves exactly like the built-in palette functions noted earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不局限于使用现成的颜色设计。函数`colorRampPalette`允许你创建自己的调色板；你只需为同名参数提供两个或更多的期望关键颜色，它就会创建一个在这些颜色之间过渡的调色板。调用`colorRampPalette`的结果本身就是一个函数——其行为与前面提到的内置调色板函数完全相同。
- en: 'Let’s say you’d like to be able to generate colors on a scale between purple
    and yellow. You specify the key colors to be interpolated, in the desired order,
    as a character vector of names from the collection that R recognizes. The following
    line creates this palette function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望能够在紫色和黄色之间生成颜色。你需要指定要插值的关键颜色，并按所需的顺序将它们作为字符向量的名称，选择 R 所识别的颜色集合中的名称。以下代码行创建了这个调色板函数：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s create another one, this time picking one that will show up a little clearer
    in case a color plot that ends up using it is printed in grayscale (in which case
    sticking to monochromatic palettes is a good idea).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个，这次选择一个颜色稍微清晰一些的调色板，以防使用它的颜色图打印为灰度图（在这种情况下，使用单色调色板是个好主意）。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are a couple more, using more than two colors this time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的示例，这次使用了超过两种颜色：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Having created a handful of custom palette functions, you can now generate any
    number of colors from each range just like before (done here using the previously
    stored `N` value of 600 each). After doing so, you can adapt the earlier plotting
    code to get the image in [Figure 25-3](ch25.xhtml#ch25fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一些自定义调色板函数后，你现在可以像以前一样从每个范围中生成任意数量的颜色（这里使用之前存储的`N`值，即每个600个）。完成后，你可以调整之前的绘图代码，得到[图
    25-3](ch25.xhtml#ch25fig3)中的图像。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](../images/f25-03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-03.jpg)'
- en: '*Figure 25-3: Some examples of custom color palettes created using* `colorRampPalette`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-3：一些使用`colorRampPalette`创建的自定义颜色调色板示例。*'
- en: '***25.1.4 Using Color Palettes to Index a Continuum***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.4 使用颜色调色板对连续值进行索引***'
- en: 'You’ve now seen a few times how color can be used to identify groups based
    on a categorical variable (the data corresponding to a certain level are simply
    given a distinct color from the others), which is pretty easy to do. However,
    assigning colors appropriately to values on a continuum requires a little more
    thought. There are two methods for this: through categorization or through normalization
    of your continuous values. Let’s look first at the former approach.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次看到如何使用颜色来根据分类变量标识组（属于某一特定级别的数据简单地被赋予一个与其他数据不同的颜色），这其实很容易实现。然而，给连续值适当地分配颜色则需要更多的思考。为此有两种方法：通过分类或通过标准化连续值。我们首先来看第一种方法。
- en: '**Via Categorization**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过分类**'
- en: One way to color values according to a continuous variable is to turn it into
    the familiar problem of coloring points of a categorical variable. You can do
    this by binning your continuous values into a fixed number of *k* categories,
    generating *k* colors from your palette, and matching each observation to the
    appropriate color based on the bin it falls into.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据连续变量为值着色的一种方法是将其转化为为分类变量着色的熟悉问题。你可以通过将连续值分箱为固定数量的*k*类，从你的调色板中生成*k*种颜色，并根据每个观测值所属的箱子匹配相应的颜色。
- en: 'In [Section 20.1](ch20.xhtml#ch20lev1sec62), you plotted height against writing
    handspan for the `survey` data from the `MASS` package. This time, let’s use color
    to additionally inform the nonwriting handspan variable. Load the package and
    execute the following line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20.1节](ch20.xhtml#ch20lev1sec62)，你绘制了来自`MASS`包的`survey`数据的身高与书写手跨度之间的关系。这一次，我们使用颜色来额外表达非书写手跨度变量。加载该包并执行以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This creates the data frame object `surv`, which is made up of only the three
    required columns. Any rows with missing values are removed via a call to `na.omit`
    (refer to [Section 6.1.3](ch06.xhtml#ch06lev2sec57)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建数据框对象`surv`，它只包含三个必要的列。通过调用`na.omit`去除所有包含缺失值的行（参见[第6.1.3节](ch06.xhtml#ch06lev2sec57)）。
- en: Now, the first thing to do is decide on your color palette.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先要做的是决定你的调色板。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate colors that go from a dark, dull red at the lower end of
    the scale to a slightly faded yellow at the higher end (similar to the builtin
    `heat.colors` palette; see [Figure 25-2](ch25.xhtml#ch25fig2)). Next, you need
    to decide how many bins, *k*, you’re going to construct for the continuous values.
    This determines how many distinct colors to generate from `NW.pal`. For these
    data, set *k* = 5.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成从比例尺下端的深暗红色到上端稍微褪色的黄色的颜色（类似于内置的`heat.colors`调色板；见[图25-2](ch25.xhtml#ch25fig2)）。接下来，你需要决定你将为连续值构建多少个箱子，*k*。这将决定从`NW.pal`生成多少种不同的颜色。对于这些数据，设置*k*
    = 5。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Your five `NW.pal` colors, as hex codes, are available. Next, you need to actually
    bin the continuous values, which you can do using `cut`. First you need to set
    *k* + 1 break points for the bins (refer to [Section 4.3.3](ch04.xhtml#ch04lev2sec48)
    for a refresher), using `seq`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你的五种`NW.pal`颜色，作为十六进制代码，已经准备好。接下来，你需要实际对连续值进行分箱，可以使用`cut`来实现。首先，你需要设置*k* + 1个分割点（参见[第4.3.3节](ch04.xhtml#ch04lev2sec48)复习），使用`seq`。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The six equally spaced values span the range of the students’ nonwriting handspans,
    delineating your five intended bins. Then `cut` factorizes the nonwriting handspans
    with respect to those bins. You can use `as.numeric` to specifically return the
    indexes for extracting the appropriate color for each observation from your five
    ordered hex codes in `ryc` (full output is suppressed here for reasons of print).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 六个等距的值跨越学生的非书写手的跨度范围，划定了你的五个目标箱子。然后，`cut`根据这些箱子对非书写手的跨度进行因子化。你可以使用`as.numeric`特意返回索引，以从`ryc`中的五个有序十六进制代码提取每个观测值的适当颜色（由于打印原因，这里省略了完整输出）。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’re ready to plot; the result of the following is given on the left of [Figure
    25-4](ch25.xhtml#ch25fig4):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好绘图；以下结果见[图25-4](ch25.xhtml#ch25fig4)左侧：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![image](../images/f25-04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-04.jpg)'
- en: '*Figure 25-4: Illustrating two ways to assign color to points based on a continuous
    value: via categorization (left) and via normalization (right)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-4：展示两种根据连续值为点着色的方法：通过分类（左）和通过归一化（右）*'
- en: '**Via Normalization**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过归一化**'
- en: Using categorization to index a continuum with color is a little unsophisticated.
    There are plenty of ways you can bin your observations, for example, so your plot
    might look very different from the same plot designed by someone else. In a computational
    sense, it’s more accurate (not to mention elegant) to leave your continuous data
    as is.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分类法通过颜色为连续值进行索引有点过于简单。你可以通过多种方式将观测值分箱，例如，你的图可能与另一个人设计的相同图表看起来完全不同。从计算的角度来看，保留你的连续数据不变是更准确（更优雅）的做法。
- en: 'Recall the built-in `gray` palette mentioned in [Section 25.1.2](ch25.xhtml#ch25lev2sec243).
    This function behaved a little differently from the others. Instead of simply
    asking for a number of colors from the specified palette, you’re required to provide
    a numeric vector of values to tell R, on a continuous scale from 0 through 1,
    how “far along” the palette to go. This type of behavior suits the current task
    perfectly, since your raw data are also on a continuous scale. To implement it,
    you need two things: a way to create a palette that will behave like `gray` and
    a *normalized* version of your continuous values that fall within the acceptable
    standardized range of 0 to 1 inclusive.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第25.1.2节](ch25.xhtml#ch25lev2sec243)中提到的内置`gray`调色板。这个函数的行为与其他函数略有不同。它不是简单地要求你从指定的调色板中选择颜色数量，而是要求你提供一个数值向量，以告知
    R 在从 0 到 1 的连续范围内，调色板“走多远”。这种行为非常适合当前的任务，因为你的原始数据也是连续的。为了实现这一点，你需要两样东西：一种能够像`gray`一样行为的调色板，以及一个*归一化*后的连续值版本，这些值必须落在
    0 到 1 的标准化范围内（包括 0 和 1）。
- en: 'The `colorRamp` function allows you to create your palette and is used in the
    same way as `colorRampPalette`, but the result is a color palette function that
    expects a numeric vector as stated. You’ll see that in a moment. To transform
    a collection of *n* original values {*x*[1], ..., *x*[n]} to, say, {*z*[1], ...,
    *z*[n]}, where 0 ≤ *z[i]* ≤ 1; *i* = 1, ..., *n*, you can employ the following
    equation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorRamp`函数允许你创建调色板，并且与`colorRampPalette`的用法相同，但返回的结果是一个颜色调色板函数，期望输入一个数值向量。你将很快看到这一点。为了将一组原始值
    {*x*[1], ..., *x*[n]} 转换为，比如说， {*z*[1], ..., *z*[n]}，其中 0 ≤ *z[i]* ≤ 1；*i* = 1,
    ..., *n*，你可以使用以下公式：'
- en: '![image](../images/e25-1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e25-1.jpg)'
- en: 'Let’s make that an R function by writing the following in the R editor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 R 编辑器中编写以下代码将其转化为一个 R 函数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Based on a vector `datavec` as its only argument, `normalize` implements [Equation
    (25.1)](ch25.xhtml#ch25eq1), using the optional `na.rm` argument to ensure any
    missing values in `datavec` don’t contaminate the calculation of the minimum and
    maximum values (see [Section 13.2.1](ch13.xhtml#ch13lev2sec116)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `datavec` 向量作为唯一参数，`normalize` 实现了[公式 (25.1)](ch25.xhtml#ch25eq1)，使用可选的 `na.rm`
    参数来确保 `datavec` 中的任何缺失值不会污染最小值和最大值的计算（见[第13.2.1节](ch13.xhtml#ch13lev2sec116)）。
- en: 'Import `normalize` and enter the following, which shows the original nonwriting
    handspan values (from the object `surv` you created earlier) and their corresponding
    normalized values (output snipped for brevity):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `normalize`，并输入以下代码，它展示了原始的非书写手跨度值（来自你之前创建的 `surv` 对象）及其对应的归一化值（为了简洁，输出被省略）：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, you need to create a new version of the color palette with `colorRamp`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要使用`colorRamp`创建一个新的颜色调色板版本。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Generate the corresponding colors for each observation based on the normalized
    data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据归一化数据为每个观测值生成相应的颜色。
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you actually look at the returned object in `ryc2`, you’ll note it’s a matrix
    of RGB triplets corresponding to each normalized value you supplied to your `colorRamp`
    function `NW.pal2` (noninteger values end up being coerced to integers). These
    need to be converted to hex codes before you can use them in plotting. Using `rgb`
    just as you saw in [Section 25.1.1](ch25.xhtml#ch25lev2sec242), you get the vector
    you need (snipped for print).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际查看`ryc2`中返回的对象，你会注意到它是一个 RGB 三元组矩阵，对应于你提供给`colorRamp`函数`NW.pal2`的每个归一化值（非整数值最终会被强制转换为整数）。在你将它们用于绘图之前，需要将这些值转换为十六进制代码。像在[第25.1.1节](ch25.xhtml#ch25lev2sec242)中看到的那样，使用`rgb`函数，你将得到所需的向量（为打印简洁，已省略）。
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the difference between the hex codes you obtain here in `NW.cols2` and
    those in `NW.cols`. Here, you get a hex code for each unique value, but for the
    categorized `NW.cols`, you have only one hex code for each bin (so just *k* =
    5 colors).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你在`NW.cols2`中获得的十六进制代码和在`NW.cols`中获得的十六进制代码之间的差异。在这里，你为每个独特的值获取一个十六进制代码，但对于分类后的`NW.cols`，你每个分箱只有一个十六进制代码（所以只有*k*
    = 5种颜色）。
- en: This line produces the image on the right of [Figure 25-4](ch25.xhtml#ch25fig4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行生成了[图 25-4](ch25.xhtml#ch25fig4)右侧的图像。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In terms of this relatively simple example, the visual difference between the
    two approaches is minimal, though looking closely you can indeed pick out the
    smoother color transition in the normalized version. As you increase *k* when
    using the categorization technique, the visual result will become closer to that
    of the normalization approach. That said, the normalization approach should generally
    be preferred, since it more closely fits the continuous nature of the values you’re
    trying to visualize, and it works more effectively for values with a skewed distribution
    or when you’re working with a complex color palette.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就这个相对简单的例子而言，两种方法之间的视觉差异很小，尽管仔细观察，你确实可以辨认出归一化版本中更平滑的颜色过渡。当你增加 *k* 值时，使用分类技术的视觉效果将越来越接近归一化方法。然而，通常应优先选择归一化方法，因为它更贴合你想要可视化的值的连续特性，并且对于分布偏斜的值或使用复杂色板时更为有效。
- en: '***25.1.5 Including a Color Legend***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.5 包含颜色图例***'
- en: Now that you can use color to significant effect in your plots, you need a legend
    to reference the color scale. It’s possible to create a legend using base R tools
    alone, but it can be simpler to use contributed functionality in R instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在图形中有效使用颜色，你需要一个图例来参考颜色尺度。尽管使用基础 R 工具也可以创建图例，但使用 R 中的贡献功能通常会更简单。
- en: 'One useful function for this is the `colorlegend` command. This is found in
    the `shape` package ([Soetaert, 2014](ref.xhtml#ref62)), so first download and
    install `shape` from CRAN. The following code then loads the package, reproduces
    the most recent plot (based on the `surv` object created earlier and shown on
    the right of [Figure 25-4](ch25.xhtml#ch25fig4)) with some tidier axis titles,
    and draws the color strip legend:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的函数是 `colorlegend` 命令。这个函数位于 `shape` 包中（[Soetaert, 2014](ref.xhtml#ref62)），因此首先需要从
    CRAN 下载并安装 `shape` 包。接下来的代码将加载该包，重新绘制最近的图形（基于之前创建的 `surv` 对象，并显示在[图 25-4](ch25.xhtml#ch25fig4)的右侧），并绘制颜色条图例：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This result is given on the left of [Figure 25-5](ch25.xhtml#ch25fig5).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果见于[图 25-5](ch25.xhtml#ch25fig5)的左侧。
- en: The `colorlegend` functions assumes that you already have a plot present in
    an active graphics device, so you need to have one created first. The first thing
    you supply to `colorlegend` is the color span of the values you want to reference.
    This is easiest with a color palette function like those listed in the help file
    `?rainbow` or created using `colorRampPalette`—in other words, a function that
    takes an integer value telling it how many colors to generate. Doing so with a
    large number of colors gives you a smooth color strip, so I use `NW.pal(200)`.
    Next, you provide `colorlegend` with the range of the values that will be referenced
    by the legend using `zlim`, in this case, the range of the nonwriting handspans
    `range(surv$NW.Hnd)`. The `zval` argument takes in the values that you want to
    mark off on the legend. The values of a sequence between 13 and 23, in steps of
    2, are marked off.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorlegend` 函数假设你已经在活动的图形设备中创建了一个图形，因此你需要先创建一个图形。你传递给 `colorlegend` 的第一个参数是你想要参考的值的颜色范围。使用像
    `?rainbow` 帮助文件中列出的颜色调色板函数或通过 `colorRampPalette` 创建的函数最为简便——换句话说，一个接受整数值的函数，告诉它需要生成多少种颜色。使用大量颜色时，可以得到平滑的色带，因此我使用
    `NW.pal(200)`。接下来，使用 `zlim` 为 `colorlegend` 提供一个值的范围，这个值将被图例所参考，在这个例子中，是非写手手势的范围
    `range(surv$NW.Hnd)`。`zval` 参数接受你希望在图例上标记的值。一个从 13 到 23，步长为 2 的序列被标记了出来。'
- en: '![image](../images/f25-05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-05.jpg)'
- en: '*Figure 25-5: Two examples of implementing a color strip legend using the*
    `colorlegend` *function from the contributed* `shape` *package*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-5：使用来自贡献包* `shape` *的* `colorlegend` *函数实现颜色条图例的两个例子*'
- en: The positioning and sizing of the color legend are done using the `posx` and
    `posy` arguments. Rather than taking user coordinates, each of these must be a
    vector of length 2 describing, in *relative device coordinates*, the horizontal
    (`posx`) and vertical (`posy`) lengths of the strip. In this example, `posx=c(0.3,0.33)`
    tells the function to draw the width of the legend from 30 percent of the left
    of the device to 33 percent so that the width is 3 percent of the overall device
    and positioned to the left of the center. Setting `posy=c(0.5,0.9)` says you want
    the length of the strip to span 40 percent of the device, from 50 percent of the
    way up from the bottom to 90 percent and up. Lastly, you can add the title to
    the legend by supplying a character string to `main`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色图例的位置和大小是通过`posx`和`posy`参数来控制的。这两个参数并非使用用户坐标，而是必须是一个长度为2的向量，在*相对设备坐标*下描述条形的水平（`posx`）和垂直（`posy`）长度。在这个例子中，`posx=c(0.3,0.33)`指示函数从设备左侧的30%到33%之间绘制图例的宽度，使得宽度占整个设备的3%，并且位置靠左于中心。设置`posy=c(0.5,0.9)`表示你希望条形的长度覆盖设备的40%，从底部50%的位置到90%之间。最后，你可以通过向`main`提供一个字符字符串为图例添加标题。
- en: You’ll probably need to experiment a bit in a trial-and-error fashion to get
    the positioning and sizing (and appropriate tick marks using `zval`) you want.
    The device-specific nature of `posx` and `posy` means that if you resize your
    device, you might well need to reevaluate the values of these arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要通过试验和错误的方式来调整图例的位置、大小（以及使用`zval`设置适当的刻度标记）。`posx`和`posy`的设备特定性意味着如果你重新调整设备大小，可能需要重新评估这些参数的值。
- en: If you wanted the legend to appear outside the default plot region, you could
    easily use the `xlim` argument in the initial call to `plot` to widen the horizontal
    size of the plot, giving you extra space to draw a full-length legend. Alternatively,
    you could’ve changed the figure or outer margin spacing (refer to [Section 23.2](ch23.xhtml#ch23lev1sec77))
    to give you enough room to put the legend outside the plot region. This next chunk
    of code does just that by widening the right margin, replotting the scatterplot,
    and inserting a color legend into that extra space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望图例出现在默认绘图区域之外，可以很容易地在第一次调用`plot`时使用`xlim`参数来加宽绘图的横向大小，从而为绘制完整的图例腾出额外的空间。或者，你也可以通过调整图形或外边距的间距（参考[第23.2节](ch23.xhtml#ch23lev1sec77)）来为图例腾出足够的空间，使其出现在绘图区域之外。以下代码段通过加宽右边距、重新绘制散点图，并将颜色图例插入到额外的空间中，完成了这一操作。
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The result is given on the right of [Figure 25-5](ch25.xhtml#ch25fig5). The
    legend is narrower than before, taking up only 2 percent of the device width on
    the right with `posx=c(0.89,0.91)`. With no specification of `posy`, `colorlegend`
    has used the default of `c(0.05,0.9)`, giving a color strip that spans almost
    the entire height of the device. The tick marks and labeling of the new legend
    are now placed in increments of 1 from 13.5 to 22.5; note that to display decimal
    places (in other words, *significant digits*), you need to increase the `digit`
    argument from its default, `0`, to reveal them. Here, `digit=1` prints the tick
    mark labels to one decimal place.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图25-5](ch25.xhtml#ch25fig5)右侧所示。图例比之前更窄，右侧仅占设备宽度的2%，`posx=c(0.89,0.91)`。由于没有指定`posy`，`colorlegend`使用了默认值`c(0.05,0.9)`，这使得颜色条几乎覆盖了设备的整个高度。新图例的刻度标记和标签现在以1为增量，范围从13.5到22.5；请注意，要显示小数位数（也就是说，*有效数字*），你需要将`digit`参数从默认值`0`调整为其他值。在此，`digit=1`将刻度标签显示为一位小数。
- en: There are more properties that you can control with these legends, including
    labeling style and tick mark positioning; see the `?colorlegend` help file for
    details. You may also like to investigate the similarly named function `color.legend`
    in the contributed `plotrix` package ([Lemon, 2006](ref.xhtml#ref40)) for a slightly
    different take on drawing color legends on existing R plots.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以控制这些图例的更多属性，包括标签样式和刻度标记的位置；有关详细信息，请参阅`?colorlegend`帮助文件。你也可以考虑查看贡献的`plotrix`包中同名的函数`color.legend`（[Lemon,
    2006](ref.xhtml#ref40)），它提供了一种稍微不同的方法来绘制现有R图上的颜色图例。
- en: '***25.1.6 Opacity***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.6 不透明度***'
- en: Another useful skill is the ability to specify the opacity of any of the colors
    and color palettes discussed so far. All functions that provide the user with
    hex codes have an optional argument `alpha`, the valid range of which depends
    on the function (a quick check of the corresponding documentation will tell you).
    For example, the `rgb` function uses `maxColorValue` to set the upper bound on
    opacity, and palette functions like `rainbow` all use the normalized range from
    0 through 1 (just like in the `ggplot2` plots created throughout [Chapter 24](ch24.xhtml#ch24)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, R assumes full opacity when you’re creating colors. However, hex
    codes change slightly when opacity is explicitly set using `alpha`. Rather than
    six characters after the `#`, eight will appear, with the last two containing
    the additional opacity information. Consider the following lines of code, which
    generate four different versions of red: default, zero opacity, 40 percent opacity
    (0.4 × 255 = 102), and full opacity, respectively:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the first and last colors are identical; it’s just that the last hex
    code explicitly specifies full opacity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always adjust the opacity of any color you’ve already got with the
    `alpha.f` argument (which takes values in the range 0 through 1) of the ready-to-use
    `adjustcolor` function. The following line takes the default red hex code created
    by the first line in the previous example and turns it into a 40 percent opaque
    version (the third line in the previous code):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You briefly came across this command already in [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    when creating a transparent gray confidence interval for a LOESS-smoothed trend
    using base R graphics. This approach is also applicable to hex codes generated
    after you’ve used a built-in or custom palette function to obtain a vector of
    colors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put opacity to the test using the built-in `quakes` data frame, which
    consists of data on 1,000 seismic events near Fiji. Let’s re-create the plot in
    [Figure 13-6](ch13.xhtml#ch13fig6) on [page 284](ch13.xhtml#page_284) showing
    “number of detecting stations” against “event magnitude” and dress it up using
    color to identify the continuous “depth” data. Since there are many overlapping
    observations, reducing opacity of the individual points would be a good idea for
    visualization. The code
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'sets up a custom three-color palette both ways (in other words, as a function
    expecting an integer, `depth.pal`, and as a function expecting a value between
    0 and 1, `depth.pal2`; refer to [Sections 25.1.3](ch25.xhtml#ch25lev2sec244) and
    [25.1.4](ch25.xhtml#ch25lev2sec245)). Then, the following line uses the normalization
    approach, with the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    to obtain the appropriate colors for the points to be plotted, according to the
    “depth” variable of the data set:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The request for 60 percent opacity is made through `alpha` in the call to `rgb`.
    You can create the plot with the following call, which assigns the colors stored
    in `depth.cols`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This plot affords another opportunity to showcase the `colorlegend` function
    from the `shape` package. Assuming you have `shape` already loaded in the current
    R session, the next line draws a corresponding color legend inside the plot region
    (on a default-size device):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here you can see another demonstration of the use of `adjustcolor`, where the
    color sequence generated with the call to `depth.pal(20)` is then reduced to 60
    percent opacity to match the plotted points. Again, `posx` and `posy` are used
    to position the legend, and the optional logical argument `left` is set to `TRUE`
    to make the tick marks and color legend labels appear on the left side of the
    strip. [Figure 25-6](ch25.xhtml#ch25fig6) shows the final result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-6: Altering the color opacity in a custom palette, used to index
    the continuous “event depth” observations in a plot of “number of stations” against
    “magnitude” for the* `quakes` *data set, and a corresponding color legend using*
    `colorlegend` *from the* `shape` *package*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.7 RGB Alternatives and Further Functionality***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RGB triplets aren’t the only way color can be represented in R. Other specifications
    include hue-saturation-value (HSV) and hue-chroma-luminance (HCL), available through
    the built-in `hsv` and `hcl` functions. These work in much the same way as `rgb`,
    where you specify the strength of influence of the three components and out pop
    corresponding character string hex codes that form valid R colors for any relevant
    plotting command. In fact, the HSV parameterization is what’s used internally
    by the built-in palettes detailed in [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    such as `rainbow` and `heat.colors`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Contributed functionality offers even more flexibility. The `colorspace` package
    ([Ihaka et al., 2015](ref.xhtml#ref34)), which translates between different color
    formats, is worth noting, as is `RColorBrewer` ([Neuwirth, 2014](ref.xhtml#ref51)),
    which is based directly on the well-received color schemes designed by Cynthia
    Brewer (see *[http://colorbrewer2.org/](http://colorbrewer2.org/)*). `RColorBrewer`
    provides more options for creating palettes than are supplied by the built-in
    functionality `colorRampPalette` and `colorRamp`. That said, from an introductory
    perspective, you should find the use of RGB and the base R functionality as discussed
    here sufficient for most visual explorations of your data and models.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.1**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure the `car` package is loaded. Revisit the `Salaries` data frame you looked
    at in [Exercises 24.1](ch24.xhtml#ch24exc1) ([page 622](ch24.xhtml#page_622))
    and [24.2](ch24.xhtml#ch24exc2) ([page 628](ch24.xhtml#page_628)) and take a look
    at the help file `?Salaries` to remind yourself of the variables. Your task is
    to use color, point size, opacity, and point character type to reflect “years
    since Ph.D.,” “sex,” and “rank” in a scatterplot of “salary” against “years of
    service,” by completing the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Set up a custom color palette that goes from `"black"` to `"red"` to `"yellow2"`.
    Create two versions of this palette—one that expects a number of colors and one
    that expects a vector of normalized values between 0 and 1.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two vectors that will control point character and character expansion
    following the guidelines in (i) and (ii). Each of these can be achieved in a single
    line by vector subsetting/repetition based on a numeric coercion of the corresponding
    factor vector in the data frame.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the point characters `19`, `17`, and `15` to reference the three increasing
    academic ranks in that order.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a character expansion of `1` for females and a character expansion of `1.5`
    for males.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    to create a [0,1] normalized version of the range of values of the “years since
    Ph.D.” variable. Then use the appropriate palette from (a) along with `rgb` to
    convert these to the required hex codes.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the vector of colors you just created in (c), adjusting opacity. Colors
    in the vector that correspond to females should be reduced to 90 percent opacity;
    colors that correspond to males should be reduced to 30 percent opacity.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, start the plot; alter the default figure margins to be 5, 4, 4, and 6 lines
    wide on the bottom, left, top, and right, respectively. Plot salary on the *y*-axis
    against years of service on the *x*-axis. Set the corresponding point colors according
    to your vector from (d) and the point characters and character expansion according
    to your vectors from (b). Tidy up the *x*-axis and *y*-axis titles.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate two separate legends following the guidelines in (i) and (ii). Both
    legends should be horizontal, and you should relax clipping to allow their placement
    in figure margins (refer to [Section 23.2.3](ch23.xhtml#ch23lev2sec228)).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the first legend at the user coordinate given by `x=-5` and `y=265000`.
    It should use the levels of the “rank” factor vector as the referencing text and
    pair these with the corresponding `pch` symbols as assigned. Include an appropriate
    title for the legend.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second legend should be placed next to the first, using an *x*-coordinate
    of `40` and the same *y*-coordinate value. This legend should show two points,
    both red and of type `19`, but reference the two levels of sex by altering the
    character expansion and opacity of these to reference points as assigned.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, ensure the `shape` package is loaded and use the `colorlegend` function
    along with 50 colors generated from the appropriate palette from (a) to reference
    “years since Ph.D.” You can leave the horizontal and vertical placements of the
    legend at their default values. The `zlim` range should simply be set to match
    the range of the observed data, and the tick mark values set via `zval` should
    be a sequence between 10 and 50, increasing in steps of 10\. Include an appropriate
    title for the color legend.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After all this, my version of this plot is given here:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0647-01.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your next task is a little different. The goal is to plot a standard normal
    probability density function but use color to shade in polygons underneath the
    curve to denote “distance from mean.” To achieve this, complete the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Generate a vector of exactly 25 colors from the built-in palette `terrain.colors`
    and name it `tcols`. Then, using a reversed version of it obtained via `tcols[25:1]`,
    append the two vectors together to form a new vector of length 50 containing the
    first 25 colors shading one way and then the same 25 shading the opposite way.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create and store an evenly spaced sequence of exactly 51 values between
    −3 and 3 inclusive; name it `vals`. Use `dnorm` to calculate and store the corresponding
    51 values of the standard normal density curve; name it `normvals`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the normal density curve by plotting the values in (i) as a line (recall
    `type="l"`). In the same call to `plot`, use knowledge from [Chapter 23](ch23.xhtml#ch23)
    to set both the *x*-axis and *y*-axis styles to be of type `"i"`; suppress both
    axis titles with empty strings; change the surrounding box to be an *L* shape;
    and suppress the drawing of the *x*-axis. Give the plot a suitable main title.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To shade the different colors underneath the curve, use a `for` loop, iterating
    through the integers 1 to 50\. At each iteration, the loop should call `polygon`
    (refer to [Section 15.2.3](ch15.xhtml#ch15lev2sec135)). Assuming your indexer
    is `i`, the vertices of each polygon should be formed by the vectors `vals[rep(c(i,i+1),each=2)]`
    and `c(0,normvals[c(i,i+1)],0)`. Each polygon should suppress its border and be
    colored according to the relevant `i`th entry in your color vector of length 50
    created in (h).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, ensure the `shape` package has been loaded and use your length 50 color
    vector to produce a color legend with default placement to reference “distance
    from mean.” You can easily set the `zlim` and `zval` arguments in the call to
    `colorlegend` using `vals`. Include an appropriate title for the legend. For reference,
    my result is given here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0648-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '**25.2 3D Scatterplots**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will look at creating 3D scatterplots, which allow you to plot
    raw observations based on three continuous variables at once, as opposed to only
    two in a conventional 2D scatterplot. You’ll then learn how to enhance your 3D
    scatterplot to represent more variables and make it easier to interpret. There
    are several ways to create three-variable scatterplots in R, but the go-to method
    is usually the `scatterplot3d` function in the contributed package of the same
    name ([Ligges and Mächler, 2003](ref.xhtml#ref42)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '***25.2.1 Basic Syntax***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The syntax of the `scatterplot3d` function is similar to the default `plot`
    function. In the latter, you supply a vector of *x*- and *y*-axis coordinates;
    in the former, you merely supply an additional third vector of values providing
    the *z*-axis coordinates. With that additional dimension, you can think of these
    three axes in terms of the *x*-axis increasing from left to right, the *y*-axis
    increasing from foreground to background, and the *z*-axis increasing from bottom
    to top.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Install and load the `scatterplot3d` package, and let’s go straight into an
    example. Recall the famous iris flower data, which you first encountered in [Section
    14.4](ch14.xhtml#ch14lev1sec47). This data set contains measurements on four continuous
    variables (petal length/width and sepal length/width) and one categorical variable
    (flower species); the `iris` data frame is immediately accessible from the R prompt,
    so there’s no need to load anything. Enter the following so you have quick access
    to the measurement values that make up the data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The most basic 3D scatterplot of, say, petal length, petal width, and sepal
    width, is achieved with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s as simple as that—the result of this code is given on the left of [Figure
    25-7](ch25.xhtml#ch25fig7). Here you can observe a general positive relationship
    among all three plotted variables. There’s also a clearly isolated cluster of
    observations in the foreground that have relatively large sepal widths but small
    petal measurements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-7: Two 3D scatterplots of the famous* `iris` *data with petal width,
    petal length, and sepal width on the* x*-,* y*-, and* z*-axis, respectively. Left:
    Basic default appearance. Right: Tidying up titles and adding visual enhancements
    to emphasize 3D depth and legibility via color and vertical line marks.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '***25.2.2 Visual Enhancements***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can be difficult to clearly perceive depth in the plotted cloud of points,
    even with the box and *x*-*y* plane grid lines that are drawn by default. For
    this reason, there are a couple of optional enhancements you can make to a `scatterplot3d`
    plot—coloring the points to help make the transition from foreground to background
    clearer and setting the `type="h"` argument to draw lines perpendicular to the
    *x*-*y* plane.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The right-hand plot in [Figure 25-7](ch25.xhtml#ch25fig7) shows the plot with
    these enhancements and is the result of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`xlab`, `ylab`, `zlab`, and `main` control the corresponding titles of the
    three axes and the plot itself.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The vertical lines make reading the values of the points much easier. By default,
    those lines in a `type="h"` plot are solid, but you can alter this with the `lty.hplot`
    argument (which behaves in the same way as the standard graphical parameter `lty`);
    setting `lty.hplot=2` requests dashed lines. Similarly, you can alter the line
    type of the “nonvisible” sides of the box; setting `lty.hide=3` instructs the
    plot to draw those lines as dotted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Setting `highlight.3d=TRUE` emphasizes 3D depth by applying color transitioning
    from red to black based on the *y*-axis position of a point. This is useful, but
    there’s an important consequence—it means you can no longer use color to represent
    a fourth variable with such a plot.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Along that line of thought, remember that the `iris` data has a fourth continuous
    variable, sepal length (stored as `slen` in [Section 25.2.1](ch25.xhtml#ch25lev2sec249)),
    that you’re not displaying in either of the plots in [Figure 25-7](ch25.xhtml#ch25fig7).
    You’re also not displaying the categorical variable of flower species, so let’s
    fix that. First, set up a color band for the missing measurement variable, using
    your knowledge of having color palettes reference a continuous variable from [Section
    25.1.4](ch25.xhtml#ch25lev2sec245).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that for the last line to run, you’ll need to have the `normalize` function
    defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245) available in your current
    session.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code produces the 3D scatterplot, which also uses the `pch` argument
    to distinguish among the three different species:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I’ve used the vector `c(19,17,15)`, with the numeric coercion of the `iris$Species`
    vector passed to the square brackets, to pair `pch` character numbers as follows:
    `19` with *Iris setosa* (the first level of the factor), `17` with *Iris versicolor*
    (the second level), and `15` with *Iris virginica* (the third level), respectively
    (refer to [Figure 7-5](ch07.xhtml#ch7fig5) on [page 133](ch07.xhtml#page_133)
    for the different types of point characters).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: You can then insert a legend referencing species with a familiar call to `legend`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And with a little experimentation, you can include a color strip legend too
    (making sure you’ve loaded the `shape` package so you have access to the `colorlegend`
    function as per [Section 25.1.4](ch25.xhtml#ch25lev2sec245)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The final result of all this is the image in [Figure 25-8](ch25.xhtml#ch25fig8).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-8: A 3D scatterplot of the famous* `iris` *data, displaying all
    five present variables with the additional use of color (for sepal length) and
    point character (for species).*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: With the creative use of color and point type, you’ve now been able to display
    the five-dimensional data in a single 3D scatterplot. This reveals important information
    about the data. For instance, you can now identify *Iris setosa* as the clearly
    separate group of points in the foreground and see that while *Iris setosa* tend
    to have smaller petal widths and lengths and larger sepal widths than the other
    two species (especially *Iris versicolor*), the purple coloring at the lower end
    of the scale suggests they tend to have smaller sepal lengths.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.2**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `scatterplot3d` library has been loaded in your current R session.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn your attention back to the `diabetes` data frame found in the `faraway`
    package (you first looked at these data in [Section 21.5.2](ch21.xhtml#ch21lev2sec203)).
    Your goal is to produce a `scatterplot3d` plot of weight, hip, and waist measurements
    as per the following guidelines:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Hip, waist, and weight variables should correspond to the *x*-axis, *y*-axis,
    and *z*-axis, respectively; provide neat axis titles.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use built-in functionality to ensure the 3D depth is highlighted by color.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Choose two different point characters to reflect gender.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Place a simple legend referencing these two point characters and gender in
    the blank space in the upper-left area.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a 3D scatterplot of the built-in `airquality` data, which you first
    met in [Section 24.2.2](ch24.xhtml#ch24lev2sec239), according to the following
    guidelines:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Create a copy of the data frame using `na.omit` to remove all rows that contain
    missing values and work with this copy.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Plot wind speed and solar radiation against the *x*- and *y*-axes, respectively,
    using the *z*-axis to plot temperature.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Apply vertical dotted lines reaching up from the *x*-*y* plane to each observation.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The data in `airquality` are comprised of measurements taken over five months,
    from May to September. Each plotted point should take on the corresponding `pch`
    value from `1` to `5` respective to the order of these five months.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – With a vector of 50 colors generated from the built-in `topo.colors` palette,
    use the categorization approach to ensure each plotted point is colored according
    to its ozone value.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Set a legend to reference the five point types according to month.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Set a color legend (using functionality from the `shape` package) to reference
    the ozone value accordingly.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Ensure the plot has neat axis, main, and legend titles.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**25.3 Preparing a Surface for Plotting**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the rest of this chapter, you’ll look at three types of 3D plots geared to
    visualize a *bivariate surface*. Such plots are required when you have two variables,
    based on which a function, estimate, or model has been defined, and you want to
    use the third available axis (in other words, the *z*-axis) to map out the resulting
    surface. You’ve seen examples of bivariate functions already, through the response
    surfaces for the `mtcars` data in [Section 21.5.4](ch21.xhtml#ch21lev2sec205)
    (where you looked at mean MPG as a function of car weight and horsepower) and
    through the study of diagnostic tools for linear regression models in [Section
    22.3.6](ch22.xhtml#ch22lev2sec219) (where you saw how Cook’s distance can be expressed
    as a function of residual and leverage).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Before you look at producing these plots, it’s important to understand how they’re
    created in R. The function/estimate/model of interest should be thought of as
    a plane or surface that can vary according to continuous, two-dimensional *x*-*y*
    coordinates. Plotting a completely continuous surface is technically impossible
    since that would require you to evaluate the function at an infinite number of
    coordinates. Therefore, evaluation of the surface is typically performed on a
    finite *grid* of evenly spaced coordinates along both the *x*- and *y*-axes. The
    result of the function at each unique pair of coordinates is stored in a corresponding
    position in an appropriately sized matrix (the size of which depends directly
    upon the resolution of the evaluation grid in the *x*- and *y*-axes), generically
    referred to as the *z-matrix*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Since all the traditional R graphics commands that plot these bivariate functions
    operate in the same way—using this *z*-matrix—it’s critical to understand how
    this matrix is constructed, arranged, and interpreted by those commands to ensure
    you’re correctly drawing the outcome. In this section, you’ll ready yourself for
    the specific plot types looked at in the remainder of this chapter by getting
    familiar with this construct in a hypothetical situation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***25.3.1 Constructing an Evaluation Grid***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you have a bivariate function that results in a continuous surface that’s
    defined between 1 and 6 on the *x*-axis and 1 and 4 on the *y*-axis. You can define
    evenly spaced sequences over each of these coordinate ranges using `seq`; for
    simplicity, let’s just do so in straight-out integers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What this implies is that you’re planning to draw your surface based on evaluation
    of the bivariate function of interest upon the grid of *x*-*y* values defined
    by 24 unique positions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When passed two vectors, the built-in `expand.grid` function explicitly generates
    all unique coordinate pairs by simply repeating each value in the second vector
    against the entire length of the first vector.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result is stored as a two-column data frame with 24 rows. If you look at
    `xycoords` object in the R console, you’ll see `x` values from `1` to `6` all
    paired with a repeated `y` value of `1`, then `x` from `1` to `6` paired with
    `y` as `2`, and so on.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, what you’d now do is use the evaluation grid coordinates in `xycoords`
    to calculate the result of your bivariate function. For this hypothetical example,
    let’s just say that your bivariate function has resulted in the 24 letters *a*
    to *x*, corresponding to the order of the unique evaluation coordinates in `xycoords`.
    To make this even clearer, take a look at the following column-bind of the hypothetical
    function result with each evaluation coordinate (note that the ready-to-use `letters`
    object in R allows you to generate letters of the alphabet quickly):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What this emphasizes is that each unique *x*-*y* evaluation coordinate, expressible
    via `expand.grid`, will have a *z* value associated with it. All together, these
    *z* values define the resulting surface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '***25.3.2 Constructing the z-Matrix***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3D plots used to visualize a bivariate function require the *z* values corresponding
    to the *x*-*y* evaluation grid in the form of an appropriately constructed matrix.
    The size of the *z*-matrix is determined directly by the resolution of the evaluation
    grid; the number of rows corresponds to the number of unique *x* grid values,
    and the number of columns corresponds to the number of unique *y* grid values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You therefore need to take a little care turning your calculated *z* values
    into a matrix. When your vector of *z*-axis values corresponds to the evaluation
    grid arranged in the standard `expand.grid` fashion (in other words, where coordinates
    are stacked by increasing *x* values and repeated *y* values), be sure that your
    resulting *z*-matrix is filled in the default column-wise fashion (see [Section
    3.1.1](ch03.xhtml#ch03lev2sec24)), with the number of rows and columns being exactly
    representative of the number of values in each of the *x*- and *y*-value sequences,
    respectively (`xcoords` and `ycoords` shown earlier). In the current example,
    you know that the resulting *z*-matrix needs to be of size 6 × 4 because there
    are six *x* locations and four *y* locations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the correct matrix representation of the hypothetical “function
    result” vector `z`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***25.3.3 Conceptualizing the z-Matrix***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important thing to be gained from this section is an idea of how the
    *z*-matrix in its current arrangement translates to *x*-*y* coordinate-based plotting.
    Comparing `zmat` to the earlier output, you can see that moving down a column
    of `zmat` translates to an increase in the *x*-coordinate value for a given *y*-coordinate
    value. In other words, when this hypothetical surface of letters is plotted, moving
    down a column of the matrix corresponds to moving horizontally from left to right
    on the corresponding plot, given a particular vertical *y* position.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-9](ch25.xhtml#ch25fig9) provides a conceptual diagram of this illustrative
    surface, indexed by `zmat` as per the 24 unique coordinates defined via `xcoords`
    and `ycoords`. (The code to produce this is included in the R script files for
    this book, which can be found at *[https://www.nostarch.com/bookofr/](https://www.nostarch.com/bookofr/)*.)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-09.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-9: Conceptual diagram of a* z*-matrix for plotting bivariate functions,
    based on a 6* × *4 coordinate grid*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: As you now progress to plot some actual surfaces of interest, you should keep
    the concept of the *z*-matrix as illustrated in [Figure 25-9](ch25.xhtml#ch25fig9)
    in mind. The 6 × 4 grid used in this hypothetical example is coarse. In practice,
    you’ll usually use far finer grids in terms of the resolution of the *x*- and
    *y*-sequences to improve the visual appearance of the surface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**25.4 Contour Plots**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common plots used to display a surface based on evaluation of
    a function over a grid of bivariate coordinates is the *contour plot*. Contour
    plots are perhaps most easily explained as a series of lines—the contours—drawn
    over the 2D evaluation grid, with each contour marking off a specific level of
    the surface of interest.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***25.4.1 Drawing Contour Lines***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Based on a given numeric *z*-matrix, the R function `contour` is what’s used
    to produce the contours connecting *x*-*y* coordinates that share the same *z*
    value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1: Topographical Map**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For an example, you’ll use another ready-to-use data set—the `volcano` object.
    This data set is simply a matrix containing measurements of the elevation above
    sea level (in meters) of a dormant volcano over a rectangular area in the Auckland
    region of New Zealand; see the documentation in `?volcano` for details. To view
    the topography, you need the `volcano` object (which is your *z*-matrix) and the
    relevant *x*- and *y*-coordinate sequences. In this case, just use integers corresponding
    to the size of the `volcano` matrix (row and column numbers can be obtained with
    a simple call to `dim`; see [Section 3.1.3](ch03.xhtml#ch03lev2sec26)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The *x*- and *y*-sequences are provided to `x` and `y`, respectively, and the
    *z-*matrix to `z`. The optional argument `asp=1`, referring to the aspect ratio
    of the plot, forces a 1-to-1 unit treatment of the coordinate axes (this is relevant
    when the units have a physical size interpretation, like in plots of geographical
    regions—as is the case here).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-10](ch25.xhtml#ch25fig10) shows the result of this example. By default,
    R automatically chooses the levels of `z` at which to draw the contours for an
    aesthetically pleasing result. Contours are also selectively labeled with their
    corresponding *z* value. Looking at the topography, you can see the highest peak
    is a rim on the left, marked by an oblong contour at 190 m, with a depression
    (at around 160 m) falling immediately to the right.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-10: Using* `contour` *to produce a topographic map of the* `volcano`
    *data*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Contours are able to show you not only the peaks and troughs in a surface like
    this but the “steepness” of any such features too. The closer together the contour
    lines lie, the more rapid the change in the overall level of the bivariate function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2: Parametric Response Surface**'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As a different kind of example, consider the multiple linear model fitted to
    the `mtcars` data mentioned earlier—that is, of MPG modeled by horsepower, weight,
    and an interaction between the two predictors. As in [Section 21.5.4](ch21.xhtml#ch21lev2sec205),
    you can get the fitted model object with the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The goal is to plot the response, mean mileage, as the previous function of
    horsepower and weight. To do this, you need to evaluate the mean MPG, according
    to the previous model, for a grid of horsepower and weight values. The following
    code does exactly that.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, this code sets up evenly spaced sequences (each of length 20, spanning
    the range of the observed data) in both `hp` and `wt`—these are your *x-*and *y*-sequences.
    This implies there will be 20 × 20 = 400 unique coordinates at which you’ll be
    evaluating the fitted model; these coordinates are obtained using `expand.grid`
    as in [Section 25.3](ch25.xhtml#ch25lev1sec88).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can use `predict` to get the 400 corresponding mean MPG (*z*) values;
    since it’s already a data frame in the required format, `hp.wt` can be passed
    directly to the `newdata` argument.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, you simply need to arrange the resulting vector as the appropriate 20
    × 20 *z*-matrix.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, you plot the result as contours, as shown in [Figure 25-11](ch25.xhtml#ch25fig11).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this call, you can see the use of the optional `levels` argument. Rather
    than let R automatically decide at which values of *z* to show contours, you can
    supply a numeric vector to this argument with the specific levels at which to
    draw the lines. This numeric vector must be on the same scale as the resulting
    bivariate function of interest; here, I asked for contours at all integer levels
    from 32 through 8\. I also employ the familiar arguments `lty` and `lwd` to control
    the appearance of the contour lines themselves, which are set here as dashed and
    slightly thicker than usual.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, for contour plots in particular, you’ll often want to deviate from
    the default axis limit style, because the small amount of additional “padding”
    space that’s included in the default plot region (refer to [Section 23.4.1](ch23.xhtml#ch23lev2sec232))
    can be rather prominent—take another look at the volcano contour plot in [Figure
    25-10](ch25.xhtml#ch25fig10). As shown previously, setting `xaxs` and `yaxs` to
    `"i"` restricts all plotting to the exact limits imposed by `x` and `y`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-11: Contour lines depicting the response surface based on a multiple
    linear model of MPG by horsepower and weight, from the* `mtcars` *data*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 3: Nonparametric Bivariate Density Estimate (Earthquake Data)**'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another useful role fulfilled by contour plots and the other plots in this chapter
    is to visualize bivariate density functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 24.2.2](ch24.xhtml#ch24lev2sec239), you looked at the idea of kernel
    density estimation (KDE) as a method by which to construct smooth estimates of
    the probability density functions of your data—essentially, sophisticated histograms.
    KDE extends to higher dimensions quite naturally so that you can also estimate
    the density of bivariate observations in the *x*-*y* plane. This again involves
    visualizing a *z*-matrix over a fixed grid of coordinates. For theoretical details
    on multivariate KDE, see Wand and Jones ([1995](ref.xhtml#ref70)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn your attention back to the built-in `quakes` data frame and recall the
    plots of the spatial coordinates of the 1,000 seismic events (for example, [Figure
    13-1](ch13.xhtml#ch13fig1) on [page 265](ch13.xhtml#page_265) and [Figure 23-1](ch23.xhtml#ch23fig1)
    on [page 578](ch23.xhtml#page_578)). To estimate the probability density function
    of these points, you can use the `kde2d` function in the `MASS` package. Load
    `MASS` and execute the following line to produce the kernel estimate of the observed
    two-dimensional data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You supply the bivariate data as the `x` and `y` arguments for the horizontal
    and vertical axes. The optional argument `n` is used to specify the number of
    evaluation coordinates (along each of the two axes) at which to actually return
    the estimated density surface. This defines the size of the matrix returned by
    a call to `kde2d`. Here, you’ve asked for KDE to be performed on a 100 × 100 evenly
    spaced grid over the range of the observed data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting object is simply a list with three members. The components accessed
    through `$x` and `$y` contain the evenly spaced evaluation grid coordinates in
    the corresponding axis directions, and `$z` provides you with the corresponding
    *z*-matrix. You can confirm by entering either `quak.dens$x` or `quak.dens$y`
    at the prompt that they are indeed increasing sequences spanning the ranges of
    the observed data. Entering the following confirms the size of the matrix of interest:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that, you have all the ingredients you need to display contours of the
    KDE surface. The next line produces the default contour plot, given on the top
    left of [Figure 25-12](ch25.xhtml#ch25fig12).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are many more optional arguments available to `contour` for displaying
    your continuous surface. It can also be helpful to simultaneously view other data
    or raw observations (if they’ve been used in some way to create the surface, as
    is the case with bivariate KDE). The following code replots the `quakes` kernel
    estimate with unpadded axes, different contour levels to the defaults, and the
    raw observations; you can see the result on the top right of [Figure 25-12](ch25.xhtml#ch25fig12):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Rather than using `levels` to determine the exact levels at which to draw the
    contours (as you did with Example 2), you can use the `nlevels` argument to specify
    the *number* of levels to display, and the function will choose the specific values.
    This latest call to `contour` requested 50 levels to be drawn. You can suppress
    the automatic labeling of the displayed contours by setting `drawlabels=FALSE`,
    also done here, followed by a call to `points` to add the original observations
    to the image. Naturally, the smooth contours delineating the nonparametric density
    estimate reflect the heterogeneous spatial patterning of the data.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Changing the appearance of your plotted contours needn’t be done universally;
    you can also alter the appearance of each individual contour level. This can be
    handy if, for example, you want to display contours at a handful of specific levels
    without the default labeling (to focus on the shape of the surface itself) but
    still want to be able to discern the values of those contours. You might also
    want to superimpose contours on an existing plot that already depicts other data
    or model-based results of interest. The third plot of the earthquake KDE surface,
    given on the bottom of [Figure 25-12](ch25.xhtml#ch25fig12), shows how you can
    achieve both of these things.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-12.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-12: Three examples of a contour plot of the bivariate kernel estimate
    of the probability density function of the spatial earthquake locations given
    in the* `quakes` *data set*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: To start the plot, the spatial locations of the earthquake data are drawn as
    half-size gray dots using `plot`, the style of the axes are set using `xaxs` and
    `yaxs` to remove the artificial padding around the edges of the plot region, and
    axis titles are added.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, before calling `contour`, store the desired levels at which to draw contours
    in a vector named `quak.levs` (again, choosing appropriate contour levels depends
    entirely on what kind of surface you’re plotting; you need to be at least roughly
    aware of the values stored in the relevant *z*-matrix).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, remember that by default, `contour` refreshes the graphics device and starts
    a new plot, but you want to avoid that when adding contour lines to an existing
    plot. To do so, you need to explicitly specify `add=TRUE`. You then provide the
    four specified levels in `quak.levs` to `levels` and suppress labeling with `drawlabels=FALSE`.
    To control the appearance of contour lines at individual levels, you supply the
    sequence of integers `4:1` to `lty`, the first entry of which, `4`, defines the
    line type of the contour at *z* = 0.001\. The second entry, `3`, specifies the
    line type of the *z* = 0.005 contour, and so on. Lastly, set all drawn contours
    to double-thickness with the single supplied value `lwd=2`. (You could supply
    a vector with four elements here too, if you want differing line thicknesses for
    the different contours. The same element-wise contour specification extends to
    other relevant aesthetics, such as color via `col`.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As a final touch, since the automatic labeling was suppressed in `contour`,
    add a legend in the bottom-left corner of the plot region, referencing the values
    of the contours through the four different line types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**NOTE**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '*Many built-in and contributed base R plotting functions that by default initialize,
    refresh, or open a new plot include an* `add` *argument as shown here. This allows
    you to use the graphics produced by these functions as additions to an already
    existing graphic. Look in the relevant help file to see whether this is the case
    for a given command.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '***25.4.2 Color-Filled Contours***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a straightforward variation on the contour plot, you can use color to fill
    the gaps between the different levels that are drawn. Combined with a color legend,
    this removes the need to label the contour lines and in certain cases can make
    it easier to visually interpret fluctuations in the plotted *z*-matrix surface.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The `filled.contour` function does this for you. You need to supply the increasing
    sequences of grid coordinates in both the *x*-axis and *y*-axisdirections, as
    well as the corresponding *z*-matrix, to the arguments `x`, `y`, and `z` in the
    same way as in `contour`. The easiest way to specify the colors is to supply a
    color palette to the `color.palette` argument (which defaults to the built-in
    `cm.colors` palette; refer to [Figure 25-2](ch25.xhtml#ch25fig2)), and R does
    the rest.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `mtcars` response surface from Example 2 for a quick demonstration.
    If you don’t already have them in your current workspace, use the code from [Section
    25.4.1](ch25.xhtml#ch25lev2sec254) to obtain the relevant fitted multiple linear
    regression model, the evaluation grid coordinates, and the prediction thereof.
    With the objects `hp.seq`, `wt.seq`, and `car.pred.mat` defined as earlier, the
    following call produces [Figure 25-13](ch25.xhtml#ch25fig13):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![image](../images/f25-13.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-13: Filled contour plot of the response surface for the fitted multiple
    linear model of the* `mtcars` *data*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Note in this plot that the default color palette hasn’t been used. Instead,
    you’ve supplied a custom palette (produced as a direct result of an appropriate
    call to `colorRampPalette`; refer to [Section 25.1.3](ch25.xhtml#ch25lev2sec244))
    to the relevant argument, moving from white at the lower end to dark red at the
    upper end. Note also that although the *x*-axis and *y*-axis titles are provided
    as usual to `xlab` and `ylab`, you have to supply the title for the color legend
    in a particular way—inside a call to `title` to the `key.title` argument. This
    is because `filled.contour` actually produces two plots, one for the image itself
    and one for the color legend, and makes use of the `layout` command to place them
    next to one another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This internal use of `layout` isn’t directly a problem, but, as you saw in [Section
    23.1.4](ch23.xhtml#ch23lev2sec225), it complicates matters somewhat if you want
    to annotate the filled contour plot after the fact (by, for example, adding points
    to an existing graphic) since the original user coordinate system is lost.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Turn your attention back to the two-dimensional kernel estimate of the spatial
    `quakes` data (use the code from [Section 25.4.1](ch25.xhtml#ch25lev2sec254) to
    re-create it if you haven’t already got the `quak.dens` object in your workspace).
    The following code creates a filled contour plot of the density surface using
    the built-in `topo.colors` palette and modifies the number of drawn levels from
    the default of 20 to 30\. In the same call, you can superimpose the points of
    the raw observations onto the image through special use of the optional `plot.axes`
    argument. [Figure 25-14](ch25.xhtml#ch25fig14) shows the result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![image](../images/f25-14.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-14: Filled contour plot of the kernel estimate of the probability
    density function of the spatial* `quakes` *data, with raw observations superimposed.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the way in which `plot.axes` is used; it effectively takes a
    chunk of code. When `plot.axes` is invoked, you must explicitly tell it to mark
    the *x*- and *y*-axes if you want the labeled tick marks to remain. This is done
    with two calls to `axis` (refer to [Section 23.4.3](ch23.xhtml#ch23lev2sec234)—`axis(1)`
    gives *x*, and `axis(2)` is used for *y*). You add the data points with a call
    to `points`; in this example, these are instructed to plot at half size, with
    30 percent opacity imparted with `adjustcolor`. Since you’re supplying multiple
    separate commands at once to the `plot.axes` argument, each command needs to be
    separated by a semicolon (`;`) inside braces (`{ }`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Annotation of a filled contour plot in this fashion requires a little more forethought
    since you’re required to manually add the axes via calls to `axis` and perform
    all subsequently desired plotting actions within the call to `filled.contour`.
    It won’t work to, for example, produce a filled contour plot like the `quakes`
    KDE surface and then call `points` as a separate line of code. If you try it,
    you’ll see the observed data points unable to align correctly with their original
    user coordinates as indicated on the axes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.3**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you inspected various multiple linear regression models of the
    cost of nuclear power plant construction in [Chapters 21](ch21.xhtml#ch21) and
    [22](ch22.xhtml#ch22). The goal now will be to visually assess the impact of including/excluding
    an interactive term between two continuous predictors using contours. Revisit
    the `nuclear` data set, available when you load the `boot` package, and bring
    up the help file to refresh your memory of the variables present.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Fit and summarize two linear models with construction cost as the response
    variable according to the following guidelines:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first should account for main effects of the two predictors concerning the
    date of issue of the construction permit and plant capacity.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second, in addition to the two main effects, should include an interaction
    between permit issue date and capacity.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up appropriate *z*-matrices for plotting each of these response surfaces.
    Each one should be based on a 50 × 50 evaluation grid constructed using evenly
    spaced sequences in the capacity and date variables.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify `mfrow` in `par` so that you can display default contour plots for the
    two response surfaces from (a)(i) and (a)(ii) next to one another. Do they appear
    similar? Does thistie in with the statistical significance (or lack thereof) of
    the interaction term in (a)(ii)?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To directly compare the two surfaces, use your choice of built-in color palette
    to produce a filled contour plot of the main-effects-only model and superimpose
    the contour lines of the interactive model on it. Take note of the following:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – This plot is achieved in a single call to `filled.contour`. Recall the special
    way you use `plot.axes` to draw additional features on an existing color-filled
    contour plot.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The contour lines of the interactive model can be added with an appropriate
    call to `contour`. Recall the use of the optional argument `add`.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The superimposed contours should be dashed lines of double thickness.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The *x*- and *y*-axes should be included and given tidy titles.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Add some brief text describing the filled contours versus the contour lines,
    with reference to the two versions of the construction cost model and with an
    additional call to `text` that makes use of a single mouse-clicked location from
    `locator` (see [Section 23.3](ch23.xhtml#ch23lev1sec78)). Note that this call
    will need to fully relax clipping for the text to be visible in any of the margins.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My result is shown here.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0667-01.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Another built-in data frame in R, `faithful`, contains observations of waiting
    times and durations of eruptions of the Old Faithful geyser in Yellowstone National
    Park, Wyoming. See the documentation in `?faithful` for details. Plot the data
    with duration on the *y*-axis and waiting time on the *x*-axis.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate the bivariate density of these data via KDE using a 100 × 100 evaluation
    grid and produce a default contour plot thereof.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a filled contour plot of the kernel estimate using a custom palette that
    ranges from `"darkblue"` to `"hotpink"`; include the raw data as half-size gray
    points. Label the axes and titles appropriately.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replot the raw data as gray, 3/4-sized, type `2` point characters; set the style
    of the axes to restrict to exactly the ranges of the observed data; and ensure
    tidy axis titles and a main title. To this plot, add the contour lines of the
    density estimate at the specific levels obtained in a sequence from 0.002 to 0.014
    in steps of 0.004\. Suppress the labeling of the contours. The contour lines should
    be dark red and increase in line width thickness for higher levels of the density.
    Add a legend referencing the density level at each of these lines.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: My plots for (g) and (h) are shown here.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0668-01.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: '**25.5 Pixel Images**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pixel image* is arguably the most literal visual representation of a continuous
    surface approximated by a finite evaluation grid. Its appearance is similar to
    a filled contour plot, but an image plot gives you more direct control over the
    display of each entry of the relevant *z*-matrix.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '***25.5.1 One Grid Point = One Pixel***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider each entry of your *z*-matrix as a little rectangle whose color depicts
    its relative value. These rectangles, or *pixels*, are exactly what’s depicted
    as the cells formed by the dashed gray lines making up the conceptual diagram
    of the *z*-matrix in [Figure 25-9](ch25.xhtml#ch25fig9) on [page 656](ch25.xhtml#page_656).
    This emphasizes the important fact that the fineness of your evaluation grid sequences
    (in both the *x*- and *y*-coordinate directions) directly defines the size of
    each pixel and therefore the smoothness of the resulting image. A smaller pixel
    means the *resolution* of the image is increased.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `image` function plots pixel images. Much as with `contour`, you
    supply your *x*- and *y*-axis evaluation grid coordinates as increasing sequences
    to the `x` and `y` arguments, with the corresponding *z*-matrix supplied to `z`.
    Going back to the `volcano` data set first looked at in Example 1 of [Section
    25.4.1](ch25.xhtml#ch25lev2sec254), the following line produces [Figure 25-15](ch25.xhtml#ch25fig15):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note again that you use the optional argument `asp=1` to enforce a one-to-one
    aspect ratio of the horizontal and vertical axes. This plot is comprised of exactly
    87 × 61 = 5307 pixels; each one represents a particular entry in the `volcano`
    matrix. Visually, the reflection of this image in the contour plot of the same
    data in [Figure 25-10](ch25.xhtml#ch25fig10) is clear.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-15.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-15: Pixel image of the Auckland volcano topography*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The `image` command expects a vector of colors, usually supplied as hex codes
    from a palette, to be passed to its `col` argument. If this isn’t specified, it
    defaults to `heat.colors(12)` using the built-in palette, as in the image plot
    of `volcano`. One immediate concern, however, is the lack of a color legend. Contributed
    tools such as the `colorlegend` function from the `shape` package (refer to [Section
    25.1.5](ch25.xhtml#ch25lev2sec246)) prove useful for these plots.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Return now to the `mtcars` response surface from Example 2 that fits the multiple
    linear regression model of MPG on horsepower and weight (and an interactive effect
    between the two predictors). The code for the necessary objects is reproduced
    here in a shortened form for convenience (refer to [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    for a fuller explanation of the operations):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just as earlier, you’ve set up a matrix of 400 elements in `car.pred.mat`, which
    is based on sequences of length 20 in both continuous predictors.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Now, make sure the `shape` package is loaded so you have access to the `colorlegend`
    function. The code that follows first sets up a custom palette of blue colors,
    sets new margin limits that widen the area on the rightmost axis, and then plots
    the predicted 20 × 20 response surface including a color legend; the result is
    given on the left of [Figure 25-16](ch25.xhtml#ch25fig16).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![image](../images/f25-16.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-16: Two pixel images of the* `mtcars` *mean MPG response surface
    introduced in Example 2, with accompanying color legends. In terms of the evaluation
    grid in the horsepower and weight variables, the surface on the left has a resolution
    of 20 ²; the image on the right is based on a finer 50 ² grid. Contours are superimposed
    upon the rightmost plot.*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'With a relatively coarse evaluation grid, the pixels making up the surface
    are prominent. You can easily increase the resolution of the parametric response
    surface by using finer sequences for the `hp.seq` and `wt.seq` evaluation grid.
    The code that follows does just that by increasing `len` to `50`, over-writing
    the objects used previously:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then the right-hand image of [Figure 25-16](ch25.xhtml#ch25fig16) is produced
    with the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The newly plotted surface consists of 50² = 2500 pixels, as opposed to the previous
    image of merely 20² = 400 pixels. The improvement in the picture is obvious. In
    plotting the new image, the number of colors used (from the custom `blues` palette)
    is increased to 100 to provide smoother color transitions. Note also the use of
    `add` in a call to `contour` to superimpose contour lines upon the image to provide
    further visual emphasis of the fluctuating surface over the evaluation grid. A
    legend is added with an appropriate call to `colorlegend` as a final touch.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '***25.5.2 Surface Truncation and Empty Pixels***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of its one-to-one literal representation of the *z*-matrix, a pixel
    image is especially good when you want to plot a surface that fits irregularly
    over, or is smaller than, the standard rectangular evaluation grid spanning the
    *x-*and *y*-axes. To carefully demonstrate this kind of manipulation, let’s turn
    to a new data set from the contributed `spatstat` package by Baddeley and Turner
    ([2005](ref.xhtml#ref06)). Install `spatstat` with a call to `install.package("spatstat")`.
    Note that `spatstat` has a number of dependencies; see [Appendix A.2.3](app01.xhtml#app01lev2sec275)
    if you have any trouble downloading and installing `spatstat`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 4: Nonparametric Bivariate Density Estimate (Chorley-Ribble Data)**'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once `spatstat` is installed and loaded in your current R session with a call
    to `library("spatstat")`, inspect the help file brought up by entering `?chorley`
    at the prompt. This details the Chorely-Ribble cancer data—spatial locations of
    1,036 cases of cancer of the larynx and lung collected in the late 1970s and early
    1980s in a particular region of England (data first analyzed by [Diggle, 1990](ref.xhtml#ref18)).
    The `chorley` object is of a special class specific to `spatstat` (a `"ppp"` object—*planar
    point pattern*), but its components can be extracted just as if you’re referencing
    members of a named list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of the observations can be retrieved as the components `$x`
    and `$y`. To view the spatial dispersion of the observations, the following line
    gives you the top-left image of [Figure 25-17](ch25.xhtml#ch25fig17):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Your goal is to display a kernel estimate of the two-dimensional probability
    density function of the cancer distribution, similar to what you did with the
    earthquake data in Example 3\. You’ll use the `kde2d` function for this—execute
    `library("MASS")` to gain access to it. Then, exactly as you used it for the spatial
    locations of `quakes`, the default KDE surface for the observed Chorley-Ribble
    data is given with the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note the specification of a fine 256 × 256 easting-northing evaluation grid.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the density estimate, use the built-in `rainbow` palette and use
    the optional `start` and `end` arguments to restrict the total range of the palette
    to begin at red at the lower end and end at magenta/pink at the upper end (these
    arguments were mentioned briefly in [Section 25.1.2](ch25.xhtml#ch25lev2sec243);
    refer to the help file `?rainbow` for more details on the use of `start` and `end`).
    Prestore 200 colors from this palette with the following line:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, the image is produced by calling this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Another component of `chorley`, named `$window`, contains the vertices of an
    irregular polygon. This polygon defines the geographical study region in which
    the observations themselves were made. The `$window` component also happens to
    be another special object class of `spatstat`, namely, `"owin"` for “observation
    window.” Although it’s possible to extract the specific vertices of the polygon
    and plot it manually with built-in functionality, the authors of `spatstat` have
    provided a standard `plot` method to use for this purpose.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the `image` command, calling the following code superimposes
    the border of the study region upon the pixel image:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The final result is given on the top right of [Figure 25-17](ch25.xhtml#ch25fig17).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that the geographical region in which the data were collected
    is a little wider than the *x*- and *y*-ranges of the observations themselves,
    so the current plot hasn’t been able to show the region in its entirety. The following
    code shows this numerically:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The *x*- and *y*-ranges of the study region can be obtained as the `$xrange`
    and `$yrange` components of the `$window` component (which is stored in the first
    line as the object `chor.WIN`). You can see that the overall study region is slightly
    larger when you compare its limits to the results of calling `range` on the raw
    data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: That’s not the only problem, either. From the plot, you can also see that the
    KDE surface has been estimated and drawn in some areas that are actually *outside*
    the study region, so that will need to be fixed as well. (You’ll look at that
    in a moment.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-17.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-17: Visual experimentations in attempts to plot a two-dimensional
    kernel estimate of the probability density function of the Chorley-Ribble cancer
    data as a pixel image. Top left: The raw data. Top right: The default* `kde2d`
    *result based on the data ranges with the study region superimposed. Bottom left:
    Expanding the* `xlim` *and* `ylim` *of the call to* `image` *when plotting the
    original density estimate. Bottom right: A revised density estimate, using the
    full* x*- and* y*-ranges of the study region to define the evaluation grid.*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: So, first off, what can you do to ensure the entire geographical region is displayed?
    Well, you could of course use the ranges of the region as stored previously in
    the vectors `WIN.xr` and `WIN.yr` and supply them to the familiar optional `xlim`
    and `ylim` arguments when calling `image`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The result of these two lines is given on the bottom left of [Figure 25-17](ch25.xhtml#ch25fig17).
    Unfortunately, the original density estimate is still defined in terms of the
    original *x*- and *y*-ranges of the raw data, which gives you a border of empty
    pixels; in addition, the aforementioned density areas still fall outside the observation
    window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: All this emphasizes the important fact that a *z*-matrix is specific to a predefined
    evaluation grid. The only way to get your density estimate to span the geographical
    study region for the Chorley-Ribble data is to revise your kernel estimate so
    that it’s produced on an evaluation grid that spans the limits of the region.
    Fortunately, the `kde2d` function allows you to set optional *x*-*y* limits of
    the evaluation grid with the `lims` argument. This expects a numeric vector of
    length 4, with the *x*-axis lower and upper values followed by the *y*-axis lower
    and upper values, in that order. The following code reestimates the density using
    the study region limits and plots it. The result is given on the bottom right
    of [Figure 25-17](ch25.xhtml#ch25fig17).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With that, you’ve solved the problem of ensuring your surface spans the desired
    area. However, this definitely highlights the second problem—the data that were
    actually observed fall strictly within the defined polygon, but you can see plotted
    pixels outside the geographical region, which doesn’t make sense. You can control
    precisely which pixels are plotted in any given pixel image by setting the relevant
    entries in your *z*-matrix to be `NA` if you don’t want them drawn.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a mechanism that can decide whether a given cell entry in your *z*-matrix,
    namely, `chor.dens.WIN$z`, corresponds to a location inside or outside the polygon
    (the object `chor.WIN`). If it falls outside, you’ll want to force that entry
    to be `NA`. In general, this type of decision making requires you to test each
    element of the matrix with respect to its coordinate value on the evaluation grid,
    possibly using your own R function. Fortunately, in this case, the `inside.owin`
    function of `spatstat` does exactly that, but the principle remains the same whenever
    you need control over precisely which pixels are plotted and which aren’t.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Given one or more two-dimensional (*x*,*y*) coordinates and an object of class
    `"owin"`, the `inside.owin` function returns a corresponding logical vector with
    a `TRUE` for those coordinates inside the defined region and a `FALSE` for any
    other coordinate. As a quick demonstration, observe the following result:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This confirms what you can see from [Figure 25-17](ch25.xhtml#ch25fig17)—that
    the coordinate (355,420) lies well within the polygon and that the coordinate
    (345,415) doesn’t.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to use the `inside.owin` function on every coordinate in the evaluation
    grid that *z*-matrix `chor.dens.WIN$z` sits on. First, create the full set of
    grid coordinates using `expand.grid`, in the same way as illustrated in [Section
    25.3.1](ch25.xhtml#ch25lev2sec251).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Calling `nrow` on the resulting data frame of coordinates confirms you have
    exactly 256² = 65536 grid points as defined in the `chor.dens.WIN` KDE object.
    The following call then takes the two columns of `chor.xy` and makes use of logical
    negation (using `!`) to produce a logical vector that flags grid coordinates that
    are located *outside* the defined geographical region.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The final step is now at hand.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: First, for clarity, recast the long `chor.outside` vector as a 256 × 256 matrix
    to emphasize that it corresponds exactly to the *z*-matrix of interest. Then this
    logical flag matrix is used to directly overwrite the “outside” entries in the
    *z*-matrix to be `NA`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'All that’s left now is to plot the image with the newly manipulated *z*-matrix.
    Make sure you have the `shape` package loaded for the finishing touch of a color
    legend. The following code creates the KDE surface pixel image plot with pixel
    points restricted to the geographical region defined by `$window` only:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: First you open a new graphics device and widen the right margin to incorporate
    the color legend. Next you invoke `image` to plot, specifically using an *L*-shaped
    box and a strict one-to-one *x*-*y* aspect ratio, and then you add the region
    polygon with slightly thicker lines. Finally you execute `colorlegend` to obtain
    an appropriately positioned legend referencing the color values (the specific
    positioning and tick marks of which were found after a little trial and error).
    You can see the final result in [Figure 25-18](ch25.xhtml#ch25fig18).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-18.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-18: Final pixel image plot of the Chorley-Ribble KDE surface, restricted
    to the geographical study region of the originally collected data.*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '*In truncating the kernel estimate of the bivariate density estimate that was
    originally defined over the full rectangular evaluation grid, technically you
    no longer have a valid probability density function as a result (since the integral
    over the irregular region will no longer evaluate to a total probability of 1).
    A more mathematically sound approach requires a deeper knowledge of multivariate
    KDE and is beyond the scope of this text. Nevertheless, being able to truncate
    pixel plots like this is useful in any situation where you want to define your
    surface on a (possibly irregular) subset of an overall rectangular evaluation
    grid.*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.4**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisit the built-in `airquality` data set and take a look at the help file
    to refresh your memory of the variables present. Create a copy of the data frame:
    select the columns pertaining to daily temperature, wind speed, and ozone level
    and use `na.omit` to remove any records with missing values.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: From your explorations of these data in [Chapter 24](ch24.xhtml#ch24), there
    appears to be an association among daily temperature, wind speed, and ozone level.
    Fit a multiple linear regression model that aims to predict mean temperature based
    on the wind speed and ozone level, including an interactive effect. Summarize
    the resulting object.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the model from (a), construct a *z*-matrix of predicted mean daily temperature
    based on a 50 × 50 evaluation grid in both wind speed and ozone.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a pixel image of the response surface, superimposing the raw observations
    as per the following:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – A graphics device should be initialized based on bottom, left, top, and right
    margin lines of 5, 4, 4, and 6, respectively.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – 20 colors from the built-in `topo.colors` palette should be used to produce
    the image; include tidy axis titles.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Revisit the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    and use the built-in function `gray` to generate a vector of gray colors (refer
    to [Section 25.1.2](ch25.xhtml#ch25lev2sec243)) based on the normalized raw temperature
    observations. Superimpose the raw observations based on wind speed and ozone onto
    the pixel image, using the gray color vector to indicate the corresponding temperature
    observations.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Two separate calls should then be made to `colorlegend` of the `shape` package.
    The first should appear in the space on the right margin, referencing the surface
    itself. The second should use the built-in `gray.colors` function, setting the
    optional arguments `start=0` and `end=1`, to generate 10 shades of gray for use
    in the legend that references the raw temperature observations of the superimposed
    points. This legend should reside on top of the pixel image itself, in the upper-right
    quadrant where there are no raw observations.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Both legends should have appropriate titles, and you may need to experiment
    a little with the `posx` and `posy` arguments to find satisfactory placement.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My result of this plotting exercise appears here.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0677-01.jpg)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In [Section 25.5.2](ch25.xhtml#ch25lev2sec257), you used the `chorley` data
    set in creating a pixel image truncated to a subset of the overall rectangular
    evaluation grid. Ensure `spatstat` is loaded in your current R session and execute
    the following two lines:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: R> fire <- split(clmfires)$intentional
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: R> firewin <- clmfires$window
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: This extracts the 1,786 locations of fires recorded as intentionally lit in
    a particular region of Spain. The spatial coordinates can be extracted as the
    `$x` and `$y` members of `fire`, and the geographical region itself is stored
    as a polygon in `firewin` (of the same class as the `chorley$window` object you
    looked at earlier). See the documentation obtained with `?clmfires` for further
    details.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Using the total *x*- and *y*-range of the study region, use `kde2d` from the
    `MASS` package to calculate a bivariate kernel estimate of the probability density
    function of the spatial dispersion of intentionally lit fires. The KDE surface
    should be calculated based on a 256 × 256 evaluation grid.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all points on the rectangular evaluation grid that fall outside the
    geographical region using `expand.grid` in conjunction with `inside.owin`. Set
    all corresponding pixels of the density surface to `NA`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct a pixel image of the truncated density, as per the following:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – The graphics device should have three lines of space on the bottom, left,
    and top of the plot region and should have seven lines on the right.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – In producing the image itself, you should use 50 colors generated from the
    built-in `heat.colors` palette. A one-to-one aspect ratio should be maintained,
    the axis titles should be suppressed, and the box type set to be an *L* shape.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The geographical study region should be superimposed onto the image using
    a double-width line.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `colorlegend` from `shape`, a color legend referencing the density with
    an appropriate title should be placed to the right of the image. You’ll need to
    experiment with the `posx` argument for placement. Label the legend at a sequence
    from `5e-6` to `35e-6` in steps of `5e-6` (refer to [Section 2.1.3](ch02.xhtml#ch02lev2sec19)
    for an explanation of e-notation); also, ensure these labels are able to display
    up to six decimal places of precision.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For your reference, my result is given here.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0679-01.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: '**25.6 Perspective Plots**'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last kind of plot you’ll look at in this chapter is the *perspective plot*,
    some-times also referred to as a *wireframe*. Unlike contour plots and pixel images,
    where fluctuations in the surface are emphasized with line patterns and/or colors,
    a perspective plot uses a physical third dimension against which the *z* value
    is plotted.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.1 Basic Plots and Angle Adjustment***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perspective plots are especially useful when you want to emphasize the fluctuating
    nature of the values populating your *z*-matrix. For example, in some applications
    you might want to get a good impression of the relative extremity of any present
    peaks and/or troughs in the plotted surface, which is harder to do in, for example,
    a pixel image or contour plot.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the `mtcars` response surface plotted as contours and as pixel images
    in [Sections 25.4.1](ch25.xhtml#ch25lev2sec254) and [25.5.1](ch25.xhtml#ch25lev2sec256).
    You created a 20 × 20 evaluation grid in the horsepower and weight variables,
    as well as a corresponding *z*-matrix of 400 giving the predicted mean MPG result:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The built-in R function `persp` is used to create perspective plots. Its basic
    usage is the same as `contour`, `filled.contour`, and `image`. Your increasing
    sequences in the *x*- and *y*-axis directions, which define the evaluation grid,
    are passed to `x` and `y`, with your corresponding *z*-matrix passed to `z`. Bring
    up the default appearance for the 20 × 20 `mtcars` response surface with the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This appears in the top left of [Figure 25-19](ch25.xhtml#ch25fig19).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the perspective plot is straightforward. The default viewing angle
    shows the *x*-axis in the foreground, increasing from left to right, and the *y*-axis
    on the left side, increasing from the foreground to deeper in the background.
    In this way, the evaluation grid lies flat along the bottom in the 3D graphic,
    with the *z*-axis against which your surface is plotted increasing from the bottom
    vertically to the top.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The viewing angle is one of the most important aspects of such a plot. In `persp`,
    you can control it with the two optional arguments `theta`, which spins the plot
    around horizontally, and `phi`, which adjusts the vertical viewing position. Both
    are specified in degrees; `theta` defaults to `0`, so you’re looking directly
    at the *x*-axis spanning left to right in front of you, and `phi` defaults to
    `15` to give a slightly elevated viewing position so you can see the *y*-axis
    extending foreground to background. In general, you can think of the possible
    value of `theta` as anywhere from `0` to `360`, representing a complete rotation
    all around the plot, and the possible value of `phi` as anywhere from `90` to
    `-90`, the range of which moves you from a bird’s-eye view directly from the top
    looking down to a submarine view directly from the bottom looking up.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'This second example demonstrates this behavior:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In fact, it’s this line of code that originally produced the rightmost image
    in [Figure 21-9](ch21.xhtml#ch21fig9) on [page 523](ch21.xhtml#page_523) (when
    you were introduced to the concept of an interactive term between two continuous
    predictors in a multiple linear regression model). The graphic is reproduced here
    in the top right of [Figure 25-19](ch25.xhtml#ch25fig19). The axis titles are
    tidied up using `xlab` and `ylab`, with `zlab` used to control the title for the
    third vertical axis. The use of `theta` and `phi` in this instance has elevated
    the viewing point slightly more than the default and rotated the plot so that
    the origin (in other words, the lower vertex denoting the lower limit of the *x*-*y*
    plane) is prominent in the foreground. It’s worth noting that increasing `theta`
    from `0` rotates the plot in a clockwise-horizontal fashion, but you could also
    supply a negative value to that argument to rotate the plot in the other direction.
    Setting `theta=-30`, as shown here, has the same effect as setting `theta=330`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-19.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-19: Perspective plots of the 20* × *20* `mtcars` *response surface
    created using* `persp`*. Top left: Default appearance. Top right: Using* `theta`
    *and* `phi` *to adjust the viewing angle. Bottom left: Setting* `ticktype="detailed"`
    *to provide detailed axis labeling. Bottom right: Adding depth shading using*
    `shade` *and removing facet border lines with* `border=NA`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are no tick marks or labels included, only directional arrows.
    You can remedy this by setting the optional `ticktype` argument to `"detailed"`.
    You can find the result of the following in the bottom left of [Figure 25-19](ch25.xhtml#ch25fig19),
    which also offers another viewing angle:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The help file `?persp` details a host of other arguments specific to controlling
    the presentation of any given perspective plot. As a few examples, you could shade
    the surface in grayscale to emphasize the 3D depth of the image, you could change
    the color or suppress the plotting of the grid lines making up the surface itself,
    or you could change the relative length of the *z*-axis. The final plot of the
    `mtcars` response surface illustrates such actions. The result of the following
    call is visible in the bottom right of [Figure 25-19](ch25.xhtml#ch25fig19).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With the same viewing angle as the previous plot, this plot uses the `shade`
    argument to shade the surface facets to produce a lighting-style effect, enhancing
    the perceptive depth slightly. The calculations for the shading rely on a non-negative
    numeric value; setting `shade=0.6` provides a moderate-strength effect. You might
    like to experiment with larger or smaller values. If you’re shading the surface
    in this way, it’s usually best to suppress the grid lines that by default make
    up the surface; you can set `border=NA` to achieve this (the `border` argument
    can also be used to simply change the surface grid color by supplying any valid
    R color to it). Finally, the `expand` argument is used to adjust the size of the
    *z*-axis. Specifying `expand=0.8` requests a vertical axis that is 80 percent
    the size of the axes in the evaluation grid, producing a slightly “squashed down”
    prism in which the surface is drawn. You could also use values greater than 1
    for `expand`, in which case the effect would be to “stretch out” the plot along
    the vertical.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.2 Coloring Facets***'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like most traditional R plotting commands, you can use the optional `col` argument
    to color the facets of a perspective surface. To color a perspective surface with
    a constant color throughout, you would just provide `col` with a single value.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in `col`, however, it’s often the case that you want to
    color the surface according to the fluctuating *z*-values to highlight the changing
    value of the bivariate function. To successfully do this for the facets making
    up the surface, it’s important to understand that these facets aren’t the same
    as the pixels that would make up a pixel image of the same *z*-matrix. Where `image`
    pixels are directly represented by the entries of, say, your *m* × *n*-sized *z*-matrix,
    `persp` facets should be interpreted as the space *between* the border lines drawn
    at those matrix entries, leaving you with (*m* − 1) × (*n* − 1) facets. In other
    words, in a perspective plot, each *z*-matrix entry lies at an intersection of
    the drawn lines—the *z*-matrix entries are *not* situated in the middle of each
    facet.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, take another look at [Figure 25-9](ch25.xhtml#ch25fig9)
    on [page 656](ch25.xhtml#page_656). When you use `image`, R automatically calculates
    the pixel sizes based on your *x*- and *y*-axis evaluation grid sequences and
    plots the surface based on the rectangles formed by the dashed gray lines, with
    the *z*-matrix entries `a`, `b`, `c`, and so on, represented directly. When you
    use `persp`, however, the visible border lines are represented by the solid-line
    grid (of arrows), intersecting at each entry, and so the facets of the resulting
    surface are formed by the space between these lines, each one defined by four
    adjacent entries. [Figure 25-20](ch25.xhtml#ch25fig20) shows a section of the
    hypothetical grid in [Figure 25-9](ch25.xhtml#ch25fig9), where I’ve marked off
    one pixel as interpreted by `image` and one facet as interpreted by `persp`. With
    that, you can see why, in [Figure 25-9](ch25.xhtml#ch25fig9), there would be exactly
    6 × 4 = 24 pixels in an image plot but 5 × 3 = 15 facets in a perspective plot.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-20.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-20: Illustrating the difference in treatment of the* z*-matrix in
    a pixel image and in a perspective plot. The highlighted box in the bottom-left
    corner represents an* `image` *pixel of the value* `a` *in the* z*-matrix; the
    highlighted box to the right represents a* `persp` *facet formed by the values*
    `b`, `h`, `i`*, and* `c`*. For coloring, the* z*-value of the highlighted facet
    will be calculated as the mean of those four entries, in other words,* (`b` +
    `h` + `i` + `c`)*/4.*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The `col` argument needs to specify the (*m* − 1) × (*n* − 1) facet colors (assuming
    an *m* × *n z*-matrix passed to `z`). The typical way to find this in R if you’re
    intending to color the facets according to the *z*-value is to first calculate
    each facet’s *z*-value, which will be the average of the four adjacent *z*-matrix
    entries. Only thereafter can you deploy one of the color assignment approaches
    from [Section 25.1.4](ch25.xhtml#ch25lev2sec245).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recast the pixel image of the Chorley-Ribble kernel density estimate (Example
    4; [Figure 25-18](ch25.xhtml#ch25fig18)), complete with *z*-axis-specific coloring,
    as a perspective plot. First, make sure you have the packages `spatstat` and `MASS`
    already loaded. Then repeat the code from earlier to obtain the kernel estimate
    on the appropriate evaluation grid, truncated to the geographical study region.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, you need to calculate all the facet *z* values; this can be done en masse
    with the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first three lines simply store the *z*-matrix as the object `zm` and its
    total rows and columns (both 256 in this case) as `nr` and `nc`, respectively,
    for compactness of the code.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth line is where the relevant calculations happen, giving a matrix
    of the facet *z* values. It does this systematically, by element-wise summation
    of four versions of the original *z*-matrix: `zm[-1,-1]` (first row and first
    column omitted), `zm[-1,-nc]` (first row, last column omitted), `zm[-nr,-1]` (last
    row, first column omitted), and `zm[-nr,-nc]` (last row, last column omitted).
    When the four alternates are summed in this way and divided by 4 at the end, the
    result is a matrix `zf`, each element of which is the four-point average of each
    “rectangle” of four adjacent entries in the original *z*-matrix, exactly as noted
    in the discussion and caption of [Figure 25-20](ch25.xhtml#ch25fig20). The final
    call to `dim` on `zf` confirms the size of the result. Since there are a total
    of 256 × 256 evaluation grid lines in the defined *z*-matrix, these encapsulate
    a total of 255 × 255 perspective facets.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'The hard work is done, and all you need to do now is assign the colors from
    your palette to the calculated facet *z* values in `zf`. You can do this using
    either the categorization or normalization approach, as noted in [Section 25.1.4](ch25.xhtml#ch25lev2sec245);
    for simplicity, let’s stick to categorization. Consider the following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The first line is repeated from [Section 25.5.2](ch25.xhtml#ch25lev2sec257)
    to generate the same 200 colors from the built-in `rainbow` palette as were used
    in the pixel images. The second line sets up an evenly spaced sequence spanning
    the range of the calculated facet *z*-values to form the category break points
    that are required by the categorization approach. Note the use of `na.rm=TRUE`
    in the required calls to `min` and `max` to avoid all the `NA` entries present
    in `zf` (remember, the surface has been truncated to the irregular polygon representing
    the geographical study region). The sequence is one more in length than the number
    of generated colors—again, refer to [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    for this necessary feature of the categorization approach. Lastly, `cut` assigns
    each of the `zf` facet value entries an appropriate rank with respect to the 200
    ordered bins. As you’ve learned, the `zf.colors` ranks are subsequently used to
    index the vector of 200 colors stored in `rbow` when plotting.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: With that, you can enjoy the fruits of your labor! The following code plots
    the bivariate kernel density estimate of the Chorley-Ribble observations as a
    perspective plot using facet coloring to reflect the relative height of the surface
    along the *z*-axis. Border lines are suppressed to show off the color clearly,
    the *z*-axis is scaled down slightly, and a color legend is inserted on the right
    side (ensure the `shape` package has been loaded for that) after manipulating
    the default figure margins via `mar` in a call to `par` to create extra space
    for it. You can find the result in [Figure 25-21](ch25.xhtml#ch25fig21).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![image](../images/f25-21.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-21: A perspective plot of the Chorley-Ribble density estimate, demonstrating
    facet coloring that changes according to the* z*-value of the surface.*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included the optional argument `scale=FALSE` in the execution of `persp`.
    This retains a one-to-one aspect ratio in the *x*- and *y*-coordinate directions;
    this is useful since you’re looking at geographical data. Unfortunately, this
    also forces the density estimate values on the *z*-axis to be scaled in the same
    way, which makes no sense in the context of the current plot. To avoid the small
    scale resulting in a supremely flat appearance of the surface itself, you need
    to use `expand` to artificially amplify the surface along the third axis. In this
    instance, multiplying it by a factor of around 750 provides a visually pleasing
    result. Note that this would not be necessary if you left the `scale` argument
    at its default `TRUE` value (since, in that case, R internally scales all three
    axes for a one-to-one-to-one aspect ratio).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.3 Rotating with Loops***'
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last bit of fun you can have with perspective plots if you want
    to get an overall impression of the plotted surface. Using a simple `for` loop
    ([Section 10.2.1](ch10.xhtml#ch10lev2sec92)) to increment either `theta` or `phi`,
    you can perform a series of repeated calls to `persp`, each one at a slightly
    new angle. Doing this in sequence results in an animation—essentially a cartoon—of
    a rotating surface, allowing you to see it from all different sides.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following basic function in the R editor:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Using an ellipsis (see [Section 11.2.4](ch11.xhtml#ch11lev2sec102)), `persprot`
    simply takes all the arguments you’d usually supply to a call to `persp`, barring
    `theta` and `phi`. Then comes a `for` loop, which immediately calls `persp` with
    `theta=0` and the content of the ellipsis. The `for` loop alters the vertical
    viewing angle, starting with `phi=90` (birds-eye view) and moving down to a mildly
    elevated `phi=20`. A second `for` loop then completes a full 360-degree horizontal
    rotation by altering `theta`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The only formally tagged argument is `skip`, which determines the amount `phi`
    and `theta` increment by at each iteration. The default, `skip=1`, simply moves
    through the integer-valued angles. Increasing `skip` will reduce the time it takes
    to complete the rotation, though it makes for a more jagged animation.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of graphics device you’re using, you may want to experiment
    with `skip`. Note that not all graphics device types will be well-suited to the
    animation effect sought by running this rather crude function (for example, it’s
    not appropriate if you’re using RStudio—see [Appendix B](app02.xhtml#app02)).
    That said, when running the base R GUI applications on OS X or Windows, I find
    `persprot` works well under default graphics settings.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Import the function to try it; let’s do so here for a perspective plot of a
    kernel estimate of the probability density function of the spatial `quakes` locations
    you first examined as Example 3, [Section 25.4.1](ch25.xhtml#ch25lev2sec254).
    With the `MASS` package already loaded, produce the density estimate on a 50 ×
    50 evaluation grid with the following line.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Then you use `persprot` just as you’d use `persp`, without needing to specify
    either `theta` or `phi`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[Figure 25-22](ch25.xhtml#ch25fig22) shows a series of screenshots of the rotating
    plot.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-22.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-22: A rotating perspective plot of a KDE surface for the spatial
    earthquake locations, after a call to the custom* `persprot` *function*'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.5**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: In [Exercise 25.3](ch25.xhtml#ch25exc3) (a), you revisited the `nuclear` data
    set from the `boot` package and fitted two multiple linear regression models aiming
    to model mean construction cost by permit date issue and plant capacity—one with
    main effects only and the other including an interaction term between the two
    continuous predictors.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Refit the two versions of the model and produce perspective plots of the response
    surfaces based again on a 50 × 50 evaluation grid, taking the following into account:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Use `mfrow` in a call to `par` to display the two perspective plots next to
    each other. In the same call to `par`, override the default figure margins to
    have only one line of space on each side (`par` is explored in this role in [Chapter
    23](ch23.xhtml#ch23)).
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `zlim` to ensure both plots are displayed on the same scale of vertical
    axis, spin each one horizontally 25 degrees, and ensure detailed axis markings
    and tidy titles.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Is there any visual indication that the presence of the interaction term has
    had any meaningful impact on modeling the response?
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start a fresh plot. To get a better idea of the difference between the two surfaces,
    produce a perspective plot of the *z*-matrix obtained as the elementwise difference
    between the two individual *z*-matrices for the two fitted models in (a). What,
    in general, is the effect of including the interaction term?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn your attention back to the topographical information on the Auckland volcano,
    as the built-in R object `volcano`: an 87 × 61 matrix of elevation values (in
    meters). You first looked at this in [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    as a contour plot.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Produce the most basic, default perspective plot of the volcano, using simple
    integer sequences for the *x*- and *y*-coordinates.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The plot in (c) is decidedly unappealing for a number of reasons. Produce a
    more realistic depiction of the volcano as per the following:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Use a new graphics device with the margin widths reset to one, one, one, and
    four lines on the bottom, left, top, and right, respectively.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The help file `?volcano` reveals the *x*- and *y*-coordinates to which the
    volcano *z*-matrix corresponds is in 10-meter units. Using `scale` and altering
    `expand`, replot the surface with the correct aspect ratio in all three axes.
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Suppress all axis tick marks and notation using `axes`.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The facets should be colored according to 50 colors generated from the built-in
    `terrain.colors` palette, and the facet border lines should be suppressed.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Find your choice of visually appealing viewing angle.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `colorlegend` from the `shape` package to place a color legend referencing
    elevation in meters in the space to the right of the plot. Experiment with the
    arguments to find appropriate placement and tick mark labels.
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s my version of the improved plot:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0689-01.jpg)'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In [Exercise 25.4](ch25.xhtml#ch25exc4), you looked at the spatial distribution
    of intentionally lit fires in a region of Spain. Ensure the `spatstat` package
    is loaded, and then rerun the following lines to obtain the relevant data objects:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: R> fire <- split(clmfires)$intentional
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: R> firewin <- clmfires$window
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Borrow the code from [Exercise 25.4](ch25.xhtml#ch25exc4) (d) and (e) to reproduce
    the kernel density estimate of this dispersion of observations, based on a 256
    × 256 evaluation grid, truncated to the study region. Then, display it as a perspective
    plot according to the following:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Just as with the pixel image, use 50 colors from the built-in `heat.colors`
    palette to color the facets by *z* value. Note the truncated *z*-matrix for this
    function contains `NA` values.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Border lines on the surface should be suppressed, and you should find your
    preferred choice of viewing angle.
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `scale` to ensure the correct spatial aspect ratio. In doing so, you’ll
    also need to adjust the *z*-axis expansion by a factor of around 5,000,000 for
    the density surface to be visible along the vertical, given the natural scaling
    of the density estimate on the specified evaluation grid.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Employ detailed axis labeling and simply entitle the axes `"X"`, `"Y"`, and
    `"Z"` as appropriate.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My product is given here.
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0690-01.jpg)'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use the `persprot` function defined in [Section 25.6.3](ch25.xhtml#ch25lev2sec260)
    to view the surface from (e), setting `skip=10`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
- en: '| `palette` | List integer colors | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
- en: '| `col2rgb` | Named color to RGB | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
- en: '| `rgb` | RGB to hex code | [Section 25.1.1](ch25.xhtml#ch25lev2sec242), [p.
    633](ch25.xhtml#page_633) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
- en: '| `rainbow`, `heat.colors`, `gray`, `terrain.colors`, `cm.colors`, `topo.colors`,
    `gray.colors` | Built-in palettes | [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    [p. 635](ch25.xhtml#page_635) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
- en: '| `colorRampPalette` | Custom palette (integer) | [Section 25.1.3](ch25.xhtml#ch25lev2sec244),
    [p. 636](ch25.xhtml#page_636) |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
- en: '| `colorRamp` | Custom palette ([0,1] interval) | [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    [p. 640](ch25.xhtml#page_640) |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
- en: '| `colorlegend` | Color legend (`shape`) | [Section 25.1.5](ch25.xhtml#ch25lev2sec246),
    [p. 641](ch25.xhtml#page_641) |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
- en: '| `scatterplot3d` | 3D scatterplot (`scatterplot3d`) | [Section 25.2.1](ch25.xhtml#ch25lev2sec249),
    [p. 649](ch25.xhtml#page_649) |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
- en: '| `expand.grid` | All unique evaluation coords. | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 654](ch25.xhtml#page_654) |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
- en: '| `letters` | Alphabet characters | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 655](ch25.xhtml#page_655) |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
- en: '| `contour` | Contour plot | [Section 25.4.1](ch25.xhtml#ch25lev2sec254), [p.
    657](ch25.xhtml#page_657) |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
- en: '| `kde2D` | Bivariate KDE (`MASS`) | [Section 25.4.1](ch25.xhtml#ch25lev2sec254),
    [p. 660](ch25.xhtml#page_660) |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
- en: '| `filled.contour` | Color-filled contour plot | [Section 25.4.2](ch25.xhtml#ch25lev2sec255),
    [p. 664](ch25.xhtml#page_664) |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
- en: '| `image` | Pixel images | [Section 25.5.1](ch25.xhtml#ch25lev2sec256), [p.
    668](ch25.xhtml#page_668) |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
- en: '| `inside.owin` | Test inside region (`spatstat`) | [Section 25.5.2](ch25.xhtml#ch25lev2sec257),
    [p. 674](ch25.xhtml#page_674) |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
- en: '| `persp` | Perspective plot | [Section 25.6.1](ch25.xhtml#ch25lev2sec258),
    [p. 680](ch25.xhtml#page_680) |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
