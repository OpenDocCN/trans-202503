- en: '**25**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DEFINING COLORS AND PLOTTING IN HIGHER DIMENSIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve mastered some fundamental visualization skills, you can go beyond
    the standard *x*- and *y*-axes by, for example, coloring points according to some
    additional value or variable or adding a *z*-axis for constructing a 3D plot.
    Higher-dimensional plots like this allow you to visually explore your data or
    models using more variables than would be possible otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll get into more detail when it comes to handling colors
    and color palettes in R, and then you’ll look at four new plots: 3D scatterplots,
    contour plots, pixel image plots, and perspective plots.'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.1 Representing and Using Color**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Color plays a key role in many plots. As you’ve already seen, color can be used
    purely for aesthetic enhancement, or it can be a critical aid to interpreting
    your data/models by distinguishing between values and variables. Before learning
    about some more complicated data and model visualization tools, it’s useful to
    understand a little about how R formally represents and handles colors. In this
    section, you’ll examine common ways to create and represent specific colors and
    how to define and use a cohesive collection of colors; the latter is referred
    to as a *palette*.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.1 Red-Green-Blue Hexadecimal Color Codes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When specifying colors in plots, your instruction to R so far has been given
    either in the form of an integer value from `1` to `8` or as a character string
    (see the relevant comments in [Section 7.2.3](ch07.xhtml#ch07lev2sec65)). For
    programming purposes, you need a more objective representation of these colors.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common methods of color specification is to specify different
    *saturations* or *intensities* of three primaries—red, green, and blue (RGB)—which
    are then mixed to form the resulting target color. Each primary component of the
    standard RGB system is assigned an integer from 0 to 255 (inclusive). Such mixtures
    are therefore able to form a total of 256³ = 16,777,216 possible colors.
  prefs: []
  type: TYPE_NORMAL
- en: You always express these values in (R, G, B) order; the result is commonly referred
    to as a *triplet*. For example, (0,0,0) represents pure black, (255,255,255) represents
    pure white, and (0,255,0) is full green.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `col` argument lets you select one of eight colors when you supply it an
    integer from 1 to 8\. You can find these eight colors with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These are but a small subset of the 650+ named colors that you can list by
    entering `colors()` at the R prompt. All of these named colors can also be expressed
    in the standard RGB format. To find the RGB values for a color, supply the desired
    color names as a vector of character strings to the built-in `col2rgb` function.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result is a matrix of RGB values, with each column representing one of your
    specified colors. This is what R actually means, in an RGB sense, when you ask
    it to plot these colors using the corresponding character string.
  prefs: []
  type: TYPE_NORMAL
- en: 'These RGB triplets are frequently expressed as *hexadecimals*, a numeric coding
    system often used in computing. In R, a hexadecimal, or *hex code*, is a character
    string with a `#` followed by six alphanumeric characters: valid characters are
    the letters *A* through *F* and the digits 0 through 9\. The first pair of characters
    represents the red component, and the second and third pairs represent green and
    blue, respectively. If you have or create one or more RGB triplets, you can turn
    them into hex codes for R to use in any subsequent plotting through the `rgb`
    function. This command takes a matrix of RGB values, though note that it expects
    each (R, G, B) color to be a row of that matrix (as opposed to the columns provided
    from a call to, say, `col2rgb`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also need to tell `rgb` that your maximum color value, as per the standard
    RGB format, is 255 (since by default it scales this and uses 1). The following
    code performs a matrix transpose (refer to [Section 3.3](ch03.xhtml#ch03lev1sec14))
    on the result of the previous call to `col2rgb`, putting my three colors as RGB
    triplets in the required form as rows, and specifies the `maxColorValue` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output tells you the hexadecimal codes for the RGB values R refers to with
    the names `"black"`, `"green3"`, and `"pink"`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go into the specifics of converting a standard RGB triplet to a hexadecimal
    here because it’s beyond the scope of this book, but it’s important to know that
    R represents any colors you create using RGB triplets as hex codes, so you should
    be able to at least recognize a hexadecimal when you’re working with colors and
    color palettes in plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an even more colorful exploration, let’s write a modest little function
    to plot points in individual colors and label them appropriately with RGB triplets
    and corresponding hex codes. Consider the following in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function `pcol` takes one argument, `cols`, intended to be a character vector
    of color names recognized by R. When you execute `pcol`, it opens a new graphics
    device and equalizes the figure margin settings to be one line on each side. A
    plot is begun, fully suppressed except for a box. This is so you can use `locator`
    (see [Section 23.3](ch23.xhtml#ch23lev1sec78)) to place points in the plot region,
    implemented in a `for` loop, one after the other. Each point represents one of
    the `cols`, and after its coordinates are returned from `locator`, `points` puts
    down a large dot of the color at hand, with `text` providing annotation to the
    right of each point achieved using `paste` (refer to [Section 4.2](ch04.xhtml#ch04lev1sec17)).
    This annotation includes the R color name, the RGB triplet, and the hex code on
    top of one another; the latter two are found using `col2rgb` and `rgb` exactly
    as demonstrated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sets up the device, first storing 14 valid R color names
    (chosen randomly) in the character vector `mycols`. After exhausting these with
    mouse clicks in different areas of the plot region, the execution is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When I execute `pcol` as shown here, I click through the 14 points, producing
    rough columns on my graphics device. [Figure 25-1](ch25.xhtml#ch25fig1) shows
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-1: Various named R colors alongside their corresponding RGB triplets
    and hex codes.*'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, you can obtain any color you want (in other words, far more than
    the named ones that are built into R) by specifying an RGB value and obtaining
    its hex code. These hexadecimals can be supplied as is to any of the traditional
    R graphics functions where you specify color (commonly to a `col` argument). You’ll
    see this as the chapter progresses. Naturally, you can also assign a hex code
    or a vector of hex codes (for example, if you’re creating your own custom colors)
    to a new object in your R workspace so you can use it in subsequent plotting.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.2 Built-in Palettes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Being able to implement your own RGB colors is most useful when you need many
    colors, the collection of which is referred to as a *palette*. You’ll typically
    need a palette when color is used to describe something on a continuum, like the
    various shades of blue used for the height measurements in [Figure 24-6](ch24.xhtml#ch24fig6)
    on [page 621](ch24.xhtml#page_621).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of color palettes built into the base R installation. These
    are defined by the functions `rainbow`, `heat.colors`, `terrain.colors`, `topo.colors`,
    `cm.colors`, `gray.colors`, and `gray`. With the exception of `gray`, you directly
    specify the number of colors you want, and they’ll be returned as a character
    vector of hex codes representing an equally spaced sequence over the entire color
    range of that particular palette.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easiest to see this in action with a visualization. The following code
    generates exactly 600 colors from each palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that instead of a single integer, `gray` expects a numeric vector of values
    between 0 (total black) and 1 (total white) to provide a grayscale. Its counterpart
    function, `gray.colors`, works the same as the other built-in palettes but defaults
    to a slightly narrower visual range between the extremes of black and white. These
    can be reset using the optional arguments `start` and `end`, which you’ll see
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The next code chunk uses skills from [Chapter 23](ch23.xhtml#ch23) to initialize
    a new plot and uses vector repetition to place 600 points for each palette in
    a single call to `points`, coloring them appropriately as per the vectors of hex
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 25-2](ch25.xhtml#ch25fig2) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-2: Showcasing the color ranges of the built-in palettes, with default
    limits used in* `gray.colors`.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information, access the help files `?gray.colors` and `?gray` for the
    respective grayscale palettes, with the others all appearing under `?rainbow`.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.3 Custom Palettes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re not restricted to the ready-to-use color designs. The function `colorRampPalette`
    allows you to create your own palettes; you supply two or more desired key colors
    to an argument of the same name, and it creates a palette that transitions between
    them. The result of a call to `colorRampPalette` is itself a function—one that
    behaves exactly like the built-in palette functions noted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’d like to be able to generate colors on a scale between purple
    and yellow. You specify the key colors to be interpolated, in the desired order,
    as a character vector of names from the collection that R recognizes. The following
    line creates this palette function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create another one, this time picking one that will show up a little clearer
    in case a color plot that ends up using it is printed in grayscale (in which case
    sticking to monochromatic palettes is a good idea).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple more, using more than two colors this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Having created a handful of custom palette functions, you can now generate any
    number of colors from each range just like before (done here using the previously
    stored `N` value of 600 each). After doing so, you can adapt the earlier plotting
    code to get the image in [Figure 25-3](ch25.xhtml#ch25fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-3: Some examples of custom color palettes created using* `colorRampPalette`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.4 Using Color Palettes to Index a Continuum***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve now seen a few times how color can be used to identify groups based
    on a categorical variable (the data corresponding to a certain level are simply
    given a distinct color from the others), which is pretty easy to do. However,
    assigning colors appropriately to values on a continuum requires a little more
    thought. There are two methods for this: through categorization or through normalization
    of your continuous values. Let’s look first at the former approach.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Via Categorization**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One way to color values according to a continuous variable is to turn it into
    the familiar problem of coloring points of a categorical variable. You can do
    this by binning your continuous values into a fixed number of *k* categories,
    generating *k* colors from your palette, and matching each observation to the
    appropriate color based on the bin it falls into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 20.1](ch20.xhtml#ch20lev1sec62), you plotted height against writing
    handspan for the `survey` data from the `MASS` package. This time, let’s use color
    to additionally inform the nonwriting handspan variable. Load the package and
    execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This creates the data frame object `surv`, which is made up of only the three
    required columns. Any rows with missing values are removed via a call to `na.omit`
    (refer to [Section 6.1.3](ch06.xhtml#ch06lev2sec57)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first thing to do is decide on your color palette.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will generate colors that go from a dark, dull red at the lower end of
    the scale to a slightly faded yellow at the higher end (similar to the builtin
    `heat.colors` palette; see [Figure 25-2](ch25.xhtml#ch25fig2)). Next, you need
    to decide how many bins, *k*, you’re going to construct for the continuous values.
    This determines how many distinct colors to generate from `NW.pal`. For these
    data, set *k* = 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Your five `NW.pal` colors, as hex codes, are available. Next, you need to actually
    bin the continuous values, which you can do using `cut`. First you need to set
    *k* + 1 break points for the bins (refer to [Section 4.3.3](ch04.xhtml#ch04lev2sec48)
    for a refresher), using `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The six equally spaced values span the range of the students’ nonwriting handspans,
    delineating your five intended bins. Then `cut` factorizes the nonwriting handspans
    with respect to those bins. You can use `as.numeric` to specifically return the
    indexes for extracting the appropriate color for each observation from your five
    ordered hex codes in `ryc` (full output is suppressed here for reasons of print).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re ready to plot; the result of the following is given on the left of [Figure
    25-4](ch25.xhtml#ch25fig4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-4: Illustrating two ways to assign color to points based on a continuous
    value: via categorization (left) and via normalization (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Via Normalization**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using categorization to index a continuum with color is a little unsophisticated.
    There are plenty of ways you can bin your observations, for example, so your plot
    might look very different from the same plot designed by someone else. In a computational
    sense, it’s more accurate (not to mention elegant) to leave your continuous data
    as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the built-in `gray` palette mentioned in [Section 25.1.2](ch25.xhtml#ch25lev2sec243).
    This function behaved a little differently from the others. Instead of simply
    asking for a number of colors from the specified palette, you’re required to provide
    a numeric vector of values to tell R, on a continuous scale from 0 through 1,
    how “far along” the palette to go. This type of behavior suits the current task
    perfectly, since your raw data are also on a continuous scale. To implement it,
    you need two things: a way to create a palette that will behave like `gray` and
    a *normalized* version of your continuous values that fall within the acceptable
    standardized range of 0 to 1 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `colorRamp` function allows you to create your palette and is used in the
    same way as `colorRampPalette`, but the result is a color palette function that
    expects a numeric vector as stated. You’ll see that in a moment. To transform
    a collection of *n* original values {*x*[1], ..., *x*[n]} to, say, {*z*[1], ...,
    *z*[n]}, where 0 ≤ *z[i]* ≤ 1; *i* = 1, ..., *n*, you can employ the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e25-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s make that an R function by writing the following in the R editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Based on a vector `datavec` as its only argument, `normalize` implements [Equation
    (25.1)](ch25.xhtml#ch25eq1), using the optional `na.rm` argument to ensure any
    missing values in `datavec` don’t contaminate the calculation of the minimum and
    maximum values (see [Section 13.2.1](ch13.xhtml#ch13lev2sec116)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `normalize` and enter the following, which shows the original nonwriting
    handspan values (from the object `surv` you created earlier) and their corresponding
    normalized values (output snipped for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, you need to create a new version of the color palette with `colorRamp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Generate the corresponding colors for each observation based on the normalized
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you actually look at the returned object in `ryc2`, you’ll note it’s a matrix
    of RGB triplets corresponding to each normalized value you supplied to your `colorRamp`
    function `NW.pal2` (noninteger values end up being coerced to integers). These
    need to be converted to hex codes before you can use them in plotting. Using `rgb`
    just as you saw in [Section 25.1.1](ch25.xhtml#ch25lev2sec242), you get the vector
    you need (snipped for print).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the difference between the hex codes you obtain here in `NW.cols2` and
    those in `NW.cols`. Here, you get a hex code for each unique value, but for the
    categorized `NW.cols`, you have only one hex code for each bin (so just *k* =
    5 colors).
  prefs: []
  type: TYPE_NORMAL
- en: This line produces the image on the right of [Figure 25-4](ch25.xhtml#ch25fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In terms of this relatively simple example, the visual difference between the
    two approaches is minimal, though looking closely you can indeed pick out the
    smoother color transition in the normalized version. As you increase *k* when
    using the categorization technique, the visual result will become closer to that
    of the normalization approach. That said, the normalization approach should generally
    be preferred, since it more closely fits the continuous nature of the values you’re
    trying to visualize, and it works more effectively for values with a skewed distribution
    or when you’re working with a complex color palette.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.5 Including a Color Legend***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you can use color to significant effect in your plots, you need a legend
    to reference the color scale. It’s possible to create a legend using base R tools
    alone, but it can be simpler to use contributed functionality in R instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'One useful function for this is the `colorlegend` command. This is found in
    the `shape` package ([Soetaert, 2014](ref.xhtml#ref62)), so first download and
    install `shape` from CRAN. The following code then loads the package, reproduces
    the most recent plot (based on the `surv` object created earlier and shown on
    the right of [Figure 25-4](ch25.xhtml#ch25fig4)) with some tidier axis titles,
    and draws the color strip legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This result is given on the left of [Figure 25-5](ch25.xhtml#ch25fig5).
  prefs: []
  type: TYPE_NORMAL
- en: The `colorlegend` functions assumes that you already have a plot present in
    an active graphics device, so you need to have one created first. The first thing
    you supply to `colorlegend` is the color span of the values you want to reference.
    This is easiest with a color palette function like those listed in the help file
    `?rainbow` or created using `colorRampPalette`—in other words, a function that
    takes an integer value telling it how many colors to generate. Doing so with a
    large number of colors gives you a smooth color strip, so I use `NW.pal(200)`.
    Next, you provide `colorlegend` with the range of the values that will be referenced
    by the legend using `zlim`, in this case, the range of the nonwriting handspans
    `range(surv$NW.Hnd)`. The `zval` argument takes in the values that you want to
    mark off on the legend. The values of a sequence between 13 and 23, in steps of
    2, are marked off.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-5: Two examples of implementing a color strip legend using the*
    `colorlegend` *function from the contributed* `shape` *package*'
  prefs: []
  type: TYPE_NORMAL
- en: The positioning and sizing of the color legend are done using the `posx` and
    `posy` arguments. Rather than taking user coordinates, each of these must be a
    vector of length 2 describing, in *relative device coordinates*, the horizontal
    (`posx`) and vertical (`posy`) lengths of the strip. In this example, `posx=c(0.3,0.33)`
    tells the function to draw the width of the legend from 30 percent of the left
    of the device to 33 percent so that the width is 3 percent of the overall device
    and positioned to the left of the center. Setting `posy=c(0.5,0.9)` says you want
    the length of the strip to span 40 percent of the device, from 50 percent of the
    way up from the bottom to 90 percent and up. Lastly, you can add the title to
    the legend by supplying a character string to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll probably need to experiment a bit in a trial-and-error fashion to get
    the positioning and sizing (and appropriate tick marks using `zval`) you want.
    The device-specific nature of `posx` and `posy` means that if you resize your
    device, you might well need to reevaluate the values of these arguments.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted the legend to appear outside the default plot region, you could
    easily use the `xlim` argument in the initial call to `plot` to widen the horizontal
    size of the plot, giving you extra space to draw a full-length legend. Alternatively,
    you could’ve changed the figure or outer margin spacing (refer to [Section 23.2](ch23.xhtml#ch23lev1sec77))
    to give you enough room to put the legend outside the plot region. This next chunk
    of code does just that by widening the right margin, replotting the scatterplot,
    and inserting a color legend into that extra space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The result is given on the right of [Figure 25-5](ch25.xhtml#ch25fig5). The
    legend is narrower than before, taking up only 2 percent of the device width on
    the right with `posx=c(0.89,0.91)`. With no specification of `posy`, `colorlegend`
    has used the default of `c(0.05,0.9)`, giving a color strip that spans almost
    the entire height of the device. The tick marks and labeling of the new legend
    are now placed in increments of 1 from 13.5 to 22.5; note that to display decimal
    places (in other words, *significant digits*), you need to increase the `digit`
    argument from its default, `0`, to reveal them. Here, `digit=1` prints the tick
    mark labels to one decimal place.
  prefs: []
  type: TYPE_NORMAL
- en: There are more properties that you can control with these legends, including
    labeling style and tick mark positioning; see the `?colorlegend` help file for
    details. You may also like to investigate the similarly named function `color.legend`
    in the contributed `plotrix` package ([Lemon, 2006](ref.xhtml#ref40)) for a slightly
    different take on drawing color legends on existing R plots.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.6 Opacity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful skill is the ability to specify the opacity of any of the colors
    and color palettes discussed so far. All functions that provide the user with
    hex codes have an optional argument `alpha`, the valid range of which depends
    on the function (a quick check of the corresponding documentation will tell you).
    For example, the `rgb` function uses `maxColorValue` to set the upper bound on
    opacity, and palette functions like `rainbow` all use the normalized range from
    0 through 1 (just like in the `ggplot2` plots created throughout [Chapter 24](ch24.xhtml#ch24)).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, R assumes full opacity when you’re creating colors. However, hex
    codes change slightly when opacity is explicitly set using `alpha`. Rather than
    six characters after the `#`, eight will appear, with the last two containing
    the additional opacity information. Consider the following lines of code, which
    generate four different versions of red: default, zero opacity, 40 percent opacity
    (0.4 × 255 = 102), and full opacity, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first and last colors are identical; it’s just that the last hex
    code explicitly specifies full opacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always adjust the opacity of any color you’ve already got with the
    `alpha.f` argument (which takes values in the range 0 through 1) of the ready-to-use
    `adjustcolor` function. The following line takes the default red hex code created
    by the first line in the previous example and turns it into a 40 percent opaque
    version (the third line in the previous code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You briefly came across this command already in [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    when creating a transparent gray confidence interval for a LOESS-smoothed trend
    using base R graphics. This approach is also applicable to hex codes generated
    after you’ve used a built-in or custom palette function to obtain a vector of
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put opacity to the test using the built-in `quakes` data frame, which
    consists of data on 1,000 seismic events near Fiji. Let’s re-create the plot in
    [Figure 13-6](ch13.xhtml#ch13fig6) on [page 284](ch13.xhtml#page_284) showing
    “number of detecting stations” against “event magnitude” and dress it up using
    color to identify the continuous “depth” data. Since there are many overlapping
    observations, reducing opacity of the individual points would be a good idea for
    visualization. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'sets up a custom three-color palette both ways (in other words, as a function
    expecting an integer, `depth.pal`, and as a function expecting a value between
    0 and 1, `depth.pal2`; refer to [Sections 25.1.3](ch25.xhtml#ch25lev2sec244) and
    [25.1.4](ch25.xhtml#ch25lev2sec245)). Then, the following line uses the normalization
    approach, with the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    to obtain the appropriate colors for the points to be plotted, according to the
    “depth” variable of the data set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The request for 60 percent opacity is made through `alpha` in the call to `rgb`.
    You can create the plot with the following call, which assigns the colors stored
    in `depth.cols`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This plot affords another opportunity to showcase the `colorlegend` function
    from the `shape` package. Assuming you have `shape` already loaded in the current
    R session, the next line draws a corresponding color legend inside the plot region
    (on a default-size device):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see another demonstration of the use of `adjustcolor`, where the
    color sequence generated with the call to `depth.pal(20)` is then reduced to 60
    percent opacity to match the plotted points. Again, `posx` and `posy` are used
    to position the legend, and the optional logical argument `left` is set to `TRUE`
    to make the tick marks and color legend labels appear on the left side of the
    strip. [Figure 25-6](ch25.xhtml#ch25fig6) shows the final result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-6: Altering the color opacity in a custom palette, used to index
    the continuous “event depth” observations in a plot of “number of stations” against
    “magnitude” for the* `quakes` *data set, and a corresponding color legend using*
    `colorlegend` *from the* `shape` *package*'
  prefs: []
  type: TYPE_NORMAL
- en: '***25.1.7 RGB Alternatives and Further Functionality***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RGB triplets aren’t the only way color can be represented in R. Other specifications
    include hue-saturation-value (HSV) and hue-chroma-luminance (HCL), available through
    the built-in `hsv` and `hcl` functions. These work in much the same way as `rgb`,
    where you specify the strength of influence of the three components and out pop
    corresponding character string hex codes that form valid R colors for any relevant
    plotting command. In fact, the HSV parameterization is what’s used internally
    by the built-in palettes detailed in [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    such as `rainbow` and `heat.colors`.
  prefs: []
  type: TYPE_NORMAL
- en: Contributed functionality offers even more flexibility. The `colorspace` package
    ([Ihaka et al., 2015](ref.xhtml#ref34)), which translates between different color
    formats, is worth noting, as is `RColorBrewer` ([Neuwirth, 2014](ref.xhtml#ref51)),
    which is based directly on the well-received color schemes designed by Cynthia
    Brewer (see *[http://colorbrewer2.org/](http://colorbrewer2.org/)*). `RColorBrewer`
    provides more options for creating palettes than are supplied by the built-in
    functionality `colorRampPalette` and `colorRamp`. That said, from an introductory
    perspective, you should find the use of RGB and the base R functionality as discussed
    here sufficient for most visual explorations of your data and models.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure the `car` package is loaded. Revisit the `Salaries` data frame you looked
    at in [Exercises 24.1](ch24.xhtml#ch24exc1) ([page 622](ch24.xhtml#page_622))
    and [24.2](ch24.xhtml#ch24exc2) ([page 628](ch24.xhtml#page_628)) and take a look
    at the help file `?Salaries` to remind yourself of the variables. Your task is
    to use color, point size, opacity, and point character type to reflect “years
    since Ph.D.,” “sex,” and “rank” in a scatterplot of “salary” against “years of
    service,” by completing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a custom color palette that goes from `"black"` to `"red"` to `"yellow2"`.
    Create two versions of this palette—one that expects a number of colors and one
    that expects a vector of normalized values between 0 and 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two vectors that will control point character and character expansion
    following the guidelines in (i) and (ii). Each of these can be achieved in a single
    line by vector subsetting/repetition based on a numeric coercion of the corresponding
    factor vector in the data frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the point characters `19`, `17`, and `15` to reference the three increasing
    academic ranks in that order.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a character expansion of `1` for females and a character expansion of `1.5`
    for males.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    to create a [0,1] normalized version of the range of values of the “years since
    Ph.D.” variable. Then use the appropriate palette from (a) along with `rgb` to
    convert these to the required hex codes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the vector of colors you just created in (c), adjusting opacity. Colors
    in the vector that correspond to females should be reduced to 90 percent opacity;
    colors that correspond to males should be reduced to 30 percent opacity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, start the plot; alter the default figure margins to be 5, 4, 4, and 6 lines
    wide on the bottom, left, top, and right, respectively. Plot salary on the *y*-axis
    against years of service on the *x*-axis. Set the corresponding point colors according
    to your vector from (d) and the point characters and character expansion according
    to your vectors from (b). Tidy up the *x*-axis and *y*-axis titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate two separate legends following the guidelines in (i) and (ii). Both
    legends should be horizontal, and you should relax clipping to allow their placement
    in figure margins (refer to [Section 23.2.3](ch23.xhtml#ch23lev2sec228)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the first legend at the user coordinate given by `x=-5` and `y=265000`.
    It should use the levels of the “rank” factor vector as the referencing text and
    pair these with the corresponding `pch` symbols as assigned. Include an appropriate
    title for the legend.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second legend should be placed next to the first, using an *x*-coordinate
    of `40` and the same *y*-coordinate value. This legend should show two points,
    both red and of type `19`, but reference the two levels of sex by altering the
    character expansion and opacity of these to reference points as assigned.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, ensure the `shape` package is loaded and use the `colorlegend` function
    along with 50 colors generated from the appropriate palette from (a) to reference
    “years since Ph.D.” You can leave the horizontal and vertical placements of the
    legend at their default values. The `zlim` range should simply be set to match
    the range of the observed data, and the tick mark values set via `zval` should
    be a sequence between 10 and 50, increasing in steps of 10\. Include an appropriate
    title for the color legend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After all this, my version of this plot is given here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0647-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your next task is a little different. The goal is to plot a standard normal
    probability density function but use color to shade in polygons underneath the
    curve to denote “distance from mean.” To achieve this, complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a vector of exactly 25 colors from the built-in palette `terrain.colors`
    and name it `tcols`. Then, using a reversed version of it obtained via `tcols[25:1]`,
    append the two vectors together to form a new vector of length 50 containing the
    first 25 colors shading one way and then the same 25 shading the opposite way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create and store an evenly spaced sequence of exactly 51 values between
    −3 and 3 inclusive; name it `vals`. Use `dnorm` to calculate and store the corresponding
    51 values of the standard normal density curve; name it `normvals`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the normal density curve by plotting the values in (i) as a line (recall
    `type="l"`). In the same call to `plot`, use knowledge from [Chapter 23](ch23.xhtml#ch23)
    to set both the *x*-axis and *y*-axis styles to be of type `"i"`; suppress both
    axis titles with empty strings; change the surrounding box to be an *L* shape;
    and suppress the drawing of the *x*-axis. Give the plot a suitable main title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To shade the different colors underneath the curve, use a `for` loop, iterating
    through the integers 1 to 50\. At each iteration, the loop should call `polygon`
    (refer to [Section 15.2.3](ch15.xhtml#ch15lev2sec135)). Assuming your indexer
    is `i`, the vertices of each polygon should be formed by the vectors `vals[rep(c(i,i+1),each=2)]`
    and `c(0,normvals[c(i,i+1)],0)`. Each polygon should suppress its border and be
    colored according to the relevant `i`th entry in your color vector of length 50
    created in (h).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, ensure the `shape` package has been loaded and use your length 50 color
    vector to produce a color legend with default placement to reference “distance
    from mean.” You can easily set the `zlim` and `zval` arguments in the call to
    `colorlegend` using `vals`. Include an appropriate title for the legend. For reference,
    my result is given here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0648-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**25.2 3D Scatterplots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will look at creating 3D scatterplots, which allow you to plot
    raw observations based on three continuous variables at once, as opposed to only
    two in a conventional 2D scatterplot. You’ll then learn how to enhance your 3D
    scatterplot to represent more variables and make it easier to interpret. There
    are several ways to create three-variable scatterplots in R, but the go-to method
    is usually the `scatterplot3d` function in the contributed package of the same
    name ([Ligges and Mächler, 2003](ref.xhtml#ref42)).
  prefs: []
  type: TYPE_NORMAL
- en: '***25.2.1 Basic Syntax***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The syntax of the `scatterplot3d` function is similar to the default `plot`
    function. In the latter, you supply a vector of *x*- and *y*-axis coordinates;
    in the former, you merely supply an additional third vector of values providing
    the *z*-axis coordinates. With that additional dimension, you can think of these
    three axes in terms of the *x*-axis increasing from left to right, the *y*-axis
    increasing from foreground to background, and the *z*-axis increasing from bottom
    to top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install and load the `scatterplot3d` package, and let’s go straight into an
    example. Recall the famous iris flower data, which you first encountered in [Section
    14.4](ch14.xhtml#ch14lev1sec47). This data set contains measurements on four continuous
    variables (petal length/width and sepal length/width) and one categorical variable
    (flower species); the `iris` data frame is immediately accessible from the R prompt,
    so there’s no need to load anything. Enter the following so you have quick access
    to the measurement values that make up the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The most basic 3D scatterplot of, say, petal length, petal width, and sepal
    width, is achieved with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It’s as simple as that—the result of this code is given on the left of [Figure
    25-7](ch25.xhtml#ch25fig7). Here you can observe a general positive relationship
    among all three plotted variables. There’s also a clearly isolated cluster of
    observations in the foreground that have relatively large sepal widths but small
    petal measurements.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-7: Two 3D scatterplots of the famous* `iris` *data with petal width,
    petal length, and sepal width on the* x*-,* y*-, and* z*-axis, respectively. Left:
    Basic default appearance. Right: Tidying up titles and adding visual enhancements
    to emphasize 3D depth and legibility via color and vertical line marks.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***25.2.2 Visual Enhancements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can be difficult to clearly perceive depth in the plotted cloud of points,
    even with the box and *x*-*y* plane grid lines that are drawn by default. For
    this reason, there are a couple of optional enhancements you can make to a `scatterplot3d`
    plot—coloring the points to help make the transition from foreground to background
    clearer and setting the `type="h"` argument to draw lines perpendicular to the
    *x*-*y* plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right-hand plot in [Figure 25-7](ch25.xhtml#ch25fig7) shows the plot with
    these enhancements and is the result of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`xlab`, `ylab`, `zlab`, and `main` control the corresponding titles of the
    three axes and the plot itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The vertical lines make reading the values of the points much easier. By default,
    those lines in a `type="h"` plot are solid, but you can alter this with the `lty.hplot`
    argument (which behaves in the same way as the standard graphical parameter `lty`);
    setting `lty.hplot=2` requests dashed lines. Similarly, you can alter the line
    type of the “nonvisible” sides of the box; setting `lty.hide=3` instructs the
    plot to draw those lines as dotted.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `highlight.3d=TRUE` emphasizes 3D depth by applying color transitioning
    from red to black based on the *y*-axis position of a point. This is useful, but
    there’s an important consequence—it means you can no longer use color to represent
    a fourth variable with such a plot.
  prefs: []
  type: TYPE_NORMAL
- en: Along that line of thought, remember that the `iris` data has a fourth continuous
    variable, sepal length (stored as `slen` in [Section 25.2.1](ch25.xhtml#ch25lev2sec249)),
    that you’re not displaying in either of the plots in [Figure 25-7](ch25.xhtml#ch25fig7).
    You’re also not displaying the categorical variable of flower species, so let’s
    fix that. First, set up a color band for the missing measurement variable, using
    your knowledge of having color palettes reference a continuous variable from [Section
    25.1.4](ch25.xhtml#ch25lev2sec245).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the last line to run, you’ll need to have the `normalize` function
    defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245) available in your current
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code produces the 3D scatterplot, which also uses the `pch` argument
    to distinguish among the three different species:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve used the vector `c(19,17,15)`, with the numeric coercion of the `iris$Species`
    vector passed to the square brackets, to pair `pch` character numbers as follows:
    `19` with *Iris setosa* (the first level of the factor), `17` with *Iris versicolor*
    (the second level), and `15` with *Iris virginica* (the third level), respectively
    (refer to [Figure 7-5](ch07.xhtml#ch7fig5) on [page 133](ch07.xhtml#page_133)
    for the different types of point characters).'
  prefs: []
  type: TYPE_NORMAL
- en: You can then insert a legend referencing species with a familiar call to `legend`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And with a little experimentation, you can include a color strip legend too
    (making sure you’ve loaded the `shape` package so you have access to the `colorlegend`
    function as per [Section 25.1.4](ch25.xhtml#ch25lev2sec245)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The final result of all this is the image in [Figure 25-8](ch25.xhtml#ch25fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-8: A 3D scatterplot of the famous* `iris` *data, displaying all
    five present variables with the additional use of color (for sepal length) and
    point character (for species).*'
  prefs: []
  type: TYPE_NORMAL
- en: With the creative use of color and point type, you’ve now been able to display
    the five-dimensional data in a single 3D scatterplot. This reveals important information
    about the data. For instance, you can now identify *Iris setosa* as the clearly
    separate group of points in the foreground and see that while *Iris setosa* tend
    to have smaller petal widths and lengths and larger sepal widths than the other
    two species (especially *Iris versicolor*), the purple coloring at the lower end
    of the scale suggests they tend to have smaller sepal lengths.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `scatterplot3d` library has been loaded in your current R session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn your attention back to the `diabetes` data frame found in the `faraway`
    package (you first looked at these data in [Section 21.5.2](ch21.xhtml#ch21lev2sec203)).
    Your goal is to produce a `scatterplot3d` plot of weight, hip, and waist measurements
    as per the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Hip, waist, and weight variables should correspond to the *x*-axis, *y*-axis,
    and *z*-axis, respectively; provide neat axis titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use built-in functionality to ensure the 3D depth is highlighted by color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Choose two different point characters to reflect gender.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Place a simple legend referencing these two point characters and gender in
    the blank space in the upper-left area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a 3D scatterplot of the built-in `airquality` data, which you first
    met in [Section 24.2.2](ch24.xhtml#ch24lev2sec239), according to the following
    guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Create a copy of the data frame using `na.omit` to remove all rows that contain
    missing values and work with this copy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Plot wind speed and solar radiation against the *x*- and *y*-axes, respectively,
    using the *z*-axis to plot temperature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Apply vertical dotted lines reaching up from the *x*-*y* plane to each observation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The data in `airquality` are comprised of measurements taken over five months,
    from May to September. Each plotted point should take on the corresponding `pch`
    value from `1` to `5` respective to the order of these five months.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – With a vector of 50 colors generated from the built-in `topo.colors` palette,
    use the categorization approach to ensure each plotted point is colored according
    to its ozone value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Set a legend to reference the five point types according to month.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Set a color legend (using functionality from the `shape` package) to reference
    the ozone value accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Ensure the plot has neat axis, main, and legend titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**25.3 Preparing a Surface for Plotting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the rest of this chapter, you’ll look at three types of 3D plots geared to
    visualize a *bivariate surface*. Such plots are required when you have two variables,
    based on which a function, estimate, or model has been defined, and you want to
    use the third available axis (in other words, the *z*-axis) to map out the resulting
    surface. You’ve seen examples of bivariate functions already, through the response
    surfaces for the `mtcars` data in [Section 21.5.4](ch21.xhtml#ch21lev2sec205)
    (where you looked at mean MPG as a function of car weight and horsepower) and
    through the study of diagnostic tools for linear regression models in [Section
    22.3.6](ch22.xhtml#ch22lev2sec219) (where you saw how Cook’s distance can be expressed
    as a function of residual and leverage).
  prefs: []
  type: TYPE_NORMAL
- en: Before you look at producing these plots, it’s important to understand how they’re
    created in R. The function/estimate/model of interest should be thought of as
    a plane or surface that can vary according to continuous, two-dimensional *x*-*y*
    coordinates. Plotting a completely continuous surface is technically impossible
    since that would require you to evaluate the function at an infinite number of
    coordinates. Therefore, evaluation of the surface is typically performed on a
    finite *grid* of evenly spaced coordinates along both the *x*- and *y*-axes. The
    result of the function at each unique pair of coordinates is stored in a corresponding
    position in an appropriately sized matrix (the size of which depends directly
    upon the resolution of the evaluation grid in the *x*- and *y*-axes), generically
    referred to as the *z-matrix*.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the traditional R graphics commands that plot these bivariate functions
    operate in the same way—using this *z*-matrix—it’s critical to understand how
    this matrix is constructed, arranged, and interpreted by those commands to ensure
    you’re correctly drawing the outcome. In this section, you’ll ready yourself for
    the specific plot types looked at in the remainder of this chapter by getting
    familiar with this construct in a hypothetical situation.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.3.1 Constructing an Evaluation Grid***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you have a bivariate function that results in a continuous surface that’s
    defined between 1 and 6 on the *x*-axis and 1 and 4 on the *y*-axis. You can define
    evenly spaced sequences over each of these coordinate ranges using `seq`; for
    simplicity, let’s just do so in straight-out integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: What this implies is that you’re planning to draw your surface based on evaluation
    of the bivariate function of interest upon the grid of *x*-*y* values defined
    by 24 unique positions.
  prefs: []
  type: TYPE_NORMAL
- en: When passed two vectors, the built-in `expand.grid` function explicitly generates
    all unique coordinate pairs by simply repeating each value in the second vector
    against the entire length of the first vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The result is stored as a two-column data frame with 24 rows. If you look at
    `xycoords` object in the R console, you’ll see `x` values from `1` to `6` all
    paired with a repeated `y` value of `1`, then `x` from `1` to `6` paired with
    `y` as `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, what you’d now do is use the evaluation grid coordinates in `xycoords`
    to calculate the result of your bivariate function. For this hypothetical example,
    let’s just say that your bivariate function has resulted in the 24 letters *a*
    to *x*, corresponding to the order of the unique evaluation coordinates in `xycoords`.
    To make this even clearer, take a look at the following column-bind of the hypothetical
    function result with each evaluation coordinate (note that the ready-to-use `letters`
    object in R allows you to generate letters of the alphabet quickly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What this emphasizes is that each unique *x*-*y* evaluation coordinate, expressible
    via `expand.grid`, will have a *z* value associated with it. All together, these
    *z* values define the resulting surface.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.3.2 Constructing the z-Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3D plots used to visualize a bivariate function require the *z* values corresponding
    to the *x*-*y* evaluation grid in the form of an appropriately constructed matrix.
    The size of the *z*-matrix is determined directly by the resolution of the evaluation
    grid; the number of rows corresponds to the number of unique *x* grid values,
    and the number of columns corresponds to the number of unique *y* grid values.
  prefs: []
  type: TYPE_NORMAL
- en: You therefore need to take a little care turning your calculated *z* values
    into a matrix. When your vector of *z*-axis values corresponds to the evaluation
    grid arranged in the standard `expand.grid` fashion (in other words, where coordinates
    are stacked by increasing *x* values and repeated *y* values), be sure that your
    resulting *z*-matrix is filled in the default column-wise fashion (see [Section
    3.1.1](ch03.xhtml#ch03lev2sec24)), with the number of rows and columns being exactly
    representative of the number of values in each of the *x*- and *y*-value sequences,
    respectively (`xcoords` and `ycoords` shown earlier). In the current example,
    you know that the resulting *z*-matrix needs to be of size 6 × 4 because there
    are six *x* locations and four *y* locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the correct matrix representation of the hypothetical “function
    result” vector `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '***25.3.3 Conceptualizing the z-Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important thing to be gained from this section is an idea of how the
    *z*-matrix in its current arrangement translates to *x*-*y* coordinate-based plotting.
    Comparing `zmat` to the earlier output, you can see that moving down a column
    of `zmat` translates to an increase in the *x*-coordinate value for a given *y*-coordinate
    value. In other words, when this hypothetical surface of letters is plotted, moving
    down a column of the matrix corresponds to moving horizontally from left to right
    on the corresponding plot, given a particular vertical *y* position.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-9](ch25.xhtml#ch25fig9) provides a conceptual diagram of this illustrative
    surface, indexed by `zmat` as per the 24 unique coordinates defined via `xcoords`
    and `ycoords`. (The code to produce this is included in the R script files for
    this book, which can be found at *[https://www.nostarch.com/bookofr/](https://www.nostarch.com/bookofr/)*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-9: Conceptual diagram of a* z*-matrix for plotting bivariate functions,
    based on a 6* × *4 coordinate grid*'
  prefs: []
  type: TYPE_NORMAL
- en: As you now progress to plot some actual surfaces of interest, you should keep
    the concept of the *z*-matrix as illustrated in [Figure 25-9](ch25.xhtml#ch25fig9)
    in mind. The 6 × 4 grid used in this hypothetical example is coarse. In practice,
    you’ll usually use far finer grids in terms of the resolution of the *x*- and
    *y*-sequences to improve the visual appearance of the surface.
  prefs: []
  type: TYPE_NORMAL
- en: '**25.4 Contour Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common plots used to display a surface based on evaluation of
    a function over a grid of bivariate coordinates is the *contour plot*. Contour
    plots are perhaps most easily explained as a series of lines—the contours—drawn
    over the 2D evaluation grid, with each contour marking off a specific level of
    the surface of interest.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.4.1 Drawing Contour Lines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Based on a given numeric *z*-matrix, the R function `contour` is what’s used
    to produce the contours connecting *x*-*y* coordinates that share the same *z*
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1: Topographical Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For an example, you’ll use another ready-to-use data set—the `volcano` object.
    This data set is simply a matrix containing measurements of the elevation above
    sea level (in meters) of a dormant volcano over a rectangular area in the Auckland
    region of New Zealand; see the documentation in `?volcano` for details. To view
    the topography, you need the `volcano` object (which is your *z*-matrix) and the
    relevant *x*- and *y*-coordinate sequences. In this case, just use integers corresponding
    to the size of the `volcano` matrix (row and column numbers can be obtained with
    a simple call to `dim`; see [Section 3.1.3](ch03.xhtml#ch03lev2sec26)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The *x*- and *y*-sequences are provided to `x` and `y`, respectively, and the
    *z-*matrix to `z`. The optional argument `asp=1`, referring to the aspect ratio
    of the plot, forces a 1-to-1 unit treatment of the coordinate axes (this is relevant
    when the units have a physical size interpretation, like in plots of geographical
    regions—as is the case here).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-10](ch25.xhtml#ch25fig10) shows the result of this example. By default,
    R automatically chooses the levels of `z` at which to draw the contours for an
    aesthetically pleasing result. Contours are also selectively labeled with their
    corresponding *z* value. Looking at the topography, you can see the highest peak
    is a rim on the left, marked by an oblong contour at 190 m, with a depression
    (at around 160 m) falling immediately to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-10: Using* `contour` *to produce a topographic map of the* `volcano`
    *data*'
  prefs: []
  type: TYPE_NORMAL
- en: Contours are able to show you not only the peaks and troughs in a surface like
    this but the “steepness” of any such features too. The closer together the contour
    lines lie, the more rapid the change in the overall level of the bivariate function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2: Parametric Response Surface**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As a different kind of example, consider the multiple linear model fitted to
    the `mtcars` data mentioned earlier—that is, of MPG modeled by horsepower, weight,
    and an interaction between the two predictors. As in [Section 21.5.4](ch21.xhtml#ch21lev2sec205),
    you can get the fitted model object with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to plot the response, mean mileage, as the previous function of
    horsepower and weight. To do this, you need to evaluate the mean MPG, according
    to the previous model, for a grid of horsepower and weight values. The following
    code does exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, this code sets up evenly spaced sequences (each of length 20, spanning
    the range of the observed data) in both `hp` and `wt`—these are your *x-*and *y*-sequences.
    This implies there will be 20 × 20 = 400 unique coordinates at which you’ll be
    evaluating the fitted model; these coordinates are obtained using `expand.grid`
    as in [Section 25.3](ch25.xhtml#ch25lev1sec88).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can use `predict` to get the 400 corresponding mean MPG (*z*) values;
    since it’s already a data frame in the required format, `hp.wt` can be passed
    directly to the `newdata` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Then, you simply need to arrange the resulting vector as the appropriate 20
    × 20 *z*-matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you plot the result as contours, as shown in [Figure 25-11](ch25.xhtml#ch25fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this call, you can see the use of the optional `levels` argument. Rather
    than let R automatically decide at which values of *z* to show contours, you can
    supply a numeric vector to this argument with the specific levels at which to
    draw the lines. This numeric vector must be on the same scale as the resulting
    bivariate function of interest; here, I asked for contours at all integer levels
    from 32 through 8\. I also employ the familiar arguments `lty` and `lwd` to control
    the appearance of the contour lines themselves, which are set here as dashed and
    slightly thicker than usual.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, for contour plots in particular, you’ll often want to deviate from
    the default axis limit style, because the small amount of additional “padding”
    space that’s included in the default plot region (refer to [Section 23.4.1](ch23.xhtml#ch23lev2sec232))
    can be rather prominent—take another look at the volcano contour plot in [Figure
    25-10](ch25.xhtml#ch25fig10). As shown previously, setting `xaxs` and `yaxs` to
    `"i"` restricts all plotting to the exact limits imposed by `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-11: Contour lines depicting the response surface based on a multiple
    linear model of MPG by horsepower and weight, from the* `mtcars` *data*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 3: Nonparametric Bivariate Density Estimate (Earthquake Data)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another useful role fulfilled by contour plots and the other plots in this chapter
    is to visualize bivariate density functions.
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 24.2.2](ch24.xhtml#ch24lev2sec239), you looked at the idea of kernel
    density estimation (KDE) as a method by which to construct smooth estimates of
    the probability density functions of your data—essentially, sophisticated histograms.
    KDE extends to higher dimensions quite naturally so that you can also estimate
    the density of bivariate observations in the *x*-*y* plane. This again involves
    visualizing a *z*-matrix over a fixed grid of coordinates. For theoretical details
    on multivariate KDE, see Wand and Jones ([1995](ref.xhtml#ref70)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn your attention back to the built-in `quakes` data frame and recall the
    plots of the spatial coordinates of the 1,000 seismic events (for example, [Figure
    13-1](ch13.xhtml#ch13fig1) on [page 265](ch13.xhtml#page_265) and [Figure 23-1](ch23.xhtml#ch23fig1)
    on [page 578](ch23.xhtml#page_578)). To estimate the probability density function
    of these points, you can use the `kde2d` function in the `MASS` package. Load
    `MASS` and execute the following line to produce the kernel estimate of the observed
    two-dimensional data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You supply the bivariate data as the `x` and `y` arguments for the horizontal
    and vertical axes. The optional argument `n` is used to specify the number of
    evaluation coordinates (along each of the two axes) at which to actually return
    the estimated density surface. This defines the size of the matrix returned by
    a call to `kde2d`. Here, you’ve asked for KDE to be performed on a 100 × 100 evenly
    spaced grid over the range of the observed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting object is simply a list with three members. The components accessed
    through `$x` and `$y` contain the evenly spaced evaluation grid coordinates in
    the corresponding axis directions, and `$z` provides you with the corresponding
    *z*-matrix. You can confirm by entering either `quak.dens$x` or `quak.dens$y`
    at the prompt that they are indeed increasing sequences spanning the ranges of
    the observed data. Entering the following confirms the size of the matrix of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have all the ingredients you need to display contours of the
    KDE surface. The next line produces the default contour plot, given on the top
    left of [Figure 25-12](ch25.xhtml#ch25fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many more optional arguments available to `contour` for displaying
    your continuous surface. It can also be helpful to simultaneously view other data
    or raw observations (if they’ve been used in some way to create the surface, as
    is the case with bivariate KDE). The following code replots the `quakes` kernel
    estimate with unpadded axes, different contour levels to the defaults, and the
    raw observations; you can see the result on the top right of [Figure 25-12](ch25.xhtml#ch25fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Rather than using `levels` to determine the exact levels at which to draw the
    contours (as you did with Example 2), you can use the `nlevels` argument to specify
    the *number* of levels to display, and the function will choose the specific values.
    This latest call to `contour` requested 50 levels to be drawn. You can suppress
    the automatic labeling of the displayed contours by setting `drawlabels=FALSE`,
    also done here, followed by a call to `points` to add the original observations
    to the image. Naturally, the smooth contours delineating the nonparametric density
    estimate reflect the heterogeneous spatial patterning of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the appearance of your plotted contours needn’t be done universally;
    you can also alter the appearance of each individual contour level. This can be
    handy if, for example, you want to display contours at a handful of specific levels
    without the default labeling (to focus on the shape of the surface itself) but
    still want to be able to discern the values of those contours. You might also
    want to superimpose contours on an existing plot that already depicts other data
    or model-based results of interest. The third plot of the earthquake KDE surface,
    given on the bottom of [Figure 25-12](ch25.xhtml#ch25fig12), shows how you can
    achieve both of these things.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-12: Three examples of a contour plot of the bivariate kernel estimate
    of the probability density function of the spatial earthquake locations given
    in the* `quakes` *data set*'
  prefs: []
  type: TYPE_NORMAL
- en: To start the plot, the spatial locations of the earthquake data are drawn as
    half-size gray dots using `plot`, the style of the axes are set using `xaxs` and
    `yaxs` to remove the artificial padding around the edges of the plot region, and
    axis titles are added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, before calling `contour`, store the desired levels at which to draw contours
    in a vector named `quak.levs` (again, choosing appropriate contour levels depends
    entirely on what kind of surface you’re plotting; you need to be at least roughly
    aware of the values stored in the relevant *z*-matrix).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, remember that by default, `contour` refreshes the graphics device and starts
    a new plot, but you want to avoid that when adding contour lines to an existing
    plot. To do so, you need to explicitly specify `add=TRUE`. You then provide the
    four specified levels in `quak.levs` to `levels` and suppress labeling with `drawlabels=FALSE`.
    To control the appearance of contour lines at individual levels, you supply the
    sequence of integers `4:1` to `lty`, the first entry of which, `4`, defines the
    line type of the contour at *z* = 0.001\. The second entry, `3`, specifies the
    line type of the *z* = 0.005 contour, and so on. Lastly, set all drawn contours
    to double-thickness with the single supplied value `lwd=2`. (You could supply
    a vector with four elements here too, if you want differing line thicknesses for
    the different contours. The same element-wise contour specification extends to
    other relevant aesthetics, such as color via `col`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As a final touch, since the automatic labeling was suppressed in `contour`,
    add a legend in the bottom-left corner of the plot region, referencing the values
    of the contours through the four different line types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Many built-in and contributed base R plotting functions that by default initialize,
    refresh, or open a new plot include an* `add` *argument as shown here. This allows
    you to use the graphics produced by these functions as additions to an already
    existing graphic. Look in the relevant help file to see whether this is the case
    for a given command.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***25.4.2 Color-Filled Contours***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a straightforward variation on the contour plot, you can use color to fill
    the gaps between the different levels that are drawn. Combined with a color legend,
    this removes the need to label the contour lines and in certain cases can make
    it easier to visually interpret fluctuations in the plotted *z*-matrix surface.
  prefs: []
  type: TYPE_NORMAL
- en: The `filled.contour` function does this for you. You need to supply the increasing
    sequences of grid coordinates in both the *x*-axis and *y*-axisdirections, as
    well as the corresponding *z*-matrix, to the arguments `x`, `y`, and `z` in the
    same way as in `contour`. The easiest way to specify the colors is to supply a
    color palette to the `color.palette` argument (which defaults to the built-in
    `cm.colors` palette; refer to [Figure 25-2](ch25.xhtml#ch25fig2)), and R does
    the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `mtcars` response surface from Example 2 for a quick demonstration.
    If you don’t already have them in your current workspace, use the code from [Section
    25.4.1](ch25.xhtml#ch25lev2sec254) to obtain the relevant fitted multiple linear
    regression model, the evaluation grid coordinates, and the prediction thereof.
    With the objects `hp.seq`, `wt.seq`, and `car.pred.mat` defined as earlier, the
    following call produces [Figure 25-13](ch25.xhtml#ch25fig13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-13: Filled contour plot of the response surface for the fitted multiple
    linear model of the* `mtcars` *data*'
  prefs: []
  type: TYPE_NORMAL
- en: Note in this plot that the default color palette hasn’t been used. Instead,
    you’ve supplied a custom palette (produced as a direct result of an appropriate
    call to `colorRampPalette`; refer to [Section 25.1.3](ch25.xhtml#ch25lev2sec244))
    to the relevant argument, moving from white at the lower end to dark red at the
    upper end. Note also that although the *x*-axis and *y*-axis titles are provided
    as usual to `xlab` and `ylab`, you have to supply the title for the color legend
    in a particular way—inside a call to `title` to the `key.title` argument. This
    is because `filled.contour` actually produces two plots, one for the image itself
    and one for the color legend, and makes use of the `layout` command to place them
    next to one another.
  prefs: []
  type: TYPE_NORMAL
- en: This internal use of `layout` isn’t directly a problem, but, as you saw in [Section
    23.1.4](ch23.xhtml#ch23lev2sec225), it complicates matters somewhat if you want
    to annotate the filled contour plot after the fact (by, for example, adding points
    to an existing graphic) since the original user coordinate system is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Turn your attention back to the two-dimensional kernel estimate of the spatial
    `quakes` data (use the code from [Section 25.4.1](ch25.xhtml#ch25lev2sec254) to
    re-create it if you haven’t already got the `quak.dens` object in your workspace).
    The following code creates a filled contour plot of the density surface using
    the built-in `topo.colors` palette and modifies the number of drawn levels from
    the default of 20 to 30\. In the same call, you can superimpose the points of
    the raw observations onto the image through special use of the optional `plot.axes`
    argument. [Figure 25-14](ch25.xhtml#ch25fig14) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-14: Filled contour plot of the kernel estimate of the probability
    density function of the spatial* `quakes` *data, with raw observations superimposed.*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the way in which `plot.axes` is used; it effectively takes a
    chunk of code. When `plot.axes` is invoked, you must explicitly tell it to mark
    the *x*- and *y*-axes if you want the labeled tick marks to remain. This is done
    with two calls to `axis` (refer to [Section 23.4.3](ch23.xhtml#ch23lev2sec234)—`axis(1)`
    gives *x*, and `axis(2)` is used for *y*). You add the data points with a call
    to `points`; in this example, these are instructed to plot at half size, with
    30 percent opacity imparted with `adjustcolor`. Since you’re supplying multiple
    separate commands at once to the `plot.axes` argument, each command needs to be
    separated by a semicolon (`;`) inside braces (`{ }`).
  prefs: []
  type: TYPE_NORMAL
- en: Annotation of a filled contour plot in this fashion requires a little more forethought
    since you’re required to manually add the axes via calls to `axis` and perform
    all subsequently desired plotting actions within the call to `filled.contour`.
    It won’t work to, for example, produce a filled contour plot like the `quakes`
    KDE surface and then call `points` as a separate line of code. If you try it,
    you’ll see the observed data points unable to align correctly with their original
    user coordinates as indicated on the axes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.3**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you inspected various multiple linear regression models of the
    cost of nuclear power plant construction in [Chapters 21](ch21.xhtml#ch21) and
    [22](ch22.xhtml#ch22). The goal now will be to visually assess the impact of including/excluding
    an interactive term between two continuous predictors using contours. Revisit
    the `nuclear` data set, available when you load the `boot` package, and bring
    up the help file to refresh your memory of the variables present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fit and summarize two linear models with construction cost as the response
    variable according to the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first should account for main effects of the two predictors concerning the
    date of issue of the construction permit and plant capacity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second, in addition to the two main effects, should include an interaction
    between permit issue date and capacity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up appropriate *z*-matrices for plotting each of these response surfaces.
    Each one should be based on a 50 × 50 evaluation grid constructed using evenly
    spaced sequences in the capacity and date variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify `mfrow` in `par` so that you can display default contour plots for the
    two response surfaces from (a)(i) and (a)(ii) next to one another. Do they appear
    similar? Does thistie in with the statistical significance (or lack thereof) of
    the interaction term in (a)(ii)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To directly compare the two surfaces, use your choice of built-in color palette
    to produce a filled contour plot of the main-effects-only model and superimpose
    the contour lines of the interactive model on it. Take note of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – This plot is achieved in a single call to `filled.contour`. Recall the special
    way you use `plot.axes` to draw additional features on an existing color-filled
    contour plot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The contour lines of the interactive model can be added with an appropriate
    call to `contour`. Recall the use of the optional argument `add`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The superimposed contours should be dashed lines of double thickness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The *x*- and *y*-axes should be included and given tidy titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Add some brief text describing the filled contours versus the contour lines,
    with reference to the two versions of the construction cost model and with an
    additional call to `text` that makes use of a single mouse-clicked location from
    `locator` (see [Section 23.3](ch23.xhtml#ch23lev1sec78)). Note that this call
    will need to fully relax clipping for the text to be visible in any of the margins.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My result is shown here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0667-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Another built-in data frame in R, `faithful`, contains observations of waiting
    times and durations of eruptions of the Old Faithful geyser in Yellowstone National
    Park, Wyoming. See the documentation in `?faithful` for details. Plot the data
    with duration on the *y*-axis and waiting time on the *x*-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate the bivariate density of these data via KDE using a 100 × 100 evaluation
    grid and produce a default contour plot thereof.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a filled contour plot of the kernel estimate using a custom palette that
    ranges from `"darkblue"` to `"hotpink"`; include the raw data as half-size gray
    points. Label the axes and titles appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replot the raw data as gray, 3/4-sized, type `2` point characters; set the style
    of the axes to restrict to exactly the ranges of the observed data; and ensure
    tidy axis titles and a main title. To this plot, add the contour lines of the
    density estimate at the specific levels obtained in a sequence from 0.002 to 0.014
    in steps of 0.004\. Suppress the labeling of the contours. The contour lines should
    be dark red and increase in line width thickness for higher levels of the density.
    Add a legend referencing the density level at each of these lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: My plots for (g) and (h) are shown here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0668-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**25.5 Pixel Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pixel image* is arguably the most literal visual representation of a continuous
    surface approximated by a finite evaluation grid. Its appearance is similar to
    a filled contour plot, but an image plot gives you more direct control over the
    display of each entry of the relevant *z*-matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.5.1 One Grid Point = One Pixel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider each entry of your *z*-matrix as a little rectangle whose color depicts
    its relative value. These rectangles, or *pixels*, are exactly what’s depicted
    as the cells formed by the dashed gray lines making up the conceptual diagram
    of the *z*-matrix in [Figure 25-9](ch25.xhtml#ch25fig9) on [page 656](ch25.xhtml#page_656).
    This emphasizes the important fact that the fineness of your evaluation grid sequences
    (in both the *x*- and *y*-coordinate directions) directly defines the size of
    each pixel and therefore the smoothness of the resulting image. A smaller pixel
    means the *resolution* of the image is increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `image` function plots pixel images. Much as with `contour`, you
    supply your *x*- and *y*-axis evaluation grid coordinates as increasing sequences
    to the `x` and `y` arguments, with the corresponding *z*-matrix supplied to `z`.
    Going back to the `volcano` data set first looked at in Example 1 of [Section
    25.4.1](ch25.xhtml#ch25lev2sec254), the following line produces [Figure 25-15](ch25.xhtml#ch25fig15):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note again that you use the optional argument `asp=1` to enforce a one-to-one
    aspect ratio of the horizontal and vertical axes. This plot is comprised of exactly
    87 × 61 = 5307 pixels; each one represents a particular entry in the `volcano`
    matrix. Visually, the reflection of this image in the contour plot of the same
    data in [Figure 25-10](ch25.xhtml#ch25fig10) is clear.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-15: Pixel image of the Auckland volcano topography*'
  prefs: []
  type: TYPE_NORMAL
- en: The `image` command expects a vector of colors, usually supplied as hex codes
    from a palette, to be passed to its `col` argument. If this isn’t specified, it
    defaults to `heat.colors(12)` using the built-in palette, as in the image plot
    of `volcano`. One immediate concern, however, is the lack of a color legend. Contributed
    tools such as the `colorlegend` function from the `shape` package (refer to [Section
    25.1.5](ch25.xhtml#ch25lev2sec246)) prove useful for these plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return now to the `mtcars` response surface from Example 2 that fits the multiple
    linear regression model of MPG on horsepower and weight (and an interactive effect
    between the two predictors). The code for the necessary objects is reproduced
    here in a shortened form for convenience (refer to [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    for a fuller explanation of the operations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Just as earlier, you’ve set up a matrix of 400 elements in `car.pred.mat`, which
    is based on sequences of length 20 in both continuous predictors.
  prefs: []
  type: TYPE_NORMAL
- en: Now, make sure the `shape` package is loaded so you have access to the `colorlegend`
    function. The code that follows first sets up a custom palette of blue colors,
    sets new margin limits that widen the area on the rightmost axis, and then plots
    the predicted 20 × 20 response surface including a color legend; the result is
    given on the left of [Figure 25-16](ch25.xhtml#ch25fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-16: Two pixel images of the* `mtcars` *mean MPG response surface
    introduced in Example 2, with accompanying color legends. In terms of the evaluation
    grid in the horsepower and weight variables, the surface on the left has a resolution
    of 20 ²; the image on the right is based on a finer 50 ² grid. Contours are superimposed
    upon the rightmost plot.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a relatively coarse evaluation grid, the pixels making up the surface
    are prominent. You can easily increase the resolution of the parametric response
    surface by using finer sequences for the `hp.seq` and `wt.seq` evaluation grid.
    The code that follows does just that by increasing `len` to `50`, over-writing
    the objects used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the right-hand image of [Figure 25-16](ch25.xhtml#ch25fig16) is produced
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The newly plotted surface consists of 50² = 2500 pixels, as opposed to the previous
    image of merely 20² = 400 pixels. The improvement in the picture is obvious. In
    plotting the new image, the number of colors used (from the custom `blues` palette)
    is increased to 100 to provide smoother color transitions. Note also the use of
    `add` in a call to `contour` to superimpose contour lines upon the image to provide
    further visual emphasis of the fluctuating surface over the evaluation grid. A
    legend is added with an appropriate call to `colorlegend` as a final touch.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.5.2 Surface Truncation and Empty Pixels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of its one-to-one literal representation of the *z*-matrix, a pixel
    image is especially good when you want to plot a surface that fits irregularly
    over, or is smaller than, the standard rectangular evaluation grid spanning the
    *x-*and *y*-axes. To carefully demonstrate this kind of manipulation, let’s turn
    to a new data set from the contributed `spatstat` package by Baddeley and Turner
    ([2005](ref.xhtml#ref06)). Install `spatstat` with a call to `install.package("spatstat")`.
    Note that `spatstat` has a number of dependencies; see [Appendix A.2.3](app01.xhtml#app01lev2sec275)
    if you have any trouble downloading and installing `spatstat`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 4: Nonparametric Bivariate Density Estimate (Chorley-Ribble Data)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once `spatstat` is installed and loaded in your current R session with a call
    to `library("spatstat")`, inspect the help file brought up by entering `?chorley`
    at the prompt. This details the Chorely-Ribble cancer data—spatial locations of
    1,036 cases of cancer of the larynx and lung collected in the late 1970s and early
    1980s in a particular region of England (data first analyzed by [Diggle, 1990](ref.xhtml#ref18)).
    The `chorley` object is of a special class specific to `spatstat` (a `"ppp"` object—*planar
    point pattern*), but its components can be extracted just as if you’re referencing
    members of a named list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of the observations can be retrieved as the components `$x`
    and `$y`. To view the spatial dispersion of the observations, the following line
    gives you the top-left image of [Figure 25-17](ch25.xhtml#ch25fig17):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Your goal is to display a kernel estimate of the two-dimensional probability
    density function of the cancer distribution, similar to what you did with the
    earthquake data in Example 3\. You’ll use the `kde2d` function for this—execute
    `library("MASS")` to gain access to it. Then, exactly as you used it for the spatial
    locations of `quakes`, the default KDE surface for the observed Chorley-Ribble
    data is given with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note the specification of a fine 256 × 256 easting-northing evaluation grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the density estimate, use the built-in `rainbow` palette and use
    the optional `start` and `end` arguments to restrict the total range of the palette
    to begin at red at the lower end and end at magenta/pink at the upper end (these
    arguments were mentioned briefly in [Section 25.1.2](ch25.xhtml#ch25lev2sec243);
    refer to the help file `?rainbow` for more details on the use of `start` and `end`).
    Prestore 200 colors from this palette with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the image is produced by calling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Another component of `chorley`, named `$window`, contains the vertices of an
    irregular polygon. This polygon defines the geographical study region in which
    the observations themselves were made. The `$window` component also happens to
    be another special object class of `spatstat`, namely, `"owin"` for “observation
    window.” Although it’s possible to extract the specific vertices of the polygon
    and plot it manually with built-in functionality, the authors of `spatstat` have
    provided a standard `plot` method to use for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the `image` command, calling the following code superimposes
    the border of the study region upon the pixel image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The final result is given on the top right of [Figure 25-17](ch25.xhtml#ch25fig17).
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that the geographical region in which the data were collected
    is a little wider than the *x*- and *y*-ranges of the observations themselves,
    so the current plot hasn’t been able to show the region in its entirety. The following
    code shows this numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The *x*- and *y*-ranges of the study region can be obtained as the `$xrange`
    and `$yrange` components of the `$window` component (which is stored in the first
    line as the object `chor.WIN`). You can see that the overall study region is slightly
    larger when you compare its limits to the results of calling `range` on the raw
    data.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not the only problem, either. From the plot, you can also see that the
    KDE surface has been estimated and drawn in some areas that are actually *outside*
    the study region, so that will need to be fixed as well. (You’ll look at that
    in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-17: Visual experimentations in attempts to plot a two-dimensional
    kernel estimate of the probability density function of the Chorley-Ribble cancer
    data as a pixel image. Top left: The raw data. Top right: The default* `kde2d`
    *result based on the data ranges with the study region superimposed. Bottom left:
    Expanding the* `xlim` *and* `ylim` *of the call to* `image` *when plotting the
    original density estimate. Bottom right: A revised density estimate, using the
    full* x*- and* y*-ranges of the study region to define the evaluation grid.*'
  prefs: []
  type: TYPE_NORMAL
- en: So, first off, what can you do to ensure the entire geographical region is displayed?
    Well, you could of course use the ranges of the region as stored previously in
    the vectors `WIN.xr` and `WIN.yr` and supply them to the familiar optional `xlim`
    and `ylim` arguments when calling `image`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The result of these two lines is given on the bottom left of [Figure 25-17](ch25.xhtml#ch25fig17).
    Unfortunately, the original density estimate is still defined in terms of the
    original *x*- and *y*-ranges of the raw data, which gives you a border of empty
    pixels; in addition, the aforementioned density areas still fall outside the observation
    window.
  prefs: []
  type: TYPE_NORMAL
- en: All this emphasizes the important fact that a *z*-matrix is specific to a predefined
    evaluation grid. The only way to get your density estimate to span the geographical
    study region for the Chorley-Ribble data is to revise your kernel estimate so
    that it’s produced on an evaluation grid that spans the limits of the region.
    Fortunately, the `kde2d` function allows you to set optional *x*-*y* limits of
    the evaluation grid with the `lims` argument. This expects a numeric vector of
    length 4, with the *x*-axis lower and upper values followed by the *y*-axis lower
    and upper values, in that order. The following code reestimates the density using
    the study region limits and plots it. The result is given on the bottom right
    of [Figure 25-17](ch25.xhtml#ch25fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With that, you’ve solved the problem of ensuring your surface spans the desired
    area. However, this definitely highlights the second problem—the data that were
    actually observed fall strictly within the defined polygon, but you can see plotted
    pixels outside the geographical region, which doesn’t make sense. You can control
    precisely which pixels are plotted in any given pixel image by setting the relevant
    entries in your *z*-matrix to be `NA` if you don’t want them drawn.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a mechanism that can decide whether a given cell entry in your *z*-matrix,
    namely, `chor.dens.WIN$z`, corresponds to a location inside or outside the polygon
    (the object `chor.WIN`). If it falls outside, you’ll want to force that entry
    to be `NA`. In general, this type of decision making requires you to test each
    element of the matrix with respect to its coordinate value on the evaluation grid,
    possibly using your own R function. Fortunately, in this case, the `inside.owin`
    function of `spatstat` does exactly that, but the principle remains the same whenever
    you need control over precisely which pixels are plotted and which aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given one or more two-dimensional (*x*,*y*) coordinates and an object of class
    `"owin"`, the `inside.owin` function returns a corresponding logical vector with
    a `TRUE` for those coordinates inside the defined region and a `FALSE` for any
    other coordinate. As a quick demonstration, observe the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This confirms what you can see from [Figure 25-17](ch25.xhtml#ch25fig17)—that
    the coordinate (355,420) lies well within the polygon and that the coordinate
    (345,415) doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to use the `inside.owin` function on every coordinate in the evaluation
    grid that *z*-matrix `chor.dens.WIN$z` sits on. First, create the full set of
    grid coordinates using `expand.grid`, in the same way as illustrated in [Section
    25.3.1](ch25.xhtml#ch25lev2sec251).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Calling `nrow` on the resulting data frame of coordinates confirms you have
    exactly 256² = 65536 grid points as defined in the `chor.dens.WIN` KDE object.
    The following call then takes the two columns of `chor.xy` and makes use of logical
    negation (using `!`) to produce a logical vector that flags grid coordinates that
    are located *outside* the defined geographical region.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The final step is now at hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: First, for clarity, recast the long `chor.outside` vector as a 256 × 256 matrix
    to emphasize that it corresponds exactly to the *z*-matrix of interest. Then this
    logical flag matrix is used to directly overwrite the “outside” entries in the
    *z*-matrix to be `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that’s left now is to plot the image with the newly manipulated *z*-matrix.
    Make sure you have the `shape` package loaded for the finishing touch of a color
    legend. The following code creates the KDE surface pixel image plot with pixel
    points restricted to the geographical region defined by `$window` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: First you open a new graphics device and widen the right margin to incorporate
    the color legend. Next you invoke `image` to plot, specifically using an *L*-shaped
    box and a strict one-to-one *x*-*y* aspect ratio, and then you add the region
    polygon with slightly thicker lines. Finally you execute `colorlegend` to obtain
    an appropriately positioned legend referencing the color values (the specific
    positioning and tick marks of which were found after a little trial and error).
    You can see the final result in [Figure 25-18](ch25.xhtml#ch25fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-18: Final pixel image plot of the Chorley-Ribble KDE surface, restricted
    to the geographical study region of the originally collected data.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In truncating the kernel estimate of the bivariate density estimate that was
    originally defined over the full rectangular evaluation grid, technically you
    no longer have a valid probability density function as a result (since the integral
    over the irregular region will no longer evaluate to a total probability of 1).
    A more mathematically sound approach requires a deeper knowledge of multivariate
    KDE and is beyond the scope of this text. Nevertheless, being able to truncate
    pixel plots like this is useful in any situation where you want to define your
    surface on a (possibly irregular) subset of an overall rectangular evaluation
    grid.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisit the built-in `airquality` data set and take a look at the help file
    to refresh your memory of the variables present. Create a copy of the data frame:
    select the columns pertaining to daily temperature, wind speed, and ozone level
    and use `na.omit` to remove any records with missing values.'
  prefs: []
  type: TYPE_NORMAL
- en: From your explorations of these data in [Chapter 24](ch24.xhtml#ch24), there
    appears to be an association among daily temperature, wind speed, and ozone level.
    Fit a multiple linear regression model that aims to predict mean temperature based
    on the wind speed and ozone level, including an interactive effect. Summarize
    the resulting object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the model from (a), construct a *z*-matrix of predicted mean daily temperature
    based on a 50 × 50 evaluation grid in both wind speed and ozone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a pixel image of the response surface, superimposing the raw observations
    as per the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – A graphics device should be initialized based on bottom, left, top, and right
    margin lines of 5, 4, 4, and 6, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – 20 colors from the built-in `topo.colors` palette should be used to produce
    the image; include tidy axis titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Revisit the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    and use the built-in function `gray` to generate a vector of gray colors (refer
    to [Section 25.1.2](ch25.xhtml#ch25lev2sec243)) based on the normalized raw temperature
    observations. Superimpose the raw observations based on wind speed and ozone onto
    the pixel image, using the gray color vector to indicate the corresponding temperature
    observations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Two separate calls should then be made to `colorlegend` of the `shape` package.
    The first should appear in the space on the right margin, referencing the surface
    itself. The second should use the built-in `gray.colors` function, setting the
    optional arguments `start=0` and `end=1`, to generate 10 shades of gray for use
    in the legend that references the raw temperature observations of the superimposed
    points. This legend should reside on top of the pixel image itself, in the upper-right
    quadrant where there are no raw observations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Both legends should have appropriate titles, and you may need to experiment
    a little with the `posx` and `posy` arguments to find satisfactory placement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My result of this plotting exercise appears here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0677-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In [Section 25.5.2](ch25.xhtml#ch25lev2sec257), you used the `chorley` data
    set in creating a pixel image truncated to a subset of the overall rectangular
    evaluation grid. Ensure `spatstat` is loaded in your current R session and execute
    the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: R> fire <- split(clmfires)$intentional
  prefs: []
  type: TYPE_NORMAL
- en: R> firewin <- clmfires$window
  prefs: []
  type: TYPE_NORMAL
- en: This extracts the 1,786 locations of fires recorded as intentionally lit in
    a particular region of Spain. The spatial coordinates can be extracted as the
    `$x` and `$y` members of `fire`, and the geographical region itself is stored
    as a polygon in `firewin` (of the same class as the `chorley$window` object you
    looked at earlier). See the documentation obtained with `?clmfires` for further
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Using the total *x*- and *y*-range of the study region, use `kde2d` from the
    `MASS` package to calculate a bivariate kernel estimate of the probability density
    function of the spatial dispersion of intentionally lit fires. The KDE surface
    should be calculated based on a 256 × 256 evaluation grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all points on the rectangular evaluation grid that fall outside the
    geographical region using `expand.grid` in conjunction with `inside.owin`. Set
    all corresponding pixels of the density surface to `NA`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct a pixel image of the truncated density, as per the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – The graphics device should have three lines of space on the bottom, left,
    and top of the plot region and should have seven lines on the right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – In producing the image itself, you should use 50 colors generated from the
    built-in `heat.colors` palette. A one-to-one aspect ratio should be maintained,
    the axis titles should be suppressed, and the box type set to be an *L* shape.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The geographical study region should be superimposed onto the image using
    a double-width line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `colorlegend` from `shape`, a color legend referencing the density with
    an appropriate title should be placed to the right of the image. You’ll need to
    experiment with the `posx` argument for placement. Label the legend at a sequence
    from `5e-6` to `35e-6` in steps of `5e-6` (refer to [Section 2.1.3](ch02.xhtml#ch02lev2sec19)
    for an explanation of e-notation); also, ensure these labels are able to display
    up to six decimal places of precision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For your reference, my result is given here.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0679-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**25.6 Perspective Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last kind of plot you’ll look at in this chapter is the *perspective plot*,
    some-times also referred to as a *wireframe*. Unlike contour plots and pixel images,
    where fluctuations in the surface are emphasized with line patterns and/or colors,
    a perspective plot uses a physical third dimension against which the *z* value
    is plotted.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.1 Basic Plots and Angle Adjustment***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perspective plots are especially useful when you want to emphasize the fluctuating
    nature of the values populating your *z*-matrix. For example, in some applications
    you might want to get a good impression of the relative extremity of any present
    peaks and/or troughs in the plotted surface, which is harder to do in, for example,
    a pixel image or contour plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the `mtcars` response surface plotted as contours and as pixel images
    in [Sections 25.4.1](ch25.xhtml#ch25lev2sec254) and [25.5.1](ch25.xhtml#ch25lev2sec256).
    You created a 20 × 20 evaluation grid in the horsepower and weight variables,
    as well as a corresponding *z*-matrix of 400 giving the predicted mean MPG result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in R function `persp` is used to create perspective plots. Its basic
    usage is the same as `contour`, `filled.contour`, and `image`. Your increasing
    sequences in the *x*- and *y*-axis directions, which define the evaluation grid,
    are passed to `x` and `y`, with your corresponding *z*-matrix passed to `z`. Bring
    up the default appearance for the 20 × 20 `mtcars` response surface with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This appears in the top left of [Figure 25-19](ch25.xhtml#ch25fig19).
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the perspective plot is straightforward. The default viewing angle
    shows the *x*-axis in the foreground, increasing from left to right, and the *y*-axis
    on the left side, increasing from the foreground to deeper in the background.
    In this way, the evaluation grid lies flat along the bottom in the 3D graphic,
    with the *z*-axis against which your surface is plotted increasing from the bottom
    vertically to the top.
  prefs: []
  type: TYPE_NORMAL
- en: The viewing angle is one of the most important aspects of such a plot. In `persp`,
    you can control it with the two optional arguments `theta`, which spins the plot
    around horizontally, and `phi`, which adjusts the vertical viewing position. Both
    are specified in degrees; `theta` defaults to `0`, so you’re looking directly
    at the *x*-axis spanning left to right in front of you, and `phi` defaults to
    `15` to give a slightly elevated viewing position so you can see the *y*-axis
    extending foreground to background. In general, you can think of the possible
    value of `theta` as anywhere from `0` to `360`, representing a complete rotation
    all around the plot, and the possible value of `phi` as anywhere from `90` to
    `-90`, the range of which moves you from a bird’s-eye view directly from the top
    looking down to a submarine view directly from the bottom looking up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This second example demonstrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In fact, it’s this line of code that originally produced the rightmost image
    in [Figure 21-9](ch21.xhtml#ch21fig9) on [page 523](ch21.xhtml#page_523) (when
    you were introduced to the concept of an interactive term between two continuous
    predictors in a multiple linear regression model). The graphic is reproduced here
    in the top right of [Figure 25-19](ch25.xhtml#ch25fig19). The axis titles are
    tidied up using `xlab` and `ylab`, with `zlab` used to control the title for the
    third vertical axis. The use of `theta` and `phi` in this instance has elevated
    the viewing point slightly more than the default and rotated the plot so that
    the origin (in other words, the lower vertex denoting the lower limit of the *x*-*y*
    plane) is prominent in the foreground. It’s worth noting that increasing `theta`
    from `0` rotates the plot in a clockwise-horizontal fashion, but you could also
    supply a negative value to that argument to rotate the plot in the other direction.
    Setting `theta=-30`, as shown here, has the same effect as setting `theta=330`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-19: Perspective plots of the 20* × *20* `mtcars` *response surface
    created using* `persp`*. Top left: Default appearance. Top right: Using* `theta`
    *and* `phi` *to adjust the viewing angle. Bottom left: Setting* `ticktype="detailed"`
    *to provide detailed axis labeling. Bottom right: Adding depth shading using*
    `shade` *and removing facet border lines with* `border=NA`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are no tick marks or labels included, only directional arrows.
    You can remedy this by setting the optional `ticktype` argument to `"detailed"`.
    You can find the result of the following in the bottom left of [Figure 25-19](ch25.xhtml#ch25fig19),
    which also offers another viewing angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The help file `?persp` details a host of other arguments specific to controlling
    the presentation of any given perspective plot. As a few examples, you could shade
    the surface in grayscale to emphasize the 3D depth of the image, you could change
    the color or suppress the plotting of the grid lines making up the surface itself,
    or you could change the relative length of the *z*-axis. The final plot of the
    `mtcars` response surface illustrates such actions. The result of the following
    call is visible in the bottom right of [Figure 25-19](ch25.xhtml#ch25fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: With the same viewing angle as the previous plot, this plot uses the `shade`
    argument to shade the surface facets to produce a lighting-style effect, enhancing
    the perceptive depth slightly. The calculations for the shading rely on a non-negative
    numeric value; setting `shade=0.6` provides a moderate-strength effect. You might
    like to experiment with larger or smaller values. If you’re shading the surface
    in this way, it’s usually best to suppress the grid lines that by default make
    up the surface; you can set `border=NA` to achieve this (the `border` argument
    can also be used to simply change the surface grid color by supplying any valid
    R color to it). Finally, the `expand` argument is used to adjust the size of the
    *z*-axis. Specifying `expand=0.8` requests a vertical axis that is 80 percent
    the size of the axes in the evaluation grid, producing a slightly “squashed down”
    prism in which the surface is drawn. You could also use values greater than 1
    for `expand`, in which case the effect would be to “stretch out” the plot along
    the vertical.
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.2 Coloring Facets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like most traditional R plotting commands, you can use the optional `col` argument
    to color the facets of a perspective surface. To color a perspective surface with
    a constant color throughout, you would just provide `col` with a single value.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in `col`, however, it’s often the case that you want to
    color the surface according to the fluctuating *z*-values to highlight the changing
    value of the bivariate function. To successfully do this for the facets making
    up the surface, it’s important to understand that these facets aren’t the same
    as the pixels that would make up a pixel image of the same *z*-matrix. Where `image`
    pixels are directly represented by the entries of, say, your *m* × *n*-sized *z*-matrix,
    `persp` facets should be interpreted as the space *between* the border lines drawn
    at those matrix entries, leaving you with (*m* − 1) × (*n* − 1) facets. In other
    words, in a perspective plot, each *z*-matrix entry lies at an intersection of
    the drawn lines—the *z*-matrix entries are *not* situated in the middle of each
    facet.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, take another look at [Figure 25-9](ch25.xhtml#ch25fig9)
    on [page 656](ch25.xhtml#page_656). When you use `image`, R automatically calculates
    the pixel sizes based on your *x*- and *y*-axis evaluation grid sequences and
    plots the surface based on the rectangles formed by the dashed gray lines, with
    the *z*-matrix entries `a`, `b`, `c`, and so on, represented directly. When you
    use `persp`, however, the visible border lines are represented by the solid-line
    grid (of arrows), intersecting at each entry, and so the facets of the resulting
    surface are formed by the space between these lines, each one defined by four
    adjacent entries. [Figure 25-20](ch25.xhtml#ch25fig20) shows a section of the
    hypothetical grid in [Figure 25-9](ch25.xhtml#ch25fig9), where I’ve marked off
    one pixel as interpreted by `image` and one facet as interpreted by `persp`. With
    that, you can see why, in [Figure 25-9](ch25.xhtml#ch25fig9), there would be exactly
    6 × 4 = 24 pixels in an image plot but 5 × 3 = 15 facets in a perspective plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-20: Illustrating the difference in treatment of the* z*-matrix in
    a pixel image and in a perspective plot. The highlighted box in the bottom-left
    corner represents an* `image` *pixel of the value* `a` *in the* z*-matrix; the
    highlighted box to the right represents a* `persp` *facet formed by the values*
    `b`, `h`, `i`*, and* `c`*. For coloring, the* z*-value of the highlighted facet
    will be calculated as the mean of those four entries, in other words,* (`b` +
    `h` + `i` + `c`)*/4.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `col` argument needs to specify the (*m* − 1) × (*n* − 1) facet colors (assuming
    an *m* × *n z*-matrix passed to `z`). The typical way to find this in R if you’re
    intending to color the facets according to the *z*-value is to first calculate
    each facet’s *z*-value, which will be the average of the four adjacent *z*-matrix
    entries. Only thereafter can you deploy one of the color assignment approaches
    from [Section 25.1.4](ch25.xhtml#ch25lev2sec245).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recast the pixel image of the Chorley-Ribble kernel density estimate (Example
    4; [Figure 25-18](ch25.xhtml#ch25fig18)), complete with *z*-axis-specific coloring,
    as a perspective plot. First, make sure you have the packages `spatstat` and `MASS`
    already loaded. Then repeat the code from earlier to obtain the kernel estimate
    on the appropriate evaluation grid, truncated to the geographical study region.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to calculate all the facet *z* values; this can be done en masse
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines simply store the *z*-matrix as the object `zm` and its
    total rows and columns (both 256 in this case) as `nr` and `nc`, respectively,
    for compactness of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth line is where the relevant calculations happen, giving a matrix
    of the facet *z* values. It does this systematically, by element-wise summation
    of four versions of the original *z*-matrix: `zm[-1,-1]` (first row and first
    column omitted), `zm[-1,-nc]` (first row, last column omitted), `zm[-nr,-1]` (last
    row, first column omitted), and `zm[-nr,-nc]` (last row, last column omitted).
    When the four alternates are summed in this way and divided by 4 at the end, the
    result is a matrix `zf`, each element of which is the four-point average of each
    “rectangle” of four adjacent entries in the original *z*-matrix, exactly as noted
    in the discussion and caption of [Figure 25-20](ch25.xhtml#ch25fig20). The final
    call to `dim` on `zf` confirms the size of the result. Since there are a total
    of 256 × 256 evaluation grid lines in the defined *z*-matrix, these encapsulate
    a total of 255 × 255 perspective facets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hard work is done, and all you need to do now is assign the colors from
    your palette to the calculated facet *z* values in `zf`. You can do this using
    either the categorization or normalization approach, as noted in [Section 25.1.4](ch25.xhtml#ch25lev2sec245);
    for simplicity, let’s stick to categorization. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The first line is repeated from [Section 25.5.2](ch25.xhtml#ch25lev2sec257)
    to generate the same 200 colors from the built-in `rainbow` palette as were used
    in the pixel images. The second line sets up an evenly spaced sequence spanning
    the range of the calculated facet *z*-values to form the category break points
    that are required by the categorization approach. Note the use of `na.rm=TRUE`
    in the required calls to `min` and `max` to avoid all the `NA` entries present
    in `zf` (remember, the surface has been truncated to the irregular polygon representing
    the geographical study region). The sequence is one more in length than the number
    of generated colors—again, refer to [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    for this necessary feature of the categorization approach. Lastly, `cut` assigns
    each of the `zf` facet value entries an appropriate rank with respect to the 200
    ordered bins. As you’ve learned, the `zf.colors` ranks are subsequently used to
    index the vector of 200 colors stored in `rbow` when plotting.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you can enjoy the fruits of your labor! The following code plots
    the bivariate kernel density estimate of the Chorley-Ribble observations as a
    perspective plot using facet coloring to reflect the relative height of the surface
    along the *z*-axis. Border lines are suppressed to show off the color clearly,
    the *z*-axis is scaled down slightly, and a color legend is inserted on the right
    side (ensure the `shape` package has been loaded for that) after manipulating
    the default figure margins via `mar` in a call to `par` to create extra space
    for it. You can find the result in [Figure 25-21](ch25.xhtml#ch25fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f25-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-21: A perspective plot of the Chorley-Ribble density estimate, demonstrating
    facet coloring that changes according to the* z*-value of the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included the optional argument `scale=FALSE` in the execution of `persp`.
    This retains a one-to-one aspect ratio in the *x*- and *y*-coordinate directions;
    this is useful since you’re looking at geographical data. Unfortunately, this
    also forces the density estimate values on the *z*-axis to be scaled in the same
    way, which makes no sense in the context of the current plot. To avoid the small
    scale resulting in a supremely flat appearance of the surface itself, you need
    to use `expand` to artificially amplify the surface along the third axis. In this
    instance, multiplying it by a factor of around 750 provides a visually pleasing
    result. Note that this would not be necessary if you left the `scale` argument
    at its default `TRUE` value (since, in that case, R internally scales all three
    axes for a one-to-one-to-one aspect ratio).
  prefs: []
  type: TYPE_NORMAL
- en: '***25.6.3 Rotating with Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last bit of fun you can have with perspective plots if you want
    to get an overall impression of the plotted surface. Using a simple `for` loop
    ([Section 10.2.1](ch10.xhtml#ch10lev2sec92)) to increment either `theta` or `phi`,
    you can perform a series of repeated calls to `persp`, each one at a slightly
    new angle. Doing this in sequence results in an animation—essentially a cartoon—of
    a rotating surface, allowing you to see it from all different sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following basic function in the R editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Using an ellipsis (see [Section 11.2.4](ch11.xhtml#ch11lev2sec102)), `persprot`
    simply takes all the arguments you’d usually supply to a call to `persp`, barring
    `theta` and `phi`. Then comes a `for` loop, which immediately calls `persp` with
    `theta=0` and the content of the ellipsis. The `for` loop alters the vertical
    viewing angle, starting with `phi=90` (birds-eye view) and moving down to a mildly
    elevated `phi=20`. A second `for` loop then completes a full 360-degree horizontal
    rotation by altering `theta`.
  prefs: []
  type: TYPE_NORMAL
- en: The only formally tagged argument is `skip`, which determines the amount `phi`
    and `theta` increment by at each iteration. The default, `skip=1`, simply moves
    through the integer-valued angles. Increasing `skip` will reduce the time it takes
    to complete the rotation, though it makes for a more jagged animation.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of graphics device you’re using, you may want to experiment
    with `skip`. Note that not all graphics device types will be well-suited to the
    animation effect sought by running this rather crude function (for example, it’s
    not appropriate if you’re using RStudio—see [Appendix B](app02.xhtml#app02)).
    That said, when running the base R GUI applications on OS X or Windows, I find
    `persprot` works well under default graphics settings.
  prefs: []
  type: TYPE_NORMAL
- en: Import the function to try it; let’s do so here for a perspective plot of a
    kernel estimate of the probability density function of the spatial `quakes` locations
    you first examined as Example 3, [Section 25.4.1](ch25.xhtml#ch25lev2sec254).
    With the `MASS` package already loaded, produce the density estimate on a 50 ×
    50 evaluation grid with the following line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Then you use `persprot` just as you’d use `persp`, without needing to specify
    either `theta` or `phi`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 25-22](ch25.xhtml#ch25fig22) shows a series of screenshots of the rotating
    plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f25-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-22: A rotating perspective plot of a KDE surface for the spatial
    earthquake locations, after a call to the custom* `persprot` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.5**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Exercise 25.3](ch25.xhtml#ch25exc3) (a), you revisited the `nuclear` data
    set from the `boot` package and fitted two multiple linear regression models aiming
    to model mean construction cost by permit date issue and plant capacity—one with
    main effects only and the other including an interaction term between the two
    continuous predictors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refit the two versions of the model and produce perspective plots of the response
    surfaces based again on a 50 × 50 evaluation grid, taking the following into account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Use `mfrow` in a call to `par` to display the two perspective plots next to
    each other. In the same call to `par`, override the default figure margins to
    have only one line of space on each side (`par` is explored in this role in [Chapter
    23](ch23.xhtml#ch23)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `zlim` to ensure both plots are displayed on the same scale of vertical
    axis, spin each one horizontally 25 degrees, and ensure detailed axis markings
    and tidy titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Is there any visual indication that the presence of the interaction term has
    had any meaningful impact on modeling the response?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start a fresh plot. To get a better idea of the difference between the two surfaces,
    produce a perspective plot of the *z*-matrix obtained as the elementwise difference
    between the two individual *z*-matrices for the two fitted models in (a). What,
    in general, is the effect of including the interaction term?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn your attention back to the topographical information on the Auckland volcano,
    as the built-in R object `volcano`: an 87 × 61 matrix of elevation values (in
    meters). You first looked at this in [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    as a contour plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Produce the most basic, default perspective plot of the volcano, using simple
    integer sequences for the *x*- and *y*-coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The plot in (c) is decidedly unappealing for a number of reasons. Produce a
    more realistic depiction of the volcano as per the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Use a new graphics device with the margin widths reset to one, one, one, and
    four lines on the bottom, left, top, and right, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The help file `?volcano` reveals the *x*- and *y*-coordinates to which the
    volcano *z*-matrix corresponds is in 10-meter units. Using `scale` and altering
    `expand`, replot the surface with the correct aspect ratio in all three axes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Suppress all axis tick marks and notation using `axes`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The facets should be colored according to 50 colors generated from the built-in
    `terrain.colors` palette, and the facet border lines should be suppressed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Find your choice of visually appealing viewing angle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `colorlegend` from the `shape` package to place a color legend referencing
    elevation in meters in the space to the right of the plot. Experiment with the
    arguments to find appropriate placement and tick mark labels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s my version of the improved plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0689-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In [Exercise 25.4](ch25.xhtml#ch25exc4), you looked at the spatial distribution
    of intentionally lit fires in a region of Spain. Ensure the `spatstat` package
    is loaded, and then rerun the following lines to obtain the relevant data objects:'
  prefs: []
  type: TYPE_NORMAL
- en: R> fire <- split(clmfires)$intentional
  prefs: []
  type: TYPE_NORMAL
- en: R> firewin <- clmfires$window
  prefs: []
  type: TYPE_NORMAL
- en: 'Borrow the code from [Exercise 25.4](ch25.xhtml#ch25exc4) (d) and (e) to reproduce
    the kernel density estimate of this dispersion of observations, based on a 256
    × 256 evaluation grid, truncated to the study region. Then, display it as a perspective
    plot according to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – Just as with the pixel image, use 50 colors from the built-in `heat.colors`
    palette to color the facets by *z* value. Note the truncated *z*-matrix for this
    function contains `NA` values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Border lines on the surface should be suppressed, and you should find your
    preferred choice of viewing angle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Use `scale` to ensure the correct spatial aspect ratio. In doing so, you’ll
    also need to adjust the *z*-axis expansion by a factor of around 5,000,000 for
    the density surface to be visible along the vertical, given the natural scaling
    of the density estimate on the specified evaluation grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Employ detailed axis labeling and simply entitle the axes `"X"`, `"Y"`, and
    `"Z"` as appropriate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My product is given here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0690-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use the `persprot` function defined in [Section 25.6.3](ch25.xhtml#ch25lev2sec260)
    to view the surface from (e), setting `skip=10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `palette` | List integer colors | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  prefs: []
  type: TYPE_TB
- en: '| `col2rgb` | Named color to RGB | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  prefs: []
  type: TYPE_TB
- en: '| `rgb` | RGB to hex code | [Section 25.1.1](ch25.xhtml#ch25lev2sec242), [p.
    633](ch25.xhtml#page_633) |'
  prefs: []
  type: TYPE_TB
- en: '| `rainbow`, `heat.colors`, `gray`, `terrain.colors`, `cm.colors`, `topo.colors`,
    `gray.colors` | Built-in palettes | [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    [p. 635](ch25.xhtml#page_635) |'
  prefs: []
  type: TYPE_TB
- en: '| `colorRampPalette` | Custom palette (integer) | [Section 25.1.3](ch25.xhtml#ch25lev2sec244),
    [p. 636](ch25.xhtml#page_636) |'
  prefs: []
  type: TYPE_TB
- en: '| `colorRamp` | Custom palette ([0,1] interval) | [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    [p. 640](ch25.xhtml#page_640) |'
  prefs: []
  type: TYPE_TB
- en: '| `colorlegend` | Color legend (`shape`) | [Section 25.1.5](ch25.xhtml#ch25lev2sec246),
    [p. 641](ch25.xhtml#page_641) |'
  prefs: []
  type: TYPE_TB
- en: '| `scatterplot3d` | 3D scatterplot (`scatterplot3d`) | [Section 25.2.1](ch25.xhtml#ch25lev2sec249),
    [p. 649](ch25.xhtml#page_649) |'
  prefs: []
  type: TYPE_TB
- en: '| `expand.grid` | All unique evaluation coords. | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 654](ch25.xhtml#page_654) |'
  prefs: []
  type: TYPE_TB
- en: '| `letters` | Alphabet characters | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 655](ch25.xhtml#page_655) |'
  prefs: []
  type: TYPE_TB
- en: '| `contour` | Contour plot | [Section 25.4.1](ch25.xhtml#ch25lev2sec254), [p.
    657](ch25.xhtml#page_657) |'
  prefs: []
  type: TYPE_TB
- en: '| `kde2D` | Bivariate KDE (`MASS`) | [Section 25.4.1](ch25.xhtml#ch25lev2sec254),
    [p. 660](ch25.xhtml#page_660) |'
  prefs: []
  type: TYPE_TB
- en: '| `filled.contour` | Color-filled contour plot | [Section 25.4.2](ch25.xhtml#ch25lev2sec255),
    [p. 664](ch25.xhtml#page_664) |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | Pixel images | [Section 25.5.1](ch25.xhtml#ch25lev2sec256), [p.
    668](ch25.xhtml#page_668) |'
  prefs: []
  type: TYPE_TB
- en: '| `inside.owin` | Test inside region (`spatstat`) | [Section 25.5.2](ch25.xhtml#ch25lev2sec257),
    [p. 674](ch25.xhtml#page_674) |'
  prefs: []
  type: TYPE_TB
- en: '| `persp` | Perspective plot | [Section 25.6.1](ch25.xhtml#ch25lev2sec258),
    [p. 680](ch25.xhtml#page_680) |'
  prefs: []
  type: TYPE_TB
