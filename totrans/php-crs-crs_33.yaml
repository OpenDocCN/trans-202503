- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 27 INTRODUCTION TO DATABASES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Databases are one of the ways computer systems can persistently store data so
    that it can be remembered when code runs at a later time. We’ll explore how to
    use PHP to work with databases over the next several chapters, starting in this
    chapter with database fundamentals. We’ll go over basic database terminology,
    look at how databases are structured, and consider the motivation for and benefits
    of connecting a web application to a database.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also discuss how a database fits with our coverage so far about web application
    architecture. You’ll learn how to map the contents of a database onto an object-oriented
    structure of classes and objects, and you’ll see how a database forms the backbone
    of the model component of the MVC architecture described in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*This book doesn’t aim to provide a comprehensive guide to relational database
    design, a complex field in its own right. Our focus will be on interacting with
    databases by using PHP. Some books for learning more about SQL and databases include*
    Practical SQL*, 2nd edition (2022), by Anthony DeBarros;* The Manga Guide to Databases
    *(2009) by Mana Takahashi; and* MySQL Crash Course *(2023) by Rick Silva, all
    from No Starch Press.*'
  prefs: []
  type: TYPE_NORMAL
- en: Relational Database Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The majority of modern database systems are *relational*, meaning they’re composed
    of a set of interrelated tables. Each table represents a type of entity. For example,
    a customer table might store information about the customers at an e-commerce
    site.
  prefs: []
  type: TYPE_NORMAL
- en: A table consists of columns and rows. Each column represents an attribute of
    the entity (for example, the customer table might have columns for a customer’s
    name, address, phone number, and so on). Each row represents a single instance
    of the entity (for example, an individual customer). Each row is also called a
    *record*.
  prefs: []
  type: TYPE_NORMAL
- en: The relationships between database tables are established through keys; each
    *key* is a unique identifier associated with one record in a table. Referencing
    one table’s keys from within another table creates a link between the two tables,
    while also avoiding duplication of data. Continuing our e-commerce example, each
    customer in our customer table could be given a *primary key* in the form of a
    unique customer ID number. Meanwhile, we might also have an invoice table for
    recording transactions, with a unique ID number for each invoice. Every invoice
    should be related to a single customer (the person who initiated the transaction),
    while each customer may be associated with multiple invoices, since a person can
    initiate multiple transactions.
  prefs: []
  type: TYPE_NORMAL
- en: We would establish this relationship by storing the customer ID associated with
    each invoice as a column in the invoice table, unambiguously associating each
    invoice with one—and only one—customer. In the context of the invoice table, the
    customer ID is known as a *foreign key*, since it connects to a field in a different
    table. Thanks to the foreign key, the invoice table doesn’t need to duplicate
    the name, address, and other information about the customer; we can simply look
    up those details in the customer table based on the customer ID assigned to a
    given invoice. This is the power of the relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a unique key to each row also helps maintain the correctness, or *integrity*,
    of the database. When database changes are being attempted, these keys act as
    links between data items in different tables. The system can ensure there’s an
    associated data item corresponding to a key referenced by another item in a different
    table. Rules can be established in the database to prevent new data from being
    created if it attempts to link to a nonexistent data item. For example, this might
    save a customer from being charged for a nonexistent invoice, or save an invoice
    from being assigned to a nonexistent customer. Other rules can be related to deletions
    of data, creating a warning or exception if we try to delete an item that other
    items are linked to.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the structure of a database’s tables, the relationships between the
    tables, and the rules governing data integrity are referred to as the *relational
    schema* for that database. Complex web applications often require several relational
    schemas that operate side by side. For example, one schema might be for the financial
    records of an organization, another for human resource details, and another for
    stock items and customer orders.
  prefs: []
  type: TYPE_NORMAL
- en: Database Management Systems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The software that creates, modifies, retrieves from, and stores a database
    is called a *database management system (DBMS)*. For a relational database, we
    sometimes refer more specifically to a *relational database management system
    (RDBMS)*. For the purposes of this book, we’ll focus on two (R)DBMSs: MySQL and
    SQLite. These are two of the most popular free and open source systems in use
    today.'
  prefs: []
  type: TYPE_NORMAL
- en: Some DBMSs run as server applications requiring usernames and passwords. They
    may run on the same computer system as the web application that uses them, or
    they may run on a completely independent internet server. MySQL is an example
    of a server-based DBMS. Other DBMSs, such as SQLite, are file-based, meaning the
    data is stored in files on the same computer as the web application. Server-based
    DBMSs like MySQL can work with multiple database schemas, whereas SQLite and most
    other file-based DBMSs store a single database schema in each file. One SQLite
    file might hold the financial records database, for example, another file could
    hold the human resource details database, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For a computer language like PHP to communicate with a particular DBMS, you
    need a *database driver*. This piece of software allows a program to communicate
    with a DBMS through its own standard protocol. For example, PHP has a driver for
    MySQL, a driver for SQLite, and other drivers for other DBMSs. The MySQL and SQLite
    PHP drivers may already be enabled on your system. If not, you’ll get driver errors
    when you try to run the code in the following chapters, and you may need to tweak
    the settings in your *php.ini* configuration file. See [Appendix B](appendix-b.xhtml)
    for instructions on setting up one or both of these database systems locally,
    or [Appendix C](appendix-c.xhtml) if you’re working in Replit.
  prefs: []
  type: TYPE_NORMAL
- en: When your PHP program needs to work with a DBMS, it uses a database *connection*
    at runtime. This connection is an active communication link between a computer
    program and a DBMS. To create a connection with a server-based database system,
    you must provide the host and port details, and usually the appropriate username
    and password authentication details as well. In some cases, a connection can be
    made directly to work with a particular database schema (for example, the human
    resource details schema); in other cases, a general connection is made to the
    DBMS, and either a new schema is created or the existing schema to be used is
    selected after the connection has been created. Once a connection has been established
    to work with a specific schema, the desired actions can be executed, which might
    include creating tables and relationships, inserting or deleting data, or retrieving
    data from the tables of the schema.
  prefs: []
  type: TYPE_NORMAL
- en: One key advantage of databases over other persistent storage methods such as
    files is that many DBMSs are designed to safely be used by multiple people simultaneously.
    Incorporating a database into a web application thus allows many people to interact
    with the application at the same time, while still ensuring the security and integrity
    of the system data. This is one area where server-based DBMSs like MySQL shine
    over file-based DBMSs like SQLite. While SQLite allows multiple simultaneous users
    to work on its file-based database, it locks the entire database file when a user
    is making changes. This is fine for local machine testing and development, but
    it would result in unacceptable delays for a fully deployed, real-world web application
    with heavy traffic. Systems such as MySQL can handle large numbers of concurrent
    connections, locking only single tables or even single database rows to minimize
    any interference with other users.
  prefs: []
  type: TYPE_NORMAL
- en: Server-based DBMSs also have the potential to be run as multiple instances,
    allowing multiple versions of both the web application and its database to help
    a system handle massive numbers of simultaneous users. Instances can be added
    and removed as needed to cope with a varying load of traffic over time. This technique
    is known as *load balancing*, and many cloud services implement it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Query Language
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The majority of modern RDBMSs are manipulated using Structured Query Language
    (SQL). SQL is designed to accomplish three key aspects of working with relational
    databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the structure of the related tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating the stored data (creating, updating, or deleting data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the data (searching the database, given criteria to match against)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 27-1 illustrates SQL statements for each of these kinds of actions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 27-1: Examples of SQL definition, manipulation, and querying statements'
  prefs: []
  type: TYPE_NORMAL
- en: The first SQL statement creates a product table and defines its structure. Each
    entry in this table will store the id, description, and price of a product. Each
    of these columns is given a data type (such as float for the price column), and
    the id column is designated as the table’s primary key, meaning each table entry
    should have a unique id value.
  prefs: []
  type: TYPE_NORMAL
- en: The second SQL statement demonstrates how to manipulate the data stored in the
    database; the statement deletes all entries from the product table that have a
    negative price. Finally, the third SQL statement is an example of a database query;
    it uses SELECT to request all the entries in the products table that have a price
    greater than 99.
  prefs: []
  type: TYPE_NORMAL
- en: Although SQL isn’t case-sensitive, it’s common practice to write SQL keywords
    like SELECT, FROM, and WHERE in all caps, and to use lowercase letters for table
    and column names as well as for strings forming a condition in a statement. Following
    this convention helps make SQL statements more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Databases and Web Application Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Databases naturally fit into the architecture of object-oriented web applications.
    Classes of objects can be written to closely map to the data items stored in database
    tables, and databases and their classes are the usual choice for the model (M)
    component in the MVC web application pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The class structure of OOP easily maps to relational database tables. A common
    and straightforward way to structure a web application working with a database
    is to design a class that corresponds to each table in the database. These *entity
    classes* have properties mirroring the table’s columns, and an instance of the
    class would correspond to a record (row) of the table.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to write data to a database table, we would first create an object
    of the appropriate class containing the new data, then use our database connection
    to send the object’s data to the database table. We can even send data back to
    that object; for example, if the database needs to choose a new unique key for
    the new record, this value can be sent back to the web application and stored
    in the corresponding object for future reference. Conversely, if we need to read
    a whole record out of a database table, we would read the retrieved data into
    a new object of the appropriate class, at which point the rest of the application
    can utilize the database data by accessing that object.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a web application (and its database) implementing products of various
    categories. We may have categories with names such as food, hardware, and furniture,
    and each product must be related to one of these categories. [Figure 27-1](#fig27-1)
    shows the database’s relational schema. This kind of diagram is called an *entity-relationship
    (ER) model*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure27-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 27-1: An ER diagram showing related Product and Category entities'
  prefs: []
  type: TYPE_NORMAL
- en: Our database will have a Product table containing an entry for each product
    as well as a Category table with the possible categories the products can fall
    into. The line connecting the tables illustrates how entries from these tables
    can relate. The 1 at the Category end of the connecting line expresses the relationship
    “each product is associated with precisely one category.” The crow’s foot link
    and asterisk (*) at the Product end expresses the relationship “each category
    is associated with zero, one, or more products.”
  prefs: []
  type: TYPE_NORMAL
- en: Each record in the Category table will have a unique integer id property (a
    primary key) and a text description. [Table 27-1](#tab27-1) shows sample entries
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 27-1: Example Rows for the Category Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| id (primary key) | name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | "food" |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | "hardware" |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | "furniture" |'
  prefs: []
  type: TYPE_TB
- en: Every record in the Product table will similarly have a unique integer id property
    as a primary key, along with a text description and a float price. Each product
    will also be related to exactly one category via the category_id column, which
    will store a reference to the key for one of the records in the Category table.
    Again, this is known as a *foreign key*. [Table 27-2](#tab27-2) shows example
    rows for the Product table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 27-2: Example Rows for the Product Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| id (unique key) | description | price | category_id |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | "peanut bar" | 1.00 | 1 (food) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | "hammer" | 9.99 | 2 (hardware) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | "ladder" | 59.99 | 2 (hardware) |'
  prefs: []
  type: TYPE_TB
- en: We can easily map our database tables to object-oriented classes. [Figure 27-2](#fig27-2)
    shows the corresponding class diagram for Product and Category. Notice that this
    UML diagram is essentially the same as the ER model from [Figure 27-1](#fig27-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure27-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 27-2: A class diagram of the related Product and Category classes'
  prefs: []
  type: TYPE_NORMAL
- en: Each class has properties for all the columns of its corresponding database
    table; for example, the Product class has id, description, price, and category
    properties. Each Product object will be related to exactly one Category object
    via its category property, which will store a reference to a Category object.
    Notice that this is the main difference between our class structure and our database
    structure. In the Product database table, the category_id column simply stores
    the integer ID of the related category, whereas with our classes we can store
    a reference to a complete Category object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 27-3](#fig27-3) shows the objects that will be created when we read
    the sample database rows from [Tables 27-1](#tab27-1) and [27-2](#tab27-2) into
    our web application.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure27-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 27-3: Connecting Product objects to Category objects'
  prefs: []
  type: TYPE_NORMAL
- en: We end up with three Product objects, linked to their corresponding Category
    objects. Notice that each Product object is associated with only one Category
    object. In contrast, a Category object can be related to zero, one, or many Product
    objects, since at a given point we may have no products for some categories, perhaps
    just one product, or more.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller Pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In previous chapters, we’ve discussed the MVC software architecture, which assigns
    the various tasks required for operating a web application to different parts
    of the system. We’ve focused primarily on how a templating library like Twig provides
    the view component of MVC, preparing content to be displayed to the user, and
    on how a front controller and other specialized controller classes provide the
    controller component, making decisions about how to respond to each user request.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve said little so far about the model part of this architecture, the actual
    data that underlies the web application. This is where a database comes in. It
    stores the data in an organized format and serves it up or modifies it when prompted
    by the controller classes. The classes corresponding to the database tables are
    part of the model component of the application as well. [Figure 27-4](#fig27-4)
    illustrates the database’s place in the MVC web application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure27-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 27-4: The MVC architecture, highlighting the model component'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the action controller classes communicate with (read from and modify)
    the *model classes*. As you’ll learn in the following chapters, these are the
    object-oriented classes that communicate with the database. All database interactions
    are kept completely separate from the controller and view components of the application.
    This compartmentalization means that we could change the underlying database (from
    a file-based DBMS to a server-based DBMS, for example) without having to make
    any changes to the front controller, the action controller classes, or the templates.
  prefs: []
  type: TYPE_NORMAL
- en: '### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the concept of databases, especially SQL-based
    relational databases, and considered some of the advantages of adding databases
    to web applications. We also explored how databases fit into web application architecture,
    including how databases are the heart of the MVC pattern’s model component. We
    observed the close mapping among the tables, columns, and rows of a relational
    database and the classes, properties, and instances used in OOP. With this introduction,
    you’re now ready for the remaining chapters in the book, where you’ll learn to
    use PHP to connect to, create, modify, and retrieve data from MySQL and SQLite
    relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Read up on some of the history of databases in the phoenixNAP article “What
    Is a Database?” by Milica Dancuk (*[https://phoenixnap.com/kb/what-is-a-database](https://phoenixnap.com/kb/what-is-a-database)*).
  prefs: []
  type: TYPE_NORMAL
- en: 2.   DB Fiddle (*[https://www.db-fiddle.com](https://www.db-fiddle.com)*) is
    a great online resource for practicing SQL statements and designing a database.
    You can create and populate tables, query them, and view the results. Try using
    DB Fiddle to implement the Product and Category database tables discussed in this
    chapter. Insert the three rows of sample data for each database table (see [Tables
    27-1](#tab27-1) and [27-2](#tab27-2)), then run queries to select the data from
    each table.
  prefs: []
  type: TYPE_NORMAL
