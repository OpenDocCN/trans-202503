- en: Displays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AN LCD Reminder**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll connect a character LCD to your Raspberry Pi to display
    a scrolling reminder message. You’ll start by displaying static text for short
    messages and then learn how to display scrolling text ideal for longer messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: 16×2 Hi tachi HD44780-compatible LCD
  prefs: []
  type: TYPE_NORMAL
- en: 10 kΩ potent iometer
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit_CharLCD library
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE LIQUID CRYSTAL DISPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest and cheapest display screen around is the *liquid crystal display
    (LCD)*. LCDs are found in everyday electronics devices like vending machines,
    calculators (see [Figure 6-1](ch06.xhtml#ch06fig1)), parking meters, and printers,
    and are ideal for displaying text or small icons.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0086-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-1:** Calculator with an LCD'
  prefs: []
  type: TYPE_NORMAL
- en: LCDs are measured according to the number of rows and columns of characters
    that fit on the screen. A 16×2 LCD can display 2 rows of 16 characters each. You’ll
    find sizes ranging from 8×1 to 40×4.
  prefs: []
  type: TYPE_NORMAL
- en: LCDs also vary in background color. You can find a wide variety of background
    colors, including RGB background lights that let you create any color.
  prefs: []
  type: TYPE_NORMAL
- en: The most common LCD modules use the Hitachi HD44780 chip, which allows you to
    use custom characters. [Figure 6-2](ch06.xhtml#ch06fig2) shows a standard 16×2
    Hitachi HD44780–compatible LCD; we recommend using this type for this project.
    Most 16×2 screens will be compatible, but before you buy one, check the part’s
    data sheet just to be safe. You can also use 20×4 LCDs as long as they are Hitachi
    HD44780–compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0086-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-2:** A standard 16×2 Hitachi HD44780–compatible LCD'
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely at [Figure 6-2](ch06.xhtml#ch06fig2), you’ll see 32 rectangles
    made of 5×8 pixels. The combination of on and off pixels is what makes up the
    character shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Soldering the Headers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: More likely than not, your LCD module will come with the header pins separate,
    as shown in [Figure 6-3](ch06.xhtml#ch06fig3). You’ll need to solder the pins
    to your module to make it breadboard-friendly. Put the pins in the available holes—there
    should be 16 pins for 16 holes—with the long end pointing down and solder them
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0087-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-3:** LCD with separate header pins'
  prefs: []
  type: TYPE_NORMAL
- en: '**The LCD Module Pinout**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LCD module pins are numbered from 1 to 16, from left to right when the
    pins are above the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **PIN** | **SYMBOL** | **DESCRIPTION** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | VSS | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | VDD | Power supply |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | V0 | Contrast adjustment |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | RS | Register selection |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | R/W | Read/Write selection |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | E | Enable |'
  prefs: []
  type: TYPE_TB
- en: '| 7–14 | DB0–DB7 | Data pins |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | LEDA | Backlight anode (5V) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | LEDK | Backlight cathode (–) |'
  prefs: []
  type: TYPE_TB
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Raspberry Pi GPIOs are designed for 3.3 V, but most LCDs are 5 V. This
    isn’t a problem as long as you’re only sending data out of the Pi and not reading
    data from the screen to the Pi. With a 5 V screen,* do not connect the R/W pin
    of the display to the Pi. *This pin sends data at 5 V, and it will very likely
    fry your Pi!*'
  prefs: []
  type: TYPE_NORMAL
- en: VSS is a ground pin and should be connected to GND. VDD is a power pin and should
    be given 5 V or 3.3 V depending on the type of LCD you are working with; most
    require 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: V0 allows you to adjust the contrast between the characters and the backlight
    when the LCD is connected to a potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: RS, R/W, and E are control pins. When using the screen to display text only,
    as in this project, you should permanently connect R/W directly to ground; in
    other words, you’ll only be writing to the LCD and not reading from it.
  prefs: []
  type: TYPE_NORMAL
- en: Pins 7 to 14 are data pins, used to send information. Pins 15 and 16 are the
    anode and cathode for the backlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the LCD module has 16 pins, you need only 6 of them to communicate with
    your Raspberry Pi: 4, 6, 11, 12, 13, and 14.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING YOUR CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that your LCD is ready to use, you can start building this project’s circuit.
    Follow these steps to wire the LCD and Pi, using the circuit diagram in [Figure
    6-4](ch06.xhtml#ch06fig4) for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the breadboard power rails to 5 V and GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To power the LCD, connect 5 V from the power rails to LCD pin 2 (VDD) and to
    LCD pin 15 (LEDA). Connect LCD pin 1 (VSS), pin 5 (R/W), and pin 16 (LEDK) to
    the GND rail on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a potentiometer to adjust the contrast: connect one of the outer leads
    to the GND and the other outer lead to 5 V, and then connect the middle lead to
    LCD pin 3 (V0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Pi’s GPIO pins as shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LCD** | **RASPBERRY PI** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4 (RS) | GPIO 27 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 (E) | GPIO 22 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 (DB4) | GPIO 25 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 (DB5) | GPIO 24 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 (DB6) | GPIO 23 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 (DB7) | GPIO 18 |'
  prefs: []
  type: TYPE_TB
- en: '![image](../images/f0089-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-4:** LCD wired to the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re finished wiring, try adjusting the LCD contrast by rotating the
    potentiometer; you should see the backlighting change. If the contrast doesn’t
    change, double-check the wiring before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can write the script to display messages on the LCD, you need to
    install the Python library for a character LCD, Adafruit_CharLCD. This library
    features a lot of functions that make it easy to control the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing the Python Library for a Character LCD**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go to the Raspberry Pi desktop taskbar and open the terminal. Before installing
    the Adafruit_CharLCD library, you need to install the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When prompted, type y and press ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the desktop, create a folder called *Libraries*, and change directory
    to the newly created folder with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the installation files by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the *Adafruit_Python_CharLCD* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the following command to install the Adafruit_CharLCD library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You successfully installed the Python library for a character
    LCD. We encourage you to navigate through the *Examples* folder and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying a Character Message**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go to your *Projects* folder and create a new folder called *Displays*. Open
    **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new script.
    Then, enter the following code into the Python Editor and save the script as *character_lcd.py*
    (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You start by importing the previously installed character LCD library at ➊.
    Then, at ➋ you configure your Pi pins. At ➌, you define your LCD size. If you’re
    using a 20×4 LCD, you need to change those two lines of code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the LCD is initialized ➍, and you write your message inside the
    function `lcd.message('`string`')` between the single quotes ➎. The `\n` escape
    character tells the LCD to display the text that follows on the next line. Feel
    free to change this message to anything you like!
  prefs: []
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script, and your LCD
    should display the text, as in [Figure 6-5](ch06.xhtml#ch06fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0091-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-5:** Your circuit displaying a static message'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Other Functionality**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s worth knowing a few other useful functions you can use for more than just
    displaying text; you may want to set the cursor to a certain position or clear
    the display in preparation for new messages, for example. The library you’ve installed
    provides the following functions for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lcd.message(`string`)` displays the message written between brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.clear()` clears the display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.show_cursor(`boolean`)` shows the cursor after the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.blink(`boolean`)` shows a blinking cursor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.move_right()` moves the displayed message one character to the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.move_left()` moves the displayed message one character to the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.home()` sets the cursor to the first column and first row (0,0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd.set_cursor(int, int)` sets the cursor to the specified column and row.
    For example, `lcd.set_cursor(2, 1)` sets the cursor to the third column and second
    row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data types shown in italic tell you what kind of value you need to enter
    as an argument; for example, in place of boolean you’d enter `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scrolling a Reminder Message**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This LCD screen is pretty small, so you’ll get stuck if you try to display messages
    longer than 32 characters. So, now we’ll show you how to write a script to display
    a longer message that scrolls across the screen, like a reminder for a doctor
    appointment you can’t miss. In the first row, you’ll have a title for your message,
    like “Reminder” or “Don’t forget,” and in the second row your reminder message
    will scroll by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Displaying a scrolling message is not as straightforward as showing a static
    message, so let’s think about what we want to happen before we write our code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first row displays a static title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second row displays a scrolling message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scrolling message moves from right to left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The characters should appear from the rightmost column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The characters should disappear at the leftmost column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The message scrolls forever until stopped. Inside the *Displays* folder, create
    a new script with **Python 3 (IDLE)** called *scrolling_text.py* and enter the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You’re already familiar with importing the Adafruit_CharLCD library, configuring
    the Raspberry Pi pins, defining the screen size, and initializing the LCD.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you also need to import the time library ➊ to use functions
    related to time. At ➋ and ➌, you assign the text that will be displayed as the
    title and reminder messages, respectively. The `delay` ➍ will be the time a character
    stays in one place before moving one character to the left. In this case, you
    set the delay to `0.3` seconds; the lower the delay, the faster the text will
    scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➎, you create a function called `scroll_message(``*string*, *float*)` that
    accepts two parameters: a string that will be your `reminder` and a float that
    will be the `delay`. Inside the function you start by creating a `padding` variable
    that consists of a blank character multiplied by the number of columns your LCD
    has. This will fill all your character slots initially with a blank square variable,
    creating the illusion that characters are appearing gradually. Then you create
    a new variable called `reminder_message` that is the concatenation of the `padding`,
    the `reminder`, and one blank space. You need to add this extra blank space to
    create the disappearing effect of the `reminder_message`.'
  prefs: []
  type: TYPE_NORMAL
- en: The function goes through a `for` ➏ loop from `0` to the length of the `reminder_message`.
    The function `len(`object`)` returns the length of an object—in this case, the
    number of characters in the `reminder_message` string, which tells us how many
    times to loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python uses* zero-based indexing, *which means that indexes start counting
    at zero. For instance, the first character of a string has index `0`.*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, the code starts by setting the cursor to the first column,
    second row, where you want to start displaying your reminder. In the next line,
    `reminder_message[i:(i+lcd_columns)]` truncates your `reminder_message`, returning
    the characters from index `i` to index number `i+lcd_columns` exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the loop runs, you will display a different part of your message;
    this is what actually creates the scrolling effect (see [Figure 6-6](ch06.xhtml#ch06fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0094-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-6:** Truncating a string to make a scrolling effect'
  prefs: []
  type: TYPE_NORMAL
- en: After displaying the full message, the code waits the number of seconds assigned
    in the `delay` variable.
  prefs: []
  type: TYPE_NORMAL
- en: At ➐, you clear the screen and display the `title` message from the first column,
    in the first row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at ➑, you create a `while` loop that is always `True`. This is a little
    trick to make something run forever and ever. Inside that loop you call the function
    `scroll_message(``*string*, *float*)` with your own arguments: `reminder` and
    `delay`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Unfortunately,
    we can’t show the text moving in a book, but you get the idea!
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We recommend that you modify the sample script we’ve given you with the coding
    tricks you’ve learned here and earlier, and experiment with the functions shown
    in [“Adding Other Functionality”](ch06.xhtml#lev71) on [page 91](ch06.xhtml#page_91)
    to get familiar with the LCD. When you’re done, here are some projects to try:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a weather forecaster using the LCD display—take a look at [Project 7](ch07.xhtml#ch07),
    in which we show how to get weather data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display messages based on weather conditions, like “Don’t forget your umbrella.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display sensor data on the LCD—check out [Projects 9](ch09.xhtml#ch09)–[12](ch12.xhtml#ch12)
    to learn how to read data from a sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mini Weather Forecaster**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’re going to build a weather forecaster that displays the
    day’s weather for your location on an OLED display. You’ll learn how to make API
    requests, which are really useful for projects that rely on frequently updated
    data, and how to use an OLED display.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0097-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: 0.96-inch OLED display
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit_SSD1306 library
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE OLED DISPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *organic light-emitting diode (OLED)* display this project uses is the
    SSD1306 model: a monocolor, 0.96-inch display with 128×64 pixels, shown in [Figure
    7-1](ch07.xhtml#ch07fig1). Compared to the LCD, which has a reserved space of
    5×8 pixels for each character, the OLED display is much more versatile. It allows
    you to choose which pixels are on and off, enabling you to produce custom text
    and images anywhere in the display. The OLED display also doesn’t require backlight,
    which results in a very nice contrast in dark environments. Additionally, its
    pixels consume energy only when they are on, so the OLED display consumes less
    power than an LCD.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0098-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-1:** The SSD1306 0.96-inch monocolor OLED display'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some OLED displays use SPI communication instead of I²C—these will come with
    a different set of pins. Make sure you check the pin layout before purchasing
    your OLED display.*'
  prefs: []
  type: TYPE_NORMAL
- en: This OLED display generally has four pins, GND, VCC, SCL, and SDA (see [Figure
    7-1](ch07.xhtml#ch07fig1)), though you may find that some models come with an
    extra reset pin. Some displays may come with the pins in a different order as
    well—VCC, GND, SCL, SDA—so just pay attention to the labels as you follow this
    project’s instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The OLED display in [Figure 7-1](ch07.xhtml#ch07fig1) uses the Inter-Integrated
    Circuit (I²C) communication protocol to communicate with the Raspberry Pi, for
    which you need the SDA and SCL pins (GPIO 2 and GPIO 3, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '**USING THE OPENWEATHERMAP API**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application programming interface (API) is a set of functions written by
    software developers to enable anyone to use their data or services. For example,
    the OpenWeatherMap project (*[https://openweathermap.org/](https://openweathermap.org/)*)
    has an API that enables users to request weather data using many different programming
    languages. In this project you’ll use that API to request the day’s weather forecast
    for your chosen location. Learning to use APIs with your Pi is a great skill because
    it allows you access to a wide variety of constantly changing information, such
    as current stock prices, currency exchange rates, the latest news, traffic updates,
    tweets, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenWeatherMap’s free plan provides everything you need to complete this project.
    To use the API you need an API key, known as the *APIID*. To get an APIID:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser and go to *[https://openweathermap.org/appid/](https://openweathermap.org/appid/)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Sign up** button and create a free account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll be presented with a dashboard that contains several tabs. Select the
    **API keys** tab, as shown in [Figure 7-2](ch07.xhtml#ch07fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0099-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 7-2:** API keys on OpenWeatherMap'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the API keys tab, you’ll see a default key (shown in [Figure 7-2](ch07.xhtml#ch07fig2));
    this is a unique key you’ll need to pull information from the site. Copy and paste
    this key somewhere; you’ll need it in a moment. You can create a new key for each
    separate project if you like, but if you aren’t familiar with using APIs, we’d
    recommend just using the default key provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To pull information on weather in your chosen location, enter the following
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**WARNING**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*APIs are unique to the user and shouldn’t be shared with anyone. In this case,
    whoever has your API key can only request the weather, but if you were using social
    media APIs, for example, you could run into security issues—like strangers getting
    access to your personal information. Don’t share your API keys with anyone.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace your_city with the city you want data for, your_country_code with the
    country code for that city, and your_unique_API_key with the unique API key from
    step 4\. For example, the updated API URL for the town of Porto, Portugal, would
    be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy your URL into your browser, and the API will return a bunch of information
    corresponding to your local weather. [Listing 7-1](ch07.xhtml#ch07list1) shows
    the weather in Porto, Portugal, on the day we wrote this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LISTING 7-1:** The API response'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*More information on using the API to get weather information is available
    at* [https://openweathermap.org/current](https://openweathermap.org/current).'
  prefs: []
  type: TYPE_NORMAL
- en: This may not look like much now, but next you’ll see how to organize this data
    with tabs and paragraphs to make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding JSON Syntax**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you can see, the weather data for your chosen location is stored in a specific
    way, with symbols like `{}[] : ""` and `,`. This syntax is *JavaScript Object
    Notation (JSON)*, a standard for exchanging data in a way that’s convenient for
    computers. In JSON syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is represented in name/value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each name is followed by a colon ( `:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name/value pairs are separated with commas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curly brackets hold objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Square brackets hold arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.xhtml#ch07list2) shows how you can organize the API information
    so it’s easier to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 7-2:** The API JSON information rearranged for a clearer structure'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you can more easily see all the different kinds of information the API provides.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making an API Request**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you have a URL that returns your local weather data. To show you how to
    access the information using Python, we’ll give you an example.
  prefs: []
  type: TYPE_NORMAL
- en: The simple code snippet in [Listing 7-3](ch07.xhtml#ch07list3) requests the
    current maximum temperature in Kelvin for Porto, Portugal, and prints it in the
    Python shell. Replace our URL with your own, and you’ll get the same information
    for your chosen location.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 7-3:** Requesting maximum temperature'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At ➊, you import the requests library, which is essential for making API requests.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋, you create a variable called `weather_data` in which you store the data
    returned after the API request. To make an API request for information, you use
    the command `requests.get('`your_url`')`, with your URL as the argument inside
    single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌, you create the `temp_max` variable to hold the particular data you’re
    requesting. In this case, you want the maximum temperature.
  prefs: []
  type: TYPE_NORMAL
- en: To get that value, you first convert the `weather_data` variable to JSON with
    the `.json()` method. Then, using the `.get()` method, you access the `temp_max`
    variable, which contains the maximum temperature value. You can see in [Listing
    7-2](ch07.xhtml#ch07list2) that `main` is the top-level parent of the data you
    want to access, `temp_max`, so you need to get through `main` first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, to access the wind speed you enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You need to go through the parent of `speed`, which is `wind`, to request the
    information about wind speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to get the city name, you enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After learning how to make API requests in Python, you’re ready to start this
    project!
  prefs: []
  type: TYPE_NORMAL
- en: '**THE REQUESTS LIBRARY**'
  prefs: []
  type: TYPE_NORMAL
- en: The requests library, also called “HTTP for Humans,” is an Apache2- licensed
    Python library used to send *hypertext transfer protocol (HTTP)* requests. This
    powerful library makes it simple to connect to web servers via HTTP. This capability
    allows you to easily request information from any web page, as you’ve been doing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply wire the OLED display to the Pi according to the pinout shown in the
    table. Remember that the pin order may be different on some models, so follow
    the pin labels.
  prefs: []
  type: TYPE_NORMAL
- en: '| **OLED DISPLAY** | **RASPBERRY PI** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| VCC | 3.3 V |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| SDA | GPIO 2 (SDA) |'
  prefs: []
  type: TYPE_TB
- en: '| SCL | GPIO 3 (SCL) |'
  prefs: []
  type: TYPE_TB
- en: '| RST (if existent) | GPIO 24 |'
  prefs: []
  type: TYPE_TB
- en: Check your circuit against [Figure 7-3](ch07.xhtml#ch07fig3) and then move on
    to the software.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0103-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-3:** Wiring the OLED display to the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you enter the script, you need to install the Adafruit_SSD1306 library
    to use the OLED with the Raspberry Pi. This library makes it simple to write text
    and draw images on the display. You’ll also need to enable I²C communication so
    the OLED and Pi can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing the Library for the OLED Display**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you haven’t done so already, create a folder called *Libraries* on your
    Desktop. Then, open the terminal and navigate to the *Libraries* folder on your
    Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the OLED library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Adafruit_Python_SSD1306 library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Enabling I²C Communication**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The OLED communicates with the Pi using the I²C communication protocol, so you
    need to enable I²C communication on your Pi. Go to the Desktop main menu and select
    **Preferences** ▸ **Raspberry Pi Configuration**. In the Interfaces tab, enable
    I²C, as shown in [Figure 7-4](ch07.xhtml#ch07fig4), and press **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0104-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-4:** Enabling I²C communication'
  prefs: []
  type: TYPE_NORMAL
- en: '**I²C COMMUNICATION PROTOCOL**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I²C*, or *Inter-Integrated Circuit*, is a communication protocol that allows
    communication between multiple *slave* integrated circuits and one master chip.
    The slaves are the devices that respond to the master. The master chip can communicate
    with all slaves, but a slave can only communicate with the master. Both the slave
    and master can transfer data, but that transfer is always controlled by the master.
    In this case, the Raspberry Pi is the master chip and the OLED integrated circuit
    is the slave. The Raspberry Pi supports I²C communication in its GPIO pins through
    the SDA and SCL pins. The biggest advantage of using this communication protocol
    is that you can connect more than one device via I²C using just the SDA and SCL
    pins—no need to use additional pins on the header.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the code shown in [Listing 7-4](ch07.xhtml#ch07list4) to the Python
    Editor and save the script as *weather_forecast.py* inside the *Displays* folder
    (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 7-4:** The *weather_forecast.py* script'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As usual, your code starts by importing the required libraries ➊. The Adafruit_SSD1306
    library contains the OLED display driver classes. From the Python Imaging Library
    (PIL) you import three modules—`Image`, `ImageDraw`, and `ImageFont`—to create
    an image with the text that you’re going to display on the OLED.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OLED LIBRARIES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Adafruit_SSD1306 library refers to everything shown on the OLED display
    as an “image”—even text. The three modules you’re using here have the following
    roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Image creates a new image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageDraw draws the text or icons inside the image and shows what you’ll see
    on the actual OLED display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageFont sets the text font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initializing the OLED Display**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even if your display doesn’t have a reset pin, you need to set the `RST` pin
    in your code. If your display does have a reset pin, it should be connected to
    GPIO 24\. So, in either case, you set `RST` to `24` here ➋.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌, you create a class for your display. For a 128×32 display, create the
    class `SSD1306_128_32`; for a 128×64 display, create the class `SSD1306_128_64`.
    We’ve given both options in the code so you can just uncomment the line that matches
    your display size and comment out the other.
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, you initialize the display library and prepare the display so that you
    can draw text on it. We’ve commented the code heavily to help you understand the
    purpose of each line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the API Request**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➍, you create a variable called `open_weather_map_url` to hold the API URL.
    Make sure to update this line with your own API URL.
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, you make the API request, after which there are several blocks of code
    that work similarly. We’ll explain the one at ➐, and then you’ll be able to follow
    what the rest are doing. You create a variable, `location`, to get the location.
    This variable is a concatenation of several strings. First, you get the location
    using `weather_data.json().get('name')`, which in this example returns `Porto`.
    You add a hyphen by using `+ ' - '` and then the country code using `weather_data.json().get('sys').get('country')`;
    in this example, it returns `PT`. So, the `location` variable returns `Porto –
    PT`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Text on the OLED Display**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To draw text on the display, you use the `draw.text()` function, which takes
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: x and y coordinates  Where the text starts being drawn
  prefs: []
  type: TYPE_NORMAL
- en: text  The text to display
  prefs: []
  type: TYPE_NORMAL
- en: font  The font the text will appear in
  prefs: []
  type: TYPE_NORMAL
- en: fill  The pixel brightness—255 is the maximum
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to display the location on the top line of the OLED forecaster,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `x` and `top` coordinates were defined at ➎. This example uses the default
    library font, though you should feel free to explore other fonts by downloading
    the font files and modifying the code.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks of code to display the weather description, temperature, pressure,
    humidity, and wind are all similar. Note that you need to increment the `to`p
    variable to draw text on the next line of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the lines of code at ➑ display the image on the OLED. The delay time
    at the end determines how fast the loop updates the weather information—in this
    case, every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Congratulations,
    now you have a tiny weather forecaster that will give you constantly updated data
    on the weather in your chosen location!
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use APIs to get way more information than just the weather. With your
    favorite search engine, enter a query like *free API for <thing>* to find an API
    you can access. Here are some ideas to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: Traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latest news
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current Bitcoin exchange rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pong with a Sense HAT**
  prefs: []
  type: TYPE_NORMAL
- en: Here you’ll build your own LED Pong game using the Sense HAT. The Sense HAT
    is an add-on board for your Pi that gives it a lot more functionality through
    extra features like an LED matrix, joystick, and several sensors that get information
    from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0111-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi (versions with 40 GPIOs)
  prefs: []
  type: TYPE_NORMAL
- en: Sense HAT
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the Sense HAT’s LED matrix to display the game and the joystick
    to play. If you don’t have the hardware, not to worry: you’ll also learn how to
    use the Sense HAT emulator to create the same game without it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING PONG**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the first video games ever created, Pong is an immensely popular 2D
    table-tennis (ping-pong) game that can be played in single- or double-player mode.
    You’re going to create the single-player version, so it’s more like playing squash:
    you bounce the ball against the walls with your bat and catch it with the bat
    when it comes back. If you miss the ball, you lose.'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE RASPBERRY PI SENSE HAT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi Sense HAT features an 8×8 RGB LED matrix, a five-button joystick,
    a gyroscope, an accelerometer, a magnetometer, a temperature sensor, a barometric
    sensor, and a humidity sensor in one package, shown in [Figure 8-1](ch08.xhtml#ch08fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0112-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-1:** Raspberry Pi Sense HAT'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting the Board**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Sense HAT is not compatible with Raspberry Pi 1 Model A and B, but you
    can build the project using the emulator if you have an incompatible board.*'
  prefs: []
  type: TYPE_NORMAL
- en: This project doesn’t require much hardware assembly—you just need to mount the
    Sense HAT on the Pi, and the rest is done in code.
  prefs: []
  type: TYPE_NORMAL
- en: Attach the 40 GPIOs on the Sense HAT to the 40 GPIOs on your Raspberry Pi; the
    boards should line up perfectly. When you first successfully mount the Sense HAT
    on a powered Pi, the LED matrix displays an illuminated rainbow background as
    shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0113-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-2:** Sense HAT welcome rainbow'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Sense HAT Emulator**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t have a Sense HAT or a compatible board, or if you just want to
    test the script first, you can use the Sense HAT emulator to build the Pong game
    on your computer. The emulator is a virtual Sense HAT that you can interact with
    to test your scripts. To launch it from the Desktop main menu, go to **Programming**
    ▸ **Sense HAT Emulator**. This opens the emulator window, shown in [Figure 8-3](ch08.xhtml#ch08fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0113-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-3:** Sense HAT Emulator window'
  prefs: []
  type: TYPE_NORMAL
- en: The Sense HAT emulator comes with examples stored in **File** ▸ **Examples**;
    just select the example you want and then run the file to see the code in action
    in the emulator window.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH SENSE HAT FUNCTIONS AND CONTROLS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you go right into building the game, it’s important to understand how
    to control the LED matrix and read inputs from the joystick. Let’s look at some
    examples that you’ll use later in the Pong script.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling the LED Matrix**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Sense HAT LED matrix has 8 columns and 8 rows, containing a total of 64
    RGB LEDs. You can display text and create images on the matrix by controlling
    each LED individually. You can also set the color of each LED.
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying Text**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code in [Listing 8-1](ch08.xhtml#ch08list1) displays the scrolling text
    “Hello World!” in blue on the dot matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 8-1:** Display text on the Sense HAT LED matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First import the `SenseHat` class ➊. If you’re using the emulator, delete or
    comment out this line and uncomment the code at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_message()` function ➌ accepts the message to display—a text string—as
    the first parameter, and then takes several options as further parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The sense_hat library uses the British spelling “colour,” so you must use
    “colour” throughout your code.*'
  prefs: []
  type: TYPE_NORMAL
- en: Use `text_colour = [*r*, *g*, *b*]` to set the RGB color of the text, replacing
    `*r*, *g*, *b*` with integers between `0` and `255` (as you did in [Project 5](ch05.xhtml#ch05)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `scroll_speed = *x*`, where x is a float, to control the speed at which
    text moves across the display. The default scrolling speed is set to pause for
    0.1 seconds each time the text shifts one pixel to the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `back_colour = [*r*, *g*, *b*]` to set the background color, replacing `*r*,
    *g*, *b*` with integer values as with `text_colour`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controlling Specific LEDs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To control individual LEDs, you refer to each LED you want to light by its position
    in the matrix. For that, the Sense HAT uses an (x, y) coordinate system. For example,
    the LEDs in [Figure 8-4](ch08.xhtml#ch08fig4) have the coordinates listed next
    to the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0115-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-4:** Sense HAT coordinate system'
  prefs: []
  type: TYPE_NORMAL
- en: To light up the LEDs in [Figure 8-4](ch08.xhtml#ch08fig4) with their corresponding
    colors, you’d use the code in [Listing 8-2](ch08.xhtml#ch08list2).
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 8-2:** Using `set_pixel()` to light particular LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The function `sense.set_pixel(*x*, *y*, *r*, *g*, *b*)` lights up a specific
    LED, in which x is the x-coordinate; y is the y-coordinate; and r, g, and b set
    the color.
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying a Picture**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rather than controlling individual LEDs, you can use the function `sense.set_pixels()`
    to more quickly display an image. Instead of entering coordinates, you insert
    a list for all 64 LEDs that determines the color of each LED. Take a look at the
    code in [Listing 8-3](ch08.xhtml#ch08list3), which displays a sad face.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 8-3:** Displaying an image with `set_pixels()`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The red Xs in the `sad_face` array won’t appear red in your code. We’re just
    highlighting them so it’s easier to visualize how the LEDs will look.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a variable to store the color of the lit LEDs (`X`), and a variable
    to store the color of the background (`N`)—you can set the background to any color
    or set it to `0` to keep it unlit. Then you need to create an array that sets
    each of the 64 LEDs either to `X` or to `N`. [Figure 8-5](ch08.xhtml#ch08fig5)
    shows the end result of the code in [Listing 8-3](ch08.xhtml#ch08list3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0116-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-5:** Displaying a sad face on the LED matrix'
  prefs: []
  type: TYPE_NORMAL
- en: You can include as many colors as you want in your drawing; you just need to
    change the color parameters. We encourage you to practice working with the LED
    matrix by changing the colors and drawing your own images.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to control the LED matrix, let’s look at how to program
    the joystick.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Data from the Joystick**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The joystick that comes with the Sense HAT has five control options:'
  prefs: []
  type: TYPE_NORMAL
- en: Move up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to tell your program what each control option should make the Pi do.
    The script in [Listing 8-4](ch08.xhtml#ch08list4) sets the events associated with
    each joystick control, and displays a message on the computer screen saying which
    control was used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 8-4:** Associating events with each joystick control'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, you need to tell your Pi what action to take when each joystick control
    is triggered. You do that by defining a series of functions to perform actions.
    For example, when the joystick is moved up, you call the function `move_up()`
    ➊ to print the message `joystick was moved up`. The `event` argument tells the
    Pi that the joystick will be sending information to those functions. Then you
    use `sense.stick.direction_up = move_up` ➋ to associate the `move_up` function
    with the up movement of the joystick.
  prefs: []
  type: TYPE_NORMAL
- en: The other movement functions work in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to display text and drawings on the LED matrix and how
    to make something happen when the joystick is used, you’re ready to start writing
    the script for your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the game aims to do:'
  prefs: []
  type: TYPE_NORMAL
- en: A bat that is 3 pixels long and 1 pixel wide should appear in column 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time you move the joystick up or down, the bat should move correspondingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ball should start in a random position and move diagonally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ball hits something—walls, ceiling, or the bat—it should move diagonally
    in the opposite direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ball hits column 0, it means you missed the ball, so you lose and the
    game is over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entering the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new script.
    Then copy the code in [Listing 8-5](ch08.xhtml#ch08list5) to the new file and
    save the script as *pong_game.py* inside the *Displays* folder (remember that
    you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 8-5:** The Pong game code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot going on in this code. Let’s walk through it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Necessary Libraries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➊, you import the `randint()` function from the rand library to generate
    pseudorandom integers and the `sleep()` function from the time library to set
    delay times.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋, you create an object called `sense` that will be used to refer to the
    Sense HAT throughout the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Bat**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The bat is a 3-pixel bar that moves up and down the leftmost column. At ➌, you
    define the bat’s starting position at 4 pixels down from the top with `y = 4`.
    The complete bat is drawn in green within the `draw_bat()` function ➏, which adds
    one more pixel to the top of the starting position (`y - 1`) and to the bottom
    (`y + 1`) to make the bat 3 pixels long.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving the Bat**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The bat moves just on the y-axis, so its x-coordinate is always `0`, but its
    y-coordinate needs to change as the player moves the bat. In other words, the
    player can only move the bat up and down. The `move_up()` and `move_down()` functions,
    defined at ➐, control those movements. At ➒, you tell the Pi what action to take
    when the player moves the joystick up or down by calling `move_up()` and `move_down()`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a closer look at the `move_up()` function (the `move_down()` function
    works in a similar way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `move_up()` function accepts `event` as a parameter. Basically, the `event`
    parameter allows you to pass some information about the joystick to the function—such
    as the time the stick was used; the direction it was pushed; and if it was pressed,
    released, or held—so the Pi knows how to react.
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Writing* `y -= 1` *in Python is equal to* `y = y - 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: When the player moves the joystick up, the function moves the y-coordinate of
    the bat up by subtracting `1` from the variable `y`. But first, the code checks
    that `y > 1`; otherwise, the bat may end up moving out of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring Variable Scope**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note that `y` is defined as a `global` variable. Not all variables in a program
    are accessible at all locations in the program, so there might be areas where
    it is invalid to call a certain variable. A variable’s *scope* is the area of
    a program where it is accessible. In Python, there are two basic variable scopes:
    *local* and *global*.'
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined in the main code body is global, meaning it is accessible
    anywhere else in the code. A variable defined inside a function is local to that
    function, so what you do with the local variable inside the function has no effect
    on variables outside, even if they have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: As you want `y` to be usable both inside the function where it is defined and
    throughout the code, it needs to be declared as `global`. Otherwise, when you
    move the joystick nothing will happen, because the `y` variable is just being
    changed inside the function and not in the main body of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Ball**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make a moving ball, you first need a starting position and a velocity. At
    ➍, you set the ball’s starting position using a list. Lists are defined between
    square brackets, `[*0th element*, *1st element*, ..., *nth element*]`, and each
    element is separated by a comma. The elements in the lists have *zero indexing*,
    meaning the index for the first element is 0, not 1\. In this case, our 0th element
    is the x-position, and the 1st element is the y-position.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the game, the ball is in a random position, generated by the
    `randint()` function. That random position can be between 1 and 6 for the y-axis
    and 2 and 6 for the x-axis. These numbers ensure that the ball doesn’t start on
    the ceiling, walls, or next to the bat.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving the Ball**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you have a starting position for the ball, you need to give it a velocity
    ➎ to get it moving. You create a list for the ball’s velocity in which the 0th
    element is the velocity for the x-coordinate and the 1st element is the velocity
    for the y-coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: You need to add or subtract the velocity to or from the current ball position
    to make the ball move forward or backward, respectively. The `draw_ball()` function
    at ➑ is where you display and move the ball, which always moves in diagonals.
    If it goes forward it continues forward, and if it goes backward it continues
    backward, unless it hits the ceiling or the bat, in which case it goes in the
    opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keeping the Game Running**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once everything is set up, you add a `while` loop to keep the game running ➓.
    The `while` loop starts by cleaning the display; then, it calls the function `draw_bat()`
    to draw the bat and `draw_ball()` to display the ball.
  prefs: []
  type: TYPE_NORMAL
- en: The `sleep()` function in the last line defines the time the ball takes to move
    to another position, so you can use this function to determine how fast the ball
    moves. If you increase the delay time, the game becomes slower and easier; if
    you decrease it, the game moves faster. We encourage you to experiment with different
    delay times.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Congratulations! After a lot of programming, you have your reward: you can
    play Pong on your Sense HAT! Press **F5** or go to **Run** ▸ **Run Module** to
    run the script.'
  prefs: []
  type: TYPE_NORMAL
- en: When you lose and the game ends, the LED matrix displays a sad face as shown
    in [Figure 8-6](ch08.xhtml#ch08fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0123-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 8-6:** LED matrix displaying a sad face when the game ends'
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some ideas to upgrade your game:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrease the delay time as the game continues to increase the level of difficulty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a scoring system so that you earn a point every time the ball hits the bat,
    and display the score on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a condition that restarts the game when you press the joystick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
