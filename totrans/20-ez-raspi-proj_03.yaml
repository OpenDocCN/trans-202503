- en: Displays
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示屏
- en: '**6'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: AN LCD Reminder**
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**LCD 提醒**'
- en: In this project, you’ll connect a character LCD to your Raspberry Pi to display
    a scrolling reminder message. You’ll start by displaying static text for short
    messages and then learn how to display scrolling text ideal for longer messages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将把一个字符型 LCD 连接到树莓派上，以显示滚动的提醒信息。你将首先显示短消息的静态文本，然后学习如何显示适合长消息的滚动文本。
- en: '![image](../images/f0085-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0085-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需部件**'
- en: Raspberry Pi
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派
- en: Breadboard
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板
- en: 16×2 Hi tachi HD44780-compatible LCD
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 16×2 Hitachi HD44780 兼容 LCD
- en: 10 kΩ potent iometer
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 10 kΩ 可调电阻
- en: Jumper wires
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 跳线线
- en: '**SOFTWARE REQUIRED**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需软件**'
- en: Adafruit_CharLCD library
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit_CharLCD 库
- en: '**INTRODUCING THE LIQUID CRYSTAL DISPLAY**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**液晶显示屏介绍**'
- en: The simplest and cheapest display screen around is the *liquid crystal display
    (LCD)*. LCDs are found in everyday electronics devices like vending machines,
    calculators (see [Figure 6-1](ch06.xhtml#ch06fig1)), parking meters, and printers,
    and are ideal for displaying text or small icons.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最便宜的显示屏是 *液晶显示器（LCD）*。LCD 广泛应用于日常电子设备中，如自动售货机、计算器（见 [图 6-1](ch06.xhtml#ch06fig1)）、停车计时器和打印机，非常适合显示文本或小图标。
- en: '![image](../images/f0086-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0086-01.jpg)'
- en: '**FIGURE 6-1:** Calculator with an LCD'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-1：** 带 LCD 的计算器'
- en: LCDs are measured according to the number of rows and columns of characters
    that fit on the screen. A 16×2 LCD can display 2 rows of 16 characters each. You’ll
    find sizes ranging from 8×1 to 40×4.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LCD 的大小是根据屏幕上能够显示的字符的行数和列数来测量的。一个 16×2 的 LCD 可以显示 2 行每行 16 个字符。你会找到从 8×1 到 40×4
    不等的不同尺寸。
- en: LCDs also vary in background color. You can find a wide variety of background
    colors, including RGB background lights that let you create any color.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: LCD 还可以在背景颜色上有所不同。你可以找到各种各样的背景颜色，包括 RGB 背景灯，允许你创建任何颜色。
- en: The most common LCD modules use the Hitachi HD44780 chip, which allows you to
    use custom characters. [Figure 6-2](ch06.xhtml#ch06fig2) shows a standard 16×2
    Hitachi HD44780–compatible LCD; we recommend using this type for this project.
    Most 16×2 screens will be compatible, but before you buy one, check the part’s
    data sheet just to be safe. You can also use 20×4 LCDs as long as they are Hitachi
    HD44780–compatible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 LCD 模块使用的是 Hitachi HD44780 芯片，它允许你使用自定义字符。[图 6-2](ch06.xhtml#ch06fig2)
    展示了一个标准的 16×2 Hitachi HD44780 兼容 LCD；我们建议在本项目中使用这种类型。大多数 16×2 屏幕是兼容的，但在购买之前，最好检查一下该部件的数据手册以确保兼容性。你也可以使用
    20×4 的 LCD，只要它们是 Hitachi HD44780 兼容的。
- en: '![image](../images/f0086-02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0086-02.jpg)'
- en: '**FIGURE 6-2:** A standard 16×2 Hitachi HD44780–compatible LCD'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-2：** 标准 16×2 Hitachi HD44780 兼容 LCD'
- en: If you look closely at [Figure 6-2](ch06.xhtml#ch06fig2), you’ll see 32 rectangles
    made of 5×8 pixels. The combination of on and off pixels is what makes up the
    character shapes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 [图 6-2](ch06.xhtml#ch06fig2)，你会看到由 5×8 像素组成的 32 个矩形。开关像素的组合构成了字符形状。
- en: '**Soldering the Headers**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**焊接插针**'
- en: More likely than not, your LCD module will come with the header pins separate,
    as shown in [Figure 6-3](ch06.xhtml#ch06fig3). You’ll need to solder the pins
    to your module to make it breadboard-friendly. Put the pins in the available holes—there
    should be 16 pins for 16 holes—with the long end pointing down and solder them
    in place.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更有可能的是，你的 LCD 模块将带有单独的插针，如 [图 6-3](ch06.xhtml#ch06fig3) 所示。你需要将插针焊接到模块上，以使其适用于面包板。将插针放入可用的孔中——每个
    16 个孔中应有 16 个插针——长端朝下并将其焊接到位。
- en: '![image](../images/f0087-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0087-01.jpg)'
- en: '**FIGURE 6-3:** LCD with separate header pins'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-3：** 带有单独插针的 LCD'
- en: '**The LCD Module Pinout**'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**LCD 模块引脚图**'
- en: 'The LCD module pins are numbered from 1 to 16, from left to right when the
    pins are above the screen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: LCD 模块的引脚编号从 1 到 16，当引脚位于屏幕上方时，从左到右排列：
- en: '| **PIN** | **SYMBOL** | **DESCRIPTION** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **PIN** | **符号** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | VSS | Ground |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1 | VSS | 地 |'
- en: '| 2 | VDD | Power supply |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 2 | VDD | 电源 |'
- en: '| 3 | V0 | Contrast adjustment |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 3 | V0 | 对比度调整 |'
- en: '| 4 | RS | Register selection |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 4 | RS | 寄存器选择 |'
- en: '| 5 | R/W | Read/Write selection |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 5 | R/W | 读/写选择 |'
- en: '| 6 | E | Enable |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 6 | E | 启用 |'
- en: '| 7–14 | DB0–DB7 | Data pins |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 7–14 | DB0–DB7 | 数据引脚 |'
- en: '| 15 | LEDA | Backlight anode (5V) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 15 | LEDA | 背光阳极（5V） |'
- en: '| 16 | LEDK | Backlight cathode (–) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 16 | LEDK | 背光阴极（–） |'
- en: '**WARNING**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The Raspberry Pi GPIOs are designed for 3.3 V, but most LCDs are 5 V. This
    isn’t a problem as long as you’re only sending data out of the Pi and not reading
    data from the screen to the Pi. With a 5 V screen,* do not connect the R/W pin
    of the display to the Pi. *This pin sends data at 5 V, and it will very likely
    fry your Pi!*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*树莓派的GPIO设计为3.3V，但大多数LCD为5V。只要您仅从树莓派发送数据而不是从屏幕读取数据到树莓派，这不是问题。使用5V屏幕时，*请勿将显示器的R/W引脚连接到树莓派。*
    该引脚以5V发送数据，很可能会烧坏您的树莓派！*'
- en: VSS is a ground pin and should be connected to GND. VDD is a power pin and should
    be given 5 V or 3.3 V depending on the type of LCD you are working with; most
    require 5 V.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: VSS是接地引脚，应连接到GND。VDD是电源引脚，应该根据LCD的类型连接到5V或3.3V；大多数需要5V。
- en: V0 allows you to adjust the contrast between the characters and the backlight
    when the LCD is connected to a potentiometer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: V0允许您在LCD连接到电位器时调整字符与背光之间的对比度。
- en: RS, R/W, and E are control pins. When using the screen to display text only,
    as in this project, you should permanently connect R/W directly to ground; in
    other words, you’ll only be writing to the LCD and not reading from it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RS、R/W和E是控制引脚。仅使用屏幕显示文本时（如本项目所示），应将R/W引脚永久连接到地面；换句话说，您将只向LCD写入数据，而不从中读取数据。
- en: Pins 7 to 14 are data pins, used to send information. Pins 15 and 16 are the
    anode and cathode for the backlight.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚7到14是数据引脚，用于发送信息。引脚15和16是背光的阳极和阴极。
- en: 'Though the LCD module has 16 pins, you need only 6 of them to communicate with
    your Raspberry Pi: 4, 6, 11, 12, 13, and 14.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管LCD模块有16个引脚，但您只需要其中的6个来与树莓派通信：4、6、11、12、13和14。
- en: '**WIRING YOUR CIRCUIT**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接线您的电路**'
- en: Now that your LCD is ready to use, you can start building this project’s circuit.
    Follow these steps to wire the LCD and Pi, using the circuit diagram in [Figure
    6-4](ch06.xhtml#ch06fig4) for reference.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的LCD已准备好使用，可以开始构建此项目的电路。按照以下步骤连接LCD和树莓派，并参考[图6-4](ch06.xhtml#ch06fig4)的电路图进行接线。
- en: Connect the breadboard power rails to 5 V and GND.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板的电源轨连接到5V和GND。
- en: To power the LCD, connect 5 V from the power rails to LCD pin 2 (VDD) and to
    LCD pin 15 (LEDA). Connect LCD pin 1 (VSS), pin 5 (R/W), and pin 16 (LEDK) to
    the GND rail on the breadboard.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为LCD供电，将5V从电源轨连接到LCD引脚2（VDD）和LCD引脚15（LEDA）。将LCD引脚1（VSS）、引脚5（R/W）和引脚16（LEDK）连接到面包板的GND轨。
- en: 'Add a potentiometer to adjust the contrast: connect one of the outer leads
    to the GND and the other outer lead to 5 V, and then connect the middle lead to
    LCD pin 3 (V0).'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个电位器来调整对比度：将一个外部引脚连接到GND，另一个外部引脚连接到5V，然后将中间引脚连接到LCD引脚3（V0）。
- en: Connect the Pi’s GPIO pins as shown in the following table.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下表连接树莓派的GPIO引脚。
- en: '| **LCD** | **RASPBERRY PI** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **LCD** | **树莓派** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4 (RS) | GPIO 27 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 4 (RS) | GPIO 27 |'
- en: '| 6 (E) | GPIO 22 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 6 (E) | GPIO 22 |'
- en: '| 11 (DB4) | GPIO 25 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 11 (DB4) | GPIO 25 |'
- en: '| 12 (DB5) | GPIO 24 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 12 (DB5) | GPIO 24 |'
- en: '| 13 (DB6) | GPIO 23 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 13 (DB6) | GPIO 23 |'
- en: '| 14 (DB7) | GPIO 18 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 14 (DB7) | GPIO 18 |'
- en: '![image](../images/f0089-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0089-01.jpg)'
- en: '**FIGURE 6-4:** LCD wired to the Raspberry Pi'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-4：** LCD与树莓派的接线'
- en: When you’re finished wiring, try adjusting the LCD contrast by rotating the
    potentiometer; you should see the backlighting change. If the contrast doesn’t
    change, double-check the wiring before moving on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成接线后，尝试旋转电位器调整LCD的对比度；您应该能看到背光变化。如果对比度没有变化，请在继续之前仔细检查接线。
- en: '**WRITING THE SCRIPT**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写脚本**'
- en: Before you can write the script to display messages on the LCD, you need to
    install the Python library for a character LCD, Adafruit_CharLCD. This library
    features a lot of functions that make it easy to control the LCD.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本以在LCD上显示消息之前，您需要安装字符LCD的Python库Adafruit_CharLCD。该库具有许多功能，便于控制LCD。
- en: '**Installing the Python Library for a Character LCD**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**为字符LCD安装Python库**'
- en: 'Go to the Raspberry Pi desktop taskbar and open the terminal. Before installing
    the Adafruit_CharLCD library, you need to install the following dependencies:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 打开树莓派桌面任务栏中的终端。在安装Adafruit_CharLCD库之前，您需要安装以下依赖项：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When prompted, type y and press ENTER.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，输入y并按下ENTER。
- en: 'Navigate to the desktop, create a folder called *Libraries*, and change directory
    to the newly created folder with the following commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到桌面，创建一个名为*Libraries*的文件夹，然后使用以下命令更改目录到新创建的文件夹：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Download the installation files by entering the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令下载安装文件：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Navigate to the *Adafruit_Python_CharLCD* directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 *Adafruit_Python_CharLCD* 目录：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, execute the following command to install the Adafruit_CharLCD library:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行以下命令来安装 Adafruit_CharLCD 库：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You successfully installed the Python library for a character
    LCD. We encourage you to navigate through the *Examples* folder and take a look.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你成功安装了字符LCD的Python库。我们鼓励你浏览 *Examples* 文件夹并看看。
- en: '**Displaying a Character Message**'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**显示字符消息**'
- en: 'Go to your *Projects* folder and create a new folder called *Displays*. Open
    **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new script.
    Then, enter the following code into the Python Editor and save the script as *character_lcd.py*
    (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 转到你的 *Projects* 文件夹，并创建一个名为 *Displays* 的新文件夹。打开 **Python 3 (IDLE)**，并转到 **文件**
    ▸ **新建文件** 创建一个新脚本。然后，将以下代码输入到Python编辑器中，并将脚本保存为 *character_lcd.py*（记得你可以在 *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*
    下载所有脚本）：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You start by importing the previously installed character LCD library at ➊.
    Then, at ➋ you configure your Pi pins. At ➌, you define your LCD size. If you’re
    using a 20×4 LCD, you need to change those two lines of code accordingly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先在➊导入之前安装的字符LCD库。然后，在➋配置你的Pi引脚。在➌定义你的LCD大小。如果你使用的是20×4的LCD，需要相应地更改这两行代码。
- en: After that, the LCD is initialized ➍, and you write your message inside the
    function `lcd.message('`string`')` between the single quotes ➎. The `\n` escape
    character tells the LCD to display the text that follows on the next line. Feel
    free to change this message to anything you like!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，LCD 在 ➍ 初始化，你在函数 `lcd.message('`string`')` 中写下你的消息，消息放在单引号之间 ➎。`\n` 转义字符告诉LCD在下一行显示随后的文本。随时可以更改这个消息为你喜欢的任何内容！
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script, and your LCD
    should display the text, as in [Figure 6-5](ch06.xhtml#ch06fig5).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按 **F5** 或转到 **运行** ▸ **运行模块** 来运行脚本，你的LCD应显示文本，如[图6-5](ch06.xhtml#ch06fig5)所示。
- en: '![image](../images/f0091-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0091-01.jpg)'
- en: '**FIGURE 6-5:** Your circuit displaying a static message'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-5：** 显示静态消息的电路'
- en: '**Adding Other Functionality**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加其他功能**'
- en: 'It’s worth knowing a few other useful functions you can use for more than just
    displaying text; you may want to set the cursor to a certain position or clear
    the display in preparation for new messages, for example. The library you’ve installed
    provides the following functions for you:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一些其他有用的函数是值得的，你可以用它们做的不仅仅是显示文本；例如，你可能想将光标设置到某个位置，或者清除显示以准备新消息。你安装的库为你提供了以下功能：
- en: '`lcd.message(`string`)` displays the message written between brackets.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.message(`string`)` 显示括号中写的消息。'
- en: '`lcd.clear()` clears the display.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.clear()` 清除显示。'
- en: '`lcd.show_cursor(`boolean`)` shows the cursor after the message.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.show_cursor(`boolean`)` 在消息后显示光标。'
- en: '`lcd.blink(`boolean`)` shows a blinking cursor.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.blink(`boolean`)` 显示一个闪烁的光标。'
- en: '`lcd.move_right()` moves the displayed message one character to the right.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.move_right()` 将显示的消息向右移动一个字符。'
- en: '`lcd.move_left()` moves the displayed message one character to the left.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.move_left()` 将显示的消息向左移动一个字符。'
- en: '`lcd.home()` sets the cursor to the first column and first row (0,0).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.home()` 将光标设置到第一列和第一行（0,0）。'
- en: '`lcd.set_cursor(int, int)` sets the cursor to the specified column and row.
    For example, `lcd.set_cursor(2, 1)` sets the cursor to the third column and second
    row.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lcd.set_cursor(int, int)` 将光标设置到指定的列和行。例如，`lcd.set_cursor(2, 1)` 将光标设置到第三列和第二行。'
- en: The data types shown in italic tell you what kind of value you need to enter
    as an argument; for example, in place of boolean you’d enter `True` or `False`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 斜体中的数据类型告诉你需要输入什么类型的值作为参数；例如，布尔值可以输入 `True` 或 `False`。
- en: '**Scrolling a Reminder Message**'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**滚动提醒消息**'
- en: This LCD screen is pretty small, so you’ll get stuck if you try to display messages
    longer than 32 characters. So, now we’ll show you how to write a script to display
    a longer message that scrolls across the screen, like a reminder for a doctor
    appointment you can’t miss. In the first row, you’ll have a title for your message,
    like “Reminder” or “Don’t forget,” and in the second row your reminder message
    will scroll by.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 LCD 屏幕相当小，所以如果你尝试显示超过 32 个字符的消息，显示会卡住。因此，现在我们将向你展示如何编写一个脚本，显示一个较长的滚动消息，就像一个你不能错过的医生预约提醒。在第一行，你将有一个消息的标题，比如“提醒”或者“别忘了”，第二行则是你的提醒消息会滚动显示。
- en: 'Displaying a scrolling message is not as straightforward as showing a static
    message, so let’s think about what we want to happen before we write our code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显示滚动消息并不像显示静态消息那样简单，所以在编写代码之前，让我们思考一下我们想要发生什么：
- en: The first row displays a static title.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行显示静态标题。
- en: The second row displays a scrolling message.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行显示滚动消息。
- en: The scrolling message moves from right to left.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动消息从右向左移动。
- en: The characters should appear from the rightmost column.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符应从最右侧的列出现。
- en: The characters should disappear at the leftmost column.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符应在最左侧的列消失。
- en: 'The message scrolls forever until stopped. Inside the *Displays* folder, create
    a new script with **Python 3 (IDLE)** called *scrolling_text.py* and enter the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 消息会永远滚动，直到被停止。在 *Displays* 文件夹内，创建一个新的 **Python 3 (IDLE)** 脚本，命名为 *scrolling_text.py*，并输入以下代码：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’re already familiar with importing the Adafruit_CharLCD library, configuring
    the Raspberry Pi pins, defining the screen size, and initializing the LCD.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉导入 Adafruit_CharLCD 库、配置 Raspberry Pi 引脚、定义屏幕大小和初始化 LCD。
- en: For this example, you also need to import the time library ➊ to use functions
    related to time. At ➋ and ➌, you assign the text that will be displayed as the
    title and reminder messages, respectively. The `delay` ➍ will be the time a character
    stays in one place before moving one character to the left. In this case, you
    set the delay to `0.3` seconds; the lower the delay, the faster the text will
    scroll.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你还需要导入时间库 ➊ 来使用与时间相关的函数。在 ➋ 和 ➌ 处，你分别为将要显示的标题和提醒消息分配文本。`delay` ➍ 是角色在移动到左侧一个字符之前停留在一个位置的时间。在这个例子中，你将延迟设置为
    `0.3` 秒；延迟越小，文本滚动越快。
- en: 'At ➎, you create a function called `scroll_message(``*string*, *float*)` that
    accepts two parameters: a string that will be your `reminder` and a float that
    will be the `delay`. Inside the function you start by creating a `padding` variable
    that consists of a blank character multiplied by the number of columns your LCD
    has. This will fill all your character slots initially with a blank square variable,
    creating the illusion that characters are appearing gradually. Then you create
    a new variable called `reminder_message` that is the concatenation of the `padding`,
    the `reminder`, and one blank space. You need to add this extra blank space to
    create the disappearing effect of the `reminder_message`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，你创建一个名为 `scroll_message(``*string*, *float*)` 的函数，该函数接受两个参数：一个字符串作为你的
    `reminder`，和一个浮动数值作为 `delay`。在函数内部，你首先创建一个 `padding` 变量，它由若干个空白字符组成，空白字符的数量与 LCD
    的列数相等。这将最初填满所有字符槽，创造字符逐渐出现的错觉。接着，你创建一个名为 `reminder_message` 的新变量，它是 `padding`、`reminder`
    和一个空格的连接。你需要添加这个额外的空格来创造 `reminder_message` 消失的效果。
- en: The function goes through a `for` ➏ loop from `0` to the length of the `reminder_message`.
    The function `len(`object`)` returns the length of an object—in this case, the
    number of characters in the `reminder_message` string, which tells us how many
    times to loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过一个 `for` ➏ 循环从 `0` 到 `reminder_message` 的长度进行循环。函数 `len(`object`)` 返回一个对象的长度——在这个例子中，就是
    `reminder_message` 字符串中的字符数量，这告诉我们循环的次数。
- en: '**NOTE**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python uses* zero-based indexing, *which means that indexes start counting
    at zero. For instance, the first character of a string has index `0`.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 使用* 从零开始的索引，*这意味着索引从零开始计数。例如，字符串的第一个字符的索引是 `0`。*'
- en: Inside the loop, the code starts by setting the cursor to the first column,
    second row, where you want to start displaying your reminder. In the next line,
    `reminder_message[i:(i+lcd_columns)]` truncates your `reminder_message`, returning
    the characters from index `i` to index number `i+lcd_columns` exclusively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，代码首先设置光标到第一列、第二行的位置，你希望开始显示提醒的地方。在下一行，`reminder_message[i:(i+lcd_columns)]`
    截取你的 `reminder_message`，返回从索引 `i` 到索引 `i+lcd_columns` 之间的字符（不包括 `i+lcd_columns`）。
- en: Each time the loop runs, you will display a different part of your message;
    this is what actually creates the scrolling effect (see [Figure 6-6](ch06.xhtml#ch06fig6)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环运行时，你将显示消息的不同部分；这就是实际产生滚动效果的原因（见 [图 6-6](ch06.xhtml#ch06fig6)）。
- en: '![image](../images/f0094-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0094-01.jpg)'
- en: '**FIGURE 6-6:** Truncating a string to make a scrolling effect'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-6：** 截断字符串以产生滚动效果'
- en: After displaying the full message, the code waits the number of seconds assigned
    in the `delay` variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显示完整消息后，代码会等待 `delay` 变量中分配的秒数。
- en: At ➐, you clear the screen and display the `title` message from the first column,
    in the first row.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➐ 处，你清除屏幕，并从第一列、第一行显示 `title` 消息。
- en: 'Finally, at ➑, you create a `while` loop that is always `True`. This is a little
    trick to make something run forever and ever. Inside that loop you call the function
    `scroll_message(``*string*, *float*)` with your own arguments: `reminder` and
    `delay`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ➑ 处，你创建了一个始终为 `True` 的 `while` 循环。这是一个小技巧，让某个程序永远运行下去。在这个循环内部，你调用函数 `scroll_message(``*string*,
    *float*)`，并传入你自己的参数：`reminder` 和 `delay`。
- en: '**Running the Script**'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运行脚本**'
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Unfortunately,
    we can’t show the text moving in a book, but you get the idea!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按**F5**键或进入**运行** ▸ **运行模块**来运行脚本。不幸的是，我们无法展示书中文字的滚动效果，但你大致能理解！
- en: '**TAKING IT FURTHER**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步深入**'
- en: 'We recommend that you modify the sample script we’ve given you with the coding
    tricks you’ve learned here and earlier, and experiment with the functions shown
    in [“Adding Other Functionality”](ch06.xhtml#lev71) on [page 91](ch06.xhtml#page_91)
    to get familiar with the LCD. When you’re done, here are some projects to try:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你根据你在此处以及之前学到的编码技巧，修改我们提供的示例脚本，并尝试使用 [“添加其他功能”](ch06.xhtml#lev71) 中展示的函数，这些内容出现在
    [第 91 页](ch06.xhtml#page_91)，以熟悉 LCD。当你完成后，下面是一些可以尝试的项目：
- en: Build a weather forecaster using the LCD display—take a look at [Project 7](ch07.xhtml#ch07),
    in which we show how to get weather data.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LCD 显示屏构建天气预报器——查看 [项目 7](ch07.xhtml#ch07)，我们将展示如何获取天气数据。
- en: Display messages based on weather conditions, like “Don’t forget your umbrella.”
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据天气情况显示消息，例如“别忘了带伞。”
- en: Display sensor data on the LCD—check out [Projects 9](ch09.xhtml#ch09)–[12](ch12.xhtml#ch12)
    to learn how to read data from a sensor.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 LCD 上显示传感器数据——查看 [项目 9](ch09.xhtml#ch09)–[12](ch12.xhtml#ch12)，学习如何读取传感器数据。
- en: '**7'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: Mini Weather Forecaster**
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Mini Weather Forecaster**
- en: In this project, you’re going to build a weather forecaster that displays the
    day’s weather for your location on an OLED display. You’ll learn how to make API
    requests, which are really useful for projects that rely on frequently updated
    data, and how to use an OLED display.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将构建一个天气预报器，显示你所在地当天的天气信息。你将学习如何发出 API 请求，这对于依赖频繁更新数据的项目非常有用，并且学习如何使用
    OLED 显示屏。
- en: '![image](../images/f0097-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0097-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需部件**'
- en: Raspberry Pi
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派
- en: Breadboard
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板
- en: 0.96-inch OLED display
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 0.96 英寸 OLED 显示屏
- en: Jumper wires
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 跳线
- en: '**SOFTWARE REQUIRED**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需软件**'
- en: Adafruit_SSD1306 library
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit_SSD1306 库
- en: '**INTRODUCING THE OLED DISPLAY**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**介绍 OLED 显示屏**'
- en: 'The *organic light-emitting diode (OLED)* display this project uses is the
    SSD1306 model: a monocolor, 0.96-inch display with 128×64 pixels, shown in [Figure
    7-1](ch07.xhtml#ch07fig1). Compared to the LCD, which has a reserved space of
    5×8 pixels for each character, the OLED display is much more versatile. It allows
    you to choose which pixels are on and off, enabling you to produce custom text
    and images anywhere in the display. The OLED display also doesn’t require backlight,
    which results in a very nice contrast in dark environments. Additionally, its
    pixels consume energy only when they are on, so the OLED display consumes less
    power than an LCD.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用的 *有机发光二极管（OLED）* 显示屏是 SSD1306 型号：一款单色、0.96 英寸、128×64 像素的显示屏，如 [图 7-1](ch07.xhtml#ch07fig1)
    所示。与 LCD 显示屏相比，LCD 每个字符预留了 5×8 像素的空间，而 OLED 显示屏更为灵活。它允许您选择哪些像素是开（点亮）或关（熄灭）的，能够在显示屏的任意位置生成自定义文本和图像。OLED
    显示屏也不需要背光，因此在暗环境中对比度很好。此外，OLED 的像素仅在点亮时消耗电能，因此它比 LCD 显示屏消耗更少的电量。
- en: '![image](../images/f0098-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0098-01.jpg)'
- en: '**FIGURE 7-1:** The SSD1306 0.96-inch monocolor OLED display'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-1：** SSD1306 0.96 英寸单色 OLED 显示屏'
- en: '**NOTE**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some OLED displays use SPI communication instead of I²C—these will come with
    a different set of pins. Make sure you check the pin layout before purchasing
    your OLED display.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些 OLED 显示屏使用 SPI 通信而不是 I²C—这些显示屏会有一组不同的引脚。在购买 OLED 显示屏之前，请务必检查引脚布局。*'
- en: This OLED display generally has four pins, GND, VCC, SCL, and SDA (see [Figure
    7-1](ch07.xhtml#ch07fig1)), though you may find that some models come with an
    extra reset pin. Some displays may come with the pins in a different order as
    well—VCC, GND, SCL, SDA—so just pay attention to the labels as you follow this
    project’s instructions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该 OLED 显示屏通常有四个引脚，GND、VCC、SCL 和 SDA（见 [图 7-1](ch07.xhtml#ch07fig1)），但您可能会发现一些型号额外配有复位引脚。有些显示屏的引脚顺序也可能不同—VCC、GND、SCL、SDA—因此在按照本项目说明操作时，请注意查看标签。
- en: The OLED display in [Figure 7-1](ch07.xhtml#ch07fig1) uses the Inter-Integrated
    Circuit (I²C) communication protocol to communicate with the Raspberry Pi, for
    which you need the SDA and SCL pins (GPIO 2 and GPIO 3, respectively).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](ch07.xhtml#ch07fig1) 中的 OLED 显示屏使用内部集成电路（I²C）通信协议与树莓派进行通信，您需要使用 SDA
    和 SCL 引脚（分别为 GPIO 2 和 GPIO 3）。'
- en: '**USING THE OPENWEATHERMAP API**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 OpenWeatherMap API**'
- en: An application programming interface (API) is a set of functions written by
    software developers to enable anyone to use their data or services. For example,
    the OpenWeatherMap project (*[https://openweathermap.org/](https://openweathermap.org/)*)
    has an API that enables users to request weather data using many different programming
    languages. In this project you’ll use that API to request the day’s weather forecast
    for your chosen location. Learning to use APIs with your Pi is a great skill because
    it allows you access to a wide variety of constantly changing information, such
    as current stock prices, currency exchange rates, the latest news, traffic updates,
    tweets, and much more.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是一组由软件开发人员编写的函数，用于使任何人都能使用他们的数据或服务。例如，OpenWeatherMap 项目 (*[https://openweathermap.org/](https://openweathermap.org/)*
    ) 提供了一个 API，允许用户使用多种编程语言请求天气数据。在本项目中，您将使用该 API 请求所选位置的天气预报。学习如何使用 API 与树莓派配合工作是一项很棒的技能，因为它可以让您访问各种不断变化的信息，如当前股价、货币兑换率、最新新闻、交通更新、推文等。
- en: 'OpenWeatherMap’s free plan provides everything you need to complete this project.
    To use the API you need an API key, known as the *APIID*. To get an APIID:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap 的免费计划提供了完成此项目所需的一切。要使用 API，您需要一个 API 密钥，称为 *APIID*。获取 APIID 的方法：
- en: Open a browser and go to *[https://openweathermap.org/appid/](https://openweathermap.org/appid/)*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，访问 *[https://openweathermap.org/appid/](https://openweathermap.org/appid/)。
- en: Press the **Sign up** button and create a free account.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **注册** 按钮并创建一个免费账户。
- en: You’ll be presented with a dashboard that contains several tabs. Select the
    **API keys** tab, as shown in [Figure 7-2](ch07.xhtml#ch07fig2).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个包含多个标签的仪表板。选择 **API 密钥** 标签，如 [图 7-2](ch07.xhtml#ch07fig2) 所示。
- en: '![image](../images/f0099-01.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0099-01.jpg)'
- en: '**FIGURE 7-2:** API keys on OpenWeatherMap'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-2：** OpenWeatherMap 的 API 密钥'
- en: On the API keys tab, you’ll see a default key (shown in [Figure 7-2](ch07.xhtml#ch07fig2));
    this is a unique key you’ll need to pull information from the site. Copy and paste
    this key somewhere; you’ll need it in a moment. You can create a new key for each
    separate project if you like, but if you aren’t familiar with using APIs, we’d
    recommend just using the default key provided.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 API 密钥标签页中，你将看到一个默认的密钥（如[图 7-2](ch07.xhtml#ch07fig2)所示）；这是你需要从网站提取信息的唯一密钥。复制并粘贴此密钥到某个地方，稍后你会用到它。如果你喜欢，可以为每个单独的项目创建一个新密钥，但如果你不熟悉使用
    API，我们建议你直接使用默认密钥。
- en: 'To pull information on weather in your chosen location, enter the following
    URL:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取你选择位置的天气信息，请输入以下 URL：
- en: '[PRE7]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**WARNING**'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*APIs are unique to the user and shouldn’t be shared with anyone. In this case,
    whoever has your API key can only request the weather, but if you were using social
    media APIs, for example, you could run into security issues—like strangers getting
    access to your personal information. Don’t share your API keys with anyone.*'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*API 对用户是唯一的，不应与他人共享。在这种情况下，拥有你 API 密钥的人只能请求天气信息，但如果你在使用社交媒体 API 时，可能会遇到安全问题——例如，陌生人获取你的个人信息。不要与任何人分享你的
    API 密钥。*'
- en: 'Replace your_city with the city you want data for, your_country_code with the
    country code for that city, and your_unique_API_key with the unique API key from
    step 4\. For example, the updated API URL for the town of Porto, Portugal, would
    be:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 your_city 替换为你想要获取数据的城市，将 your_country_code 替换为该城市的国家代码，将 your_unique_API_key
    替换为步骤 4 中获得的唯一 API 密钥。例如，葡萄牙波尔图市的更新 API URL 将是：
- en: '[PRE8]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copy your URL into your browser, and the API will return a bunch of information
    corresponding to your local weather. [Listing 7-1](ch07.xhtml#ch07list1) shows
    the weather in Porto, Portugal, on the day we wrote this project.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 URL 复制到浏览器中，API 将返回与你当地天气相关的一大堆信息。[列表 7-1](ch07.xhtml#ch07list1) 显示的是我们写这个项目时波尔图（葡萄牙）的天气。
- en: '**LISTING 7-1:** The API response'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**列表 7-1：** API 响应'
- en: '[PRE9]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**NOTE**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*More information on using the API to get weather information is available
    at* [https://openweathermap.org/current](https://openweathermap.org/current).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关如何使用 API 获取天气信息的更多信息，请访问* [https://openweathermap.org/current](https://openweathermap.org/current)。'
- en: This may not look like much now, but next you’ll see how to organize this data
    with tabs and paragraphs to make it more readable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能看起来不太重要，但接下来你将看到如何使用标签和段落组织这些数据，使其更易于阅读。
- en: '**Understanding JSON Syntax**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**理解 JSON 语法**'
- en: 'As you can see, the weather data for your chosen location is stored in a specific
    way, with symbols like `{}[] : ""` and `,`. This syntax is *JavaScript Object
    Notation (JSON)*, a standard for exchanging data in a way that’s convenient for
    computers. In JSON syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，选择位置的天气数据以特定的方式存储，使用了像 `{}[] : ""` 和 `,` 等符号。这种语法是 *JavaScript 对象表示法（JSON）*，一种用于数据交换的标准，方便计算机处理。在
    JSON 语法中：'
- en: Data is represented in name/value pairs.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据以名称/值对的形式表示。
- en: Each name is followed by a colon ( `:`).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个名称后面都跟一个冒号（`:`）。
- en: Name/value pairs are separated with commas.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称/值对之间用逗号分隔。
- en: Curly brackets hold objects.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号用于表示对象。
- en: Square brackets hold arrays.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号用于表示数组。
- en: '[Listing 7-2](ch07.xhtml#ch07list2) shows how you can organize the API information
    so it’s easier to understand.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-2](ch07.xhtml#ch07list2) 显示了如何组织 API 信息，使其更易理解。'
- en: '**LISTING 7-2:** The API JSON information rearranged for a clearer structure'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7-2：** 重排后的 API JSON 信息，结构更加清晰'
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you can more easily see all the different kinds of information the API provides.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更轻松地看到 API 提供的各种信息。
- en: '**Making an API Request**'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**发起 API 请求**'
- en: Now you have a URL that returns your local weather data. To show you how to
    access the information using Python, we’ll give you an example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个返回你当地天气数据的 URL。为了展示如何使用 Python 访问这些信息，我们将给出一个示例。
- en: The simple code snippet in [Listing 7-3](ch07.xhtml#ch07list3) requests the
    current maximum temperature in Kelvin for Porto, Portugal, and prints it in the
    Python shell. Replace our URL with your own, and you’ll get the same information
    for your chosen location.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-3](ch07.xhtml#ch07list3) 中的简单代码片段请求波尔图（葡萄牙）的当前最大温度（单位：开尔文），并在 Python
    shell 中打印出来。用你自己的 URL 替换我们的 URL，你将获得所选位置的相同信息。'
- en: '**LISTING 7-3:** Requesting maximum temperature'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7-3：** 请求最大温度'
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At ➊, you import the requests library, which is essential for making API requests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，你导入了 `requests` 库，这是发起 API 请求所必需的。
- en: At ➋, you create a variable called `weather_data` in which you store the data
    returned after the API request. To make an API request for information, you use
    the command `requests.get('`your_url`')`, with your URL as the argument inside
    single quotes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 步，你创建了一个名为 `weather_data` 的变量，用来存储 API 请求返回的数据。要发起 API 请求获取信息，你使用命令 `requests.get('`your_url`')`，其中
    `your_url` 是你 URL 的参数，并且需要放在单引号中。
- en: At ➌, you create the `temp_max` variable to hold the particular data you’re
    requesting. In this case, you want the maximum temperature.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 步，你创建了 `temp_max` 变量来存储你所请求的特定数据。在这个例子中，你需要的是最大温度。
- en: To get that value, you first convert the `weather_data` variable to JSON with
    the `.json()` method. Then, using the `.get()` method, you access the `temp_max`
    variable, which contains the maximum temperature value. You can see in [Listing
    7-2](ch07.xhtml#ch07list2) that `main` is the top-level parent of the data you
    want to access, `temp_max`, so you need to get through `main` first.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取该值，你首先使用 `.json()` 方法将 `weather_data` 变量转换为 JSON 格式。然后，使用 `.get()` 方法，你可以访问包含最大温度值的
    `temp_max` 变量。你可以在 [清单 7-2](ch07.xhtml#ch07list2) 中看到，`main` 是你需要访问的 `temp_max`
    数据的顶级父元素，所以你需要先通过 `main` 来获取。
- en: 'In the same way, to access the wind speed you enter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，要访问风速信息，你需要输入：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You need to go through the parent of `speed`, which is `wind`, to request the
    information about wind speed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过 `wind`（风速数据的父元素）来请求关于风速的信息。
- en: 'If you just want to get the city name, you enter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取城市名称，输入：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After learning how to make API requests in Python, you’re ready to start this
    project!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了如何在 Python 中发起 API 请求之后，你已经准备好开始这个项目了！
- en: '**THE REQUESTS LIBRARY**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**requests 库**'
- en: The requests library, also called “HTTP for Humans,” is an Apache2- licensed
    Python library used to send *hypertext transfer protocol (HTTP)* requests. This
    powerful library makes it simple to connect to web servers via HTTP. This capability
    allows you to easily request information from any web page, as you’ve been doing
    here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: requests 库，也叫做“HTTP for Humans”，是一个 Apache2 许可的 Python 库，用于发送 *超文本传输协议（HTTP）*
    请求。这个强大的库使得通过 HTTP 连接到 Web 服务器变得简单。这一功能让你能够轻松地从任何网页请求信息，就像你在这里所做的那样。
- en: '**WIRING THE CIRCUIT**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**电路连接**'
- en: Simply wire the OLED display to the Pi according to the pinout shown in the
    table. Remember that the pin order may be different on some models, so follow
    the pin labels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只需按照表中显示的引脚图将 OLED 显示器连接到树莓派。记住，不同型号的引脚顺序可能不同，因此请根据引脚标签来连接。
- en: '| **OLED DISPLAY** | **RASPBERRY PI** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **OLED 显示器** | **树莓派** |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VCC | 3.3 V |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| VCC | 3.3 V |'
- en: '| GND | GND |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| GND | GND |'
- en: '| SDA | GPIO 2 (SDA) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| SDA | GPIO 2 (SDA) |'
- en: '| SCL | GPIO 3 (SCL) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| SCL | GPIO 3 (SCL) |'
- en: '| RST (if existent) | GPIO 24 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| RST（如果存在） | GPIO 24 |'
- en: Check your circuit against [Figure 7-3](ch07.xhtml#ch07fig3) and then move on
    to the software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对照 [图 7-3](ch07.xhtml#ch07fig3) 检查你的电路，然后继续进行软件部分。
- en: '![image](../images/f0103-01.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0103-01.jpg)'
- en: '**FIGURE 7-3:** Wiring the OLED display to the Raspberry Pi'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-3：** 将 OLED 显示器连接到树莓派'
- en: '**WRITING THE SCRIPT**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写脚本**'
- en: Before you enter the script, you need to install the Adafruit_SSD1306 library
    to use the OLED with the Raspberry Pi. This library makes it simple to write text
    and draw images on the display. You’ll also need to enable I²C communication so
    the OLED and Pi can communicate.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入脚本之前，你需要安装 Adafruit_SSD1306 库来使用 OLED 显示器和树莓派。这个库使得在显示器上写文本和绘制图像变得简单。你还需要启用
    I²C 通信，以便 OLED 和树莓派之间能够通信。
- en: '**Installing the Library for the OLED Display**'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安装 OLED 显示器的库**'
- en: 'If you haven’t done so already, create a folder called *Libraries* on your
    Desktop. Then, open the terminal and navigate to the *Libraries* folder on your
    Pi:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有做过，先在桌面上创建一个名为 *Libraries* 的文件夹。然后，打开终端并导航到你树莓派上的 *Libraries* 文件夹：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Clone the OLED library:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆 OLED 库：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install the Adafruit_Python_SSD1306 library:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Adafruit_Python_SSD1306 库：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Enabling I²C Communication**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**启用 I²C 通信**'
- en: The OLED communicates with the Pi using the I²C communication protocol, so you
    need to enable I²C communication on your Pi. Go to the Desktop main menu and select
    **Preferences** ▸ **Raspberry Pi Configuration**. In the Interfaces tab, enable
    I²C, as shown in [Figure 7-4](ch07.xhtml#ch07fig4), and press **OK**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: OLED 使用 I²C 通信协议与树莓派进行通信，因此你需要在树莓派上启用 I²C 通信。前往桌面主菜单，选择 **Preferences** ▸ **Raspberry
    Pi Configuration**。在 Interfaces 选项卡中，启用 I²C，如 [图 7-4](ch07.xhtml#ch07fig4) 所示，然后按
    **OK**。
- en: '![image](../images/f0104-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0104-01.jpg)'
- en: '**FIGURE 7-4:** Enabling I²C communication'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-4：** 启用 I²C 通信'
- en: '**I²C COMMUNICATION PROTOCOL**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**I²C 通信协议**'
- en: '*I²C*, or *Inter-Integrated Circuit*, is a communication protocol that allows
    communication between multiple *slave* integrated circuits and one master chip.
    The slaves are the devices that respond to the master. The master chip can communicate
    with all slaves, but a slave can only communicate with the master. Both the slave
    and master can transfer data, but that transfer is always controlled by the master.
    In this case, the Raspberry Pi is the master chip and the OLED integrated circuit
    is the slave. The Raspberry Pi supports I²C communication in its GPIO pins through
    the SDA and SCL pins. The biggest advantage of using this communication protocol
    is that you can connect more than one device via I²C using just the SDA and SCL
    pins—no need to use additional pins on the header.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*I²C*，即 *集成电路互联*，是一种通信协议，允许多个 *从属* 集成电路与一个主芯片之间进行通信。从属设备是响应主设备的设备。主芯片可以与所有从设备通信，但从设备只能与主设备通信。主从设备都可以传输数据，但传输始终由主设备控制。在这个案例中，树莓派是主芯片，OLED
    集成电路是从设备。树莓派通过其 GPIO 引脚的 SDA 和 SCL 引脚支持 I²C 通信。使用这种通信协议的最大优势是，你只需要通过 SDA 和 SCL
    引脚就能连接多个设备——无需使用额外的引脚。'
- en: '**Entering the Script**'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**输入脚本**'
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the code shown in [Listing 7-4](ch07.xhtml#ch07list4) to the Python
    Editor and save the script as *weather_forecast.py* inside the *Displays* folder
    (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Python 3 (IDLE)** 并转到 **文件** ▸ **新建文件** 来创建一个新脚本。将 [清单 7-4](ch07.xhtml#ch07list4)
    中显示的代码复制到 Python 编辑器中，并将脚本保存在 *Displays* 文件夹中，命名为 *weather_forecast.py*（记住，你可以在
    *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*
    下载所有脚本）：
- en: '**LISTING 7-4:** The *weather_forecast.py* script'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7-4：** *weather_forecast.py* 脚本'
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, your code starts by importing the required libraries ➊. The Adafruit_SSD1306
    library contains the OLED display driver classes. From the Python Imaging Library
    (PIL) you import three modules—`Image`, `ImageDraw`, and `ImageFont`—to create
    an image with the text that you’re going to display on the OLED.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你的代码从导入所需的库开始 ➊。Adafruit_SSD1306 库包含了 OLED 显示驱动类。你从 Python Imaging Library（PIL）中导入了三个模块——`Image`、`ImageDraw`
    和 `ImageFont`——来创建一个带有文本的图像，这些文本将显示在 OLED 上。
- en: '**THE OLED LIBRARIES**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**OLED 库**'
- en: 'The Adafruit_SSD1306 library refers to everything shown on the OLED display
    as an “image”—even text. The three modules you’re using here have the following
    roles:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit_SSD1306 库将 OLED 显示器上显示的所有内容都称为“图像”——即使是文本。你在这里使用的三个模块各自的角色如下：
- en: Image creates a new image.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Image 创建一个新图像。
- en: ImageDraw draws the text or icons inside the image and shows what you’ll see
    on the actual OLED display.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageDraw 在图像内绘制文本或图标，并显示你将在实际 OLED 显示器上看到的内容。
- en: ImageFont sets the text font.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageFont 设置文本字体。
- en: '**Initializing the OLED Display**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化 OLED 显示屏**'
- en: Even if your display doesn’t have a reset pin, you need to set the `RST` pin
    in your code. If your display does have a reset pin, it should be connected to
    GPIO 24\. So, in either case, you set `RST` to `24` here ➋.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的显示屏没有重置引脚，你也需要在代码中设置 `RST` 引脚。如果你的显示屏有重置引脚，它应该连接到 GPIO 24。所以，无论哪种情况，你都需要在此处
    ➋ 将 `RST` 设置为 `24`。
- en: At ➌, you create a class for your display. For a 128×32 display, create the
    class `SSD1306_128_32`; for a 128×64 display, create the class `SSD1306_128_64`.
    We’ve given both options in the code so you can just uncomment the line that matches
    your display size and comment out the other.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，你创建了一个显示类。对于 128×32 显示屏，创建 `SSD1306_128_32` 类；对于 128×64 显示屏，创建 `SSD1306_128_64`
    类。我们在代码中给出了这两种选项，你只需取消注释与你的显示屏尺寸匹配的那一行，并注释掉另一行。
- en: At ➎, you initialize the display library and prepare the display so that you
    can draw text on it. We’ve commented the code heavily to help you understand the
    purpose of each line.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，你初始化显示库并准备显示屏，以便可以在其上绘制文本。我们对代码进行了大量注释，以帮助你理解每一行的作用。
- en: '**Making the API Request**'
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**发起 API 请求**'
- en: At ➍, you create a variable called `open_weather_map_url` to hold the API URL.
    Make sure to update this line with your own API URL.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，你创建了一个名为 `open_weather_map_url` 的变量来保存 API URL。确保用你自己的 API URL 更新这一行。
- en: At ➏, you make the API request, after which there are several blocks of code
    that work similarly. We’ll explain the one at ➐, and then you’ll be able to follow
    what the rest are doing. You create a variable, `location`, to get the location.
    This variable is a concatenation of several strings. First, you get the location
    using `weather_data.json().get('name')`, which in this example returns `Porto`.
    You add a hyphen by using `+ ' - '` and then the country code using `weather_data.json().get('sys').get('country')`;
    in this example, it returns `PT`. So, the `location` variable returns `Porto –
    PT`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏ 处，你发出 API 请求，之后有几个代码块起到类似的作用。我们将解释 ➐ 处的代码，然后你就能理解其他代码块的功能。你创建一个名为 `location`
    的变量来获取位置。这个变量是多个字符串的拼接。首先，使用 `weather_data.json().get('name')` 获取位置，在这个例子中返回 `Porto`。然后用
    `+ ' - '` 添加一个连字符，再用 `weather_data.json().get('sys').get('country')` 获取国家代码；在这个例子中，返回
    `PT`。因此，`location` 变量返回 `Porto – PT`。
- en: '**Drawing Text on the OLED Display**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在 OLED 显示屏上绘制文本**'
- en: 'To draw text on the display, you use the `draw.text()` function, which takes
    the following parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在显示屏上绘制文本，可以使用 `draw.text()` 函数，函数接受以下参数：
- en: x and y coordinates  Where the text starts being drawn
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: x 和 y 坐标  文本开始绘制的位置
- en: text  The text to display
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: text  要显示的文本
- en: font  The font the text will appear in
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: font  文本显示的字体
- en: fill  The pixel brightness—255 is the maximum
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: fill  像素亮度—255 是最大值
- en: 'For example, to display the location on the top line of the OLED forecaster,
    use the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 OLED 预报器的顶行显示位置，请使用以下代码：
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `x` and `top` coordinates were defined at ➎. This example uses the default
    library font, though you should feel free to explore other fonts by downloading
    the font files and modifying the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `top` 坐标在 ➎ 处定义。这个例子使用了默认的库字体，不过你可以通过下载字体文件并修改代码，来探索其他字体。'
- en: The blocks of code to display the weather description, temperature, pressure,
    humidity, and wind are all similar. Note that you need to increment the `to`p
    variable to draw text on the next line of the display.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 显示天气描述、温度、气压、湿度和风速的代码块都很相似。请注意，你需要递增 `top` 变量才能在显示屏的下一行绘制文本。
- en: Finally, the lines of code at ➑ display the image on the OLED. The delay time
    at the end determines how fast the loop updates the weather information—in this
    case, every 10 seconds.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ➑ 处的代码行将图像显示在 OLED 上。末尾的延时时间决定了循环更新天气信息的速度——在这个例子中，是每 10 秒更新一次。
- en: '**Running the Script**'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运行脚本**'
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Congratulations,
    now you have a tiny weather forecaster that will give you constantly updated data
    on the weather in your chosen location!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按 **F5** 或前往 **运行** ▸ **运行模块** 来运行脚本。恭喜你，现在你有了一个小型天气预报器，能不断更新你所选地点的天气数据！
- en: '**TAKING IT FURTHER**'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步探索**'
- en: 'You can use APIs to get way more information than just the weather. With your
    favorite search engine, enter a query like *free API for <thing>* to find an API
    you can access. Here are some ideas to get you started:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 API 获取比天气更多的信息。使用你最喜欢的搜索引擎，输入类似 *free API for <thing>* 的查询，来找到你可以访问的 API。以下是一些可以让你开始的想法：
- en: Traffic
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交通
- en: Tweets
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推文
- en: Latest news
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新新闻
- en: Stock prices
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格
- en: Current Bitcoin exchange rate
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前比特币汇率
- en: '**8'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: Pong with a Sense HAT**
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 Sense HAT 的 Pong**
- en: Here you’ll build your own LED Pong game using the Sense HAT. The Sense HAT
    is an add-on board for your Pi that gives it a lot more functionality through
    extra features like an LED matrix, joystick, and several sensors that get information
    from the outside world.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将使用 Sense HAT 构建你自己的 LED Pong 游戏。Sense HAT 是一个附加板，可以为你的 Pi 增加更多功能，提供额外的特性，如
    LED 矩阵、操纵杆以及从外界获取信息的多个传感器。
- en: '![image](../images/f0111-01.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0111-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需部件**'
- en: Raspberry Pi (versions with 40 GPIOs)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi（具有 40 个 GPIO 引脚的版本）
- en: Sense HAT
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT
- en: 'You’ll use the Sense HAT’s LED matrix to display the game and the joystick
    to play. If you don’t have the hardware, not to worry: you’ll also learn how to
    use the Sense HAT emulator to create the same game without it.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 Sense HAT 的 LED 矩阵来显示游戏，并用操纵杆来玩。如果你没有硬件，不用担心：你还将学习如何使用 Sense HAT 模拟器，在没有硬件的情况下创建相同的游戏。
- en: '**INTRODUCING PONG**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**介绍 Pong**'
- en: 'One of the first video games ever created, Pong is an immensely popular 2D
    table-tennis (ping-pong) game that can be played in single- or double-player mode.
    You’re going to create the single-player version, so it’s more like playing squash:
    you bounce the ball against the walls with your bat and catch it with the bat
    when it comes back. If you miss the ball, you lose.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “Pong”是最早创建的视频游戏之一，是一款非常流行的2D乒乓球游戏，可以单人或双人模式玩。你将创建单人版，所以这更像是打壁球：你用球拍把球弹回墙壁，然后在球回来的时候用球拍接住它。如果你错过了球，就输了。
- en: '**INTRODUCING THE RASPBERRY PI SENSE HAT**'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**介绍Raspberry Pi Sense HAT**'
- en: The Raspberry Pi Sense HAT features an 8×8 RGB LED matrix, a five-button joystick,
    a gyroscope, an accelerometer, a magnetometer, a temperature sensor, a barometric
    sensor, and a humidity sensor in one package, shown in [Figure 8-1](ch08.xhtml#ch08fig1).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Sense HAT具有一个8×8 RGB LED矩阵、一个五按钮操纵杆、一个陀螺仪、一个加速度计、一个磁力计、一个温度传感器、一个气压传感器和一个湿度传感器，所有这些都集成在一个包中，如[图8-1](ch08.xhtml#ch08fig1)所示。
- en: '![image](../images/f0112-01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0112-01.jpg)'
- en: '**FIGURE 8-1:** Raspberry Pi Sense HAT'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-1：** Raspberry Pi Sense HAT'
- en: '**Mounting the Board**'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安装电路板**'
- en: '**NOTE**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Sense HAT is not compatible with Raspberry Pi 1 Model A and B, but you
    can build the project using the emulator if you have an incompatible board.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sense HAT与Raspberry Pi 1 Model A和B不兼容，但如果你有不兼容的板子，可以使用模拟器来构建这个项目。*'
- en: This project doesn’t require much hardware assembly—you just need to mount the
    Sense HAT on the Pi, and the rest is done in code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目不需要太多的硬件组装——你只需要将Sense HAT安装到Pi上，剩下的工作都在代码中完成。
- en: Attach the 40 GPIOs on the Sense HAT to the 40 GPIOs on your Raspberry Pi; the
    boards should line up perfectly. When you first successfully mount the Sense HAT
    on a powered Pi, the LED matrix displays an illuminated rainbow background as
    shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将Sense HAT上的40个GPIO引脚连接到Raspberry Pi上的40个GPIO引脚；两块板子应该完全对齐。当你第一次成功地将Sense HAT安装到一个通电的Pi上时，LED矩阵会显示一个发光的彩虹背景，如[图8-2](ch08.xhtml#ch08fig2)所示。
- en: '![image](../images/f0113-01.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0113-01.jpg)'
- en: '**FIGURE 8-2:** Sense HAT welcome rainbow'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-2：** Sense HAT欢迎彩虹'
- en: '**Using the Sense HAT Emulator**'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用Sense HAT模拟器**'
- en: If you don’t have a Sense HAT or a compatible board, or if you just want to
    test the script first, you can use the Sense HAT emulator to build the Pong game
    on your computer. The emulator is a virtual Sense HAT that you can interact with
    to test your scripts. To launch it from the Desktop main menu, go to **Programming**
    ▸ **Sense HAT Emulator**. This opens the emulator window, shown in [Figure 8-3](ch08.xhtml#ch08fig3).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Sense HAT或兼容的板子，或者你只想先测试脚本，可以使用Sense HAT模拟器在你的计算机上构建Pong游戏。模拟器是一个虚拟的Sense
    HAT，你可以与其互动来测试脚本。要从桌面主菜单启动它，进入**编程** ▸ **Sense HAT模拟器**。这将打开模拟器窗口，如[图8-3](ch08.xhtml#ch08fig3)所示。
- en: '![image](../images/f0113-02.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0113-02.jpg)'
- en: '**FIGURE 8-3:** Sense HAT Emulator window'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-3：** Sense HAT模拟器窗口'
- en: The Sense HAT emulator comes with examples stored in **File** ▸ **Examples**;
    just select the example you want and then run the file to see the code in action
    in the emulator window.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT模拟器自带一些存储在**文件** ▸ **示例**中的示例；只需选择你想要的示例，然后运行文件，在模拟器窗口中查看代码效果。
- en: '**WORKING WITH SENSE HAT FUNCTIONS AND CONTROLS**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Sense HAT功能和控制**'
- en: Before you go right into building the game, it’s important to understand how
    to control the LED matrix and read inputs from the joystick. Let’s look at some
    examples that you’ll use later in the Pong script.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建游戏之前，了解如何控制LED矩阵和读取操纵杆输入是非常重要的。让我们看一些你将在Pong脚本中使用的示例。
- en: '**Controlling the LED Matrix**'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**控制LED矩阵**'
- en: The Sense HAT LED matrix has 8 columns and 8 rows, containing a total of 64
    RGB LEDs. You can display text and create images on the matrix by controlling
    each LED individually. You can also set the color of each LED.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT LED矩阵有8列和8行，共有64个RGB LED。你可以通过单独控制每个LED来显示文本和创建图像。你还可以设置每个LED的颜色。
- en: '**Displaying Text**'
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示文本**'
- en: The code in [Listing 8-1](ch08.xhtml#ch08list1) displays the scrolling text
    “Hello World!” in blue on the dot matrix.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list1)中的代码会在点阵上以蓝色显示滚动文本“Hello World!”。'
- en: '**LISTING 8-1:** Display text on the Sense HAT LED matrix'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8-1：** 在Sense HAT LED矩阵上显示文本'
- en: '[PRE19]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First import the `SenseHat` class ➊. If you’re using the emulator, delete or
    comment out this line and uncomment the code at ➋.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`SenseHat`类 ➊。如果你使用的是模拟器，请删除或注释掉这一行，并取消注释➋处的代码。
- en: 'The `show_message()` function ➌ accepts the message to display—a text string—as
    the first parameter, and then takes several options as further parameters:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_message()` 函数 ➌ 接受要显示的消息——文本字符串——作为第一个参数，然后接受多个选项作为进一步的参数：'
- en: '**NOTE**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The sense_hat library uses the British spelling “colour,” so you must use
    “colour” throughout your code.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*sense_hat 库使用英国拼写“colour”，因此你必须在代码中使用“colour”。*'
- en: Use `text_colour = [*r*, *g*, *b*]` to set the RGB color of the text, replacing
    `*r*, *g*, *b*` with integers between `0` and `255` (as you did in [Project 5](ch05.xhtml#ch05)).
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `text_colour = [*r*, *g*, *b*]` 来设置文本的 RGB 颜色，将 `*r*, *g*, *b*` 替换为介于 `0`
    和 `255` 之间的整数（就像你在[项目 5](ch05.xhtml#ch05)中做的那样）。
- en: Use `scroll_speed = *x*`, where x is a float, to control the speed at which
    text moves across the display. The default scrolling speed is set to pause for
    0.1 seconds each time the text shifts one pixel to the left.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `scroll_speed = *x*`，其中 x 是一个浮点数，来控制文本在显示屏上滚动的速度。默认的滚动速度设置为每次文本向左移动一个像素时暂停
    0.1 秒。
- en: Use `back_colour = [*r*, *g*, *b*]` to set the background color, replacing `*r*,
    *g*, *b*` with integer values as with `text_colour`.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `back_colour = [*r*, *g*, *b*]` 来设置背景颜色，将 `*r*, *g*, *b*` 替换为与 `text_colour`
    相同的整数值。
- en: '**Controlling Specific LEDs**'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制特定的 LED**'
- en: To control individual LEDs, you refer to each LED you want to light by its position
    in the matrix. For that, the Sense HAT uses an (x, y) coordinate system. For example,
    the LEDs in [Figure 8-4](ch08.xhtml#ch08fig4) have the coordinates listed next
    to the diagram.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制单个 LED，你需要通过它在矩阵中的位置来引用每个想要点亮的 LED。为此，Sense HAT 使用 (x, y) 坐标系统。例如，[图 8-4](ch08.xhtml#ch08fig4)中的
    LED 坐标就在图示旁边列出。
- en: '![image](../images/f0115-01.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0115-01.jpg)'
- en: '**FIGURE 8-4:** Sense HAT coordinate system'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-4：** Sense HAT 坐标系统'
- en: To light up the LEDs in [Figure 8-4](ch08.xhtml#ch08fig4) with their corresponding
    colors, you’d use the code in [Listing 8-2](ch08.xhtml#ch08list2).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用对应的颜色点亮[图 8-4](ch08.xhtml#ch08fig4)中的 LED，你可以使用[清单 8-2](ch08.xhtml#ch08list2)中的代码。
- en: '**LISTING 8-2:** Using `set_pixel()` to light particular LEDs'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8-2：** 使用 `set_pixel()` 点亮特定的 LED'
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function `sense.set_pixel(*x*, *y*, *r*, *g*, *b*)` lights up a specific
    LED, in which x is the x-coordinate; y is the y-coordinate; and r, g, and b set
    the color.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `sense.set_pixel(*x*, *y*, *r*, *g*, *b*)` 点亮特定的 LED，其中 x 是 x 坐标；y 是 y 坐标；r、g
    和 b 设置颜色。
- en: '**Displaying a Picture**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示图片**'
- en: Rather than controlling individual LEDs, you can use the function `sense.set_pixels()`
    to more quickly display an image. Instead of entering coordinates, you insert
    a list for all 64 LEDs that determines the color of each LED. Take a look at the
    code in [Listing 8-3](ch08.xhtml#ch08list3), which displays a sad face.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与其控制单个 LED，你可以使用函数 `sense.set_pixels()` 来更快速地显示图像。你可以插入一个包含所有 64 个 LED 颜色的列表，而不是输入坐标。看看[代码清单
    8-3](ch08.xhtml#ch08list3)，它显示了一个悲伤的表情。
- en: '**LISTING 8-3:** Displaying an image with `set_pixels()`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8-3：** 使用 `set_pixels()` 显示图像'
- en: '[PRE21]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The red Xs in the `sad_face` array won’t appear red in your code. We’re just
    highlighting them so it’s easier to visualize how the LEDs will look.*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 `sad_face` 数组中的红色 X 不会在你的代码中显示为红色。我们只是用红色 X 来突出它们，这样更容易可视化 LED 的显示效果。*'
- en: 'You create a variable to store the color of the lit LEDs (`X`), and a variable
    to store the color of the background (`N`)—you can set the background to any color
    or set it to `0` to keep it unlit. Then you need to create an array that sets
    each of the 64 LEDs either to `X` or to `N`. [Figure 8-5](ch08.xhtml#ch08fig5)
    shows the end result of the code in [Listing 8-3](ch08.xhtml#ch08list3):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个变量来存储点亮的 LED 的颜色（`X`），另一个变量来存储背景颜色（`N`）——你可以将背景设置为任何颜色，或者设置为 `0` 使其保持不亮。然后你需要创建一个数组，将每个
    64 个 LED 设置为 `X` 或 `N`。[图 8-5](ch08.xhtml#ch08fig5) 显示了[清单 8-3](ch08.xhtml#ch08list3)中的代码执行后的结果：
- en: '![image](../images/f0116-01.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0116-01.jpg)'
- en: '**FIGURE 8-5:** Displaying a sad face on the LED matrix'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-5：** 在 LED 矩阵上显示一个悲伤的表情'
- en: You can include as many colors as you want in your drawing; you just need to
    change the color parameters. We encourage you to practice working with the LED
    matrix by changing the colors and drawing your own images.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的绘图中，你可以包含任意多的颜色；你只需要更改颜色参数。我们鼓励你通过更改颜色并绘制自己的图像来练习使用 LED 矩阵。
- en: Now that you know how to control the LED matrix, let’s look at how to program
    the joystick.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何控制 LED 矩阵了，接下来我们来看如何编程控制摇杆。
- en: '**Reading Data from the Joystick**'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从摇杆读取数据**'
- en: 'The joystick that comes with the Sense HAT has five control options:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 随 Sense HAT 一起提供的摇杆有五个控制选项：
- en: Move up
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上移动
- en: Move down
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下移动
- en: Move right
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右移动
- en: Move left
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左移动
- en: Press
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下
- en: 'You need to tell your program what each control option should make the Pi do.
    The script in [Listing 8-4](ch08.xhtml#ch08list4) sets the events associated with
    each joystick control, and displays a message on the computer screen saying which
    control was used:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉程序每个控制选项应该让 Pi 做什么。[列表 8-4](ch08.xhtml#ch08list4)中的脚本设置了与每个摇杆控制相关联的事件，并在计算机屏幕上显示哪个控制被使用的信息：
- en: '**LISTING 8-4:** Associating events with each joystick control'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8-4：** 将事件与每个摇杆控制关联'
- en: '[PRE22]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, you need to tell your Pi what action to take when each joystick control
    is triggered. You do that by defining a series of functions to perform actions.
    For example, when the joystick is moved up, you call the function `move_up()`
    ➊ to print the message `joystick was moved up`. The `event` argument tells the
    Pi that the joystick will be sending information to those functions. Then you
    use `sense.stick.direction_up = move_up` ➋ to associate the `move_up` function
    with the up movement of the joystick.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要告诉你的Pi在每个摇杆控制被触发时应该采取什么行动。你通过定义一系列函数来执行这些动作。例如，当摇杆被向上移动时，你调用`move_up()`函数➊来打印消息`joystick
    was moved up`。`event`参数告诉Pi摇杆将向这些函数发送信息。然后，你使用`sense.stick.direction_up = move_up`➋将`move_up`函数与摇杆的向上移动关联起来。
- en: The other movement functions work in the same way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的运动功能也以相同的方式工作。
- en: '**WRITING THE SCRIPT**'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写脚本**'
- en: Now that you know how to display text and drawings on the LED matrix and how
    to make something happen when the joystick is used, you’re ready to start writing
    the script for your game.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道了如何在LED矩阵上显示文本和图形，以及如何在摇杆使用时触发某些事件，你已经准备好开始编写游戏脚本了。
- en: 'Here’s what the game aims to do:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏的目标：
- en: A bat that is 3 pixels long and 1 pixel wide should appear in column 0.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长3像素、宽1像素的球拍应该出现在第0列。
- en: Each time you move the joystick up or down, the bat should move correspondingly.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次你移动摇杆向上或向下时，球拍应该相应地移动。
- en: The ball should start in a random position and move diagonally.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球应该从一个随机位置开始并朝对角线移动。
- en: When the ball hits something—walls, ceiling, or the bat—it should move diagonally
    in the opposite direction.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球碰到某物——墙壁、天花板或球拍——时，它应该朝相反的方向对角线移动。
- en: If the ball hits column 0, it means you missed the ball, so you lose and the
    game is over.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果球击中第0列，意味着你错过了球，那么你就输了，游戏结束。
- en: '**Entering the Script**'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**输入脚本**'
- en: Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new script.
    Then copy the code in [Listing 8-5](ch08.xhtml#ch08list5) to the new file and
    save the script as *pong_game.py* inside the *Displays* folder (remember that
    you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Python 3 (IDLE)**，然后点击**文件** ▸ **新建文件**来创建一个新的脚本。接着将[列表 8-5](ch08.xhtml#ch08list5)中的代码复制到新文件中，并将脚本保存为*pong_game.py*，存放在*Displays*文件夹内（记得你可以在*[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*下载所有脚本）。
- en: '**LISTING 8-5:** The Pong game code'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8-5：** Pong 游戏代码'
- en: '[PRE23]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There’s a lot going on in this code. Let’s walk through it step by step.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了很多事情。让我们一步一步地解析它。
- en: '**Importing Necessary Libraries**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入必要的库**'
- en: At ➊, you import the `randint()` function from the rand library to generate
    pseudorandom integers and the `sleep()` function from the time library to set
    delay times.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，你从rand库导入了`randint()`函数，用来生成伪随机整数，从time库导入了`sleep()`函数，用来设置延迟时间。
- en: At ➋, you create an object called `sense` that will be used to refer to the
    Sense HAT throughout the code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，你创建了一个名为`sense`的对象，它将在代码中引用Sense HAT。
- en: '**Creating the Bat**'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建球拍**'
- en: The bat is a 3-pixel bar that moves up and down the leftmost column. At ➌, you
    define the bat’s starting position at 4 pixels down from the top with `y = 4`.
    The complete bat is drawn in green within the `draw_bat()` function ➏, which adds
    one more pixel to the top of the starting position (`y - 1`) and to the bottom
    (`y + 1`) to make the bat 3 pixels long.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 球拍是一个3像素长、1像素宽的条形，移动在最左侧的列上。在➌处，你定义了球拍的起始位置为从顶部向下4像素，`y = 4`。完整的球拍在`draw_bat()`函数中以绿色绘制➏，它在起始位置的顶部（`y
    - 1`）和底部（`y + 1`）各加上一个像素，使得球拍总长度为3像素。
- en: '**Moving the Bat**'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动球拍**'
- en: The bat moves just on the y-axis, so its x-coordinate is always `0`, but its
    y-coordinate needs to change as the player moves the bat. In other words, the
    player can only move the bat up and down. The `move_up()` and `move_down()` functions,
    defined at ➐, control those movements. At ➒, you tell the Pi what action to take
    when the player moves the joystick up or down by calling `move_up()` and `move_down()`,
    respectively.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 球拍仅在y轴上移动，因此它的x坐标始终为`0`，但随着玩家移动球拍，y坐标需要变化。换句话说，玩家只能上下移动球拍。`move_up()`和`move_down()`函数（在➐处定义）控制这些移动。在➒处，你通过调用`move_up()`和`move_down()`分别告诉Pi当玩家向上或向下移动操纵杆时采取什么动作。
- en: 'Take a closer look at the `move_up()` function (the `move_down()` function
    works in a similar way):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看`move_up()`函数（`move_down()`函数的工作方式类似）：
- en: '[PRE24]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `move_up()` function accepts `event` as a parameter. Basically, the `event`
    parameter allows you to pass some information about the joystick to the function—such
    as the time the stick was used; the direction it was pushed; and if it was pressed,
    released, or held—so the Pi knows how to react.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_up()`函数接受`event`作为参数。基本上，`event`参数允许你将一些有关操纵杆的信息传递给函数——比如操纵杆使用的时间、推动的方向，以及它是被按下、释放还是保持——这样Pi就知道如何做出反应。'
- en: '**HINT**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*Writing* `y -= 1` *in Python is equal to* `y = y - 1`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Python中*写`y -= 1` *等同于* `y = y - 1`。'
- en: When the player moves the joystick up, the function moves the y-coordinate of
    the bat up by subtracting `1` from the variable `y`. But first, the code checks
    that `y > 1`; otherwise, the bat may end up moving out of the matrix.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家向上移动操纵杆时，函数通过从变量`y`中减去`1`来将球拍的y坐标向上移动。但首先，代码检查`y > 1`；否则，球拍可能会移动出矩阵。
- en: '**Declaring Variable Scope**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**声明变量作用域**'
- en: 'Note that `y` is defined as a `global` variable. Not all variables in a program
    are accessible at all locations in the program, so there might be areas where
    it is invalid to call a certain variable. A variable’s *scope* is the area of
    a program where it is accessible. In Python, there are two basic variable scopes:
    *local* and *global*.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`y`被定义为`global`变量。并非程序中的所有变量都可以在程序的所有位置访问，所以可能有些地方无法调用某些变量。变量的*作用域*是程序中可以访问它的区域。在Python中，有两种基本的变量作用域：*局部*和*全局*。
- en: A variable defined in the main code body is global, meaning it is accessible
    anywhere else in the code. A variable defined inside a function is local to that
    function, so what you do with the local variable inside the function has no effect
    on variables outside, even if they have the same name.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在主代码主体中定义的变量是全局的，这意味着它可以在代码中的其他任何地方访问。在函数内部定义的变量是局部变量，所以在函数内部对局部变量的操作不会影响外部的变量，即使它们有相同的名称。
- en: As you want `y` to be usable both inside the function where it is defined and
    throughout the code, it needs to be declared as `global`. Otherwise, when you
    move the joystick nothing will happen, because the `y` variable is just being
    changed inside the function and not in the main body of the code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你希望`y`在定义它的函数内以及整个代码中都能使用，所以它需要被声明为`global`。否则，当你移动操纵杆时，什么也不会发生，因为`y`变量只是在函数内部发生了变化，而不是在代码的主主体中发生变化。
- en: '**Creating the Ball**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建球**'
- en: To make a moving ball, you first need a starting position and a velocity. At
    ➍, you set the ball’s starting position using a list. Lists are defined between
    square brackets, `[*0th element*, *1st element*, ..., *nth element*]`, and each
    element is separated by a comma. The elements in the lists have *zero indexing*,
    meaning the index for the first element is 0, not 1\. In this case, our 0th element
    is the x-position, and the 1st element is the y-position.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个移动的球，首先需要一个起始位置和一个速度。在➍处，你使用列表设置球的起始位置。列表是由方括号定义的，`[*第0个元素*，*第1个元素*，...，*第n个元素*]`，每个元素之间用逗号分隔。列表中的元素是*零索引*，这意味着第一个元素的索引是0，而不是1。这里，我们的第0个元素是x坐标，第1个元素是y坐标。
- en: When you start the game, the ball is in a random position, generated by the
    `randint()` function. That random position can be between 1 and 6 for the y-axis
    and 2 and 6 for the x-axis. These numbers ensure that the ball doesn’t start on
    the ceiling, walls, or next to the bat.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始游戏时，球的位置是随机的，由`randint()`函数生成。该随机位置的y轴范围是1到6，x轴范围是2到6。这些数字确保球不会出现在天花板、墙壁或球拍旁边。
- en: '**Moving the Ball**'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动球**'
- en: Once you have a starting position for the ball, you need to give it a velocity
    ➎ to get it moving. You create a list for the ball’s velocity in which the 0th
    element is the velocity for the x-coordinate and the 1st element is the velocity
    for the y-coordinate.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为小球设置了起始位置，你需要给它一个速度 ➎ 使其开始移动。你创建了一个小球速度的列表，其中第0个元素是x坐标的速度，第1个元素是y坐标的速度。
- en: You need to add or subtract the velocity to or from the current ball position
    to make the ball move forward or backward, respectively. The `draw_ball()` function
    at ➑ is where you display and move the ball, which always moves in diagonals.
    If it goes forward it continues forward, and if it goes backward it continues
    backward, unless it hits the ceiling or the bat, in which case it goes in the
    opposite direction.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将速度加到或从当前小球位置中减去，使小球向前或向后移动。➑处的`draw_ball()`函数是用来显示和移动小球的地方，小球总是沿对角线移动。如果它向前，它就会继续向前；如果它向后，它就会继续向后，除非它碰到天花板或球拍，这时它会反向移动。
- en: '**Keeping the Game Running**'
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**保持游戏运行**'
- en: Once everything is set up, you add a `while` loop to keep the game running ➓.
    The `while` loop starts by cleaning the display; then, it calls the function `draw_bat()`
    to draw the bat and `draw_ball()` to display the ball.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切准备就绪，你就可以添加一个`while`循环来保持游戏运行 ➓。`while`循环从清除显示开始；然后，它调用`draw_bat()`函数来绘制球拍，并调用`draw_ball()`来显示小球。
- en: The `sleep()` function in the last line defines the time the ball takes to move
    to another position, so you can use this function to determine how fast the ball
    moves. If you increase the delay time, the game becomes slower and easier; if
    you decrease it, the game moves faster. We encourage you to experiment with different
    delay times.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行中的`sleep()`函数定义了小球移动到另一个位置所需的时间，因此你可以使用此函数来决定小球的移动速度。如果增加延迟时间，游戏会变慢且更容易；如果减少延迟时间，游戏会加速。我们鼓励你尝试不同的延迟时间。
- en: '**Running the Script**'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运行脚本**'
- en: 'Congratulations! After a lot of programming, you have your reward: you can
    play Pong on your Sense HAT! Press **F5** or go to **Run** ▸ **Run Module** to
    run the script.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！经过大量编程，你获得了回报：你可以在你的Sense HAT上玩Pong游戏！按**F5**或者进入**Run** ▸ **Run Module**来运行脚本。
- en: When you lose and the game ends, the LED matrix displays a sad face as shown
    in [Figure 8-6](ch08.xhtml#ch08fig6).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输了且游戏结束时，LED矩阵会显示一个悲伤的表情，如[图8-6](ch08.xhtml#ch08fig6)所示。
- en: '![image](../images/f0123-01.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0123-01.jpg)'
- en: '**FIGURE 8-6:** LED matrix displaying a sad face when the game ends'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-6：** 游戏结束时LED矩阵显示悲伤的表情'
- en: '**TAKING IT FURTHER**'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步提升**'
- en: 'Here are some ideas to upgrade your game:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些升级游戏的想法：
- en: Decrease the delay time as the game continues to increase the level of difficulty.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着游戏的进行，减少延迟时间以增加游戏的难度。
- en: Add a scoring system so that you earn a point every time the ball hits the bat,
    and display the score on the screen.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个得分系统，每次小球击中球拍时得一分，并在屏幕上显示分数。
- en: Insert a condition that restarts the game when you press the joystick.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入一个条件，当你按下操纵杆时重新开始游戏。
