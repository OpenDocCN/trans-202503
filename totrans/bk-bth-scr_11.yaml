- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 CALLING ROUTINES AND BAT FILES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, I introduced labels and nonsequential execution, both
    of which also play a major part in this chapter. I’ll soon introduce a new twist
    on an already discussed command, allowing you to create and call a routine defined
    by a label. Instead of simply handing control over to the code just after the
    label, control is returned to the place from where it was called after the routine
    executes. As you write more complex and interesting bat files, you’ll want a full
    understanding of routines.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](chapter8.xhtml), I introduced the concept of calling executables
    compiled in other languages. I’ll expand on that discussion here, describing different
    techniques for one bat file calling another bat file. You’ll obviously learn about
    the most typical type of call, one that returns control to the calling bat file.
    But you’ll also learn techniques for relinquishing control to the called bat file
    and how to spawn a second parallel Batch process. In addition, you’ll explore
    different ways to exit from a routine or bat file gracefully, with or without
    a return code.
  prefs: []
  type: TYPE_NORMAL
- en: The call Command, Revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can create callable internal routines, you must understand the similarities
    and differences between two commands that work with labels. One is the call command
    first introduced in [Chapter 8](chapter8.xhtml), where we used it to call programs
    compiled in other languages. The other is the goto command, introduced in [Chapter
    9](chapter9.xhtml) for altering the execution flow of a bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare and contrast the two commands, recall this code from [Chapter 9](chapter9.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The goto command skipped the middle echo command, resulting in this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the contrast, [Listing 10-1](#Lis10-1) changes every instance
    of goto in that code to call, including both the goto command and the text in
    the echo commands, while leaving everything else identical in this very concise
    bat file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: A short bat file demonstrating the call command'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the bat file from [Listing 10-1](#Lis10-1), and you’ll get the four
    lines shown in [Listing 10-2](#Lis10-2) written to the console, not the three
    some may have expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: The results written to the console when executing [Listing 10-1](#Lis10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The display of Before CALL obviously executes right off the bat (pun intended).
    The call command temporarily hands control to the code just after the label, resulting
    in After LABEL being displayed. When this was a goto command, that was it; the
    bat file ended after that display. But with the call command, after everything
    between :MyLabel and the end of the bat file executes, control returns to the
    command immediately after the call command. Hence, After CALL is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Some might expect the execution to be completed at this point, but the interpreter
    next encounters :MyLabel again. We aren’t calling it or going to it; instead,
    it’s just the next line of code. Notice that I didn’t call it a command or even
    a statement. It’s just a line of code, a placeholder, and in this context, little
    more than a very subtle speed bump on the path to the next command. The interpreter
    moves on to the last line in the bat file, and the text After LABEL is displayed
    a second time. The interpreter finds no other command to interpret, and the bat
    file is done.
  prefs: []
  type: TYPE_NORMAL
- en: While the goto command relinquishes control, the call command remembers from
    where it came and returns to that spot when its business is done. We now have
    the makings of a callable internal routine, and we’ll be calling that routine
    with the call command.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Internal Routines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As your Batch code gets more interesting, you’ll want to execute a bit of code
    multiple times from various locations in a bat file. For instance, you might want
    to call an executable more than once, or you might want to periodically check
    a directory for some files in need of copying. When we get to interactive Batch,
    you might want to ask the user a question and get a response several times.
  prefs: []
  type: TYPE_NORMAL
- en: Faced with a need for multiple invocations of a section of code, a novice coder
    might resort to cutting and pasting—a loathsome and odious option in my exceedingly
    judgmental (but accurate) opinion. A far better solution is to create an internal
    routine and call it from those multiple locations. You can even place some code
    that’s called only once into a routine just to better organize your bat file.
    Sometimes it’s perfectly fine to run right through a label, but more times than
    not, you’ll want to create a routine that can be invoked only by calling it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following exercise, I’ll take [Listing 10-1](#Lis10-1) and reconfigure
    it so that the label defines a callable routine. That is, the execution flow will
    call the routine, return from it, and exit the bat file before falling through
    to that routine again. To this end, I’ll need a way to terminate both the routine
    and bat file. The final display of After LABEL that appears in [Listing 10-2](#Lis10-2)
    will be no more. Instead, we’ll expect these three lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code, which looks quite a bit different, does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before stepping through the code, notice the three goto :eof commands. As you
    might expect, the first one ❷ jumps to the *end of file*, ceasing the bat file.
    The other two ❹ ❻ are something quite different—something new.
  prefs: []
  type: TYPE_NORMAL
- en: After the initial echo command, the call command ❶ invokes the routine that
    :MyLabel ❸ defines, which contains just two commands. The first is the familiar
    echo of After LABEL to the console, and the second is a goto :eof command ❹. Because
    this command is being executed after a label is called, it ends not the file but
    the routine, and control returns to the command just after the call command ❶,
    writing After CALL to the console. Finally, the main goto :eof command ❷ exits
    the bat file, because the interpreter knows that it isn’t in a routine.
  prefs: []
  type: TYPE_NORMAL
- en: When inside the :MyLabel ❸ routine, going to :eof (or *end of file*) is a misnomer;
    it’s really more of an *end of routine*, but let’s not quibble over semantics.
    If you remove this goto :eof command ❹, control would’ve continued through to
    the code under :AnotherLabel ❺ before returning to the mainline logic. But with
    this command ❹, the code under :AnotherLabel never executes.
  prefs: []
  type: TYPE_NORMAL
- en: Since the goto :eof command has two distinct uses, I usually follow such commands
    with a remark defining exactly what it’s terminating, either the name of the routine
    or the bat file itself. I’m simply placing the rem command after an ampersand,
    which separates the two commands on a single line of code. Programmatically, it’s
    not necessary, but this practice very much enhances the code’s readability, especially
    when the routines become longer and more complex than the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Bat Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Short or repetitive bits of code are great candidates for internal routines;
    you can add one or more routines to the end of a bat file to create a well-organized
    module of which you can be proud. But sometimes those short bits of code aren’t
    so short, or they are so useful that you would like to make them available to
    other bat files written by you and maybe even others. Instead of a routine, this
    scenario calls for one bat file calling another bat file. For instance, you might
    create a single bat file to handle logging and call it from multiple other bat
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing one bat file from another works a bit differently than executing
    an internal routine. But first, let’s return to how a compiled program is executed
    from [Chapter 8](chapter8.xhtml). When the interpreter comes across a line of
    code that’s simply the name of an executable, it invokes the executable. Hence,
    this “command” executes the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the program completes its task, control returns to the bat file. You
    might expect the calling of a bat file to work the same way, but alas, it does
    not. However, the following line of code indeed executes the called bat file,
    but with an enormous batveat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That batveat is simple: control never returns to the calling bat file. The
    entire process ends when the called bat file ends. The vast majority of the time
    you’ll want control returned; otherwise, there wouldn’t be much point in coding
    anything after the invocation of the called bat file. To see control returned,
    you can insert the call command just before the called bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To sum up, whether calling bat files or compiled executables of another language,
    you can use the call command or omit it, but there’s a difference. When calling
    an executable, both techniques are virtually identical. When calling a fellow
    bat file, the call command ensures that control is returned to the caller. Without
    the command, control never returns.
  prefs: []
  type: TYPE_NORMAL
- en: Since I’ve never found a use for a non-returning bat file invocation, my preference
    always is to omit the call command for executables and use it for bat files. One
    advantage is that at a glance, it’s obvious what type of file is being called.
  prefs: []
  type: TYPE_NORMAL
- en: Early in my career, I learned about the need for the call command vis-à-vis
    bat files the hard way when I couldn’t figure out why my bat file just stopped
    executing. There was no hang or abort message; it just stopped. Complicating matters,
    my troubleshooting was understandably focused on the called bat file. It took
    quite a while before I noticed the missing call command and, more important, understood
    its significance. But that isn’t the only idiosyncrasy concerning the call command.
  prefs: []
  type: TYPE_NORMAL
- en: Notes on Calling a Label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, I mentioned that it’s possible to leave the colon off
    the label name in the argument of the goto command, although including it is highly
    encouraged. With the call command, the colon is always required when calling a
    label defining an internal routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This apparent incongruity might not make sense until you consider that the
    goto command is concerned only with going to labels inside its bat file, while
    the call command calls entities inside and outside of its bat file. The upshot
    is that something very unexpected happens when an attempt to call :MyLabel is
    invoked without the colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A colon would’ve told the interpreter to call an internal routine, but instead
    the interpreter tries to call an external file. First it looks for an executable,
    such as *MyLabel.com* or *MyLabel.exe*, in the current directory. Then it looks
    for *MyLabel.bat* and a few other types of executables with this filename, also
    in the current directory. Then it goes through all the directories in the path
    variable desperately looking for anything named MyLabel that it can execute. If
    no such file is found, the interpreter won’t look for a label of that name, even
    if :MyLabel is a valid label in the bat file; instead, it generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: When navigating to a label with either the goto or call command, always use
    the colon, for consistency’s sake if nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 9](chapter9.xhtml), I mentioned that the goto command aborts a
    process when the label isn’t found. The call command is a little more forgiving.
    They both write out an error message when its argument is an invalid label, but
    the call command also sets errorlevel to 1\. If you choose not to interrogate
    the return code, the process continues on cavalierly as if nothing is amiss. (See
    [Chapter 28](chapter28.xhtml) for more details on how to handle a failed call
    command.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Launching Bat Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might want to launch or spawn a bat file as a new process. That
    is, you may wish to kick off another bat file but don’t want the interpreter to
    wait around for it to finish up before continuing. For instance, you can execute
    multiple processes in parallel to speed up overall processing time. You can spin
    off a noncritical but time-consuming task, perhaps a logging process, to execute
    on its own time. In [Chapter 26](chapter26.xhtml), I’ll discuss how to automatically
    kill and restart a process that’s hung. To make this happen, I’ll spawn the process
    susceptible to hanging as an independent bat file and monitor it from the main
    bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch or spawn a bat file, simply use the start command in lieu of the
    call command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a second command or DOS window where the file *LaunchedBat.bat*
    executes simultaneously with the bat file that started it.
  prefs: []
  type: TYPE_NORMAL
- en: The exit Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exit command, as you might imagine, exits routines, bat files, or entire
    executions, and it can even set a return code. It overlaps in functionality with
    the goto :eof command, but I’ll soon show a significant distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exit command with no arguments abruptly ends the entire process. Sadly,
    the second echo command won’t be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first echo command writes its message to the console, but the exit command
    closes the window before you can read it. This happens regardless of where the
    exit command is invoked—in the high-level bat file, in a called bat file, or even
    in a routine in either type of bat file. This variant of the command is analogous
    to a sledgehammer.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the /B option turns the exit command into more of a jewelry mallet.
    The documentation is unclear as to what B represents, but for me it stands for
    *break* in that the following command breaks out of just the code being invoked,
    whether it’s a called bat file or a routine inside a bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command exits the entire process only if invoked in the main logic of the
    high-level bat file. It doesn’t change errorlevel and is logically equivalent
    to goto :eof. Both commands are valid, and the usage usually comes down to personal
    preference. Mine is the goto :eof command, but only in those instances when I
    don’t need the return code.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of [Chapter 9](chapter9.xhtml), I referenced the rudimentary
    abort logic reproduced in [Listing 10-3](#Lis10-3) but left its explanation for
    later, which is now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: An abort routine labeled as :Abort'
  prefs: []
  type: TYPE_NORMAL
- en: 'This exit command behaves just like exit /B with one exception. When control
    is returned to where the code was called, the command’s numerical argument following
    the option becomes the new value contained in errorlevel. In short, the command
    breaks out of a bat file or routine and returns an exit or return code. In the
    prior example, the return code is 1. But if no errors are detected, the main logic
    of a bat file might end by setting the return code to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If a fatal error is detected, a goto :Abort command from the mainline logic
    will direct the interpreter to the abort logic shown in [Listing 10-3](#Lis10-3).
    The goto command must be used because a call command would treat the abort logic
    like a called routine; the errorlevel would be set, but control would be returned
    to the spot of the fatal error. But when navigating to the label with the goto
    command, a routine isn’t invoked; it’s still considered to be in the mainline
    logic, and the exit command ends the bat file instead of a routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this more flexible, you can create a variable for the exit code, setting
    it to different values for different failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then this logic can be accessed via multiple goto commands in the bat file.
  prefs: []
  type: TYPE_NORMAL
- en: (A real-world abort routine will be far more interesting than this simple echo
    command. The error message could be multiple lines and have variable content,
    all written to a logfile as well as the console, but I’ve simplified it here to
    keep the focus on the exit command.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I’ve detailed the different methods of calling internal routines
    and other bat files. You’ve learned how to return from those calls with or without
    a return code, or how to simply end the entire process abruptly from anywhere.
    You also learned how to launch or spawn another bat file, which is entirely independent
    of the first bat file. Above all else, you now understand the significant and
    subtle differences between the goto and call commands. In a nutshell, the call
    returns control and can reach outside of its bat file, while the goto does neither.
  prefs: []
  type: TYPE_NORMAL
- en: One large piece remains in this puzzle. A calling bat file can pass multiple
    arguments to a called bat file, and that called bat file can even set and pass
    back parameters in return. There’s more to this than one might expect, and I’ll
    detail all of the nuances in the very next chapter.
  prefs: []
  type: TYPE_NORMAL
