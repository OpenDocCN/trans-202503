<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Web APIs"><div class="titlepage"><div><div><h1 class="title"><a id="web_apis"/>Chapter 14. Web APIs</h1></div></div></div><p><a class="indexterm" id="iddle1639"/><a class="indexterm" id="iddle1773"/><a class="indexterm" id="iddle1783"/><a class="indexterm" id="iddle2328"/>Eventually, you might want to expand your application beyond your website.
        Popular web applications usually also have a native mobile client and sometimes even a
        desktop client. You may also want to integrate data from your application with other
        websites and applications.</p><p>A web <span class="emphasis"><em>application programming interface</em></span> (or
          <span class="emphasis"><em>API</em></span>) makes all of these things possible. Think of an API as a
        language that applications use to communicate with each other. On the Web, the API is
        usually a REST protocol using JavaScript Object Notation (JSON) messages.</p><p>In this chapter, we’ll explore the GitHub API to see how to access detailed
        information about users and repositories. After discussing GitHub’s API, you’ll
        build your own. In the process, I’ll cover details such as JSON, the Hypertext
        Transfer Protocol (HTTP), and token-based authentication.</p><div class="sect1" title="The GitHub API"><div class="titlepage"><div><div><h1 class="title"><a id="github_api"/>The GitHub API</h1></div></div></div><p><a class="indexterm" id="iddle1640"/>The GitHub code-hosting service has an extensive API. Many of its features are
          even available without authentication. If you want to continue exploring the GitHub API
          after working through the examples in this chapter, complete details are available online
          at <span class="emphasis"><em><a class="ulink" href="https://developer.github.com/">https://developer.github.com/</a></em></span>.</p><p>The GitHub API provides easy access to data about users, organizations, repositories,
          and other site features. For example, go to <span class="emphasis"><em><a class="ulink" href="https://api.github.com/orgs/rails/">https://api.github.com/orgs/rails/</a></em></span> in your web browser to see the
          Rails organization on GitHub:</p><a id="pro_id00429"/><pre class="programlisting"> {
   "login": "rails",
➊  "id": 4223,
➋  "url": "https://api.github.com/orgs/rails",
   "repos_url": "https://api.github.com/orgs/rails/repos",
   "events_url": "https://api.github.com/orgs/rails/events",
   "members_url": "https://api.github.com/orgs/rails/me...",
   "public_members_url": "https://api.github.com/orgs/r...",
   "avatar_url": "https://avatars.githubusercontent.com...",
   "name": "Ruby on Rails",
   "company": null,
   "blog": "http://weblog.rubyonrails.org/",
   "location": null,
   "email": null,
   "public_repos": 73,
   "public_gists": 3,
   "followers": 2,
   "following": 0,
   "html_url": "https://github.com/rails",
➌  "created_at": "2008-04-02T01:59:25Z",
➍  "updated_at": "2014-04-13T20:24:49Z",
   "type": "Organization"
}</pre><p>The data returned should be at least partially familiar to anyone who’s worked
          with Rails models. You’ll see fields for <code class="literal">id</code> ➊,
            <code class="literal">created_at</code> ➌, and <code class="literal">updated_at</code> ➍, as
          seen in all of the models you’ve created so far. The GitHub API also includes
          several <code class="literal">url</code> fields ➋ that you can use to access more data about
          the organization.</p><p>For example, go to the <code class="literal">repos_url</code> (<span class="emphasis"><em><a class="ulink" href="https://api.github.com/orgs/rails/repos/">https://api.github.com/orgs/rails/repos/</a></em></span>) to see a list of source
          code repositories belonging to the Rails organization. From there, you can access the
          details of an individual repository by going to its <code class="literal">url</code>, such as
              <span class="emphasis"><em><a class="ulink" href="https://api.github.com/repos/rails/rails/">https://api.github.com/repos/rails/rails/</a></em></span>.</p><p>Go to <span class="emphasis"><em><a class="ulink" href="https://api.github.com/users/username/">https://api.github.com/users/username/</a></em></span> to
          access information about an individual user. To see my GitHub account, visit
              <span class="emphasis"><em><a class="ulink" href="https://api.github.com/users/anthonylewis/">https://api.github.com/users/anthonylewis/</a></em></span> in your
          browser.</p><div class="note" title="Note"><h3 class="title"><a id="ch14note01"/>Note</h3><p><a class="indexterm" id="iddle1703"/><a class="indexterm" id="iddle1704"/><a class="indexterm" id="iddle1771"/><a class="indexterm" id="iddle1781"/><a class="indexterm" id="iddle2193"/><span class="emphasis"><em>The data returned by these requests is in</em></span> JavaScript
            Object Notation (JSON) <span class="emphasis"><em>format, which is based on a subset of the JavaScript
              programming language. In JSON format, data between curly braces is a single JavaScript
              object with various named properties. Each property consists of a name, followed by a
              colon, and the property value. This format is quite similar to a hash in
              Ruby.</em></span></p></div><p>In addition to the simple requests for data you’ve made so far, the GitHub API
          also supports creating and updating objects using the appropriate requests. These actions
          require authentication, of course. But before I can cover API authentication, I need to
          tell you a little more about HTTP.</p></div><div class="sect1" title="HTTP"><div class="titlepage"><div><div><h1 class="title"><a id="http"/>HTTP</h1></div></div></div><p>HTTP is the language of the Web. Web servers and browsers use this protocol to
          communicate. I’ve discussed some aspects of HTTP already, such as the HTTP verbs
          (GET, POST, PATCH, and DELETE), while covering the REST architecture in <a class="xref" href="ch04.html" title="Chapter 4. Controllers">Chapter 4</a>.</p><p>In addition to the data you’ve seen so far, an HTTP response also contains a
          header with more detailed information. You’re probably familiar with part of the
          data in an HTTP response header. Anyone who’s spent any time on the Web has probably
          seen a 404 or 500 response from a web server. Status codes such as these are included in
          every response from a web server.</p><div class="sect2" title="Status Codes"><div class="titlepage"><div><div><h2 class="title"><a id="status_codes"/>Status Codes</h2></div></div></div><p>The first line of every response includes an HTTP status code. This three-digit
            numeric code tells the client the type of response to expect.</p><p>Status codes are broken up into five categories based on their first digit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>1<span class="emphasis"><em>xx</em></span> Informational</p></li><li class="listitem"><p>2<span class="emphasis"><em>xx</em></span> Success</p></li><li class="listitem"><p>3<span class="emphasis"><em>xx</em></span> Redirection</p></li><li class="listitem"><p>4<span class="emphasis"><em>xx</em></span> Client Error</p></li><li class="listitem"><p>5<span class="emphasis"><em>xx</em></span> Server Error</p></li></ul></div><p>You shouldn’t encounter any status codes in the 1<span class="emphasis"><em>xx</em></span> range
            while working with APIs. The original HTTP 1.0 specification did not define any codes in
            this range, and in my experience, they are rarely used.</p><p>Status codes in the 2<span class="emphasis"><em>xx</em></span> range indicate a successful request.
            Hopefully, you’ll encounter many of these. Common codes include <span class="emphasis"><em>200
              OK,</em></span> which indicates a successful response, typically to a GET request;
              <span class="emphasis"><em>201 Created,</em></span> which is returned when an object is created on the
            server in response to a POST request; and <span class="emphasis"><em>204 No Content,</em></span> which
            indicates that a request was successful, but there is no additional data in the
            response.</p><p><a class="indexterm" id="iddle1326"/><a class="indexterm" id="iddle1414"/><a class="indexterm" id="iddle1756"/><a class="indexterm" id="iddle1871"/><a class="indexterm" id="iddle2148"/>The 3<span class="emphasis"><em>xx</em></span> range of status codes indicates a redirect to a
            different address. Rails issues a <span class="emphasis"><em>302 Found</em></span> response any time you
            use <code class="literal">redirect_to</code> in your application. To see this in action, log in to
            your application and watch the log for the redirect.</p><p>Status codes in the 4<span class="emphasis"><em>xx</em></span> range indicate some kind of client
            error. In other words, the user made a mistake. <span class="emphasis"><em>401 Unauthorized</em></span> is
            returned in response to a request for a URL that requires authentication. The
              <span class="emphasis"><em>403 Forbidden</em></span> status code is similar to 401, except the server
            will not complete the request even if the client successfully authenticates. The
              <span class="emphasis"><em>404 Not Found</em></span> is sent when a client attempts to access a URL that
            does not exist. As you work with APIs, you may encounter the <span class="emphasis"><em>406 Not
              Acceptable</em></span> status code for an invalid request or the <span class="emphasis"><em>422
              Unprocessable Entity</em></span> status code, which means the request is valid, but the
            included data could not be processed.</p><p>The 5<span class="emphasis"><em>xx</em></span> range of status codes indicates an error on the server.
            The <span class="emphasis"><em>500 Internal Server Error</em></span> code is the most commonly used. It is
            a general message that does not provide any additional data. The <span class="emphasis"><em>503 Service
              Unavailable</em></span> status code indicates a temporary problem with the
            server.</p><p>To see these codes, you need to examine the HTTP header sent with a response. These
            are not normally displayed by web browsers. Luckily, tools exist that make examining
            HTTP headers easy. One of the most popular is the command-line program known as
            Curl.</p></div><div class="sect2" title="Curl"><div class="titlepage"><div><div><h2 class="title"><a id="curl"/>Curl</h2></div></div></div><p>Curl is a free command-line tool for network communication. Curl is included with
            Mac OS X and Linux, and Windows users can download the tool from <span class="emphasis"><em><a class="ulink" href="http://curl.haxx.se/">http://curl.haxx.se/</a></em></span>. Curl uses URL syntax, making it an ideal
            tool for testing web APIs.</p><p>Open a terminal window and try a few <code class="literal">curl</code> commands. Let’s
            start with the GitHub API you just looked at.</p><a id="pro_id00430"/><pre class="programlisting">$ <span class="strong"><strong>curl https://api.github.com/users/anthonylewis</strong></span>
{
  "login": "anthonylewis",
  "id": 301,
  <span class="emphasis"><em>--snip--</em></span>
}</pre><p>This example shows how to retrieve information about a particular user account from
            GitHub. Curl only shows the response data by default; enter <span class="strong"><strong><code class="literal">curl -i</code></strong></span> to include the HTTP headers with the
            response:</p><a id="pro_id00431"/><pre class="programlisting">  $ <span class="strong"><strong>curl -i https://api.github.com/users/anthonylewis</strong></span>
➊ HTTP/1.1 200 OK
  Server: GitHub.com
  Date: Thu, 17 Apr 2014 00:36:29 GMT
  Content-Type: application/json; charset=utf-8
  Status: 200 OK
➋ X-RateLimit-Limit: 60
  X-RateLimit-Remaining: 58
➌ X-RateLimit-Reset: 1397696651
  <span class="emphasis"><em>--snip--</em></span>

  {
   "login": "anthonylewis",
   "id": 301,
   <span class="emphasis"><em>--snip--</em></span>
  }</pre><p><a class="indexterm" id="iddle1063"/><a class="indexterm" id="iddle1208"/><a class="indexterm" id="iddle1419"/><a class="indexterm" id="iddle1641"/><a class="indexterm" id="iddle1642"/><a class="indexterm" id="iddle2258"/><a class="indexterm" id="iddle2343"/>The response headers start with the status code of <code class="literal">200 OK</code>
            ➊. Also note that GitHub API requests are rate limited. The
              <code class="literal">X-RateLimit-Limit: 60</code> line ➋ indicates that you are limited
            to 60 requests over a certain period of time. The next line says you have 58 requests
            remaining. Your rate limit resets automatically at the time given by the
              <code class="literal">X-RateLimit-Reset: 1397696651</code> line ➌.</p><div class="note" title="Note"><h3 class="title"><a id="ch14note02"/>Note</h3><p><span class="emphasis"><em>The number <code class="literal">1397696651</code> is a Unix timestamp. You can
                convert it to a normal time by entering <code class="literal">Time.at 1397696651</code> in an
                IRB session or Rails console.</em></span></p></div></div></div><div class="sect1" title="Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="authentication-id00031"/>Authentication</h1></div></div></div><p>So far, you’ve only read public data from the GitHub API. You can also use the
          GitHub API to read private data about users and repositories and to create or update
          information, but these actions require authentication.</p><p>I covered user authentication in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>. Users expect to log
          in to an application once and then browse a site for some time. You maintain a
          user’s log in state in the session, which is stored in a cookie that the browser
          automatically includes with every request.</p><p>API requests don’t maintain a session. Applications accessing an API need to
          provide authentication credentials with each request. A popular choice for API requests is
            <span class="emphasis"><em>token-based authentication</em></span>. In token-based authentication, users
          include a unique API token with each request.</p><p>You can use the <code class="literal">curl</code> command to test token-based authentication on
          GitHub. First, you need to generate a personal access token on GitHub’s Application
          Settings page. Log in to GitHub, if necessary, and go to <span class="emphasis"><em><a class="ulink" href="https://github.com/settings/applications/">https://github.com/settings/applications/</a></em></span>. On that page, click the
            <span class="strong"><strong>Generate New Token</strong></span> button. Next, you provide a
          description for this token; something like API Testing should be fine. Finally, confirm
          that the checkboxes beside “repo” and “user” are checked, and
          click the <span class="strong"><strong>Generate Token</strong></span> Button.</p><p>GitHub should take you back to the Application Settings page and present you with a
          new 40-digit hexadecimal token. Copy your new token and paste it into a text file so you
          can keep up with it. As the on-screen message says, you won’t be able to see it
          again!</p><p><a class="indexterm" id="iddle1979"/>To verify your token is working, enter the following <code class="literal">curl</code>
          command in your terminal. Replace the word <span class="strong"><strong><span class="emphasis"><em><code class="literal">token</code></em></span></strong></span> with your actual token in
          all of these requests:</p><a id="pro_id00432"/><pre class="programlisting">$ <span class="strong"><strong>curl -H "Authorization: Token <span class="emphasis"><em>token</em></span>" https://api.github.com/user</strong></span>
{
  "login": "anthonylewis",
  "id": 301,
  <span class="emphasis"><em>--snip--</em></span></pre><p>Here, I’ve used the <code class="literal">-H</code> parameter to <code class="literal">curl</code>
          to pass custom header data to the server, and, in this case, that data is the
            <code class="literal">Authorization: Token</code> header followed by my token.</p><p>You should see information about your own account, even though you didn’t
          specify a username. GitHub uses your personal access token to authenticate the
          request.</p><p>You can now use the token to access private information, such as the list of Git
          repositories associated with your account.</p><a id="pro_id00433"/><pre class="programlisting">$ <span class="strong"><strong>curl -H "Authorization: Token <span class="emphasis"><em>token</em></span>" https://api.github.com/user/repos</strong></span>
[
  {
    "id": 6289476,
    "name": "blog",
    "full_name": "anthonylewis/blog",
    "owner": {
      "login": "anthonylewis",
      "id": 301,
      <span class="emphasis"><em>--snip--</em></span></pre><p>GitHub should return an array of repositories created with your account. Depending on
          how many repositories you’ve created, this could be a lot of data.</p><p>Now that you have a token, you can also add another repository to your account using a
          POST request. As you learned in <a class="xref" href="ch04.html" title="Chapter 4. Controllers">Chapter 4</a>, POST means
            <span class="emphasis"><em>create</em></span> in REST.</p><a id="pro_id00434"/><pre class="programlisting">➊ $ <span class="strong"><strong>curl -i -d '{"name":"API Test"}' \</strong></span>
         <span class="strong"><strong>-H "Authorization: Token <span class="emphasis"><em>token</em></span>" \</strong></span>
         <span class="strong"><strong>https://api.github.com/user/repos</strong></span>
➋ HTTP/1.1 201 Created
  Server: GitHub.com
  Date: Mon, 21 Apr 2014 23:47:59 GMT
  Content-Type: application/json; charset=utf-8
  Status: 201 Created
  <span class="emphasis"><em>--snip---</em></span>
➌ {
    "id": 18862420,
    "name": "API-Test",
    "full_name": "anthonylewis/API-Test",
    "owner": {
      "login": "anthonylewis",
    "id": 301,
  <span class="emphasis"><em>--snip--</em></span></pre><p><a class="indexterm" id="iddle1062"/><a class="indexterm" id="iddle1065"/><a class="indexterm" id="iddle1248"/><a class="indexterm" id="iddle1868"/><a class="indexterm" id="iddle1984"/><a class="indexterm" id="iddle2104"/>The <code class="literal">-d</code> option to <code class="literal">curl</code> specifies data to
          be included with the request. Here, you send a JSON string with the name <code class="literal">"API
            Test"</code> for the new repository ➊. Because you’re sending data,
            <code class="literal">curl</code> automatically uses a POST request. GitHub responds to the
          request with headers indicating HTTP status <code class="literal">201 Created</code> ➋,
          followed by information about the newly created repository ➌.</p><p>Now that you have some experience with an existing API, let’s create our own API
          for our social application.</p></div><div class="sect1" title="Your Own API"><div class="titlepage"><div><div><h1 class="title"><a id="your_own_api"/>Your Own API</h1></div></div></div><p>You may remember from <a class="xref" href="ch04.html" title="Chapter 4. Controllers">Chapter 4</a> that the Rails scaffold generator
          used the <code class="literal">respond_to</code> method inside the
            <code class="literal">PostsController</code> to return different data based on the type of
          request. This approach is fine for some applications, but the addition of user
          authentication and sessions in your application leads to problems.</p><p>The existing controllers authenticate users by calling the
            <code class="literal">authenticate_user!</code> method before every action. Your API will use a
          different method to support token-based authentication. The existing controllers also
          display data, such as posts, based on the value of <code class="literal">current_user</code>. Your
          API will display all posts when requested.</p><p>Rather than use the same controllers for the application and the API, you can build
          separate controllers for each. Because your application is mainly about posts,
          you’ll start there when building your API.</p><div class="sect2" title="API Routes"><div class="titlepage"><div><div><h2 class="title"><a id="api_routes"/>API Routes</h2></div></div></div><p>Start by adding routes for API requests. The GitHub API used a subdomain for API
            requests. Because you haven’t set up your own domain, you’ll use a separate
            path for API requests. Open the file <span class="emphasis"><em>config/routes.rb</em></span> and add the
            following block near the end:</p><a id="pro_id00435"/><pre class="programlisting">  Social::Application.routes.draw do
  <span class="emphasis"><em>--snip--</em></span>

➊   <span class="strong"><strong>namespace :api do</strong></span>
      <span class="strong"><strong>resources :posts</strong></span>
    <span class="strong"><strong>end</strong></span>
  end</pre><p>The <code class="literal">namespace :api</code> block ➊ indicates that all routes
            created for the resources it contains start with the path <span class="emphasis"><em>api/</em></span>.
            Additionally, the controller files for those resources should be inside a directory
            named <span class="emphasis"><em>api</em></span>, and the controller classes should be inside a module
            named <code class="literal">Api</code>.</p><p>You can enter the <code class="literal">bin/rake routes</code> command in a terminal to see
            the newly created routes.</p></div><div class="sect2" title="API Controllers"><div class="titlepage"><div><div><h2 class="title"><a id="api_controllers"/>API Controllers</h2></div></div></div><p><a class="indexterm" id="iddle1060"/><a class="indexterm" id="iddle1077"/><a class="indexterm" id="iddle1379"/><a class="indexterm" id="iddle1418"/><a class="indexterm" id="iddle1723"/><a class="indexterm" id="iddle1778"/><a class="indexterm" id="iddle1852"/><a class="indexterm" id="iddle1997"/><a class="indexterm" id="iddle2107"/><a class="indexterm" id="iddle2231"/>Now that you’ve defined the routes, you need to create a controller to
            handle these actions. First, create a directory for the API controllers by entering the
            following command:</p><a id="pro_id00436"/><pre class="programlisting">$ <span class="strong"><strong>mkdir app/controllers/api</strong></span></pre><p>Then create a new file named
              <span class="emphasis"><em>app/controllers/api/posts_controller.rb</em></span> and add the code for the
            API <code class="literal">PostsController</code>, as shown here:</p><a id="pro_id00437"/><pre class="programlisting">  <span class="strong"><strong>module Api</strong></span>
    <span class="strong"><strong>class PostsController &lt; ApplicationController</strong></span>
➊   <span class="strong"><strong>respond_to :json</strong></span>

➋   <span class="strong"><strong>def index</strong></span>
      <span class="strong"><strong>@posts = Post.all</strong></span>
➌     <span class="strong"><strong>respond_with @posts</strong></span>
    <span class="strong"><strong>end</strong></span>
  <span class="strong"><strong>end</strong></span>
<span class="strong"><strong>end</strong></span></pre><p>The file starts with <code class="literal">module Api</code> to indicate this class belongs to
            the API namespace. Inside the <code class="literal">PostsController</code> class is a call to the
              <code class="literal">respond_to</code> class method. Calling <code class="literal">respond_to
              :json</code>, indicates that the actions in this controller return JSON data
            ➊.</p><p>The class then defines the <code class="literal">index</code> action ➋. The
              <code class="literal">index</code> action retrieves all posts and then uses the
              <code class="literal">respond_with</code> method to send them to the client ➌. The
              <code class="literal">respond_with</code> method automatically formats the data based on the
            format and HTTP verb used in the request. In this case, it should return JSON data in
            response to a GET request for the <code class="literal">index</code> action.</p><p>After you save this file, start the Rails server if it isn’t already started.
            Then you can use <code class="literal">curl</code> to test your API by entering this
            command:</p><a id="pro_id00438"/><pre class="programlisting">$ <span class="strong"><strong>curl http://localhost:3000/api/posts</strong></span>
[{"id":1,"title":"First Post","body":"Hello, World!"...</pre><p>The API returns an array of posts in response to the posts <code class="literal">index</code>
            action.</p><p>The data is compact and on a single line, which can be hard to read, but several
            free tools can pretty-print JSON data for you. For example, jq is a JSON processor that
            pretty-prints JSON data and adds syntax highlighting. Download jq from <span class="emphasis"><em><a class="ulink" href="http://stedolan.github.io/jq/">http://stedolan.github.io/jq/</a></em></span>. Once installed, you can pipe the
            output through jq’s basic filter by adding <code class="literal">| jq '.'</code> to the end
            of the command:</p><a id="pro_id00439"/><pre class="programlisting">$ <span class="strong"><strong>curl http://localhost:3000/api/posts | jq '.'</strong></span>
[
  {
   "id": 1,
   "title": "First Post",
   "body": "Hello, World!",
   "url":null,
   "user_id":1,
   <span class="emphasis"><em>--snip--</em></span></pre><p><a class="indexterm" id="iddle1168"/><a class="indexterm" id="iddle1772"/><a class="indexterm" id="iddle1782"/><a class="indexterm" id="iddle2329"/>The remaining examples in this chapter are pretty-printed. I leave off the
              <code class="literal">| jq '.'</code> for brevity, but you should include it if you want your
            output to look like what you see in the book. You can also see JSON output in your web
            browser. Entering <span class="emphasis"><em>http://localhost:3000/api/posts</em></span> in your web
            browser causes an <code class="literal">ActionController::UnknownFormat</code> error. If you check
            the server output in your terminal, you’ll see this is a <span class="emphasis"><em>406 Not
              Acceptable</em></span> error, as discussed earlier in this chapter. This error occurs
            because the controller only responds to JSON requests, but your web browser asks for
            HTML by default.</p><p>Specify a different content type by adding an extension to the URL in the address
            bar. Browsing to <span class="emphasis"><em>http://localhost:3000/api/posts.json</em></span> returns a
            JSON array of posts as expected.</p></div><div class="sect2" title="Customizing JSON Output"><div class="titlepage"><div><div><h2 class="title"><a id="customizing_json_output"/>Customizing JSON Output</h2></div></div></div><p>So far your API returns all of the data associated with each post. You may want to
            include additional data with each record, and, in some cases, you may want to exclude
            data from some fields. For example, including data about the author of each post is
            helpful, but you don’t want to include the user’s
              <code class="literal">password_digest</code> or <code class="literal">api_token</code>.</p><p>You can customize the output from your API built in to Rails in a couple of ways.
            Which method you use depends on how much customization you need and your personal
            preference.</p><div class="sect3" title="as_json"><div class="titlepage"><div><div><h3 class="title"><a id="asunderscorejson"/>as_json</h3></div></div></div><p>Because this API returns JSON data, you can easily customize the output by
              changing the way Rails converts a model to JSON. Rails first calls the
                <code class="literal">as_json</code> method on a model to convert it to a hash, which is then
              converted to a JSON string.</p><p>You can override the <code class="literal">as_json</code> method in the
                <code class="literal">Post</code> model to customize the data returned for each post. Open the
              file <span class="emphasis"><em>app/models/post.rb</em></span> and add the <code class="literal">as_json</code>
              method, shown here, to force the method to show only each post’s
                <code class="literal">id</code> and <code class="literal">title</code>:</p><a id="pro_id00440"/><pre class="programlisting">  class Post &lt; ActiveRecord::Base
    <span class="emphasis"><em>--snip--</em></span>

➊   <span class="strong"><strong>def as_json(options={})</strong></span>
➋     <span class="strong"><strong>super(only: [:id, :title])</strong></span>
    <span class="strong"><strong>end</strong></span>

    <span class="emphasis"><em>--snip--</em></span>
  end</pre><p><a class="indexterm" id="iddle1614"/><a class="indexterm" id="iddle1774"/>Be sure to include the <code class="literal">options</code> parameter with a default
              value of <code class="literal">{}</code> ➊ because the original
                <code class="literal">as_json</code> includes it. You aren’t using the
                <code class="literal">options</code> parameter, but because you’re overriding an
              existing method, your definition must match the original. Your
                <code class="literal">as_json</code> method calls <code class="literal">super</code>, which invokes the
              original <code class="literal">as_json</code> method defined by Active Record, with the
              parameter <code class="literal">only: [:id, :title]</code> ➋.</p><p>With this method in place, your API should only return the <code class="literal">id</code>
              and <code class="literal">title</code> of each post. Use the <code class="literal">curl</code> command to
              verify the change:</p><a id="pro_id00441"/><pre class="programlisting">$ <span class="strong"><strong>curl http://localhost:3000/api/posts</strong></span>
[
  {"id": 1, "title": "First Post"},
  {"id": 2, "title": "Google Search"}
]</pre><p>The <code class="literal">as_json</code> method supports several additional options. Instead
              of specifying fields to include with <code class="literal">:only</code>, you could exclude
              fields with the <code class="literal">:except</code> option. You can also include associated
              models with the <code class="literal">:include</code> option. For example, update the
                <code class="literal">as_json</code> method, as shown here, to exclude the
                <code class="literal">user_id</code> field and include the post’s associated
                <code class="literal">user</code> model:</p><a id="pro_id00442"/><pre class="programlisting">def as_json(options={})
  <span class="strong"><strong>super(except: [:user_id], include: :user)</strong></span>
end</pre><p>The <code class="literal">:methods</code> option calls a list of methods and includes their
              return values in the output. For example, you can use this option to call the
                <code class="literal">cached_comment_count</code> method you added in <a class="xref" href="ch12.html" title="Chapter 12. Performance">Chapter 12</a>:</p><a id="pro_id00443"/><pre class="programlisting">def as_json(options={})
  <span class="strong"><strong>super(except: [:user_id], include: :user,</strong></span>
    <span class="strong"><strong>methods: :cached_comment_count)</strong></span>
end</pre><p>This option will include the cached number of comments associated with this post
              in the output.</p><p>Overriding <code class="literal">as_json</code> certainly works, but depending on the level
              of customization required, this can get a bit messy. Fortunately, Rails provides a way
              to customize fully the JSON data returned by your API. Remove the
                <code class="literal">as_json</code> method from the <code class="literal">Post</code> model and
              let’s cover jbuilder.</p></div><div class="sect3" title="Jbuilder"><div class="titlepage"><div><div><h3 class="title"><a id="jbuilder"/>Jbuilder</h3></div></div></div><p>Jbuilder is a domain-specific language for generating JSON output. The jbuilder
              gem is included by default in the <span class="emphasis"><em>Gemfile</em></span> generated by the
                <code class="literal">rails new</code> command. Using jbuilder, you can create views for each
              of your API actions, just as you used ERB to create views for web actions.</p><p><a class="indexterm" id="iddle1417"/><a class="indexterm" id="iddle1784"/><a class="indexterm" id="iddle1785"/>As with your other views, you need to create a directory for your jbuilder
              views. The view directory must match the controller name. Enter the following commands
              to create a directory for API views and a subdirectory for the
                <code class="literal">PostsController</code> views:</p><a id="pro_id00444"/><pre class="programlisting">$ <span class="strong"><strong>mkdir app/views/api</strong></span>
$ <span class="strong"><strong>mkdir app/views/api/posts</strong></span></pre><p>With these directories in place, you can create your first jbuilder view. Create a
              new file named <span class="emphasis"><em>app/views/api/posts/index.json.jbuilder</em></span> and open
              it in your editor. Add this single line of code and save the file:</p><a id="pro_id00445"/><pre class="programlisting"><span class="strong"><strong>json.array! @posts</strong></span></pre><p>The <code class="literal">json.array!</code> method tells jbuilder to render the value of
                <code class="literal">@posts</code> as a JSON array. Use Curl to check the output of the index
              action:</p><a id="pro_id00446"/><pre class="programlisting">$ <span class="strong"><strong>curl http://localhost:3000/api/posts</strong></span>
[
  {
    "id": 1,
    "title": "First Post",
    "body": "Hello, World!",
    "url":null,
    "user_id":1,
    <span class="emphasis"><em>--snip--</em></span></pre><p>The output is the same as when you started. Now let’s see about customizing
              this output.</p><p>The <code class="literal">json.array!</code> method also accepts a block. Inside the block,
              you can access each individual record in the array. You can then use the
                <code class="literal">json.extract!</code> method to include only certain fields from the
              post:</p><a id="pro_id00447"/><pre class="programlisting"><span class="strong"><strong>json.array! @posts do |post|</strong></span>
  <span class="strong"><strong>json.extract! post, :id, :title, :body, :url</strong></span>
<span class="strong"><strong>end</strong></span></pre><p>This example renders the <code class="literal">id</code>, <code class="literal">title</code>,
                <code class="literal">body</code>, and <code class="literal">url</code> fields from each post as
              JSON.</p><p>All of the usual view helpers are also available in jbuilder views. For example,
              you can include a URL for each post using the <code class="literal">api_post_url</code> helper
              method:</p><a id="pro_id00448"/><pre class="programlisting">  json.array! @posts do |post|
    json.extract! post, :id, :title, :body, :url
➊   <span class="strong"><strong>json.post_url api_post_url(post)</strong></span>
end</pre><p><a class="indexterm" id="iddle1066"/><a class="indexterm" id="iddle1067"/><a class="indexterm" id="iddle1211"/><a class="indexterm" id="iddle1246"/><a class="indexterm" id="iddle2259"/><a class="indexterm" id="iddle2261"/><a class="indexterm" id="iddle2295"/>The output of method calls, such as <code class="literal">api_post_url(post)</code>
              ➊, are automatically converted to JSON format. The next example adds some data
              about the author of each post:</p><a id="pro_id00449"/><pre class="programlisting">json.array! @posts do |post|
  json.extract! post, :id, :title, :body, :url
  json.post_url api_post_url(post)

  <span class="strong"><strong>json.user do</strong></span>
    <span class="strong"><strong>json.extract! post.user, :id, :name, :email</strong></span>
  <span class="strong"><strong>end</strong></span>
end</pre><p>Here, I’ve used the <code class="literal">json.extract!</code> method again to include
              only specific fields for each user. You don’t want to make the
                <code class="literal">password_digest</code> for users available through your public
              API.</p></div></div><div class="sect2" title="Token-Based Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="token-based_authentication"/>Token-Based Authentication</h2></div></div></div><p>Now let’s add authentication so you can also create posts through your API.
            You’ll add token-based authentication, like you used earlier when accessing the
            GitHub API.</p><div class="sect3" title="Generating Tokens"><div class="titlepage"><div><div><h3 class="title"><a id="generating_tokens"/>Generating Tokens</h3></div></div></div><p>First, add a field for the <code class="literal">api_token</code> string to the
                <code class="literal">User</code> model by generating a database migration:</p><a id="pro_id00450"/><pre class="programlisting">$ <span class="strong"><strong>bin/rails g migration add_api_token_to_users api_token:string</strong></span></pre><p>Remember to enter the <code class="literal">bin/rake db:migrate</code> command after
              generating this migration to update your database.</p><p>Now update the <code class="literal">User</code> model by opening
                <span class="emphasis"><em>app/models/user.rb</em></span> in your editor and adding a validation for
              the <code class="literal">api_token</code> field and a <code class="literal">before_validation</code>
              call-back to generate the API token:</p><a id="pro_id00451"/><pre class="programlisting">   class User &lt; ActiveRecord::Base
     <span class="emphasis"><em>--snip--</em></span>

➊    <span class="strong"><strong>validates :api_token, presence: true, uniqueness: true</strong></span>

➋    <span class="strong"><strong>before_validation :generate_api_token</strong></span>

     <span class="emphasis"><em>--snip--</em></span></pre><p>First, you need to validate that the <code class="literal">api_token</code> is present and
              unique ➊. Because you’re using this value to authenticate, no two users
              can have the same <code class="literal">api_token</code>.</p><p><a class="indexterm" id="iddle1619"/><a class="indexterm" id="iddle1696"/><a class="indexterm" id="iddle2066"/><a class="indexterm" id="iddle2138"/>Next, you use a <code class="literal">before_validation</code> callback to call a
              method to generate the <code class="literal">api_token</code> if it doesn’t already exist
              ➋. Add the <code class="literal">generate_api_token</code> method at the bottom of the
                <code class="literal">User</code> model as shown here:</p><a id="pro_id00452"/><pre class="programlisting">  class User &lt; ActiveRecord::Base

    <span class="emphasis"><em>--snip--</em></span>

    <span class="strong"><strong>def generate_api_token</strong></span>
➊     <span class="strong"><strong>return if api_token.present?</strong></span>

      <span class="strong"><strong>loop do</strong></span>
➋       <span class="strong"><strong>self.api_token = SecureRandom.hex</strong></span>
➌       <span class="strong"><strong>break unless User.exists? api_token: api_token</strong></span>
      <span class="strong"><strong>end</strong></span>
    <span class="strong"><strong>end</strong></span>

  end</pre><p>The <code class="literal">generate_api_token</code> method returns immediately if the
                <code class="literal">api_token</code> already has a value ➊. If a value is not present
              for the <code class="literal">api_token</code>, the method calls
                <code class="literal">SecureRandom.hex</code> inside an endless <code class="literal">loop</code> to
              generate a value ➋. The <code class="literal">SecureRandom</code> class uses the most
              secure random-number generator available on your computer to generate values. On Unix
              computers, it uses the <code class="literal">/dev/urandom</code> device; on Windows, it uses the
              Win32 Cryptographic API. The <code class="literal">SecureRandom</code> class also includes
              several methods for formatting random values. The <code class="literal">hex</code> method
              returns a random 32-character hexadecimal value. Finally, if a user with this
                <code class="literal">api_token</code> doesn’t exist, break out of the loop
              ➌.</p><p>Now open a Rails console and update the existing users:</p><a id="pro_id00453"/><pre class="programlisting">➊ irb(main):001:0&gt; <span class="strong"><strong>user = User.first</strong></span>
    User Load (0.2ms) SELECT "users".* ...
  =&gt; #&lt;User id: 1, ... api_token: nil&gt;
➋ irb(main):002:0&gt; <span class="strong"><strong>user.save</strong></span>
     (0.1ms) begin transaction
    User Exists (0.2ms) SELECT 1 AS one FROM ...
    User Exists (0.1ms) SELECT 1 AS one FROM ...
    User Exists (0.1ms) SELECT 1 AS one FROM ...
    SQL (1.3ms) UPDATE "users" SET "api_token" ...
     (1.7ms)  commit transaction
  =&gt; true</pre><p>Because the <code class="literal">generate_api_token</code> method is called automatically
              using a <code class="literal">before_validation</code> callback, you simply need to load the
              user into a variable ➊ and then save it to the database ➋ to update it.
              Do this for each of your users. If any user doesn’t have a value for
                <code class="literal">api_token</code>, it will be created.</p><p><a class="indexterm" id="iddle1082"/><a class="indexterm" id="iddle1107"/><a class="indexterm" id="iddle1201"/><a class="indexterm" id="iddle1210"/><a class="indexterm" id="iddle2262"/>Now update the user <code class="literal">show</code> view to display the
                <code class="literal">api_token</code> when a user views his or her own account. Update
                <span class="emphasis"><em>app/views/users/show.html.erb</em></span> as shown here:</p><a id="pro_id00454"/><pre class="programlisting">  &lt;div class="page-header"&gt;
    &lt;h1&gt;User&lt;/h1&gt;
  &lt;/div&gt;

  &lt;p class="lead"&gt;&lt;%= @user.email %&gt;&lt;/p&gt;

➊ <span class="strong"><strong>&lt;% if @user == current_user %&gt;</strong></span>
    <span class="strong"><strong>&lt;p class="lead"&gt;API Token: &lt;%= @user.api_token %&gt;&lt;/p&gt;</strong></span>
  <span class="strong"><strong>&lt;% end %&gt;</strong></span>

<span class="emphasis"><em>--snip--</em></span></pre><p>Because API tokens are essentially passwords, you want to protect them by only
              showing them when the user being displayed is equal to the
                <code class="literal">current_user</code> ➊.</p></div><div class="sect3" title="Authenticating Requests"><div class="titlepage"><div><div><h3 class="title"><a id="authenticating_requests"/>Authenticating Requests</h3></div></div></div><p>Now that all users have an API token, let’s put those tokens to use. The
              process of authenticating with a token is similar to the username and password
              authentication you already created. Because you may have more than one controller for
              your API, you should include the authentication method in
                <code class="literal">ApplicationController</code>, which is the parent class of all other
              controllers.</p><p>First, you need a method to authenticate using an <code class="literal">api_token</code>.
              Luckily, Rails has a built-in method called
                <code class="literal">authenticate_or_request_with_http_token</code> to handle the details for
              you. Open the file <span class="emphasis"><em>app/controllers/application_ controller.rb</em></span> and
              add the following method to see how this works:</p><a id="pro_id00455"/><pre class="programlisting">  class ApplicationController &lt; ActionController::Base
    # Prevent CSRF attacks by raising an exception.
    # For APIs, you may want to use :null_session instead.
    protect_from_forgery with: :exception

    private

    <span class="strong"><strong>def authenticate_token!</strong></span>
      <span class="strong"><strong>authenticate_or_request_with_http_token do |token, options|</strong></span>
➊       <span class="strong"><strong>@api_user = User.find_by(api_token: token)</strong></span>
      <span class="strong"><strong>end</strong></span>
    <span class="strong"><strong>end</strong></span>

    <span class="emphasis"><em>--snip--</em></span></pre><p>This method is named <code class="literal">authenticate_token!</code> to match the
                <code class="literal">authenticate_user!</code> method you added in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>. The
                <code class="literal">authenticate_or_request_with_http_token</code> retrieves the token
              included in the request’s Authorization header and passes it to a block. Inside
              the block, you try to find a user in the database <a class="indexterm" id="iddle1061"/><a class="indexterm" id="iddle1079"/><a class="indexterm" id="iddle1223"/><a class="indexterm" id="iddle1426"/><a class="indexterm" id="iddle1568"/><a class="indexterm" id="iddle2102"/>using the given token ➊. The <code class="literal">find_by</code> method
              returns a <code class="literal">User</code> object if a matching user is found, or
                <code class="literal">nil</code> otherwise. This value is assigned to the
                <code class="literal">@api_user</code> instance variable and returned from the block. If the
              block returns a false value, such as <code class="literal">nil</code>, the method knows that
              authentication failed and sends a <span class="emphasis"><em>401 Unauthorized</em></span> response to
              the client.</p><p>You wrote a helper method called <code class="literal">current_user</code> for accessing the
              authenticated user in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>. For API requests, the
              authenticated user is already assigned to the <code class="literal">@api_user</code> instance
              variable, so you can use this variable.</p><p>Your token-based authentication solution is ready to go now. Let’s try it
              out by adding the ability to create text posts through your API.</p></div><div class="sect3" title="Using Token-Based Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="using_token-based_authentication"/>Using Token-Based Authentication</h3></div></div></div><p>First, you need to add routes for text posts, so open
                <span class="emphasis"><em>config/routes.rb</em></span> and add the <code class="literal">text_posts</code>
              resources inside the <code class="literal">:api</code> namespace:</p><a id="pro_id00456"/><pre class="programlisting">Social::Application.routes.draw do
<span class="emphasis"><em>--snip--</em></span>

  namespace :api do u
    resources :posts
    <span class="strong"><strong>resources :text_posts</strong></span>
  end
end</pre><p>Now you need a controller for text posts. Remember, it needs to be inside the
                <span class="emphasis"><em>api/</em></span> directory because the routes are in the
                <code class="literal">:api</code> namespace. Create a file named
                <span class="emphasis"><em>app/controllers/api/text_posts_controller.rb</em></span> and add the
              following code:</p><a id="pro_id00457"/><pre class="programlisting">  <span class="strong"><strong>module Api</strong></span>
    <span class="strong"><strong>class TextPostsController &lt; ApplicationController</strong></span>
      <span class="strong"><strong>respond_to :json</strong></span>
➊     <span class="strong"><strong>before_action :authenticate_token!</strong></span>

    <span class="strong"><strong>end</strong></span>
  <span class="strong"><strong>end</strong></span></pre><p>This controller starts the same as the API posts controller. The
                <code class="literal">TextPostsController</code> class must be inside a module called
                <code class="literal">Api</code>. It also includes <code class="literal">respond_to :json</code>. The
              first change is the addition of <code class="literal">before_action :authenticate_token!</code>
              ➊. The controller calls the <code class="literal">authenticate_token!</code> method
              before each action.</p><p>You want to create text posts, so add the <code class="literal">create</code> method:</p><a id="pro_id00458"/><pre class="programlisting">  module Api
    class TextPostsController &lt; ApplicationController
      respond_to :json
      before_action :authenticate_token!
➊   <span class="strong"><strong>def create</strong></span>
      <span class="strong"><strong>@text_post = @api_user.text_posts.create(text_post_params)</strong></span>
      <span class="strong"><strong>respond_with @text_post</strong></span>
    <span class="strong"><strong>end</strong></span>
  end
end</pre><p><a class="indexterm" id="iddle1415"/><a class="indexterm" id="iddle2253"/>The <code class="literal">create</code> method uses the <code class="literal">@api_user</code>
              instance variable set inside <code class="literal">authenticate_token!</code> to create a new
              text post ➊. You then use <code class="literal">respond_with</code> to send the new text
              post back to the client. Note that you don’t check to see whether the text post
              was actually created. The <code class="literal">respond_with</code> method automatically sends
              the appropriate error response if <code class="literal">@text_post</code> contains
              errors.</p><p>Because you also want to specify permitted parameter values, your final addition
              is a <code class="literal">text_post_params</code> method:</p><a id="pro_id00459"/><pre class="programlisting">  module Api
    class TextPostsController &lt; ApplicationController
      before_action :authenticate_token!

      respond_to :json

      def create
        @text_post = @api_user.text_posts.build(text_post_params)
        respond_with @text_post
      end

     <span class="strong"><strong>private</strong></span>

➊    <span class="strong"><strong>def text_post_params</strong></span>
       <span class="strong"><strong>params.require(:text_post).permit(:title, :body)</strong></span>
     <span class="strong"><strong>end</strong></span>
  end
end</pre><p>The <code class="literal">text_post_params</code> method permits data for a
                <code class="literal">:title</code> and <code class="literal">:body</code> in a nested hash with the key
                <code class="literal">:text_post</code> ➊. This is the same as the
                <code class="literal">text_post_params</code> method in the controller for web
              requests.</p><p>Enter the <code class="literal">curl</code> command to try out the new API. Make sure to set
              the <code class="literal">Content-Type</code> header to <code class="literal">application/json</code> when
              you run the command, so Rails automatically parses the JSON data included with your
              request. Replace the word <span class="strong"><strong><span class="emphasis"><em><code class="literal">token</code></em></span></strong></span> with the actual
                <code class="literal">api_token</code> from one of your application’s users.</p><a id="pro_id00460"/><pre class="programlisting">  <span class="strong"><strong>$ curl -i \</strong></span>
       <span class="strong"><strong>-d '{"text_post":{"title":"Test","body":"Hello"}}' \</strong></span>
       <span class="strong"><strong>-H "Content-Type: application/json" \</strong></span>
       <span class="strong"><strong>-H "Authorization: Token <span class="emphasis"><em>token</em></span>" \</strong></span>
       <span class="strong"><strong>http://localhost:3000/api/text_posts</strong></span>
1 HTTP/1.1 422 Unprocessable Entity
<span class="emphasis"><em>--snip--</em></span></pre><p><a class="indexterm" id="iddle1404"/><a class="indexterm" id="iddle1410"/><a class="indexterm" id="iddle2009"/>Something went wrong: The status code <span class="emphasis"><em>422 Unprocessable
                Entity</em></span> ➊ means the data the client passed to the server is not
              valid. Check the server output in your terminal for more information.</p><a id="pro_id00461"/><pre class="programlisting">  Started POST "/api/text_posts" for 127.0.0.1 at 2014-04-23 19:39:09 -0500
  Processing by Api::TextPostsController#create as */*
    Parameters: {"text_post"=&gt;{"title"=&gt;"Test", "body"=&gt;"Hello"}}
➊ Can't verify CSRF token authenticity
  Completed 422 Unprocessable Entity in 1ms

--<span class="emphasis"><em>snip</em></span>--</pre><p>The data passed to the server is valid but didn’t include a CSRF token
              ➊. Remember, this token is not the same as the API token. The CSRF token is
              another unique token that is sent automatically when you submit form data in your
              application. Because you aren’t submitting a form, you have no way of knowing
              the correct CSRF token.</p><p>When you were updating the <code class="literal">ApplicationController</code> earlier, you
              may have noticed a helpful comment at the top of the class. Rails normally prevents
              CSRF attacks by raising an exception. This is great for a web application, but it
              won’t work for an API. Instead of raising an exception, you can prevent CSRF
              attacks by clearing out the user’s session data. Now any time the application
              receives data from a user that does not include the CSRF token, it clears the
              user’s session, effectively logging the user out of the application and
              preventing the attack.</p><p>Fortunately, rather than store authentication data in the session, API clients
              include the correct API token with each request. So API requests should work fine with
              a null session. Open <span class="emphasis"><em>app/controllers/application_controller.rb</em></span> in
              your editor and make the following update:</p><a id="pro_id00462"/><pre class="programlisting">  class ApplicationController &lt; ActionController::Base
    # Prevent CSRF attacks by raising an exception.
    # For APIs, you may want to use :null_session instead.
➊   <span class="strong"><strong>protect_from_forgery with: :null_session</strong></span>

    <span class="emphasis"><em>--snip--</em></span></pre><p>In the <code class="literal">protect_from_forgery</code> method call ➊, change the
              value of the <code class="literal">:with</code> option to <code class="literal">:null_session</code>, and
              then try the same request again using <code class="literal">curl</code>:</p><a id="pro_id00463"/><pre class="programlisting">  <span class="strong"><strong>$ curl -i \</strong></span>
         <span class="strong"><strong>-d '{"text_post":{"title":"Test","body":"Hello"}}' \</strong></span>
         <span class="strong"><strong>-H "Content-Type: application/json" \</strong></span>
         <span class="strong"><strong>-H "Authorization: Token <span class="emphasis"><em>token</em></span>" \</strong></span>
         <span class="strong"><strong>http://localhost:3000/api/text_posts</strong></span>
➊ HTTP/1.1 201 Created
  <span class="emphasis"><em>--snip--</em></span>
➋ {
    "id":5,
    "title":"Test",
    "body":"Hello",
    "url":null,
    "user_id":1,
    "created_at":"2014-04-24T00:33:35.874Z",
    "updated_at":"2014-04-24T00:33:35.874Z"
  }</pre><p>The status code is now <span class="emphasis"><em>201 Created</em></span>, which means success
              ➊. The HTTP headers are followed by a JSON representation of the new text post
              ➋. Because you didn’t create a jbuilder view for this action, the default
              JSON representation is used.</p><p>You can also open the <code class="literal">posts</code> index page in your browser, or
              issue an API request for all posts with the command <code class="literal">curl
                http://localhost:3000/api/posts</code>, to verify the text post was created
              successfully.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00032"/>Summary</h1></div></div></div><p>A Web API can open up your application to collaborations from both your customers and
          third-party applications. With an effective API, you can also build native mobile or
          desktop clients for your application. You could even use another application’s API
          to integrate its data into yours.</p><p>In this chapter, we discussed the GitHub API and used it to access detailed data about
          users and repositories. After covering the Hypertext Transfer Protocol and token-based
          authentication, you built your own API for your social network application.</p><p>In the next chapter, you’ll learn how to set up your own server to host Rails
          applications and use the Capistrano remote server automation tool to deploy and maintain
          your applications.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00033"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch14qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch14qa1qe1"/><a id="ch14qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. Verify that your token-based authentication is really working by issuing a
                POST request with a fake token. Use the <code class="literal">curl</code> command to send the
                request, and be sure to check both the status code in the headers and the response
                body.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch14qa1qe2"/><a id="ch14qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. Try to create a text post with invalid data and see what happens. You can
                check the validation for text posts in <span class="emphasis"><em>app/models/text_post.rb</em></span>.
                Again, use the <code class="literal">curl</code> command to send the request and be sure to
                check the status code in both the headers and the response body.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch14qa1qe3"/><a id="ch14qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. Extend the API by adding a <code class="literal">show</code> action to the posts
                controller. This action should find the correct post using
                  <code class="literal">params[:id]</code> and then use the <code class="literal">respond_with</code>
                method to send the post back to the client. Because this is a GET request, you can
                check it with <code class="literal">curl</code> or in your web browser.</p></td></tr></tbody></table></div></div></div></body></html>