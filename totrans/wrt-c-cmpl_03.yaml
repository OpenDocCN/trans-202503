- en: '![](../images/pg24.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg24.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-05.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-05.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">UNARY
    OPERATORS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">一元运算符</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'C has several *unary operators*, which operate on a single value. In this chapter,
    you’ll extend your compiler to handle two unary operators: negation and bitwise
    complement. You’ll transform complex, nested unary expressions into simple operations
    that can be expressed in assembly. Instead of performing this transformation in
    a single compiler pass, you’ll introduce a new intermediate representation between
    the AST produced by the parser and the assembly AST produced by the assembly generation
    pass. You’ll also break up assembly generation into several smaller passes. The
    new passes are bolded in the diagram at the start of this chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有几种 *一元运算符*，它们作用于单个值。在本章中，你将扩展编译器，以处理两个一元运算符：否定和按位取反。你将把复杂的、嵌套的一元表达式转换为可以在汇编中表达的简单操作。你不会在单一的编译过程中过滤这一转换，而是会在解析器生成的抽象语法树（AST）和汇编生成过程生成的汇编抽象语法树之间引入一种新的中间表示。你还将把汇编生成过程分解为几个较小的过程。新过程在本章开头的图示中已被加粗标出。
- en: To get started, let’s look at a C program using the new unary operators and
    the corresponding assembly we’ll generate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看一个使用新一元运算符的 C 程序和我们将生成的相应汇编代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Negation and Bitwise Complement in Assembly</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编中的否定和按位取反</samp>
- en: In this chapter, you’ll learn to compile programs like [Listing 2-1](chapter2.xhtml#list2-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何编译像[清单 2-1](chapter2.xhtml#list2-1)这样的程序。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A C program with
    negation and bitwise complement</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-1：带有否定和按位取反的 C 程序</samp>
- en: This program contains a nested expression using both new unary operators. The
    first operator, *negation* (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>),
    negates an integer—no surprise there. The *bitwise complement* (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    operator flips every bit in an integer, which has the effect of negating the integer
    and then subtracting one. (It has this effect because computers use a system called
    *two’s complement* to represent signed integers. If you’re not familiar with two’s
    complement, see “Additional Resources” on [page 45](#pg_45) for links to a few
    explanations of how it works.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序包含了一个嵌套表达式，使用了两个新的一元运算符。第一个运算符，*否定*（<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>），否定一个整数——这没什么意外。*按位取反*（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">~</samp>）运算符将一个整数的每一位进行翻转，这样会使整数变为其负数，然后再减去
    1。（之所以会有这样的效果，是因为计算机使用一种称为 *二进制补码* 的系统来表示有符号整数。如果你不熟悉二进制补码，请参见[第 45 页](#pg_45)中的“附加资源”，其中有一些关于其工作原理的解释链接。）
- en: Your compiler will convert [Listing 2-1](chapter2.xhtml#list2-1) to the assembly
    code in [Listing 2-2](chapter2.xhtml#list2-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器会将[清单 2-1](chapter2.xhtml#list2-1)转换为[清单 2-2](chapter2.xhtml#list2-2)中的汇编代码。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: The assembly code
    for [Listing 2-1](chapter2.xhtml#list2-1)</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-2：对应[清单 2-1](chapter2.xhtml#list2-1)的汇编代码</samp>
- en: The first three instructions after <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    form the *function prologue*, which sets up the current stack frame; I’ll cover
    them in the next section, when I talk about the stack in detail. After the function
    prologue, we calculate the intermediate result, –2, and then the final result,
    1, storing each of them at a unique memory address. This isn’t very efficient,
    since we waste a lot of instructions copying values from one address to another.
    The optimizations we’ll implement in [Part III](part3.xhtml) will clean up most
    of these unnecessary copies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 后的前三条指令形成了 *函数前奏*，它设置了当前的栈帧；我将在下一节详细讲解栈时覆盖它们。函数前奏之后，我们计算中间结果
    –2，然后是最终结果 1，并将每个结果存储在一个独立的内存地址上。这并不是很高效，因为我们浪费了大量的指令将值从一个地址复制到另一个地址。我们将在[第三部分](part3.xhtml)中实现的优化将清理掉这些不必要的复制。
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    ❶ stores <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> at an address
    in memory. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    ❷ means “the value stored in the RBP register, minus four.” The value in RBP is
    a memory address on the stack (more on this shortly), so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> refers to another memory address
    4 bytes lower. Next, we negate the value at this address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    instruction ❸, so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>. (Just
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    has an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix to indicate
    that it’s operating on a 32-bit value.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令 ❶ 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    存储到内存中的一个地址。操作数 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    ❷ 意味着“RBP 寄存器中存储的值减去四”。RBP 中的值是栈上的一个内存地址（稍后会详细讲解），因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    指向的是比当前地址低 4 字节的另一个内存地址。接下来，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    指令 ❸ 对该地址的值进行取反，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    包含的值变成 <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>。（和 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> 指令也有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    后缀，表示它是在操作 32 位值。）
- en: 'We then handle the outer bitwise complement expression. We start by copying
    the source value, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    to the destination address at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We can’t do this in a single instruction, because <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    can’t have memory addresses as both its source and destination operands. At least
    one operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> needs
    to be a register or an immediate value. We get around this by copying <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>
    from memory into a scratch register, R10D ❹, and from there to the destination
    memory address ❺. Then, we take the bitwise complement of <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction
    ❻, so memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    now contains the value we want to return: <samp class="SANS_TheSansMonoCd_W5Regular_11">~(-2)</samp>,
    which evaluates to 1\. To return this value, we move it into EAX ❼. The final
    three instructions are the *function epilogue*, which tears down the stack frame
    and returns from the function.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们处理外部的按位取反表达式。首先，我们将存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    的源值复制到目的地址 <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>。我们不能通过单条指令完成这个操作，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令的源操作数和目的操作数不能都是内存地址。至少有一个操作数必须是寄存器或立即数。我们通过将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp> 从内存中复制到一个临时寄存器 R10D ❹，再从该寄存器复制到目的内存地址
    ❺ 来绕过这一限制。然后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 指令
    ❻ 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp> 进行按位取反操作，因此内存地址 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> 现在包含我们想要返回的值：<samp class="SANS_TheSansMonoCd_W5Regular_11">~(-2)</samp>，其结果为
    1。为了返回这个值，我们将其移动到 EAX 寄存器中 ❼。最后的三条指令是 *函数尾部代码*，用于销毁栈帧并从函数返回。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If you compile [Listing 2-1](chapter2.xhtml#list2-1) to assembly using GCC,
    Clang, or any other production C compiler, it won’t look anything like [Listing
    2-2](chapter2.xhtml#list2-2). That’s because those compilers evaluate constant
    expressions at compile time, even when you’ve disabled optimizations! I’m guessing
    they behave this way because some constant expressions, like static variable initializers,*
    must *be evaluated at compile time, and evaluating all constant expressions at
    compile time is simpler than evaluating only some.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用 GCC、Clang 或其他生产环境的 C 编译器将 [示例 2-1](chapter2.xhtml#list2-1) 编译成汇编，它将与
    [示例 2-2](chapter2.xhtml#list2-2) 完全不同。这是因为这些编译器在编译时就会计算常量表达式，即使你已经禁用了优化！我猜它们之所以这样做，是因为某些常量表达式，比如静态变量初始化器，*必须*在编译时进行计算，而在编译时计算所有常量表达式比只计算部分常量表达式更简单。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Stack</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">栈</samp>
- en: 'There are still two unanswered questions about [Listing 2-2](chapter2.xhtml#list2-2):
    what the function prologue and epilogue do, and why we refer to stack addresses
    relative to a value in the RBP register. To answer these questions, we need to
    talk about the segment of program memory called the *stack*. The RSP register,
    also called the *stack pointer*, always holds the address of the top of the stack.
    (RSP points to the last used stack slot, rather than the first free one.) As with
    any stack data structure, you can push values onto the stack and pop values off
    it; the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    assembly instructions do exactly that.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [清单 2-2](chapter2.xhtml#list2-2)，仍有两个未解的问题：函数序言和尾声做了什么，以及为什么我们要相对于 RBP 寄存器中的值引用栈地址。为了回答这些问题，我们需要讨论程序内存中的一个段，叫做
    *栈*。RSP 寄存器，也称为 *栈指针*，始终保存栈顶的地址。（RSP 指向的是最后使用的栈槽，而不是第一个空闲的栈槽。）与任何栈数据结构一样，你可以将值推入栈中，也可以从栈中弹出值；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    汇编指令正是完成这一操作的。
- en: 'The stack grows toward lower memory addresses. When you push something onto
    the stack, you decrement RSP. That means the “top of the stack”—the address stored
    in RSP—is the *lowest* address on the stack. The stack diagrams in this book are
    oriented with lower memory addresses at the top, so the top of the stack is at
    the top of the diagram. Think of the memory addresses in these diagrams like line
    numbers in a code listing. The top of a code listing is line 1, and line numbers
    increase as you go down; similarly, the addresses in these diagrams increase as
    you go down the page or screen. Note that most stack diagrams in other books and
    articles use the opposite orientation: they put the top of the stack at the bottom
    of the diagram, so lower memory addresses appear lower on the page. I find that
    layout really confusing, but if you prefer it, just turn your book upside down.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 栈向较低的内存地址增长。当你将数据推入栈时，RSP 会减小。这意味着“栈顶”——存储在 RSP 中的地址——是栈中的 *最低* 地址。本书中的栈图是按照较低的内存地址位于顶部来排列的，因此栈顶位于图的顶部。可以将这些图中的内存地址视为代码列表中的行号。代码列表的顶部是第
    1 行，行号随着向下移动而增加；同样，图中的地址随着向下滚动页面或屏幕而增加。需要注意的是，大多数书籍和文章中的栈图采用的是相反的布局：它们将栈顶放在图的底部，因此较低的内存地址显示在页面的下方。我觉得这种布局非常令人困惑，但如果你喜欢它，只需把书倒过来即可。
- en: 'An instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">push $3</samp>
    does two things:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 <samp class="SANS_TheSansMonoCd_W5Regular_11">push $3</samp> 这样的指令做了两件事：
- en: Writes the value being pushed (in this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>)
    to the next empty spot on the stack. The <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instructions adjust
    the stack pointer in 8-byte increments, and the top value on the stack is currently
    at the address stored in RSP, so the next empty spot is RSP – 8.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要推送的值（在这个例子中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>）写入栈上的下一个空闲位置。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    指令以 8 字节为增量调整栈指针，栈顶的值目前位于 RSP 存储的地址，因此下一个空闲位置是 RSP – 8。
- en: Decrements RSP by 8 bytes. The new address in RSP is now the top of the stack,
    and the value at that address is <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RSP 减少 8 字节。此时 RSP 中的新地址就是栈顶，而该地址上的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。
- en: '[Figure 2-1](#fig2-1) illustrates the effect of a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction on the stack and RSP register.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#fig2-1) 说明了 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    指令对栈和 RSP 寄存器的影响。'
- en: '![](../images/fig2-1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig2-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The effect of push
    $3 on memory and RSP [Description](description-06.xhtml)</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：push $3 对内存和 RSP 的影响 [描述](description-06.xhtml)</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction performs
    the opposite operation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop
    %rax</samp> copies the value at the top of the stack into the RAX register, then
    adds 8 bytes to RSP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> 指令执行相反的操作。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pop %rax</samp> 会将栈顶的值复制到 RAX 寄存器中，然后将
    RSP 加上 8 字节。
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction
    decrements the stack pointer by 8 bytes, it has to push an 8-byte value. Likewise,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction always
    pops an 8-byte value off the stack. Values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>—like
    the return value in [Listing 2-1](chapter2.xhtml#list2-1)—are only 4 bytes. You
    can’t push only 4 bytes onto the stack, but you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    to copy a 4-byte value into stack space you’ve already allocated. A couple of
    instructions do this in [Listing 2-2](chapter2.xhtml#list2-2), including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl $2, -4(%rbp)</samp>. (On 32-bit systems,
    the reverse is true; you can push and pop 4-byte values but not 8-byte values.
    On both kinds of systems, it’s also possible, though very unusual, to push and
    pop 2-byte values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp> instructions; the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> suffix, for *word*, indicates
    that the instruction takes a 2-byte operand. We won’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp>, or any other 2-byte
    instructions in this book.) Memory addresses on x64 systems are 8 bytes, so you
    can use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    to put them on and take them off the stack. This will come in handy in a moment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令会将栈指针减去8字节，因此它必须推送一个8字节的值。同样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>指令总是从栈上弹出一个8字节的值。像[int](chapter2.xhtml#list2-1)中的返回值那样的类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的值，只有4字节。你不能只将4字节的值推入栈中，但你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令将一个4字节的值复制到你已经分配的栈空间中。[Listing
    2-2](chapter2.xhtml#list2-2)中的几个指令就是这样做的，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $2, -4(%rbp)</samp>。（在32位系统上，情况正好相反；你可以推送和弹出4字节的值，但不能推送8字节的值。在这两种系统上，尽管非常不常见，你也可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp>指令来推送和弹出2字节的值；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w</samp>后缀，代表*字（word）*，表示该指令接受一个2字节的操作数。我们在本书中不会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp>或任何其他2字节指令。）在x64系统上，内存地址是8字节，因此你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">push</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>将它们放入栈中或从栈中取出。这在稍后会派上用场。
- en: The stack isn’t just an undifferentiated chunk of memory; it’s divided into
    sections called *stack frames*. Whenever a function is called, it allocates some
    memory at the top of the stack by decreasing the stack pointer. This memory is
    the function’s stack frame, where it stores local variables and temporary values.
    Just before the function returns, it deallocates its stack frame, restoring the
    stack pointer to its previous value. By convention, the RBP register points to
    the base of the current stack frame; for this reason, it’s sometimes called the
    *base pointer*. We refer to data in the current stack frame relative to the address
    stored in RBP. This means we don’t need absolute addresses, which we can’t know
    in advance. Since the stack grows toward lower memory addresses, every address
    in the current stack frame is lower than the address stored in RBP; this is why
    the addresses of local variables, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    all have negative offsets from RBP. In later chapters, we’ll also refer to data
    in the caller’s stack frame, like function parameters, relative to RBP. (It’s
    possible to refer to local variables and parameters relative to RSP instead, and
    not bother with RBP at all; most production compilers do this as an optimization.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 栈不仅仅是一个无差别的内存块；它被划分为叫做*栈帧*的不同部分。每当一个函数被调用时，它通过减少栈指针来在栈顶分配一些内存。这块内存就是该函数的栈帧，用于存储局部变量和临时值。在函数返回之前，它会释放栈帧，将栈指针恢复到之前的值。按照惯例，RBP寄存器指向当前栈帧的基址；因此，它有时被称为*基指针*。我们通过相对于RBP存储的地址来引用当前栈帧中的数据。这意味着我们不需要绝对地址，因为我们无法提前知道它们。由于栈是向着较低的内存地址增长的，因此当前栈帧中的每个地址都低于RBP中存储的地址；这就是为什么像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>这样的局部变量地址，都是相对于RBP的负偏移量。在后面的章节中，我们还会提到相对于RBP的数据，比如调用者栈帧中的函数参数。（也可以将局部变量和参数相对于RSP进行引用，而根本不涉及RBP；大多数生产环境编译器会作为一种优化这样做。）
- en: 'Now that you understand how the stack works, let’s look at the function prologue
    and epilogue in more detail. The function prologue sets up the stack frame in
    three instructions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了栈的工作原理，接下来我们更详细地看一下函数前言和尾部。函数前言通过三条指令设置栈帧：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq %rbp</samp> saves the current
    value of RBP, the address of the base of the caller’s stack frame, onto the stack.
    We’ll need this value when we restore the caller’s stack frame later. This value
    will be at the bottom of the new stack frame established by the next instruction.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq %rbp</samp> 将当前的 RBP 值，即调用者栈帧基地址，保存到栈中。稍后恢复调用者栈帧时，我们需要这个值。这个值将位于由下一条指令建立的新栈帧的栈底。
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rsp, %rbp</samp> makes
    the top of the stack the base of the new stack frame. At this point, the top and
    bottom of the current stack frame are the same. The current stack frame holds
    exactly one value, which both RSP and RBP point to: the base of the caller’s stack
    frame, which we saved in the previous instruction.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rsp, %rbp</samp> 将栈顶设为新栈帧的基地址。此时，当前栈帧的栈顶和栈底是相同的。当前栈帧只保存一个值，这个值是
    RSP 和 RBP 都指向的：即我们在前一条指令中保存的调用者栈帧的基地址。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp> decrements the stack pointer
    by *n* bytes. The stack frame now has *n* bytes available to store local and temporary
    variables.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp> 将栈指针减去 *n* 字节。此时栈帧有 *n*
    字节的空间来存储局部变量和临时变量。
- en: '[Figure 2-2](#fig2-2) shows how each instruction in the function prologue affects
    the stack. In this figure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction allocates 24 bytes, enough space for six 4-byte integers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#fig2-2) 显示了函数前言中每条指令对栈的影响。在这个图中，<samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    指令分配了 24 字节的空间，足够容纳六个 4 字节的整数。'
- en: '![](../images/fig2-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig2-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The state of the
    stack at each point in the function prologue [Description](description-07.xhtml)</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-2：函数前言每个阶段栈的状态 [描述](description-07.xhtml)</samp>
- en: 'The function epilogue restores the caller’s stack frame by setting RSP and
    RBP back to the same values they had before the function prologue. This requires
    two instructions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数尾部通过将 RSP 和 RBP 恢复到函数前言之前的相同值，恢复了调用者的栈帧。这需要两条指令：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rbp, %rsp</samp> puts us
    back where we were after the second instruction of the function prologue: both
    RSP and RBP point to the bottom of the current stack frame, which holds the caller’s
    value for RBP.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rbp, %rsp</samp> 将我们带回函数前言第二条指令执行后的位置：RSP
    和 RBP 都指向当前栈帧的栈底，该栈帧保存了调用者的 RBP 值。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">popq %rbp</samp> reverses the
    first instruction of the function prologue and restores the caller’s values for
    the RSP and RBP registers. It restores RBP because the value at the top of the
    stack was the base address of the caller’s stack frame that we saved at the start
    of the prologue. It restores RSP by removing the last value in this stack frame
    from the stack, leaving RSP pointing to the top of the caller’s stack frame.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">popq %rbp</samp> 恢复了函数前言中的第一条指令，恢复了调用者的
    RSP 和 RBP 寄存器值。它通过恢复 RBP，因为栈顶的值是我们在函数前言开始时保存的调用者栈帧的基地址。通过移除栈帧中的最后一个值来恢复 RSP，使
    RSP 指向调用者栈帧的栈顶。
- en: '[Figure 2-3](#fig2-3) shows the effect of each instruction in the function
    epilogue.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#fig2-3) 显示了每条指令在函数尾部的作用。'
- en: '![](../images/fig2-3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig2-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The state of the
    stack at each point in the function epilogue [Description](description-08.xhtml)</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-3：函数尾部每个阶段栈的状态 [描述](description-08.xhtml)</samp>
- en: Now that we know what output our compiler should produce, let’s keep coding.
    We’ll start by extending the lexer and parser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道编译器应该生成什么输出，继续编程吧。我们将从扩展词法分析器和语法分析器开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'In this chapter, you’ll extend the lexer to recognize three new tokens:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将扩展词法分析器，使其识别三个新的符号：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">~</samp> | A tilde, the bitwise
    complement operator |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">~</samp> | 一个波浪号，按位取反运算符 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-</samp> | A hyphen, the negation
    operator |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-</samp> | 一个连字符，取反运算符 |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--</samp> | Two hyphens, the
    decrement operator |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--</samp> | 两个连字符，递减运算符 |'
- en: While you won’t implement the decrement operator in this chapter, you still
    need to add a token for it. Otherwise, your compiler will accept programs it should
    reject, like the one in [Listing 2-3](chapter2.xhtml#list2-3).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在这一章中不会实现递减运算符，但仍然需要为它添加一个符号。否则，编译器将接受一些应该被拒绝的程序，例如[列表 2-3](chapter2.xhtml#list2-3)中的那个程序。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: An invalid C program
    using the decrement operator</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-3：一个使用递减运算符的无效 C 程序</samp>
- en: This shouldn’t compile, because you can’t decrement a constant. But if your
    compiler doesn’t know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    is a distinct token, it will think [Listing 2-3](chapter2.xhtml#list2-3) is equivalent
    to [Listing 2-4](chapter2.xhtml#list2-4), which is a perfectly valid program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不应该编译通过，因为不能对常量进行递减操作。但如果你的编译器没有识别出<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>是一个独立的符号，它会认为[列表
    2-3](chapter2.xhtml#list2-3)等同于[列表 2-4](chapter2.xhtml#list2-4)，而后者是一个完全有效的程序。
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A valid C program
    with two negation operators in a row</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-4：一个有效的 C 程序，连续两个取反运算符</samp>
- en: Your compiler should reject language features you haven’t implemented; it shouldn’t
    compile them incorrectly. That’s why your lexer needs to know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    is a single token, not just two negation operators in a row. (On the other hand,
    the lexer should lex <samp class="SANS_TheSansMonoCd_W5Regular_11">~~</samp> as
    two bitwise complement operators in a row. Expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">~~2</samp>
    are valid.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器应该拒绝那些你未实现的语言特性；它不应该错误地编译它们。因此，词法分析器需要知道<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>是一个单独的符号，而不是两个连续的取反运算符。（另一方面，词法分析器应将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">~~</samp>解析为两个连续的按位取反运算符。像<samp class="SANS_TheSansMonoCd_W5Regular_11">~~2</samp>这样的表达式是有效的。）
- en: You can process the new tokens the same way you handled punctuation like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>in
    [Chapter 1](chapter1.xhtml). First, you need to define a regular expression for
    each new token. The regular expressions here are the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>.
    Next, have your lexer check the input against these new regexes, as well as the
    regexes from the previous chapter, every time it tries to produce a token. When
    the start of the input stream matches more than one possible token, choose the
    longest one. For example, if your input stream starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>,
    parse it as a decrement operator rather than two negation operators.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理标点符号（例如<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>在[第
    1 章](chapter1.xhtml)中的方式一样）来处理新的符号。首先，你需要为每个新的符号定义一个正则表达式。这里的正则表达式是<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>。接着，每当词法分析器试图生成一个符号时，它需要检查输入是否与这些新正则表达式匹配，也要检查来自上一章的正则表达式。当输入流的开始匹配多个可能的符号时，选择最长的一个。例如，如果输入流以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp>开头，则应将其解析为递减运算符，而不是两个连续的取反运算符。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>'
- en: To parse the new operators in this chapter, we first need to extend the AST
    and formal grammar we defined in [Chapter 1](chapter1.xhtml). Let’s look at the
    AST first. Since unary operations are expressions, we represent them with a new
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST
    node. [Listing 2-5](chapter2.xhtml#list2-5) shows the updated AST definition,
    with new parts bolded.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析本章中的新运算符，我们首先需要扩展我们在 [第一章](chapter1.xhtml) 中定义的抽象语法树（AST）和形式语法。首先让我们看看 AST。由于一元运算是表达式，我们用一个新的构造器为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST 节点表示它们。[清单 2-5](chapter2.xhtml#list2-5)
    显示了更新后的 AST 定义，新增的部分已加粗。
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: The abstract syntax
    tree with unary operations</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-5：包含一元运算的抽象语法树</samp>
- en: 'The updated rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    indicates that an expression can be either a constant integer or a unary operation.
    A unary operation consists of one of the two unary operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>, applied to an
    inner expression. Notice that the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    is recursive: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor
    for an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node contains
    another <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node. This lets
    us construct arbitrarily deeply nested expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~(-~-(-4)))</samp>.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 规则表明，一个表达式可以是常量整数或一元运算。一元运算由两种一元运算符之一，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">补码</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">取反</samp>，应用于一个内层表达式。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 的定义是递归的：<samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    构造器对于一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 节点包含另一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 节点。这使得我们能够构造任意深度嵌套的表达式，如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-(~(-~-(-4)))</samp>。
- en: We also need to make the corresponding changes to the grammar, shown in [Listing
    2-6](chapter2.xhtml#list2-6).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对语法进行相应的更改，如 [清单 2-6](chapter2.xhtml#list2-6) 所示。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: The formal grammar
    with unary operations</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-6：包含一元运算的形式语法</samp>
- en: '[Listing 2-6](chapter2.xhtml#list2-6) includes a new production rule for unary
    expressions and a <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    symbol to represent the two unary operators. These changes correspond to the additions
    to the AST in [Listing 2-5](chapter2.xhtml#list2-5). We’ve also added a third
    production rule for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    symbol, which describes a parenthesized expression. It doesn’t have a corresponding
    constructor in the AST because the rest of the compiler doesn’t need to distinguish
    between an expression wrapped in parentheses and the same expression without parentheses.
    The expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">((((1))))</samp>
    are all represented by the same AST node: <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-6](chapter2.xhtml#list2-6) 包含了一条新的产生式规则，用于一元表达式，并且新增了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    符号来表示两个一元运算符。这些更改与 [清单 2-5](chapter2.xhtml#list2-5) 中对 AST 的扩展相对应。我们还为 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    符号添加了第三条产生式规则，描述了带括号的表达式。它在 AST 中没有对应的构造器，因为编译器的其他部分不需要区分一个带括号的表达式与一个没有括号的相同表达式。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">(1)</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">((((1))))</samp> 都由相同的 AST 节点表示：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>。'
- en: The decrement operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>)
    doesn’t show up anywhere in this grammar, so your parser should fail if it encounters
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> token.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 减法运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>）在该语法中没有出现，因此当你的解析器遇到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> 标记时应该报错。
- en: To update the parsing stage, modify your compiler’s AST data structure to match
    [Listing 2-5](chapter2.xhtml#list2-5). Then, update your recursive descent parsing
    code to reflect the changes in [Listing 2-6](chapter2.xhtml#list2-6). Parsing
    an expression gets a bit more complicated in this chapter because you need to
    figure out which of the three different production rules for the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    symbol to apply. The pseudocode in [Listing 2-7](chapter2.xhtml#list2-7) demonstrates
    how to parse an expression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新解析阶段，请修改编译器的AST数据结构，以匹配[列表 2-5](chapter2.xhtml#list2-5)。然后，更新递归下降解析代码，以反映[列表
    2-6](chapter2.xhtml#list2-6)中的更改。在这一章中，解析表达式变得有些复杂，因为您需要弄清楚应用<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>符号的三个不同生成规则中的哪一个。[列表
    2-7](chapter2.xhtml#list2-7)中的伪代码演示了如何解析一个表达式。
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Parsing an expression</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-7：解析表达式</samp>
- en: First, we look at the next token in the input to figure out which production
    rule to apply. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">peek</samp>
    to look at this token without removing it from the input stream. Once we know
    which production rule to use, we’ll want to process the whole input, including
    that first token, using that rule. So, we don’t want to consume this token from
    the input just yet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查看输入中的下一个标记，以确定应用哪个生成规则。我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">peek</samp>来查看这个标记，但不将其从输入流中移除。一旦确定使用哪个生成规则，我们将处理整个输入，包括第一个标记，并使用该规则。因此，我们现在不想从输入中消费这个标记。
- en: If the expression we’re about to parse is valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>
    should be an integer, a unary operator, or an open parenthesis. If it’s an integer
    ❶, we parse it the same way as in the previous chapter. If it’s a unary operator
    ❷, we apply the second production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    from [Listing 2-6](chapter2.xhtml#list2-6) to construct a unary expression. This
    rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop> <exp></samp>, so
    we parse the unary operator and then the inner expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    symbol is a single token, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>,
    which we’ve already inspected. In [Listing 2-7](chapter2.xhtml#list2-7), we handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp> in a separate function
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>, whose definition
    I’ve omitted). In practice, you probably don’t need a separate function to parse
    one token. Either way, we end up with an AST node representing the appropriate
    unary operator. The next symbol in the production rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    which we parse with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    (This is the recursive part of “recursive descent.”) This call should return an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node representing
    the operand of the unary expression. Now we have AST nodes for both the operator
    and the operand, so we return the AST node for the whole unary expression ❸.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们即将解析的表达式是有效的，<samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>应该是一个整数、一元运算符或左括号。如果它是一个整数❶，我们像上一章那样解析它。如果它是一个一元运算符❷，我们应用[列表
    2-6](chapter2.xhtml#list2-6)中的第二个生成规则来构建一个一元表达式。该规则是<samp class="SANS_TheSansMonoCd_W5Regular_11"><unop>
    <exp></samp>，因此我们先解析一元运算符，然后解析内部表达式。<samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>符号是一个单一标记，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>，我们已经检查过了。在[列表 2-7](chapter2.xhtml#list2-7)中，我们在一个单独的函数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>，其定义已被省略）中处理<samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>。实际上，您可能不需要一个单独的函数来解析一个标记。无论如何，我们最终得到一个AST节点，表示适当的一元运算符。生成规则中的下一个符号是<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>，我们通过递归调用<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>来解析它。（这就是“递归下降”中的递归部分。）这个调用应返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST节点，表示一元表达式的操作数。现在我们有了运算符和操作数的AST节点，所以我们返回整个一元表达式的AST节点❸。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is an open
    parenthesis ❹, we apply the third production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" <exp> ")"</samp> .
    We remove the open parenthesis from the input stream, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    recursively to handle the expression that follows. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    to remove the closing parenthesis or throw a syntax error if it’s missing. Since
    the AST doesn’t need to indicate that there were parentheses, we return the inner
    expression as is ❺.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>
    isn’t an integer, a unary operator, or an open parenthesis ❻, the expression is
    malformed, so we throw a syntax error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">TACKY: A New Intermediate Representation</samp>'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting the AST to assembly isn’t as straightforward as it was in the last
    chapter. C expressions can have nested subexpressions, and assembly instructions
    can’t. A single expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~2)</samp>
    needs to be broken up into two assembly instructions: one to apply the inner bitwise
    complement operation and another to apply the outer negation operation.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll bridge the gap between C and assembly using a new intermediate representation
    (IR), *three-address code (TAC)*. In TAC, the operands of each instruction are
    constants or variables, not nested expressions. It’s called three-address code
    because most instructions use at most three values: two source operands and a
    destination. (The instructions in this chapter use only one or two values; we’ll
    introduce instructions that use three values when we implement binary operators
    in [Chapter 3](chapter3.xhtml).) To rewrite nested expressions in TAC, we often
    need to introduce new temporary variables. For example, [Listing 2-8](chapter2.xhtml#list2-8)
    shows the three-address code for <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3;</samp>.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: The three-address
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return 1 + 2 *
    3;</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: There are two main reasons to use three-address code instead of converting an
    AST directly to assembly. First, it lets us handle major structural transformations—like
    removing nested expressions—separately from the details of assembly language,
    like figuring out which operands are valid for which instructions. This means
    we can write several smaller, simpler compiler passes, instead of having one huge,
    complicated assembly generation pass. Second, three-address code is well suited
    to several optimizations we’ll implement in [Part III](part3.xhtml). It has a
    simple, uniform structure, which makes it easy to answer questions like “Is the
    result of this expression ever used?” or “Will this variable always have the same
    value?” The answers to those questions determine what optimizations are safe to
    perform.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Most compilers use some form of three-address code internally, but the details
    vary. I’ve decided to name the intermediate representation in this book *TACKY*.
    (Naming your intermediate representations is, in my opinion, one of the best parts
    of compiler design.) I made up TACKY for this book, but it’s similar to three-address
    code in other compilers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining TACKY</samp>
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll define TACKY in ASDL, like our other intermediate representations. The
    definition of TACKY in [Listing 2-9](chapter2.xhtml#list2-9) looks similar to
    the AST definition from [Listing 2-5](chapter2.xhtml#list2-5), but there are a
    few important differences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: The TACKY intermediate
    representation</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In TACKY, a function body consists of a list of instructions ❶ rather than
    a single statement. In this respect, it’s similar to the assembly AST we defined
    in the previous chapter. For now, TACKY has two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    returns a value; <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> performs
    some unary operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>,
    the source value for the expression, and stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    the destination. Both instructions operate on <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>s,
    which can be either constant integers (<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>)
    or temporary variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>).
    The TACKY we generate must meet one requirement that isn’t explicit in [Listing
    2-9](chapter2.xhtml#list2-9): the <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    of a unary operation must be a temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>,
    not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>. Trying to
    assign a value to a constant wouldn’t make sense.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the ASDL definition of TACKY, you’ll need to implement
    this definition in your own compiler, much like the definitions of the AST and
    assembly AST. Once you have your TACKY data structure, you’re ready to write the
    IR generation stage, which converts the AST to TACKY.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating TACKY</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your TACKY generation pass should traverse an AST in the form defined in [Listing
    2-5](chapter2.xhtml#list2-5) and return a TACKY AST in the form defined in [Listing
    2-9](chapter2.xhtml#list2-9). The tricky part is turning an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    node into a list of instructions; once you have that figured out, handling the
    other AST nodes is easy. [Table 2-1](chapter2.xhtml#tab2-1) lists a few examples
    of ASTs and the resulting TACKY.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">TACKY
    Representations of Unary Expressions</samp>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">AST</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">TACKY</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp> |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Unary(Complement, Constant(2)))</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement, Constant(2),
    Var("tmp.0")) Return(Var("tmp.0"))</samp> |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate, Constant(8),
    Var("tmp.0"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement,
    Var("tmp.0"), Var("tmp.1"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate,
    Var("tmp.1"), Var("tmp.2")) Return(Var("tmp.2"))</samp> |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: In these examples, we convert each unary operation into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    TACKY instruction, starting with the innermost expression and working our way
    out. We store the result of each <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    instruction in a temporary variable, which we then use in the outer expression
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. [Listing
    2-10](chapter2.xhtml#list2-10) describes how to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node to TACKY.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Converting an
    expression into a list of TACKY instructions</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: This pseudocode emits the instructions needed to calculate an expression by
    appending them to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp>
    argument. It also returns a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    that represents the result of the expression, which we’ll use when translating
    the outer expression or statement.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">match</samp> statement in
    [Listing 2-10](chapter2.xhtml#list2-10) checks which type of expression we’re
    translating, then runs the clause to handle that expression. If the expression
    is a constant, we return the equivalent TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>
    without generating any new instructions. Note that this code includes two different
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> constructs; the
    one we match on is a node in the original AST ❶, while the one we return is a
    node in the TACKY AST ❷. The same is true for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    constructs that appear in the following clause.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> is a unary expression,
    we construct TACKY values for the source and destination. First, we call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively on the source
    expression to get the corresponding TACKY value. This also generates the TACKY
    instructions to calculate that value. Then, we create a new temporary variable
    for the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_temporary</samp>
    helper function generates a unique name for this variable. We use another helper
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_unop</samp>, to
    convert the unary operator to its TACKY equivalent. Once we have our source, destination,
    and unary operator, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    TACKY instruction and append it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp>
    list. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    as the result of the whole expression.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    processes an expression, not a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. You need a separate function (which I won’t provide pseudocode for)
    to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    to TACKY. This function should call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    to process the statement’s return value, then emit a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Names
    for Temporary Variables</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s clear that every temporary variable needs a distinct name. In later chapters,
    we’ll also need to guarantee that these autogenerated names won’t conflict with
    user-defined names for functions and global variables, or with autogenerated names
    from different functions. These identifiers must all be unique because we’ll store
    all of them—autogenerated names and user-defined function and variable names—in
    the same table.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: One simple solution is to maintain a global integer counter; to generate a unique
    name, increment the counter and use its new value as the name of the temporary
    variable. This name won’t conflict with other temporary names because the counter
    produces a new value each time we increment it. It won’t conflict with user-defined
    identifiers because integers aren’t valid identifiers in C. In [Table 2-1](chapter2.xhtml#tab2-1),
    I used a variation on this approach, concatenating a descriptive string, a period,
    and the value of the global counter to produce unique identifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.0</samp>.
    These won’t conflict with user-defined identifiers because C identifiers can’t
    contain periods. With this naming scheme, you can encode useful information in
    autogenerated names, like the name of the function where they’re used. (It’s less
    useful if you name every variable <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    like I’ve done here.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的解决方案是维护一个全局整数计数器；为了生成一个唯一的名称，递增计数器并使用其新值作为临时变量的名称。这个名称不会与其他临时名称冲突，因为每次递增计数器时它都会生成一个新值。它也不会与用户定义的标识符冲突，因为整数在
    C 语言中不是有效的标识符。在[表 2-1](chapter2.xhtml#tab2-1)中，我使用了这种方法的变体，将描述性字符串、句点和全局计数器的值连接起来，生成像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp.0</samp>这样的唯一标识符。这些不会与用户定义的标识符冲突，因为
    C 语言中的标识符不能包含句点。通过这种命名方案，你可以在自动生成的名称中编码有用的信息，比如它们所在的函数名称。（如果你像我这里一样将每个变量命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>，那就没那么有用了。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Compiler
    Driver</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新编译器驱动程序</samp>
- en: To test out the TACKY generator, you need to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">--tacky</samp>
    command line option to run your compiler through the TACKY generation stage, stopping
    before assembly generation. Like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">--lex</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--parse</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp>
    options, this new option shouldn’t produce any output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 TACKY 生成器，你需要添加一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">--tacky</samp>命令行选项，通过该选项让编译器运行到
    TACKY 生成阶段，但在汇编生成之前停止。像现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">--lex</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">--parse</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp>选项一样，这个新选项不应产生任何输出。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: TACKY is closer to assembly, but it still doesn’t specify exactly which assembly
    instructions we need. The next step is converting the program from TACKY into
    the assembly AST we defined in the last chapter. We’ll do this in three small
    compiler passes. First, we’ll produce an assembly AST, but still refer to temporary
    variables directly. Next, we’ll replace those variables with concrete addresses
    on the stack. That step will result in some invalid instructions because many
    x64 assembly instructions can’t use memory addresses for both operands. So, in
    the last compiler pass, we’ll rewrite the assembly AST to fix any invalid instructions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: TACKY 更接近汇编，但它仍然没有明确指出我们需要哪些汇编指令。下一步是将 TACKY 程序转换为我们在上一章定义的汇编抽象语法树（AST）。我们将在三个小的编译器阶段完成这个过程。首先，我们将生成一个汇编
    AST，但仍然直接引用临时变量。接下来，我们将用栈上的具体地址替换这些变量。这一步会导致一些无效的指令，因为许多 x64 汇编指令不能对两个操作数使用内存地址。所以，在最后一个编译器阶段，我们将重写汇编
    AST，以修复任何无效的指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY
    to Assembly</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将 TACKY 转换为汇编</samp>
- en: We’ll start by extending the assembly AST we defined in the last chapter. We
    need some new constructs to represent the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instructions from
    [Listing 2-2](chapter2.xhtml#list2-2). We also need to decide how to represent
    the function prologue and epilogue in the assembly AST.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从扩展上一章中定义的汇编 AST 开始。我们需要一些新的构造来表示[清单 2-2](chapter2.xhtml#list2-2)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>指令。我们还需要决定如何在汇编
    AST 中表示函数的前导和尾声。
- en: There are a few different ways to handle the prologue and epilogue. We could
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instructions to the
    assembly AST. We could add high-level instructions that correspond to the entire
    prologue and epilogue, instead of maintaining a one-to-one correspondence between
    assembly AST constructs and assembly instructions. Or we could leave out the function
    prologue and epilogue entirely and add them during code emission. I’ll use a combination
    of the first and last options. This chapter’s assembly AST, shown in [Listing
    2-11](chapter2.xhtml#list2-11), includes a construct corresponding to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction (the third instruction
    in the function prologue). This construct specifies how many bytes we need to
    subtract from the stack pointer. The assembly AST doesn’t include the other instructions
    from the prologue and epilogue; these instructions are always the same, so we
    can add them during code emission. That said, the other approaches to representing
    the function prologue and epilogue will also work, so choose whichever you like
    best.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数序言和尾声有几种不同的方法。我们可以将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>`、
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>`
    指令添加到汇编 AST 中。我们可以添加对应于整个函数序言和尾声的高级指令，而不是维护汇编 AST 结构和汇编指令之间的一对一对应关系。或者我们可以完全忽略函数序言和尾声，并在代码生成过程中添加它们。我会同时使用第一种和最后一种选项的结合。本章的汇编
    AST 在 [Listing 2-11](chapter2.xhtml#list2-11) 中显示了与 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>`
    指令（函数序言中的第三条指令）对应的结构。该结构指定了我们需要从堆栈指针中减去的字节数。汇编 AST 不包括序言和尾声中的其他指令；这些指令总是相同的，因此我们可以在代码生成过程中添加它们。尽管如此，其他代表函数序言和尾声的方法也能工作，所以选择你喜欢的方式。
- en: We’ll also introduce *pseudoregisters* to represent temporary variables. We
    use pseudoregisters as operands in assembly instructions, like real registers;
    the only difference is that we have an unlimited supply of them. Because they
    aren’t real registers, they can’t appear in the final assembly program; they’ll
    need to be replaced by real registers or memory addresses in a later compiler
    pass. For now, we’ll assign every pseudoregister to a distinct address in memory.
    In [Part III](part3.xhtml), we’ll write a *register allocator*, which assigns
    as many pseudoregisters as possible to hardware registers instead of memory addresses.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引入 *伪寄存器* 来表示临时变量。我们将伪寄存器作为汇编指令中的操作数使用，就像真实寄存器一样；唯一的区别在于我们可以无限制地使用它们。因为它们不是真实寄存器，所以它们不能出现在最终的汇编程序中；在后续的编译器通行证中，它们需要被真实寄存器或内存地址替换。目前，我们将每个伪寄存器分配到内存中的不同地址。在
    [第三部分](part3.xhtml) 中，我们将编写一个 *寄存器分配器*，它将尽可能多地将伪寄存器分配给硬件寄存器，而不是内存地址。
- en: '[Listing 2-11](chapter2.xhtml#list2-11) shows the updated assembly AST, with
    the new parts bolded.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-11](chapter2.xhtml#list2-11) 展示了更新后的汇编 AST，新增部分已加粗。'
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: The assembly
    AST with unary operators</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: 带有一元运算符的汇编 AST</samp>`'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> node has
    a couple of new constructors to represent our new assembly instructions. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor represents a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    instruction. It takes one operand that’s used as both source and destination.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> constructor
    represents the third instruction in the function prologue, <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    %rsp</samp>. Its one child, an integer, indicates the number of bytes we subtract
    from RSP.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp>` 节点新增了几个构造函数，用于表示我们的新汇编指令。
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>` 构造函数表示单个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>`
    或 `<samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>` 指令。它接受一个操作数，用作源操作数和目的操作数。
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>` 构造函数表示函数序言中的第三条指令，
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp>`。它的一个子节点是整数，指示我们从 RSP 中减去的字节数。'
- en: 'We also have several new instruction operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    constructor represents a hardware register. It can specify either hardware register
    we’ve seen so far: EAX or R10D. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand lets us use an arbitrary identifier as a pseudoregister. We use this to
    refer to the temporary variables we produced while generating TACKY. Ultimately,
    we need to replace every pseudoregister with a location on the stack; we represent
    those with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand,
    which indicates the stack address at the given offset from RBP. For example, we’d
    represent the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    with the assembly AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Every hardware register has several aliases, depending on how many bytes of
    the register you need. EAX refers to the lower 32 bits of the 64-bit RAX register,
    and R10D refers to the lower 32 bits of the 64-bit R10 register. The names AL
    and R10B refer to the lower 8 bits of RAX and R10, respectively. Register names
    in the assembly AST are size agnostic, so AX in [Listing 2-11](chapter2.xhtml#list2-11)
    can refer to the register alias RAX, EAX, or AL, depending on context. (The name
    AX normally refers to the lower 16 bytes of RAX, but we won’t use 16-byte register
    aliases in this book.)*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write a straightforward conversion from TACKY to assembly, shown
    in [Tables 2-2](chapter2.xhtml#tab2-2) through [2-5](chapter2.xhtml#tab2-5). As
    [Table 2-2](chapter2.xhtml#tab2-2) illustrates, we convert TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp> nodes to the
    corresponding assembly constructs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: We’ll convert each TACKY instruction to a sequence of assembly instructions,
    as shown in [Table 2-3](chapter2.xhtml#tab2-3). Since our new assembly instructions
    use the same operand for the source and destination, we copy the source value
    into the destination before issuing a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">返回(值)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(值,
    Reg(AX)) Ret</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator,
    dst)</samp> |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">一元运算符(一元运算符, 源, 目标)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(源, 目标) 一元运算符(一元运算符, 目标)</samp>
    |'
- en: '[Table 2-4](chapter2.xhtml#tab2-4) shows the corresponding assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>
    for each TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>,
    and [Table 2-5](chapter2.xhtml#tab2-5) shows the conversion from TACKY operands
    to assembly operands.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](chapter2.xhtml#tab2-4) 显示了每个 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">一元运算符</samp>
    对应的汇编 <samp class="SANS_TheSansMonoCd_W5Regular_11">一元运算符</samp>，而 [表 2-5](chapter2.xhtml#tab2-5)
    显示了 TACKY 操作数到汇编操作数的转换。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 算术运算符转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编运算符</samp>
    |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">补码</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">取反</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">常量(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">立即数(int)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp> |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">变量(标识符)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">伪变量(标识符)</samp>
    |'
- en: Note that we’re not using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction yet; we’ll add it in the very last pass before code emission, once
    we know how many bytes we need to allocate. We’re also not using any <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands; we’ll replace every <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand
    in the next compiler pass. And we’re not using the R10D register; we’ll introduce
    it when we rewrite invalid instructions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    指令；我们将在代码生成的最后阶段添加它，当我们知道需要分配多少字节时。我们也没有使用任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    操作数；我们将在下一个编译阶段将每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    操作数替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> 操作数。同时，我们还没有使用
    R10D 寄存器；我们将在重写无效指令时引入它。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换伪寄存器</samp>'
- en: 'Next, we write a compiler pass to replace each <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand,
    leaving the rest of the assembly AST unchanged. In [Listing 2-2](chapter2.xhtml#list2-2),
    we used two stack locations: <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. This pass follows
    the same pattern: we replace the first temporary variable we see with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>,
    the next with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-8)</samp>,
    and so on. We subtract four for each new variable, since every temporary variable
    is a 4-byte integer. You’ll need to maintain a map from identifiers to offsets
    as you go so you can replace each pseudoregister with the same address on the
    stack every time it appears. For example, if you process the instructions'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: you should replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("a")</samp>
    with the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand
    in both instructions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This compiler pass should also return the stack offset of the final temporary
    variable, because that tells us how many bytes to allocate on the stack in the
    next pass.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we need to traverse the assembly AST one more time and make two small fixes.
    First, we’ll insert the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction at the very beginning of the instruction list in the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    The integer argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    should be the stack offset of the last temporary variable we allocated in the
    previous compiler pass. That way, we’ll allocate enough space on the stack to
    accommodate every address we use. For example, if we replace three temporary variables,
    replacing the last one with <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>,
    we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(12)</samp>
    at the front of the instruction list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The second fix is rewriting invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions. When we replaced pseudoregisters with stack addresses, we may have
    ended up with <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions
    where both the source and destination are <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands. This happens when the unary expression in your program has at least
    one level of nesting. But <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>,
    like many other instructions, can’t have memory addresses as both the source and
    the destination. If you try to assemble a program with an instruction like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl -4(%rbp), -8(%rbp)</samp>, the assembler
    will reject it. When you encounter an invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction, rewrite it to first copy from the source address into R10D and then
    copy from R10D to the destination. For example, the instruction
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'becomes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I’ve chosen R10D as a scratch register because it doesn’t serve any other special
    purpose. Some registers are required by particular instructions; for example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, which
    performs division, requires the dividend to be stored in EAX. Other registers
    are used to pass arguments during function calls. Using any of these registers
    for scratch at this stage could cause conflicts. For example, you might copy a
    function argument into the correct register, but then accidentally overwrite it
    while using that register to transfer a different value between memory addresses.
    Because R10D doesn’t have any special purpose, we don’t have to worry about these
    conflicts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we’ll extend the code emission stage to handle our new constructs and
    print out the function prologue and epilogue. [Tables 2-6](chapter2.xhtml#tab2-6)
    through [2-9](chapter2.xhtml#tab2-9) show how to print out each assembly construct.
    New constructs and changes to the way we emit existing constructs are bolded.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-6](chapter2.xhtml#tab2-6) shows how to include the prologue when you
    emit an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-7](chapter2.xhtml#tab2-7) shows how to include the function epilogue
    just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction
    and how to emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instructions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(unary_operator, operand)</samp>
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AllocateStack(int)</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: As this table illustrates, you should emit <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction. Emit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp> instruction, according
    to its <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp> argument.
    [Table 2-8](chapter2.xhtml#tab2-8) shows which <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>
    corresponds to each of these instructions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-8:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">negl</samp>
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">notl</samp>
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: Finally, [Table 2-9](chapter2.xhtml#tab2-9) shows how to print out the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-9:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(AX)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%eax</samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R10)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10d</samp>
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stack(int)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">(%rbp)</samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: Because RBP and RSP contain memory addresses, which are 8 bytes, we always operate
    on them using quadword instructions, which have a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    suffix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction
    in [Table 2-7](chapter2.xhtml#tab2-7) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction in the prologue and epilogue are identical apart from the size of
    their operands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you extended your compiler to implement negation and bitwise
    complement. You also implemented a new intermediate representation, wrote two
    new compiler passes that transform assembly code, and learned how stack frames
    are structured. Next, you’ll implement binary operations like addition and subtraction.
    The changes to the backend in the next chapter are pretty simple; the tricky part
    is getting the parser to respect operator precedence and associativity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter touched on *two’s complement*, which is how all modern computers
    represent signed integers. Two’s complement will show up throughout this book,
    so it’s worth taking the time to understand it. Here are a couple of overviews
    of how it works:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: “Two’s Complement” by Thomas Finley covers how and why two’s complement representations
    work (*[https://<wbr>www<wbr>.cs<wbr>.cornell<wbr>.edu<wbr>/~tomf<wbr>/notes<wbr>/cps104<wbr>/twoscomp<wbr>.html](https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html)*).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2](chapter2.xhtml) of *The Elements of Computing Systems* by Noam
    Nisan and Shimon Schocken (MIT Press, 2005) covers similar material from a more
    hardware-focused perspective. This is the companion book for the Nand to Tetris
    project. This chapter is freely available at *[https://<wbr>www<wbr>.nand2tetris<wbr>.org<wbr>/course](https://www.nand2tetris.org/course)*;
    click the book icon under “Project 2: Boolean Arithmetic.”'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
