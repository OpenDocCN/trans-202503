- en: '![](../images/pg24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-05.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">UNARY
    OPERATORS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'C has several *unary operators*, which operate on a single value. In this chapter,
    you’ll extend your compiler to handle two unary operators: negation and bitwise
    complement. You’ll transform complex, nested unary expressions into simple operations
    that can be expressed in assembly. Instead of performing this transformation in
    a single compiler pass, you’ll introduce a new intermediate representation between
    the AST produced by the parser and the assembly AST produced by the assembly generation
    pass. You’ll also break up assembly generation into several smaller passes. The
    new passes are bolded in the diagram at the start of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let’s look at a C program using the new unary operators and
    the corresponding assembly we’ll generate.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Negation and Bitwise Complement in Assembly</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn to compile programs like [Listing 2-1](chapter2.xhtml#list2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A C program with
    negation and bitwise complement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program contains a nested expression using both new unary operators. The
    first operator, *negation* (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>),
    negates an integer—no surprise there. The *bitwise complement* (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    operator flips every bit in an integer, which has the effect of negating the integer
    and then subtracting one. (It has this effect because computers use a system called
    *two’s complement* to represent signed integers. If you’re not familiar with two’s
    complement, see “Additional Resources” on [page 45](#pg_45) for links to a few
    explanations of how it works.)
  prefs: []
  type: TYPE_NORMAL
- en: Your compiler will convert [Listing 2-1](chapter2.xhtml#list2-1) to the assembly
    code in [Listing 2-2](chapter2.xhtml#list2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: The assembly code
    for [Listing 2-1](chapter2.xhtml#list2-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first three instructions after <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    form the *function prologue*, which sets up the current stack frame; I’ll cover
    them in the next section, when I talk about the stack in detail. After the function
    prologue, we calculate the intermediate result, –2, and then the final result,
    1, storing each of them at a unique memory address. This isn’t very efficient,
    since we waste a lot of instructions copying values from one address to another.
    The optimizations we’ll implement in [Part III](part3.xhtml) will clean up most
    of these unnecessary copies.
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    ❶ stores <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> at an address
    in memory. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    ❷ means “the value stored in the RBP register, minus four.” The value in RBP is
    a memory address on the stack (more on this shortly), so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> refers to another memory address
    4 bytes lower. Next, we negate the value at this address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    instruction ❸, so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>. (Just
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    has an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix to indicate
    that it’s operating on a 32-bit value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We then handle the outer bitwise complement expression. We start by copying
    the source value, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    to the destination address at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We can’t do this in a single instruction, because <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    can’t have memory addresses as both its source and destination operands. At least
    one operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> needs
    to be a register or an immediate value. We get around this by copying <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>
    from memory into a scratch register, R10D ❹, and from there to the destination
    memory address ❺. Then, we take the bitwise complement of <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction
    ❻, so memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    now contains the value we want to return: <samp class="SANS_TheSansMonoCd_W5Regular_11">~(-2)</samp>,
    which evaluates to 1\. To return this value, we move it into EAX ❼. The final
    three instructions are the *function epilogue*, which tears down the stack frame
    and returns from the function.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you compile [Listing 2-1](chapter2.xhtml#list2-1) to assembly using GCC,
    Clang, or any other production C compiler, it won’t look anything like [Listing
    2-2](chapter2.xhtml#list2-2). That’s because those compilers evaluate constant
    expressions at compile time, even when you’ve disabled optimizations! I’m guessing
    they behave this way because some constant expressions, like static variable initializers,*
    must *be evaluated at compile time, and evaluating all constant expressions at
    compile time is simpler than evaluating only some.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Stack</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are still two unanswered questions about [Listing 2-2](chapter2.xhtml#list2-2):
    what the function prologue and epilogue do, and why we refer to stack addresses
    relative to a value in the RBP register. To answer these questions, we need to
    talk about the segment of program memory called the *stack*. The RSP register,
    also called the *stack pointer*, always holds the address of the top of the stack.
    (RSP points to the last used stack slot, rather than the first free one.) As with
    any stack data structure, you can push values onto the stack and pop values off
    it; the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    assembly instructions do exactly that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack grows toward lower memory addresses. When you push something onto
    the stack, you decrement RSP. That means the “top of the stack”—the address stored
    in RSP—is the *lowest* address on the stack. The stack diagrams in this book are
    oriented with lower memory addresses at the top, so the top of the stack is at
    the top of the diagram. Think of the memory addresses in these diagrams like line
    numbers in a code listing. The top of a code listing is line 1, and line numbers
    increase as you go down; similarly, the addresses in these diagrams increase as
    you go down the page or screen. Note that most stack diagrams in other books and
    articles use the opposite orientation: they put the top of the stack at the bottom
    of the diagram, so lower memory addresses appear lower on the page. I find that
    layout really confusing, but if you prefer it, just turn your book upside down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">push $3</samp>
    does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Writes the value being pushed (in this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>)
    to the next empty spot on the stack. The <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instructions adjust
    the stack pointer in 8-byte increments, and the top value on the stack is currently
    at the address stored in RSP, so the next empty spot is RSP – 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrements RSP by 8 bytes. The new address in RSP is now the top of the stack,
    and the value at that address is <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 2-1](#fig2-1) illustrates the effect of a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction on the stack and RSP register.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The effect of push
    $3 on memory and RSP [Description](description-06.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction performs
    the opposite operation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop
    %rax</samp> copies the value at the top of the stack into the RAX register, then
    adds 8 bytes to RSP.
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction
    decrements the stack pointer by 8 bytes, it has to push an 8-byte value. Likewise,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction always
    pops an 8-byte value off the stack. Values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>—like
    the return value in [Listing 2-1](chapter2.xhtml#list2-1)—are only 4 bytes. You
    can’t push only 4 bytes onto the stack, but you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    to copy a 4-byte value into stack space you’ve already allocated. A couple of
    instructions do this in [Listing 2-2](chapter2.xhtml#list2-2), including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl $2, -4(%rbp)</samp>. (On 32-bit systems,
    the reverse is true; you can push and pop 4-byte values but not 8-byte values.
    On both kinds of systems, it’s also possible, though very unusual, to push and
    pop 2-byte values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp> instructions; the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> suffix, for *word*, indicates
    that the instruction takes a 2-byte operand. We won’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp>, or any other 2-byte
    instructions in this book.) Memory addresses on x64 systems are 8 bytes, so you
    can use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    to put them on and take them off the stack. This will come in handy in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The stack isn’t just an undifferentiated chunk of memory; it’s divided into
    sections called *stack frames*. Whenever a function is called, it allocates some
    memory at the top of the stack by decreasing the stack pointer. This memory is
    the function’s stack frame, where it stores local variables and temporary values.
    Just before the function returns, it deallocates its stack frame, restoring the
    stack pointer to its previous value. By convention, the RBP register points to
    the base of the current stack frame; for this reason, it’s sometimes called the
    *base pointer*. We refer to data in the current stack frame relative to the address
    stored in RBP. This means we don’t need absolute addresses, which we can’t know
    in advance. Since the stack grows toward lower memory addresses, every address
    in the current stack frame is lower than the address stored in RBP; this is why
    the addresses of local variables, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    all have negative offsets from RBP. In later chapters, we’ll also refer to data
    in the caller’s stack frame, like function parameters, relative to RBP. (It’s
    possible to refer to local variables and parameters relative to RSP instead, and
    not bother with RBP at all; most production compilers do this as an optimization.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand how the stack works, let’s look at the function prologue
    and epilogue in more detail. The function prologue sets up the stack frame in
    three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq %rbp</samp> saves the current
    value of RBP, the address of the base of the caller’s stack frame, onto the stack.
    We’ll need this value when we restore the caller’s stack frame later. This value
    will be at the bottom of the new stack frame established by the next instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rsp, %rbp</samp> makes
    the top of the stack the base of the new stack frame. At this point, the top and
    bottom of the current stack frame are the same. The current stack frame holds
    exactly one value, which both RSP and RBP point to: the base of the caller’s stack
    frame, which we saved in the previous instruction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp> decrements the stack pointer
    by *n* bytes. The stack frame now has *n* bytes available to store local and temporary
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 2-2](#fig2-2) shows how each instruction in the function prologue affects
    the stack. In this figure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction allocates 24 bytes, enough space for six 4-byte integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig2-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The state of the
    stack at each point in the function prologue [Description](description-07.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function epilogue restores the caller’s stack frame by setting RSP and
    RBP back to the same values they had before the function prologue. This requires
    two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rbp, %rsp</samp> puts us
    back where we were after the second instruction of the function prologue: both
    RSP and RBP point to the bottom of the current stack frame, which holds the caller’s
    value for RBP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">popq %rbp</samp> reverses the
    first instruction of the function prologue and restores the caller’s values for
    the RSP and RBP registers. It restores RBP because the value at the top of the
    stack was the base address of the caller’s stack frame that we saved at the start
    of the prologue. It restores RSP by removing the last value in this stack frame
    from the stack, leaving RSP pointing to the top of the caller’s stack frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 2-3](#fig2-3) shows the effect of each instruction in the function
    epilogue.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig2-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The state of the
    stack at each point in the function epilogue [Description](description-08.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what output our compiler should produce, let’s keep coding.
    We’ll start by extending the lexer and parser.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll extend the lexer to recognize three new tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">~</samp> | A tilde, the bitwise
    complement operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-</samp> | A hyphen, the negation
    operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--</samp> | Two hyphens, the
    decrement operator |'
  prefs: []
  type: TYPE_TB
- en: While you won’t implement the decrement operator in this chapter, you still
    need to add a token for it. Otherwise, your compiler will accept programs it should
    reject, like the one in [Listing 2-3](chapter2.xhtml#list2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: An invalid C program
    using the decrement operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This shouldn’t compile, because you can’t decrement a constant. But if your
    compiler doesn’t know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    is a distinct token, it will think [Listing 2-3](chapter2.xhtml#list2-3) is equivalent
    to [Listing 2-4](chapter2.xhtml#list2-4), which is a perfectly valid program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A valid C program
    with two negation operators in a row</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Your compiler should reject language features you haven’t implemented; it shouldn’t
    compile them incorrectly. That’s why your lexer needs to know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    is a single token, not just two negation operators in a row. (On the other hand,
    the lexer should lex <samp class="SANS_TheSansMonoCd_W5Regular_11">~~</samp> as
    two bitwise complement operators in a row. Expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">~~2</samp>
    are valid.)
  prefs: []
  type: TYPE_NORMAL
- en: You can process the new tokens the same way you handled punctuation like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>in
    [Chapter 1](chapter1.xhtml). First, you need to define a regular expression for
    each new token. The regular expressions here are the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>.
    Next, have your lexer check the input against these new regexes, as well as the
    regexes from the previous chapter, every time it tries to produce a token. When
    the start of the input stream matches more than one possible token, choose the
    longest one. For example, if your input stream starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>,
    parse it as a decrement operator rather than two negation operators.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To parse the new operators in this chapter, we first need to extend the AST
    and formal grammar we defined in [Chapter 1](chapter1.xhtml). Let’s look at the
    AST first. Since unary operations are expressions, we represent them with a new
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST
    node. [Listing 2-5](chapter2.xhtml#list2-5) shows the updated AST definition,
    with new parts bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: The abstract syntax
    tree with unary operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    indicates that an expression can be either a constant integer or a unary operation.
    A unary operation consists of one of the two unary operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>, applied to an
    inner expression. Notice that the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    is recursive: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor
    for an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node contains
    another <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node. This lets
    us construct arbitrarily deeply nested expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~(-~-(-4)))</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to make the corresponding changes to the grammar, shown in [Listing
    2-6](chapter2.xhtml#list2-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: The formal grammar
    with unary operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-6](chapter2.xhtml#list2-6) includes a new production rule for unary
    expressions and a <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    symbol to represent the two unary operators. These changes correspond to the additions
    to the AST in [Listing 2-5](chapter2.xhtml#list2-5). We’ve also added a third
    production rule for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    symbol, which describes a parenthesized expression. It doesn’t have a corresponding
    constructor in the AST because the rest of the compiler doesn’t need to distinguish
    between an expression wrapped in parentheses and the same expression without parentheses.
    The expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">((((1))))</samp>
    are all represented by the same AST node: <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The decrement operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>)
    doesn’t show up anywhere in this grammar, so your parser should fail if it encounters
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> token.
  prefs: []
  type: TYPE_NORMAL
- en: To update the parsing stage, modify your compiler’s AST data structure to match
    [Listing 2-5](chapter2.xhtml#list2-5). Then, update your recursive descent parsing
    code to reflect the changes in [Listing 2-6](chapter2.xhtml#list2-6). Parsing
    an expression gets a bit more complicated in this chapter because you need to
    figure out which of the three different production rules for the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    symbol to apply. The pseudocode in [Listing 2-7](chapter2.xhtml#list2-7) demonstrates
    how to parse an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Parsing an expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we look at the next token in the input to figure out which production
    rule to apply. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">peek</samp>
    to look at this token without removing it from the input stream. Once we know
    which production rule to use, we’ll want to process the whole input, including
    that first token, using that rule. So, we don’t want to consume this token from
    the input just yet.
  prefs: []
  type: TYPE_NORMAL
- en: If the expression we’re about to parse is valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>
    should be an integer, a unary operator, or an open parenthesis. If it’s an integer
    ❶, we parse it the same way as in the previous chapter. If it’s a unary operator
    ❷, we apply the second production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    from [Listing 2-6](chapter2.xhtml#list2-6) to construct a unary expression. This
    rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop> <exp></samp>, so
    we parse the unary operator and then the inner expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    symbol is a single token, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>,
    which we’ve already inspected. In [Listing 2-7](chapter2.xhtml#list2-7), we handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp> in a separate function
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>, whose definition
    I’ve omitted). In practice, you probably don’t need a separate function to parse
    one token. Either way, we end up with an AST node representing the appropriate
    unary operator. The next symbol in the production rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    which we parse with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    (This is the recursive part of “recursive descent.”) This call should return an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node representing
    the operand of the unary expression. Now we have AST nodes for both the operator
    and the operand, so we return the AST node for the whole unary expression ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is an open
    parenthesis ❹, we apply the third production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" <exp> ")"</samp> .
    We remove the open parenthesis from the input stream, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    recursively to handle the expression that follows. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    to remove the closing parenthesis or throw a syntax error if it’s missing. Since
    the AST doesn’t need to indicate that there were parentheses, we return the inner
    expression as is ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>
    isn’t an integer, a unary operator, or an open parenthesis ❻, the expression is
    malformed, so we throw a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">TACKY: A New Intermediate Representation</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting the AST to assembly isn’t as straightforward as it was in the last
    chapter. C expressions can have nested subexpressions, and assembly instructions
    can’t. A single expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~2)</samp>
    needs to be broken up into two assembly instructions: one to apply the inner bitwise
    complement operation and another to apply the outer negation operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll bridge the gap between C and assembly using a new intermediate representation
    (IR), *three-address code (TAC)*. In TAC, the operands of each instruction are
    constants or variables, not nested expressions. It’s called three-address code
    because most instructions use at most three values: two source operands and a
    destination. (The instructions in this chapter use only one or two values; we’ll
    introduce instructions that use three values when we implement binary operators
    in [Chapter 3](chapter3.xhtml).) To rewrite nested expressions in TAC, we often
    need to introduce new temporary variables. For example, [Listing 2-8](chapter2.xhtml#list2-8)
    shows the three-address code for <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3;</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: The three-address
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return 1 + 2 *
    3;</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are two main reasons to use three-address code instead of converting an
    AST directly to assembly. First, it lets us handle major structural transformations—like
    removing nested expressions—separately from the details of assembly language,
    like figuring out which operands are valid for which instructions. This means
    we can write several smaller, simpler compiler passes, instead of having one huge,
    complicated assembly generation pass. Second, three-address code is well suited
    to several optimizations we’ll implement in [Part III](part3.xhtml). It has a
    simple, uniform structure, which makes it easy to answer questions like “Is the
    result of this expression ever used?” or “Will this variable always have the same
    value?” The answers to those questions determine what optimizations are safe to
    perform.
  prefs: []
  type: TYPE_NORMAL
- en: Most compilers use some form of three-address code internally, but the details
    vary. I’ve decided to name the intermediate representation in this book *TACKY*.
    (Naming your intermediate representations is, in my opinion, one of the best parts
    of compiler design.) I made up TACKY for this book, but it’s similar to three-address
    code in other compilers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll define TACKY in ASDL, like our other intermediate representations. The
    definition of TACKY in [Listing 2-9](chapter2.xhtml#list2-9) looks similar to
    the AST definition from [Listing 2-5](chapter2.xhtml#list2-5), but there are a
    few important differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: The TACKY intermediate
    representation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In TACKY, a function body consists of a list of instructions ❶ rather than
    a single statement. In this respect, it’s similar to the assembly AST we defined
    in the previous chapter. For now, TACKY has two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    returns a value; <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> performs
    some unary operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>,
    the source value for the expression, and stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    the destination. Both instructions operate on <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>s,
    which can be either constant integers (<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>)
    or temporary variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>).
    The TACKY we generate must meet one requirement that isn’t explicit in [Listing
    2-9](chapter2.xhtml#list2-9): the <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    of a unary operation must be a temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>,
    not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>. Trying to
    assign a value to a constant wouldn’t make sense.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the ASDL definition of TACKY, you’ll need to implement
    this definition in your own compiler, much like the definitions of the AST and
    assembly AST. Once you have your TACKY data structure, you’re ready to write the
    IR generation stage, which converts the AST to TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your TACKY generation pass should traverse an AST in the form defined in [Listing
    2-5](chapter2.xhtml#list2-5) and return a TACKY AST in the form defined in [Listing
    2-9](chapter2.xhtml#list2-9). The tricky part is turning an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    node into a list of instructions; once you have that figured out, handling the
    other AST nodes is easy. [Table 2-1](chapter2.xhtml#tab2-1) lists a few examples
    of ASTs and the resulting TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">TACKY
    Representations of Unary Expressions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">AST</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">TACKY</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Unary(Complement, Constant(2)))</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement, Constant(2),
    Var("tmp.0")) Return(Var("tmp.0"))</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate, Constant(8),
    Var("tmp.0"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement,
    Var("tmp.0"), Var("tmp.1"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate,
    Var("tmp.1"), Var("tmp.2")) Return(Var("tmp.2"))</samp> |'
  prefs: []
  type: TYPE_TB
- en: In these examples, we convert each unary operation into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    TACKY instruction, starting with the innermost expression and working our way
    out. We store the result of each <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    instruction in a temporary variable, which we then use in the outer expression
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. [Listing
    2-10](chapter2.xhtml#list2-10) describes how to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node to TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Converting an
    expression into a list of TACKY instructions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This pseudocode emits the instructions needed to calculate an expression by
    appending them to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp>
    argument. It also returns a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    that represents the result of the expression, which we’ll use when translating
    the outer expression or statement.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">match</samp> statement in
    [Listing 2-10](chapter2.xhtml#list2-10) checks which type of expression we’re
    translating, then runs the clause to handle that expression. If the expression
    is a constant, we return the equivalent TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>
    without generating any new instructions. Note that this code includes two different
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> constructs; the
    one we match on is a node in the original AST ❶, while the one we return is a
    node in the TACKY AST ❷. The same is true for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    constructs that appear in the following clause.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> is a unary expression,
    we construct TACKY values for the source and destination. First, we call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively on the source
    expression to get the corresponding TACKY value. This also generates the TACKY
    instructions to calculate that value. Then, we create a new temporary variable
    for the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_temporary</samp>
    helper function generates a unique name for this variable. We use another helper
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_unop</samp>, to
    convert the unary operator to its TACKY equivalent. Once we have our source, destination,
    and unary operator, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    TACKY instruction and append it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp>
    list. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    as the result of the whole expression.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    processes an expression, not a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. You need a separate function (which I won’t provide pseudocode for)
    to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    to TACKY. This function should call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    to process the statement’s return value, then emit a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Names
    for Temporary Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s clear that every temporary variable needs a distinct name. In later chapters,
    we’ll also need to guarantee that these autogenerated names won’t conflict with
    user-defined names for functions and global variables, or with autogenerated names
    from different functions. These identifiers must all be unique because we’ll store
    all of them—autogenerated names and user-defined function and variable names—in
    the same table.
  prefs: []
  type: TYPE_NORMAL
- en: One simple solution is to maintain a global integer counter; to generate a unique
    name, increment the counter and use its new value as the name of the temporary
    variable. This name won’t conflict with other temporary names because the counter
    produces a new value each time we increment it. It won’t conflict with user-defined
    identifiers because integers aren’t valid identifiers in C. In [Table 2-1](chapter2.xhtml#tab2-1),
    I used a variation on this approach, concatenating a descriptive string, a period,
    and the value of the global counter to produce unique identifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.0</samp>.
    These won’t conflict with user-defined identifiers because C identifiers can’t
    contain periods. With this naming scheme, you can encode useful information in
    autogenerated names, like the name of the function where they’re used. (It’s less
    useful if you name every variable <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    like I’ve done here.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Compiler
    Driver</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test out the TACKY generator, you need to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">--tacky</samp>
    command line option to run your compiler through the TACKY generation stage, stopping
    before assembly generation. Like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">--lex</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--parse</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp>
    options, this new option shouldn’t produce any output.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TACKY is closer to assembly, but it still doesn’t specify exactly which assembly
    instructions we need. The next step is converting the program from TACKY into
    the assembly AST we defined in the last chapter. We’ll do this in three small
    compiler passes. First, we’ll produce an assembly AST, but still refer to temporary
    variables directly. Next, we’ll replace those variables with concrete addresses
    on the stack. That step will result in some invalid instructions because many
    x64 assembly instructions can’t use memory addresses for both operands. So, in
    the last compiler pass, we’ll rewrite the assembly AST to fix any invalid instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY
    to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by extending the assembly AST we defined in the last chapter. We
    need some new constructs to represent the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instructions from
    [Listing 2-2](chapter2.xhtml#list2-2). We also need to decide how to represent
    the function prologue and epilogue in the assembly AST.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways to handle the prologue and epilogue. We could
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instructions to the
    assembly AST. We could add high-level instructions that correspond to the entire
    prologue and epilogue, instead of maintaining a one-to-one correspondence between
    assembly AST constructs and assembly instructions. Or we could leave out the function
    prologue and epilogue entirely and add them during code emission. I’ll use a combination
    of the first and last options. This chapter’s assembly AST, shown in [Listing
    2-11](chapter2.xhtml#list2-11), includes a construct corresponding to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction (the third instruction
    in the function prologue). This construct specifies how many bytes we need to
    subtract from the stack pointer. The assembly AST doesn’t include the other instructions
    from the prologue and epilogue; these instructions are always the same, so we
    can add them during code emission. That said, the other approaches to representing
    the function prologue and epilogue will also work, so choose whichever you like
    best.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also introduce *pseudoregisters* to represent temporary variables. We
    use pseudoregisters as operands in assembly instructions, like real registers;
    the only difference is that we have an unlimited supply of them. Because they
    aren’t real registers, they can’t appear in the final assembly program; they’ll
    need to be replaced by real registers or memory addresses in a later compiler
    pass. For now, we’ll assign every pseudoregister to a distinct address in memory.
    In [Part III](part3.xhtml), we’ll write a *register allocator*, which assigns
    as many pseudoregisters as possible to hardware registers instead of memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](chapter2.xhtml#list2-11) shows the updated assembly AST, with
    the new parts bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: The assembly
    AST with unary operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> node has
    a couple of new constructors to represent our new assembly instructions. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor represents a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    instruction. It takes one operand that’s used as both source and destination.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> constructor
    represents the third instruction in the function prologue, <samp class="SANS_TheSansMonoCd_W5Regular_11">subq
    $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    %rsp</samp>. Its one child, an integer, indicates the number of bytes we subtract
    from RSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have several new instruction operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    constructor represents a hardware register. It can specify either hardware register
    we’ve seen so far: EAX or R10D. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand lets us use an arbitrary identifier as a pseudoregister. We use this to
    refer to the temporary variables we produced while generating TACKY. Ultimately,
    we need to replace every pseudoregister with a location on the stack; we represent
    those with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand,
    which indicates the stack address at the given offset from RBP. For example, we’d
    represent the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    with the assembly AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Every hardware register has several aliases, depending on how many bytes of
    the register you need. EAX refers to the lower 32 bits of the 64-bit RAX register,
    and R10D refers to the lower 32 bits of the 64-bit R10 register. The names AL
    and R10B refer to the lower 8 bits of RAX and R10, respectively. Register names
    in the assembly AST are size agnostic, so AX in [Listing 2-11](chapter2.xhtml#list2-11)
    can refer to the register alias RAX, EAX, or AL, depending on context. (The name
    AX normally refers to the lower 16 bytes of RAX, but we won’t use 16-byte register
    aliases in this book.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write a straightforward conversion from TACKY to assembly, shown
    in [Tables 2-2](chapter2.xhtml#tab2-2) through [2-5](chapter2.xhtml#tab2-5). As
    [Table 2-2](chapter2.xhtml#tab2-2) illustrates, we convert TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp> nodes to the
    corresponding assembly constructs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We’ll convert each TACKY instruction to a sequence of assembly instructions,
    as shown in [Table 2-3](chapter2.xhtml#tab2-3). Since our new assembly instructions
    use the same operand for the source and destination, we copy the source value
    into the destination before issuing a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator,
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[Table 2-4](chapter2.xhtml#tab2-4) shows the corresponding assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>
    for each TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>,
    and [Table 2-5](chapter2.xhtml#tab2-5) shows the conversion from TACKY operands
    to assembly operands.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp> |'
  prefs: []
  type: TYPE_TB
- en: Note that we’re not using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction yet; we’ll add it in the very last pass before code emission, once
    we know how many bytes we need to allocate. We’re also not using any <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands; we’ll replace every <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand
    in the next compiler pass. And we’re not using the R10D register; we’ll introduce
    it when we rewrite invalid instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write a compiler pass to replace each <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand,
    leaving the rest of the assembly AST unchanged. In [Listing 2-2](chapter2.xhtml#list2-2),
    we used two stack locations: <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. This pass follows
    the same pattern: we replace the first temporary variable we see with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>,
    the next with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-8)</samp>,
    and so on. We subtract four for each new variable, since every temporary variable
    is a 4-byte integer. You’ll need to maintain a map from identifiers to offsets
    as you go so you can replace each pseudoregister with the same address on the
    stack every time it appears. For example, if you process the instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: you should replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("a")</samp>
    with the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand
    in both instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This compiler pass should also return the stack offset of the final temporary
    variable, because that tells us how many bytes to allocate on the stack in the
    next pass.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we need to traverse the assembly AST one more time and make two small fixes.
    First, we’ll insert the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction at the very beginning of the instruction list in the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    The integer argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    should be the stack offset of the last temporary variable we allocated in the
    previous compiler pass. That way, we’ll allocate enough space on the stack to
    accommodate every address we use. For example, if we replace three temporary variables,
    replacing the last one with <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>,
    we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(12)</samp>
    at the front of the instruction list.
  prefs: []
  type: TYPE_NORMAL
- en: The second fix is rewriting invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions. When we replaced pseudoregisters with stack addresses, we may have
    ended up with <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions
    where both the source and destination are <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands. This happens when the unary expression in your program has at least
    one level of nesting. But <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>,
    like many other instructions, can’t have memory addresses as both the source and
    the destination. If you try to assemble a program with an instruction like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl -4(%rbp), -8(%rbp)</samp>, the assembler
    will reject it. When you encounter an invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction, rewrite it to first copy from the source address into R10D and then
    copy from R10D to the destination. For example, the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I’ve chosen R10D as a scratch register because it doesn’t serve any other special
    purpose. Some registers are required by particular instructions; for example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, which
    performs division, requires the dividend to be stored in EAX. Other registers
    are used to pass arguments during function calls. Using any of these registers
    for scratch at this stage could cause conflicts. For example, you might copy a
    function argument into the correct register, but then accidentally overwrite it
    while using that register to transfer a different value between memory addresses.
    Because R10D doesn’t have any special purpose, we don’t have to worry about these
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we’ll extend the code emission stage to handle our new constructs and
    print out the function prologue and epilogue. [Tables 2-6](chapter2.xhtml#tab2-6)
    through [2-9](chapter2.xhtml#tab2-9) show how to print out each assembly construct.
    New constructs and changes to the way we emit existing constructs are bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-6](chapter2.xhtml#tab2-6) shows how to include the prologue when you
    emit an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-7](chapter2.xhtml#tab2-7) shows how to include the function epilogue
    just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction
    and how to emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(unary_operator, operand)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AllocateStack(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: As this table illustrates, you should emit <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction. Emit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp> instruction, according
    to its <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp> argument.
    [Table 2-8](chapter2.xhtml#tab2-8) shows which <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>
    corresponds to each of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-8:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">negl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">notl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, [Table 2-9](chapter2.xhtml#tab2-9) shows how to print out the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-9:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(AX)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%eax</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R10)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stack(int)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">(%rbp)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  prefs: []
  type: TYPE_TB
- en: Because RBP and RSP contain memory addresses, which are 8 bytes, we always operate
    on them using quadword instructions, which have a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    suffix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction
    in [Table 2-7](chapter2.xhtml#tab2-7) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction in the prologue and epilogue are identical apart from the size of
    their operands.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you extended your compiler to implement negation and bitwise
    complement. You also implemented a new intermediate representation, wrote two
    new compiler passes that transform assembly code, and learned how stack frames
    are structured. Next, you’ll implement binary operations like addition and subtraction.
    The changes to the backend in the next chapter are pretty simple; the tricky part
    is getting the parser to respect operator precedence and associativity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter touched on *two’s complement*, which is how all modern computers
    represent signed integers. Two’s complement will show up throughout this book,
    so it’s worth taking the time to understand it. Here are a couple of overviews
    of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: “Two’s Complement” by Thomas Finley covers how and why two’s complement representations
    work (*[https://<wbr>www<wbr>.cs<wbr>.cornell<wbr>.edu<wbr>/~tomf<wbr>/notes<wbr>/cps104<wbr>/twoscomp<wbr>.html](https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2](chapter2.xhtml) of *The Elements of Computing Systems* by Noam
    Nisan and Shimon Schocken (MIT Press, 2005) covers similar material from a more
    hardware-focused perspective. This is the companion book for the Nand to Tetris
    project. This chapter is freely available at *[https://<wbr>www<wbr>.nand2tetris<wbr>.org<wbr>/course](https://www.nand2tetris.org/course)*;
    click the book icon under “Project 2: Boolean Arithmetic.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
