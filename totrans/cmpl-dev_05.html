<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label=" Page 53. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REACT</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Developers can use the React library to create a full-stack application’s user interface. React is built upon the Node.js ecosystem, and as one of the most commonly used web frameworks, it currently forms the basis of more than percent of the most visited websites.</p>&#13;
<p class="TX">To work effectively with React, you must understand the syntax used to define the appearance of user interface elements and then combine these into React components that can dynamically update. This chapter covers everything you need to know to begin developing full-stack applications using this library.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-26"/><samp class="SANS_Futura_Std_Bold_B_11">The Role of React</samp></h3>&#13;
<p class="TNI">Modern frontend architectures split an application’s user interface into small, self-contained, and reusable items. Some of these, such as headers, navigations, and logos, might appear only once per page, while others are <span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label=" Page 54. "/>repeated elements that form the page’s contents, such as headlines, buttons, and teasers. <a href="chapter4.xhtml#fig4-1">Figure 4-1</a> shows some of these items. React’s syntax embraces this pattern; the library focuses on building these independent components and, in doing so, helps us develop our applications more efficiently.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig4-1" src="../images/Figure4-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-1: User interface components</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">React uses a <i>declarative</i> programming paradigm, through which you create a user interface by describing the desired results instead of explicitly listing all the steps necessary to create it, as is done in <i>imperative</i> programming. A classic example of the declarative paradigm is HTML. Using HTML, you describe a web page’s elements, and the browser then renders the page. By contrast, you could use JavaScript to write an imperative program that creates each HTML element. In doing so, you would explicitly list the steps to build the website.</p>&#13;
<p class="TX">In addition, these user interface components are <i>reactive</i>. This means two things: one, that they handle their own isolated states, and two, that each component updates the page’s HTML as soon as its state changes. Changes to the React code instantly affect a browser’s <i>document object model (DOM)</i>, which represents a website as a tree in which each HTML element is a node. The DOM also provides an API for each node and for the website in general, enabling scripts to modify a website or a specific node.</p>&#13;
<p class="TX">DOM operations, such as re-rendering a component, are expensive. To update the DOM, React uses a <i>virtual DOM</i>, which is an in-memory clone of the actual browser DOM that it later syncs with the real thing. This virtual DOM allows for incremental updates that reduce the number of costly operations on the browser. The virtual DOM is a crucial principle of React. React calculates the difference between the virtual DOM and the real DOM with every call to one of its render functions and then decides what to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label=" Page 55. "/>update. Usually, React performs batch updates to lower the performance impact further. This process of reconciliation lets React deliver fast and responsive user interfaces.</p>&#13;
<p class="TX">Although React is primarily a user interface library, developers can also use it to build single-page applications that don’t require middleware or a backend. These apps are nothing more than a view layer rendered in the browser. To some extent, they can be dynamic: for example, we can change the page’s language, open an image gallery, or toggle an element’s visibility. However, all of this occurs in the browser, with additional React modules, rather than on the server.</p>&#13;
<p class="TX">We can also perform more advanced functionality, like updating the browser’s location to simulate the existence of distinct pages, purely in the browser, with React’s Router module. This module lets us define routes, similar to the ones we defined in our Express.js server, on the frontend. As soon as a user clicks an internal link, the routing component updates the view and changes the browser’s location. This makes it seem as though they’ve loaded another HTML page. In reality, we’ve just changed the current page’s contents. In doing so, we avoided another set of server requests, so the simulated page loads much more quickly. Also, because our JavaScript code controls the transition between pages, we can add effects and animations to these transitions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-27"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up React</samp></h3>&#13;
<p class="TNI">Unlike, say, the basic Express.js server you created in <span class="Xref"><a href="chapter1.xhtml#Exe1">Exercise 1</a> on page 13</span>, which uses standard JavaScript and can run directly with Node.js, React relies on an advanced setup with a complete build toolchain. For example, it uses a custom JavaScript Syntax Extension (JSX) to describe HTML elements and TypeScript for static typing, both of which require a transpiler to convert the code to JavaScript. Therefore, the manual process for setting up React is quite complex.</p>&#13;
<p class="TX">Thus, we generally rely on other tools. In the case of a single-page application, we use a code generator, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp>, to scaffold it. During this scaffolding process, <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> generates the boilerplate code for a new React application, as well as the build chain and folder structure for the project. It also provides a consistent project layout that helps us easily understand other React projects.</p>&#13;
<p class="TX">To run the examples in this chapter, one option is to scaffold a simple TypeScript React app with <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> by following the steps at <a href="https://create-react-app.dev/docs/getting-started/"><i>https://<wbr/>create<wbr/>-react<wbr/>-app<wbr/>.dev<wbr/>/docs<wbr/>/getting<wbr/>-started<wbr/>/</i></a>. If you don’t want to create a dedicated project, you can instead run code using React with a TypeScript template in an online playground, such as <a href="https://codesandbox.io"><i>https://<wbr/>codesandbox<wbr/>.io</i></a> or <a href="https://stackblitz.com"><i>https://<wbr/>stackblitz<wbr/>.com</i></a>. The playgrounds and <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> follow the same file structure. In both cases, you should save your code to the default <i>App.tsx</i> file.</p>&#13;
<p class="TX">For more complex apps, we’d use a complete web application framework such as Next.js, which provides the necessary setup out of the box. Covered in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, Next.js is the most popular framework for full-stack <span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label=" Page 56. "/>web applications that use React. Internally, Next.js employs a variation of <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> for scaffolding. We’ll rely on it in future chapters to work with React.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H1" id="sec3"><span id="h1-28"/><samp class="SANS_Futura_Std_Bold_B_11">The JavaScript Syntax Extension</samp></h3>&#13;
<p class="TNI">React uses JSX to define the appearance of user interface components. JSX is an extension of JavaScript that a transpiler must convert before the browser renders it to the DOM. While it has HTML-like syntax, it is more than a simple templating language. Instead, it allows us to use any JavaScript feature to describe React elements. For example, we can use JSX syntax inside conditional statements, assign it to variables, and return it from functions. The compiler will then embed any variable or valid JavaScript expression wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>) into the HTML.</p>&#13;
<p class="TX">This logic allows us to, for instance, use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> to loop over an array, check each item for a certain condition, pass the item to another function, and create a set of JSX elements based on the function’s return value, directly inside a page’s template. While this may sound abstract, we’ll use this pattern extensively when we create React components in the Food Finder application you’ll build in <span class="Xref"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-54"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example JSX Expression</samp></h4>&#13;
<p class="TNI">JSX expressions, like those in <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>, are the most essential part of the React user interfaces. This JavaScript code defines a JSX function expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">getElement</samp>, that takes one string as a parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">JSX.Element</samp>.</p>&#13;
<span id="Lis4-1"/>&#13;
<pre class="pre-74"><code>import React from "react";&#13;
&#13;
export default function App() {&#13;
    const getElement = (weather: string): JSX.Element =&gt; {&#13;
        const element = &lt;h1&gt;The weather is {weather}&lt;/h1&gt;;&#13;
        return element;&#13;
    };&#13;
    return getElement("sunny");&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-1: A minimal example of a JSX expression</span></p>&#13;
<p class="TX">The entry point for each React application is the <samp class="SANS_TheSansMonoCd_W5Regular_11">App</samp> function. Like the <i>index.js</i> file of our Express.js server, this function is executed when the application starts. Here, we usually set up the global elements, such as stylesheets and the overall page layout.</p>&#13;
<p class="TX">React renders the function’s return value to the browser. In <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>, we immediately return an element. As the smallest building blocks of React user interfaces, <i>elements</i> describe what you’ll see on the screen, just as HTML elements do. Examples of elements include custom buttons, headlines, and images.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label=" Page 57. "/>After importing the React package, we create the JSX element and store it in an <samp class="SANS_TheSansMonoCd_W5Regular_11">element</samp> constant. At first glance, you might wonder why it isn’t wrapped in quotes, as it contains what appears to be a regular HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> element and looks like a string. The answer is that it isn’t a string but a JSX element from which the library creates HTML elements programmatically. As a result, the code will display a message about the weather to the page.</p>&#13;
<p class="TX">As soon as we call the JSX expression, the React library transpiles it into a regular JavaScript function call and creates an HTML string from the JSX element displayed in the browser. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, you learned that all valid JavaScript is also valid TypeScript. Hence, we can use JSX with TypeScript as well. JSX files use a .<i>jsx</i> (JavaScript) or <i>.tsx</i> (TypeScript) extension. Paste this code into the <i>App.tsx</i> file of the project you created, and the browser should render an <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML element with the text <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather is sunny</samp> either in the preview pane of the online playground or in your browser.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ReactDOM Package</samp></h4>&#13;
<p class="TNI">One easy way to work with elements is to use the ReactDOM package, which contains APIs for working with the DOM. Note that the elements you create aren’t browser DOM elements. Instead, they’re plain JavaScript objects that will be rendered, using React’s <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function, to the virtual DOM’s root element and then attached to the browser DOM.</p>&#13;
<p class="TX">React elements are <i>immutable</i>: once created, they cannot be changed. If you do alter any part of the element, React will create a new element and re-render the virtual DOM, then compare the virtual DOM with the browser DOM to decide whether the browser DOM needs an update. We’ll use JSX abstractions for these tasks; nonetheless, it’s good to understand how React works under the hood. If you want to dig deeper, consult the official documentation at <a href="https://react.dev/learn"><i>https://<wbr/>react<wbr/>.dev<wbr/>/learn</i></a>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1" id="sec6"><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">Organizing Code into Components</samp></h3>&#13;
<p class="TNI">We mentioned that components are independent, reusable pieces of code built from React elements. Elements are objects that can contain other elements. Once rendered to the virtual or browser DOM, they create DOM nodes or whole DOM subtrees. Meanwhile, React <i>components</i> are classes or functions that output elements and render them to the virtual DOM. We will build a user interface using React components. For more information about this distinction, read the deep dive at the official React blog: <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html"><i>https://<wbr/>reactjs<wbr/>.org<wbr/>/blog<wbr/>/2015<wbr/>/12<wbr/>/18<wbr/>/react<wbr/>-components<wbr/>-elements<wbr/>-and<wbr/>-instances<wbr/>.html</i></a>.</p>&#13;
<p class="TX">While other frameworks might separate a user interface’s code by technology, splitting it into HTML, CSS, and JavaScript files, React instead separates code into these logical building blocks. As a result, a single physical file contains all the information necessary for a component, regardless of underlying technologies.</p>&#13;
<p class="TX">More concretely, a React component is a JavaScript function that, by convention, starts with an uppercase letter. Furthermore, it takes a single object argument, called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>, and returns a React element. This <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label=" Page 58. "/>argument should never be modified inside the component and is considered immutable inside the React code.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#Lis4-2">Listing 4-2</a> shows a basic React component that displays the same weather string as in the previous listings. In addition, we’ve added a custom interface and a click handler. The custom interface enables us to set an attribute on the JSX component and read its value in the TypeScript code. It’s a common way to pass values to a function component without a global state management library.</p>&#13;
<p class="TX">Here, we simply pass the component the same string used in the previous listings and render it to the DOM, but for a real-world application, the weather string might be part of an API response. To get the weather data, a parent component might query the API and then send this data through the component’s attribute to the component’s code, or each component in the application would need to query the API to access that data, impacting the overall performance of the application.</p>&#13;
<p class="TX">The click handler enables us to react to user interactions. In JSX, click handlers have the same names as in HTML, and we add them the way we might add inline DOM events. For example, to react to a user clicking an element, we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> attribute with a callback function.</p>&#13;
<span id="Lis4-2"/>&#13;
<pre class="pre-75"><code>import React from "react";&#13;
&#13;
export default function App() {&#13;
&#13;
    interface WeatherProps {&#13;
        weather: string;&#13;
    }&#13;
&#13;
    const clickHandler = (text: string): void =&gt; {&#13;
        alert(text);&#13;
    };&#13;
&#13;
    const WeatherComponent = (props: WeatherProps): JSX.Element =&gt; {&#13;
        const text = `The weather is ${props.weather}`;&#13;
        return (&lt;h1 onClick={() =&gt; clickHandler(text)}&gt;{text}&lt;/h1&gt;);&#13;
    };&#13;
&#13;
    return (&lt;WeatherComponent weather="sunny" /&gt;);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-2: A basic React component</span></p>&#13;
<p class="TX">First we create a custom interface for our new component’s properties. We’ll use this interface for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp> parameter later. Because we set a <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute on the component and define a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> property on the interface, we can access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp> in our TypeScript code.</p>&#13;
<p class="TX">Then we create the event handler as an arrow function with one string parameter. We use an <samp class="SANS_TheSansMonoCd_W5Regular_11">onClick</samp> event property similar to inline DOM events and assign a callback function, <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp>. As soon as the user clicks the page’s headline, we display a simple alert box.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label=" Page 59. "/>Next, we define the component. As you can see, it’s a JSX expression that implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp> interface and returns a JSX element. Inside the component, we use an untagged template literal to create text and add the dynamic weather information with the value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute, via <samp class="SANS_TheSansMonoCd_W5Regular_11">props.weather</samp>. Then we return the JSX element and, finally, return and render the weather component, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">sunny</samp> as the attribute’s value.</p>&#13;
<p class="TX">Paste this code into the <i>App.tsx</i> file. The browser should render an <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp> HTML element with the text <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather is sunny</samp> in the preview pane. When you click the text, an alert box will display it once more. Change the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> attribute to display different weather strings.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Class Components</samp></h4>&#13;
<p class="TNI">There are two kinds of components in React: class components and function components. The component in <a href="chapter4.xhtml#Lis4-2">Listing 4-2</a> is a <i>function component</i>, which borrows heavily from functional programming. In particular, these components follow the pattern of pure functions: they create some output (JSX elements) based on some input (the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument and the JSX component’s attributes). While we emphasize this type of component in this chapter, you should know the basics of class components too.</p>&#13;
<p class="TX">A <i>class component</i> follows the typical patterns of object-oriented programming: it is defined as a class and inherits methods from its parent <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp> class. Like all components, it has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> and returns a JSX element. Class components also have <samp class="SANS_TheSansMonoCd_W5Regular_11">constructor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> functions, and you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> keyword to refer to the current component’s instance.</p>&#13;
<p class="TX">Of particular value, the internal property <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp> provides you an interface to store and access information about the component’s internal state, such as opened elements, the current image in an image gallery, or, as in the next example, a simple click counter. Of similar importance are the class’s <i>lifecycle</i> methods, which run during specific lifecycle steps: for example, whenever the component mounts, renders, updates, or unmounts. In <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp> lifecycle method. React runs this method immediately after the component becomes part of the DOM. It is similar to the browser’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DOMReady</samp> event, with which you might already be familiar.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#Lis4-3">Listing 4-3</a> shows the previously created weather component defined as a class component. To practice accessing the component’s state, we’ve added a counter that will count the clicks on the headline element. Because it records the internal component’s state, the counter resets on page reload. Paste this code into the <i>App.tsx</i> file and click the headline to count up.</p>&#13;
<span id="Lis4-3"/>&#13;
<pre class="pre-76"><code>import React from "react";&#13;
&#13;
export default function App() {&#13;
    interface WeatherProps {&#13;
        weather: string;&#13;
    }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label=" Page 60. "/>    type WeatherState = {&#13;
        count: number;&#13;
    };&#13;
&#13;
    class WeatherComponent extends React.Component&lt;WeatherProps, WeatherState&gt; {&#13;
        constructor(props: WeatherProps) {&#13;
            super(props);&#13;
            this.state = {&#13;
                count: 0&#13;
            };&#13;
        }&#13;
&#13;
        componentDidMount() {&#13;
            this.setState({count: 1});&#13;
        }&#13;
&#13;
        clickHandler(): void {&#13;
            this.setState({count: this.state.count + 1});&#13;
        }&#13;
&#13;
        render() {&#13;
            return (&#13;
                &lt;h1 onClick={() =&gt; this.clickHandler()}&gt;&#13;
                    The weather is {this.props.weather}, and the counter shows{" "}&#13;
                    {this.state.count}&#13;
                &lt;/h1&gt;&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    return (&lt;WeatherComponent weather="sunny" /&gt;);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-3: A basic React class component</span></p>&#13;
<p class="TX">First we define the custom interface to use for the component’s properties. We also define a type to use in the counter we’ll create later.</p>&#13;
<p class="TX">Next, we define the class component, extending the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">React.Component</samp>. Following object-oriented programming patterns, the constructor calls a <samp class="SANS_TheSansMonoCd_W5Regular_11">super</samp> function and initializes the component’s state. We set our counter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. As soon as the browser mounts the component, it calls the lifecycle method <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp>, changing the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. We modify the click handler to count the number of clicks instead of displaying an alert box, and we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp> function. Here we return the JSX elements that display the weather props and the current state as HTML.</p>&#13;
<p class="TX">Finally, we return the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherComponent</samp>, and React initializes it. The preview pane displays the string <samp class="SANS_TheSansMonoCd_W5Regular_11">The weather is sunny, and the counter shows 1</samp>. We see from the number <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> that the lifecycle method was indeed called. Each click on the headline increases the number instantly, because of the reactive nature of the component’s state. As soon as the state changes, React re-renders the component and updates the view with the current value of the state.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-57"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label=" Page 61. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Providing Reusable Behavior with Hooks</samp></h4>&#13;
<p class="TNI">Function components can use <i>hooks</i> to provide reusable behaviors, such as for accessing a component’s state. Hooks are functions that offer simple and reusable interfaces to state and lifecycle features. <a href="chapter4.xhtml#Lis4-4">Listing 4-4</a> shows the same weather component we created in <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>, this time written as a function component. It uses hooks instead of lifecycle methods to update the component’s counter.</p>&#13;
<span id="Lis4-4"/>&#13;
<pre class="pre-77"><code>import React, {useState,useEffect} from "react";&#13;
&#13;
export default function App() {&#13;
&#13;
    interface WeatherProps {&#13;
        weather: string;&#13;
    }&#13;
&#13;
    const WeatherComponent = (props: WeatherProps): JSX.Element =&gt; {&#13;
&#13;
        const [count, setCount] = useState(0);&#13;
        useEffect(() =&gt; {setCount(1)},[]);&#13;
&#13;
        return (&#13;
            &lt;h1 onClick={() =&gt; setCount(count + 1)}&gt;&#13;
                The weather is {props.weather},&#13;
                and the counter shows {count}&#13;
            &lt;/h1&gt;&#13;
        );&#13;
    };&#13;
&#13;
    return (&lt;WeatherComponent weather="sunny" /&gt;);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-4: A React function component that uses hooks</span></p>&#13;
<p class="TX">We’ve added two new features to this component: an indicator of the component’s state and a way to run code as soon as we mount the component. Therefore, we use the two hooks, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>, by importing them as named imports from the React module, then adding them to the function component. The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook replaces the <samp class="SANS_TheSansMonoCd_W5Regular_11">this.state</samp> property from the class component, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hooks the <samp class="SANS_TheSansMonoCd_W5Regular_11">componentDidMount</samp> lifecycle method. In addition, we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">clickHandler</samp> from the previous example with a simple inline function to update the counter.</p>&#13;
<p class="TX">Each call to a hook produces an entirely isolated state, so we can use the same hook multiple times in the same component and trust that the state will update. This pattern keeps the hook callbacks small and focused. Also note that the runtime does not hoist hooks. They are called in the order in which we define them in the code.</p>&#13;
<p class="TX">When you compare <a href="chapter4.xhtml#Lis4-3">Listings 4-3</a> and <a href="chapter4.xhtml#Lis4-4">4-4</a>, you should instantly see that the function component is more readable and easier to understand. For this reason, we’ll exclusively use function components in the rest of this book.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-30"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label=" Page 62. "/><samp class="SANS_Futura_Std_Bold_B_11">Working with Built-in Hooks</samp></h3>&#13;
<p class="TNI">React provides a collection of built-in hooks. You’ve just seen the most common ones, <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>. Another useful hook is <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>, for sharing data among components. Other built-in hooks cover more specific use cases to enhance the performance of your application or handle specific edge cases. You can look them up as needed in the React documentation.</p>&#13;
<p class="TX">You can also create custom hooks whenever you need to break a monolithic component into smaller, reusable packages. Custom hooks follow a specific naming convention. They start with <samp class="SANS_TheSansMonoCd_W5Regular_11">use</samp>, followed by an action beginning with an uppercase letter. You should define only one functionality per hook to make it easily testable.</p>&#13;
<p class="TX">This section will guide you through the three most common hooks and the benefits of using them.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Managing the Internal State with useState</samp></h4>&#13;
<p class="TNI">A pure function uses only the data that is available inside the function. Still, it can react to local state changes, such as the counter in the weather component we created. The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook is probably the most-used one for handling regional states. This internal component’s state is available only inside the component and is never exposed to the outside.</p>&#13;
<p class="TX">Because the component state is reactive, React re-renders the component as soon as we update its state, changing the value across the entire component. However, React guarantees that the state is stable and won’t change on re-renders.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook returns the reactive state variable and a setter function used to set the state, as shown in <a href="chapter4.xhtml#Lis4-5">Listing 4-5</a>.</p>&#13;
<span id="Lis4-5"/>&#13;
<pre class="pre-78"><code>const [<b>count</b>, <b>setCount</b>] = useState(<b>0</b>);</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-5: The</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">useState</samp> <span class="Futura_Std_Book_Oblique_BI_11">hook viewed in isolation</span></p>&#13;
<p class="TX">We initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook with the default value. The hook itself returns the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> and the setter function we need to modify the state variable’s value, because we cannot modify this variable directly. For example, to set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> we created in <a href="chapter4.xhtml#Lis4-5">Listing 4-5</a> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, we need to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount</samp> function with the new value as a parameter, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">setCount(1)</samp>. By convention, the setter function begins with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> followed by the state variable’s name.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Side Effects with useEffect</samp></h4>&#13;
<p class="TNI">Pure functions should rely only on the data passed to them. When a function uses or modifies data outside its local scope, we call this a <i>side effect</i>. The simplest example of a side effect is modifying a global variable. This is considered a bad practice both in JavaScript and in functional programming.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label=" Page 63. "/>Sometimes, however, our components need to interact with the “outside world” or have an external dependency. In these cases, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook, which handles side effects, providing an escape hatch from the functional aspect of the component. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> can manage dependencies, call APIs, and fetch data required for the component.</p>&#13;
<p class="TX">This hook runs after React mounts the component into the layout and the rendering process of the component is completed. It has an optional return object, which runs before the component is unmounted. You can use it for cleanup, for example, to remove event listeners.</p>&#13;
<p class="TX">One way to use this hook is to observe and react to dependencies. To do this, we can pass it an optional array of dependencies. Any change to one of these dependencies would trigger a rerun of the hook. If the dependency array is empty, the hook won’t depend on any external value and never reruns. This is the case in our weather component, where <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> is executed only after mounting and unmounting the component. It has no external dependencies, so the dependency array remains empty and the hook runs only once.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing Global Data with useContext and Context Providers</samp></h4>&#13;
<p class="TNI">Ideally, React’s function components would be pure functions that operate only on data passed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> parameter. Alas, a component might sometimes need to consume a shared, global state. In this case, React implements the <i>context provider</i> to share global data with a tree of child components.</p>&#13;
<p class="TX">The context provider wraps the child components, and we can access the shared data with the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> hook. As the context value changes, React automatically re-renders all child components. Thus, it is quite an expensive hook. You shouldn’t use it for datasets that change frequently.</p>&#13;
<p class="TX">In the full-stack application you’ll build in <span class="Xref"><a href="part2.xhtml">Part II</a></span>, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> to share session data with child components. Shared contexts are also often employed to keep track of color schemes and themes. <a href="chapter4.xhtml#Lis4-6">Listing 4-6</a> shows how to consume a theme through a context provider.</p>&#13;
<span id="Lis4-6"/>&#13;
<pre class="pre-79"><code>import React, {useState, createContext, useContext} from "react";&#13;
&#13;
export default function App() {&#13;
    const ThemeContext = createContext("");&#13;
&#13;
    const ContextComponent = (): JSX.Element =&gt; {&#13;
&#13;
        const [theme, setTheme] = useState("dark");&#13;
&#13;
        return (&#13;
            &lt;div&gt;&#13;
                &lt;ThemeContext.Provider value={theme}&gt;&#13;
                    &lt;button onClick={() =&gt; setTheme(theme == "dark" ? "light" : "dark")}&gt;&#13;
                        Toggle theme&#13;
                    &lt;/button&gt;&#13;
                    &lt;Headline /&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label=" Page 64. "/>                &lt;/ThemeContext.Provider&gt;&#13;
            &lt;/div&gt;&#13;
        );&#13;
    };&#13;
&#13;
    const Headline = (): JSX.Element =&gt; {&#13;
        const theme = useContext(ThemeContext);&#13;
        return (&lt;h1 className={theme}&gt;Current theme: {theme}&lt;/h1&gt;);&#13;
    };&#13;
&#13;
    return (&lt;ContextComponent /&gt;);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-6: A complete context provider example</span></p>&#13;
<p class="TX">First we import the necessary functions from the React package and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">createContext</samp> function to initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp>. Next, we create the parent component and name it <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>. This is the wrapper that holds the context provider and all child components.</p>&#13;
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContextComponent</samp>, we create the local <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and set the stateful variable as the content the context provides. This enables us to change the variable in the context from inside a child component. Because we used a reactive stateful variable for the value, all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> variable will instantly update across all child components.</p>&#13;
<p class="TX">We add a button element and toggle the value of the stateful variable between light and dark whenever a user clicks the button. Finally, we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp> component, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> hook to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> value provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThemeContext</samp> to all child components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Headline</samp> component uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp> value for the HTML class and displays the current <samp class="SANS_TheSansMonoCd_W5Regular_11">theme</samp>.</p>&#13;
<p class="HeadProject"><span id="Exe4"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4: Create a Reactive User Interface for the Express.js Server</samp></p>&#13;
<p class="TNI">Let’s use your new knowledge and our weather component to create a reactive user interface for the Express.js server. The new React component will allow us to update text on the web page by clicking it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding React to the Server</samp></h4>&#13;
<p class="TNI">First we’ll include React in our project. For experimentation purposes, you can add the React library and the stand-alone version of the Babel.js transpiler directly inside your HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp> tag. Be aware, however, that this technique is not suitable for production. Transpiling code in the browser is a slow process, and the JavaScript libraries we add here aren’t optimized. Using React with a skeleton Express.js server requires a decent number of tedious setup steps and a decent amount of maintenance. We’ll use Next.js in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> to simplify developing React applications.</p>&#13;
<p class="TX">Create a folder, named <i>public</i>, next to the <i>package.json</i> file and then create an empty file called <i>weather.html</i> inside it. Add the code in <a href="chapter4.xhtml#Lis4-7">Listing 4-7</a>, which contains our React example with the weather component. Later, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label=" Page 65. "/>we’ll create a new endpoint, <i>/components/weather</i>, that directly returns the HTML file.</p>&#13;
<span id="Lis4-7"/>&#13;
<pre class="pre-80"><code>&lt;!DOCTYPE html&gt;&#13;
&lt;html&gt;&#13;
    &lt;head&gt;&#13;
        &lt;meta charset="UTF-8" /&gt;&#13;
        <b>&lt;title&gt;Weather Component&lt;/title&gt;</b>&#13;
        <b>&lt;script src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt;</b>&#13;
        <b>&lt;script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt;</b>&#13;
        <b>&lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;</b>&#13;
    &lt;/head&gt;&#13;
    &lt;body&gt;&#13;
        &lt;div id="root"&gt;&lt;/div&gt;&#13;
      &#13;
        &lt;script type="text/babel"&gt;&#13;
            function App() {&#13;
&#13;
                <b>const WeatherComponent = (props) =&gt; {</b>&#13;
                  &#13;
                    const [count, setCount] = <b>React.useState</b>(0);&#13;
                    <b>React.useEffect</b>(() =&gt; {&#13;
                        setCount(1);&#13;
                    }, []);&#13;
&#13;
                    return (&#13;
                        &lt;h1 onClick={() =&gt; setCount(count + 1)}&gt;&#13;
                            The weather is {props.weather}, &#13;
                            and the counter shows {count}&#13;
                        &lt;/h1&gt;&#13;
                    );&#13;
                };&#13;
                return (&lt;WeatherComponent weather="sunny" /&gt;);&#13;
          }&#13;
&#13;
            const container = document.getElementById("root");&#13;
            const root = ReactDOM.createRoot(container);&#13;
            root.render(&lt;App /&gt;);&#13;
        &lt;/script&gt;&#13;
    &lt;/body&gt;&#13;
&lt;/html&gt;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-7: The static file</span> <span class="Futura_Std_Book_11">/public/weather.html</span> <span class="Futura_Std_Book_Oblique_BI_11">renders React in the browser.</span></p>&#13;
<p class="TX">First we add three React scripts to the <i>weather.html</i> file: these are <i>react.development</i>, <i>react.dom.development</i>, and the stand-alone <i>babel.js</i>, which are all similar to the import of React we previously used in the <i>App.tsx</i> file. Then we add ReactDOM to let React interact with the DOM. The three files add a global property, <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">window.object</samp>. We use this property as a global variable to reference React functions. The stand-alone Babel script adds the Babel.js transpiler, which we need to convert the code from JSX to JavaScript.</p>&#13;
<p class="TX">Next, we add the weather component’s code we developed previously. Instead of referencing the <i>App.tsx</i> file, we place app functions directly inside <span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label=" Page 66. "/>the HTML file and mark the script block as <samp class="SANS_TheSansMonoCd_W5Regular_11">text/babel</samp>. This type tells Babel to transpile the code inside the script tag into standard JavaScript.</p>&#13;
<p class="TX">We make a few simple modifications to the weather component’s code. First we remove the type annotations, as they are allowed only in TypeScript files. Then, because we are using the browser environment, we prefix the hooks with their global property name, <samp class="SANS_TheSansMonoCd_W5Regular_11">React</samp>. Finally, we use ReactDOM to create the React root container and render the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">App /&gt;</samp> component there.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Endpoint for the Static HTML File</samp></h4>&#13;
<p class="TNI">The second file we’ll edit is the <i>index.ts</i> file in the root directory. We add the highlighted code in <a href="chapter4.xhtml#Lis4-8">Listing 4-8</a> to add a new entry point, <i>/components/weather</i>.</p>&#13;
<span id="Lis4-8"/>&#13;
<pre class="pre-81"><code>import {routeHello, routeAPINames, routeWeather} from "./routes.js";&#13;
import express, {Request, Response} from "express";&#13;
&#13;
<b>import path from "path";</b>&#13;
&#13;
const server = express();&#13;
const port = 3000;&#13;
&#13;
<var>--snip--</var>&#13;
<b>server.get("/components/weather", function (req: Request, res: Response): void {</b>&#13;
    <b>const filePath = path.join(process.cwd(), "public", "weather.html");</b>&#13;
    <b>res.setHeader("Content-Type", "text/html");</b>&#13;
    <b>res.sendFile(filePath);</b>&#13;
<b>});</b>&#13;
&#13;
server.listen(port, function (): void {&#13;
    console.log("Listening on " + port);&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 4-8: The refactored</span> <span class="Futura_Std_Book_11">index.ts</span></p>&#13;
<p class="TX">To load the static HTML file, import <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> from Node.js’s default path module. The path module provides all kinds of utilities for working with files and directories. In particular, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">join</samp> function to create a valid path that meets the operation system’s format.</p>&#13;
<p class="TX">We use the default global <samp class="SANS_TheSansMonoCd_W5Regular_11">process.cwd</samp> function to get the current working directory, and from there, we create the path to our HTML file. Then we add the weather component’s entry point and set the response’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Content -Type</samp> header to <i>text/html</i>. Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sendFile</samp> function to send to the browser the <i>weather.html</i> file we created previously.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Server</samp></h4>&#13;
<p class="TNI">We need to transpile the server code to JavaScript, so we run TSC with <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:</p>&#13;
&#13;
<pre class="pre-82"><code>$ <b>npx tsc</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label=" Page 67. "/>The generated files, <i>index.js</i> and <i>routes.js</i>, are similar to the previously created ones. TSC doesn’t touch the static HTML. The stand-alone Babel.js script converts the JSX code on runtime in the browser. Start the server from your command line:</p>&#13;
&#13;
<pre class="pre-83"><code>$ <b>node index.js</b>&#13;
Listening on 3000&#13;
</code></pre>&#13;
<p class="TX">Now visit <i>http://localhost:3000/components/weather-component</i> in your browser. You see the same text you saw when you rendered the weather component in the React playground, as in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>. As soon as you click the text, the click handler increases the reactive state variable, and the counter shows the new value.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig4-2" src="../images/Figure4-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 4-2: Browser response from the Node.js web server</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You successfully created your first React application. To gain more experience with React, try adding a custom button component for the click counter, with a style attribute that uses a JSX expression to change the background color for odd and even counter values.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H1" id="sec16"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You should now have a solid foundation with which to create your React apps. JSX elements are the building blocks of React components that return JSX to be rendered as HTML in the DOM, via React’s virtual DOM. You also explored the difference between class components and modern function components, took a deep dive into React hooks, and used these hooks to build a function component.</p>&#13;
<p class="TX">If you want to explore React’s full potential, take a look at the React tutorials from W3Schools at <a href="https://www.w3schools.com/REACT/DEFAULT.ASP"><i>https://<wbr/>www<wbr/>.w3schools<wbr/>.com<wbr/>/REACT<wbr/>/DEFAULT<wbr/>.ASP</i></a> and those created by the React team at <a href="https://react.dev/learn/tutorial-tic-tac-toe"><i>https://<wbr/>react<wbr/>.dev<wbr/>/learn<wbr/>/tutorial<wbr/>-tic<wbr/>-tac<wbr/>-toe</i></a>.</p>&#13;
<p class="TX">In the next chapter, we’ll work with Next.js. Built on top of React, Next.js is a production-ready full-stack web development framework for single-page applications.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>