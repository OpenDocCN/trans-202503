<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>12. Interactive Authentication</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch12" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch12">
<span class="CN"><span aria-label=" Page 397. " epub:type="pagebreak" id="pg_397" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">INTERACTIVE AUTHENTICATION</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">When you authenticate to your Windows system, you’ll usually access a login interface, enter your credentials, and be greeted with the desktop. But quite a lot happens behind the scenes to make this authentication process work. <i>Interactive authentication</i> is the mechanism that converts a set of credentials into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that you can use to interact with authorization systems, such as access checks.</p>
<p class="TX">Windows uses many types of interactive authentication for a variety of purposes. For example, it uses one type when a user creates an interactive desktop and another when the user has provided credentials to a network-facing service. We’ll begin this chapter by exploring how Windows creates your interactive desktop when you authenticate to a Windows system. We’ll then cover how this interactive authentication is implemented through <span aria-label=" Page 398. " epub:type="pagebreak" id="pg_398" role="doc-pagebreak"></span>the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API. Finally, we’ll look at the various types of interactive authentication, the differences between them, and when they might be used.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-91"></span><samp class="SANS_Futura_Std_Bold_B_11">Creating a User’s Desktop</samp></h3>
<p class="TNI1">The most common way of interacting with a Windows system is via the user interface on a desktop. <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> summarizes the process of creating a user’s desktop.</p>
<figure class="IMG"><img alt="" class="img1" height="903" id="fig12-1" src="../images/Figure12-1.jpg" width="1376"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An overview of interactive desktop creation</samp></p></figcaption>
</figure>
<p class="TX">When the Windows system starts, the session manager creates a console session, as described in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>. In this console session it starts an instance of the Winlogon process, which gathers credentials and starts the new user’s processes once they’re authenticated. The Winlogon process then creates the LogonUI process to display a UI. The LogonUI process reads the credentials from the user and passes them back to Winlogon <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">Next, the Winlogon process sends the credentials to the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API to verify that they’re correct <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If the user has successfully authenticated, a token representing the user’s identity is returned to Winlogon <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The console session can then be reconfigured for the user, a process that includes creating a window station and desktop and spawning the user initialization process using the user’s token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API directly supports the most common type of credential, a username and password pair. However, Windows allows many other local authentication factors as well, such as biometric data (for example, a scanning of the user’s face) or a simple PIN. To handle these, <span aria-label=" Page 399. " epub:type="pagebreak" id="pg_399" role="doc-pagebreak"></span>Winlogon loads a credential provider when needed. Each provider is responsible for mapping its credential type to one that <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> supports to get the token.</p>
<aside aria-label="box-4" class="box">
<p class="BoxTitle" id="box-4"><samp class="SANS_Dogma_OT_Bold_B_11">THE SECURE ATTENTION SEQUENCE</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">One of the original security features in Windows NT was the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">secure attention sequence (SAS)</samp><samp class="SANS_Futura_Std_Book_11">, which a user could invoke by pressing</samp> <samp class="SANS_Futura_Std_Book_SC_11">CTRL-ALT-DELETE</samp><samp class="SANS_Futura_Std_Book_11">. The handling of this key chord was built into the operating system, so applications couldn’t block it. When the key chord was pressed, the system would notify Winlogon, which would switch the desktop to display an authentication prompt or an options menu. By making it impossible to block the SAS, Windows ensured it was safe for a user to enter their credentials into the computer.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The latest versions of Windows don’t use the SAS as the LogonUI by default, although it’s still a configurable option. If you’re already authenticated and you press</samp> <samp class="SANS_Futura_Std_Book_SC_11">CTRL-ALT-DELETE</samp><samp class="SANS_Futura_Std_Book_11">, the system will switch to the Winlogon desktop to display the menu shown here.</samp></p>
<figure class="IMG"><img alt="" class="img7" height="892" src="../images/pg399.jpg" width="1101"/>
</figure>
</aside>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-92"></span><samp class="SANS_Futura_Std_Bold_B_11">The LsaLogonUser API</samp></h3>
<p class="TNI1">We know the basics of how to create a desktop on Windows. Now let’s dig into how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API implements the interactive authentication service for Winlogon and other applications on the local system. This API <span aria-label=" Page 400. " epub:type="pagebreak" id="pg_400" role="doc-pagebreak"></span>might seem quite complex, but it really requires only three pieces of information from an application to authenticate a user:</p>
<ul class="ul">
<li class="ListBullet">The logon type requested</li>
<li class="ListBullet">The security package identifier</li>
<li class="ListBullet">The user’s credentials</li>
</ul>
<p class="TX">The API uses the <i>logon type</i> to accommodate different authentication scenarios. <a href="chapter12.xhtml#tab12-1">Table 12-1</a> lists the logon types most commonly used by applications.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab12-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Logon Types</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Interact with a local desktop.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Run as a background process, even if no desktop is available.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Run as a system service.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Interact with the system from a network client.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Perform network authentication, but store the user’s credentials for later use.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Clone the caller’s token and change network user credentials.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Interact with a desktop via the Remote Desktop Protocol.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Verify the user’s credentials for unlocking the desktop.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> is a special type that Winlogon uses to verify a user’s credentials on the lock screen, and it isn’t typically used by applications directly. We’ll come back to some of the other logon types later in the chapter.</p>
<p class="TX">Windows abstracts the details of authentication to a <i>security package</i>, which provides a standardized interface to an authentication protocol. The authentication protocol is a formal process that takes a set of credentials and verifies that they’re valid. It also provides a mechanism to return information about the verified user, such as their group memberships. We also sometimes refer to a security package as a <i>security support provider (SSP).</i></p>
<p class="TX">We can enumerate the available security packages using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPackage</samp> PowerShell command, as shown in <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a>.</p>
<span id="Lis12-1"></span><pre><code>PS&gt; <b>Get-LsaPackage | Select-Object Name, Comment</b>
Name                                         Comment
----                                         -------
Negotiate                                    Microsoft Package Negotiator <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
NegoExtender                                 NegoExtender Security Package
Kerberos                                     Microsoft Kerberos V1.0
NTLM                                         NTLM Security Package <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
TSSSP                                        TS Service Security Package
pku2u                                        PKU2U Security Package
CloudAP                                      Cloud AP Security Package
WDigest                                      Digest Authentication for Windows
<span aria-label=" Page 401. " epub:type="pagebreak" id="pg_401" role="doc-pagebreak"></span>Schannel                                     Schannel Security Package
Microsoft Unified Security Protocol Provider Schannel Security Package
Default TLS SSP                              Schannel Security Package
CREDSSP                                      Microsoft CredSSP Security Provider
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-1: Enumerating the supported security packages</span></p>
<p class="TX">Applications typically access a security package via a more generic API that is agnostic to the authentication protocol used. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> works across multiple different packages by accepting a unique identifier for the package to use. A security package can also implement a network authentication protocol, which we’ll cover in more depth in the following chapters.</p>
<p class="TX">The most widely used security packages for local authentication are <i>Negotiate</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <i>NT LAN Manager (NTLM)</i> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The NTLM authentication protocol was introduced in Windows NT 3.1, and it’s also sometimes referred to as the <i>Microsoft Authentication Package V1.0</i> in documentation. The Negotiate package can automatically select between different authentication protocols, depending on the circumstances. For example, it might select NTLM if authenticating locally to the SAM database or Kerberos when authenticating to a domain.</p>
<p class="TX">The supported credential types depend on the security package being used for the authentication. For example, NTLM supports only username and password credentials, whereas Kerberos supports X.509 certificates and smart card authentication in addition to a username and password.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-131"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp></h4>
<p class="TNI1">Let’s explore how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API authenticates a user in more detail. <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> gives an overview of this process for a user in the local SAM database.</p>
<figure class="IMG"><img alt="" class="img1" height="421" id="fig12-2" src="../images/Figure12-2.jpg" width="1360"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The local authentication process using LsaLogonUser</samp></p></figcaption>
</figure>
<p class="TX">Due to the complexities of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API, it’s more common for an application to use a simpler API provided by the system. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp> API accepts a username, a domain name, a password, and the logon type and formats the parameters appropriately for the underlying security package.</p>
<p class="TX"><span aria-label=" Page 402. " epub:type="pagebreak" id="pg_402" role="doc-pagebreak"></span>It then forwards these parameters, including the user’s credentials, to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API in the LSA process <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The API in turn forwards the authentication request to the chosen security package, which in this case is the NTLM package implemented in the <i>MSV1_0.DLL</i> library.</p>
<p class="TX">The security package checks whether the user exists in the local SAM database. If it does, the user’s password is converted to an NT hash (discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>), and then it is compared against the value stored in the database <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If the hashes match and the user account is enabled, the authentication proceeds and the user’s details, such as group membership, are read from the SAM database for the authentication process to use.</p>
<p class="TX">Now that the security package knows the user’s group membership and account details, it can check whether the local security policy allows the user to authenticate <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The main policy checks whether the logon type requested is granted an account right. <a href="chapter12.xhtml#tab12-2">Table 12-2</a> lists the logon types and the account rights the user must be granted in order to authenticate. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> logon type doesn’t need a specific account right; we’ll cover why in the <span class="Xref">“Network Credentials” box on page 407</span>.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab12-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Logon Types and Associated Allow and Deny Account Rights</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Allow account right</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Deny account right</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">If the user doesn’t have the necessary account right granted or is explicitly denied the right, the authentication will fail. There can be other limitations on authentication, as well; for example, you could configure a user so that they’re allowed to authenticate only between certain times, or even only on certain days of the week. If the user doesn’t meet one of the policy requirements, the security package will reject the authentication.</p>
<p class="TX">If the user’s credentials are valid and the policy permits them to authenticate, the LSA can create a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call based on the information about the user and their privileges extracted from the SAM and LSA policy databases <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The application receives a handle to a token, which the user can subsequently use for impersonation or to create a new process within the limits of the assignment, as described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-132"></span><span aria-label=" Page 403. " epub:type="pagebreak" id="pg_403" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Authentication</samp></h4>
<p class="TNI1">Authenticating a user to a domain controller is not significantly different from local authentication, but it’s still worth highlighting the small distinctions. <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> shows the domain authentication process.</p>
<figure class="IMG"><img alt="" class="img1" height="593" id="fig12-3" src="../images/Figure12-3.jpg" width="1660"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The domain authentication process using LsaLogonUser</samp></p></figcaption>
</figure>
<p class="TX">The domain authentication process starts in the same manner as local authentication. The application provides the credentials and other parameters to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API running in the LSA process <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. At this point, it’s likely that API will use the Negotiate security package to select the most appropriate security package to authenticate with.</p>
<p class="TX">In this example, it once again uses the NTLM security package, which is easy to understand. However, in a modern Windows network, you’re more likely to find Kerberos used. Interactive authentication with Kerberos is much more complex, so I’ll wait until <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> to provide details about it.</p>
<p class="TX">Windows also supports online authentication protocols, such as those for Microsoft and Azure Active Directory accounts. Authentication for these accounts uses the <i>CloudAP</i> security package, which Negotiate will select automatically if it’s the best security package to use. Details of this selection process are beyond the scope of this book, although we’ll cover some aspects of Negotiate in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>.</p>
<p class="TX">The NTLM security package once again generates the NT hash, but instead of consulting the local SAM database, it determines the domain controller for the user’s domain. It then forwards the authentication request containing the user’s name and NT hash to the domain controller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp> API using the <i>Netlogon</i> network protocol.</p>
<p class="TX">While Windows has deprecated the Netlogon protocol for primary domain authentication, it has not removed the protocol in the latest versions. Not removing legacy features can result in important security issues as technology becomes obsolete and security expectations change. For example, CVE-2020-1472, dubbed <i>Zerologon</i>, was a serious vulnerability in the Netlogon protocol that allowed unauthenticated users to compromise the entire domain network due to a flaw in the weak cryptography used by the protocol.</p>
<p class="TX"><span aria-label=" Page 404. " epub:type="pagebreak" id="pg_404" role="doc-pagebreak"></span>The domain controller verifies the user’s credentials in the domain’s user database <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. For modern versions of Windows, this is Active Directory, not a SAM database. The user must also be enabled for the authentication to succeed. If the hashes match, the user’s information is extracted from Active Directory and returned to the client system.</p>
<p class="TX">Once the user’s credentials have been validated, the client system can verify its local policy <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> to determine whether the user is permitted to authenticate based on the logon type and other restrictions, such as time limits. If every check succeeds, the LSA generates the token and returns it to the application <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<aside aria-label="box-5" class="box">
<p class="BoxTitle" id="box-5"><samp class="SANS_Dogma_OT_Bold_B_11">CACHED DOMAIN CREDENTIALS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">What happens to a Windows system that is connected to a domain when the enterprise network is disconnected or otherwise unavailable? If authentication relies on being able to contact a domain controller over the network, how could you authenticate to the system to change the network configuration? You could ensure that every user had a separate local user account to deal with this issue, but that isn’t a very satisfactory option.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To solve this problem, the LSA stores a cache of recently used domain credentials. Each time a successful domain authentication occurs, the LSA caches the credentials. The next time the user authenticates to the system, if the domain authentication fails because the domain controller is no longer accessible, the LSA can check whether the credentials used match any of the values stored in the cache. If it finds a match, it will grant access to the system. However, the LSA will also keep trying to contact the domain controller to verify the user’s credentials. This is especially important for Kerberos, because without contact with the domain controller, the user won’t be able to access any network resources.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">I mentioned in the previous chapter that these cached credentials are stored in the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SECURITY</samp> <samp class="SANS_Futura_Std_Book_11">registry hive. We won’t delve into the details of this storage, as it could easily change between versions of Windows.</samp></p>
</aside>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-133"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logon and Console Sessions</samp></h4>
<p class="TNI1">Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API has verified the user’s credentials, it can create an initial token for the user. Before it can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>, however, the LSA must set up an associated logon session. We discussed the logon session in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, in the context of the token’s authentication ID, but it’s worth going into more depth about what it contains.</p>
<p class="TX">Let’s begin by querying the LSA for all current logon sessions using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtLogonSession</samp> PowerShell command, as shown in <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a>. You should run this command as an administrator to display all the logon sessions on the system.</p>
<span id="Lis12-2"></span><pre><code><span aria-label=" Page 405. " epub:type="pagebreak" id="pg_405" role="doc-pagebreak"></span>PS&gt; <b>Get-NtLogonSession | Sort-Object LogonId</b>
LogonId           UserName                     LogonType          SessionId
-------           --------                     ---------          ---------
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> 00000000-000003E4 NT AUTHORITY\NETWORK SERVICE Service            0
00000000-000003E5 NT AUTHORITY\LOCAL SERVICE   Service            0
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> 00000000-000003E7 NT AUTHORITY\SYSTEM          UndefinedLogonType 0
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> 00000000-00006A39 Font Driver Host\UMFD-0      Interactive        0
00000000-00006A96 Font Driver Host\UMFD-1      Interactive        1
00000000-0000C5E9 Window Manager\DWM-1         Interactive        1
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> 00000000-00042A51 GRAPHITE\user                Interactive        1
00000000-00042AB7 GRAPHITE\user                Interactive        1
00000000-000E7A72 Font Driver Host\UMFD-3      Interactive        2
00000000-000E7CF2 Window Manager\DWM-3         Interactive        2
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-2: Displaying all current logon sessions</span></p>
<p class="TX">We can see that the first two sessions are for service accounts <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> value. Oddly, the third session is also a service account, for the <i>SYSTEM</i> user, but notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> is undefined <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This is because the kernel creates the <i>SYSTEM</i> logon session before the LSA process is started, which means no authentication has taken place.</p>
<p class="TX">The rest of the logon sessions are for interactive accounts, as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Only one user is authenticated <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>; the other accounts belong to system processes such as the user-mode font driver (UMFD) and the desktop window manager (DWM). We won’t cover these system processes in any detail. Observe that the current user has two logon sessions. This is because of UAC, introduced in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>; we’ll come back to why UAC generates two sessions in <span class="Xref">“Token Creation” on page 407</span>.</p>
<p class="TX">Notice also that a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionId</samp> is shown for each logon session, in addition to the authentication identifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp>) that identifies the account. This is the console session ID. It’s important not to confuse the logon session and console session types. As this output shows, it’s possible for a single console session to host multiple separate logon sessions, and for a single logon session to be used across multiple console sessions.</p>
<p class="TX">The LSA stores the console session ID originally associated with the logon session when it was created. In <a href="chapter12.xhtml#Lis12-3">Listing 12-3</a>, we query the LSA for all current console sessions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtConsoleSession</samp>. This behavior allows multiple users to share the same console and desktop.</p>
<span id="Lis12-3"></span><pre><code>PS&gt; <b>Get-NtConsoleSession</b>
SessionId UserName      SessionName            State
--------- --------      -----------            -----
0                       Services               Disconnected
1         GRAPHITE\user 31C5CE94259D4006A9E4#0 Active
2                      <b> </b>Console                Connected
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-3: Displaying all current console sessions</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionName</samp> column indicates where the console session is connected. Session 0 is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Services</samp> console, meaning it’s used only for system <span aria-label=" Page 406. " epub:type="pagebreak" id="pg_406" role="doc-pagebreak"></span>services. The <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp> column indicates the state of the UI. For session 0 this is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnected</samp>, as there is no UI displayed.</p>
<p class="TX">Session 1 is created on demand when the user successfully completes the interactive authentication process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp> column identifies the authenticated user. The session state is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>, as this is the console session in which I ran the PowerShell command. The session name is a unique value indicating that this is a remote desktop connection.</p>
<p class="TX">Finally, session 2 lives on the physical console. It shows a state of <samp class="SANS_TheSansMonoCd_W5Regular_11">Connected</samp>, as it currently hosts a LogonUI in case a user tries to physically log in to the machine. However, at this point there’s no authenticated user in session 2, as you can see by the absence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp> in the listing.</p>
<p class="TX"><a href="chapter12.xhtml#fig12-4">Figure 12-4</a> summarizes the relationships between logon sessions and console sessions in this example. The console sessions are the gray boxes in the background, and the logon sessions are the white boxes in the foreground.</p>
<figure class="IMG"><img alt="" class="img1" height="1101" id="fig12-4" src="../images/Figure12-4.jpg" width="1372"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The console and logon sessions</samp></p></figcaption>
</figure>
<p class="TX">Notice that console session 0 contains the service logon sessions, such as those for the local system, the network service, and the local service. The local system logon session is also used for the LogonUI process running in console session 2. At the bottom right is console session 1, which contains two user logon sessions: one for the UAC administrator and one for the filtered non-administrator.</p>
<aside aria-label="box-6" class="box">
<p class="BoxTitle" id="box-6"><span aria-label=" Page 407. " epub:type="pagebreak" id="pg_407" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">NETWORK CREDENTIALS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">One other important value stored in the logon session is the set of network authentication credentials for the user. Storing these credentials can save the user from having to retype them for every network service. Not all types of logon sessions store network credentials, though; for example, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> <samp class="SANS_Futura_Std_Book_11">logon types store the credentials, but the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> <samp class="SANS_Futura_Std_Book_11">logon type does not. If you want a network logon session with stored network credentials, you can use the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> <samp class="SANS_Futura_Std_Book_11">logon type instead.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> <samp class="SANS_Futura_Std_Book_11">logon type doesn’t authenticate a new user. Instead, the LSA makes a copy of the caller’s token, creates a new logon session, and uses the supplied credentials only for network authentication. This allows a user to authenticate as a different user locally and remotely. Note that this logon type doesn’t verify the credentials in the call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp><samp class="SANS_Futura_Std_Book_11">; it verifies them only when they’re used. This means that if you specify the wrong credentials,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> <samp class="SANS_Futura_Std_Book_11">will return successfully but then fail at a later point, when the credentials are required.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">We’ll cover network authentication and how it interacts with the user’s network authentication credentials in more detail in the following chapters.</samp></p>
</aside>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-134"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Token Creation</samp></h4>
<p class="TNI1">With a new logon session, the LSA can create the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the user. To do this, it must gather information about the token’s various security properties, including the user’s groups, privileges, and logon session ID, then pass these to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>.</p>
<p class="TX">You might be wondering where the user’s groups come from. As domain authentication is the most complex case, let’s consider the groups assigned to a domain user token when Winlogon authenticates the user. (The group assignment will look similar in the local authentication process, except that the LSA will consider only local groups.) <a href="chapter12.xhtml#tab12-3">Table 12-3</a> shows the group assignments for the <i>alice</i> user.</p>
<p class="Anchor"><span aria-label=" Page 408. " epub:type="pagebreak" id="pg_408" role="doc-pagebreak"></span></p>
<table class="Basic-Table1">
<caption><p class="TT" id="tab12-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Groups Added to an Interactive Token on a Domain-Joined System</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Group name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Group source</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table1 TBF gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\alice</samp></p></td>
<td class="Basic-Table TBF gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Domain user account</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Domain Users</samp></p></td>
<td class="Basic-Table TB" rowspan="3"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Domain group membership</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority asserted identity</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Claims Valid</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TB gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Local Resource</samp></p></td>
<td class="Basic-Table TB gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Domain-local resource group membership</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Administrators</samp></p></td>
<td class="Basic-Table TB" rowspan="2"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Local group membership</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Users</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp></p></td>
<td class="Basic-Table TB gbg" rowspan="4"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Automatic LSA groups</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Authenticated Users</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Everyone</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TB gbg"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Mandatory Label\High Mandatory Level</samp></p></td>
</tr>
<tr>
<td class="Basic-Table1 TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\LogonSessionId_0_6077548</samp></p></td>
<td class="Basic-Table TB" rowspan="2"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Winlogon groups</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">As you can see, the groups added to the token come from six sources. The first entry comes from the domain user account. (In a local authentication scenario, the group would come from the local user account instead.)</p>
<p class="TX">Next are the domain group memberships. These come from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scopes, discussed in the previous chapter. The <i>alice</i> user is a member of the first group, <i>Domain Users</i>. The other two groups are generated automatically when the user authenticates. The <i>Authentication authority asserted identity</i> group relates to a feature called <i>Service for User (S4U)</i>, which we’ll explore when we talk about Kerberos authentication in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
<p class="TX">The following source includes the groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp> scope. These domain-local groups are marked in the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp> group attribute, although the attribute doesn’t affect their use in an access check. The list of domain-local resource groups a user belongs to is returned in the response from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp> API, known as a <i>privilege attribute certificate (PAC)</i>. We’ll also come back to the PAC in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
<p class="TX">Next, any local groups the user is a member of are added to the token. These local groups can be selected based on the domain SIDs provided during the authentication process.</p>
<p class="TX">These are followed by the automatic LSA groups. Membership in the <i>Everyone</i> and <i>Authenticated Users</i> groups is granted to all authenticated tokens automatically. <i>INTERACTIVE</i> group membership is granted when a user is authenticated using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type. <a href="chapter12.xhtml#tab12-4">Table 12-4</a> provides a list of the SIDs added for different logon types. The LSA adds the <i>Mandatory Label\High Mandatory Level</i> SID automatically if the user is considered an administrator (for example, if they’re in the <i>Administrators</i> group or have certain high-level privileges). This sets the integrity level of the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>. Normal users get the <i>Medium Mandatory Level</i> SID, while system service users (such as <i>SYSTEM</i>) get the <i>System Mandatory Level</i> SID.</p>
<p class="Anchor"><span aria-label=" Page 409. " epub:type="pagebreak" id="pg_409" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab12-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">The SIDs Added to the Token for Each Logon Type</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">SID</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\BATCH</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-3</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\SERVICE</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-6</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\NETWORK</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\NETWORK</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The same as that of the original token</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp></p>
<p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\REMOTE INTERACTIVE LOGON</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-14</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The same as the logon session that is being unlocked</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Providing a unique SID for each logon type allows a security descriptor to secure resources depending on the type of logon. For example, a security descriptor could explicitly deny access to the <i>NT AUTHORITY\NETWORK</i> SID, meaning a user authenticated from the network would be denied access to the resource, while other authenticated users would be granted access.</p>
<p class="TX">The sixth set of SIDs added to the token are for the groups added by Winlogon when it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API. The API allows a caller with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled to add arbitrary group SIDs to the created token, so Winlogon adds a logon session and a <i>LOCAL</i> SID. This logon session SID’s two RID values are the two 32-bit integers from a LUID generated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateLocallyUniqueId</samp> system call. You might assume that the LUID would match the one used for the logon session. However, as the SID is created before the call to the LSA that creates the logon session, this isn’t possible. This SID is used to secure ephemeral resources such as the user’s <i>BaseNamedObjects</i> directory.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If you don’t specify a logon session SID when creating the token, the LSA will add its own for you. However, it will follow the same pattern of using a different LUID from that of the token’s logon session.</i></p>
</blockquote>
<p class="TX">As discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, the token’s privileges are based on the account rights stored in the local LSA policy database. This is true even in domain authentication; however, the account rights can be modified using a domain group policy deployed to computers in the domain.</p>
<p class="TX">If the user is considered an administrator, UAC is enabled, and the user is authenticating with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> logon type, the LSA will first build the full token and create a new logon session, then create a second copy of the full token with a new logon session but call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> to remove administrator privileges (see <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> for a more in-depth description of this). The LSA will then link the two tokens together and return the filtered token back to the caller. This behavior is why we observed two logon sessions for the same user in <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a>.</p>
<p class="TX">You can disable the token-splitting behavior by adjusting the system’s UAC settings. It’s also disabled by default for the <i>Administrator</i> user, which <span aria-label=" Page 410. " epub:type="pagebreak" id="pg_410" role="doc-pagebreak"></span>is always created when Windows is installed but only enabled by default on Windows Server systems. The LSA checks the last RID of the user’s SID: if it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>, which matches the <i>Administrator</i> user, the token won’t be split.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-93"></span><samp class="SANS_Futura_Std_Bold_B_11">Using the LsaLogonUser API from PowerShell</samp></h3>
<p class="TNI1">Now that you know how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API works, let’s see how to access the API from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> PowerShell module. Unless you run PowerShell with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>, some features of the API will be blocked, such as adding new group SIDs to the token, but you’ll be able to create a new token if you have the user’s username and password.</p>
<p class="TX">We access the API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logon</samp> parameter. <a href="chapter12.xhtml#Lis12-4">Listing 12-4</a> shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> to authenticate a new user.</p>
<span id="Lis12-4"></span><pre><code>PS&gt; <b>$password = Read-Host -AsSecureString -Prompt "Password"</b>
Password: <b>********</b>
PS&gt; <b>$token = Get-NtToken -Logon -User </b><b><var>user</var></b> <b>-Domain $env:COMPUTERNAME</b>
<b>-Password $password -LogonType Network</b>
PS&gt; <b>Get-NtLogonSession -Token $token</b>
LogonId           UserName         LogonType SessionId
-------           --------         --------- ---------
00000000-9BBFFF01 GRAPHITE\user    Network   3
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-4: Authenticating a user</span></p>
<p class="TX">It’s best not to enter passwords on the command line. Instead, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp> property to read the password as a secure string.</p>
<p class="TX">We can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>, specifying the username, the domain, and the password. (Replace the username in this example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp>, with that of a valid local user.) We set the domain to the name of the local computer, indicating that we want to authenticate using a local account. You can set any logon type, but in this case we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>, which works for all users. Whether the LSA will allow other logon types depends on the assigned account rights.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>By default, the LsaLogonUser API won’t authenticate a user with an empty password outside of the physical console. If you try running the command with a user account that has an empty password, the call will fail.</i></p>
</blockquote>
<p class="TX">The logon type also determines what type of token <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> will return based on the created token’s likely purpose, such as creating a new process or impersonation. <a href="chapter12.xhtml#tab12-5">Table 12-5</a> shows the mappings of logon type to token type. (We can freely convert between primary and impersonation tokens through duplication, so the tokens don’t have to be used in the expected way.)</p>
<p class="Anchor"><span aria-label=" Page 411. " epub:type="pagebreak" id="pg_411" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab12-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Logon Types Mapped to Token Types</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Token type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Impersonation</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Impersonation</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Primary</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">In <a href="chapter12.xhtml#Lis12-4">Listing 12-4</a>, the command returned an impersonation token. You might be wondering: Are we allowed to impersonate the token without having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> enabled, especially if the token belongs to a different user? The LSA sets the new token’s origin ID to the caller’s authentication ID, so based on the rules for impersonation covered in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, we can, even if the token belongs to a different user.</p>
<p class="TX">This isn’t considered a security issue, because if you know the user’s password, you can already fully authenticate as that user. In <a href="chapter12.xhtml#Lis12-5">Listing 12-5</a>, we check whether the origin and authentication IDs match using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenId</samp> command.</p>
<span id="Lis12-5"></span><pre><code>PS&gt; <b>Get-NtTokenId -Authentication</b>
LUID
----
00000000-000A0908

PS&gt; <b>Get-NtTokenId -Token $token -Origin</b>
LUID
----
00000000-000A0908
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-5: Comparing the authentication ID and origin ID</span></p>
<p class="TX">We query the primary token for its authentication ID, then query the new token for its origin ID. The output shows that the IDs are equal.</p>
<p class="TX">However, there is one restriction on impersonating the token. If the user being authenticated is an administrator, and the authentication process uses a logon type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>, the command won’t return a filtered token. Instead, it will return an administrator with a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level. This integrity level prevents the token from being impersonated from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>-level process. But because the returned token handle has write access, we can reduce the integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> before impersonating it. We do this in <a href="chapter12.xhtml#Lis12-6">Listing 12-6</a>.</p>
<span id="Lis12-6"></span><pre><code><span aria-label=" Page 412. " epub:type="pagebreak" id="pg_412" role="doc-pagebreak"></span>PS&gt; <b>Get-NtTokenIntegrityLevel -Token $token</b>
High

PS&gt; <b>Test-NtTokenImpersonation $token</b>
False

PS&gt; <b>Set-NtTokenIntegrityLevel -Token $token Medium</b>
PS&gt; <b>Test-NtTokenImpersonation $token</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-6: Testing the ability to impersonate the returned token</span></p>
<p class="TX">In this case, the token we’ve authenticated is a member of the <i>Administrators</i> group and so has a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level. We try to impersonate it, and as you can see, the command returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. We then set the token’s integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> and test impersonation again. The operation now returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-94"></span><samp class="SANS_Futura_Std_Bold_B_11">Creating a New Process with a Token</samp></h3>
<p class="TNI1">If you use a logon type that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp> token, you might assume that the token will enable you to create a new process. To test this, run <a href="chapter12.xhtml#Lis12-7">Listing 12-7</a> as a non-administrator user, making sure to change the username to that of a valid account.</p>
<span id="Lis12-7"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Logon -User </b><b><var>user</var></b> <b>-Domain $env:COMPUTERNAME</b>
<b>-Password $password -LogonType Interactive</b>
PS&gt; <b>New-Win32Process cmd.exe -Token $token</b>
Exception calling "CreateProcess": "A required privilege is not held
by the client"
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-7: Creating a new process with an authenticated token</span></p>
<p class="TX">You’ll find that creating the new process fails. This is because the new token doesn’t meet the requirements for primary token assignment described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. The process creation would work if the calling process had <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>, which Winlogon would have; however, a normal user process doesn’t have this privilege.</p>
<p class="TX">If you rerun the command as an administrator, though, it should succeed, even though administrators are not granted the privilege by default. Let’s explore why this works. The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> command first tries to create the process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp> API, which runs in-process. As the calling process doesn’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>, this operation fails.</p>
<p class="TX">Upon this failure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> API will fall back to calling an alternative API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>. This API isn’t implemented in-process; instead, it’s implemented in a system service, the secondary logon service, which does have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>. In this case, the service will check whether the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> before creating the new process.</p>
<p class="TX"><span aria-label=" Page 413. " epub:type="pagebreak" id="pg_413" role="doc-pagebreak"></span>The command therefore works for administrators who are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>. Even so, administrators shouldn’t rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp> exclusively, because the API doesn’t support many features of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>, such as inheriting arbitrary handles to the new process.</p>
<p class="TX">There is also a way for a non-administrator user to create a process as a different user. The secondary logon service exposes a second API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>, that accepts the username, domain, and password for the user to create instead of a token handle. The service authenticates the user using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>, then uses the authenticated token with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>. As the service has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>, the process creation will succeed.</p>
<p class="TX">You can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp> parameter when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> command to use <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>, as shown in <a href="chapter12.xhtml#Lis12-8">Listing 12-8</a>.</p>
<span id="Lis12-8"></span><pre><code>PS&gt; <b>$creds = Read-LsaCredential</b>
UserName: <b>alice</b>
Domain: <b>MINERAL</b>
Password: <b>********</b>

PS&gt; <b>$proc = New-Win32Process -CommandLine cmd.exe -Credential $creds</b>
PS&gt; <b>$proc.Process.User</b>
Name          Sid
----          ---
MINERAL\alice S-1-5-21-1195776225-522706947-2538775957-1110
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-8: Calling CreateProcessWithLogon using New-Win32Process</span></p>
<p class="TX">Here we read the credentials for the <i>alice</i> user and create the new process using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>, specifying the credentials with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp> parameter. This will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API.</p>
<p class="TX">The API will return a process and thread handle to use. For example, we can query for the process user, which shows it was created with a token for the authenticated <i>alice</i> user.</p>
<p class="TX">The API doesn’t allow you to specify the logon type of the user (it defaults to <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>), but you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetCredentialsOnly</samp> flag to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonFlags</samp> parameter to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> logon type instead.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-95"></span><samp class="SANS_Futura_Std_Bold_B_11">The Service Logon Type</samp></h3>
<p class="TNI1">Let’s wrap up this chapter by talking a little more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> logon type. The service control manager uses this logon type to create tokens for system service processes. It will allow any user account that has been granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp> account right to authenticate.</p>
<p class="TX">However, the LSA also supports four well-known local service accounts that are not stored in the SAM database. We can create them using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> by specifying the domain name as <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> logon type and one of the usernames in <a href="chapter12.xhtml#tab12-6">Table 12-6</a>, which also shows the user SIDs.</p>
<p class="Anchor"><span aria-label=" Page 414. " epub:type="pagebreak" id="pg_414" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab12-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Usernames and SIDs for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> <samp class="SANS_Futura_Std_Book_11">Logon Type</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Username</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">User SID</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">IUSR</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-17</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">SYSTEM</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL SERVICE</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LocalService</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NETWORK SERVICE</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">NetworkService</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The <i>SYSTEM</i> user is the only administrator of the four users; the other three are not members of the <i>Administrators</i> group, but they do have high-level privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>, which makes them effectively equivalent to an administrator.</p>
<p class="TX">The <i>IUSR</i> account represents the anonymous internet user. It’s available to reduce the privileges for the Internet Information Services (IIS) web server when it’s configured for anonymous authentication. When a request is made to the IIS web server with no user credentials, it will impersonate an <i>IUSR</i> account token before opening any resources, such as files. This prevents inadvertently exposing resources remotely as a privileged user.</p>
<p class="TX">For these built-in service accounts, you don’t need to specify a password, but you do need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled, which prevents it from being used outside of a system service. <a href="chapter12.xhtml#Lis12-9">Listing 12-9</a> shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> to create a <i>SYSTEM</i> user token. Run these commands as an administrator.</p>
<span id="Lis12-9"></span><pre><code>PS&gt; <b>Get-NtToken -Logon -LogonType Service -Domain 'NT AUTHORITY' -User SYSTEM </b>
<b>-WithTcb</b>
User                GroupCount PrivilegeCount AppContainer Restricted
----                ---------- -------------- ------------ ----------
NT AUTHORITY\SYSTEM 11         31             False        False

PS&gt; <b>Get-NtToken -Service System -WithTcb</b>
User                GroupCount PrivilegeCount AppContainer Restricted
----                ---------- -------------- ------------ ----------
NT AUTHORITY\SYSTEM 11         31             False        False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-9: Getting the</span> <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp> <span class="Futura_Std_Book_Oblique_I_11">user token</span></p>
<p class="TX">Even as an administrator you don’t receive <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> by default, so the command supports a <samp class="SANS_TheSansMonoCd_W5Regular_11">WithTcb</samp> parameter, which automatically impersonates a token with the privilege enabled. You can also simplify the creation of a service account by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> parameter and specifying the name of the service user to create.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-96"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some examples that demonstrate how to use the various commands introduced in this chapter in security research or systems analysis.</p>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-135"></span><span aria-label=" Page 415. " epub:type="pagebreak" id="pg_415" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing Privileges and Logon Account Rights</samp></h4>
<p class="TNI1">I mentioned in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp> command to add a SID to the list of account rights. Now that we know how to authenticate a user, let’s use this command to explore these account rights. In <a href="chapter12.xhtml#Lis12-10">Listing 12-10</a>, we assign privileges and logon account rights to a new user. Run these commands as an administrator.</p>
<span id="Lis12-10"></span><pre><code>PS&gt; <b>$password = Read-Host -AsSecureString -Prompt "Password"</b>
Password: <b>********</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$user = New-LocalUser -Name "Test" -Password $password</b>
PS&gt; <b>$sid = $user.Sid.Value</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$token = Get-NtToken -Logon -User $user.Name -SecurePassword $password</b>
<b>-LogonType Interactive</b>
PS&gt; <b>$token.ElevationType</b>
Default

PS&gt; <b>$token.Close()</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Add-NtAccountRight -Privilege SeDebugPrivilege -Sid $sid</b>
PS&gt; <b>$token = Get-NtToken -Logon -User $user.Name -SecurePassword $password</b>
<b>-LogonType Interactive</b>
PS&gt; <b>Enable-NtTokenPrivilege -Token $token SeDebugPrivilege -PassThru</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> WARNING: Couldn't set privilege SeDebugPrivilege

PS&gt; <b>$token.ElevationType</b>
Limited

PS&gt; <b>$token.Close()</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>$token = Get-NtToken -Logon -User $user.Name -SecurePassword $password</b>
<b>-LogonType Network</b>
PS&gt; <b>Enable-NtTokenPrivilege -Token $token SeDebugPrivilege -PassThru</b>
Name             Luid              Enabled
----             ----              -------
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> SeDebugPrivilege 00000000-00000014 True

PS&gt; <b>$token.ElevationType</b>
Default

PS&gt; <b>$token.Close()</b>
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> PS&gt; <b>Add-NtAccountRight -LogonType SeDenyInteractiveLogonRight -Sid $sid</b>
PS&gt; <b>Add-NtAccountRight -LogonType SeBatchLogonRight -Sid $sid</b>
<span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> PS&gt; <b>Get-NtToken -Logon -User $user.Name -SecurePassword $password</b>
<b>-LogonType Interactive</b>
Get-NtToken : (0x80070569) - Logon failure: the user has not been granted
the requested logon type at this computer.

PS&gt; <b>$token = Get-NtToken -Logon -User $user.Name -SecurePassword $password</b>
<b>-LogonType Batch</b>
PS&gt; <b>Get-NtTokenGroup $token | Where-Object {$_.Sid.Name -eq </b>
<b>"NT AUTHORITY\BATCH"}</b>
Sid        : S-1-5-3
Attributes : Mandatory, EnabledByDefault, Enabled
Enabled    : True
Mandatory  : True
<span aria-label=" Page 416. " epub:type="pagebreak" id="pg_416" role="doc-pagebreak"></span>DenyOnly   : False
<span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> Name       : NT AUTHORITY\BATCH

PS&gt; <b>$token.Close()</b>
<span aria-label="annotation10" class="CodeAnnotationHang1">❿</span> PS&gt; <b>Remove-NtAccountRight -Privilege SeDebugPrivilege -Sid $sid</b>
PS&gt; <b>Remove-NtAccountRight -LogonType SeDenyInteractiveLogonRight -Sid $sid</b>
PS&gt; <b>Remove-NtAccountRight -LogonType SeBatchLogonRight -Sid $sid</b>
PS&gt; <b>Remove-LocalUser $user</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-10: Assigning account rights to a new user</span></p>
<p class="TX">We start by creating a new user <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and testing that we can authenticate interactively <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can do so because the user is automatically part of the <i>BUILTIN\Users</i> group, which has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> by default. We also check that the token hasn’t been filtered for UAC by looking at the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> parameter, which shows up as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>, indicating that no filtering took place.</p>
<p class="TX">Next, we assign the user the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> privilege <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This is a high-level privilege, so we should expect the LSA to perform UAC filtering. We find this to be the case when we authenticate the user: we can’t enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>, since it’s been filtered <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> is now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>.</p>
<p class="TX">However, we can instead use network authentication <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, which isn’t subject to the default UAC filtering rules. We can now enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> once again, indicating that no filtering took place.</p>
<p class="TX">We then test the logon account rights. Remember that the user is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> because they are a member of the <i>BUILTIN\Users</i> group. We can’t remove that logon right without also removing them from that group, so instead we explicitly deny it to the specific user by adding their SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp> <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. Then we verify the intended behavior by trying to log on interactively <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, which now returns an error.</p>
<p class="TX">We also added the user’s SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>, which allows them to authenticate as a batch logon session. Normally, only members of the <i>Administrators</i> group receive this access right. We verify we’ve authenticated as a batch logon session by checking for the <i>NT AUTHORITY\BATCH</i> group that the LSA assigns <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>.</p>
<p class="TX">Finally, we clean up the account right assignments using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp> command <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>. This isn’t strictly necessary, as the LSA will clean up the assignments when the local user is removed, but I’ve included the operations here to demonstrate the use of the command.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-136"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Process in a Different Console Session</samp></h4>
<p class="TNI1">In certain scenarios, you might want to start a process inside a different console session. For example, if you’re running code in a system service using session 0, you might want to show a message on the currently authenticated user’s desktop.</p>
<p class="TX">To successfully create a process on another desktop, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> to change a token’s session ID and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp> to create the process. By default, an administrator user has neither of these <span aria-label=" Page 417. " epub:type="pagebreak" id="pg_417" role="doc-pagebreak"></span>privileges, so to test the example code provided here you’ll need to run PowerShell as the <i>SYSTEM</i> user.</p>
<p class="TX">First run the following command as an administrator to create a shell process on your desktop with the required privileges:</p>
<pre><code>PS&gt; <b>Start-Win32ChildProcess ((Get-NtProcess -Current).Win32ImagePath)</b>
<b>-RequiredPrivilege SeTcbPrivilege,SeAssignPrimaryTokenPrivilege</b>
</code></pre>
<p class="TX">Next, make sure that you have two users authenticated at the same time on different desktops on the same machine. If you use Fast User Switching, you’ll be able to easily confirm that a process was created on each desktop.</p>
<p class="TX"><a href="chapter12.xhtml#Lis12-11">Listing 12-11</a> starts by finding the console session for the new process. Run these commands as the <i>SYSTEM</i> user.</p>
<span id="Lis12-11"></span><pre><code>PS&gt; <b>$username = "GRAPHITE\user"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$console = Get-NtConsoleSession |</b>
<b>Where-Object FullyQualifiedUserName -eq $username</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$token = Get-NtToken -Duplicate -TokenType Primary</b>
PS&gt; <b>Enable-NtTokenPrivilege SeTcbPrivilege</b>
PS&gt; <b>$token.SessionId = $console.SessionId</b>
PS&gt; <b>$cmd = "cmd.exe"</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$proc = New-Win32Process $cmd -Token $token -Desktop "WinSta0\Default"</b>
<b>-CreationFlags NewConsole</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$proc.Process.SessionId -eq $console.SessionId</b>
True

PS&gt; <b>$proc.Dispose()</b>
PS&gt; <b>$token.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-11: Creating a new process in a different console session</span></p>
<p class="TX">We start by selecting the console session belonging to a user named <i>GRAPHITE\user</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a duplicate of our current token (which belongs to the <i>SYSTEM</i> user), enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>, and assign the console session ID to the token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">With this new token, we can create a new process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> command, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> parameter <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this case we’re creating a copy of Notepad, but you can change this process to any application you’d like by altering the command. Also note that we set the name of the window station and desktop, separated by a backslash, for the new process. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>, respectively, ensures that we create the application on the default desktop; otherwise, the user interface would be hidden.</p>
<p class="TX">We can verify that we’ve created the process in the target session by comparing the expected session ID with the actual session ID assigned to the process <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In this case, the comparison returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, which indicates success. If you now switch back to the other user, you should find a copy of Notepad running as the <i>SYSTEM</i> user on the desktop.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="h2-137"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticating Virtual Accounts</samp></h4>
<p class="TNI1">In <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, I mentioned that you can create your own SID-to-name mappings in the LSA using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp> command. Once you’ve set up a <span aria-label=" Page 418. " epub:type="pagebreak" id="pg_418" role="doc-pagebreak"></span>mapping, you can also create a new token for that SID through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>. <a href="chapter12.xhtml#Lis12-12">Listing 12-12</a> demonstrates; run these commands as an administrator.</p>
<span id="Lis12-12"></span><pre><code>PS&gt; <b>$domain_sid = Get-NtSid "S-1-5-99" </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
PS&gt; <b>$group_sid = Get-NtSid -BaseSid $domain_sid -RelativeIdentifier 0</b>
PS&gt; <b>$user_sid = Get-NtSid -BaseSid $domain_sid -RelativeIdentifier 1</b>
PS&gt; <b>$domain = "CUSTOMDOMAIN"</b>
PS&gt; <b>$group = "ALL USERS"</b>
PS&gt; <b>$user = "USER"</b>
PS&gt; <b>$token = Invoke-NtToken -System {</b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
    <b>Add-NtSidName -Domain $domain -Sid $domain_sid -Register </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
    <b>Add-NtSidName -Domain $domain -Name $group -Sid $group_sid -Register</b>
    <b>Add-NtSidName -Domain $domain -Name $user -Sid $user_sid -Register</b>
    <b>Add-NtAccountRight -Sid $user_sid -LogonType SeInteractiveLogonRight </b><span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
    <b>Get-NtToken -Logon -Domain $domain -User $user -LogonProvider Virtual</b>
<b>-LogonType Interactive </b><span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
    <b>Remove-NtAccountRight -Sid $user_sid -LogonType SeInteractiveLogonRight </b><span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
    <b>Remove-NtSidName -Sid $domain_sid -Unregister</b>
<b>}</b>
PS&gt; <b>Format-NtToken $token -User -Group</b>
USER INFORMATION
----------------
Name              Sid
----              ---
CUSTOMDOMAIN\User S-1-5-99-1 <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>

GROUP SID INFORMATION
-----------------
Name                                   Attributes
----                                   ----------
Mandatory Label\Medium Mandatory Level Integrity, IntegrityEnabled
Everyone                               Mandatory, EnabledByDefault, Enabled
BUILTIN\Users                          Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\INTERACTIVE               Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\Authenticated Users       Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\This Organization         Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\LogonSessionId_0_10173    Mandatory, EnabledByDefault, Enabled, LogonId
CUSTOMDOMAIN\ALL USERS                 Mandatory, EnabledByDefault, Enabled <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 12-12: Creating a virtual account token</span></p>
<p class="TX">We start by setting up some parameters to use in later commands <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We create three SIDs: the domain, a group, and a user. These values don’t need to reflect real SIDs or names. We then need to add the SIDs and create a token, all of which requires <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>, so we impersonate a <i>SYSTEM</i> token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">We register the three SIDs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Note that you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> parameter; otherwise, you’ll merely add the SID to the PowerShell module’s name cache and won’t register it with LSASS. Once we’ve added the SIDs, we need to grant the user <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> so that we can authenticate them and receive a token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. You could choose a different logon right, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>, if you wanted.</p>
<p class="TX"><span aria-label=" Page 419. " epub:type="pagebreak" id="pg_419" role="doc-pagebreak"></span>We can now authenticate the user via <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Make sure to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Virtual</samp> logon provider and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type. You don’t need to specify a password, but you can’t perform the operation without <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>.</p>
<p class="TX">Before we finish impersonating, we remove the logon right and then delete the domain SID <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Deleting the domain SID will also delete the group and user SIDs automatically.</p>
<p class="TX">Finally, we format the token. Now we can see that the user SID is the virtual SID we created <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, and that the token is automatically granted the group SID as well <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. Note that if we hadn’t added the SID-to-name mapping for the group SID, we’d still be granted it, but the SID would not be resolvable to a name. We can now impersonate the token or use it to create a new process running under that user identity.</p>
</section>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-97"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">As you’ve seen, interactive authentication, the process used to access the Windows desktop, is an extremely complicated topic. The authentication process requires a combination of a user interface, which collects the credentials, and the Winlogon process, which calls the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API. Once the API has validated the user’s credentials, it creates a new logon session, along with a token that Winlogon can use to create the user’s initial processes. The logon session can also cache the credentials so the user won’t need to re-enter them to access network services.</p>
<p class="TX">Next, we defined the differences between local authentication and domain authentication. We only touched on how authentication works with Netlogon here, but we’ll cover the more common Kerberos in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>. With an understanding of the basic authentication mechanisms in hand, we discussed how the LSA uses the user information to build a token, including how it assigns groups and privileges and how UAC results in token filtering for administrators.</p>
<p class="TX">We then discussed how to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API using the PowerShell module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command. We saw that we can use the token returned from the API to impersonate a user, because the LSA sets the token’s origin ID to the caller’s authentication ID. We also saw how to create a new process as a different user via the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> command.</p>
<p class="TX">Finally, we looked briefly at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> logon type and the four accounts that the LSA predefines. The service control manager uses these for its system service processes. In the next chapter, we’ll begin exploring how network authentication allows a user to authenticate to another Windows system. This will also allow us to understand the protocols used by domain authentication.</p>
</section>
</section>
</div></body>
</html>