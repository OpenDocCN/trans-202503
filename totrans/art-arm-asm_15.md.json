["```\nand w0, w0, 0b1111111111111000000000000\n```", "```\nmov w1, #0x2f3\nlsl w1, w1,   #12 // Make it 0x2f3000.\nand w0, w0,   #0b1111111111111000000000000\ncmp w0, w1  // 0b0001011110011000000000000\n```", "```\nand w0, w0, #0b1111111111111000000000000\nlsr w0, w0, #12\ncmp w0, #0x2F3\n```", "```\ncmtst V`d.t`, V`d.t`, V`d.t`\n```", "```\nand     w0, w0, #0xFFF   // Strip all but bits 0 to 11 from W0.\nbic     w1, w1, 0xFFF000 // Clear bits 12 to 23 in W1.\nlsl     w0, w0, 12       // Move bits 0 through 11 to 12 through 23 in W0.\norr     w1, w1, w0       // Merge the bits into W1.\n```", "```\nStartPosn = 12;\nBitMask   = 0xFFF << StartPosn  // Mask occupies bits 12 to 23.\n   .\n   .\n   .\n  lsl w0, w0, #StartPosn  // Move into position.\n  and w0, w0, #BitMask    // Strip all but bits 12 to 23.\n  and w1, w1, #~BitMask   // Clear bits 12 to 23 in W1.\n  orr w1, w1, w0          // Merge the bits into W1.\n```", "```\nbic  `Rd`, `Rl`, `Rr`  // `Rd` = `Rl` && ~`Rr`\nbics `Rd`, `Rl`, `Rr`  // Also affects condition codes\n```", "```\nbic Vd.`t`, Vl.`t`, Vr.`t`\n```", "```\nbic Vd.`t`, #imm8\nbic Vd.`t`, #imm8, lsl #`shift`\n```", "```\nadds w0, w0, w0\n```", "```\n// Simulate rol v1.4s, v1.4s, #4:\n\n        ushr    v2.4s, v1.4s, #28      // HO 4 bits to 0:3\n        shl     v1.4s, v1.4s, #4       // Bits 0:27 to 4:31\n        orr     v1.16b, v1.16b, v2.16b // Merge in LO bits.\n```", "```\n// Simulate ror v1.4s, v1.4s, #4:\n\n        shl    v2.4s, v1.4s, #28      // Bits 0:3 to 28:31\n        ushr   v1.4s, v1.4s, #4       // Bits 4:31 to 0:27\n        orr    v1.16b, v1.16b, v2.16b // Merge bits.\n```", "```\n// Simulate shl for 128 bits:\n\n        ushr    v2.2d, v1.2d, #60      // Save bits 60:63.\n        mov     v2.b[8], v2.b[0]       // Move into HO dword.\n        mov     v2.b[0],  wzr          // No mask at original\n        Shl     v1.4s, v1.4s, #4       // Shift bits left.\n        orr     v1.16b, v1.16b, v2.16b // Merge bits 60:63.\n```", "```\ncls `Rd`, `Rs`\nclz `Rd`, `Rs`\ncls V`d.t1`, V`s.t1`\nclz V`d.t1`, V`s.t1`\ncnt V`d.t2`, V`s.t2`\n```", "```\nrbit W`d`, W`s`\nrbit X`d`, X`s`\nrbit V`d.t`, V`s.t` // `t` = 8B or 16B\n```", "```\nrbit  v1.16b, v1.16b  // Do a 2D bit reversal; first bits,\nrev64 v1.16b, v1.16b  // then bytes.\n```", "```\nbif V`d.t`, V`s.t`, V`m.t`    // `t` = 8B (64 bits) or 16B (128 bits)\nbit V`d.t`, V`s.t`, V`m.t`    // V`d` = dest, V`s` = source, V`m` = mask\nbsl V`d.t`, V`s1.t`, V`s0.t`\n```", "```\nubfx `Rd`, `Rs`, #`lsb`, #`len`\n```", "```\nubfx x0, x1, #8, #16\n```", "```\nubfiz `Rd`, `Rs`, #`posn`, #`len`\n```", "```\nubfiz w1, w0, #12, #8\n```", "```\nubfm `Rd`, `Rs`, #`immr`, #`imms`\n```", "```\nubfm `Rd`, `Rs`, #(`Rsize` - `shift`) % `Rsize`, #`Rsize` - 1 - `shift`\n```", "```\nubfm `Rd`, `Rs`, #`shift`, #`Rsize` - 1 // `Rsize` is register size.\n```", "```\nubfm `Rd`, `Rs`, #(`Rsize`-`lsb`) % `Rsize`, #`width` - 1\n```", "```\nubfm `Rd`, `Rs`, #`lsb`, #`lsb` + `width` - 1\n```", "```\nextr `Rd`, `Rl`, `Rr`, #`posn`\n```", "```\ntbz `Rs`, #`imm`, `target` // R`s` = W`n` or X`n`, `imm` = 0 to 31 (W`n`) or\ntbnz `Rs`, #`imm`, `target` // 0 to 63 (X`n`). `target` is a stmt label.\n```", "```\nadds `Rd`, `Rn`, `Rn` // `R` = X or W\n```", "```\nadcs `Rn`, `Rn`, `Rn` // `R` = X or W\n```", "```\n lea     r3, mask            // 0x0008000400020001\n        ldr     q3, [r3]\n        cmeq    v0.4h, v1.4h, v2.4h\n        and     v0.8b, v0.8b, v3.8b // Keep LO bit of each lane.\n        addv    h0, v0.4h           // Merge the bits into H0.\n        umov    w0, v0.h[0]\n        lsl     w0, w0, #28\n        mrs     x0, nzcv\n```", "```\n tst w0, 0b10000  // Check bit #4 to see if it is 0/1.\n  bne bitIsSet\n\n `Do this if the bit is clear.`\n   .\n   .\n   .\nbitIsSet:   // Branch here if the bit is set.\n```", "```\n tst w0, 0b0110\n    beq noBitsSet\n\n `Do whatever needs to be done if one of the bits is set.`\n\nnoBitsSet:\n```", "```\n ldr  w1, =bitMask     // Assume not valid immediate const.\n    ands w0, w0, w1\n    cmp  w0, w1\n    bne  allBitsArentSet\n\n// All the bit positions in W0 corresponding to the set\n// bits in bitMask are equal to 1 if we get here.\n\n `Do whatever needs to be done if the bits match.`\n\nallBitsArentSet:\n```", "```\n ldr  w1, =bitMask     // Assume not valid immediate const.\n    mvn  w0, w0\n    tst  w0, w1\n    bne  NotAllOnes\n\n// At this point, W0 contained all 1s in the bit positions\n// occupied by 1s in the bitMask constant.\n\n `Do whatever needs to be done at this point.`\n\nNotAllOnes:\n```", "```\norr     w1, wzr, #0x80000000  // mov x1, #0x80000000\nnegs    w1, w1                // Sets V (and N) flags\n```", "```\nlsl  w1, w1, #5\nbic  w0, w0, #0b111100000\norr  w0, w0, w1\n```", "```\nbfi `Rd`, `Rs`, #`posn`, #`len`\n```", "```\nbfi w0, w1, #12, #16\n```", "```\n// Listing12-1.S\n//\n// Demonstrate inserting bit strings into a register.\n//\n// Note that this program must be assembled and linked\n// with the \"LARGEADDRESSAWARE:NO\" option.\n\n#include    \"aoaa.inc\"\n\n            .text\n            .pool\n\nttlStr:     wastr   \"Listing 12-1\"\n\n// Sample input data for the main program:\n\nValue2Merge:\n            .dword  0x12, 0x1e, 0x5555\n            .dword  0x1200, 0x120\n\nMergeInto:\n            .dword  0xffffffff, 0, 0x12345678\n            .dword  0x33333333, 0xf0f0f0f\n\nLenInBits:  .dword  5, 9, 16, 16, 12\nszLenInBits =       (.-LenInBits)/8\n\nStartPosn:  .dword  7, 4, 4, 12, 18\n\n// Format strings used to print results:\n\nfmtstr1:    wastr   \"merge(%x, \"\nfmtstr2:    wastr   \"%x, \"\nfmtstr3:    wastr   \"%d) = \"\nfmtstr4:    wastr   \"%x\\n\"\nfmtstr:     wastr   \"Here I am!\\n\"\n\n// getTitle\n//\n// Returns a pointer to the program's name\n// in X0:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// MergeBits(Val2Merge, MergeWith, Start, Length)\n//\n// Length (LenInBits[i]) value is passed in X3.\n// Start (StartPosn[i]) is passed in X2.\n// Val2Merge (Value2Merge[i]) and MergeWith (MergeInto[i])\n// are passed in X1 and X0.\n//\n// mergeBits result is returned in X0.\n\n            proc    mergeBits\n\n            locals  mb\n            qword   mb.x1x2\n            qword   mb.x3x4\n            byte    mb.stk, 64\n            endl    mb\n\n            enter   mb.size\n\n            stp     x1, x2, [fp, #mb.x1x2]\n            stp     x3, x4, [fp, #mb.x3x4]\n\n // Generate mask bits\n            // 1 in bits 0 to n - 1:\n\n          ❶ mov     x4, #1\n            lsl     x4, x4, x3  // Compute 2**n.\n            sub     x4, x4, #1  // 2**n - 1\n\n            // Position mask bits to target location:\n\n          ❷ lsl     x4, x4, x2\n\n            // Mask out target bits:\n\n          ❸ bic     x0, x0, x4\n\n            // Merge the bits:\n\n          ❹ lsl     x1, x1, x2\n            orr     x0, x0, x1\n\n            // Restore registers and return:\n\n            ldp     x3, x4, [fp, #mb.x3x4]\n            ldp     x1, x2, [fp, #mb.x1x2]\n            leave\n            endp    mergeBits\n\n// Here is the asmMain function:\n\n          ❺ proc    asmMain, public\n\n            locals  am\n            qword   am.x20x21\n            qword   am.x22x23\n            dword   am.x24\n            byte    am.stk, 256\n            endl    am\n\n            enter   am.size\n            stp     x20, x21, [fp, #am.x20x21]\n            stp     x22, x23, [fp, #am.x22x23]\n            str     x24, [fp, #am.x24]\n\n            // The following loop calls mergeBits as\n            // follows\n            //\n            // mergeBits\n            // (\n            //      Value2Merg[i],\n            //      MergeInto[i],\n            //      StartPosn[i],\n            //      LenInBits[i]);\n            //\n            // where \"i\" runs from 4 down to 0.\n //\n            // Index of the last element in the arrays:\n\n            mov     x20, #szLenInBits - 1\n\ntestLoop: \n\n            // Fetch the Value2Merge element and write\n            // its value to the display while it is\n            // handy:\n\n            lea     x1, Value2Merge\n            ldr     x1, [x1, x20, lsl #3]\n            mstr    x1, [sp]\n            lea     x0, fmtstr1\n            mov     x22, x1             // Save for later.\n            bl      printf\n\n            // Fetch the MergeInto element and write\n            // its value to the display:\n\n            lea     x1, MergeInto\n            ldr     x1, [x1, x20, lsl #3]\n            mstr    x1, [sp]\n            mov     x21, x1             // Save for later.\n            lea     x0, fmtstr2\n            bl      printf\n\n            // Fetch the StartPosn element and write\n            // its value to the display:\n\n            lea     x1, StartPosn\n            ldr     x1, [x1, x20, lsl #3]\n            mstr    x1, [sp]\n            mov     x23, x1             // Save for later.\n            lea     x0, fmtstr2\n            bl      printf\n\n            // Fetch the LenInBits element and write\n            // its value to the display:\n\n            lea     x1, LenInBits\n            ldr     x1, [x1, x20, lsl #3]\n            mstr    x1, [sp]\n            mov     x24, x1             // Save for later.\n            lea     x0, fmtstr3\n            bl      printf\n\n            // Call MergeBits:\n            //      (\n            //          Value2Merge,\n            //          MergeInto,\n            //          StartPosn,\n            //          LenInBits\n            //      );\n\n mov     x0, x21\n            mov     x1, x22\n            mov     x2, x23\n            mov     x3, x24\n            bl      mergeBits\n\n            // Display the function result (returned in\n            // X0\\. For this program, the results are\n            // always 32 bits, so it prints only the LO\n            // 32 bits of X0):\n\n            mov     x1, x0\n            mstr    x1, [sp]\n            lea     x0, fmtstr4\n            bl      printf\n\n            // Repeat for each element of the array:\n\n            subs    x20, x20, #1\n            bpl     testLoop\n\nallDone:\n            ldp     x20, x21, [fp, #am.x20x21]\n            ldp     x22, x23, [fp, #am.x22x23]\n            ldr     x24, [fp, #am.x24]\n            leave\n            endp    asmMain\n```", "```\n% ./build Listing12-1\n% ./Listing12-1\nCallingListing 12-1:\nmerge(120, f0f0f0f, 12, 12) = 4830f0f\nmerge(1200, 33333333, c, 16) = 31200333\nmerge(5555, 12345678, 4, 16) = 12355558\nmerge(1e, 0, 4, 9) = 1e0\nmerge(12, ffffffff, 7, 5) = fffff97f\nListing12-1 terminated\n```", "```\nbfm `Rd`, `Rs`, #`rotate`, #`bitposn`\n```", "```\nbfxil `Rd`, `Rs`, #`posn`, #`len`\n```", "```\nmov   w0, wzr         // Extract bits 5 through 12 from W1\nbfxil w0, w1, #5, #8  // and store them in W0.\n```", "```\n// Generate mask bits\n// 1 in bits 0 to n - 1:\n\nmov     x4, #1\nlsl     x4, x4, x3  // Compute 2**n.\nsub     x4, x4, #1  // 2**n - 1\n\n// Position mask bits to target location:\n\nlsl     x4, x4, x2\n\n// Extract the target bits:\n\nand     x1, x1, x4\n\n// Right-justify the bits to bit 0:\n\nlsr     x0, x1, x2\n```", "```\nbfc `Rd`, #`posn`, #`len`\n```", "```\nbfi `Rd`, `Rzr`, #`posn`, #`len`  // Rzr = WZR or XZR\n```", "```\nbfm `Rd`, `Rs`, #`immr`, #`imms`\n```", "```\nldr     w0, =0xffffffff\nmov     w1, #0x2\nbfm     w0, w1, #4, #2\n```", "```\nbfm `Rd`, `Rs`, #(-`posn` % 64), #(len-1)\n```", "```\nbfm `Rd`, `Rs`, #`posn`, #(`len`+`posn`-1)\n```", "```\nldr w2, =0b11110001000000000000 // Bit set mask in posn.\nlsl w0, w0, #12                 // Move src bits into posn.\nand w0, w0, w2                  // Mask out source bits.\nbic w1, w1, w2                  // Clear out destination bits.\norr w1, w1, w0                  // Merge bit set into W1.\n```", "```\n// W0- Contains the source value to insert the bits into\n// W1- Contains the bits to insert, justified against bit 0\n// W2- Counter (size of register, 32 in this case)\n// W3- Bitmap; 1s specify bits to copy, 0 specifies bits\n//      to preserve\n\n            mov     w2, #32      // Number of bits to rotate\n            b.al    DistLoop\n\nCopyToW0:\n            extr    w0, w1, w0, #1\n            lsr     w1, w1, #1\n            cbz     w2, Done\nDistLoop:\n          ❶ sub     w2, w2, #1\n            tst     w3, #1\n            lsr     w3, w3, #1\n            bne     CopyToW0\n\n          ❷ ror     w0, w0, #1\n            cbnz    w2, DistLoop\nDone:\n```", "```\n// W0- Destination register\n// W1- Source register\n// W3- Bitmap with 1s representing bits to copy to W0\n\n        mov    w0, wzr    // Clear destination register.\n        b.al   ShiftLoop\n\nShiftInW0:\n        extr    w0, w0, w1, #31\n      ❶ lsl     w1, w1, #1\n\nShiftLoop:\n      ❷ tst     w3, #0x80000000\n        lsl     w3, w3, #1\n        bne     ShiftInW0   // W3 HO bit was set.\n\n      ❸ lsl     w1, w1, #1\n        cbnz    w3, ShiftLoop\n```", "```\n`Element_Address_in_bits` =\n    `Base_address_in_bits` + `index` × `element_size_in_bits`\n```", "```\n`Byte_of_1st_bit` =\n    `Base_Address` + (`index` × `element_size_in_bits`) / 8\n\n`Offset_to_1st_bit` =\n    (`index` × `element_size_in_bits`) % 8\n```", "```\nAO3Bobjects:\n    .space  (200 * 3)/8 + 2  // \"+2\" handles truncation.\n```", "```\n// Extract the `i`th group of 3 bits in AO3Bobjects\n// and leave this value in W0:\n\n        mov     w2, wzr         // Put i / 8 remainder here.\n        ldr     w0, [fp, #i]    // Get the index into the array.\n\n        mov     w4, #3\n        mul     w0, w0, w4      // W0 = W0 * 3 (3 bits/element)\n        ubfiz   w2, w0, #0, #3  // W2 = LO 3 bits of W0\n        lsr     w0, w0, #3      // W0 / 8 -> W0 and W0 % 8 -> W2\n\n// Okay, fetch the word containing the 3 bits you want to\n// extract. You have to fetch a word because the last bit or two\n// could wind up crossing the byte boundary (that is, bit\n// offset 6 and 7 in the byte).\n\n        lea     x1, AO3Bobjects\n\n        ldrh    w0, [x1, x0]    // Fetch 16 bits.\n        lsr     w0, w0, w2      // Move bits down to bit 0.\n        And     w0, w0, #0b111  // Remove the other bits.\n```", "```\nMasks:\n            .hword    ~ 0b0111,            ~ 0b00111000\n            .hword    ~ 0b000111000000,    ~ 0b1110\n            .hword    ~ 0b01110000,        ~ 0b001110000000\n            .hword    ~ 0b00011100,        ~ 0b11100000\n              .\n              .\n              .\n\n// Get the index into the array (assume i is a local variable):\n\n            ldr     w1, [fp, #i]\n\n// Use LO 3 bits as index into Masks table:\n\n and     w2, w1, #0b111\n            lea     x4, Masks\n            ldrh    w4, [x4, w2, uxtw #1] // Get bitmask.\n\n// Convert index into the array into a bit index.\n// To do this, multiply the index by 3:\n\n            mov     w3, #3\n            mul     w1, w1, w3\n\n// Divide by 8 to get the byte index into W1\n// and the bit index (the remainder) into W2:\n\n            and     w2, w1, #0b111\n            lsr     w1, w1, #3\n\n// Grab the bits and clear those you're inserting:\n\n            lea     x5, AO3Bobjects\n            ldrh    w6, [x5, w1, uxtw #0]\n            and     w3, w4, w6\n\n// Put your 3 bits in their proper location:\n\n            lsl     w0, w0, w2\n\n// Merge bits into destination:\n\n            orr     w3, w3, w0\n\n// Store back into memory:\n\n            strh    w3, [x5, w1, uxtw #0]\n```", "```\n000 000 000 000 000 111 000 000 000 000 00 ...\n```", "```\n0000 0000 0000 0011 1000 0000 0000 0000\n```", "```\n mov  w1, #31    // Count off the bit positions in W1.\nTstLp:    adds w0, w0, w0 // Check whether the current bit\n                          // position contains a 1.\n          bcs  Done       // Exit loop if it does.\n          subs w1, w1, #1 // Decrement your bit position counter by 1.\n          bpl  TstLp      // Exit after 32 iterations.\nDone:\n```", "```\nclz w0, w0\nsub w0, w0, #31\nneg w0, w0\n```", "```\n mov  w2, #16\n          lsl  w0, w0, #16     // Put LO 16 bits in the HO\n          lsl  w1, w1, #16     // bit positions.\nMergeLp:  extr w3, w3, w0, #31 // Shift a bit from W0 into W3.\n          Extr w3, w3, w1, #31 // Shift a bit from W1 into W3.\n          lsl  w0, w0, #1      // Move on to the next bit in\n          lsl  w1, w1, #1      // W0 and W1.\n          subs w2, w2, #1      // Repeat 16 times.\n          bne  MergeLp\n```", "```\nbfi  w3, w0, #0, #6   // W0[0:5] to W3[0:5]\nbfi  w3, w1, #6, #5   // W1[0:4] to W3[6:10]\nlsr  w0, w0, #6\nbfi  w3, w0, #11, #6  // W0[6:11] to W3[11:16]\nlsr  w1, w1, #5\nbfi  w3, w1, #17, #11 // W1[5:15] to W3[17:27]\nlsr  w0, w0, #6\nbfi  w3, w0, #28, #4  // W0[12:15] to W3[28:31]\n```", "```\n ldr     w0, =0x55555555\n            mov     w3, wzr\n            mov     w1, wzr\n            mov     w2, #16     // Count the loop iterations.\nExtractLp:  adds    w0, w0, w0  // Extract odd bits to W3.\n            adc     w3, w3, w3\n            adds    w0, w0, w0  // Extract even bits to W1.\n            adc     w1, w1, w1\n subs    w2, w2, #1  // Repeat 16 times.\n            bne     ExtractLp\n```", "```\n// Listing12-2.S\n//\n// Demonstration of bit string searching\n\n        #include    \"aoaa.inc\"\n\n        .text\n        .pool\nttlStr: wastr   \"Listing 12-2\"\nnoMatchStr:\n        wastr   \"Did not find bit string\\n\"\n\nmatchStr:\n        wastr   \"Found bit string at posn %d\\n\"\n\n        proc    getTitle, public\n        lea     x0, ttlStr\n        ret\n        endp    getTitle\n\n        proc    asmMain, public\n\n locals  am\n        word    pattern\n        word    source\n        word    mask\n        byte    am.stk, 64\n        endl    am\n\n        enter   am.size\n\n        // Initialize the local variables this code\n        // will use:\n\n        mov     w0, #0b1011110101101100\n        str     w0, [fp, #source]\n        mov     w0, #0b1011\n        str     w0, [fp, #pattern]\n        mov     w0, #0b1111\n        str     w0, [fp, #mask]\n\n        // Here's the code that will search for the\n        // pattern in the source bit string:\n\n        mov     w2, #28             // 28 attempts because 32 - 4 = 28\n                                    // (len(src) - len(pat))\n        ldr     w3, [fp, #mask]     // Mask for the comparison.\n        ldr     w0, [fp, #pattern]  // Pattern to search for\n        and     w0, w0, w3          // Mask unnecessary bits in W0.\n        ldr     w1, [fp, #source]   // Get the source value.\nScanLp: mov     w4, w1              // Copy the LO 4 bits of W1.\n        and     w4, w4, w3          // Mask unwanted bits.\n        cmp     w0, w4              // See if you match the pattern.\n        beq     Matched\n        sub     w2, w2, #1          // Repeat specified number of times.\n        lsr     w1, w1, #1\n        cbnz    w1, ScanLp\n\n// Do whatever needs to be done if you failed to\n// match the bit string:\n\n        lea     x0, noMatchStr\n        bl      printf\n        b.al    Done\n\n// If you get to this point, you matched the bit string.\n// You can compute the position in the original source as 28 - W2.\n\nMatched:\n        mov     x1, #28\n        sub     x1, x1, x2\n        mstr    x1, [sp]\n        lea     x0, matchStr\n        bl      printf\nDone:\n        leave                       // Return to caller.\n        endp    asmMain\n```", "```\n% ./build Listing12-2\n% ./Listing12-2\nCalling Listing12-2:\nFound bit string at posn 2\nListing12-2 terminated\n```"]