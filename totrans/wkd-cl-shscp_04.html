<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_79"/><span class="big"><strong>3</strong></span><br/><strong>CREATING UTILITIES</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">One of the main purposes of creating shell scripts is to drop complex command line sequences into files, making them replicable and easy to tweak. It should be no surprise, then, that user commands are sprawled across this book. What is surprising? That we haven’t written a wrapper for every single command on our Linux, Solaris, and OS X systems.</p>&#13;
<p class="indent">Linux/Unix is the only major operating system where you can decide that you don’t like the default flags of a command and fix it forever with just a few keystrokes, or where you can emulate the behavior of your favorite utilities from other operating systems by using an alias or a dozen lines of script. That’s what makes Unix so tremendously fun—and what led to writing this book in the first place!</p>&#13;
<h3 class="h3" id="ch03lev1sec01"><span epub:type="pagebreak" id="page_80"/><strong>#22 A Reminder Utility</strong></h3>&#13;
<p class="noindenta">Windows and Mac users have appreciated simple utilities like Stickies for years, the streamlined applications that let you keep tiny notes and reminders stuck on your screen. They’re perfect for jotting down phone numbers or other reminders. Unfortunately, there’s no analog if you want to take notes while working on a Unix command line, but the problem is easily solved with this pair of scripts.</p>&#13;
<p class="indent">The first script, <code>remember</code> (shown in <a href="ch03.xhtml#ch3ex1">Listing 3-1</a>), lets you easily save your snippets of information into a single <code>rememberfile</code> in your home directory. If invoked without any arguments, it reads standard input until the end-of-file sequence (<code>^D</code>) is given by pressing <small>CTRL</small>-D. If invoked with arguments, it just saves those arguments directly to the data file.</p>&#13;
<p class="indent">The other half of this duo is <code>remindme</code>, a companion shell script shown in <a href="ch03.xhtml#ch3ex2">Listing 3-2</a>, which either displays the contents of the whole <code>rememberfile</code> when no arguments are given or displays the results of searching through it using the arguments as a pattern.</p>&#13;
<h4 class="h4" id="ch03lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # remember--An easy command line-based reminder pad&#13;
&#13;
   rememberfile="$HOME/.remember"&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     # Prompt the user for input and append whatever they write to&#13;
     #   the rememberfile.&#13;
     echo "Enter note, end with ^D: "&#13;
<span class="ent">➊</span>   cat - &gt;&gt; $rememberfile&#13;
   else&#13;
     # Append any arguments passed to the script on to the .remember file.&#13;
<span class="ent">➋</span>   echo "$@" &gt;&gt; $rememberfile&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch3ex1"/><em>Listing 3-1: The</em> <code><em>remember</em></code> <em>shell script</em></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3ex2">Listing 3-2</a> details the companion script, <code>remindme</code>.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # remindme--Searches a data file for matching lines or, if no&#13;
   #   argument is specified, shows the entire contents of the data file&#13;
&#13;
   rememberfile="$HOME/.remember"&#13;
&#13;
   if [ ! -f $rememberfile ] ; then&#13;
     echo "$0: You don't seem to have a .remember file. " &gt;&amp;2&#13;
     echo "To remedy this, please use 'remember' to add reminders" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     # Display the whole rememberfile when not given any search criteria.&#13;
<span class="ent">➌</span>   more $rememberfile&#13;
   else&#13;
     # Otherwise, search through the file for the given terms, and display&#13;
     #   the results neatly.&#13;
<span class="ent">➍</span>   grep -i -- "$@" $rememberfile | ${PAGER:-more}&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_81"/><a id="ch3ex2"/><em>Listing 3-2: The</em> <code><em>remindme</em></code> <em>shell script, a companion to the</em> <code><em>remember</em></code> <em>shell script in <a href="ch03.xhtml#ch3ex1">Listing 3-1</a></em></p>&#13;
<h4 class="h4" id="ch03lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>remember</code> shell script in <a href="ch03.xhtml#ch3ex1">Listing 3-1</a> can work as an interactive program, requesting the user to enter the details to remember, or it could actually be scripted since it can also accept anything to store simply as a command line argument. If a user does not pass any arguments to the script, then we do a little tricky coding. After printing a user-friendly message on how to enter an item, we read the data from the user with <code>cat</code> <span class="ent">➊</span>:</p>&#13;
<pre class="programs">cat - &gt;&gt; $rememberfile</pre>&#13;
<p class="indent">In previous chapters, we have used the <code>read</code> command to get input from the user. This line of code reads from <code>stdin</code> (the <code>-</code> in the command is shorthand for <code>stdin</code> or <code>stdout</code>, depending on the context) using <code>cat</code> until the user presses <small>CTRL</small>-D, which tells the <code>cat</code> utility that the file has ended. As <code>cat</code> prints the data it reads from <code>stdin</code>, and appends this data to the <code>rememberfile</code>.</p>&#13;
<p class="indent">If an argument is specified to the script, however, all arguments are simply appended as is to the <code>rememberfile</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">The <code>remindme</code> script in <a href="ch03.xhtml#ch3ex2">Listing 3-2</a> cannot work if the <code>rememberfile</code> doesn’t exist, so we first check if the <code>rememberfile</code> exists before attempting to do anything. If the <code>rememberfile</code> doesn’t exist, we exit immediately after printing a message to the screen alerting the user why.</p>&#13;
<p class="indent">If no arguments are passed to the script, we assume the user just wants to see the contents of the <code>rememberfile</code>. Using the <code>more</code> utility to allow paging through the <code>rememberfile</code>, we simply display the contents to the user <span class="ent">➌</span>.</p>&#13;
<p class="indent">Otherwise, if arguments are passed to the script, we perform a case-insensitive <code>grep</code> to search for any matching terms in the <code>rememberfile</code>, and then display these results with paging as well <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To use the <code>remindme</code> utility, first add notes, phone numbers, or anything else to the <code>rememberfile</code> with the <code>remember</code> script, as in <a href="ch03.xhtml#ch3ex3">Listing 3-3</a>. Then search this freeform database with <code>remindme</code>, specifying as long or short a pattern as you’d like.</p>&#13;
<h4 class="h4" id="ch03lev2sec04"><span epub:type="pagebreak" id="page_82"/><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">remember Southwest Airlines: 800-IFLYSWA</span>&#13;
$ <span class="codestrong">remember</span>&#13;
Enter note, end with ^D:&#13;
<span class="codestrong">Find Dave's film reviews at http://www.DaveOnFilm.com/</span>&#13;
<span class="codestrong">^D</span></pre>&#13;
<p class="listcap"><a id="ch3ex3"/><em>Listing 3-3: Testing the</em> <code><em>remember</em></code> <em>shell script</em></p>&#13;
<p class="indent">Then, when you want to remember that note months later, <a href="ch03.xhtml#ch3ex4">Listing 3-4</a> shows how you can find the reminder.</p>&#13;
<pre class="programs">$ <span class="codestrong">remindme film reviews</span>&#13;
Find Dave's film reviews at http://www.DaveOnFilm.com/</pre>&#13;
<p class="listcap"><a id="ch3ex4"/><em>Listing 3-4: Testing the</em> <code><em>remindme</em></code> <em>shell script</em></p>&#13;
<p class="indent">Or if there’s an 800 number you can’t quite recall, <a href="ch03.xhtml#ch3ex5">Listing 3-5</a> demonstrates locating a partial phone number.</p>&#13;
<pre class="programs">$ <span class="codestrong">remindme 800</span>&#13;
Southwest Airlines: 800-IFLYSWA</pre>&#13;
<p class="listcap"><a id="ch3ex5"/><em>Listing 3-5: Locating a partial phone number with the</em> <code><em>remindme</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch03lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">While certainly not any sort of shell script programming tour de force, these scripts neatly demonstrate the extensibility of the Unix command line. If you can envision something, the odds are good that there’s a simple way to accomplish it.</p>&#13;
<p class="indent">These scripts could be improved in any number of ways. For instance, you could introduce the concept of <em>records</em>: each <code>remember</code> entry is timestamped, and multiline input can be saved as a single record that can be searched for using regular expressions. This approach lets you store phone numbers for a group of people and retrieve them all just by remembering the name of one person in the group. If you’re really into scripting, you might also want to include edit and delete capabilities. Then again, it’s pretty easy to edit the <em>~/.remember</em> file by hand.</p>&#13;
<h3 class="h3" id="ch03lev1sec02"><strong>#23 An Interactive Calculator</strong></h3>&#13;
<p class="noindenta">If you’ll remember, <code>scriptbc</code> (<a href="ch01.xhtml#ch01lev1sec10">Script #9</a> on <a href="ch01.xhtml#page_34">page 34</a>) allowed us to invoke floating-point <code>bc</code> calculations as inline command arguments. The logical next step is to write a wrapper script to turn this script into a fully interactive command line–based calculator. The script (shown in <a href="ch03.xhtml#ch3ex6">Listing 3-6</a>) ends up being really short! Ensure that the <code>scriptbc</code> script is in the <code>PATH</code>, otherwise this script will fail to run.</p>&#13;
<h4 class="h4" id="ch03lev2sec06"><span epub:type="pagebreak" id="page_83"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # calc--A command line calculator that acts as a frontend to bc&#13;
&#13;
   scale=2&#13;
&#13;
&#13;
   show_help()&#13;
   {&#13;
   cat &lt;&lt; EOF&#13;
     In addition to standard math functions, calc also supports:&#13;
&#13;
     a % b       remainder of a/b&#13;
     a ^ b       exponential: a raised to the b power&#13;
     s(x)        sine of x, x in radians&#13;
     c(x)        cosine of x, x in radians&#13;
     a(x)        arctangent of x, in radians&#13;
     l(x)        natural log of x&#13;
     e(x)        exponential log of raising e to the x&#13;
     j(n,x)      Bessel function of integer order n of x&#13;
     scale N     show N fractional digits (default = 2)&#13;
   EOF&#13;
   }&#13;
&#13;
   if [ $# -gt 0 ] ; then&#13;
     exec scriptbc "$@"&#13;
   fi&#13;
&#13;
   echo "Calc--a simple calculator. Enter 'help' for help, 'quit' to quit."&#13;
&#13;
   /bin/echo -n "calc&gt; "&#13;
&#13;
<span class="ent">➊</span> while read command args&#13;
   do&#13;
     case $command&#13;
     in&#13;
       quit|exit) exit 0                                  ;;&#13;
       help|\?)   show_help                               ;;&#13;
       scale)     scale=$args                             ;;&#13;
       *)         scriptbc -p $scale "$command" "$args"   ;;&#13;
     esac&#13;
&#13;
     /bin/echo -n "calc&gt; "&#13;
   done&#13;
&#13;
   echo ""&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch3ex6"/><em>Listing 3-6: The</em> <code><em>calc</em></code> <em>command line calculator shell script</em></p>&#13;
<h4 class="h4" id="ch03lev2sec07"><span epub:type="pagebreak" id="page_84"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Perhaps the most interesting part of this code is the <code>while read</code> statement <span class="ent">➊</span>, which creates an infinite loop that displays the <code>calc&gt;</code> prompt until the user exits, either by entering <code>quit</code> or by entering an end-of-file sequence (<code>^D</code>). The simplicity of this script is what makes it extra wonderful: shell scripts don’t need to be complex to be useful!</p>&#13;
<h4 class="h4" id="ch03lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script uses <code>scriptbc</code>, the floating-point calculator we wrote in <a href="ch01.xhtml#ch01lev1sec10">Script #9</a>, so make sure you have that script available in your <code>PATH</code> as <code>scriptbc</code> (or set a variable like <code>$scriptbc</code> to the script’s current name) before running it. By default, this script runs as an interactive tool that prompts the user for the desired actions. If invoked with arguments, those arguments are passed along to the <code>scriptbc</code> command instead. <a href="ch03.xhtml#ch3ex7">Listing 3-7</a> shows both usage options at work.</p>&#13;
<h4 class="h4" id="ch03lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">calc 150 / 3.5</span>&#13;
42.85&#13;
$ <span class="codestrong">calc</span>&#13;
Calc--a simple calculator. Enter 'help' for help, 'quit' to quit.&#13;
calc&gt; <span class="codestrong">help</span>&#13;
  In addition to standard math functions, calc also supports:&#13;
&#13;
  a % b       remainder of a/b&#13;
  a ^ b       exponential: a raised to the b power&#13;
  s(x)        sine of x, x in radians&#13;
  c(x)        cosine of x, x in radians&#13;
  a(x)        arctangent of x, in radians&#13;
  l(x)        natural log of x&#13;
  e(x)        exponential log of raising e to the x&#13;
  j(n,x)      Bessel function of integer order n of x&#13;
  scale N     show N fractional digits (default = 2)&#13;
calc&gt; <span class="codestrong">54354 ^ 3</span>&#13;
160581137553864&#13;
calc&gt; <span class="codestrong">quit</span>&#13;
$</pre>&#13;
<p class="listcap"><a id="ch3ex7"/><em>Listing 3-7: Testing the</em> <code><em>calc</em></code> <em>shell script</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>WARNING</strong></span></p>&#13;
<p class="notep"><em>Floating-point calculations, even those that are easy for us humans, can be tricky on computers. Unfortunately, the</em> <code><em>bc</em></code> <em>command can reveal some of these glitches in unexpected ways. For example, in</em> <code><em>bc</em></code><em>, set</em> <code><em><strong>scale=0</strong></em></code> <em>and enter</em> <code><em><strong>7 % 3</strong></em></code><em>. Now try it with</em> <code><em><strong>scale=4</strong></em></code><em>. This produces</em> <code><em>.0001</em></code><em>, which is clearly incorrect.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec10"><span epub:type="pagebreak" id="page_85"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Whatever you can do in <code>bc</code> on a command line you can do in this script, with the caveat that <code>calc.sh</code> has no line-to-line memory or state retention. This means you could add more mathematical functions to the help system, if you were so inclined. For example, the variables <code>obase</code> and <code>ibase</code> let you specify input and output numeric bases, though since there’s no line-by-line memory, you’d have to either modify <code>scriptbc</code> (<a href="ch01.xhtml#ch01lev1sec10">Script #9</a> on <a href="ch01.xhtml#page_34">page 34</a>) or learn to enter the setting and the equation all on a single line.</p>&#13;
<h3 class="h3" id="ch03lev1sec03"><strong>#24 Converting Temperatures</strong></h3>&#13;
<p class="noindenta">The script in <a href="ch03.xhtml#ch3ex8">Listing 3-8</a>, which marks the first use of sophisticated mathematics in this book, can translate any temperature between Fahrenheit, Celsius, and Kelvin units. It uses the same trick of piping an equation to <code>bc</code> as we used in <a href="ch01.xhtml#ch01lev1sec10">Script #9</a> on <a href="ch01.xhtml#page_34">page 34</a>.</p>&#13;
<h4 class="h4" id="ch03lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # convertatemp--Temperature conversion script that lets the user enter&#13;
   #   a temperature in Fahrenheit, Celsius, or Kelvin and receive the&#13;
   #   equivalent temperature in the other two units as the output&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     cat &lt;&lt; EOF &gt;&amp;2&#13;
   Usage: $0 temperature[F|C|K]&#13;
   where the suffix:&#13;
       F    indicates input is in Fahrenheit (default)&#13;
       C    indicates input is in Celsius&#13;
       K    indicates input is in Kelvin&#13;
   EOF&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➊</span> unit="$(echo $1|sed -e 's/[-[:digit:]]*//g' | tr '[:lower:]' '[:upper:]' )"&#13;
<span class="ent">➋</span> temp="$(echo $1|sed -e 's/[^-[:digit:]]*//g')"&#13;
&#13;
   case ${unit:=F}&#13;
   in&#13;
   F ) # Fahrenheit to Celsius formula: Tc = (F - 32) / 1.8&#13;
     farn="$temp"&#13;
<span class="ent">➌</span>   cels="$(echo "scale=2;($farn - 32) / 1.8" | bc)"&#13;
     kelv="$(echo "scale=2;$cels + 273.15" | bc)"&#13;
     ;;&#13;
&#13;
   C ) # Celsius to Fahrenheit formula: Tf = (9/5)*Tc+32&#13;
     cels=$temp&#13;
     kelv="$(echo "scale=2;$cels + 273.15" | bc)"&#13;
<span class="ent">➍</span>   farn="$(echo "scale=2;(1.8 * $cels) + 32" | bc)"&#13;
     ;;&#13;
&#13;
<span class="ent">➎</span> K ) # Celsius = Kelvin - 273.15, then use Celsius -&gt; Fahrenheit formula&#13;
     kelv=$temp&#13;
     cels="$(echo "scale=2; $kelv - 273.15" | bc)"&#13;
     farn="$(echo "scale=2; (1.8 * $cels) + 32" | bc)"&#13;
     ;;&#13;
&#13;
     *)&#13;
     echo "Given temperature unit is not supported"&#13;
     exit 1&#13;
   esac&#13;
&#13;
   echo "Fahrenheit = $farn"&#13;
   echo "Celsius    = $cels"&#13;
   echo "Kelvin     = $kelv"&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_86"/><a id="ch3ex8"/><em>Listing 3-8: The</em> <code><em>convertatemp</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch03lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">At this point in the book, most of the script is probably clear, but let’s have a closer look at the math and regular expressions that do all the work. “Math first,” as most school-age children would undoubtedly <em>not</em> appreciate hearing! Here is the formula for converting degrees Fahrenheit to degrees Celsius:</p>&#13;
<div class="image2"><img src="../images/e0086-01.jpg" alt="image"/></div>&#13;
<p class="indent">Converted into a sequence that can be fed to <code>bc</code> and solved, it looks like the code at <span class="ent">➌</span>. The reverse conversion, Celsius to Fahrenheit, is at <span class="ent">➍</span>. The script also converts the temperature from Celsius to Kelvin <span class="ent">➎</span>. This script demonstrates one big reason to use mnemonic variable names: it makes the code a whole lot easier to read and debug.</p>&#13;
<p class="indent">The other bits of code here that are interesting are the regular expressions, the gnarliest of which is easily the one at <span class="ent">➊</span>. What we’re doing is pretty straightforward, if you can unwrap the <code>sed</code> substitution. Substitutions always look like <code>s/<em>old</em>/<em>new</em>/</code>; the <code><em>old</em></code> pattern here is zero or more occurrences of <code>-</code>, followed by any of the set of digits (recall that <code>[:digit:]</code> is the ANSI character set notation for any digit and <code>*</code> matches zero or more occurrences of the previous pattern). The <code><em>new</em></code> pattern then is what we want to replace the <code><em>old</em></code> pattern with, and in this case it is simply <code>//</code>, which signifies an empty pattern; this pattern is useful when you just want to remove the old one. This substitution effectively removes all the digits so that inputs like <code>-31f</code> turn into just <code>f</code>, giving us the type of units. Finally, the <code>tr</code> command normalizes everything to uppercase so, for example, <code>-31f</code> turns into <code>F</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>The other <code>sed</code> expression does the opposite <span class="ent">➋</span>: it removes anything that isn’t numeric by using the <code>^</code> operator to negate matches for any characters in the class <code>[:digit:]</code>. (Most languages use <code>!</code> as negation.) This provides us with the value we eventually convert using the appropriate equation.</p>&#13;
<h4 class="h4" id="ch03lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has a nice, intuitive input format, even if it is pretty unusual for a Unix command. Input is entered as a numeric value, with an optional suffix that indicates the units of the temperature entered; when no suffix is given, the code assumes the units are Fahrenheit.</p>&#13;
<p class="indent">To see the Celsius and Kelvin equivalents of 0° Fahrenheit, enter <code>0F</code>. To see what 100° Kelvin is in Fahrenheit and Celsius, use <code>100K</code>. And to get 100° Celsius in Kelvin and Fahrenheit, enter <code>100C</code>.</p>&#13;
<p class="indent">You’ll see this same single-letter suffix approach again in <a href="ch07.xhtml#ch07lev1sec08">Script #60</a> on <a href="ch07.xhtml#page_190">page 190</a>, which converts currency values.</p>&#13;
<h4 class="h4" id="ch03lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch03.xhtml#ch3ex9">Listing 3-9</a> shows conversion across many different temperatures.</p>&#13;
<pre class="programs">$ <span class="codestrong">convertatemp 212</span>&#13;
Fahrenheit = 212&#13;
Celsius    = 100.00&#13;
Kelvin     = 373.15&#13;
$ <span class="codestrong">convertatemp 100C</span>&#13;
Fahrenheit = 212.00&#13;
Celsius    = 100&#13;
Kelvin     = 373.15&#13;
$ <span class="codestrong">convertatemp 100K</span>&#13;
Fahrenheit = -279.67&#13;
Celsius    = -173.15&#13;
Kelvin     = 100</pre>&#13;
<p class="listcap"><a id="ch3ex9"/><em>Listing 3-9: Testing the</em> <code><em>convertatemp</em></code> <em>shell script with a few conversions</em></p>&#13;
<h4 class="h4" id="ch03lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">You can add a few input flags to generate succinct output for only one conversion at a time. Something like <code>convertatemp -c 100F</code> could output just the Celsius equivalent of 100° Fahrenheit, for example. This approach will help you use converted values in other scripts as well.</p>&#13;
<h3 class="h3" id="ch03lev1sec04"><strong>#25 Calculating Loan Payments</strong></h3>&#13;
<p class="noindenta">Another common calculation users might deal with is estimation of loan payments. The script in <a href="ch03.xhtml#ch3ex10">Listing 3-10</a> also helps answer the question “What can I do with that bonus?” and the related question “Can I finally afford that new Tesla?”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>While the formula to calculate payments based on the principal, interest rate, and duration of the loan is a bit tricky, some judicious use of shell variables can tame the mathematical beast and make it surprisingly understandable.</p>&#13;
<h4 class="h4" id="ch03lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # loancalc--Given a principal loan amount, interest rate, and&#13;
   #   duration of loan (years), calculates the per-payment amount&#13;
&#13;
   # Formula is M = P * ( J / (1 - (1 + J) ^ -N)),&#13;
   #   where P = principal, J = monthly interest rate, N = duration (months).&#13;
&#13;
   # Users typically enter P, I (annual interest rate), and L (length, years).&#13;
&#13;
<span class="ent">➊</span> . library.sh         # Start by sourcing the script library.&#13;
&#13;
&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $0 principal interest loan-duration-years" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➋</span> P=$1 I=$2 L=$3&#13;
   J="$(scriptbc -p 8 $I / \( 12 \* 100 \) )"&#13;
   N="$(( $L * 12 ))"&#13;
   M="$(scriptbc -p 8 $P \* \( $J / \(1 - \(1 + $J\) \^ -$N\) \) )"&#13;
&#13;
   # Now a little prettying up of the value:&#13;
&#13;
<span class="ent">➌</span> dollars="$(echo $M | cut -d. -f1)"&#13;
   cents="$(echo $M | cut -d. -f2 | cut -c1-2)"&#13;
&#13;
   cat &lt;&lt; EOF&#13;
   A $L-year loan at $I% interest with a principal amount of $(nicenumber $P 1 )&#13;
   results in a payment of \$$dollars.$cents each month for the duration of&#13;
   the loan ($N payments).&#13;
   EOF&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch3ex10"/><em>Listing 3-10: The</em> <code><em>loancalc</em></code> <em>shell script</em></p>&#13;
<h4 class="h4" id="ch03lev2sec17"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Exploring the formula itself is beyond the scope of this book, but it’s worth noting how a complex mathematical formula can be implemented directly in a shell script.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>The entire calculation could be solved using a single long input stream to <code>bc</code>, because that program also supports variables. However, being able to manipulate the intermediate values within the script itself proves beyond the capabilities of the <code>bc</code> command alone. Also, frankly, breaking up the equation into a number of intermediate equations <span class="ent">➋</span> also facilitates debugging. For example, here’s the code that splits the computed monthly payment into dollars and cents and ensures that it’s presented as a properly formatted monetary value:</p>&#13;
<pre class="programs">dollars="$(echo $M | cut -d. -f1)"&#13;
cents="$(echo $M | cut -d. -f2 | cut -c1-2)"</pre>&#13;
<p class="indent">The <code>cut</code> command proves useful here <span class="ent">➌</span>. The second line of this code grabs the portion of the monthly payment value that follows the decimal point and then chops off anything after the second character. If you would prefer to round this number to the next nearest cent instead, just add 0.005 to the value before truncating the cents at two digits.</p>&#13;
<p class="indent">Notice also how at <span class="ent">➊</span>, the script library from earlier in the book is neatly included with the <code>. library.sh</code> command in the script, ensuring that all the functions (for our purposes in this script, the <code>nicenumber()</code> function from <a href="ch01.xhtml#ch01">Chapter 1</a>) are then accessible to the script.</p>&#13;
<h4 class="h4" id="ch03lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This minimalist script expects three parameters: the amount of the loan, the interest rate, and the duration of the loan (in years).</p>&#13;
<h4 class="h4" id="ch03lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Say you’ve been eyeing a new Tesla Model S, and you’re curious about how much your payments would be if you bought the car. The Model S starts at about $69,900 out the door, and the latest interest rates are running at 4.75 percent for an auto loan. Assuming your current car is worth about $25,000 and that you can trade it in at that price, you’ll be financing the difference of $44,900. If you haven’t already had second thoughts, you’d like to see what the difference is in total payments between a four-year and five-year car loan—easily done with this script, as <a href="ch03.xhtml#ch3ex11">Listing 3-11</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">loancalc 44900 4.75 4</span>&#13;
A 4-year loan at 4.75% interest with a principal amount of 44,900&#13;
results in a payment of $1028.93 each month for the duration of&#13;
the loan (48 payments).&#13;
$ <span class="codestrong">loancalc 44900 4.75 5</span>&#13;
A 5-year loan at 4.75% interest with a principal amount of 44,900&#13;
results in a payment of $842.18 each month for the duration of&#13;
the loan (60 payments).</pre>&#13;
<p class="listcap"><a id="ch3ex11"/><em>Listing 3-11: Testing the</em> <code><em>loancalc</em></code> <em>shell script</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>If you can afford the higher payments on the four-year loan, the car will be paid off sooner, and your total payments (monthly payment times number of payments) will be significantly less. To calculate the exact savings, we can use the interactive calculator from <a href="ch03.xhtml#ch03lev1sec02">Script #23</a> on <a href="ch03.xhtml#page_82">page 82</a>, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">calc '(842.18 * 60) - (1028.93 * 48)'</span>&#13;
1142.16</pre>&#13;
<p class="indent">This seems like a worthwhile savings: $1,142.16 could buy a nice laptop!</p>&#13;
<h4 class="h4" id="ch03lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This script could really do with a way to prompt for each field if the user doesn’t provide any parameters. An even more useful version of this script would let a user specify <em>any</em> three parameters of the four (principal, interest rate, number of payments, and monthly payment amount) and automatically solve for the fourth value. That way, if you knew you could afford only $500 per month in payments and that the maximum duration of a 6 percent auto loan was 5 years, you could ascertain the largest amount of principal that you could borrow. You could accomplish this calculation by implementing flags that users can use to pass in the values they want.</p>&#13;
<h3 class="h3" id="ch03lev1sec05"><strong>#26 Keeping Track of Events</strong></h3>&#13;
<p class="noindenta">This is actually a pair of scripts that together implement a simple calendar program, similar to our reminder utility from <a href="ch03.xhtml#ch03lev1sec01">Script #22</a> on <a href="ch03.xhtml#page_80">page 80</a>. The first script, <code>addagenda</code> (shown in <a href="ch03.xhtml#ch3ex12">Listing 3-12</a>), enables you to specify a recurring event (with either a day of the week for weekly events or a day and month for annual ones) or a one-time event (with the day, month, and year). All the dates are validated and saved, along with a one-line event description, in an <em>.agenda</em> file in your home directory. The second script, <code>agenda</code> (shown in <a href="ch03.xhtml#ch3ex13">Listing 3-13</a>), checks all known events to show which ones are scheduled for the current date.</p>&#13;
<p class="indent">This kind of tool is particularly useful for remembering birthdays and anniversaries. If you have trouble remembering events, this handy script can save you a lot of grief!</p>&#13;
<h4 class="h4" id="ch03lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # addagenda--Prompts the user to add a new event for the agenda script&#13;
&#13;
   agendafile="$HOME/.agenda"&#13;
&#13;
   isDayName()&#13;
   {&#13;
     # Return 0 if all is well, 1 on error.&#13;
<span epub:type="pagebreak" id="page_91"/>     case $(echo $1 | tr '[[:upper:]]' '[[:lower:]]') in&#13;
       sun*|mon*|tue*|wed*|thu*|fri*|sat*) retval=0 ;;&#13;
       * ) retval=1 ;;&#13;
     esac&#13;
     return $retval&#13;
   }&#13;
&#13;
   isMonthName()&#13;
   {&#13;
     case $(echo $1 | tr '[[:upper:]]' '[[:lower:]]') in&#13;
       jan*|feb*|mar*|apr*|may|jun*)     return 0        ;;&#13;
       jul*|aug*|sep*|oct*|nov*|dec*)    return 0        ;;&#13;
       * ) return 1      ;;&#13;
     esac&#13;
   }&#13;
&#13;
<span class="ent">➊</span> normalize()&#13;
   {&#13;
     # Return string with first char uppercase, next two lowercase.&#13;
     /bin/echo -n $1 | cut -c1  | tr '[[:lower:]]' '[[:upper:]]'&#13;
     echo  $1 | cut -c2-3| tr '[[:upper:]]' '[[:lower:]]'&#13;
   }&#13;
&#13;
   if [ ! -w $HOME ] ; then&#13;
     echo "$0: cannot write in your home directory ($HOME)" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   echo "Agenda: The Unix Reminder Service"&#13;
   /bin/echo -n "Date of event (day mon, day month year, or dayname): "&#13;
   read word1 word2 word3 junk&#13;
&#13;
   if isDayName $word1 ; then&#13;
     if [ ! -z "$word2" ] ; then&#13;
       echo "Bad dayname format: just specify the day name by itself." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
     date="$(normalize $word1)"&#13;
&#13;
   else&#13;
&#13;
     if [ -z "$word2" ] ; then&#13;
       echo "Bad dayname format: unknown day name specified" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     if [ ! -z "$(echo $word1|sed 's/[[:digit:]]//g')" ]  ; then&#13;
       echo "Bad date format: please specify day first, by day number" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     if [ "$word1" -lt 1 -o "$word1" -gt 31 ] ; then&#13;
       echo "Bad date format: day number can only be in range 1-31" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
<span epub:type="pagebreak" id="page_92"/>     if [ ! isMonthName $word2 ] ; then&#13;
       echo "Bad date format: unknown month name specified." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     word2="$(normalize $word2)"&#13;
&#13;
     if [ -z "$word3" ] ; then&#13;
       date="$word1$word2"&#13;
     else&#13;
       if [ ! -z "$(echo $word3|sed 's/[[:digit:]]//g')" ] ; then&#13;
         echo "Bad date format: third field should be year." &gt;&amp;2&#13;
         exit 1&#13;
       elif [ $word3 -lt 2000 -o $word3 -gt 2500 ] ; then&#13;
         echo "Bad date format: year value should be 2000-2500" &gt;&amp;2&#13;
         exit 1&#13;
       fi&#13;
       date="$word1$word2$word3"&#13;
     fi&#13;
   fi&#13;
&#13;
   /bin/echo -n "One-line description: "&#13;
   read description&#13;
&#13;
   # Ready to write to data file&#13;
&#13;
<span class="ent">➋</span> echo "$(echo $date|sed 's/ //g')|$description" &gt;&gt; $agendafile&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch3ex12"/><em>Listing 3-12: The</em> <code><em>addagenda</em></code> <em>shell script</em></p>&#13;
<p class="indent">The second script, in <a href="ch03.xhtml#ch3ex13">Listing 3-13</a>, is shorter but is used more often.</p>&#13;
<pre class="programs">   #!/bin/sh&#13;
&#13;
   # agenda--Scans through the user's .agenda file to see if there&#13;
   #   are matches for the current or next day&#13;
&#13;
   agendafile="$HOME/.agenda"&#13;
&#13;
   checkDate()&#13;
   {&#13;
     # Create the possible default values that will match today.&#13;
     weekday=$1   day=$2   month=$3   year=$4&#13;
<span class="ent">➌</span>   format1="$weekday"   format2="$day$month"   format3="$day$month$year"&#13;
&#13;
   # And step through the file comparing dates...&#13;
&#13;
   IFS="|"       # The reads will naturally split at the IFS.&#13;
&#13;
   echo "On the agenda for today:"&#13;
     while read date description ; do&#13;
       if [ "$date" = "$format1" -o "$date" = "$format2" -o \&#13;
            "$date" = "$format3" ]&#13;
       then&#13;
         echo " $description"&#13;
       fi&#13;
     done &lt; $agendafile&#13;
   }&#13;
&#13;
   if [ ! -e $agendafile ] ; then&#13;
     echo "$0: You don't seem to have an .agenda file. " &gt;&amp;2&#13;
     echo "To remedy this, please use 'addagenda' to add events" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Now let's get today's date...&#13;
&#13;
<span class="ent">➍</span> eval $(date '+weekday="%a" month="%b" day="%e" year="%G"')&#13;
&#13;
<span class="ent">➎</span> day="$(echo $day|sed 's/ //g')" # Remove possible leading space.&#13;
&#13;
   checkDate $weekday $day $month $year&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_93"/><a id="ch3ex13"/><em>Listing 3-13: The</em> <code><em>agenda</em></code> <em>shell script, a companion to the</em> <code><em>addagenda</em></code> <em>script in <a href="ch03.xhtml#ch3ex12">Listing 3-12</a></em></p>&#13;
<h4 class="h4" id="ch03lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>addagenda</code> and <code>agenda</code> scripts support three types of recurring events: weekly events (“every Wednesday”), annual events (“every August 3”), and one-time events (“January 1, 2017”). As entries are added to the agenda file, their specified dates are normalized and compressed so that <code>3 August</code> becomes <code>3Aug</code> and <code>Thursday</code> becomes <code>Thu</code>. This is accomplished with the <code>normalize</code> function in <code>addagenda</code> <span class="ent">➊</span>.</p>&#13;
<p class="indent">This function chops any value entered down to three characters, ensuring that the first character is uppercase and the second and third are lowercase. This format matches the standard abbreviated day and month name values from the <code>date</code> command output, which will be critical for the correct functioning of the <code>agenda</code> script. The rest of the <code>addagenda</code> script has nothing particularly complex happening in it; the bulk of it is devoted to error tests for bad data formats.</p>&#13;
<p class="indent">Finally, at <span class="ent">➋</span> it saves the now normalized record data to the hidden file. The ratio of error-checking code to actual functional code is pretty typical of a well-written program: clean up the data on input and you’ll be able to confidently make assumptions about its formatting in subsequent apps.</p>&#13;
<p class="indent">The <code>agenda</code> script checks for events by transforming the current date into the three possible date string formats (<em>dayname</em>, <em>day+month</em>, and <em>day+month+year</em>) <span class="ent">➌</span>. It then compares these date strings to each line in the <em>.agenda</em> data file. If there’s a match, that event is shown to the user.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>The coolest hack in this pair of scripts is probably how an <code>eval</code> is used to assign variables to each of the four date values needed <span class="ent">➍</span>.</p>&#13;
<pre class="programs">eval $(date "+weekday=\"%a\" month=\"%b\" day=\"%e\" year=\"%G\"")</pre>&#13;
<p class="indent">It’s possible to extract the values one by one (for example, <code>weekday="$(date +%a)"</code>), but in very rare cases, this method can fail if the date rolls over to a new day in the middle of the four <code>date</code> invocations, so a succinct single invocation is preferable. Plus, it’s just cool.</p>&#13;
<p class="indent">Since <code>date</code> returns a day as a number with either a leading zero or a leading space, neither of which are desired, the next line of code at <span class="ent">➎</span> strips both from the value, if present, before proceeding. Go have a peek to see how that works!</p>&#13;
<h4 class="h4" id="ch03lev2sec23"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The <code>addagenda</code> script prompts the user for the date of a new event. Then, if it accepts the date format, the script prompts for a one-line description of the event.</p>&#13;
<p class="indent">The companion <code>agenda</code> script has no parameters and, when invoked, produces a list of all events scheduled for the current date.</p>&#13;
<h4 class="h4" id="ch03lev2sec24"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">To see how this pair of scripts works, let’s add a number of new events to the database, as <a href="ch03.xhtml#ch3ex14">Listing 3-14</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">addagenda</span>&#13;
Agenda: The Unix Reminder Service&#13;
Date of event (day mon, day month year, or dayname): <span class="codestrong">31 October</span>&#13;
One-line description: <span class="codestrong">Halloween</span>&#13;
$ <span class="codestrong">addagenda</span>&#13;
Agenda: The Unix Reminder Service&#13;
Date of event (day mon, day month year, or dayname): <span class="codestrong">30 March</span>&#13;
One-line description: <span class="codestrong">Penultimate day of March</span>&#13;
$ <span class="codestrong">addagenda</span>&#13;
Agenda: The Unix Reminder Service&#13;
Date of event (day mon, day month year, or dayname): <span class="codestrong">Sunday</span>&#13;
One-line description: <span class="codestrong">sleep late (hopefully)</span>&#13;
$ <span class="codestrong">addagenda</span>&#13;
Agenda: The Unix Reminder Service&#13;
Date of event (day mon, day month year, or dayname): <span class="codestrong">march 30 17</span>&#13;
Bad date format: please specify day first, by day number&#13;
$ <span class="codestrong">addagenda</span>&#13;
Agenda: The Unix Reminder Service&#13;
Date of event (day mon, day month year, or dayname): <span class="codestrong">30 march 2017</span>&#13;
One-line description: <span class="codestrong">Check in with Steve about dinner</span></pre>&#13;
<p class="listcap"><a id="ch3ex14"/><em>Listing 3-14: Testing the</em> <code><em>addagenda</em></code> <em>script and adding many agenda items</em></p>&#13;
<p class="indent">Now the <code>agenda</code> script offers a quick and handy reminder of what’s happening today, detailed in <a href="ch03.xhtml#ch3ex15">Listing 3-15</a>.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_95"/>$ <span class="codestrong">agenda</span>&#13;
On the agenda for today:&#13;
  Penultimate day of March&#13;
  sleep late (hopefully)&#13;
  Check in with Steve about dinner</pre>&#13;
<p class="listcap"><a id="ch3ex15"/><em>Listing 3-15: Using the</em> <code><em>agenda</em></code> <em>script to see what our agenda items are for today</em></p>&#13;
<p class="indent">Notice that it matched entries formatted as <em>dayname</em>, <em>day+month</em>, and <em>day+month+year</em>. For completeness, <a href="ch03.xhtml#ch3ex16">Listing 3-16</a> shows the associated <em>.agenda</em> file, with a few additional entries:</p>&#13;
<pre class="programs">$ <span class="codestrong">cat ~/.agenda</span>&#13;
14Feb|Valentine's Day&#13;
25Dec|Christmas&#13;
3Aug|Dave's birthday&#13;
4Jul|Independence Day (USA)&#13;
31Oct|Halloween&#13;
30Mar|Penultimate day of March&#13;
Sun|sleep late (hopefully)&#13;
30Mar2017|Check in with Steve about dinner</pre>&#13;
<p class="listcap"><a id="ch3ex16"/><em>Listing 3-16: The raw contents of the</em> .agenda <em>file storing the agenda items</em></p>&#13;
<h4 class="h4" id="ch03lev2sec25"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This script really just scratches the surface of this complex and interesting topic. It’d be nice to have it look a few days ahead, for example; this could be accomplished in the <code>agenda</code> script by doing some date math. If you have the GNU <code>date</code> command, date math is easy. If you don’t, well, enabling date math solely in the shell requires a complex script. We’ll look more closely at date math later in the book, notably in <a href="ch15.xhtml#ch15lev1sec01">Script #99</a> on <a href="ch15.xhtml#page_330">page 330</a>, <a href="ch15.xhtml#ch15lev1sec02">Script #100</a> on <a href="ch15.xhtml#page_332">page 332</a>, and <a href="ch15.xhtml#ch15lev1sec03">Script #101</a> on <a href="ch15.xhtml#page_335">page 335</a>.</p>&#13;
<p class="indent">Another (easier) hack would be to have <code>agenda</code> output <code>Nothing scheduled for today</code> when there are no matches for the current date, rather than the sloppier <code>On the agenda for today:</code> followed by nothing.</p>&#13;
<p class="indent">This script could also be used on a Unix box for sending out systemwide reminders about events like backup schedules, company holidays, and employee birthdays. First, have the <code>agenda</code> script on each user’s machine additionally check a shared read-only <em>.agenda</em> file. Then add a call to the <code>agenda</code> script in each user’s <em>.login</em> or similar file that’s invoked on login.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Rather surprisingly, date implementations vary across different Unix and Linux systems, so if you try something more complicated with your own date command and it fails, make sure to check the man page to see what your system can and cannot do.</em><span epub:type="pagebreak" id="page_96"/></p>&#13;
</div>&#13;
</body></html>