<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch2">
<span class="CN"><span aria-label=" Page 31. " epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">VALUE AND REFERENCE TYPES</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">We can create new types in C# in several ways, and we need to consider the individual characteristics of each approach to determine which best suits our goals. In particular, knowing how value types differ from reference types helps us choose the right way forward, because these differences have significant and sometimes unconsidered implications when we’re defining our own types. Certain trade-offs will affect how we design our type and what we can use it for. In this chapter, we’ll investigate those differences and what they mean for our programs.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">What choices we have when creating our own types</li>
<li class="BL">Why C# has both reference types and value types</li>
<li class="BL"><span aria-label=" Page 32. " epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>How choosing one or the other affects construction, null checking, and other type behavior</li>
<li class="BL">Why value type is not the same as value semantics</li>
<li class="BL">Where different types are stored in memory and how that affects an object’s lifetime</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-28"/><samp class="SANS_Futura_Std_Bold_B_11">User-Defined Types</samp></h2>
<p class="TNI">Most modern programming languages allow you to create custom types. The basic principles of user-defined types in C# will be familiar to programmers of many other languages, but some of the details are different. Therefore, in this section we’ll examine the four kinds of user-defined types: structs, classes, and the newer records and record structs (introduced in C# v9.0 and v10.0, respectively).</p>
<p class="TX">It’s important to recognize that the behavior of these types relies heavily on whether they are reference types or value types. Let’s look briefly at each kind of user-defined type with these differences in mind.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structs and Classes</samp></h3>
<p class="TNI"><a href="#list2-1">Listing 2-1</a> defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> to represent colors.</p>
<pre id="list2-1"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = (r, g, b);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Defining a simple struct</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> to indicate that instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable—that is, they never change their value. Correspondingly, none of the three properties (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, so their values can’t be changed after they’ve been given initial values using the constructor.</p>
<p class="TX">The constructor in this example uses the expression body syntax (<samp class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</samp>), which you saw in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, instead of a body enclosed between braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>. We make the expression body a single-line statement by using <i>tuple assignment</i>, which assigns the tuple of three parameter values <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to the tuple of three properties. The compiler translates this syntax into an efficient assignment from the parameter values directly to the respective backing fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> properties.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword in the struct’s definition is not mandatory but reinforces that instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable. Immutable value types <span aria-label=" Page 33. " epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/>make our code easier to comprehend and may allow some optimizations by the compiler.</p>
<p class="TX">By contrast, if we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class instead of a struct, we can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword in its definition, although we can make it immutable by not providing <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for the properties. The only other difference in defining <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as a class is the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> keyword in the definition:</p>
<pre><code>public class Color&#13;
{&#13;
<var>--snip--</var></code></pre>
<p class="TNI">The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is otherwise identical to that in <a href="#list2-1">Listing 2-1</a>.</p>
<p class="TX">The principal difference between these two types is that a class is a reference type, and a struct is a value type. Before we analyze the implications of this difference, let’s look at record and record struct types.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-30"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record Structs</samp></h3>
<p class="TNI">As of C# v9.0, we can define a record type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> keyword. Records introduce a new syntax for compactly defining a type. <a href="#list2-2">Listing 2-2</a> creates a record type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<pre id="list2-2"><code>public record Color(int Red, int Green, int Blue);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Defining a record</samp></p>
<p class="TX">This example shows a <i>positional</i> record; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type has no body, but the type definition has its own positional parameters that are used by the compiler to generate a complete type. Behind the scenes, the compiler translates the record into a class definition, meaning that records are reference types. The compiler also translates the parameter names <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> into public properties of the same name, along with a public constructor with matching parameters to initialize the property values. The positional parameters are also used by the compiler to generate other methods, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, which are overrides of their counterparts in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class.</p>
<p class="TX"><a href="#list2-3">Listing 2-3</a> creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record and uses its properties exactly as if it were a class or a struct.</p>
<pre id="list2-3"><code>var tomato = new Color(Red: 255, Green: 99, Blue: 71);&#13;
Assert.That(tomato.Red, Is.EqualTo(255));&#13;
Assert.That(tomato.Green, Is.EqualTo(99));&#13;
Assert.That(tomato.Blue, Is.EqualTo(71));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Creating an instance of Color</samp></p>
<p class="TX">Here, we use named arguments when constructing the <samp class="SANS_TheSansMonoCd_W5Regular_11">tomato</samp> variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to emphasize the names given by the compiler to the constructor parameters. Note that the property names used in the assertions are <span aria-label=" Page 34. " epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>identical to the names used in the constructor, and that both match the names used in the record definition.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>One important difference between records and structs or classes relates to handling equality comparisons between two instances, a topic we’ll examine in more detail in “Identity Equality vs. Value Equality” on <a href="#sec19">page 47</a>.</i></p>
<p class="TX">Very closely related to records are record structs, introduced in C# v10.0. In contrast to records, which are compiled as classes, record structs are translated by the compiler into struct definitions, making them value types. Otherwise, they’re the same as records. Record structs are denoted by the <samp class="SANS_TheSansMonoCd_W5Regular_11">record struct</samp> keywords, as shown here:</p>
<pre><code>public readonly record struct Color(int Red, int Green, int Blue);</code></pre>
<p class="TX">This record struct, much like the struct in <a href="#list2-1">Listing 2-1</a>, is marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>. If we left out the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword, the properties generated by the compiler would be read-write properties, with both <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword makes <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> an immutable record struct.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-31"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheritance</samp></h3>
<p class="TNI">One common way of representing relationships between classes and between records is to use <i>inheritance</i>, or deriving one type from another. However, we can’t apply inheritance to structs or record structs; it’s available only to reference types.</p>
<p class="TX">Another restriction of inheritance is that a record can inherit from another record but not explicitly from a class. Similarly, classes can’t inherit from records. In every other respect, records follow the same rules and have the same characteristics as classes as far as inheritance is concerned. Classes and records can define virtual methods and properties, allowing a more derived type to provide its own behavior by overriding the method or property, and we can choose to ignore, override, or hide any virtual methods in a derived type.</p>
<p class="TX">In contrast, structs and record structs are implicitly <i>sealed</i>, meaning that inheriting from them is prohibited. If we attempt to derive from a struct or record struct, we get a compile-time error. Structs and record structs can’t inherit from another user-defined type either.</p>
<p class="TX">Another restriction for a class or record is that it can inherit from only one base type. Any attempt at multiple inheritance results in a compiler error. If no base type is explicitly specified, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> becomes the implied base class. As you’ll see in <span class="Xref">“The Common Type System” on <a href="#sec16">page 45</a></span>, every type ultimately inherits from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, either directly or indirectly. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> class in <a href="#list2-4">Listing 2-4</a> implicitly derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp> class derives explicitly from <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>, implicitly inheriting from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class.</p>
<pre id="list2-4"><code><span aria-label=" Page 35. " epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/>public class Command&#13;
{&#13;
    public virtual IEnumerable&lt;Result&gt; RunQuery(string query)&#13;
    {&#13;
        using var transaction = connection.BeginTransaction();&#13;
        return connection.Execute(transaction, query);&#13;
    }&#13;
    private readonly DatabaseConnection connection;&#13;
}&#13;
public class DummyCommand : Command&#13;
{&#13;
    public override IEnumerable&lt;Result&gt; RunQuery(string query)&#13;
    {&#13;
        return new List&lt;Result&gt;();&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Inheritance syntax</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class defines a virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">RunQuery</samp> method, which is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp> class to alter the method’s behavior. A stub implementation like <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp> might be used during testing to avoid having the test code depend on the underlying data store’s contents.</p>
<p class="TX">Any type may <i>implement</i> multiple interfaces, but it’s important to understand that inheritance is quite different from interface implementation. When we implement an interface, the implementing method is, by default, <i>not</i> virtual. A class or record implementing a method from an interface can choose to make its implementation of the method virtual, but a struct or record struct cannot.</p>
<p class="TX">We can explicitly designate any member of a class or record as <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>, as opposed to <samp class="SANS_TheSansMonoCd_W5Regular_11">public</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>. A protected member is accessible within the class declaring it and to any types that inherit from that class, but it’s not visible to any other code. Since value types are sealed, it makes no sense for them to have virtual or protected members. If we try to make a method virtual in a value type definition or to define any protected fields, properties, or methods, we’re rewarded with a compiler error.</p>
<p class="TX">We can choose to declare a class or record type as <samp class="SANS_TheSansMonoCd_W5Regular_11">sealed</samp> so that it can’t be used for further inheritance. Sealing a class does not affect what <i>it</i> can inherit, only what can inherit from it. It’s common to seal classes that have value-like characteristics, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>, or when we wish to restrict a class’s behavior to that defined in our own implementation. If a class is intended to be immutable, whether or not it’s intended to have value-like characteristics, sealing it ensures that its immutability can’t be subverted by a mutable derived class.</p>
<p class="TX">Records are specifically intended to be value-like types and have value-like behavior defined for them by the compiler. This means we should seal record types unless we have a compelling reason not to do so. We’ll look in detail at the meaning of <i>value-like</i> and why such types should be sealed in <span class="Xref"><a href="chapter6.xhtml">Chapters 6</a> and <a href="chapter7.xhtml">7</a></span>.</p>
<aside aria-labelledby="box1" class="box">
<h3 class="BH" id="box1"><span aria-label=" Page 36. " epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">ABSTRACT BASE TYPES</samp></h3>
<p class="BTNI"><samp class="SANS_Futura_Std_Book_11">An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">abstract</samp> <samp class="SANS_Futura_Std_Book_11">type is one that can be used only as a base type for inheritance; it can’t be instantiated directly with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp><samp class="SANS_Futura_Std_Book_11">. One implication is that while classes and records can be abstract, structs and record structs can’t. It would make no sense: we can’t inherit from a value type, so it could never be instantiated.</samp></p>
<p class="BTX"><samp class="SANS_Futura_Std_Book_11">In an abstract type, we can designate methods and properties as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract</samp><samp class="SANS_Futura_Std_Book_11">, meaning they have no implementation. Their purpose is simply to define the operations that a concrete type must support. An abstract method or property is implicitly virtual, but providing an implementation for one prompts a compiler error. Abstract types don’t have to define any abstract members, but only abstract classes or records can have abstract methods and properties. Any abstract methods or properties remain abstract unless they’re explicitly overridden in a derived class. Providing an implementation for an abstract method in a derived type makes that method concrete.</samp></p>
<p class="BTX"><samp class="SANS_Futura_Std_Book_11">We can inherit one abstract type from another and choose to either provide implementations for the base type’s abstract methods or leave them as abstract. We can only directly create an instance of a class or record that is fully concrete; that is, any and all abstract methods have been overridden.</samp></p>
<p class="BTX"><samp class="SANS_Futura_Std_Book_11">If we inherit from an abstract class, we can’t then inherit from any other class because that would be a form of multiple inheritance, which is prohibited.</samp></p>
<p class="BoxBodyCustom2"><samp class="SANS_Futura_Std_Book_11">It can be tempting to think of C# interfaces and their members as being abstract (especially for users familiar with C</samp><span class="symbol">++</span><samp class="SANS_Futura_Std_Book_11">, where interfaces are commonly implemented as classes with all pure-virtual methods), but that’s not the case. An interface contains only signatures of methods and properties; they are neither abstract nor virtual.</samp></p>
</aside>
<p class="TX">Inheritance is a central feature of object-oriented code, but it applies exclusively to reference types. Inheritance—as well as the features that support it, such as virtual methods—is not appropriate for value types, in part because of the way value type instances use memory.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-32"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Instance Lifetimes</samp></h3>
<p class="TNI">Value types and reference types differ in the way each uses memory and, more specifically, in the lifetime of their instances. Value type instances are short-lived, and their lifetime is bound to the lifetime of the variables that represent them. For value types, the variable <i>is</i> the instance; when we create a new instance of a value type, the target variable effectively contains the instance data—that is, the value of each field of the type.</p>
<p class="TX">In many cases, the lifetime of a variable is defined by a block, such as a method body or a <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. Any local variables within the block cease to exist when the block ends. Alternatively, a variable might be contained in another object, in which case the variable’s lifetime is defined by the lifetime of the enclosing object. Whenever we copy a value type variable by <span aria-label=" Page 37. " epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>assigning it to another variable or passing it as an argument to a method, the copy is a whole new instance of the type in a <i>different</i> variable.</p>
<p class="TX">Reference type instances, on the other hand, are generally long-lived and can be referred to by many variables. When we create a new instance of a reference type, we’re given a reference to that instance in memory. Whenever we copy that reference, we’re not also copying the instance. The original reference and the copy both refer to the same instance. References are stored in <i>reference variables</i>.</p>
<p class="TX">All reference type instances are allocated on the heap. Their lifetime is managed by automatic garbage collection, which releases their memory when they’re no longer needed by the program. An object is considered unused when the garbage collector determines that no other live references to that instance exist. While reference type instances are not subject to their scope, reference variables <i>are</i> subject to scope, so when one goes out of scope, it’s no longer a live reference to an instance. The lifetime of a reference type instance, then, is determined by the lifetimes of <i>all</i> the references to that instance.</p>
<p class="TX">A cost is associated with being allocated on the heap, because the garbage collection process takes time while the program is running. Ensuring that unused heap memory is properly cleaned up is a complex operation and may interrupt a program’s normal execution for a short time, so an overhead is associated with reference types.</p>
<p class="TX">Value types don’t require the overhead associated with garbage collection. The memory used by a value type instance can be freed when the lifetime of its variable ends. To understand lifetime a little better, let’s look more closely at what we mean by <i>variable</i> in different contexts.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h-33"/><samp class="SANS_Futura_Std_Bold_B_11">Variables</samp></h2>
<p class="TNI">A <i>variable</i> is simply a named area of memory. We use this name—or <i>identifier</i>— to manipulate a memory location during the variable’s lifetime. C# has five main kinds of variables:</p>
<p class="ListHead"><b>Local variables</b></p>
<p class="ListPlainFirst">These are block-scope variables, where a <i>block</i> might be a method with a statement body, the body of a loop, or any section of code delimited by matching braces, <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>. When control leaves a block at the closing brace, any variables that are local to the block go out of scope. When an exception is thrown in a block, the control flow also leaves that scope and any containing scope until the exception is caught or the program exits.</p>
<p class="ListHead"><b>Instance fields</b></p>
<p class="ListPlainFirst">These are normal data members, known as <i>fields</i>, of structs and non-static classes. Each instance of a type has its own copies of any instance fields. The lifetime of an instance field is defined by the lifetime of the object to which it belongs.</p>
<p class="ListHead"><span aria-label=" Page 38. " epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/><b>Static fields</b></p>
<p class="ListPlainFirst">These fields are associated with a type, rather than individual instances of the type. The lifetime of a static field is normally tied to an application, so the instances associated with static fields are usually released when an application exits.</p>
<p class="ListHead"><b>Array elements</b></p>
<p class="ListPlainFirst">Individual elements in an array are all variables. We can access a particular element by its index and alter the element instance if it is mutable.</p>
<p class="ListHead"><b>Method parameters</b></p>
<p class="ListPlainFirst">The parameters in a method definition are technically called <i>formal parameters</i> but are commonly known as just <i>parameters</i>. A parameter’s scope is the body of the method, exactly as if the parameter were declared as a local variable within the method’s body. In code that calls a method, we pass <i>actual parameters</i>, better known as <i>arguments</i>, that correspond to the method’s parameters.</p>
<p class="TX">Regardless of its kind, a variable always has an associated type. This might be an explicitly declared type, as in the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int size</samp>, or, for local variables, the type might be implied with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. If the variable’s type is a reference type, the variable’s <i>value</i> is a reference. A non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a handle to an instance somewhere on the heap. If the variable’s type is a value type, the variable’s value is an instance of the type.</p>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-34"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables vs. Values</samp></h3>
<p class="TNI">It’s not always easy to intuit what counts as a variable and what counts as a value, but the distinction is important:</p>
<ul class="BL">
<li class="BL"><i>Variables</i> can be assigned to, although a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> field variable can be assigned only within a constructor of the type of which it is a member, or using field initialization (which we’ll discuss in <span class="Xref">“Field Initializers” on <a href="#sec30">page 58</a></span>).</li>
<li class="BL"><i>Values</i> are the results of expressions—such as the result of calling <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>, the return value from a method, or a constant expression such as a literal number or <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> literal. Values <i>can’t</i> be assigned to, but we use them to initialize variables by using assignment or passing them as arguments to method parameters.</li>
</ul>
<p class="TX">Variables, for the most part, have names. Strictly speaking, individual array elements don’t have their own names, but for an array variable <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">index</samp>] is essentially the element’s identifier. A value can have a name but doesn’t require one: the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> produces a new value, but it is anonymous unless we assign that value to a variable.</p>
<p class="TX">The type of a value defines what an <i>instance</i> looks like. Among other things, the type might have multiple fields that need space allocated in memory when an instance of the type is created. The type of a variable defines the sort of value it can contain.</p>
<p class="TX"><span aria-label=" Page 39. " epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>A value is just a pattern of bits. The type is a formal specification for interpreting that bit pattern to give it meaning in a program. Two values with identical bit patterns may be interpreted differently if they are different types. A pattern of bits that are all <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> means one thing if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, but something else entirely if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>.</p>
<p class="TX">A variable of value type directly contains its data, whereas a variable of reference type contains a reference to its data. More precisely, reference variables have a value that is a reference to an object somewhere on the heap. Put simply, a reference refers to an instance of a reference type; the value of a reference type variable is a reference.</p>
<p class="TX">The relationship between variables and values is that all variables <i>have</i> a value, although the value can’t be accessed until the variable has been definitely assigned.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-35"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Definite Assignment</samp></h3>
<p class="TNI">We can’t read the value of a variable unless the compiler is satisfied that the variable has definitely been given an initial value. More formally, a variable can be read only after a value has been <i>definitely assigned</i> to it. The C# Language Specification precisely defines what constitutes definite assignment, but the essence is that a variable must have been assigned or initialized with a value at least once before its value is read.</p>
<p class="TX">If we try to obtain the value of any variable that hasn’t been definitely assigned, the compiler raises an error to tell us that this isn’t allowed. For example, when we declare a local variable within a method, it is uninitialized unless or until we assign a value to it. Such variables are initially considered <i>un</i>assigned. Conceptually, at least, an unassigned variable doesn’t have a value.</p>
<p class="TX">When we assign something to a variable, we give that variable a new value. When we read from a variable, we obtain its value. Variables and values are both <i>expressions</i>, meaning we can evaluate them to produce a value, as long as they have been definitely assigned.</p>
<p class="TX">To reiterate, attempting to read a value from any variable that hasn’t yet been definitely assigned is an error. When we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> declaration for a local variable, we must provide an initial value where the variable is declared, because the type of the variable is inferred from the type of the value being assigned to it.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h-36"/><samp class="SANS_Futura_Std_Bold_B_11">Instances and Storage</samp></h2>
<p class="TNI">Now that we’ve clearly defined variables and values, we can explore how they relate to type instances. Whether an instance is a value type or a reference type affects where it is allocated and managed in memory; as a result, value type variables have some peculiarities that don’t apply to references.</p>
<p class="TX">Value types do not always live on the stack, despite common misconceptions. Values for local variables are most often tied to the block scope of a method, and so might be associated with a stack frame for the method, but <span aria-label=" Page 40. " epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>values can also be contained within another object as a member or an element in an array. Let’s examine this more closely by looking at some examples of how variables are embedded in objects.</p>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Values</samp></h3>
<p class="TNI">If a variable is a field embedded within an instance of another type, its value is allocated within the memory for its enclosing object. This is especially important for value type variables that directly contain the instance of their type. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in <a href="#list2-5">Listing 2-5</a>.</p>
<pre id="list2-5"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = (r, g, b);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Defining a Color struct with multiple fields</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct has three properties representing the components of an RGB color. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value is used as a field or property in a class, an instance of that class will wholly contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value on the heap. Take, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class in <a href="#list2-6">Listing 2-6</a>, which has several fields, one of which is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.</p>
<pre id="list2-6"><code>public class Brush&#13;
{&#13;
<var>--snip--</var>&#13;
    public enum BrushStyle {Solid, Gradient, Texture}&#13;
    private readonly int width;&#13;
    private readonly Color color;&#13;
    private readonly BrushStyle style;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A Color value embedded within the Brush class</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> type is a class and therefore a reference type. When we create an instance of any reference type, it’s allocated on the heap. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class has three fields, one of which is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance, which itself has three fields (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>). An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> might look roughly like <a href="#fig2-1">Figure 2-1</a> in memory.</p><span aria-label=" Page 41. " epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img70" height="213" id="fig2-1" src="../images/Figure2-1.png" width="467"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: A Color value embedded in a Brush instance on the heap</samp></p></figcaption>
</figure>
<p class="TX">When we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>, the instance is created on the heap and we’re given a reference to it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field occupies memory directly within the memory space for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance. If we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as a record struct instead of a struct, the outcome would be the same. Record structs are value types in exactly the same way as structs and are allocated directly within the memory space of any enclosing object.</p>
<p class="TX">Value type instances are not individually garbage collected, but if a value type instance is embedded in another object that has been allocated on the heap, the <i>memory</i> used by the value type instance will be reclaimed during garbage collection of the enclosing object.</p>
<p class="TX">The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field is tied to the lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance. When the garbage collector determines that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance is no longer used, it will free up the memory for that instance, including the embedded <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.</p>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Array Elements</samp></h4>
<p class="TNI">When a value type instance is an element in an array, it isn’t (strictly speaking) a field of the array object, but the value is still embedded within the memory for the array. Arrays are always allocated on the heap, regardless of the type of their elements. When we create an array, we’re given a reference to it. To illustrate, consider this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values, where <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a struct:</p>
<pre><code>var colors = new Color[3];</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable here is a reference to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances on the heap. The memory layout of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> array might look like <a href="#fig2-2">Figure 2-2</a>.</p>
<figure class="IMG"><img alt="" class="img90" height="136" id="fig2-2" src="../images/Figure2-2.png" width="602"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: An array of Color structs in memory</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 42. " epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/>In the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> array, each element is large enough to store the three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> backing fields. If the element type had more fields, each element would require more space on the heap. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type were a record struct rather than a struct, the layout would be identical; recall that the compiler translates record structs into structs.</p>
<p class="TX">Reference variables, by contrast, are all the same size, regardless of the number of fields declared in the type definition. The memory required for an array of references is determined only by the number of elements, not the size of each instance.</p>
<p class="TX">Whether the elements of an array are references or value type instances, the array is always on the heap, and the array variable refers to its elements. If the garbage collector determines that the array is no longer in use—that is, no live reference variables to it exist—then the memory for all of its elements is freed in one go.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Embedded References</samp></h4>
<p class="TNI">Reference fields are also embedded in their enclosing type, but their instances are not. If we had implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as a reference type in <a href="#list2-5">Listing 2-5</a>, rather than a value type, the layout of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance would be somewhat different. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class would be a reference, as illustrated in <a href="#fig2-3">Figure 2-3</a>.</p>
<figure class="IMG"><img alt="" class="img70" height="354" id="fig2-3" src="../images/Figure2-3.png" width="542"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: A color reference field embedded in a Brush instance</samp></p></figcaption>
</figure>
<p class="TX">Instead of containing the entire instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> within its own memory, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field refers to a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance somewhere else on the heap. Reference type instances are always allocated on the heap and are independent of one another. This applies to any reference type, so it would be true if we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as either a class or a record.</p>
<p class="TX">The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance here is <i>independent</i> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance is no longer used and its memory is released, the <span aria-label=" Page 43. " epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance will remain in memory until the garbage collector determines that it’s no longer needed.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Field and Property Layout</samp></h4>
<p class="TNI">All user-defined types can contain instance fields and properties. However, structs and record structs have one restriction that does not apply to classes or records: a value type definition can’t embed a field of its own type.</p>
<p class="TX">You’ve already seen how value type instances directly contain their fields. If a type has a field that is itself a value type, that field also directly contains <i>its</i> data. If the type of that field is the same as its containing type, the compiler is unable to determine how to create it. Consider the simple struct in <a href="#list2-7">Listing 2-7</a> that embeds an instance of <i>itself</i> as a field.</p>
<pre id="list2-7"><code>struct Node&#13;
{&#13;
    Node p;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: A struct containing an instance of itself</samp></p>
<p class="TX">This example will not compile. The compiler can’t know how to lay out the contained field named <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>’s type isn’t fully defined at the point where it is declared. The same is true of properties, because even automatic properties require a backing field, though that field is hidden from us.</p>
<p class="TX">The same reasoning applies to an indirect dependency, illustrated in <a href="#list2-8">Listing 2-8</a>.</p>
<pre id="list2-8"><code>struct Tree&#13;
{&#13;
    Node root;&#13;
}&#13;
struct Node&#13;
{&#13;
    Tree leftChild, rightChild;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: A struct with a cyclic dependency</samp></p>
<p class="TX">Neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp> type nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> type can be created here because the layout of each depends on the other. This might sound draconian, but in practice it’s rarely a problem, and we have an easy workaround: if we change the definition of either <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> to make it a reference type, the compiler will accept this code. The rule applies only to value types because, as mentioned previously, references are always the same size regardless of the type to which they refer. This means the compiler doesn’t need to know the layout of a class or record to establish a reference to it.</p>
</section>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-38"/><span aria-label=" Page 44. " epub:type="pagebreak" id="pg_44" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxed Values</samp></h3>
<p class="TNI">References can refer only to objects on the heap and can’t refer to individual value type instances, even those enclosed within a reference type object. The only way for a reference variable to individually refer to a value type instance is to make a copy of the value, put that copy on the heap, and refer to the copy with a new reference. The process of creating a copy and storing it on the heap, known as <i>boxing</i>, is automatic when the type of the variable is a reference type. A boxed value can always be converted back to its original value type, a process called <i>unboxing</i>, where the value contained in the box is <i>copied</i> into the target variable.</p>
<p class="TX">Boxing happens automatically when we refer to a value using a reference variable such as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, or when we pass a value as an argument to a method that takes a reference type parameter. Unboxing is always <i>explicit</i>: we need to cast the boxed variable back to its correct value type, as shown in <a href="#list2-9">Listing 2-9</a>.</p>
<pre id="list2-9"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = (r, g, b);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}&#13;
var red = new Color(0xFF, 0, 0);&#13;
var green = new Color(0, 0xFF, 0);&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> object copy = green;&#13;
Assert.That(object.Equals(<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> red, copy), Is.False);&#13;
var copyGreen = <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> (Color)copy;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Boxing and unboxing</samp></p>
<p class="TX">The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, and is therefore a reference, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp> gets boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Similarly, calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp> method boxes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>, because the method takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameters <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We don’t need to explicitly cast the value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> type; it’s boxed implicitly. We do require an explicit cast to unbox the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> into a new variable <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">As you’ll see shortly when we cover the Common Type System, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is the base class of every type, meaning we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> to refer to any other variable, including value type instances. A struct can also implement one or more interfaces. Interfaces are reference types, so if we use either <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or an interface type to refer to a value, that value is automatically boxed onto the heap.</p>
<p class="TX">A boxed value can be unboxed only to its original type. We can’t, for instance, unbox an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value into a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, even though an implicit built-in <span aria-label=" Page 45. " epub:type="pagebreak" id="pg_45" role="doc-pagebreak"/>conversion exists from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. If we attempt to unbox a value to anything other than its original type, we’ll get an <samp class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp> at run time.</p>
<p class="TX">Boxed values are copied to the heap, which means the box is no longer subject to the scope of its variable and may exist beyond the lifespan of its original value. It’s up to the garbage collector to clean up boxed values. <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> discusses boxing in more detail.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h2 class="H1" id="sec15"><span id="h-39"/><samp class="SANS_Futura_Std_Bold_B_11">Semantics and Type</samp></h2>
<p class="TNI">Value types have semantic implications that go beyond being an instance of a struct or record struct. Choosing a value type instead of a reference type when we define our own types requires much more than a consideration of possible optimizations. Records, in particular, differ from classes, because even though records are compiled into classes and are therefore reference types, they share some important behavioral characteristics with value types.</p>
<p class="TX">Before delving into the behavior of record and record struct types, we need to better understand how structs differ from classes.</p>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Common Type System</samp></h3>
<p class="TNI">C# has a hierarchical type system, known as the <i>Common Type System</i>, in which all types derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, a keyword alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Object</samp> type. This is why we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> to refer to any other variable—although, as you just saw, in the case of value types, the instances are boxed so they can be referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> references.</p>
<p class="TX">Even the built-in types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. In fact, all built-in types are aliases for types in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> namespace. The <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> types that underlie the numeric types are all structs and therefore value types. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is an alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> type <samp class="SANS_TheSansMonoCd_W5Regular_11">public readonly struct Int32</samp>.</p>
<p class="TX">Enumeration types created with the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> keyword are not aliases to <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> types, although they all <i>derive</i> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp> class. The individual values of an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> declaration have an underlying numeric type, which by default is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. We could specify a different numeric type—for example, if we wanted to allow the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> elements to have values larger or smaller than is permitted for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<p class="TX">The non-numeric built-ins <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> are aliases to classes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> namespace, so they’re both reference types.</p>
<p class="TX">When we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> keyword to define our own reference type, our new type derives directly from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class unless it explicitly inherits from another type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class is neither an interface nor <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract</samp>. It has a mix of virtual, nonvirtual, and static members, which provide the default implementations common to all objects.</p>
<p class="TX">All struct types (including record structs) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp> type implicitly derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp> (for which there’s no keyword alias), which in turn derives from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class, so all struct types derive <span aria-label=" Page 46. " epub:type="pagebreak" id="pg_46" role="doc-pagebreak"/><i>indirectly</i> from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. Value types, unlike reference types, have an intermediate base class defined by the language.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>ValueType itself is</i> <span class="Roman">not</span> <i>a struct, which is sometimes overlooked. All structs implicitly inherit from ValueType, so ValueType itself must be a class. Moreover, ValueType is an</i> <span class="Roman">abstract</span> <i>class, meaning we can create an instance of object but not of ValueType.</i></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class overrides all the virtual methods defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class—<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>—and customizes their implementations to provide behavior tailored for value types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementations for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are extremely important because they provide the <i>value-based</i> definition of equality that distinguishes value types from reference types. The difference between these implementations has to do with the way values are copied.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H2" id="sec17"><span id="h-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Semantics</samp></h3>
<p class="TNI">The difference between where reference types and value types store their instance data has important implications when we copy variables, because copying a reference does not copy the instance. <a href="#list2-10">Listing 2-10</a> shows a simple example to illustrate the difference.</p>
<pre id="list2-10"><code>var thing = new Thing {Host = "Palmer"};&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> var copy = thing;&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> copy.Host = "Bennings";&#13;
Assert.That(thing.Host, Is.EqualTo("Palmer"));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Copying a variable</samp></p>
<p class="TX">Here we’re copying the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> variable into a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The test checks that the properties of the original variable haven’t changed. The success of the test assertion depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a value type or a reference type.</p>
<p class="TX">As noted earlier, all variables have a value that we may copy to a new variable. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a value type, any copy we make is a new instance of the type, so if we modify any fields of that copy, those changes have no effect on the fields of the original value. Therefore, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or a record struct, the test will pass.</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a reference type, on the other hand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> variable’s value is a reference. When we copy a reference, only the value of the reference is copied, and it refers to the same instance as the original variable’s value. This means if we modify the instance using one reference, that change is reflected in <i>all</i> the references to it. Thus, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class or a record, the test will fail.</p>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locks and Reference Semantics</samp></h4>
<p class="TNI">Some situations require the behavior of reference type variables, and using a value type instance would be incorrect or even disallowed. For example, <span aria-label=" Page 47. " epub:type="pagebreak" id="pg_47" role="doc-pagebreak"/>we can’t use a value type in a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> statement to prevent a section of code from being executed concurrently by multiple threads. The compiler forbids it because the variable used as a lock needs to be a reference to an object on the heap. The purpose of locking an object is to allow only a single thread to execute the code it protects at any given time. The object instance identifies the lock and can then have multiple references to it from different threads.</p>
<p class="TX">The underlying mechanism for the <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> statement is the <samp class="SANS_TheSansMonoCd_W5Regular_11">System .Threading.Monitor</samp> class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> statement translates to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp> method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>, which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> as its parameter. Any instance of a value type passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp> as an argument will automatically be boxed. Each thread calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp> will box the value separately, and the acquisition of the lock would never fail, rendering it pointless.</p>
<p class="TX">When we’ve finished with the lock, we need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp> and pass the <i>same</i> reference used to acquire the lock with <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>. The compiler inserts the code to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp> at the closing brace of a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> block. If we use a value type, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Exit</samp> will result in a new boxed value on the heap, and so will be a different reference to that used in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp>. The result is that releasing the lock will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SynchronizationLockException</samp> error.</p>
<p class="TX">This is one situation actively requiring reference semantics, because passing a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp> method doesn’t copy the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">monitor</samp> and the code using the lock both have a reference to the same instance.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Identity Equality vs. Value Equality</samp></h4>
<p class="TNI">When we say we’re comparing variables to see whether they’re equal, what we really mean is that we’re comparing the variables’ <i>values</i>. If two variables have the same value, they’re considered equal. The type of each value plays an important role: the values being compared must be the same type, although one or both values may have resulted from an implicit conversion.</p>
<p class="TX">If we compare the values of two variables of the same reference type, their respective values are references, which compare equal by default if they both refer to the same object in memory. This is known as an <i>identity comparison</i>. We can override the default identity comparison behavior in our own reference types (a topic we’ll examine in detail in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>), but two references to separate instances that have identical field values compare <i>unequal</i> according to the default identity comparison because they refer to different objects.</p>
<p class="TX">By contrast, two value type instances compare equal—again by default, because we can modify this behavior—if all the fields of one compare equal with their counterparts on the other. The difference in equality comparison behavior between value type instances and reference type instances is directly related to their respective copy semantics. Since a copy of a value type instance is a new independent instance with identical <i>state</i>, an identity comparison makes no sense. The two concepts of copying and equality are therefore intimately related.</p>
<p class="TX"><span aria-label=" Page 48. " epub:type="pagebreak" id="pg_48" role="doc-pagebreak"/>The ability to compare two values to see whether they are equal is often underappreciated. Even if we rarely need to compare variables in our own code, commonly used classes such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary&lt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, and the LINQ methods that work on collections may be making those comparisons out of sight. <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual method defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class, which is a clue to how fundamental it really is, because it means we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method on <i>any</i> value to compare it with any other.</p>
<p class="TX">However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp> implementation always performs an identity comparison, which, again, is pointless for value types. For this reason, all structs implicitly inherit the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class. <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to perform a value-based comparison.</p>
<p class="TX">The difference between what equality means for reference types and value types affects the way our code behaves at run time. Consider <a href="#list2-11">Listing 2-11</a>, where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> type has not yet been allocated as a reference type or value type and does not explicitly override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Here, we create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> with the same value for their <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp> property. What happens when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> depends entirely on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class, record, struct, or record struct.</p>
<pre id="list2-11"><code>public ??? Thing&#13;
{&#13;
    public string Host {get; set;}&#13;
}&#13;
var thing = new Thing {Host = "Palmer"};&#13;
var clone = new Thing {Host = "Palmer"};&#13;
Assert.That(clone.Equals(thing), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: Comparing equality of two independent variables</samp></p>
<p class="TX">This assertion will fail if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp> method will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> only if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> are references to the same instance, and they’re not. The assertion will pass if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> have the same value; that is, all their fields compare equal.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> variables also compare equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is either a record or a record struct because they also use a value-based comparison for equality.</p>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records, Structs, and Value Semantics</samp></h3>
<p class="TNI">Records are reference types but have value-like behavior when it comes to comparing two record variables for equality. When a record type is compiled, the compiler generates a class definition with an overridden implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method unless we define one ourselves. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method generated for records compares two instances to determine if they have the same state, rather than just comparing two references to determine if they refer to the same instance.</p>
<p class="TX"><span aria-label=" Page 49. " epub:type="pagebreak" id="pg_49" role="doc-pagebreak"/>In a struct, on the other hand, if we don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the equality comparison relies on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class. Records, as reference types, don’t inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>. Record structs do inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, but, as with records, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is overridden by a compiler-generated implementation, because <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> might not be the optimal implementation.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation is necessarily general; it must work for <i>any</i> struct type, regardless of the types of the struct’s fields. If a field of the type has a custom implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, instances of the containing type must use that field’s implementation for comparisons; a simple structural or bitwise comparison of the instances may not always be correct. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> relies on reflection at run time to determine how to compare the fields and will use an overridden implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to compare a field if the type of that field has one.</p>
<p class="TX">If we want to avoid the overhead of reflection in a struct, we must override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with our own implementation to compare each field and property with its corresponding field or property in the instance being compared. If each field and property value compares equal, using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method where required, then the two instances are equal. This is essentially the implementation provided by the compiler for records and record structs.</p>
<p class="TX">To reiterate, structs, records, and record structs all employ a value-based comparison of their state to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, but for records and record structs, the implementation is generated automatically by the compiler, freeing us from the responsibility of providing our own custom implementation.</p>
<p class="TX">The variables we use for records—but not record structs—are references, and when we assign one record reference to another variable, we still get two references to the same record instance, just as we do if the type is a class. Records therefore have reference semantics for copying and value semantics for equality comparison.</p>
<p class="TX">The different comparison and copy semantics for value types and reference types have important consequences for the way instances of those types behave at run time. However, important differences also exist in the way those instances are created in the first place. In the next section, we’ll look at how construction and initialization differ depending on whether the type of the instance is a value type or reference type.</p>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h2 class="H1" id="sec21"><span id="h-43"/><samp class="SANS_Futura_Std_Bold_B_11">Construction and Initialization</samp></h2>
<p class="TNI">Creating a new object is superficially a simple operation, but behind the scenes the compiler goes to a great deal of trouble to make the process as efficient as possible. In principle, creating an object involves allocating the memory for an instance of a type and then calling a constructor whose job is to initialize the instance’s fields. The syntax is identical for both value types and reference types, but <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> treats them differently and hides some complexity around how and where different types are allocated in memory. <span aria-label=" Page 50. " epub:type="pagebreak" id="pg_50" role="doc-pagebreak"/>In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> expression is an abstraction that shields us from the implementation details of how memory is allocated and used.</p>
<p class="TX">Specifically, the memory for reference type instances is allocated dynamically. When a new instance of a class or record type is created, the memory is allocated on the heap at run time. Instances of struct and record struct types are allocated differently, depending on how the resulting instance is used. Consider this code, which initializes a variable with a new instance of a type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>:</p>
<pre><code>var thing = new Thing();</code></pre>
<p class="TX">This basic syntax for creating an object and assigning it to a variable is the same whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class, struct, record, or record struct. As you’ll see over the coming sections, this code depends on <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> having an accessible constructor that can be invoked with no arguments, which isn’t necessarily the case when <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a reference type. For the time being, though, let’s assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> instances can be created this way. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class or a record, <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> causes memory to be allocated on the heap at run time and returns a reference to the new object, which is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> variable.</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or a record struct, the new instance is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp> variable. However, this code may or may not allocate memory for a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> and may or may not call a constructor. The reason is that construction and initialization are separate processes. Part of the difference is related to whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a value type or reference type.</p>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H2" id="sec22"><span id="h-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Default Initialization</samp></h3>
<p class="TNI"><i>Default initialization</i> means that each of a type’s fields, including the backing fields for properties, is given a default value, which is defined in the language to mean one of the following:</p>
<ul class="BL">
<li class="BL">References are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</li>
<li class="BL">Built-in numeric value type variables are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</li>
<li class="BL">All other value types are default-initialized.</li>
</ul>
<p class="TX">Default-initialized reference type fields are a common cause of errors. For example, the simple <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> struct in <a href="#list2-12">Listing 2-12</a> relies on us manually initializing an instance by setting its properties. If we neglect to set suitable values for the properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> instance, we may be rewarded with an exception when we use the instance.</p>
<pre id="list2-12"><code>public struct MusicTrack&#13;
{&#13;
    public string Artist {get; set;}&#13;
    public string Name {get; set;}&#13;
    public override string ToString()&#13;
        =&gt; $"{Artist.ToUpper()}: {Name.ToUpper()}";&#13;
}&#13;
<span aria-label=" Page 51. " epub:type="pagebreak" id="pg_51" role="doc-pagebreak"/>&#13;
var defaultTrack = new MusicTrack();&#13;
var print = defaultTrack.ToString();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Initializing reference type fields</samp></p>
<p class="TX">The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> causes a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference exception because the <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultTrack</samp> value has been default-initialized. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> on its <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> properties, whose default-initialized value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. We need to be alert to any uses of default-initialized references in order to avoid such problems resulting from accessing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference. One way to minimize the impact of default-initialized values is by providing our own instance constructors.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h3 class="H2" id="sec23"><span id="h-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Constructors</samp></h3>
<p class="TNI">An instance constructor, like a method, can have zero or more parameters. Also like methods, constructors can be overloaded, so we can define several constructors for a type, each with a different number of parameters, or parameters of different types. Constructor definitions for classes, structs, records, and record structs have many similarities, but several important differences exist.</p>
<p class="TX">In <a href="#list2-13">Listing 2-13</a>, we add a constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> struct and use the parameter values to initialize the instance’s property values. We use the null-coalescing operator <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp> to assign an empty string for each property if its corresponding parameter is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<pre id="list2-13"><code>public readonly struct MusicTrack&#13;
{&#13;
    public MusicTrack(string artist, string name)&#13;
    =&gt; (Artist, Name) = (artist ?? string.Empty, name ?? string.Empty);&#13;
    public string Artist {get;}&#13;
    public string Name {get;}&#13;
    public override string ToString()&#13;
        =&gt; $"{Artist.ToUpper()}: {Name.ToUpper()}";&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Adding an instance constructor with parameters</samp></p>
<p class="TX">By adding a constructor, we no longer have to rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> users setting the properties explicitly, since the initial values for those properties are set in the constructor. We have made those properties <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only—that is, they can be given a value only in the constructor—and made <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct. However, we must still be cautious of using the property values inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> method because instances of any value type can always be default-initialized, regardless of the presence of a user-defined constructor definition. Adding our own constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> to give meaningful values to the properties isn’t sufficient protection against <span aria-label=" Page 52. " epub:type="pagebreak" id="pg_52" role="doc-pagebreak"/>exceptions that occur from calling methods using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference, because <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a struct type.</p>
<p class="TX">If the nullable reference type feature is enabled (see <span class="Xref">“Nullable Reference Types” on <a href="#sec38">page 64</a></span> for more), the constructor’s parameters will be non-nullable variables, meaning that passing <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> for either argument would cause a compiler warning. Using non-nullable parameters doesn’t mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t be passed as an argument, but we may decide that the warning is sufficient protection, potentially allowing us to omit the null-coalescing assignments in the constructor. The nullable reference type feature doesn’t, however, mean we can avoid verifying that the property values are not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> prior to using them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> method. Fortunately, the null-conditional operator makes the check straightforward and safe:</p>
<pre><code>public override string ToString()&#13;
    =&gt; $"{Artist?.ToUpper()}: {Name?.ToUpper()}";</code></pre>
<p class="TX">Here the presence of the null-conditional operator, a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> appended to each property name, means that in each case the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> method will be called only if the property is a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value. If either property is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, the result of the expression between the braces within the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which the string interpolation treats as an empty string.</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> were a class or record, the presence of our own constructor would mean we could no longer create an instance without passing arguments like this:</p>
<pre><code>var track = new MusicTrack();</code></pre>
<p class="TX">If we attempt to create a default-constructed instance, we get the following compiler error:</p>
<pre><code>[CS7036] There is no argument given that corresponds to the required formal parameter 'artist'&#13;
of 'MusicTrack.MusicTrack(string, string)'</code></pre>
<p class="TX">If we don’t provide any constructors for a class or record, the compiler inserts a default constructor for us. If we define a constructor when we define our own reference type, however, the compiler will not generate the default constructor. The compiler doesn’t create a default constructor for value types, but an instance of a struct or record struct can be default-initialized whether or not we define our own constructor.</p>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Default and Generated Constructors</samp></h4>
<p class="TNI">The behavior of reference types and value types differs partly because reference types are allocated on the heap, but value types might not be. The compiler generates a default constructor for reference types because instances of such types are allocated dynamically, and their instances are initialized at run time. When a reference type instance is allocated on the heap, the memory for it is set to zero, effectively default-initializing the instance.</p>
<p class="TX"><span aria-label=" Page 53. " epub:type="pagebreak" id="pg_53" role="doc-pagebreak"/>Value types are treated differently because their memory isn’t necessarily allocated at run time: for local value type variables, the compiler may <i>reserve</i> memory for the instance data, and the program accesses that memory directly. The underlying Common Intermediate Language (CIL) has an efficient instruction for default-initializing value type instances that effectively zeroes out the memory used by the instance, wherever its memory actually resides.</p>
<p class="TX">We can think of the default initialization of a struct or record struct as being performed by a compiler-provided default constructor, because the result is identical in any case. Default-initializing value types offers a minor performance advantage because it doesn’t require a method call to a constructor, although it’s almost never the most significant optimization.</p>
<p class="TX">In a positional record or a positional record struct, the compiler generates a public constructor based on the parameters we use in the type definition, like this:</p>
<pre><code>public sealed record Color(int Red, int Green, int Blue);</code></pre>
<p class="TX">The parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in this example tell the compiler to create public properties using those names and their types. The compiler also creates a constructor with the same signature as the record’s parameter list, where the properties are assigned their values. The constructor generated by the compiler is the equivalent of this:</p>
<pre><code>public Color(int Red, int Green, int Blue)&#13;
    =&gt; (this.Red, this.Green, this.Blue) = (Red, Green, Blue);</code></pre>
<p class="TX">Although the constructor has been generated by the compiler, it’s still considered a user-defined constructor and therefore still suppresses the default constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record.</p>
<p class="TX">Regardless of its type, an instance is always default-initialized when it’s first created, whether its memory is being allocated on the heap or elsewhere.</p>
<p class="TX">When we define our own constructor for a class, we can rely on all the fields having been default-initialized prior to the constructor’s body; the fields of a class are considered <i>initially assigned</i> within the constructor. In a struct’s constructor, the fields are <i>initially unassigned</i>, so we must definitely assign a value for every field of a struct or record struct, even if it’s simply to replace the value with its default-initialized equivalent.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h4 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Overloaded Constructors</samp></h4>
<p class="TNI">We can provide a constructor with parameters for any type, and we can overload the constructor by defining several constructors that have different numbers or types of parameters. This is useful when we want to support different ways to construct our type. For instance, <a href="#list2-14">Listing 2-14</a> shows a struct that has two constructors with differing signatures.</p>
<pre id="list2-14"><code><span aria-label=" Page 54. " epub:type="pagebreak" id="pg_54" role="doc-pagebreak"/>public readonly struct Color&#13;
{&#13;
    public Color(int red, int green, int blue)&#13;
        =&gt; (Red, Green, Blue) = (red, green, blue);&#13;
    public Color(uint rgb)&#13;
        =&gt; (Red, Green, Blue) = Unpack(rgb);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Overloading constructors</samp></p>
<p class="TX">The first constructor initializes the three properties from three separate parameters (<samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp>). The second constructor receives a numeric representation of an RGB value and initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> properties by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unpack</samp> method (not shown here) to unpack the number into its component parts. We select the different overloads when using the constructor by passing different arguments, as shown in <a href="#list2-15">Listing 2-15</a>.</p>
<pre id="list2-15"><code>var orange = new Color(0xFFA500);&#13;
var yellow = new Color(0xFF, 0xFF, 0);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-15: Selecting the correct overload</samp></p>
<p class="TX">Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> variable is created using the constructor with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp> parameter (the second constructor in <a href="#list2-14">Listing 2-14</a>), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp> variable uses the constructor with three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters (the first constructor in <a href="#list2-14">Listing 2-14</a>).</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterless Constructors</samp></h4>
<p class="TNI">As noted earlier, defining our own constructor for a class type will inhibit the compiler-generated default constructor, meaning that we can create new instances of the type only by passing arguments to our own constructor’s parameters. If we need to create instances of such a reference type without arguments, we can define our own <i>parameterless constructor</i>, which we might use to initialize reference type fields and properties to non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values. This is common when a class contains a collection that needs to be initialized but can be empty, as demonstrated in <a href="#list2-16">Listing 2-16</a>.</p>
<pre id="list2-16"><code>public sealed class Playlist&#13;
{&#13;
    public Playlist(IEnumerable&lt;MusicTrack&gt; items)&#13;
      <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> =&gt; queue = new(items);&#13;
    public Playlist()&#13;
      <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> =&gt; queue = new();&#13;
<span aria-label=" Page 55. " epub:type="pagebreak" id="pg_55" role="doc-pagebreak"/>&#13;
    public void Append(MusicTrack item)&#13;
        =&gt; queue.Add(item);&#13;
<var>--snip--</var>&#13;
    private Queue&lt;MusicTrack&gt; queue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-16: Defining a parameterless constructor</samp></p>
<p class="TX">The two constructors defined here allow us to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> either by passing a sequence of items to populate the queue <span aria-label="annotation1" class="CodeAnnotation">❶</span> or by passing no arguments <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If we pass no arguments, the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> field is initialized as an empty queue, ensuring that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">Both constructors initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> field by using type inference, a feature called <i>target-typed new</i>, introduced in C# v9.0. The compiler deduces the type required by <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> from the type of the target variable being initialized—in this example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue&lt; MusicTrack&gt;</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> field is guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> for any <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> instance, so we don’t need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist.Append</samp> method.</p>
<p class="TX">In a positional record, the compiler creates a constructor based on the positional arguments for the record, so by default, instances of a positional record can’t be created without arguments. We can define our own parameterless constructor for a positional record if we require that behavior. A struct or positional record struct, on the other hand, can <i>always</i> be created without arguments, whether or not we define our own constructors.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h4 class="H3" id="sec27"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Structs and Default Values</samp></h4>
<p class="TNI">As of C# v10.0, we can define our own parameterless constructors for value types to help ensure that any reference fields are non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. However, we still need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> in a value type’s implementation because an instance of a struct or record struct can always be default-initialized, effectively bypassing any constructors we define. This is illustrated in <a href="#list2-17">Listing 2-17</a>, where we add a parameterless constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> struct that explicitly initializes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> properties.</p>
<pre id="list2-17"><code>public readonly struct MusicTrack&#13;
{&#13;
    public MusicTrack()&#13;
        =&gt; (Artist, Name) = (string.Empty, string.Empty);&#13;
    public MusicTrack(string artist, string name)&#13;
        =&gt; (Artist, Name) = (artist, name);&#13;
    public string Artist {get;}&#13;
    public string Name {get;}&#13;
    public override string ToString()&#13;
        =&gt; $"{Artist?.ToUpper()}: {Name?.ToUpper()}";&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-17: Adding a parameterless constructor for a struct</samp></p>
<p class="TX"><span aria-label=" Page 56. " epub:type="pagebreak" id="pg_56" role="doc-pagebreak"/>The parameterless constructor sets both reference type properties to a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, so calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> on either property is safe when we’re using a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> instance that was created using <samp class="SANS_TheSansMonoCd_W5Regular_11">new MusicTrack</samp>. However, this doesn’t mean we can omit the null-conditional checks in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>. It’s still possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> to be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> if the instance is a default-initialized <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>—for example, when it’s an element in an array:</p>
<pre><code>var favorites = new MusicTrack[3];&#13;
var print = favorites[0].ToString();</code></pre>
<p class="TX">Without the checks for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, this code would cause <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> to throw a <samp class="SANS_TheSansMonoCd_W5Regular_11">NullReferenceException</samp> because the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">favorites</samp> array doesn’t call our parameterless constructor on its elements. Each element is default-initialized, leaving the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> properties with their default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, so attempting to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> method on a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference causes the exception.</p>
<p class="TX">Array elements are default-initialized without invoking any parameterless constructor we provide. The parameterless constructor is reserved for when we create a new instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> keyword.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="H3" id="sec28"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Type Initialization</samp></h4>
<p class="TNI">One quite subtle consequence of the way value type instances are allocated in memory is that if a value type’s fields are all public, we can definitely assign a value for each field outside the constructor (as long as they’re not read-only), which results in the whole instance being fully assigned.</p>
<p class="TX">For example, <a href="#list2-18">Listing 2-18</a> assigns a value to each field of an uninitialized struct variable.</p>
<pre id="list2-18"><code>public struct Color&#13;
{&#13;
    public int red;&#13;
    public int green;&#13;
    public int blue;&#13;
}&#13;
Color background;   // initially unassigned variable&#13;
background.red = 0xFF;&#13;
background.green = 0xA5;&#13;
background.blue = 0;&#13;
Assert.That(background.red, Is.EqualTo(0xFF));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-18: Definitely assigning a struct</samp></p>
<p class="TX">This code compiles, and the test passes. We can read the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> field, even though we’ve never allocated the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> or invoked a constructor for it. The same would be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a record struct instead.</p>
<p class="TX"><span aria-label=" Page 57. " epub:type="pagebreak" id="pg_57" role="doc-pagebreak"/>This example demonstrates that value type variables directly contain an instance of their type. Assigning to each field means we don’t need to explicitly construct an instance. However, relying on this behavior is likely to cause other problems, not the least of which is that using public fields leaves the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type open to misuse, intended or not. In practice, a constructor is a much better way to initialize a value type’s fields, which should all be private and read-only.</p>
<p class="TX">Note that if we alter the public fields to be publicly mutable properties, this code will fail to compile. We can’t access a property of a value type in any way until the instance itself has been fully, and definitely, assigned. Every property has a backing field generated by the compiler, and that backing field is always private.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Constructor Accessibility</samp></h4>
<p class="TNI">Constructors with parameters can be made public or private in any type. Private constructors are useful when we want to prevent users from creating instances with certain arguments. We used this technique in <span class="Xref">“<a href="chapter1.xhtml#sec23">Static Creation Methods</a>” in Chapter 1</span> to force users to call the static class factory methods we defined in order to create certain values, rather than using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> keyword directly. In a class or record, we can make the parameterless constructor private to prevent users from creating default-constructed instances, shown for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in <a href="#list2-19">Listing 2-19</a>.</p>
<pre id="list2-19"><code>public sealed record Color&#13;
{&#13;
    private Color() {}&#13;
    public static Color Black {get;} = new Color();&#13;
<var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-19: Making constructors private for reference types</samp></p>
<p class="TX">Since the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is marked <samp class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, we can use it to initialize the static <samp class="SANS_TheSansMonoCd_W5Regular_11">Black</samp> property value and any other static or instance members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but it’s inaccessible to code outside of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type. If users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> forget and attempt to create an instance with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>, the compiler forbids it:</p>
<pre><code>var black = new Color();&#13;
[CS0122] 'Color.Color()' is inaccessible due to its protection level</code></pre>
<p class="TX">Classes and records can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> keyword on a constructor, making it available to inheriting types. Since structs and record structs can’t be inherited, the compiler will prevent the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> in a value type.</p>
<p class="TX">In a struct or record struct, if we define our own parameterless constructor, it <i>must</i> be public. Struct and record struct instances can <i>always</i> be default-initialized, whether or not we provide a parameterless constructor.</p>
</section>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h3 class="H2" id="sec30"><span id="h-46"/><span aria-label=" Page 58. " epub:type="pagebreak" id="pg_58" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Field Initializers</samp></h3>
<p class="TNI">In a class or record definition, and in structs or record structs after C# v10.0, we can assign initial values to fields inline by using <i>field initializers</i>. We can do the same with automatic properties by using <i>property initializers</i>, which initialize the hidden backing field associated with the property. <a href="#list2-20">Listing 2-20</a> uses a field initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> class from <a href="#list2-16">Listing 2-16</a> to assign an initial value and adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property for <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> that we also assign an initial value by using a property initializer.</p>
<pre id="list2-20"><code>public sealed class Playlist&#13;
{&#13;
<var>--snip--</var>&#13;
    public string Name {get; set;} = "_playlist";&#13;
    private Queue&lt;MusicTrack&gt; queue = new();&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-20: Assigning initial values for fields and properties</samp></p>
<p class="TX">Field and property initializers are part of object construction but are not applied when a value type instance is being default-initialized. Conceptually, initializers are applied just before the body of a constructor. As noted previously, the compiler creates a default constructor for class and record types if no user-defined or positional constructors are present; however, the compiler won’t synthesize a parameterless constructor for any value type. Therefore, if we want to use field or property initializers for struct or record struct types, we must also define at least one constructor of our own. This can be a parameterless constructor or a constructor taking one or more parameters.</p>
<p class="TX">Field initializers can’t reference any instance members. However, since static fields are guaranteed to be definitely assigned before any instance fields, a field initializer can reference a static value. Static fields can also have initializers and can reference other static fields. However, we need to take care when referencing one static field from another static field because they’re initialized in the order in which they appear in the class.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="H2" id="sec31"><span id="h-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Initializers</samp></h3>
<p class="TNI">With <i>object initializers</i>, we set values for publicly mutable properties of a variable at the point of creating a new instance, like this:</p>
<pre><code>var fineBrush = new Brush {Width = 2};</code></pre>
<p class="TX">Classes, records, structs, and record structs accept this syntax, and they all behave the same way. The initialization process is the same for each: a constructor is invoked in the usual way to create an instance, and then the value is assigned to the property of the instance. In this example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> is created using a parameterless constructor (or one with <span aria-label=" Page 59. " epub:type="pagebreak" id="pg_59" role="doc-pagebreak"/>all-optional parameters), but we can call any constructor before the initialization expression inside the braces. In the special case of a constructor that requires no arguments, we can leave out the parentheses for the constructor.</p>
<p class="TX">Classes and records require an accessible parameterless constructor to use this syntax. If the parameterless constructor of a class or record is hidden or nonpublic, we <i>must</i> invoke a valid constructor before the object initialization within the braces. We don’t have to worry about this for struct or record struct types because they can always be default-initialized if the type has no parameterless constructor.</p>
<section aria-labelledby="sec32" epub:type="division">
<h4 class="H3" id="sec32"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">init-Only Properties</samp></h4>
<p class="TNI">As of C# v9.0, any property can be <i>init-only</i>, meaning it can be written to only during the creation of a new instance. Prior to C# v9.0, object initialization required properties to have a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, meaning object initialization couldn’t be used with immutable properties. Object initialization requires the value of the property to be set after the constructor has completed, which wasn’t permitted for properties without a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor allows a property to be set during object initialization and then makes the property immutable after the initialization is complete.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in <a href="#list2-21">Listing 2-21</a> demonstrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only properties are used during object initialization.</p>
<pre id="list2-21"><code>public readonly struct Color&#13;
{&#13;
    public int Red {get; init;}&#13;
    public int Green {get; init;}&#13;
    public int Blue {get; init;}&#13;
}&#13;
var orange = new Color {Red = 0xFF, Green = 0xA5};&#13;
Assert.That(orange.Red, Is.EqualTo(0xFF));&#13;
Assert.That(orange.Green, Is.EqualTo(0xA5));&#13;
Assert.That(orange.Blue, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-21: Setting properties as init-only</samp></p>
<p class="TX">When we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> variable, a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is first default-constructed, giving each property its default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The object initializer between the braces gives new values to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp> properties, leaving the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property with its default value. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, which requires that the struct has no mutable properties.</p>
<p class="TX">We can assign a value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only property in an instance constructor or by using object initialization, but we can’t assign a new value after the instance has been created. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only property is immutable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor syntax can be used for properties and indexers for any type, although it was introduced in C# v9.0 to support a special initialization syntax supported by records and known as <i>non-destructive mutation</i>.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h4 class="H3" id="sec33"><span aria-label=" Page 60. " epub:type="pagebreak" id="pg_60" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Non-destructive Mutation</samp></h4>
<p class="TNI">Records and record structs support the non-destructive mutation syntax, and as of C# v10.0, so do structs and anonymous types. Syntactically, non-destructive mutation is similar to object initialization, except that it initializes a new instance by copying an existing one and providing new values for selected properties in that copy. <a href="#list2-22">Listing 2-22</a> demonstrates this syntax, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword to copy the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> record variable to a new variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp>, and then assigning a new value to one of the properties of the copy.</p>
<pre id="list2-22"><code>public sealed record Color(int Red, int Green, int Blue);&#13;
var orange = new Color(0xFF, 0xA5, 0);&#13;
var yellow = orange with {Green = 0xFF};&#13;
Assert.That(yellow.Red, Is.EqualTo(0xFF));&#13;
Assert.That(yellow.Green, Is.EqualTo(0xFF));&#13;
Assert.That(orange.Green, Is.EqualTo(0xA5)); // unchanged in orange&#13;
Assert.That(orange.Blue, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-22: Initializing a copy of a record with non-destructive mutation</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> expression we use when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp> variable creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record with property values identical to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> instance. Those properties specified between the braces following <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> are then assigned the values by using the same syntax as object initialization. This approach is called <i>non-destructive</i> mutation because no changes are made to the original record.</p>
<p class="TX">Constructors and initializers are both ways we can create new instances with known values. However, sometimes we can’t provide an initial value for a variable, but leaving it uninitialized is too restrictive: we can’t even test it to see whether it has a value, owing to the rules governing definite assignment. In the next section, we’ll examine the options open to us when we need a variable with no value, and how value types and reference types differ here too.</p>
</section>
</section>
</section>
<section aria-labelledby="sec34" epub:type="division">
<h2 class="H1" id="sec34"><span id="h-48"/><samp class="SANS_Futura_Std_Bold_B_11">null Values and Default Values</samp></h2>
<p class="TNI">A plain value type variable can never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. An instance of a value type directly contains all of its fields, and there’s not necessarily a representation of “no value.” A default-initialized instance of a value type is not the same thing—it’s a complete instance of the type, just with the default-initialized values for each of its fields.</p>
<p class="TX">We can employ a nullable value type, which can be assigned and compared with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, as you’ll see shortly, but plain value type instances are incompatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant expression is a reference and therefore can be assigned only to reference variables. One of the <span aria-label=" Page 61. " epub:type="pagebreak" id="pg_61" role="doc-pagebreak"/>implications of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a value type variable is that we can’t pass <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> as an argument to a value type method parameter.</p>
<p class="TX">Similarly, attempting to <i>compare</i> a value with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> makes no sense. If we do, as shown in <a href="#list2-23">Listing 2-23</a>, the compiler rejects the code.</p>
<pre id="list2-23"><code>public readonly struct Speed&#13;
{&#13;
<var>--snip--</var>&#13;
}&#13;
var c = new Speed();&#13;
Assert.That(c == null, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-23: Comparing a value type variable with null</samp></p>
<p class="TX">The error from the compiler is shown here:</p>
<pre><code>[CS0019] Operator '==' cannot be applied to operands of type 'Speed' and '&lt;null&gt;'</code></pre>
<p class="TX">We can, however, compare any reference type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and, as of C# v8.0, we can use a constant pattern to make this comparison more direct by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> keyword:</p>
<pre><code>Assert.That(someObject is null, Is.True);</code></pre>
<p class="TX">Comparing any value type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> makes no sense, whatever method we choose, because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is a reference and as such is represented differently than a value type. That said, the rule against comparing value types with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> has one exception: generic types.</p>
<section aria-labelledby="sec35" epub:type="division">
<h3 class="H2" id="sec35"><span id="h-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and null</samp></h3>
<p class="TNI">In a generic class or method, an unconstrained type parameter variable can be compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. An unconstrained generic type can be either a value type or a reference type. To illustrate, the simple example in <a href="#list2-24">Listing 2-24</a> compares an instance of a generic parameter type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<pre id="list2-24"><code>public static int Compare&lt;T&gt;(T left, T right)&#13;
{&#13;
    if(left is null) return right is null ? 0 : -1;&#13;
<var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-24: Comparing a generic type parameter instance with null</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare</samp> generic method has a type parameter named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> that might represent either a value type or a reference type, because it has no type constraints. In this instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is not known to be a value type, so the compiler allows the syntax. If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s type is determined at run time to be a value type, the whole expression simply evaluates as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</p>
<p class="TX"><span aria-label=" Page 62. " epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/>The compiler still prevents us from assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, because if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> were a value type, the assignment would fail at run time. Similarly, we can’t return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> through an unconstrained type parameter, demonstrated in <a href="#list2-25">Listing 2-25</a>.</p>
<pre id="list2-25"><code>public static T Consume&lt;T&gt;(IProducerConsumerCollection&lt;T&gt; collection)&#13;
    =&gt; collection.TryTake(out var item) ? item : null;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-25: Trying to return null as a generic parameter type</samp></p>
<p class="TX">This gives the following error:</p>
<pre><code>[CS0403] Cannot convert null to type parameter 'T' because it could be a non-nullable value&#13;
type. Consider using 'default(T)' instead.</code></pre>
<p class="TX">In this example, the difficulty arises because <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is unconstrained. It might represent a struct or record struct type, for which <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is not a valid value. The error message gives us a clue that instead of returning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we can return a <i>default</i> value for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. Default values have other, more significant use cases too, but also some limitations.</p>
</section>
<section aria-labelledby="sec36" epub:type="division">
<h3 class="H2" id="sec36"><span id="h-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and Default Values</samp></h3>
<p class="TNI">The concept of a default value is closely related to a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, especially in the context of generic types and methods. At times, we—and the compiler—must ensure that an instance of a generic parameter type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is definitely assigned, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s type is not known at compile time. We can’t just use <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> to make a new instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> because the compiler isn’t able to determine which constructors are available for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value type, we can <i>always</i> make a default instance by using default initialization or by calling a parameterless constructor, but if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a reference type, it might not have an accessible default or parameterless constructor. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> constraint on <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, meaning that our generic type or method will work only with types that have an accessible parameterless constructor, but this might be too restrictive.</p>
<p class="TX">In a generic type, we can use the generic parameter to denote a field or property of the generic parameter type. Generic value types must ensure that <i>all</i> their fields are definitely assigned before control leaves the constructor. To make that possible, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword to initialize a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, as in the generic struct shown in <a href="#list2-26">Listing 2-26</a>.</p>
<pre id="list2-26"><code>public readonly struct Node&lt;T&gt;&#13;
{&#13;
    public Node(int index)&#13;
    {&#13;
        idx = index;&#13;
        contained = default;&#13;
    }&#13;
<span aria-label=" Page 63. " epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/>&#13;
    private readonly int idx;&#13;
    private readonly T contained;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-26: Initializing a default instance of a type parameter</samp></p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> constructor, the <samp class="SANS_TheSansMonoCd_W5Regular_11">contained</samp> field is assigned the default value of its type by using the target-typed default literal (available since C# v7.1), which is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">default(T)</samp>. Where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a class or record, its default value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a struct or record struct, the default value is a default-initialized instance. Note that initializing a value by using <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> does not invoke a parameterless constructor, if we have defined one. This code is valid because we can always create a default <i>value</i> for a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>: if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value type, the value is a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a reference type, a default <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword has many uses outside of generic types and methods, but within generic code it’s indispensable.</p>
<p class="TX">Default values are useful, but they’re not sufficient to identify a particular value type instance as invalid. In other words, we can’t use a default when what we really mean is <i>no value present</i>. The default value of a struct or record struct is a default-initialized instance and might therefore be a <i>valid</i> value. Consider <a href="#list2-27">Listing 2-27</a>.</p>
<pre id="list2-27"><code>int x = default;&#13;
int y = 0;&#13;
Assert.That(x.Equals(y), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-27: Default values can be valid.</samp></p>
<p class="TX">The default value for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which we may use to indicate an invalid number in some circumstances but not all. Whether that matters, especially for our own value types, depends on the context in which instances of the type are used, but limiting valid integers to only nonzero values would be very restrictive. Fortunately, we have an alternative.</p>
</section>
<section aria-labelledby="sec37" epub:type="division">
<h3 class="H2" id="sec37"><span id="h-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Value Types</samp></h3>
<p class="TNI"><i>Nullable value types</i> allow us to have a representation of a value type that means <i>no value present</i>. A nullable value type is a wrapper around a value type, and a nullable value type variable may or may not have a value. A nullable value type variable can also be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, demonstrated by using a simple test in <a href="#list2-28">Listing 2-28</a>.</p>
<pre id="list2-28"><code>int? x = null;&#13;
int y = 0;&#13;
Assert.That(x.Equals(y), Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-28: Using nullable values</samp></p>
<p class="TX"><span aria-label=" Page 64. " epub:type="pagebreak" id="pg_64" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> following the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable is shorthand for saying that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; int&gt;</samp>. We can now represent an invalid value for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> that’s distinct from any valid values for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. We can use a nullable variable for any value type, not just built-ins. The default value for a nullable is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, as shown here:</p>
<pre><code>int? x = default;&#13;
int? y = null;&#13;
Assert.That(x.Equals(y), Is.True);</code></pre>
<p class="TX">This test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the first line doesn’t initialize a default <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> but rather a default <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; int&gt;</samp>. Equality comparison between nullable values compares the underlying value if there is one. Two nullable values are equal if they both have no value, or values that themselves compare equal. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> is a struct and overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to provide this behavior.</p>
<p class="TX">As a consequence of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a plain value type variable, we can’t use a plain value type on the right-hand side of an <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> expression, like this:</p>
<pre><code>object speed = new Speed();&#13;
var actual = speed as Speed;</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is a struct or record struct, this code won’t compile, because if the cast fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> operator will return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. As we know, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t be assigned to a value. The solution is to use a nullable value type as the source of the conversion, as shown here:</p>
<pre><code>var actual = speed as Speed?;</code></pre>
<p class="TX">The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">actual</samp> variable is a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in this example and will have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> if the conversion fails—that is, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable is not in fact a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type.</p>
</section>
<section aria-labelledby="sec38" epub:type="division">
<h3 class="H2" id="sec38"><span id="h-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Reference Types</samp></h3>
<p class="TNI">C# v8.0 introduced <i>nullable reference types</i>, a feature that allows the compiler to warn us when a reference is or might be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and we expect it to have a real value. While reference variables have always been able to have a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, the nullable reference type feature allows us to express whether we <i>intend</i> for them to. In other words, when we use a nullable reference type variable, we’re being explicit about our intention that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is an <i>expected</i> potential value for a variable.</p>
<p class="TX">Reference variables are non-nullable by default. In the declaration in <a href="#list2-29">Listing 2-29</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp> variable is a <i>non-nullable</i> reference.</p>
<pre id="list2-29"><code>object brush = null;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-29: Declaring a non-nullable reference variable</samp></p>
<p class="TX"><span aria-label=" Page 65. " epub:type="pagebreak" id="pg_65" role="doc-pagebreak"/>The compiler performs static analysis that enables it to issue a warning if a non-nullable reference can’t be guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. To state that with fewer negatives, the compiler issues a warning if a value that may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is assigned to a non-nullable reference. In particular, assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a non-nullable reference, as we just did, provokes this warning:</p>
<pre><code>[CS8600] Converting null literal or possible null value to non-nullable type</code></pre>
<p class="TX">If we attempt to pass a possibly <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value as an argument to a non-nullable method parameter, we’ll get a warning from the compiler. Consider the method in <a href="#list2-30">Listing 2-30</a>, which capitalizes the first character of each word in a string.</p>
<pre id="list2-30"><code>public static string ToTitleCase(string original)&#13;
{&#13;
    var txtInfo = Thread.CurrentThread.CurrentCulture.TextInfo;&#13;
    return txtInfo.ToTitleCase(original.Trim());&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-30: Defining the ToTitleCase method with a non-nullable reference parameter</samp></p>
<p class="TX">Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp> method, we should be able to depend on the <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> parameter having a real, non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, because it’s a non-nullable string. That means we can avoid explicitly writing code to check that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, if the compiler can’t guarantee that the argument we pass isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, it will give us a warning.</p>
<p class="TX">We might have a legitimate need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference, however, in which case we mark the type of a variable as nullable to suppress the compiler warnings about possible null assignment. The syntax is the same as for nullable value types: we append a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> to the type. <a href="#list2-31">Listing 2-31</a> shows a collection of nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> elements designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">string?</samp> type name.</p>
<pre id="list2-31"><code>var names = new List&lt;string?&gt;();&#13;
// Load names from somewhere, may contain null elements&#13;
--<var>snip--</var>&#13;
var properNames = names.Select(name =&gt; ToTitleCase(name));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-31: Passing a possibly null argument for a non-nullable parameter</samp></p>
<p class="TX">If we apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp> method from <a href="#list2-30">Listing 2-30</a> to this collection, we get a similar compiler warning as with <a href="#list2-29">Listing 2-29</a>, where we explicitly assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a non-nullable reference type variable:</p>
<pre><code>[CS8604] Possible null reference argument for parameter 'original' in 'string&#13;
ToTitleCase(string original)'.</code></pre>
<p class="TX">We’re given this warning because the compiler can’t guarantee that the collection contains no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements. The compiler assumes any of the elements may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> because the element type of the collection is a nullable reference.</p>
<p class="TX"><span aria-label=" Page 66. " epub:type="pagebreak" id="pg_66" role="doc-pagebreak"/>If we explicitly check each element before making the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, the compiler can determine that we’re not using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference as an argument to the method. To achieve that, we could unpack the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> expression into a loop, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop in <a href="#list2-32">Listing 2-32</a>.</p>
<pre id="list2-32"><code>foreach (var name in names)&#13;
{&#13;
    if(name is not null)&#13;
        properNames.Add(ToTitleCase(name));&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-32: Explicitly using a non-null reference</samp></p>
<p class="TX">This code doesn’t prompt a warning about the argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp> because the compiler can perform enough analysis on the code preceding the method call to guarantee that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> argument isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">However, sometimes the compiler needs our help to determine whether it’s safe to assign a variable to a non-nullable reference or to call a method with a non-nullable parameter. <a href="#list2-33">Listing 2-33</a> shows a slightly modified version of <a href="#list2-31">Listing 2-31</a> calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, where any <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements are filtered out before the method is called.</p>
<pre id="list2-33"><code>var properNames = names&#13;
    .Where(name =&gt; name is not null)&#13;
    .Select(name =&gt; ToTitleCase(name));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-33: Removing null elements before the method call</samp></p>
<p class="TX">This code gives us the same warning as in <a href="#list2-31">Listing 2-31</a>, however, because the compiler can’t be certain <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp> won’t be invoked with a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> argument. Although it looks as if the check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is being made inline, in fact we’re calling a lambda function to make that comparison, and the compiler doesn’t attempt to analyze every possible code path to make this safe. Fortunately, we have a workaround.</p>
</section>
<section aria-labelledby="sec39" epub:type="division">
<h3 class="H2" id="sec39"><span id="h-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Null-Forgiving Operator</samp></h3>
<p class="TNI">We can use the <i>null-forgiving operator</i> to inform the compiler that we definitely know what we’re doing and that no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> references are used as arguments to a non-nullable parameter. The null-forgiving operator is an <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> appended to the variable, which is why it’s also referred to as the <i>dammit operator,</i> as in, “It’s definitely not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, dammit!” When we’ve filtered out all the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements from our collection, we apply the dammit operator to the argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, as shown in <a href="#list2-34">Listing 2-34</a>.</p>
<pre id="list2-34"><code>var properNames = names&#13;
    .Where(name =&gt; name is not null)&#13;
    .Select(name =&gt; ToTitleCase(name!));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-34: Using the null-forgiving operator</samp></p>
<p class="TX"><span aria-label=" Page 67. " epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/>Using the null-forgiving operator with the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp> convinces the compiler that it is safe to call the method having a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference type parameter. If we were to inadvertently pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference, we’d (justifiably) get the dreaded <samp class="SANS_TheSansMonoCd_W5Regular_11">Object reference not set to an instance of an object</samp> exception. We must take care when using the null-forgiving operator that we really do know that the variable can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">Nullable reference types, while having the same syntax as nullable value types, are just a device that indicates to the compiler that we’re making certain assumptions about the variable. Unlike nullable value types, which are underpinned by a distinct type with behavior injected by the compiler, nullable reference types are a purely compile-time mechanism, used for static analysis, and do not change the behavior of our code in any way. At run time, nullable and non-nullable references are just references. Nevertheless, distinguishing between them in code is useful for encoding our assumptions about nullability.</p>
<p class="TX">Unexpected <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference exceptions are the curse of many programs and a class of error that programmers everywhere go to great lengths to try to avoid. The nullable reference type feature of modern C# is one that shifts some of that responsibility away from the programmer and onto the compiler.</p>
</section>
</section>
<section aria-labelledby="sec40" epub:type="division">
<h2 class="H1" id="sec40"><span id="h-54"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</i></p>
<footer class="EPS">—Tony (C.A.R.) Hoare</footer></blockquote>
<p class="BodyContinued">The type system in C# is broadly similar to many other programming languages, including its support for user-defined types. C# differs in its distinction between reference types and value types. Although there are various recommendations on when to choose to define a value type instead of a reference type, including documentation from Microsoft, those guidelines often take only part of the story into consideration.</p>
<p class="TX">The technical purpose of distinguishing value types from reference types is to allow the compiler and Common Language Runtime to make assumptions about values that may allow certain opportunities for optimization. Some of the differences we’ve discussed result from the way reference and value type instances are stored and managed in memory. That value type variables are not independently subject to garbage collection can itself be a big win. However, we can’t just turn our classes into structs or record structs and expect that our programs will suddenly use less memory or run more quickly. Value semantics involves much more than just declaring something as a value type.</p>
<p class="TX"><span aria-label=" Page 68. " epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/>Likewise, the copy-by-value behavior of value types is more than just a side effect of the way values use memory. Copying by value gives rise to many of the constraints that are imposed on value types and for which reference types have no need. Using value types where they’re appropriate can make our code clearer and simpler in subtle ways, like not having to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values on every use of a value. The characteristics of copying values also affect the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method; although comparing variables to see if they are equal may sound inconsequential, it’s an essential aspect of working with variables.</p>
<p class="TX">The distinction between value types and reference types, then, is not just a list of <i>restrictions</i>. Genuine semantic differences affect our programs’ behavior and can bring tangible benefits. One advantage of value types is that they can never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. Constantly having to check references to ensure that they’re valid can be tiresome and error-prone. Using the non-nullable reference type feature is one way we reduce the occurrence of unexpected errors arising from dereferencing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference.</p>
<p class="TX">One of the great strengths of C# being a compiled and type-safe language is that the compiler can identify many kinds of errors <i>before</i> our program is ever run.</p>
</section>
</section>
</div></body></html>