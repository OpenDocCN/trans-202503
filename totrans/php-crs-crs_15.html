<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch12" epub:type="chapter" role="doc-chapter">
<span aria-label="225" epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch12">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">12</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">VALIDATING FORM DATA</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">Not all data received through web forms will be valid; users may make mistakes or miss required values, or a number of other things could go wrong. In this chapter, we’ll explore ways to validate the received data, and we’ll design some typical decision logic to take appropriate action depending on the values received (and any that are missing).</p>
<p class="TX">It’s important to recognize that HTML forms submit values only as text strings, regardless of the input type. One of the very reasons PHP isn’t type-sensitive is to make it easy to treat a string containing digits as a number without explicitly type-casting or including data-type conversion statements. This makes it that much more important to carefully write (and test) the validation rules for processing received form data.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="226" epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/>
<h3 class="H1" id="sec1"><span id="toc-link_170"/><span class="SANS_Futura_Std_Bold_B_11">Writing Custom Validation Logic</span></h3>
<p class="TNI1">In <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, you learned to use simple built-in filters such as <span class="SANS_TheSansMonoCd_W5Regular_11">FILTER _SANITIZE_SPECIAL_CHARS</span> in conjunction with <span class="SANS_TheSansMonoCd_W5Regular_11">filter_input()</span> to sanitize incoming form data. However, real-world data often has its own special validation criteria that goes beyond these built-in filters. Once you’ve retrieved data from the submitted form request, you may therefore need to write custom validation logic to make sure the data is as it should be.</p>
<p class="TX">Let’s illustrate how this works with a simple example: a product details form asking the user to enter a product code and a price (see <a href="#fig12-1">Figure 12-1</a>). We’ll assume that the product code must have a minimum of three characters and that the price must be a number (either an integer or a decimal value).</p>
<figure class="IMG"><a id="fig12-1"/><img alt="" class="img50" height="283" src="../images/figure12-1.jpg" width="753"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-1: A product details form in need of validation logic</span></p></figcaption>
</figure>
<p class="TX">As we explored in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, we can write a simple script confirming receipt of the form data with a few lines of PHP. <a href="#lis12-1">Listing 12-1</a> shows how.</p>
<span id="lis12-1"/>
<pre><code>&lt;?php&#13;
$productCode = filter_input(INPUT_GET, 'productCode');&#13;
$price = filter_input(INPUT_GET, 'price');&#13;
?&gt;&#13;
&lt;h1&gt;Data received:&lt;/h1&gt;&#13;
&lt;p&gt;Product Code: &lt;?= $productCode ?&gt;&lt;/p&gt;&#13;
&lt;p&gt;Price: &lt;?= $price ?&gt;&lt;/p&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-1: Confirming the received product code and price</span></p>
<p class="TX">Here we use the <span class="SANS_TheSansMonoCd_W5Regular_11">filter_input()</span> function to extract the <span class="SANS_TheSansMonoCd_W5Regular_11">productCode</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> variables from the received URL-encoded form data and display them back to the user by using PHP short echo tags. This will work if the user has submitted values as expected, but it’s never a good idea to assume the data that has arrived from the user is all present and correct.</p>
<p class="TX">We should expand the script to validate the data before confirming it to the user. We’ll try to validate the price and product code data in the following ways:</p>
<ul class="ul">
<li class="ListBullet">If the product code is missing or empty, display the error message <span class="SANS_TheSansMonoCd_W5Regular_11">missing product code</span>.</li>
<li class="ListBullet">If the product code is less than three characters in length, display the error message <span class="SANS_TheSansMonoCd_W5Regular_11">product code too few characters</span>.</li>
<li class="ListBullet"><span aria-label="227" epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>If the price isn’t a numeric value, display the error message <span class="SANS_TheSansMonoCd_W5Regular_11">price was not a number</span>.</li>
<li class="ListBullet">If no validation errors occur, display the message <span class="SANS_TheSansMonoCd_W5Regular_11">input data was error free</span>.</li>
</ul>
<p class="BodyContinued">As you’ll see, PHP has built-in functions to help with these sorts of validation checks.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_171"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Managing Multiple Validation Errors</span></h4>
<p class="TNI1">One common approach to managing custom validation logic with multiple potential errors is to use an array for the errors. Start with an empty array, then use a series of <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span> statements to add an error message to the array each time a new validation error is detected. If the array is empty after all the validation, it means the data was found to be error free. If it isn’t empty, you can loop through the array to display all the error messages to the user. <a href="#lis12-2">Listing 12-2</a> uses this approach to implement the validation logic for our product details form.</p>
<span id="lis12-2"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$productCode = filter_input(INPUT_GET, 'productCode');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$price = filter_input(INPUT_GET, 'price');</span>&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $errors = [];&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> if (empty($productCode)) {&#13;
    $errors[] = 'missing product code';&#13;
} elseif (strlen($productCode) &lt; 3) {&#13;
    $errors[] = 'product code too few characters';&#13;
}&#13;
&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> if (!is_numeric($price)) {&#13;
    $errors[] = 'price was not a number';&#13;
}&#13;
&#13;
<span aria-label="annotation4" class="codeannotated_CodeAnnotation">❹</span> if (sizeof($errors) &gt; 0) {&#13;
    // errors&#13;
    print 'Data validation errors:&lt;ul&gt;';&#13;
    foreach ($errors as $error) {&#13;
        print "&lt;li&gt; $error &lt;/li&gt;";&#13;
    }&#13;
    print "&lt;/ul&gt;";&#13;
} else {&#13;
    print 'input data was error free';&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-2: Implementing custom validation logic with an array of error messages</span></p>
<p class="TX">After extracting the product code and price from the incoming form data as before, we create an empty array in the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we use an <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif</span> structure <span aria-label="annotation2" class="CodeAnnotation">❷</span> to validate the <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> variable. The <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> branch adds the message <span class="SANS_TheSansMonoCd_W5Regular_11">'missing product code'</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> array if <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> is empty. (The <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function will return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> <span aria-label="228" epub:type="pagebreak" id="pg_228" role="doc-pagebreak"/>wasn’t found in the received form data or if it contained an empty string.) The <span class="SANS_TheSansMonoCd_W5Regular_11">elseif</span> branch, which is visited only if <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> isn’t empty, adds the message <span class="SANS_TheSansMonoCd_W5Regular_11">'product code too few characters'</span> to the array if the <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function finds the product code to contain fewer than three characters.</p>
<p class="TX">Next, we use a separate <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement to validate the <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> variable <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We pass the variable to <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span>, which returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> if the received string can be interpreted as an integer or a float. If not, we add the message <span class="SANS_TheSansMonoCd_W5Regular_11">'price was not a number'</span> to the array.</p>
<p class="TX">Finally, we test whether the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> array contains any errors <span aria-label="annotation4" class="CodeAnnotation">❹</span>. If it does, we use a <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop to display each error to the user as an item in an HTML ordered list. Otherwise, if the array is empty, we display the message <span class="SANS_TheSansMonoCd_W5Regular_11">'input data was error free'</span>.</p>
<p class="TX">This example has illustrated a range of typical validations. You’ll often find yourself checking for the following:</p>
<p class="RunInParaF"><b>Any required data that’s missing</b>   You can test for this with the <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function.</p>
<p class="RunInPara"><b>Too few characters for text data</b>   You might need to ensure that the input meets minimum-length rules for usernames or passwords, for example. You can test for this with the <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function.</p>
<p class="RunInParaL"><b>Non-numeric values</b>   You might want to know if the value received is neither a valid integer nor a decimal number. You can test for this with the <span class="SANS_TheSansMonoCd_W5Regular_11">is_numeric()</span> function.</p>
<p class="TX">While we were able to rely on built-in PHP functions for our validation checks, we needed custom logic to string them together and match them to the particular requirements of our product details form.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_172"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Testing for a Valid Zero Value</span></h4>
<p class="TNI1">Because of PHP’s type insensitivity, it’s easy to write code that incorrectly treats a numeric value of 0 as missing or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>. This happens because in PHP all the following (among other values) are considered <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>:</p>
<ul class="ul">
<li class="ListBullet">The Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> itself</li>
<li class="ListBullet">The integers <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-0</span></li>
<li class="ListBullet">The floats <span class="SANS_TheSansMonoCd_W5Regular_11">0.0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-0.0</span></li>
<li class="ListBullet">The empty string and the string <span class="SANS_TheSansMonoCd_W5Regular_11">"0"</span></li>
<li class="ListBullet">The special <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> type (including unset variables)</li>
</ul>
<p class="TX">To illustrate the problem, say you want to test whether the user left a form field blank. You’d typically use the <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function, but if the user happened to enter the digit <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> in the form field, the test <span class="SANS_TheSansMonoCd_W5Regular_11">empty('0')</span> will return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, just like the test <span class="SANS_TheSansMonoCd_W5Regular_11">empty('')</span> for a truly empty form field (remember that all form values arrive as strings in the HTTP request, even if they are numeric characters). If you want the 0 to be a valid entry for the field (for example, if the field is to record someone’s score on a test), you’ll need to write code that distinguishes between a valid 0 entry and an <span aria-label="229" epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>unacceptable empty string. The solution is to use the triple-equal-sign identical operator (<span class="SANS_TheSansMonoCd_W5Regular_11">===</span>), which tests whether its operands have the same value <i>and</i> data type, as discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>The PHP documentation describes type comparisons at</i> <span class="note_LinkURL"><a href="https://www.php.net/manual/en/types.comparisons.php">https://www.php.net/manual/en/types.comparisons.php</a></span><i>, comparing the results of the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">==</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">===</span> <i>operators, as well as showing the results for functions such as</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">gettype()</span><i>,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">empty()</span><i>, and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">isset()</span> <i>for potentially confusing values. I recommend you bookmark this page for reference.</i></p>
<p class="TX">Listing 12-3 assumes a form has been submitted with the <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> method sending a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">score</span>. The code uses an <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif</span> statement to differentiate between no value and a <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> value.</p>
<span id="lis12-3"/>
<pre><code>$score = filter_input(INPUT_GET, 'score');&#13;
if ($score === '0') {&#13;
    print "score was the string '0'";&#13;
} elseif (empty($score)) {&#13;
    print 'score was empty (but not zero)';&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-3: Distinguishing between the number</span> <span class="TheSansMonoCd_W5Regular_Italic_11">0</span> <span class="SANS_Futura_Std_Book_Oblique_11">and an empty or</span> <span class="TheSansMonoCd_W5Regular_Italic_11">NULL</span> <span class="SANS_Futura_Std_Book_Oblique_11">value</span></p>
<p class="BodyContinued">We first use the <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> operator to test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$score</span> holds the exact string <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span>. If not, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function to check whether an empty string was received.</p>
<p class="TX">If testing for a valid 0 is a task you’ll need to perform often, it would be useful to encapsulate the necessary logic in a function that returns <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> when given the string <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span> or the result of the <span class="SANS_TheSansMonoCd_W5Regular_11">empty()</span> function otherwise, as shown in <a href="#lis12-4">Listing 12-4</a>. Create a <i>zeroFunction.php</i> file containing this code, since we’ll make use of it later in this chapter.</p>
<span id="lis12-4"/>
<pre><code>&lt;?php&#13;
function isAnEmptyNonZeroString($s): bool&#13;
{&#13;
    if ($s === '0') return false;&#13;
    return empty($s);&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-4: A function that tests for an empty string but does not consider the digit 0 as empty</span></p>
<p class="TX">Keep in mind that if a numeric value of 0 is an acceptable form input, you may need to do more than simply compare the incoming string with the string literal <span class="SANS_TheSansMonoCd_W5Regular_11">'0'</span>. This is because other strings may also evaluate to 0, such as <span class="SANS_TheSansMonoCd_W5Regular_11">'0.0'</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">'0.00'</span>, and so on. To be thorough, you need to test the underlying numeric value that the incoming string represents. Fortunately, PHP provides the <span class="SANS_TheSansMonoCd_W5Regular_11">intval()</span> function, which can take in a string and return the numeric integer value of its contents. Normal PHP type juggling will take place, and so any valid numeric characters at the beginning of the string will be used <span aria-label="230" epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/>to determine the string’s integer value. As discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, any non-numeric content in a string is ignored during type juggling.</p>
<p class="TX"><a href="#tab12-1">Table 12-1</a> lists examples of strings and their <span class="SANS_TheSansMonoCd_W5Regular_11">intval()</span> evaluations. Notice that the non-numeric remainders of strings are simply ignored (such as <span class="SANS_TheSansMonoCd_W5Regular_11">'5abc'</span> evaluating to <span class="SANS_TheSansMonoCd_W5Regular_11">5</span>), as are any decimal components of numeric strings.</p>
<p class="TT"><a id="tab12-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-1:</span></span> <span class="SANS_Futura_Std_Book_11">Example</span> <span class="SANS_TheSansMonoCd_W5Regular_11">intval()</span> <span class="SANS_Futura_Std_Book_11">Calls</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Function call</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Return value</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('0')</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">0</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('00')</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">0</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('0.00')</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">0</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('0.99')</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span class="SANS_Futura_Std_Book_11">(decimal component ignored)</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('0005')</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">5</span> <span class="SANS_Futura_Std_Book_11">(leading zeros ignored)</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">intval('5abc')</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">5</span> <span class="SANS_Futura_Std_Book_11">(everything from</span> <span class="SANS_TheSansMonoCd_W5Regular_11">'a'</span> <span class="SANS_Futura_Std_Book_11">on ignored)</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">At the end of the day, validation should match whatever data the form owner specifies is acceptable. It is, of course, always a good idea to offer the user a confirmation screen with a chance to correct values after any validation and string-to-number evaluation, to make sure the form’s validation logic matches the user’s intent.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="toc-link_173"/><span class="SANS_Futura_Std_Bold_B_11">Displaying and Validating Forms in a Single Postback Script</span></h3>
<p class="TNI1">A frequently used strategy for validating web forms is to use a single script, known as a <i>postback</i>, both to display the form and to perform validation. Combining these two actions ensures that the form can be redisplayed to the user in the event of any validation errors, with the added validation error messages included. A postback also makes it easy to implement a <i>sticky form</i>, a form that’s redisplayed with the previously submitted values prepopulated in the appropriate fields, saving the user from having to enter the data again. (The term <i>sticky</i> refers to the values remaining, or sticking, in the form after submission.)</p>
<p class="TX">Using a single script to both display and validate has two drawbacks. First, the script can get very long, especially for complex forms with lots of validation logic. Second, the complexity of a script performing multiple tasks is high, making the code potentially harder to understand, more error-prone, and harder to update or maintain at a later date. In <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, we’ll address these disadvantages as we look at strategies to separate logic from display code.</p>
<p class="TX">For now, though, we’ll focus on creating single scripts for sticky postback forms. We’ll start with a form that requires only simple validation logic, and then we’ll revisit the array-based approach to handling multiple validation errors discussed earlier in the chapter.</p>
<section aria-labelledby="sec5" epub:type="division">
<span aria-label="231" epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/>
<h4 class="H2" id="sec5"><span id="toc-link_174"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Simple Validation Logic</span></h4>
<p class="TNI1">Let’s create a simple postback script for a sticky form where the user enters their name and receives a <i>Hello &lt;name&gt;</i> greeting in response. We’ll arbitrarily say that the submitted name must have at least three characters to be valid. Our postback script needs to handle three possible situations that can occur after the server receives a new HTTP request. The first situation is the initial form request (via the <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> HTTP method), when an empty text box and Submit button are presented to the user, as in <a href="#fig12-2">Figure 12-2</a>.</p>
<figure class="IMG"><a id="fig12-2"/><img alt="" class="img70" height="369" src="../images/figure12-2.jpg" width="972"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-2: The first presentation of the sticky postback form</span></p></figcaption>
</figure>
<p class="TX">The second situation is a form submission with invalid data (via the <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> HTTP method). In this case, the form should be redisplayed to the user with an error message about the invalid submission. Since the form is sticky, the text box should be populated with whatever text the user submitted last, as shown in <a href="#fig12-3">Figure 12-3</a>. In this example, a single letter <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> was submitted.</p>
<figure class="IMG"><a id="fig12-3"/><img alt="" class="img100" height="319" src="../images/figure12-3.jpg" width="1292"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-3: Redisplaying the sticky postback form with a message about the invalid data</span></p></figcaption>
</figure>
<p class="TX">The third and final situation is a form submission with valid data (via the <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> HTTP method). In this case, a confirmation message should be displayed to the user, as shown in <a href="#fig12-4">Figure 12-4</a>.</p>
<figure class="IMG"><a id="fig12-4"/><img alt="" class="img60" height="364" src="../images/figure12-4.jpg" width="972"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-4: Displaying a confirmation message after valid data is submitted</span></p></figcaption>
</figure>
<p class="TX"><span aria-label="232" epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>The logic for our postback PHP script can be visualized as a flow chart with two decisions (<a href="#fig12-5">Figure 12-5</a>).</p>
<figure class="IMG"><a id="fig12-5"/><img alt="" class="img100" height="927" src="../images/figure12-5.jpg" width="1196"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-5: A decision flowchart for the postback sticky form</span></p></figcaption>
</figure>
<p class="TX">We’ll write the postback script in a <i>public/index.php</i> file in four stages: setting default values, validating the submitted data, displaying a confirmation for valid data, and displaying the form.</p>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Default Values</span></h5>
<p class="TNI1">First, we need to set default values for the two key postback variables <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span>. The first of these Boolean flags records whether the form has been submitted, as determined by whether the incoming request uses the <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> method (indicating a form submission) or the <span class="SANS_TheSansMonoCd_W5Regular_11">GET</span> method (indicating the initial request for the form). The second flag signals whether the data received is valid. A third variable will set the default value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span> variable for our logic. <a href="#lis12-5">Listing 12-5</a> shows the code.</p>
<span id="lis12-5"/>
<pre><code>&lt;?php&#13;
$isSubmitted = ($_SERVER['REQUEST_METHOD'] === 'POST');&#13;
$isValid = true;&#13;
$firstName = '';</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-5: Setting default values</span></p>
<p class="TX">We set the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> Boolean flag to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> depending on the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">'REQUEST_METHOD'</span> key in the <span class="SANS_TheSansMonoCd_W5Regular_11">$_SERVER</span> array. This superglobal array holds information from the web server about the current executing script, <span aria-label="233" epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/>the request being processed, and the like. If the value is the string <span class="SANS_TheSansMonoCd_W5Regular_11">'POST'</span>, then <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> will be <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>; otherwise, it will be <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>.</p>
<p class="TX">We next set the <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> Boolean flag to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> by default; we’re therefore assuming the received data is valid unless later logic determines otherwise. Finally, we set <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span> to an empty string to ensure that, whatever happens, we have a value for this variable that can be inserted into the form text box when the form is presented to the user.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Learn more about the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$_SERVER</span> <i>array in the PHP documentation at</i> <span class="note_LinkURL"><a href="https://www.php.net/manual/en/reserved.variables.server.php">https://www.php.net/manual/en/reserved.variables.server.php</a></span><i>.</i></p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Validating the Submitted Data</span></h5>
<p class="TNI1">The second block of code in our postback script, shown in <a href="#lis12-6">Listing 12-6</a>, attempts to validate the submitted form data after the form has been successfully submitted.</p>
<span id="lis12-6"/>
<pre><code>if ($isSubmitted) {&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> $firstName = filter_input(INPUT_POST, 'firstName');&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> if (strlen($firstName) &lt; 3) {&#13;
        $isValid = false;&#13;
        $errorMessage = 'invalid - name must contain at least 3 letters';&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-6: Validating the number of characters in</span> <span class="TheSansMonoCd_W5Regular_Italic_11">$firstName</span></p>
<p class="TX">We perform the validation inside an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement whose body will execute only if the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> Boolean flag is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. Therefore, we’ll skip this code when the form is requested for the first time. To validate the data, we use <span class="SANS_TheSansMonoCd_W5Regular_11">filter_input()</span> to retrieve the value of <span class="SANS_TheSansMonoCd_W5Regular_11">firstName</span> from the submitted <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> variables, overwriting the default, empty-string value of <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span> in the process <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we use <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> to check whether the received string contains less than three characters <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If so, we change the <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> Boolean flag to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> and assign an error message to the <span class="SANS_TheSansMonoCd_W5Regular_11">$errorMessage</span> variable.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Displaying a Confirmation for Valid Data</span></h5>
<p class="TNI1">At this point, we have values in the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> flags that we can use to decide what to present to the user. Our third block of code, shown in <a href="#lis12-7">Listing 12-7</a>, uses these flags in a single <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement for the situation in which the form has been submitted with valid data.</p>
<span id="lis12-7"/>
<pre><code>if ($isSubmitted &amp;&amp; $isValid) {&#13;
    print "Hello $firstName";&#13;
    die(); // End script processing here&#13;
}&#13;
?&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-7: Responding to valid data</span></p>
<p class="TX"><span aria-label="234" epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>If both flags are <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, we display a <span class="SANS_TheSansMonoCd_W5Regular_11">"Hello $firstName"</span> confirmation message to the user. Then we terminate the script with the <span class="SANS_TheSansMonoCd_W5Regular_11">die()</span> function.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Displaying the Form</span></h5>
<p class="TNI1">If the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement in <a href="#lis12-7">Listing 12-7</a> fails, either the form is being requested for the first time (<span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>) or the submitted data is invalid (<span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>). In either case, the result is the same: we need to display the form to the user. <a href="#lis12-8">Listing 12-8</a> shows the necessary mix of HTML and PHP code.</p>
<span id="lis12-8"/>
<pre><code>&lt;!doctype html&gt;&#13;
&lt;html&gt;&lt;head&gt;&#13;
    &lt;title&gt;Tiny sticky postback form&lt;/title&gt;&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> &lt;style&gt;.error {background-color: pink; padding: 1rem;}&lt;/style&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> &lt;form method="POST"&gt;&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> &lt;?php if ($isSubmitted &amp;&amp; !$isValid): ?&gt;&#13;
        &lt;div class="error"&gt;&lt;?= $errorMessage ?&gt;&lt;/div&gt;&#13;
    &lt;?php endif; ?&gt;&#13;
&#13;
  <span aria-label="annotation4" class="Code_CodeAnnotation">❹</span> &lt;input name="firstName" value="&lt;?= $firstName ?&gt;"&gt;&#13;
    &lt;input type="submit"&gt;&#13;
&lt;/form&gt;&#13;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-8: Displaying the form to the user</span></p>
<p class="TX">In the HTML head, we define a CSS <span class="SANS_TheSansMonoCd_W5Regular_11">error</span> class for any error message we need to display, with a pink background and some padding <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In the page’s body, we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;form&gt;</span> element with the <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> method <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Notice that we don’t include an <span class="SANS_TheSansMonoCd_W5Regular_11">action</span> attribute setting the PHP script that will process the form; when no action is specified, the form submission request is sent by default to the same URL that displayed the form. This default is perfect for a postback form like this one.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In HTML 4, a form had to specify an</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">action</span> <i>attribute, but in HTML 5, the attribute defaults to an empty string, which results in the form submitting to the same URL as led to the form’s display.</i></p>
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;form&gt;</span> element, we use PHP’s alternative <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement syntax to display a <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;div&gt;</span> element with the content of the <span class="SANS_TheSansMonoCd_W5Regular_11">$errorMessage</span> variable if the form is submitted but the data isn’t valid <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We style the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;div&gt;</span> with our <span class="SANS_TheSansMonoCd_W5Regular_11">error</span> CSS class. We then display the form text input box and set its <span class="SANS_TheSansMonoCd_W5Regular_11">value</span> attribute to the contents of the PHP <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span> variable <span aria-label="annotation4" class="CodeAnnotation">❹</span>. If the form is being displayed for the first time, this will be the default empty string we declared in <a href="#lis12-5">Listing 12-5</a>, but if the form is being redisplayed after an invalid input, <span class="SANS_TheSansMonoCd_W5Regular_11">$firstName</span> will hold the user’s previous submission. This mechanism is what makes the form sticky: the submitted value sticks in the text box when submitted and redisplayed, saving the user from typing values again.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<span aria-label="235" epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/>
<h4 class="H2" id="sec10"><span id="toc-link_175"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Array-Based Validation Logic</span></h4>
<p class="TNI1">Let’s now join the two key concepts from this chapter and implement our earlier product details form with its array-based approach to error messages as a postback sticky form. <a href="#fig12-6">Figure 12-6</a> shows an example of the error messages to be output when the submitted data is missing values or violates any validation rules.</p>
<figure class="IMG"><a id="fig12-6"/><img alt="" class="img50" height="894" src="../images/figure12-6.jpg" width="866"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-6: The sticky postback product form with errors</span></p></figcaption>
</figure>
<p class="TX">Even with an array-based approach to data validation, our postback script will follow the same basic steps as before: setting default values, validating the data, displaying a confirmation for valid input, and displaying the form. <a href="#lis12-9">Listing 12-9</a> tackles the first step.</p>
<span id="lis12-9"/>
<pre><code>&lt;?php&#13;
require 'zeroFunction.php'; // Read in our function&#13;
&#13;
$isSubmitted = ($_SERVER['REQUEST_METHOD'] === 'POST');&#13;
$productCode = '';&#13;
$price = '';&#13;
$errors = [];</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-9: Setting default values</span></p>
<p class="TX">As before, we set the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> Boolean flag to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> depending on whether <span class="SANS_TheSansMonoCd_W5Regular_11">$_SERVER['REQUEST_METHOD']</span> contains <span class="SANS_TheSansMonoCd_W5Regular_11">'POST'</span>. We then set the <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> variables to empty strings to ensure that we can refer to them safely for default values in the form inputs. Finally, we set <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> to an empty array. We’ll add to this array only if any validation errors are found; an empty array will indicate that the data is valid.</p>
<p class="TX"><span aria-label="236" epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/>Listing 12-10 attempts to validate the submitted form data.</p>
<span id="lis12-10"/>
<pre><code>if ($isSubmitted) {&#13;
    $productCode = filter_input(INPUT_POST, 'productCode');&#13;
    $price = filter_input(INPUT_POST, 'price');&#13;
&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> if (empty($productCode)) {&#13;
        $errors[] = 'missing product code';&#13;
    }&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> elseif (strlen($productCode) &lt; 3) {&#13;
        $errors[] = 'product code too few characters';&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> if (isAnEmptyNonZeroString($price)) {&#13;
        $errors[] = 'missing price';&#13;
    } elseif (!is_numeric($price)) {&#13;
        $errors[] = 'price was not a number';&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-10: Validating the submitted form data</span></p>
<p class="TX">Once again, all our validation occurs inside an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement executed only if the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> flag is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. We first retrieve the <span class="SANS_TheSansMonoCd_W5Regular_11">productCode</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> values from the submitted <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> variables. Then we test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> is empty <span aria-label="annotation1" class="CodeAnnotation">❶</span> and add an error message to the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> array if it is. Otherwise, we test whether <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> is less than three characters long <span aria-label="annotation2" class="CodeAnnotation">❷</span>, again adding an error message to the array if not. For our last validation check, we add another error message if <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> is empty or isn’t numeric <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">Next, <a href="#lis12-11">Listing 12-11</a> shows the code to confirm a valid form submission.</p>
<span id="lis12-11"/>
<pre><code>$isValid = empty($errors);&#13;
if ($isSubmitted &amp;&amp; $isValid) {&#13;
    print 'input data was error free';&#13;
    die(); // End script processing here&#13;
}&#13;
?&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-11: Confirming a valid submission</span></p>
<p class="TX">First, we test whether the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> array is empty and set the <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> Boolean flag accordingly. Then, if both the <span class="SANS_TheSansMonoCd_W5Regular_11">$isSubmitted</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$isValid</span> Boolean flags are <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, we display a confirmation message to the user and terminate the script with the <span class="SANS_TheSansMonoCd_W5Regular_11">die()</span> function. If either flag is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, we need to display the form to the user, with any errors if appropriate. <a href="#lis12-12">Listing 12-12</a> shows the code.</p>
<span id="lis12-12"/>
<pre><code><span aria-label="237" epub:type="pagebreak" id="pg_237" role="doc-pagebreak"/>&lt;!doctype html&gt;&#13;
&lt;html&gt;&lt;head&gt;&#13;
    &lt;title&gt;Two-field postback form&lt;/title&gt;&#13;
    &lt;style&gt;.error {background-color: pink; padding: 1rem;}&lt;/style&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> &lt;?php if ($isSubmitted &amp;&amp; !$isValid): ?&gt;&#13;
    &lt;div class="error"&gt;&#13;
        &lt;ul&gt;&#13;
          <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> &lt;?php foreach ($errors as $error): ?&gt;&#13;
                &lt;li&gt;&lt;?= $error ?&gt;&lt;/li&gt;&#13;
            &lt;?php endforeach; ?&gt;&#13;
        &lt;/ul&gt;&#13;
    &lt;/div&gt;&#13;
    &lt;?php endif; ?&gt;&#13;
&#13;
    &lt;h1&gt;Product details&lt;/h1&gt;&#13;
    &lt;form method="POST"&gt;&#13;
      <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> Product code: &lt;input name="productCode" value="&lt;?= $productCode ?&gt;"&gt;&#13;
      <span aria-label="annotation4" class="Code_CodeAnnotation">❹</span> &lt;p&gt;Price: &lt;input name="price" value="&lt;?= $price ?&gt;"&gt;&lt;/p&gt;&#13;
        &lt;p&gt;&lt;input type="submit"&gt;&lt;/p&gt;&#13;
    &lt;/form&gt;&#13;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 12-12: Displaying the form with any error messages</span></p>
<p class="TX">Initially, this code is similar to our earlier sticky form template from <a href="#lis12-8">Listing 12-8</a>, up to the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement checking whether the form was submitted but the data isn’t valid <span aria-label="annotation1" class="CodeAnnotation">❶</span>. From there, we use a PHP <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop <span aria-label="annotation2" class="CodeAnnotation">❷</span> to print each message in the <span class="SANS_TheSansMonoCd_W5Regular_11">$errors</span> array as a separate list item inside the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;div&gt;</span> styled with our <span class="SANS_TheSansMonoCd_W5Regular_11">error</span> CSS class. Later, we make the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;form&gt;</span> element sticky by prefilling the product code and price fields with the values from the <span class="SANS_TheSansMonoCd_W5Regular_11">$productCode</span> <span aria-label="annotation3" class="CodeAnnotation">❸</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> <span aria-label="annotation4" class="CodeAnnotation">❹</span> variables, which will be either the user’s previous submissions or the default empty strings.</p>
<p class="TX">As you can see, the same basic structure that worked for our simpler form also worked for this more complex postback sticky form script, and the strategy of building up and displaying an array of error messages fits well into this structure. However, the complete PHP postback script is nearly 60 lines long and performs enough actions as to make the single script complex.</p>
<p class="TX">In the next chapter, we’ll explore strategies to keep the benefits of the postback approach for form processing (such as displaying validation messages with the form and using sticky form values to save the user from retyping) while breaking up the tasks of form display, validation, error message display, and confirmation logic into simpler scripts. In the process, we’ll develop a basic web application architecture that can scale up to meet the requirements of complex websites, forms, and validation rules.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<span aria-label="238" epub:type="pagebreak" id="pg_238" role="doc-pagebreak"/>
<h3 class="H1" id="sec11"><span id="toc-link_176"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we covered strategies for validating submitted form data, including using an array to flexibly handle situations where zero, one, or several validation errors must be addressed. We highlighted the special care that must be taken when a 0 is submitted as a valid entry in a form. Finally, we looked at the postback technique for displaying and validating forms with a single script, and we implemented sticky forms that conveniently prefill with the user’s previous entries. As a PHP programmer, you may have to understand and maintain a range of website programming styles, and the postback approach in this chapter is a common one you’ll likely come across in other programmers’ code, even if it’s not an approach you use often when writing your own.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_177"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Create a sticky form using the HTTP <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> method that prompts for an integer age and redisplays the form populated with the submitted value each time.</p>
<p class="ListNumber">2.   Improve your answer to Exercise 1 so that an error message is displayed if a non-numeric age is entered.</p>
<p class="ListNumber">3.   Improve your answer to Exercise 2 so that after a valid (numeric) submission is received, a confirmation message displays, stating the user’s age after their next birthday.</p>
<p class="ListNumber">4.   Create a sticky form using the HTTP <span class="SANS_TheSansMonoCd_W5Regular_11">POST</span> method that prompts for an email address. If the address is valid, a confirmation message is displayed; if it’s not valid, the form is redisplayed with an error message stating that the email address is invalid. Think about the requirements for a valid email address.</p>
</section>
</section>
</div></body></html>