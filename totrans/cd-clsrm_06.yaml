- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intentional Development Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web development tools provide a playful introduction to actual software
    code that empowers students, but it lacks permanence. Anything your students create
    with these tools vanishes when they refresh or close the browser. In this chapter, we’ll
    introduce *development environments*, where students can build computational artifacts
    that they can develop, enhance, and share with others*.* Fortunately, the coding
    environments and their features that we’ll explore in this chapter will be very
    familiar to your students because of their previous experiences with the web development
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Online Code Playgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advantage of the browser’s web development tools is to immerse students
    in code as quickly as possible. Similarly, empowering students to construct their
    own web applications easily and at the earliest opportunity is the power of *code
    playgrounds*. These websites allow programmers to write HTML, CSS, and JavaScript
    in an online tool where they can save and execute their code without difficulty.
    A growing number of code playgrounds are coming online. Sites like JSFiddle, JS
    Bin, CodePen, and W3Schools offer different options and features.
  prefs: []
  type: TYPE_NORMAL
- en: Because these comprehensive development environments are instantly accessible
    via a web browser, students can open one and start coding, just like they do with
    the web development tools. Even better, they can save their work at school and
    later open a browser at home or at the library to continue coding where they left
    off. As a result, their efforts become more intentional. They begin working toward
    a goal in a project-based task that requires deeper content engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these development environments will bear some resemblance to the web
    development tools in that they have various panels for different kinds of script
    and code. Figure 6-1 shows part of the interface for JSFiddle, a popular code
    playground.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/CitC06_01_JSFiddle_labeled_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: JSFiddle user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Like the web development tools, Figure 6-1 shows multiple panels for different
    content. In this code playground, the HTML panel ❶ defines the document. The CSS
    panel ❷ defines the look and feel of the web page, and the JavaScript panel ❸
    contains the programming code that makes the page dynamic and defines how it behaves.
    As we learned in the preceding chapter, the content, style, and programming are
    decoupled from one another to make them easier to maintain. The output panel ❹
    shows the result of combining the HTML, CSS, and JavaScript. In this example,
    the combination of the three panels renders a 3D model of an alien world covered
    with light and dark squares to explore how a planet’s albedo (its color) affects
    its average temperature. Clearly, this coding environment allows for some very
    sophisticated demonstrations.
  prefs: []
  type: TYPE_NORMAL
- en: You should carefully consider which code playground your students will work
    in. Because students will be spending a great deal of time working in this environment,
    you need to choose the most feature-rich and flexible platform for them. The following
    subsections provide some features to consider when you’re evaluating code playgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numerous features are built into development platforms that can make code easier
    to read and debug. Your students will already be familiar with many of these features
    from working with the web development tools. For example, *syntax highlighting*
    is a common feature where code is color coded to make different elements readily
    identifiable. In syntax-highlighted CSS, the html selectors might be red, the
    id selectors green, the properties blue, and their values purple. The JavaScript
    might use green for function names, blue for keywords, red for conditional logic,
    yellow for strings, and purple for integers. This color coding makes the syntax
    pop out and the code easier to read. It also allows the coder to ignore what isn’t
    immediately relevant and focus on the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful user interface (UI) features include having the interface alert
    the user to syntactically incorrect code, similar to how most word processors
    highlight misspelled words. UIs that allow for *code folding*, expanding and collapsing
    code, let students hide the extraneous parts and simplify the view. Typing in
    the editor makes code completion and automatic code indentation more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another characteristic to keep in mind when you’re evaluating development environments
    is their simplicity. A feature-rich development environment might offer a multitude
    of conveniences, but it also offers an abundance of menu options that can overwhelm
    a novice programmer. So much of software development involves the art of mitigating
    complexity. Make sure the development environment you choose helps manage that
    complexity rather than increasing it.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 5 when students first opened the web development tools and
    we asked them to think about how they felt. The web development tools can be overwhelming,
    which is why this book restricts students to only using a few of those tabs. Once
    students are comfortable with the DOM Inspector and web console, they can slowly
    explore the other features, such as Network, Performance, Memory, Security, and
    Debugger. Your students can engage with a highly complex development environment
    if you have them focus on just a few key features at the outset.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration and Portability Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very little software is written by lone programmers. Even software developers
    working alone build on solutions that came before them and make existing code
    their own. A feature available to many code playgrounds is the ability to *fork*
    a project: that is, to take an existing code example, click a button, and get
    a copy of it to modify along a new path, or *branch*. Forking an application from
    the playground and building it along a new branch provides students with existing
    code from which to learn new coding skills and lets them extend that solution
    to make it their own.'
  prefs: []
  type: TYPE_NORMAL
- en: Forking and branching code relate to *versioning* in software development. Versioning
    is the use of unique names or labels to track changes in the state of a software
    project over time. The Chapter 2 exercise “Iterative You” mentioned having students
    view themselves as iteratively improving through version labels 0.1, 0.2, 0.3,
    and so on. Each version marked a milestone in their self-improvement up to version
    1.0 on graduation day. Code playgrounds with built-in versioning features allow
    students to track their coding progress. More important, students can revert to
    previous code versions if they accidentally introduce a bug in a more current
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'When students feel confident in their creations, the code playground should
    provide them with the means to share their work. Each project should have a unique
    URL that students can provide to their peers to show off what they’ve made. Taking
    this a step further, some playgrounds can make creations *embeddable*: students
    can embed their work in other websites, like forums, and can share their work
    in such a way that their peers don’t even need to follow a link.'
  prefs: []
  type: TYPE_NORMAL
- en: Another feature to consider in a playground is *portability*. How easy is it
    to take a solution elsewhere? If students want to move their solution to another
    playground, can they easily transfer their work? What if the student wants to
    start working in a local environment, coding on a local hard drive rather than
    the cloud? Does the playground allow them to download their work to take it elsewhere?
    As long as students can access their code in the playground, they can migrate,
    even if it means copy-pasting their code into a new environment. But it’s best
    to consider at the start how easy it is to move their code.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tied to collaboration and the ability to take someone else’s code and make it
    your own is *licensing*. Specifically, you need to help students understand the
    proper-use policies, terms of service, and copyright status of code posted publicly
    to the playground. The policies will almost certainly include language that states
    it’s not acceptable to post copyrighted or offensive content to the site. Actually,
    your students should be observing such conduct already. But what is the copyright
    status of original work they find or create on the site?
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, code posted to the site will be explicitly defined as *free software,
    open source software*, or *copyleft* license, which grants users the right to
    update and redistribute the software. Even better, the playground might allow
    users to select a license from a list of permissive and restrictive licensing
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Many sites simply take no stand on licensing and place the responsibility on
    users to sort out rights violations between one another. As a best practice, students
    should include licensing information in their code to make it clear to others
    what rights are given and withheld when using the software. Similarly, students
    should look for licensing information for the projects they find in the repository
    or contact the owner for permission before clicking the fork button. Listing 6-1
    shows an example of a free software license comment embedded in code. The /* and
    */ syntax are opening and closing tags that indicate to the browser that this
    is a comment intended only for humans reading the code and should be ignored by
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Sample MIT License notice comment in JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-1 shows the MIT License, a license that’s highly popular due to its
    brevity and compatibility with free and restrictive licenses. For example, a software
    solution with a restrictive license can include solutions that are MIT Licensed
    as long as those components are identified as open source. Other open source licensing
    options include GNU General Public License (GPL), Berkeley Software Distribution
    (BSD), or even releasing to the public domain. Have a dialogue with your students
    to decide on a license that will ensure collaboration within your classroom and
    beyond it.
  prefs: []
  type: TYPE_NORMAL
- en: Software Frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some intermediate features that your students might want to explore early on
    are *software frameworks*, which extend and enhance core programming languages.
    In JavaScript programming, software frameworks can empower your students to easily
    render 3D models, code video games, or train an artificial intelligence device.
    Most code playgrounds allow users to select frameworks from a drop-down list to
    reference in the code. These features are sometimes called *dependencies*, because
    the software students write will depend on including a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Like working with JavaScript code, the framework’s abstractions have their own
    syntax. The framework has its own documentation for students to learn about its
    many features. If the framework is well established, like jQuery, students will
    find many questions answered and examples posted in online forums. Similarly,
    the framework’s website will have an examples page with demonstrations of what
    developers can do with its extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Code playgrounds make separating the content, style, and behavior clear; color
    code the syntax; highlight errors; and make including frameworks easy. But students
    can also learn some aspects of web application development by working with local
    files on a computer. After all, developers don’t code proprietary software on
    free sites in the business world. Becoming familiar with how local development
    differs from code playground development is important.
  prefs: []
  type: TYPE_NORMAL
- en: Local Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code playgrounds are invaluable for the way they accelerate development and
    abstract away many of the web programming details. But once your students know
    how to develop code in the playground you chose, it’s critical that you familiarize
    them with developing web applications in a local environment. Doing so will give
    them a more nuanced and detailed understanding of how web applications are structured.
    It will also give them access to the wide world of applications other coders have
    developed and shared outside the playgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: As with the rationale for introducing web development tools and code playgrounds,
    making development as convenient as possible is vital to your students’ enjoyment
    of working in this new local environment. For this reason, you should provide
    students with a basic template in which to begin their work. This is also good
    practice, as writing a template from scratch is a painstaking and error-prone
    process. As students will learn when they become proficient coders, it’s much
    faster and more accurate to grab code when developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template package you develop and provide to your students should include
    three files: an *index.html* file in the root folder for the content, a *styles.css*
    file in a *css* folder for the styling, and a *scripts.js* file in a *js* folder
    for the JavaScript code. The *index.html* file provides the basic starting HTML
    from which students can work; it should look very similar to Listing 6-4.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: HTML template from which students can begin local development'
  prefs: []
  type: TYPE_NORMAL
- en: Several new elements are in this code for your students to understand; most
    likely, they were abstracted away in the coding playground. Instead of three panels
    that separate HTML, CSS, and JavaScript, we have three different files that need
    to be edited individually in a text editor. The <link rel="stylesheet"> tag indicates
    the location of the CSS file relative to the *index.html* file in the href property,
    which is in a file named *styles.css* in the *css* folder. Similarly, the second
    <script> tag in this example defines the location of the JavaScript file in the
    src property relative to the *index.html* file, which is in a file named *scripts.js*
    in the *js* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Additional details in Listing 6-4 give us an opportunity to explore why the
    code is the way it is. Consider the first <script> tag, which references the jQuery
    JavaScript framework hosted on a Google server. Why isn’t this file saved in the
    *js* folder? Why rely on a third-party service to host the file? To understand
    the strategy here, students need to know about browser *caching*. Caching occurs
    when the browser saves copies of most web content to the local computer to prevent
    having to download it in the future, which speeds up page loads. By referencing
    the *jquery.min.js* file in this open JavaScript library, there’s a good chance
    the file will already be stored in a visitor’s browser cache and the client won’t
    need to download it again.
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider the content of the *jquery.min.js* file. If you enter the URL
    for this resource into a web browser to view its contents, you’ll see code similar
    to Figure 6-2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/CitC06_02_jQueryMinified.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: jQuery framework minified code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: This snippet of JavaScript code is illegible to humans but still accessible
    to computers. The code is *minified*, condensed to make the file size as small
    as possible so the browser can quickly download it. It’s been stripped of all
    line breaks and indentations, and intuitive variable and function names are replaced
    with cryptic identifiers just a few characters long.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the coding playground, including frameworks is often as simple as selecting
    them from a drop-down list without needing to add any code. Other examples of
    details that are abstracted out when working in code playgrounds instead of locally
    include the <meta> tags that provide information, such as author, keyword, and
    site description, to web crawlers. Also, the <doctype> tag that comes before the
    <html> tag tells the browser what kind of document it’s reading and how to interpret
    its tags. In addition, the ?v=0.1 is appended to the filenames: it will be incremented
    to ?v=0.2 and so forth as the files are updated, to let client browsers know to
    refresh the cached versions of these files with the latest one. You can discuss
    endless little details and changing best practices in class to give your students
    the best understanding of why certain elements exist and are defined the way they
    are in the code students work with.'
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of local development we’ll learn in more detail in Chapter 9 is how
    to collaborate when working in the local file system. We’ll explore tools that
    allow students to work on their code locally while still collaborating with others.
    For the immediate future, the projects students work on will be mostly individual
    exercises of solo problem-solving and class exercises of evaluating code as a
    group, before moving on to collaborate on larger projects in smaller groups. As
    the educator, you’ll keep tabs on the best practices in web development and iteratively
    improve the starting-point code you provide students in code playgrounds and as
    local files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we explored code playgrounds as an important step toward intentional
    development and had students work in longer-term, more permanent projects. We
    learned about the features and functionality of a good code playground, from separating
    the content, style, and functionality into different development panels to the
    UI features that make coding easier, features for collaboration and porting code
    to other platforms, licensing options, and JavaScript frameworks that empower
    students to make magic. We briefly learned about separating content, styling,
    and code into different files for local development and the additional details
    code playgrounds abstract away.
  prefs: []
  type: TYPE_NORMAL
- en: The power of the web development tools is that they instantly give students
    existing code to experiment with. The power of code playgrounds is the ability
    to easily fork existing code to adopt, adapt, and improve into permanent projects.
    The power of local development is being exposed to all the details the other environments
    abstract away and seeing the whole picture, just like an application developer
    working in the field. Each tool levels up the student from playing with existing
    code and into intentional development.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an established development environment, either in an online code
    playground or the local file system in which your students will begin to intentionally
    extend existing code and begin making their own ideas manifest, we can start exploring
    some concrete code projects for this environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll review some exercises to challenge and enlighten
    your students to build their coding confidence.
  prefs: []
  type: TYPE_NORMAL
