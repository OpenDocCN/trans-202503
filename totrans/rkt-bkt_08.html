<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_69"/><strong><span class="big">6</span><br/>BOOT PROCESS SECURITY</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">In this chapter we’ll look at two important security mechanisms implemented in the Microsoft Windows kernel: the Early Launch Anti-Malware (ELAM) module, introduced in Windows 8, and the Kernel-Mode Code Signing Policy, introduced in Windows Vista. Both mechanisms were designed to prevent the execution of unauthorized code in the kernel address space, in order to make it harder for rootkits to compromise a system. We’ll look at how these mechanisms are implemented, discuss their advantages and weak points, and examine their effectiveness against rootkits and bootkits.</p>
<h3 class="h3" id="ch06lev1sec1"><span epub:type="pagebreak" id="page_70"/><strong>The Early Launch Anti-Malware Module</strong></h3>
<p class="noindent">The Early Launch Anti-Malware (ELAM) module is a detection mechanism for Windows systems that allows third-party security software, such as antivirus software, to register a kernel-mode driver that is guaranteed to execute very early in the boot process, before any other third-party driver is loaded. Thus, when an attacker attempts to load a malicious component into the Windows kernel address space, the security software can inspect and prevent that malicious driver from loading since the ELAM driver is already active.</p>
<h4 class="h4" id="ch06lev2sec1"><strong><em>API Callback Routines</em></strong></h4>
<p class="noindent">The ELAM driver registers <em>callback</em> routines that the kernel uses to evaluate data in the system registry hive and boot-start drivers. These callbacks detect malicious data and modules and prevent them from being loaded and initialized by Windows.</p>
<p class="indent">The Windows kernel registers and unregisters these callbacks by implementing the following API routines:</p>
<p class="hangt"><span class="codestrong">CmRegisterCallbackEx</span> <strong>and</strong> <span class="codestrong">CmUnRegisterCallback</span> Register and unregister callbacks for monitoring registry data</p>
<p class="hangb"><span class="codestrong">IoRegisterBootDriverCallback</span> <strong>and</strong> <span class="codestrong">IoUnRegisterBootDriverCallback</span> Register and unregister callbacks for boot-start drivers</p>
<p class="indent">These callback routines use the prototype <span class="literal">EX_CALLBACK_FUNCTION</span>, shown in <a href="ch06.xhtml#ch06list01">Listing 6-1</a>.</p>
<p class="programs">NTSTATUS EX_CALLBACK_FUNCTION(<br/>
<span class="ent">➊</span> IN PVOID CallbackContext,<br/>
<span class="ent">➋</span> IN PVOID Argument1,         // callback type<br/>
<span class="ent">➌</span> IN PVOID Argument2          // system-provided context structure<br/>
);</p>
<p class="listing" id="ch06list01"><em>Listing 6-1: Prototype of ELAM callbacks</em></p>
<p class="indent">The parameter <span class="literal">CallbackContext</span> <span class="ent">➊</span> receives a context from the ELAM driver once the driver has executed one of the aforementioned callback routines to register a callback. The <em>context</em> is a pointer to a memory buffer holding ELAM driver–specific parameters that may be accessed by any of the callback routines. This context is a pointer that’s also used to store the current state of the ELAM driver. The argument at <span class="ent">➋</span> provides the callback type, which may be either of the following for the boot-start drivers:</p>
<p class="hangt"><span class="codestrong">BdCbStatusUpdate</span> Provides status updates to an ELAM driver regarding the loading of driver dependencies or boot-start drivers</p>
<p class="hangb"><span class="codestrong">BdCbInitializeImage</span> Used by the ELAM driver to classify boot-start drivers and their dependencies</p>
<h5 class="h5" id="ch06lev3sec1"><span epub:type="pagebreak" id="page_71"/><strong>Classification of Boot-Start Drivers</strong></h5>
<p class="noindent">The argument at <span class="ent">➌</span> provides information that the operating system uses to classify the boot-start driver as <em>known good</em> (drivers known to be legitimate and clean), <em>unknown</em> (drivers that ELAM can’t classify), and <em>known bad</em> (drivers known to be malicious).</p>
<p class="indent">Unfortunately, the ELAM driver must base this decision on limited data about the driver image to classify, namely:</p>
<ul>
<li class="noindent">The name of the image</li>
<li class="noindent">The registry location where the image is registered as a boot-start driver</li>
<li class="noindent">The publisher and issuer of the image’s certificate</li>
<li class="noindent">A hash of the image and the name of the hashing algorithm</li>
<li class="noindent">A certificate thumbprint and the name of the thumbprint algorithm</li>
</ul>
<p class="indent">The ELAM driver doesn’t receive the image’s base address, nor can it access the binary image on the hard drive because the storage device driver stack isn’t yet initialized (as the system hasn’t finished bootup). It must decide which drivers to load based solely on the hash of the image and its certificate, without being able to observe the image itself. As a consequence, the protection for the drivers is not very effective at this stage.</p>
<h5 class="h5" id="ch06lev3sec2"><strong>ELAM Policy</strong></h5>
<p class="noindent">Windows decides whether to load known bad or unknown drivers based on the ELAM policy specified in this registry key: <em>HKLM\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy</em>.</p>
<p class="indent"><a href="ch06.xhtml#ch06tab01">Table 6-1</a> lists the ELAM policy values that determine which drivers may be loaded.</p>
<p class="tabcap" id="ch06tab01"><strong>Table 6-1:</strong> ELAM Policy Values</p>
<table class="topbot-d">
<colgroup>
<col style="width:40%"/>
<col style="width:20%"/>
<col style="width:40%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Policy name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Policy value</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">PNP_INITIALIZE_DRIVERS_DEFAULT</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0x00</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Load known good drivers only.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">PNP_INITIALIZE_UNKNOWN_DRIVERS</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0x01</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Load known good and unknown drivers only.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">PNP_INITIALIZE_BAD_CRITICAL_DRIVERS</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0x03</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Load known good, unknown, and known bad critical drivers. (This is the default setting.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">PNP_INITIALIZE_BAD_DRIVERS</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">0x07</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Load all drivers.</p></td>
</tr>
</tbody>
</table>
<p class="indent">As you can see, the default ELAM policy, <span class="literal">PNP_INITIALIZE_BAD_CRITICAL_DRIVERS</span>, allows the loading of bad critical drivers. This means that if a critical driver is classified by ELAM as known bad, the system will load it <span epub:type="pagebreak" id="page_72"/>regardless. The rationale behind this policy is that critical system drivers are an essential part of the operating system, so any failure in their initialization will render the operating system unbootable; that is, the system won’t boot unless all its critical drivers are successfully loaded and initialized. This ELAM policy therefore compromises some security in favor of availability and serviceability.</p>
<p class="indent">However, this policy won’t load known bad <em>noncritical</em> drivers, or those drivers without which the operating system can still successfully load. This is the main difference between the <span class="literal">PNP_INITIALIZE_BAD_CRITICAL_DRIVERS</span> and <span class="literal">PNP_INITIALIZE_BAD_DRIVERS</span> policies: the latter allows all drivers to be loaded, including known bad noncritical drivers.</p>
<h4 class="h4" id="ch06lev2sec2"><strong><em>How Bootkits Bypass ELAM</em></strong></h4>
<p class="noindent">ELAM gives security software an advantage against rootkit threats but not against bootkits—nor was it designed to. ELAM can monitor only legitimately loaded drivers, but most bootkits load kernel-mode drivers that use undocumented operating system features. This means that a bootkit can bypass security enforcement and inject its code into kernel address space despite ELAM. In addition, as shown in <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>, a bootkit’s malicious code runs before the operating system kernel is initialized and before any kernel-mode driver is loaded, including ELAM. This means that a bootkit can sidestep ELAM protection.</p>
<div class="image"><a id="ch06fig01"/><img src="../images/06fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 6-1: The flow of the boot process with ELAM</em></p>
<p class="indent">Most bootkits load their kernel-mode code in the middle of kernel initialization, once all OS subsystems (the I/O subsystem, object manager, plug and play manager, and so forth) have been initialized but before ELAM is executed. ELAM can’t prevent the execution of malicious code that has been loaded before it, of course, so it has no defenses against bootkit techniques.</p>
<h3 class="h3" id="ch06lev1sec2"><span epub:type="pagebreak" id="page_73"/><strong>Microsoft Kernel-Mode Code Signing Policy</strong></h3>
<p class="noindent">The Kernel-Mode Code Signing Policy protects the Windows operating system by imposing code-signing requirements for modules meant to be loaded into the kernel address space. This policy has made it much harder for bootkits and rootkits to compromise a system by executing kernel-mode drivers, thus pushing rootkit developers to switch to bootkit techniques instead. Unfortunately, as explained later in the chapter, attackers can disable the entire logic of on-load signature verification by manipulating a few variables that correspond to startup configuration options.</p>
<h4 class="h4" id="ch06lev2sec3"><strong><em>Kernel-Mode Drivers Subject to Integrity Checks</em></strong></h4>
<p class="noindent">The signing policy was introduced in Windows Vista and has been enforced in all subsequent versions of Windows, though it’s enforced differently on 32-bit and 64-bit operating systems. It kicks in when the kernel-mode drivers are loaded so that it can verify their integrity before driver images are mapped into kernel address space. <a href="ch06.xhtml#ch06tab02">Table 6-2</a> shows which kernel-mode drivers on 64- and 32-bit systems are subject to which integrity checks.</p>
<p class="tabcap" id="ch06tab02"><strong>Table 6-2:</strong> Kernel-Mode Code Signing Policy Requirements</p>
<table class="topbot-d">
<colgroup>
<col style="width:50%"/>
<col style="width:20%"/>
<col style="width:30%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h" rowspan="2"><p class="tab_th"><strong>Driver type</strong></p></td>
<td style="vertical-align: top;" class="table-h" colspan="2"><p class="tab_th"><strong>Subject to integrity checks?</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>64-bit</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>32-bit</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Boot-start drivers</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Yes</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Yes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Non-boot-start PnP drivers</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Yes</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">No</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Non-boot-start, non-PnP drivers</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Yes</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">No (except drivers that stream protected media)</p></td>
</tr>
</tbody>
</table>
<p class="indent">As the table shows, on 64-bit systems, all kernel-mode modules, regardless of type, are subject to integrity checks. On 32-bit systems, the signing policy applies only to boot-start and media drivers; other drivers are not checked (PnP device installation enforces an install-time signing requirement).</p>
<p class="indent">In order to comply with the code integrity requirements, drivers must have either an embedded Software Publisher Certificate (SPC) digital signature or a catalog file with an SPC signature. Boot-start drivers, however, can have only embedded signatures because at boot time the storage device driver stack isn’t initialized, making the drivers’ catalog files inaccessible.</p>
<h4 class="h4" id="ch06lev2sec4"><strong><em>Location of Driver Signatures</em></strong></h4>
<p class="noindent">The embedded driver signature within a PE file, such as a boot-start driver, is specified in the <span class="literal">IMAGE_DIRECTORY_DATA_SECURITY</span> entry in the PE header data directories. Microsoft provides APIs to enumerate and get information on all the certificates contained in an image, as shown in <a href="ch06.xhtml#ch06list02">Listing 6-2</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_74"/>BOOL ImageEnumerateCertificates(<br/>
   _In_     HANDLE FileHandle,<br/>
   _In_     WORD TypeFilter,<br/>
   _Out_    PDWORD CertificateCount,<br/>
   _In_out_ PDWORD Indices,<br/>
   _In_opt_ DWORD IndexCount<br/>
);<br/>
BOOL ImageGetCertificateData(<br/>
   _In_    HANDLE FileHandle,<br/>
   _In_    DWORD CertificateIndex,<br/>
   _Out_   LPWIN_CERTIFICATE Certificate,<br/>
   _Inout_ PDWORD RequiredLength<br/>
);</p>
<p class="listing" id="ch06list02"><em>Listing 6-2: Microsoft’s API for enumerating and validating certificates</em></p>
<p class="indent">The Kernel-Mode Code Signing Policy has increased the security resilience of the system, but it does have its limitations. In the following sections, we discuss some of those shortcomings and how malware authors have leveraged them to bypass protections.</p>
<div class="sidebar">
<p class="sidebart"><strong>PLUG AND PLAY DEVICE INSTALLATION SIGNING POLICY</strong></p>
<p class="spara">In addition to the Kernel-Mode Code Signing Policy, Microsoft Windows has another type of signing policy: the Plug and Play Device Installation Signing Policy. It’s important not to confuse the two.</p>
<p class="sparai">The requirements of the Plug and Play Device Installation Signing Policy apply only to plug and play (PnP) device drivers and are enforced in order to verify the identity of the publisher and the integrity of the PnP device driver installation package. Verification requires that the catalog file of the driver package be signed either by a Windows Hardware Quality Labs (WHQL) certificate or by a third-party SPC. If the driver package doesn’t meet the requirements of the PnP policy, a warning dialog prompts users to decide whether to allow the driver package to be installed on their system.</p>
<p class="sparai">System administrators can disable the PnP policy, allowing PnP driver packages to be installed on a system without proper signatures. Also, note that this policy is applied only when the driver package is installed, not when the drivers are loaded. Although this may look like a TOCTOU (time of check to time of use) weakness, it’s not; it simply means that a PnP driver package that is successfully installed on a system won’t necessarily be loaded, because these drivers are also subject to the Kernel-Mode Code Signing Policy check at boot.</p>
</div>
<h4 class="h4" id="ch06lev2sec5"><strong><em>The Legacy Code Integrity Weakness</em></strong></h4>
<p class="noindent">The logic in the Kernel-Mode Code Signing Policy responsible for enforcing code integrity is shared between the Windows kernel image and the kernel-mode library <em>ci.dll</em>. The kernel image uses this library to verify the <span epub:type="pagebreak" id="page_75"/>integrity of all modules being loaded into the kernel address space. The key weakness of the signing process lies in a single point of failure in this code.</p>
<p class="indent">In Microsoft Windows Vista and 7, a single variable in the kernel image lies at the heart of this mechanism and determines whether integrity checks are enforced. It looks like this:</p>
<p class="programs">BOOL nt!g_CiEnabled</p>
<p class="indent">This variable is initialized at boot time in the kernel image routine <span class="literal">NTSTATUS SepInitializeCodeIntegrity()</span>. The operating system checks to see if it is booted into the Windows preinstallation (WinPE) mode, and if so, the variable <span class="literal">nt!g_CiEnabled</span> is initialized with the <span class="literal">FALSE</span> (0x00) value, which disables integrity checks.</p>
<p class="indent">So, of course, attackers found that they could easily dodge the integrity check by simply setting <span class="literal">nt!g_CiEnabled</span> to <span class="literal">FALSE</span>, which is exactly what happened with the Uroburos family of malware (also known as Snake and Turla) in 2011. Uroburos bypassed the code-signing policy by introducing and then exploiting a vulnerability in a third-party driver. The legitimate third-party signed driver was <em>VBoxDrv.sys</em> (the VirtualBox driver), and the exploit cleared the value of the <span class="literal">nt!g_CiEnabled</span> variable after gaining code execution in kernel mode, at which point any malicious unsigned driver could be loaded on the attacked machine.</p>
<div class="sidebar">
<p class="sidebart"><strong>A LINUX VULNERABILITY</strong></p>
<p class="spara">This kind of weakness is not unique to Windows: attackers have disabled the mandatory access control enforcement in SELinux in similar ways. Specifically, if the attacker knows the address of the variable containing SELinux’s enforcement status, all the attacker needs to do is overwrite the value of that variable. Because SELinux enforcement logic tests the variable’s value before doing any checks, this logic will render itself inactive. A detailed analysis of this vulnerability and its exploit code can be found at <em><a href="https://grsecurity.net/~spender/exploits/exploit2.txt">https://grsecurity.net/~spender/exploits/exploit2.txt</a></em>.</p>
</div>
<p class="indent">If Windows isn’t in WinPE mode, it next checks the values of the boot options <span class="literal">DISABLE_INTEGRITY_CHECKS</span> and <span class="literal">TESTSIGNING</span>. As the name suggests, <span class="literal">DISABLE_INTEGRITY_CHECKS</span> disables integrity checks. A user, on any Windows version, can set this option manually at boot with the Boot menu option Disable Driver Signature Enforcement. Windows Vista users can also use the <em>bcdedit.exe</em> tool to set the value of the <span class="literal">nointegritychecks</span> option to <span class="literal">TRUE</span>; later versions ignore this option in the Boot Configuration Data (BCD) when Secure Boot is enabled (see <a href="ch17.xhtml#ch17">Chapter 17</a> for more on Secure Boot).</p>
<p class="indent">The <span class="literal">TESTSIGNING</span> option alters the way the operating system verifies the integrity of kernel-mode modules. When it’s set to <span class="literal">TRUE</span>, certificate validation isn’t required to chain all the way up to a trusted root certificate <span epub:type="pagebreak" id="page_76"/>authority (CA). In other words, <em>any</em> driver with <em>any</em> digital signature can be loaded into kernel address space. The Necurs rootkit abuses the <span class="literal">TESTSIGNING</span> option by setting it to <span class="literal">TRUE</span> and loading its kernel-mode driver, signed with a custom certificate.</p>
<p class="indent">For years, there have been browser bugs that failed to follow the intermediate links in the X.509 certificate’s chains of trust to a legitimate trusted CA,<sup><a id="ch06fn1a" href="footnotes.xhtml#ch06fn1">1</a></sup> but OS module-signing schemes still don’t eschew shortcuts wherever chains of trust are concerned.</p>
<h4 class="h4" id="ch06lev2sec6"><strong><em>The ci.dll Module</em></strong></h4>
<p class="noindent">The kernel-mode library <em>ci.dll</em>, which is responsible for enforcing code integrity policy, contains the following routines:</p>
<p class="hangt"><span class="codestrong">CiCheckSignedFile</span> Verifies the digest and validates the digital signature</p>
<p class="hang"><span class="codestrong">CiFindPageHashesInCatalog</span> Validates whether a verified system catalog contains the digest of the first memory page of the PE image</p>
<p class="hang"><span class="codestrong">CiFindPageHashesInSignedFile</span> Verifies the digest and validates the digital signature of the first memory page of the PE image</p>
<p class="hang"><span class="codestrong">CiFreePolicyInfo</span> Frees memory allocated by the functions <span class="literal">CiVerifyHashInCatalog</span>, <span class="literal">CiCheckSignedFile</span>, <span class="literal">CiFindPageHashesInCatalog</span>, and <span class="literal">CiFindPageHashesInSignedFile</span></p>
<p class="hang"><span class="codestrong">CiGetPEInformation</span> Creates an encrypted communication channel between the caller and the <em>ci.dll</em> module</p>
<p class="hang"><span class="codestrong">CiInitialize</span> Initializes the capability of <em>ci.dll</em> to validate PE image file integrity</p>
<p class="hangb"><span class="codestrong">CiVerifyHashInCatalog</span> Validates the digest of the PE image contained within a verified system catalog</p>
<p class="indent">The routine <span class="literal">CiInitialize</span> is the most important one for our purposes, because it initializes the library and creates its data context. We can see its prototype corresponding to Windows 7 in <a href="ch06.xhtml#ch06list03">Listing 6-3</a>.</p>
<p class="programs">NTSTATUS CiInitialize(<br/>
<span class="ent">➊</span> IN ULONG CiOptions;<br/>
   PVOID Parameters;<br/>
<span class="ent">➋</span> OUT PVOID g_CiCallbacks;<br/>
);</p>
<p class="listing" id="ch06list03"><em>Listing 6-3: Prototype of the <span class="literal">CiInitialize</span> routine</em></p>
<p class="indent">The <span class="literal">CiInitialize</span> routine receives as parameters the code integrity options (<span class="literal">CiOptions</span>) <span class="ent">➊</span> and a pointer to an array of callbacks (<span class="literal">OUT PVOID g_CiCallbacks</span>) <span class="ent">➋</span>, the routines of which it fills in upon output. The kernel uses these callbacks to verify the integrity of kernel-mode modules.</p>
<p class="indent"><span epub:type="pagebreak" id="page_77"/>The <span class="literal">CiInitialize</span> routine also performs a self-check to ensure that no one has tampered with it. The routine then proceeds to verify the integrity of all the drivers in the boot-driver list, which essentially contains boot-start drivers and their dependencies.</p>
<p class="indent">Once initialization of the <em>ci.dll</em> library is complete, the kernel uses callbacks in the <span class="literal">g_CiCallbacks</span> buffer to verify the integrity of the modules. In Windows Vista and 7 (but not Windows 8), the <span class="literal">SeValidateImageHeader</span> routine decides whether a particular image passes the integrity check. <a href="ch06.xhtml#ch06list04">Listing 6-4</a> shows the algorithm underlying this routine.</p>
<p class="programs">NTSTATUS SeValidateImageHeader(Parameters) {<br/>
   NTSTATUS Status = STATUS_SUCCESS;<br/>
   VOID Buffer = NULL;<br/>
<span class="ent">➊</span> if (g_CiEnabled == TRUE) {<br/>
         if (g_CiCallbacks[0] != NULL)<br/>
         <span class="ent">➋</span> Status = g_CiCallbacks[0](Parameters);<br/>
         else<br/>
            Status = 0xC0000428<br/>
   }<br/>
   else {<br/>
      <span class="ent">➌</span> Buffer = ExAllocatePoolWithTag(PagedPool, 1, 'hPeS');<br/>
         *Parameters = Buffer<br/>
         if (Buffer == NULL)<br/>
            Status = STATUS_NO_MEMORY;<br/>
   }<br/>
   return Status;<br/>
}</p>
<p class="listing" id="ch06list04"><em>Listing 6-4: Pseudocode of the <span class="literal">SeValidateImageHeader</span> routine</em></p>
<p class="indent"><span class="literal">SeValidateImageHeader</span> checks to see if the <span class="literal">nt!g_CiEnabled</span> variable is set to <span class="literal">TRUE</span> <span class="ent">➊</span>. If not, it tries to allocate a byte-length buffer <span class="ent">➌</span> and, if it succeeds, returns a <span class="literal">STATUS_SUCCESS</span> value.</p>
<p class="indent">If <span class="literal">nt!g_CiEnabled</span> is <span class="literal">TRUE</span>, then <span class="literal">SeValidateImageHeader</span> executes the first callback in the <span class="literal">g_CiCallbacks</span> buffer, <span class="literal">g_CiCallbacks[0]</span> <span class="ent">➋</span>, which is set to the <span class="literal">CiValidateImageData</span> routine. The later callback <span class="literal">CiValidateImageData</span> verifies the integrity of the image being loaded.</p>
<h4 class="h4" id="ch06lev2sec7"><strong><em>Defensive Changes in Windows 8</em></strong></h4>
<p class="noindent">With Windows 8, Microsoft made a few changes designed to limit the kinds of attacks possible in this scenario. First, Microsoft deprecated the kernel variable <span class="literal">nt!g_CiEnabled</span>, leaving no single point of control over the integrity policy in the kernel image as in earlier versions of Windows. Windows 8 also changed the layout of the <span class="literal">g_CiCallbacks</span> buffer.</p>
<p class="indent"><a href="ch06.xhtml#ch06list05">Listing 6-5</a> (Windows 7 and Vista) and <a href="ch06.xhtml#ch06list06">Listing 6-6</a> (Windows 8) show how the layout of <span class="literal">g_CiCallbacks</span> differs between the OS versions.</p>
<p class="programs">typedef struct _CI_CALLBACKS_WIN7_VISTA {<br/>
 PVOID CiValidateImageHeader;<br/>
 PVOID CiValidateImageData;<br/>
<span epub:type="pagebreak" id="page_78"/> PVOID CiQueryInformation;<br/>
} CI_CALLBACKS_WIN7_VISTA, *PCI_CALLBACKS_WIN7_VISTA;</p>
<p class="listing" id="ch06list05"><em>Listing 6-5: Layout of <span class="literal">g_CiCallbacks</span> buffer in Windows Vista and Windows 7</em></p>
<p class="indent">As you can see in <a href="ch06.xhtml#ch06list05">Listing 6-5</a>, the Windows Vista and Windows 7 layout includes just the necessary basics. The Windows 8 layout (<a href="ch06.xhtml#ch06list06">Listing 6-6</a>), on the other hand, has more fields for additional callback functions for PE image digital signature validation.</p>
<p class="programs">typedef struct _CI_CALLBACKS_WIN8 {<br/>
    ULONG ulSize;<br/>
    PVOID CiSetFileCache;<br/>
    PVOID CiGetFileCache;<br/>
 <span class="ent">➊</span> PVOID CiQueryInformation;<br/>
 <span class="ent">➋</span> PVOID CiValidateImageHeader;<br/>
 <span class="ent">➌</span> PVOID CiValidateImageData;<br/>
    PVOID CiHashMemory;<br/>
    PVOID KappxIsPackageFile;<br/>
} CI_CALLBACKS_WIN8, *PCI_CALLBACKS_WIN8;</p>
<p class="listing" id="ch06list06"><em>Listing 6-6: Layout of <span class="literal">g_CiCallbacks</span> buffer in Windows 8</em>.x</p>
<p class="indent">In addition to the function pointers <span class="literal">CiQueryInformation</span> <span class="ent">➊</span>, <span class="literal">CiValidateImageHeader</span> <span class="ent">➋</span>, and <span class="literal">CiValidateImageData</span> <span class="ent">➌</span>, which are present in both <span class="literal">CI_CALLBACKS_WIN7_VISTA</span> and <span class="literal">CI_CALLBACKS_WIN8</span> structures, <span class="literal">CI_CALLBACKS_WIN8</span> also has fields that affect how code integrity is enforced in Windows 8.</p>
<div class="sidebar">
<p class="sidebart"><strong>FURTHER READING ON CI.DLL</strong></p>
<p class="spara">More information on the implementation details of the <em>ci.dll</em> module can be found at <em><a href="https://github.com/airbus-seclab/warbirdvm">https://github.com/airbus-seclab/warbirdvm</a></em>. This article delves into the implementation details of the encrypted memory storage used within <em>ci.dll</em> module, which may be used by other OS components to keep certain details and configuration information secret. This storage is protected by a heavily obfuscated virtual machine (VM), making it much harder to reverse engineer the storage encryption/decryption algorithm. The authors of the article provide a detailed analysis of the VM obfuscation method, and they share their Windbg plug-in for decrypting and encrypting the storage on the fly.</p>
</div>
<h3 class="h3" id="ch06lev1sec3"><strong>Secure Boot Technology</strong></h3>
<p class="noindent">Secure Boot technology was introduced in Windows 8 to protect the boot process against bootkit infection. Secure Boot leverages the Unified Extensible Firmware Interface (UEFI) to block the loading and execution of any boot application or driver without a valid digital signature in order <span epub:type="pagebreak" id="page_79"/>to protect the integrity of the operating system kernel, system files, and boot-critical drivers. <a href="ch06.xhtml#ch06fig02">Figure 6-2</a> shows the boot process with Secure Boot enabled.</p>
<div class="image"><a id="ch06fig02"/><img src="../images/06fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 6-2: The flow of the boot process with Secure Boot</em></p>
<p class="indent">When Secure Boot is enabled, the BIOS verifies the integrity of all UEFI and OS boot files executed at startup to ensure that they come from a legitimate source and have a valid digital signature. The signatures on all boot-critical drivers are checked in <em>winload.exe</em> and by the ELAM driver as part of Secure Boot verification. Secure Boot is similar to the Microsoft Kernel-Mode Code Signing Policy, but it applies to modules that are executed <em>before</em> the operating system kernel is loaded and initialized. As a result, untrusted components (that is, ones without valid signatures) will not be loaded and will trigger remediation.</p>
<p class="indent">When the system first starts, Secure Boot ensures that the preboot environment and bootloader components aren’t tampered with. The bootloader, in turn, validates the integrity of the kernel and boot-start drivers. Once the kernel passes the integrity validations, Secure Boot verifies other drivers and modules. Fundamentally, Secure Boot relies on the assumption of a <em>root of trust</em>—the idea that early in execution, a system is trustworthy. Of course, if attackers manage to execute an attack before that point, they probably win.</p>
<p class="indent">Over the last few years, the security research community has focused considerable attention on BIOS vulnerabilities that can allow attackers to bypass Secure Boot. We’ll discuss these vulnerabilities in detail in <a href="ch16.xhtml#ch16">Chapter 16</a> and delve into Secure Boot in more detail in <a href="ch17.xhtml#ch17">Chapter 17</a>.</p>
<h3 class="h3" id="ch06lev1sec4"><strong>Virtualization-Based Security in Windows 10</strong></h3>
<p class="noindent">Up until Windows 10, code integrity mechanisms were part of the system kernel itself. That essentially means that the integrity mechanism runs with the same privilege level that it is trying to protect. While this can be effective in many cases, it also means it is possible for an attacker to attack the integrity mechanism itself. To increase the effectiveness of the code integrity <span epub:type="pagebreak" id="page_80"/>mechanism, Windows 10 introduced two new features: Virtual Secure Mode and Device Guard, both of which are based on memory isolation assisted by hardware. This technology is generally referred to as <em>Second Level Address Translation</em>, and it is included in both Intel (where it is known as Extended Page Tables, or EPT) and AMD (where it’s called Rapid Virtualization Indexing, or RVI) CPUs.</p>
<h4 class="h4" id="ch06lev2sec8"><strong><em>Second Level Address Translation</em></strong></h4>
<p class="noindent">Windows has supported Second Level Address Translation (SLAT) since Windows 8 with Hyper-V (a Microsoft hypervisor). Hyper-V uses SLAT to perform memory management (for example, access protection) for virtual machines and to reduce the overhead of translating guest physical addresses (memory isolated by virtualization technologies) to real physical addresses.</p>
<p class="indent">SLAT provides hypervisors with an intermediary cache of virtual-to-physical address translation, which drastically reduces the amount of time the hypervisor takes to service translation requests to the physical memory of the host. It’s also used in the implementation of Virtual Secure Mode technology in Windows 10.</p>
<h4 class="h4" id="ch06lev2sec9"><strong><em>Virtual Secure Mode and Device Guard</em></strong></h4>
<p class="noindent">Virtual Secure Mode (VSM) virtualization-based security first appeared in Windows 10 and is based on Microsoft’s Hyper-V. When VSM is in place, the operating system and critical system modules are executed in isolated hypervisor-protected containers. This means that even if the kernel is compromised, critical components executed in other virtual environments are still secure because an attacker cannot pivot from one compromised virtual container to another. VSM also isolates the code integrity components from the Windows kernel itself in a hypervisor-protected container.</p>
<p class="indent">VSM isolation makes it impossible to use vulnerable legitimate kernel-mode drivers to disable code integrity (unless a vulnerability is found that affects the protection mechanism itself). Because the potentially vulnerable driver and the code integrity libraries are located in separate virtual containers, attackers should not be able to turn code integrity protection off.</p>
<p class="indent">Device Guard technology leverages VSM to prevent untrusted code from running on the system. To make these assurances, Device Guard combines VSM-protected code integrity with platform and UEFI Secure Boot. In doing so, Device Guard enforces the code integrity policy from the very beginning of the boot process all the way up to loading OS kernel-mode drivers and user-mode applications.</p>
<p class="indent"><a href="ch06.xhtml#ch06fig03">Figure 6-3</a> shows how Device Guard affects Windows 10’s ability to protect against bootkits and rootkits. Secure Boot protects from bootkits by verifying any firmware components executed in the preboot environment, <span epub:type="pagebreak" id="page_81"/>including the OS bootloader. To prevent malicious code from being injected into the kernel-mode address space, the VSM isolates the critical OS components responsible for enforcing code integrity (known as Hypervisor-Enforced Code Integrity, or HVCI, in this context) from the OS kernel address space.</p>
<div class="image"><a id="ch06fig03"/><img src="../images/06fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 6-3: The boot process with Virtual Secure Mode and Device Guard enabled</em></p>
<h4 class="h4" id="ch06lev2sec10"><strong><em>Device Guard Limitations on Driver Development</em></strong></h4>
<p class="noindent">Device Guard imposes specific requirements and limitations on the driver development process, and some existing drivers will not run correctly with it active. All drivers must follow these rules:</p>
<ul>
<li class="noindent">Allocate all nonpaged memory from the no-execute (NX) nonpaged pool. The driver’s PE module cannot have sections that are both writable and executable.</li>
<li class="noindent">Do not attempt direct modification of executable system memory.</li>
<li class="noindent">Do not use dynamic or self-modifying code in kernel mode.</li>
<li class="noindent">Do not load any data as executable.</li>
</ul>
<p class="indent">Because most modern rootkits and bootkits do not adhere to these requirements, they cannot run with Device Guard active, even if the driver has a valid signature or is able to bypass code integrity protection.</p>
<h3 class="h3" id="ch06lev1sec5"><span epub:type="pagebreak" id="page_82"/><strong>Conclusion</strong></h3>
<p class="noindent">This chapter has provided an overview of the evolution of code integrity protections. Boot process security is the most important frontier in defending operating systems against malware attacks. ELAM and code integrity protections are powerful security features that restrict the execution of untrusted code on the platform.</p>
<p class="indent">Windows 10 took boot process security to a new level, preventing code integrity bypasses by isolating HVCI components from the OS kernel with VSM. However, without an active Secure Boot mechanism in place, bootkits can circumvent these protections by attacking a system before they are loaded. In the following chapters, we’ll discuss Secure Boot in more detail and the BIOS attacks designed to evade it.</p>
</body></html>