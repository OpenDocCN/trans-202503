<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_484" aria-label="484"/>&#13;
<figure class="co-img"><img id="fig-pg484" class="img40" src="../images/pg484.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-42.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_485" aria-label="485"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch18">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">STRUCTURES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll add one final language feature: structures. You’ll also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operators to access structure members. In a fitting end to <span class="chapterintro_Xref-1"><a href="part2.xhtml">Part II</a></span>, you’ll draw on many of the skills, concepts, and techniques you learned in earlier chapters. In the identifier resolution stage, you’ll resolve structure tags along with function and variable identifiers. In the type checker, you’ll record structure definitions in a type table, much like you already record function and variable declarations in the symbol table. During TACKY generation, you’ll build on the strategy you used in <span class="chapterintro_Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span> to handle operations on dereferenced pointers and other objects. And on the backend, you’ll implement the part of the System V calling convention that specifies how to pass structures as function parameters and return values. Since unions are a close cousin to structures, you might want to implement those too. We won’t cover them in detail, but you can add them as an extra credit feature.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_486" aria-label="486"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-158"/><samp class="SANS_Futura_Std_Bold_B_11">Declaring Structure Types</samp></h3>&#13;
<p class="TNI">You have to declare a structure type before you can use it. There are two kinds of structure type declarations. The first, shown in <a href="chapter18.xhtml#list18-1">Listing 18-1</a>, specifies the structure’s members.</p>&#13;
<a id="list18-1"/>&#13;
<pre><code>struct complete_struct {&#13;
    long member1;&#13;
    double member2;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A complete structure type declaration</samp></p>&#13;
<p class="TX">This listing declares a complete structure type with two members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> is this type’s <i>tag</i>, which we can use to specify the type later in the program. A complete structure type must have at least one member, so it’s illegal to declare a structure type with an empty member list:</p>&#13;
<pre><code>struct empty {};</code></pre>&#13;
<p class="TX">The second kind of structure type declaration, shown in <a href="chapter18.xhtml#list18-2">Listing 18-2</a>, specifies a structure’s tag but not its members.</p>&#13;
<a id="list18-2"/>&#13;
<pre><code>struct incomplete_struct;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: An incomplete structure type declaration</samp></p>&#13;
<p class="TX"><a href="chapter18.xhtml#list18-2">Listing 18-2</a> declares an incomplete structure type. As you learned in the previous chapter, you can use incomplete types only in certain limited circumstances. For example, you can’t define a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>, but you can define a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>. (That’s because we know how much memory a pointer requires, but not how much memory this structure requires.) We’ll say that a structure declaration with no member list <i>declares</i> a type, while a structure declaration with a member list both <i>declares</i> and <i>defines</i> a type. This differs from the terminology you’ll see in the C standard and elsewhere; in particular, when people talk about “type definitions,” they usually mean aliases introduced with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> keyword.</p>&#13;
<p class="TX">Structure tags are visible only in the scope in which they’re declared, just like function and variable names. If a structure tag is declared at file scope, it’s visible from the point where it’s declared until the end of the file. If it’s declared at block scope, it’s visible until the end of the block. If two structure type declarations with the same tag appear in the same scope, they always declare the same type; if they appear in different scopes, they declare distinct types. (Type declarations don’t have linkage, so you can’t apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keywords to them.) You can declare the same structure type multiple times, but you can’t define it more than once.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_487" aria-label="487"/>A structure type is complete once its definition is in scope, as <a href="chapter18.xhtml#list18-3">Listing 18-3</a> illustrates.</p>&#13;
<a id="list18-3"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> struct s;&#13;
&#13;
struct s *ptr = 0;&#13;
&#13;
struct s {&#13;
    int a;&#13;
    int b;&#13;
}; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> struct s x = {0,0};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Declaring an incomplete type and then completing it</samp></p>&#13;
<p class="TX">Between <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is an incomplete type. It wouldn’t be legal to define a variable with type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> between these two points in the program, but it’s legal to define <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which is a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. After the end of the type declaration that specifies its member list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is a complete type, so it’s legal to define a variable with that type <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">When the same structure tag is declared in two different scopes, one can shadow the other, as <a href="chapter18.xhtml#list18-4">Listing 18-4</a> illustrates.</p>&#13;
<a id="list18-4"/>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> struct s {&#13;
    int a;&#13;
};&#13;
&#13;
int main(void) {&#13;
    printf("Outer struct size: %lu\n", <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> sizeof (struct s));&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> struct s {&#13;
        long l;&#13;
    };&#13;
&#13;
    printf("Inner struct size: %lu\n", <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> sizeof (struct s));&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-4: One structure type shadowing another</samp></p>&#13;
<p class="TX">First, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> type at file scope <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Its size is 4 bytes because it contains a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> refers to this type <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, we define another <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> type at block scope <span class="CodeAnnotation" aria-label="annotation3">❸</span>, shadowing the first type. This type contains a single <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, so its size is 8 bytes. The two definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> don’t conflict, because they appear in different scopes. In the second <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression <span class="CodeAnnotation" aria-label="annotation4">❹</span>, the specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> refers to the 8-byte <span role="doc-pagebreak" epub:type="pagebreak" id="pg_488" aria-label="488"/>structure type defined in the inner scope. Running this program gives the following output:</p>&#13;
<pre><code>$ ./listing_18_4&#13;
Outer struct size: 4&#13;
Inner struct size: 8</code></pre>&#13;
<p class="TX">Even when a structure’s tag is shadowed, its members are still visible. Consider <a href="chapter18.xhtml#list18-5">Listing 18-5</a>.</p>&#13;
<a id="list18-5"/>&#13;
<pre><code>int main(void) {&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> struct shadow {&#13;
        int x;&#13;
    };&#13;
    struct shadow outer;&#13;
    outer.x = 2;&#13;
    {&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> struct shadow {&#13;
            int y;&#13;
        };&#13;
        struct shadow inner;&#13;
        inner.y = 3;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return outer.x + inner.y;&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-5: Using a variable with a shadowed structure type</samp></p>&#13;
<p class="TX">In this listing, we first declare a structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we define a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>, with that type. In the inner scope, we declare another structure type with the same tag <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which shadows the outer declaration. We then declare a variable with this new type, <samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, we can still access the members of both variables <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Even in the inner scope, the compiler knows about the original <samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp> type, and it still knows that <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp> belongs to that type; we just can’t specify that type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp> tag.</p>&#13;
<p class="TX">To keep all our structure types straight, we’ll treat structure tags a lot like variable names: in the identifier resolution pass, we’ll replace each user-defined tag with a unique identifier.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-189"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Member Declarations</samp></h4>&#13;
<p class="TNI">The members of a structure can have any complete type, including primitive types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and derived types like arrays, pointers, or other structures. It’s illegal to declare a structure member with an incomplete type, however, because that makes it impossible to determine the size of the whole structure. This implies, as section 6.7.2.1, paragraph 3, of the C standard puts it, that “a structure shall not contain an instance of itself.” That <span role="doc-pagebreak" epub:type="pagebreak" id="pg_489" aria-label="489"/>is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> can’t contain a member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. On the other hand, a structure can contain a pointer to itself because pointer types are always complete. The canonical example, shown in <a href="chapter18.xhtml#list18-6">Listing 18-6</a>, is a node in a linked list, which holds a value and a pointer to the next list entry.</p>&#13;
<a id="list18-6"/>&#13;
<pre><code>struct linked_list_node <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> {&#13;
    int val;&#13;
    struct linked_list_node *next;&#13;
}; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6: A structure type definition that contains a pointer to itself</samp></p>&#13;
<p class="TX">After <span class="CodeAnnotation" aria-label="annotation1">❶</span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp> is visible as an incomplete type, so we can declare the member <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp> as a pointer to this type. After <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the type is complete.</p>&#13;
<p class="TX">It’s also illegal to declare functions as structure members. A structure can hold function pointers—which are complete types, just like any other pointer—but we don’t support function pointers, so that doesn’t matter to us.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tag and Member Namespaces</samp></h4>&#13;
<p class="TNI">Structure tags are in a different namespace from functions and variables. This means the same identifier can be used as both a tag and a function or variable name, and neither identifier will shadow or conflict with the other. It’s perfectly legal, for example, to declare the type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> in the same scope. It’s possible to maintain these separate namespaces because the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> keyword tells the compiler that a particular identifier is a structure tag.</p>&#13;
<p class="TX">Similarly, each structure member list is its own namespace. A structure member can share a name with any function, variable, or structure type, including the structure type that contains it, like in the following example:</p>&#13;
<pre><code>struct s {&#13;
    int s;&#13;
};</code></pre>&#13;
<p class="TX">It’s also legal for members in different structures to have the same name:</p>&#13;
<pre><code>struct s1 {&#13;
    int x;&#13;
};&#13;
&#13;
struct s2 {&#13;
    int x;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_490" aria-label="490"/>When the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> appears in an expression, like <samp class="SANS_TheSansMonoCd_W5Regular_11">var-&gt;x</samp>, the compiler can figure out from context whether it refers to the member in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, the member in <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>, or a function or variable. Unsurprisingly, it’s illegal for two members of the same structure to share a name.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-191"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Type Declarations We Aren’t Implementing</samp></h4>&#13;
<p class="TNI">C syntax doesn’t distinguish between structure type specifiers and type declarations, so you can simultaneously declare a new structure type and use that structure type in some larger construct. In <a href="chapter18.xhtml#list18-7">Listing 18-7</a>, for example, a single declaration defines a new structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.</p>&#13;
<a id="list18-7"/>&#13;
<pre><code>struct s {&#13;
    int member;&#13;
} x;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-7: Defining and specifying a structure type in the same declaration</samp></p>&#13;
<p class="TX">To simplify parsing and semantic analysis, we’ll require every declaration to declare exactly one function, variable, or type. We won’t support declarations like <a href="chapter18.xhtml#list18-7">Listing 18-7</a> that declare a new type and some other entity at the same time. This goes for incomplete types as well. The C standard lets you implicitly declare an incomplete structure type, just by specifying it:</p>&#13;
<pre><code>struct s *f(void);</code></pre>&#13;
<p class="TX">Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> hasn’t yet been declared, this declaration is legal: it simultaneously declares <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> as an incomplete type and declares a function that returns a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. However, our implementation won’t permit this. Instead, we’ll require a separate declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> first:</p>&#13;
<pre><code>struct s;&#13;
struct s *f(void);</code></pre>&#13;
<p class="TX">Requiring types to be declared before they’re used also implies that you can’t nest one structure declaration inside another, like in <a href="chapter18.xhtml#list18-8">Listing 18-8</a>.</p>&#13;
<a id="list18-8"/>&#13;
<pre><code>struct outer {&#13;
    struct inner {&#13;
        int a;&#13;
        long l;&#13;
    } i;&#13;
    double d;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-8: Declaring an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">inner</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">structure type and declaring member</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with that type in the same declaration</samp></p>&#13;
<p class="TX">We’ll impose a few other restrictions too. We’ll reject structure declarations without tags and structure members without names, even though <span role="doc-pagebreak" epub:type="pagebreak" id="pg_491" aria-label="491"/>the C standard permits them. We also won’t support <i>bit-field members</i>, which make it possible to address individual bits within a structure.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-159"/><samp class="SANS_Futura_Std_Bold_B_11">Operating on Structures</samp></h3>&#13;
<p class="TNI">You can access the members of a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operator:</p>&#13;
<pre><code>struct s var;&#13;
<var>--snip--</var>&#13;
long l = var.member1;</code></pre>&#13;
<p class="TX">If you have a pointer to a structure, you can access the structure’s members with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator. Continuing with the same example:</p>&#13;
<pre><code>struct s *ptr = &amp;var;&#13;
long l2 = ptr-&gt;member1;</code></pre>&#13;
<p class="TX">You can apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operators only to complete structure types. You can’t access the members of an incomplete structure type, since those members haven’t been defined yet.</p>&#13;
<p class="TX">Structures are aggregate types, like arrays. But structures don’t decay to pointers like arrays do, so you can use them in several ways that you can’t use arrays. For example, you can pass them as function arguments and return values. You can also assign to them, like in <a href="chapter18.xhtml#list18-9">Listing 18-9</a>.</p>&#13;
<a id="list18-9"/>&#13;
<pre><code>struct s foo;&#13;
struct s bar;&#13;
<var>--snip--</var>&#13;
foo = bar;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-9: Assigning to a structure</samp></p>&#13;
<p class="TX">You can assign to individual members of a structure too, as long as they’re lvalues. A structure member specified with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator is always an lvalue:</p>&#13;
<pre><code>ptr-&gt;member2 = 2.0;</code></pre>&#13;
<p class="TX">Recall that all dereferenced pointers are lvalues. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator produces a dereferenced pointer, much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operators do, so the same rules apply.</p>&#13;
<p class="TX">If a structure is an lvalue, any members you access with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operator are lvalues too. If a structure isn’t an lvalue, neither are its members. Therefore, this assignment expression is legal:</p>&#13;
<pre><code>var.member2 = 2.0;</code></pre>&#13;
<p class="TX">But, because the result of a function call isn’t an lvalue, this is illegal:</p>&#13;
<pre><code>return_struct().member2 = 2.0;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_492" aria-label="492"/>Structures can appear in a few other expressions, pretty much where you’d expect. They can appear in the branches of conditional expressions, as long as both branches have the same structure type. You can get their size with <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> and cast them to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, but you can’t otherwise cast to or from structure types. And if a structure or structure member is an lvalue, you can take its address.</p>&#13;
<p class="TX">There are two ways to initialize a structure. You can initialize it with an expression of the same structure type:</p>&#13;
<pre><code>struct s return_struct(void);&#13;
struct s var = return_struct();</code></pre>&#13;
<p class="TX">Or, you can use a compound initializer to initialize each member individually, like in <a href="chapter18.xhtml#list18-10">Listing 18-10</a>.</p>&#13;
<a id="list18-10"/>&#13;
<pre><code>struct example {&#13;
    int member1;&#13;
    double member2;&#13;
    char array[3];&#13;
};&#13;
&#13;
struct example var = {1, 2.0, <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> {'a', 'b', 'c'}};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-10: Initializing a structure with a compound initializer</samp></p>&#13;
<p class="TX">A compound initializer initializes a structure’s members in order. The initializer in <a href="chapter18.xhtml#list18-10">Listing 18-10</a> initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>. The inner compound initializer initializes the three array elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">array_member</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Note that compound initializers for arrays and structures have identical syntax. (The syntax for <i>designated initializers</i>, which initialize specific subobjects in an aggregate object, is different for array elements and structure members, but we won’t implement designated initializers.) By nesting compound initializers, you can initialize arrays of structures, structures that contain other structures, and so on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-160"/><samp class="SANS_Futura_Std_Bold_B_11">Structure Layout in Memory</samp></h3>&#13;
<p class="TNI">At this point, we have a pretty good sense of how structure types work in source code. Now let’s look at how they’re laid out in memory at runtime. This is specified partly by the C standard and partly by the System V ABI. It’s important to lay out structures exactly as the ABI specifies so that the code we compile can interoperate with other code that uses structures.</p>&#13;
<p class="TX">A structure’s members appear in the same order in memory as in the original structure declaration. The first member must have the same address as the structure as a whole; you can always convert a pointer to a structure into a pointer to its first member, and vice versa. Each subsequent member will be stored at the earliest free address with the correct alignment. Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp> type from <a href="chapter18.xhtml#list18-10">Listing 18-10</a> as an example. <a href="chapter18.xhtml#list18-11">Listing 18-11</a> reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>.</p>&#13;
<a id="list18-11"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_493" aria-label="493"/>struct example {&#13;
    int member1;&#13;
    double member2;&#13;
    char array[3];&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-11: A structure type with several members with different alignments</samp></p>&#13;
<p class="TX">The first member must start at the very beginning of the structure. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it occupies the structure’s first 4 bytes. Bytes in a structure are typically zero-indexed, so we’ll say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> occupies bytes 0 through 3. The next unused space is therefore at byte 4. But <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, which is 8-byte aligned; its starting address must be a multiple of 8. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> will be stored in bytes 8 through 15. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> has an offset of 8 bytes from the start of the structure. Between <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>, in bytes 4 through 7, we have 4 bytes of padding.</p>&#13;
<p class="TX">The last member, <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>, takes up 3 bytes and has an alignment of 1 byte. Since we don’t need any padding to align it correctly, we’ll store it right after <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>, in bytes 16 through 18.</p>&#13;
<p class="TX">We’ll also need padding at the end of the structure, after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>. According to the System V ABI, the size of a type must be a multiple of its alignment. The ABI also states that a structure takes on the same alignment as its most strictly aligned member. The most strictly aligned member of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>. Therefore, the whole structure must be 8-byte aligned, and its size must be a multiple of 8. The three members of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp> and the padding between them occupy 19 bytes. We’ll add 5 bytes of padding to the end of the structure, bringing its total size to 24 bytes. <a href="#fig18-1">Figure 18-1</a> illustrates the layout of the whole structure.</p>&#13;
<figure class="IMG"><img class="img100" id="fig18-1" src="../images/fig18-1.jpg" alt="" width="1629" height="337"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: The structure layout in memory <a href="description-43.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The padding between members guarantees that each member will end up at a correctly aligned memory address. If the starting address of the entire structure is a multiple of 8 and the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> from the start is also a multiple of 8, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>’s runtime memory address will be a multiple of 8 too. The padding at the end of the structure guarantees that each element in an array of structures will have the correct alignment; if the initial element in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp> objects is 8-byte aligned and its total size is 24 bytes, each subsequent element will be 8-byte aligned as well.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_494" aria-label="494"/>Now that you understand how to work with structures in C and how they’re laid out in memory, let’s get to work on implementing them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-161"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add three new tokens in this chapter:</p>&#13;
<table class="Basic-Table-ind">&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A keyword indicating a structure type specifier</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A period, the structure member access operator</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-&gt;</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">An arrow, the operator to access a structure member through a pointer</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Keep in mind that a period can be either a structure member access operator or part of a floating-point constant. We’ll recognize a period as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> token only if it’s followed by a non-digit character. If a period is followed by a digit, either it’s the start of a floating-point constant or it’s invalid. For example, if the lexer sees the input <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>, it should try to parse this as a constant. It will then raise an error, since this doesn’t match the regular expression for any kind of constant. It should <i>not</i> lex this as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> token followed by the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>.</p>&#13;
<aside class="box" aria-label="box-61"><p class="BoxTitle" id="box-61"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 18 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The lexer should reject the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/invalid_lex</samp><samp class="SANS_Futura_Std_Book_11">; these include</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> <samp class="SANS_Futura_Std_Book_11">characters that are followed by digits but aren’t part of valid floating-point constants. The lexer should accept all the other test programs in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-162"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">We’ll add several new constructs to the AST in this chapter: structure declarations, structure type specifiers, and the two new structure operators. <a href="chapter18.xhtml#list18-12">Listing 18-12</a> gives the AST definition for structure declarations.</p>&#13;
<a id="list18-12"/>&#13;
<pre><code>struct_declaration = (identifier tag, member_declaration* members)&#13;
member_declaration = (identifier member_name, type member_type)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-12: Representing structure declarations in the AST</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> consists of a tag and a list of members. To represent an incomplete structure type declaration, we’ll leave the member list empty. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_495" aria-label="495"/>(Remember that a complete structure type must have at least one member.) We’ll represent each member with a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp>, which includes a member name and a type.</p>&#13;
<p class="TX">Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST node to support structure type declarations as well as function and variable declarations:</p>&#13;
<pre><code>declaration = <var>--snip--</var> | StructDecl(struct_declaration)</code></pre>&#13;
<p class="TX">We’ll also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node to include structure type specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>:</p>&#13;
<pre><code>type =<var> --snip-- </var>| Structure(identifier tag)</code></pre>&#13;
<p class="TX">Finally, we’ll add two new expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operators, sometimes called the <i>structure member operator</i> and <i>structure pointer operator</i>, respectively. We’ll use the more concise names <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>:</p>&#13;
<pre><code>exp =<var> --snip--</var>&#13;
    | Dot(exp structure, identifier member)&#13;
    | Arrow(exp pointer, identifier member)</code></pre>&#13;
<p class="TX">Each of these operators takes an expression as its first operand and the name of a structure member as its second operand. <a href="chapter18.xhtml#list18-13">Listing 18-13</a> defines the complete AST, with this chapter’s changes bolded.</p>&#13;
<a id="list18-13"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
<b>            | StructDecl(struct_declaration)</b>&#13;
variable_declaration = (identifier name, initializer? init,&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
<b>struct_declaration = (identifier tag, member_declaration* members)</b>&#13;
<b>member_declaration = (identifier member_name, type member_type)</b>&#13;
initializer = SingleInit(exp) | CompoundInit(initializer*)&#13;
type = Char | SChar | UChar | Int | Long | UInt | ULong | Double | Void&#13;
     | FunType(type* params, type ret)&#13;
     | Pointer(type referenced)&#13;
     | Array(type element, int size)&#13;
<b>     | Structure(identifier tag)</b>&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp?)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_496" aria-label="496"/>          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | String(string)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
    | Dereference(exp)&#13;
    | AddrOf(exp)&#13;
    | Subscript(exp, exp)&#13;
    | SizeOf(exp)&#13;
    | SizeOfT(type)&#13;
<b>    | Dot(exp structure, identifier member)</b>&#13;
<b>    | Arrow(exp pointer, identifier member)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double) | ConstChar(int) | ConstUChar(int)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-13: The abstract syntax tree with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-&gt;</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp></p>&#13;
<p class="TX"><a href="chapter18.xhtml#list18-14">Listing 18-14</a> shows the corresponding changes to the grammar.</p>&#13;
<a id="list18-14"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt; <b>| &lt;struct-declaration&gt;</b>&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; ["=" &lt;initializer&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; (&lt;block&gt; | ";")&#13;
<b>&lt;struct-declaration&gt; ::= "struct" &lt;identifier&gt; </b><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><b> ["{" {&lt;member-declaration&gt;}+ "}"] ";"</b>&#13;
<b>&lt;member-declaration&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt; ";"</b>&#13;
&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;&#13;
&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;declarator-suffix&gt;]&#13;
&lt;declarator-suffix&gt; ::= &lt;param-list&gt; | {"[" &lt;const&gt; "]"}+&#13;
&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"&#13;
&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;&#13;
&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" | "double" | "char" | "void"&#13;
                   <b>| "struct" &lt;identifier&gt;</b>&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;initializer&gt; ::= &lt;exp&gt; | "{" &lt;initializer&gt; {"," &lt;initializer&gt;} [","] "}"&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" [&lt;exp&gt;] ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_497" aria-label="497"/>              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;cast-exp&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;cast-exp&gt; ::= "(" &lt;type-name&gt; ")" &lt;cast-exp&gt;&#13;
             | &lt;unary-exp&gt;&#13;
&lt;unary-exp&gt; ::= &lt;unop&gt; &lt;cast-exp&gt;&#13;
              | "sizeof" &lt;unary-exp&gt;&#13;
              | "sizeof" "(" &lt;type-name&gt; ")"&#13;
              | &lt;postfix-exp&gt;&#13;
&lt;type-name&gt; ::= {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;]&#13;
&lt;postfix-exp&gt; ::= &lt;primary-exp&gt; {<b>&lt;postfix-op&gt;}</b>&#13;
<b>&lt;postfix-op&gt; ::= "[" &lt;exp&gt; "]"</b>&#13;
<b>               | "." &lt;identifier&gt;</b>&#13;
<b>               | "-&gt;" &lt;identifier&gt;</b>&#13;
&lt;primary-exp&gt; ::= &lt;const&gt; | &lt;identifier&gt; | "(" &lt;exp&gt; ")" | {&lt;string&gt;}+&#13;
                | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]&#13;
                        | &lt;direct-abstract-declarator&gt;&#13;
&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")" {"[" &lt;const&gt; "]"}&#13;
                               | {"[" &lt;const&gt; "]"}+&#13;
&lt;unop&gt; ::= "-" | "~" | "!" | "*" | "&amp;"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; | &lt;double&gt; | &lt;char&gt;&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;string&gt; ::= ? A string token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;char&gt; ::= ? A char token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
&lt;double&gt; ::= ? A floating-point constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-14: The grammar with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-&gt;</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;struct-declaration&gt;</samp> may include a brace-enclosed list of structure members <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This member list is optional, but if the braces are present they must contain at least one member.</p>&#13;
<p class="TX">A structure member declaration has the same form as a variable declaration; it includes a list of type specifiers and a declarator and ends with a semicolon. Unlike a variable declaration, however, a structure member can’t have an initializer or a storage class. We’ll impose one syntactic requirement that isn’t reflected in the grammar: the parser should reject function declarators in structure member declarations, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;member -declaration&gt;</samp> grammar rule allows them. For example, the parser should reject this declaration:</p>&#13;
<pre><code>struct contains_function {&#13;
    int foo(void);&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_498" aria-label="498"/>A structure type specifier consists of two tokens: the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> keyword and an identifier token, which specifies the structure tag. This specifier can’t be combined with other type specifiers, but it can be modified by a pointer, array, or function declarator.</p>&#13;
<p class="TX">The new <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operators are postfix operators, like the subscript operator we added in <span class="Xref-1"><a href="chapter15.xhtml">Chapter 15</a></span>. All three postfix operators have higher precedence than any prefix operator. The new <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;postfix-op&gt;</samp> symbol includes all three operators, which ensures that they’re all parsed with the correct precedence.</p>&#13;
<aside class="box" aria-label="box-62"><p class="BoxTitle" id="box-62"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 18 --stage parse</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-163"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">We haven’t made any substantive changes to the identifier resolution pass in a while. Now we’ll have it resolve structure tags along with function and variable names. This pass will assign every structure type a unique ID, replacing its original user-defined tag. It will also throw an error if a program tries to specify a structure type before declaring it.</p>&#13;
<p class="TX">In the type checker, we’ll introduce a new table to track structure definitions. We’ll refer to these definitions when we type check initializers, member access operators, and other operations on structures. We’ll also use them to generate TACKY and assembly in later stages.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-192"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Structure Tags</samp></h4>&#13;
<p class="TNI">Let’s walk through how to handle structure tags during identifier resolution. We’ll rename these tags in basically the same way that we rename local variables. We’ll maintain a map from user-defined tags to unique identifiers. When we find a declaration of a new structure type, we’ll generate a new identifier and add it to the map. And when we encounter a structure type specifier, we’ll replace it with the corresponding unique identifier from the map. Because structure tags exist in a separate namespace from functions and variables, we’ll track them in a separate map.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Structure Tag Map</samp></h5>&#13;
<p class="TNI">In our existing identifier map, we track three pieces of information about each user-defined function or variable name: the unique identifier we’ll replace it with, whether it has linkage, and whether it was defined in the current scope. In the structure tag map, we’ll track each tag’s unique <span role="doc-pagebreak" epub:type="pagebreak" id="pg_499" aria-label="499"/>identifier and whether it was defined in the current scope, but we won’t track linkage, because that concept doesn’t apply to types. Go ahead and define this data structure. Then, we’ll look at how to resolve tags in type specifiers and declarations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Type Specifiers</samp></h5>&#13;
<p class="TNI"><a href="chapter18.xhtml#list18-15">Listing 18-15</a> illustrates how to resolve a type specifier.</p>&#13;
<a id="list18-15"/>&#13;
<pre><code>resolve_type(type_specifier, structure_map):&#13;
    match type_specifier with&#13;
    | Structure(tag) -&gt;&#13;
        if tag is in structure_map:&#13;
            unique_tag = structure_map.get(tag).new_tag&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> return Structure(unique_tag)&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> fail("Specified an undeclared structure type")&#13;
    | Pointer(referenced_t) -&gt;&#13;
        resolved_t = resolve_type(referenced_t, structure_map)&#13;
        return Pointer(resolved_t)&#13;
    | Array(elem_t, size) -&gt; &#13;
        <var>--snip--</var>&#13;
    | FunType(param_ts, ret_t) -&gt; &#13;
        <var>--snip--</var>&#13;
    | t -&gt; return t</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-15: Replacing structure tags in a type specifier</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> function accepts a type specifier and returns a copy of that specifier in which any structure tags have been replaced with unique IDs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> encounters a structure type, it replaces the tag with the corresponding identifier from <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the tag isn’t in <samp class="SANS_TheSansMonoCd_W5Regular_11">structure _map</samp>, the structure hasn’t been declared yet, so it throws an error <span class="CodeAnnotation" aria-label="annotation2">❷</span>. To resolve a derived type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>, we resolve its constituent types recursively. I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>, which we’ll handle the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>. We return any other type unchanged. We’ll process every type specifier in the AST with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>, including specifiers in function and variable declarations, cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions, and structure member declarations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Structure Type Declarations</samp></h5>&#13;
<p class="TNI">Next, let’s look at the pseudocode in <a href="chapter18.xhtml#list18-16">Listing 18-16</a>, which illustrates how to resolve a structure type declaration.</p>&#13;
<a id="list18-16"/>&#13;
<pre><code>resolve_structure_declaration(decl, structure_map):&#13;
    prev_entry = structure_map.get(decl.tag) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    if (prev_entry is null) or (not prev_entry.from_current_scope):&#13;
        unique_tag = make_temporary()&#13;
        structure_map.add(decl.tag, MapEntry(new_tag=unique_tag, from_current_scope=True)) <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    else:&#13;
        unique_tag = prev_entry.new_tag <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    processed_members = []&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_500" aria-label="500"/>    for member in decl.members:&#13;
        processed_type = resolve_type(member.member_type, structure_map) <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
        processed_member = (member_name=member.member_name, member_type=processed_type)&#13;
        processed_members.append(processed_member)&#13;
    resolved_decl = (tag=unique_tag, members=processed_members)&#13;
    return resolved_decl <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: Adding structure type declarations to the structure tag map</samp></p>&#13;
<p class="TX">First, we look up the declaration’s tag in the structure tag map <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If this tag hasn’t been declared yet, or if it was declared in an outer scope, this declaration introduces a new type. We therefore generate a new identifier and add it to the structure tag map <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the structure’s tag was already declared in the current scope, the current declaration just redeclares the same type. In this case, we don’t generate a new unique ID; instead, we use the one that’s already in the map <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">At this point, the structure tag map is up to date. Now we transform the structure type declaration itself. If this declaration specifies the structure’s members, we resolve its member types by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> on each of them <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We replace the declaration’s user-defined tag with <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>, the ID that we generated or looked up earlier in the function. Finally, we return the transformed declaration <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Note that we add the new tag to <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> before processing any structure members. This lets us accept self-referential structures, like the linked list node from <a href="chapter18.xhtml#list18-6">Listing 18-6</a>:</p>&#13;
<pre><code>struct linked_list_node {&#13;
    int val;&#13;
    struct linked_list_node *next;&#13;
};</code></pre>&#13;
<p class="TX">Also note that we don’t generate unique names for structure members. Variables and functions need unique identifiers because they’re all stored in a single symbol table, and structure tags need to be unique because they’re all stored in a single type table, but structure members won’t all be stored in one table. Instead, we’ll maintain a separate member list for each structure type, so members in different structures with the same name won’t conflict with each other.</p>&#13;
<p class="TX">We’ll make two more updates to the identifier resolution pass. First, at the start of each new scope, we’ll make a copy of the structure tag map with each entry’s <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp> attribute set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, just like we do for the identifier map. The second change is purely mechanical: we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to process the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp> expressions the same way it processes all the other kinds of expressions. I’ll skip the pseudocode for these changes, since they’re both straightforward.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Structures</samp></h4>&#13;
<p class="TNI">Much like the type checker records information about every function and variable in the symbol table, it will also record information about every complete structure type in the <i>type table</i>. Let’s start by defining the type <span role="doc-pagebreak" epub:type="pagebreak" id="pg_501" aria-label="501"/>table; then, we’ll look at how to convert structure type declarations to type table entries. Finally, we’ll use the information in the type table to type check declarations, expressions, and initializers.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Type Table</samp></h5>&#13;
<p class="TNI">The type table maps the structure tags we generated in the previous stage to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> constructs. <a href="chapter18.xhtml#list18-17">Listing 18-17</a> defines <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>.</p>&#13;
<a id="list18-17"/>&#13;
<pre><code>struct_entry = StructEntry(int alignment, int size, member_entry* members)&#13;
member_entry = MemberEntry(identifier member_name, type member_type, int offset)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-17: An entry in the type table</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> describes a structure type’s alignment, size, and members. We describe each member with a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> construct, which specifies the member’s name, its type, and its offset in bytes from the start of the structure. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> should support two different ways of accessing <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>: looking up specific members by name and getting the whole list of members in order. You might want to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp> as an ordered dictionary if your implementation language supports it.</p>&#13;
<p class="TX">Like the symbol table, the type table should be a global variable or singleton that you can easily access from any stage of the compiler. (We’ll pass it explicitly in this section’s pseudocode for the sake of clarity.)</p>&#13;
<p class="TX">Next, we’ll see how to add structure definitions to the type table as we traverse the AST.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Populating the Type Table</samp></h5>&#13;
<p class="TNI">When the type checker encounters a definition of a complete structure type, it should validate the definition, then convert it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> and add it to the type table. The type checker can ignore any structure type declaration without a member list; a declaration with no member list either declares an incomplete type or redeclares a type that was already defined.</p>&#13;
<p class="TX">To validate a structure type definition, we’ll start by checking whether this structure is in the type table already. If it is, that means there’s another definition of the same tag in the same scope, so we’ll throw an error. Then, we’ll make sure that no members of the structure share the same name, that no member has an incomplete type, and that no member type specifies an array with an incomplete element type. (Remember that arrays of incomplete type are illegal everywhere, not just in structure definitions.) You might also want to validate that no structure members have function type, but it isn’t strictly necessary since we already validated that during parsing.</p>&#13;
<p class="TX">After validating that a structure type satisfies all these requirements, we’ll calculate each member’s offset and the whole structure’s size and alignment. Earlier in the chapter, we saw how to perform these calculations and walked through an example. Now let’s look at <a href="chapter18.xhtml#list18-18">Listing 18-18</a>, which demonstrates the whole process in pseudocode.</p>&#13;
<a id="list18-18"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_502" aria-label="502"/>typecheck_struct_declaration(struct_decl, type_table):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if struct_decl.members is empty:&#13;
        return&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> validate_struct_definition(struct_decl, type_table)&#13;
&#13;
    // define a member_entry for each member&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> member_entries = []&#13;
    struct_size = 0&#13;
    struct_alignment = 1&#13;
    for member in struct_decl.members:&#13;
        member_alignment = alignment(member.member_type, type_table)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> member_offset = round_up(struct_size, member_alignment)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> m = MemberEntry(member.member_name, member.member_type,&#13;
                        member_offset)&#13;
        member_entries.append(m)&#13;
        struct_alignment = max(struct_alignment, member_alignment)&#13;
        struct_size = member_offset + size(member.member_type, type_table)&#13;
&#13;
    // define a struct_entry for the whole structure&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> struct_size = round_up(struct_size, struct_alignment)&#13;
    struct_def = StructEntry(struct_alignment, struct_size, member_entries)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> type_table.add(struct_decl.tag, struct_def)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-18: Calculating a structure definition</samp></p>&#13;
<p class="TX">We start by checking whether this declaration includes a member list <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it doesn’t, we return immediately, without making any changes to the type table. If it does have a member list, we validate that it meets the requirements described earlier in this section <span class="CodeAnnotation" aria-label="annotation2">❷</span>. I won’t give you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_struct_definition</samp>, since it isn’t too complicated.</p>&#13;
<p class="TX">Then, we get to the interesting part: figuring out each member’s layout in memory. Here, we’ll define a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> for each structure member <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As we go, we’ll maintain a running total of the structure’s size in bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>. We’ll also track the strictest member alignment we’ve seen so far as <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>.</p>&#13;
<p class="TX">To calculate a structure member’s offset, we take the next available offset, which is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>, and round it up to that member’s alignment <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (We’ll walk through how to look up each type’s size and alignment in a moment.) We construct its <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, then update <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.</p>&#13;
<p class="TX">Once we’ve processed every member, we calculate the structure’s total size by rounding <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp> up to the nearest multiple of its alignment <span class="CodeAnnotation" aria-label="annotation6">❻</span>. This rounded-up size will account for any padding at the end of the structure. Finally, we add the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> to the type table <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Structures in Helper Functions</samp></h5>&#13;
<p class="TNI">We’ve centralized a lot of type checking logic into a handful of helper functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>. You’ve probably also written a few helper functions to look up each type’s size, alignment, and other <span role="doc-pagebreak" epub:type="pagebreak" id="pg_503" aria-label="503"/>properties, although I haven’t provided pseudocode for those yet. Now we’ll extend these helpers to handle structure types too.</p>&#13;
<p class="TX">We defined <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> back in <span class="Xref-1"><a href="chapter17.xhtml#list17-12">Listing 17-12</a></span>. <a href="chapter18.xhtml#list18-19">Listing 18-19</a> gives the updated definition, with this chapter’s addition bolded.</p>&#13;
<a id="list18-19"/>&#13;
<pre><code>is_scalar(t):&#13;
    match t with&#13;
    | Void -&gt; return False&#13;
    | Array(elem_t, size) -&gt; return False&#13;
    | FunType(param_ts, ret_t) -&gt; return False&#13;
<b>    | Structure(tag) -&gt; return False</b>&#13;
    | _ -&gt; return True</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-19: Checking whether a type is scalar</samp></p>&#13;
<p class="TX">Structure types aren’t scalar, so this is pretty simple. I’m guessing you’ve written similar helper functions to test whether a type is arithmetic, whether it’s an integer type, and so on. These will require similarly straightforward updates, which we won’t get into here.</p>&#13;
<p class="TX">Updating <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> is slightly more involved; we’ll need to consult the type table. <a href="chapter18.xhtml#list18-20">Listing 18-20</a> gives the new definition of this function.</p>&#13;
<a id="list18-20"/>&#13;
<pre><code>is_complete(t, type_table):&#13;
    match t with&#13;
    | Void -&gt; return False&#13;
    | Structure(tag) -&gt;&#13;
        if tag is in type_table:&#13;
            return True&#13;
        else:&#13;
            return False&#13;
    | _ -&gt; return True</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-20: Checking whether a type is complete</samp></p>&#13;
<p class="TX">If a structure type is in the type table, it’s complete; if not, it’s incomplete. As we saw earlier, a structure type may be incomplete at one point in the program but complete later on. During type checking, the type table tells us whether the structure type is complete at the current point in the AST. Consider the code fragment in <a href="chapter18.xhtml#list18-21">Listing 18-21</a>.</p>&#13;
<a id="list18-21"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> struct s;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> struct t {&#13;
    struct s member;&#13;
};&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> struct s {&#13;
    int a;&#13;
    int b;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-21: Declaring a variable with an incomplete structure type</samp></p>&#13;
<p class="TX">Because the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> doesn’t specify any members, we won’t add it to the type table. Then, when we validate the definition of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_504" aria-label="504"/><samp class="SANS_TheSansMonoCd_W5Regular_11">struct t</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we’ll look up <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> in the type table. (Strictly speaking, we’ll look up the unique identifier that replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> during the identifier resolution stage.) When we don’t find it, we’ll correctly conclude that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is incomplete and throw an error. If the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct t</samp> appeared after the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we’d add <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> to the type table before processing <samp class="SANS_TheSansMonoCd_W5Regular_11">struct t</samp>, so we wouldn’t throw an error.</p>&#13;
<p class="TX">We also need helper functions to find a type’s size and alignment. <a href="chapter18.xhtml#list18-22">Listing 18-22</a> shows the pseudocode for the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> function.</p>&#13;
<a id="list18-22"/>&#13;
<pre><code>alignment(t, type_table):&#13;
    match t with&#13;
    | Structure(tag) -&gt;&#13;
        struct_def = type_table.get(tag)&#13;
        return struct_def.alignment&#13;
    | Array(elem_t, size) -&gt;&#13;
        return alignment(elem_t, type_table)&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-22: Calculating a type’s alignment</samp></p>&#13;
<p class="TX">To find a structure’s alignment, we’ll look it up in the type table. To find an array’s alignment, we’ll recursively calculate the alignment of its element type. We’ll hardcode the alignments of other types, which are dictated by the ABI. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>, which will look similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>We learned earlier that if a variable of array type is 16 bytes or larger, it must be 16-byte aligned. <a href="chapter18.xhtml#list18-22">Listing 18-22</a> doesn’t reflect this requirement because it calculates the alignment of types, not variables. You’ll probably want to write a different helper function to calculate the alignment of variables, if you haven’t already.</i></p>&#13;
<p class="TX">The other helper functions we defined in earlier chapters should handle structures correctly without any changes. Consider <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>, which we use to type check assignment expressions and other places where we convert a value to a specific type “as if by assignment.” <a href="chapter18.xhtml#list18-23">Listing 18-23</a> reproduces the latest version of this code from <span class="Xref-1"><a href="chapter17.xhtml#list17-11">Listing 17-11</a></span>.</p>&#13;
<a id="list18-23"/>&#13;
<pre><code>convert_by_assignment(e, target_type):&#13;
    if get_type(e) == target_type:&#13;
        return e&#13;
    if get_type(e) is arithmetic and target_type is arithmetic:&#13;
        return convert_to(e, target_type)&#13;
    if is_null_pointer_constant(e) and target_type is a pointer type:&#13;
        return convert_to(e, target_type)&#13;
    if target_type == Pointer(Void) and get_type(e) is a pointer type:&#13;
        return convert_to(e, target_type)&#13;
    if target_type is a pointer type and get_type(e) == Pointer(Void):&#13;
        return convert_to(e, target_type)&#13;
    else:&#13;
        fail("Cannot convert type for assignment")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-23: Converting an expression to a target type</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_505" aria-label="505"/>If we pass <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> an expression that already has the correct structure type, it will return the expression unchanged. In any other case with a source or target structure type, it will fail. That’s the correct behavior, since there’s no way to convert to or from a structure type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Incomplete Structure Types</samp></h5>&#13;
<p class="TNI">We need to enforce several restrictions on incomplete structure types. First, we’ll validate the use of these types in declarations; then, we’ll validate their use in expressions.</p>&#13;
<p class="TX">It’s legal to declare, but not define, a function with parameters or a return value of incomplete structure type. (Remember that a function definition is a function declaration with a body.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is an incomplete type, the type checker should accept this declaration:</p>&#13;
<pre><code>void take_a_struct(struct s incomplete);</code></pre>&#13;
<p class="TX">But it should reject this definition:</p>&#13;
<pre><code>void take_a_struct(struct s incomplete) {&#13;
    return;&#13;
}</code></pre>&#13;
<p class="TX">Similarly, we’ll accept declarations of variables with incomplete structure type but reject any definitions of these variables, including tentative definitions. (This is more restrictive than the C standard, which permits tentative definitions of variables with incomplete types in certain limited circumstances.) Concretely, we’ll accept a variable declaration with an incomplete structure type only if it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class and no initializer.</p>&#13;
<p class="TX">That takes care of declarations; now let’s consider expressions. There’s exactly one way to use a variable with incomplete type in an expression. You can take its address, as the following example demonstrates:</p>&#13;
<pre><code>extern struct s my_incomplete_struct;&#13;
struct s *ptr = &amp;my_incomplete_struct;</code></pre>&#13;
<p class="TNI">You can then use <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> like any other pointer to an incomplete type.</p>&#13;
<p class="TX">Similarly, it’s legal (if not especially useful) to dereference a pointer to an incomplete structure and then take its address, resulting in the pointer you started with:</p>&#13;
<pre><code>struct s *another_ptr = &amp;*ptr;</code></pre>&#13;
<p class="TX">Any other use of an expression with an incomplete structure type is invalid. You can’t even cast it to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> or use it as an expression statement, so the type checker should reject both of the following statements:</p>&#13;
<pre><code>(void) my_incomplete_struct;&#13;
*ptr;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_506" aria-label="506"/>We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> to catch these invalid expressions. <a href="chapter18.xhtml#list18-24">Listing 18-24</a> gives the updated definition of this function, with changes from the original definition in <span class="Xref-1"><a href="chapter15.xhtml#list15-19">Listing 15-19</a></span> bolded.</p>&#13;
<a id="list18-24"/>&#13;
<pre><code>typecheck_and_convert(e, symbols, <b>type_table</b>):&#13;
    typed_e = typecheck_exp(e, symbols, <b>type_table</b>)&#13;
    match get_type(typed_e) with&#13;
    | Array(elem_t, size) -&gt;&#13;
<var>        --snip--</var>&#13;
<b>    | Structure(tag) -&gt;</b>&#13;
<b>        if tag is not in type_table:</b>&#13;
<b>            fail("Invalid use of incomplete structure type")</b>&#13;
<b>        return typed_e</b>&#13;
    | _ -&gt; return typed_e</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-24: Rejecting incomplete structure types in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp></p>&#13;
<p class="TX">Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> processes every expression in the AST except for static initializers (which must be constants) and the operands of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions (which don’t undergo array decay). This makes <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> the most convenient place to put the new validation, even though it has nothing to do with the function’s original purpose, which is to implicitly convert arrays to pointers. With this new validation in place, we’ll handle incomplete types correctly in every kind of expression: we’ll permit incomplete structure types in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions, our existing validation will reject all incomplete types (including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>) in <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will reject incomplete structure types everywhere else. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> still accepts void expressions, which are legal in several places where expressions with incomplete structure types are not.</p>&#13;
<p class="TX">We’ve already implemented all the other validation we need for incomplete types. For example, we already require the pointer operands in pointer arithmetic expressions to point to complete types, and we already require the element types in array type specifiers to be complete.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking the Member Access Operators</samp></h5>&#13;
<p class="TNI">Next, let’s type check the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operators. In both cases, we’ll validate the expression, figure out the member type, and record that as the type of the whole expression. <a href="chapter18.xhtml#list18-25">Listing 18-25</a> demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operator.</p>&#13;
<a id="list18-25"/>&#13;
<pre><code>typecheck_exp(e, symbols, type_table):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Dot(structure, member) -&gt;&#13;
        typed_structure = typecheck_and_convert(structure, symbols, type_table)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> match get_type(typed_structure) with&#13;
        | Structure(tag) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> struct_def = type_table.get(tag)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_507" aria-label="507"/>          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> member_def = <var>&lt;find member in struct_def.members&gt;</var>&#13;
            if member_def is not found:&#13;
                fail("Structure has no member with this name")&#13;
            member_exp = Dot(typed_structure, member)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> return set_type(member_exp, member_def.member_type)&#13;
        | _ -&gt; fail("Tried to get member of non-structure")&#13;
    | Arrow(pointer, member) -&gt;&#13;
        <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-25: Type checking the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp></p>&#13;
<p class="TX">We start by type checking the first operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>, with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> (which throws an error if <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> has an incomplete type). Then, we validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> really is a structure <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it is, we look up its type in the type table <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> in the resulting type table entry <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, we annotate the expression with the member type <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> isn’t a structure or doesn’t have a member with this name, we throw an error.</p>&#13;
<p class="TX">I won’t provide pseudocode for type checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator, since it’s nearly identical; the only difference is that we validate that the first operand is a pointer to a structure, rather than a structure itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Validating Lvalues</samp></h5>&#13;
<p class="TNI">An <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> expression is always an lvalue. To determine whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> expression is an lvalue, the type checker must recursively check whether its first operand is an lvalue. For example, the type checker should reject the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member = 3</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> isn’t an lvalue, <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member</samp> isn’t either.</p>&#13;
<p class="TX">This means we might encounter arrays that aren’t lvalues! It’s a type error to explicitly take the address of such an array, like in <a href="chapter18.xhtml#list18-26">Listing 18-26</a>.</p>&#13;
<a id="list18-26"/>&#13;
<pre><code>struct s {&#13;
    int arr[3];&#13;
};&#13;
&#13;
struct s f(void);&#13;
&#13;
int main(void) {&#13;
    int *pointer_to_array[3] = &amp;(f().arr);&#13;
<var>    --snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-26: Illegally taking the address of a non-lvalue</samp></p>&#13;
<p class="TX">However, these arrays still decay to pointers, so their addresses are still loaded implicitly. The program in <a href="chapter18.xhtml#list18-27">Listing 18-27</a>, for example, is entirely legal.</p>&#13;
<a id="list18-27"/>&#13;
<pre><code>struct s {&#13;
    int arr[3];&#13;
};&#13;
&#13;
struct s f(void);&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_508" aria-label="508"/>int main(void) {&#13;
    return f().arr[0];&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-27: Implicitly converting a non-lvalue array to a pointer</samp></p>&#13;
<p class="TX">When we type check this program, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to take the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp>, just like when we type check any other expression of array type.</p>&#13;
<aside class="box" aria-label="box-63"><p class="BoxTitle" id="box-63"><samp class="SANS_Dogma_OT_Bold_B_11">THE CURIOUS CASE OF TEMPORARY LIFETIMES</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">There’s something wonky happening here. The expression</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp> <samp class="SANS_Futura_Std_Book_11">isn’t an lvalue, but in order to have an address that we can load, it has to designate an object. Section 6.2.4, paragraph 8, of the C standard resolves this dilemma: “A non-lvalue expression with structure or union type, where the structure or union contains a member with array type … refers to an object with automatic storage duration and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">temporary lifetime</samp><samp class="SANS_Futura_Std_Book_11">.… Its lifetime ends when the evaluation of the containing full expression ends. Any attempt to modify an object with temporary lifetime results in undefined behavior.”</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">An object with temporary lifetime is similar to the temporary variables we create during TACKY generation. The compiler allocates it to hold the result of an expression, and it’s never used again after that expression is evaluated. The key difference is that it’s possible to get a pointer to an object with temporary lifetime in the source program. This makes it easy to inadvertently use that object after the end of its lifetime. Consider this example, which you might expect to be equivalent to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> <samp class="SANS_Futura_Std_Book_11">statement in <a href="chapter18.xhtml#list18-27">Listing 18-27</a>:</samp></p>&#13;
<pre><code>int *arr_pointer = f().arr;&#13;
return arr_pointer[0];&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The lifetime of the structure returned by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> <samp class="SANS_Futura_Std_Book_11">ends once we finish evaluating the expression</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp><samp class="SANS_Futura_Std_Book_11">. This means that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">arr_ptr</samp> <samp class="SANS_Futura_Std_Book_11">points to an object whose lifetime has ended, so subscripting it is undefined behavior.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structures in Conditional Expressions</samp></h5>&#13;
<p class="TNI">The type checker should accept conditional expressions where both branches have the same structure type. It should reject conditional expressions where only one branch has a structure type or where the branches have two different structure types. To determine whether two structure types are identical, compare their tags, not their contents.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_509" aria-label="509"/>&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structure Initializers</samp></h5>&#13;
<p class="TNI">Finally, we’ll deal with structure initializers. As you learned earlier in this chapter, you can initialize a structure either with a single expression of that structure type or with a compound initializer. The first case shouldn’t require any changes to the type checker.</p>&#13;
<p class="TX">To handle compound initializers, we’ll type check each item in the initializer list against the corresponding member type, as <a href="chapter18.xhtml#list18-28">Listing 18-28</a> demonstrates.</p>&#13;
<a id="list18-28"/>&#13;
<pre><code>typecheck_init(target_type, init, symbols, type_table):&#13;
    match target_type, init with&#13;
    | Structure(tag), CompoundInit(init_list) -&gt;&#13;
        struct_def = type_table.get(tag) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        if length(init_list) &gt; length(struct_def.members): <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            fail("Too many elements in structure initializer")&#13;
        i = 0&#13;
        typechecked_list = []&#13;
        for init_elem in init_list: <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            t = struct_def.members[i].member_type&#13;
            typechecked_elem = typecheck_init(t, init_elem, symbols, type_table)&#13;
            typechecked_list.append(typechecked_elem)&#13;
            i += 1&#13;
        while i &lt; length(struct_def.members): <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            t = struct_def.members[i].member_type&#13;
            typechecked_list.append(zero_initializer(t))&#13;
            i += 1&#13;
        return set_type(CompoundInit(typechecked_list), target_type)&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-28: Type checking compound initializers for structures</samp></p>&#13;
<p class="TX">We’ll start by looking up the structure in the type table <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We should have already validated that <samp class="SANS_TheSansMonoCd_W5Regular_11">target_type</samp> is complete before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck _init</samp>, so at this point it’s safe to assume that the structure has been defined. Next, we’ll make sure the initializer list isn’t too long <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Just like when we process array initializers, we’ll reject an initializer list with too many elements but accept one with too few elements to initialize the whole object.</p>&#13;
<p class="TX">After performing this check, we’ll iterate through the initializer list <span class="CodeAnnotation" aria-label="annotation3">❸</span>. To type check each initializer, we’ll look up the corresponding member type in the structure’s member list, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp> recursively to make sure the initializer is compatible with that type. Finally, we’ll pad out any uninitialized structure members with zeros <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Once you’ve updated <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>, you’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> to handle structure types. To initialize a structure to zero, <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> should call itself recursively for each member type and return the results in a compound initializer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing Static Structures</samp></h5>&#13;
<p class="TNI">If a structure has static storage duration, we’ll store its initial value as a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> list in the symbol table, just like we do for arrays. The key <span role="doc-pagebreak" epub:type="pagebreak" id="pg_510" aria-label="510"/>difference is that we’ll initialize any padding in the structure too. Let’s return to the example from <a href="chapter18.xhtml#list18-10">Listing 18-10</a>:</p>&#13;
<pre><code>struct example {&#13;
    int member1;&#13;
    double member2;&#13;
    char array[3];&#13;
};&#13;
&#13;
struct example var = {1, 2.0, {'a', 'b', 'c'}};</code></pre>&#13;
<p class="TX">We figured out that this structure included 4 bytes of padding between <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> and 5 bytes of padding after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> is a static variable, we’ll use the construct in <a href="chapter18.xhtml#list18-29">Listing 18-29</a> to represent its initial value.</p>&#13;
<a id="list18-29"/>&#13;
<pre><code>Initial([IntInit(1),&#13;
       <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> ZeroInit(4),&#13;
         DoubleInit(2.0),&#13;
         CharInit(97),&#13;
         CharInit(98),&#13;
         CharInit(99),&#13;
       <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> ZeroInit(5)])</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-29: Representing the initializer from <a href="chapter18.xhtml#list18-10">Listing 18-10</a> as a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">static_init</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">list</samp></p>&#13;
<p class="TX">We initialize padding with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> construct <span class="CodeAnnotation" aria-label="annotation1">❶</span><span class="CodeAnnotation" aria-label="annotation2">❷</span> because the C standard requires the padding in static structures to be initialized to zero. <a href="chapter18.xhtml#list18-30">Listing 18-30</a> demonstrates how to generate static initializer lists like the one in <a href="chapter18.xhtml#list18-29">Listing 18-29</a>.</p>&#13;
<a id="list18-30"/>&#13;
<pre><code>create_static_init_list(init_type, initializer, type_table):&#13;
    match init_type, initializer with&#13;
    | Structure(tag), CompoundInit(init_list) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> struct_def = type_table.get(tag)&#13;
        if length(init_list) &gt; length(struct_def.members):&#13;
            fail("Too many elements in structure initializer")&#13;
        current_offset = 0&#13;
        static_inits = []&#13;
        i = 0&#13;
        for init_elem in init_list:&#13;
            member = struct_def.members[i]&#13;
            if member.offset != current_offset:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> static_inits.append(ZeroInit(member.offset - current_offset))&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> more_static_inits = create_static_init_list(member.member_type,&#13;
                                                        init_elem,&#13;
                                                        type_table)&#13;
            static_inits.append_all(more_static_inits)&#13;
            current_offset = member.offset + size(member.member_type,&#13;
                                                  type_table)&#13;
            i += 1&#13;
        if struct_def.size != current_offset:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> static_inits.append(ZeroInit(struct_def.size - current_offset))&#13;
        return static_inits&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_511" aria-label="511"/>    | Structure(tag), SingleInit(e) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> fail("Cannot initialize static structure with scalar expression")&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-30: Generating a static initializer for a structure</samp></p>&#13;
<p class="TX">To process a compound initializer for a static structure, we first look up the structure in the type table <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We make sure the initializer list isn’t too long, just like we did for non-static initializers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>. Then, we iterate over the initializer list, looking up the corresponding member definition for each element in the structure’s member list. As we go, we update the <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp> variable to track how many bytes we’ve initialized so far.</p>&#13;
<p class="TX">Each time we process the initializer for a structure member, we first check whether we’ve initialized enough bytes to bring us up to the expected offset. If we haven’t, we add the necessary padding with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> initializer <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then create the initializer list for the structure member itself with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">create_static_init_list</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Next, we update <samp class="SANS_TheSansMonoCd_W5Regular_11">current _offset</samp> based on the offset and size of the member we just initialized.</p>&#13;
<p class="TX">Once we’ve initialized every structure member, we add another <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>, if necessary, to pad out the structure to the correct size <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This last <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> zeroes out any structure members that weren’t explicitly initialized as well as any trailing padding after the last member.</p>&#13;
<p class="TX">Because there are no constants of structure type, initializing a static structure with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> expression is a type error <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<aside class="box" aria-label="box-64"><p class="BoxTitle" id="box-64"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE SEMANTIC ANALYSIS STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the changes to identifier resolution and type checking, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 18 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You’ll find the invalid test cases for this stage in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/invalid _struct_tags</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter _18/invalid_struct_tags</samp> <samp class="SANS_Futura_Std_Book_11">refer to undeclared structure tags, so your compiler should reject them during identifier resolution. (Since the C standard doesn’t require you to declare structure tags before using them, a fully conforming compiler will reject these programs for different reasons, usually because they refer to incomplete types when complete types are required.)</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">cover all sorts of type errors, like conflicting definitions of the same structure, structure declarations with incomplete member types, and member access operations that refer to nonexistent members. Several of these programs are designed to test out</samp></p>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_512" aria-label="512"/><samp class="SANS_Futura_Std_Book_11">identifier resolution, even though they cause type errors. Here’s an example of this sort of test case:</samp></p>&#13;
<pre><code>struct s;&#13;
struct s *ptr1 = 0;&#13;
int main(void) {&#13;
    struct s;&#13;
    struct s *ptr2 = 0;&#13;
    return ptr1 == ptr2;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should reject this program during type checking because it compares pointers to two distinct types. But in order for the type checker to recognize that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> <samp class="SANS_Futura_Std_Book_11">point to distinct types, the identifier resolution pass needs to generate different IDs for the two declarations of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h1-164"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">In this section, we’ll introduce one last TACKY instruction:</p>&#13;
<pre><code>CopyFromOffset(identifier src, int offset, val dst)</code></pre>&#13;
<p class="TX">This instruction mirrors the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction we added back in <span class="Xref-1"><a href="chapter15.xhtml">Chapter 15</a></span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> identifier in <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> is the name of an aggregate variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> is the byte offset of a subobject within that variable, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is the variable we’ll copy that subobject to. <a href="chapter18.xhtml#list18-31">Listing 18-31</a> defines the complete TACKY IR, including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction.</p>&#13;
<a id="list18-31"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init* init_list)&#13;
          | StaticConstant(identifier, type t, static_init init)&#13;
instruction = Return(val?)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
            | DoubleToInt(val src, val dst)&#13;
            | DoubleToUInt(val src, val dst)&#13;
            | IntToDouble(val src, val dst)&#13;
            | UIntToDouble(val src, val dst)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | GetAddress(val src, val dst)&#13;
            | Load(val src_ptr, val dst)&#13;
            | Store(val src, val dst_ptr)&#13;
            | AddPtr(val ptr, val index, int scale, val dst)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_513" aria-label="513"/>            | CopyToOffset(val src, identifier dst, int offset)&#13;
            <b>| CopyFromOffset(identifier src, int offset, val dst)</b>&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val? dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-31: Adding</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyFromOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the TACKY IR</samp></p>&#13;
<p class="TX">Not only can you access subobjects in a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instructions, but you can also copy entire structures from one location to another using <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> or pass them between functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>, just like scalar variables. We’ll represent variables of structure type as ordinary TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s.</p>&#13;
<p class="TX">Next, we’ll convert the member access operators to TACKY. Then, we’ll process compound structure initializers. We won’t change how we process most constructs that can use structures, like function calls, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements, and conditional expressions. We also won’t need to do anything with the new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StructDecl</samp> construct; we’ll discard structure declarations at this stage, just like we discard function declarations without bodies and variable declarations without initializers.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-194"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the Member Access Operators</samp></h4>&#13;
<p class="TNI">In earlier chapters, you learned that you can use an object in one of three ways: you can lvalue convert it, assign to it, or take its address. Now there’s a fourth option: if the object is a structure, you can access one of its members. And because that structure member is itself an object, you can lvalue convert it, assign to it, take its address, or access one of <i>its</i> members. Let’s look at the TACKY we should generate in each of these cases. Then, building on the approach we used to handle dereferenced pointers in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>, we’ll introduce a new kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp> to designate structure members.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Structure Members in TACKY</samp></h5>&#13;
<p class="TNI">To implement any sort of operation on a structure member, we’ll start by looking up the member’s offset in the type table. First, let’s consider cases where the structure itself is a TACKY variable, rather than a dereferenced pointer or a subobject in some larger structure. To lvalue convert a structure member, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction. We’ll translate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;struct&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;member&gt;</samp> to:</p>&#13;
<pre><code><var>&lt;instructions for struct&gt;</var>&#13;
s = <var>&lt;result of struct&gt;</var>&#13;
result = CopyFromOffset(s, <var>&lt;member offset&gt;</var>)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_514" aria-label="514"/>We’ll assign to structure members with <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, converting <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;struct&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;member&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;right&gt;</samp> to:</p>&#13;
<pre><code><var>&lt;instructions for struct&gt;</var>&#13;
dst = <var>&lt;result of struct&gt;</var>&#13;
<var>&lt;instructions for right&gt;</var>&#13;
src = <var>&lt;result of right&gt;</var>&#13;
CopyToOffset(src, dst, <var>&lt;member offset&gt;</var>)</code></pre>&#13;
<p class="TX">To get a structure member’s address, we’ll first load the address of the object that contains it, then add the member’s offset. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;struct&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;member&gt;</samp> to:</p>&#13;
<pre><code><var>&lt;instructions for struct&gt;</var>&#13;
s = <var>&lt;result of struct&gt;</var>&#13;
result = GetAddress(s)&#13;
result = AddPtr(ptr=result, index=<var>&lt;member offset&gt;</var>, scale=1)</code></pre>&#13;
<p class="TX">To process a sequence of nested member accesses, we’ll add all their offsets together and then issue an instruction depending on how the final member in the sequence is used. Consider the structure declarations in <a href="chapter18.xhtml#list18-32">Listing 18-32</a>.</p>&#13;
<a id="list18-32"/>&#13;
<pre><code>struct inner {&#13;
    char c;&#13;
    int i;&#13;
};&#13;
&#13;
struct outer {&#13;
    int member1;&#13;
    struct inner member2;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-32: Declaring a structure that contains a nested structure</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp> and we need to lvalue convert <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp>, we’ll emit:</p>&#13;
<pre><code>result = CopyFromOffset("my_struct", 8)</code></pre>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> has an offset of 4 bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an offset of 4 bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner</samp>, the object designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp> has a total offset of 8 bytes from the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp>.</p>&#13;
<p class="TX">Finally, let’s consider how to access structure members through dereferenced pointers. The most idiomatic way to do this is with an arrow operator, of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;member&gt;</samp>. This is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;exp&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">).</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;member&gt;</samp>. To implement either of these expressions, you’ll add the member offset to the pointer and then dereference the result. As with any dereferenced pointer, whether you issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction or simply use the pointer’s value will <span role="doc-pagebreak" epub:type="pagebreak" id="pg_515" aria-label="515"/>depend on how it’s used. Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_struct_pointer</samp> has type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner *</samp>. We’ll convert the expression</p>&#13;
<pre><code>inner_struct_pointer-&gt;i = 1</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>ptr = AddPtr(ptr=inner_struct_pointer, index=4, scale=1)&#13;
Store(1, ptr)</code></pre>&#13;
<p class="TX">We can implement the equivalent expression</p>&#13;
<pre><code>(*inner_struct_pointer).i = 1</code></pre>&#13;
<p class="BodyContinued">with exactly the same instructions. Now that we know what instructions we’d like to generate, we’ll update the TACKY generation pass accordingly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Designating Structure Members with SubObject</samp></h5>&#13;
<p class="TNI">Let’s extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp> construct to designate a member of an aggregate object. <a href="chapter18.xhtml#list18-33">Listing 18-33</a> gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>.</p>&#13;
<a id="list18-33"/>&#13;
<pre><code>exp_result = PlainOperand(val)&#13;
           | DereferencedPointer(val)&#13;
<b>           | SubObject(identifier base, int offset)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-33: Extending</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp_result</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to represent subobjects</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">base</samp> argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> is an aggregate object, not a pointer. The second argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>, is a byte offset into that object. The object that <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> designates might be scalar, or it might be an aggregate itself. In <a href="chapter18.xhtml#list18-34">Listing 18-34</a>, we use this construct to represent the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> operator.</p>&#13;
<a id="list18-34"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols, type_table):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Dot(structure, member) -&gt;&#13;
        struct_def = <var>&lt;look up structure's type in the type table&gt;</var>&#13;
        member_offset = <var>&lt;look up member offset in struct_def&gt;</var>&#13;
        inner_object = emit_tacky(structure, instructions, symbols, type_table)&#13;
        match inner_object with&#13;
        | PlainOperand(Var(v)) -&gt; return SubObject(v, member_offset) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        | SubObject(base, offset) -&gt; return SubObject(base, offset + member_offset) <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        | DereferencedPointer(ptr) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            dst_ptr = make_tacky_variable(Pointer(get_type(e)), symbols)&#13;
            instr = AddPtr(ptr=ptr, index=Constant(ConstLong(member_offset)),&#13;
                           scale=1, dst=dst_ptr)&#13;
            instructions.append(instr)&#13;
            return DereferencedPointer(dst_ptr)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-34: Converting the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator to TACKY</samp></p>&#13;
<p class="TX">First, we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>’s offset in the structure. Then, we process this expression’s first operand without lvalue converting it. The resulting object <span role="doc-pagebreak" epub:type="pagebreak" id="pg_516" aria-label="516"/>is either a plain TACKY variable, a subobject of a TACKY variable, or a dereferenced pointer. (We know the result isn’t a constant because TACKY doesn’t have constants of structure type.)</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> is just a variable, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> designating the object at <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> within that variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> is itself a subobject in some larger variable, we add its offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This takes care of nested member operators, like the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp> that we considered earlier in this section.</p>&#13;
<p class="TX">Finally, if the inner structure is a dereferenced pointer, we access the structure member with pointer arithmetic <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(ptr)</samp> designates the whole structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> must point to the start of the structure. We add <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to get a pointer to the specified structure member. Then, we dereference this pointer to designate the structure member itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Processing SubObject</samp></h5>&#13;
<p class="TNI">Next, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> constructs in lvalue conversions, assignment expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions. To lvalue convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>, we copy it into a new variable with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction, as <a href="chapter18.xhtml#list18-35">Listing 18-35</a> demonstrates.</p>&#13;
<a id="list18-35"/>&#13;
<pre><code>emit_tacky_and_convert(e, instructions, symbols, type_table):&#13;
    result = emit_tacky(e, instructions, symbols, type_table)&#13;
    match result with&#13;
    | SubObject(base, offset) -&gt;&#13;
        dst = make_tacky_variable(get_type(e), symbols)&#13;
        instructions.append(CopyFromOffset(base, offset, dst))&#13;
        return dst&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-35: Lvalue converting a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp></p>&#13;
<p class="TX">Conversely, when a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> appears on the left-hand side of an assignment expression, we write to it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction, as <a href="chapter18.xhtml#list18-36">Listing 18-36</a> demonstrates.</p>&#13;
<a id="list18-36"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols, type_table):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Assignment(left, right) -&gt;&#13;
        lval = emit_tacky(left, instructions, symbols, type_table)&#13;
        rval = emit_tacky_and_convert(right, instructions, symbols, type_table)&#13;
        match lval with&#13;
        | SubObject(base, offset) -&gt;&#13;
            instructions.append(CopyToOffset(rval, base, offset))&#13;
            return PlainOperand(rval)&#13;
        | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-36: Assigning to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp></p>&#13;
<p class="TX">Finally, <a href="chapter18.xhtml#list18-37">Listing 18-37</a> shows how to calculate the address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>. We load the address of the base object, then add the offset.</p>&#13;
<a id="list18-37"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_517" aria-label="517"/>    | AddrOf(inner) -&gt;&#13;
        v = emit_tacky(inner, instructions, symbols, type_table)&#13;
        match v with&#13;
        | SubObject(base, offset) -&gt;&#13;
            dst = make_tacky_variable(get_type(e), symbols)&#13;
            instructions.append(GetAddress(Var(base), dst))&#13;
            instructions.append(AddPtr(ptr=dst,&#13;
                                       index=Constant(ConstLong(offset)),&#13;
                                     <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> scale=1,&#13;
                                       dst=dst))&#13;
            return PlainOperand(dst)&#13;
        |<var> --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-37: Taking the address of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp></p>&#13;
<p class="TX">We reuse the same temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, to point to both the base of the structure and its member. We could also generate two different temporary variables, but we don’t need to. Because the offset in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> construct is in bytes, the scale of this <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Arrow Operator</samp></h5>&#13;
<p class="TNI">Now that we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>, we can easily implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp> too. To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr-&gt;member</samp>, we’ll first evaluate and lvalue convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. Then, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> to add the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>. This will give us a pointer to the designated structure member. Finally, we’ll dereference this pointer with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> construct. I’ll omit the pseudocode for this; you’ve already seen how to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">(*ptr).member</samp> to TACKY, and converting <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr-&gt;member</samp> to TACKY is very similar.</p>&#13;
<p class="TX">We don’t need any extra logic to handle the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp> expression. This expression will always produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> construct, which we already know how to handle.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Omitting Useless AddPtr Instructions</samp></h5>&#13;
<p class="TNI">The first member in a structure always has an offset of zero. As an optional optimization, you can skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction when calculating this member’s address. This affects <a href="chapter18.xhtml#list18-34">Listings 18-34</a> and <a href="chapter18.xhtml#list18-37">18-37</a>, as well as the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>, which I didn’t give the pseudocode for. In all three cases, you don’t need to generate an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction if <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-195"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Compound Initializers to TACKY</samp></h4>&#13;
<p class="TNI">To finish up this section, we’ll convert compound structure initializers to TACKY. The basic approach is the same as in previous chapters: we’ll evaluate each expression in the initializer list in turn, copying the result of each one to the correct offset in the destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction. But now we’ll need to check the type table to find the correct offset for each expression. We’ll also need to calculate the offsets of subobjects deep within nested structures, arrays of structures, structures that contain arrays, and so on.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_518" aria-label="518"/><a href="chapter18.xhtml#list18-38">Listing 18-38</a> demonstrates how to track these offsets and emit <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions as we traverse a compound initializer for a structure or array.</p>&#13;
<a id="list18-38"/>&#13;
<pre><code>compound_initializer_to_tacky(var_name, offset, init, instructions, symbols, type_table):&#13;
    match init, get_type(init) with&#13;
    | SingleInit(String(s)), Array(elem_t, size) -&gt;     <var>--snip--</var>&#13;
    | SingleInit(e), t -&gt;&#13;
        v = emit_tacky_and_convert(e, instructions, symbols, type_table)&#13;
        instructions.append(CopyToOffset(v, var_name, offset)) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    | CompoundInit(init_list), Structure(tag) -&gt;&#13;
        members = type_table.get(tag).members&#13;
        for mem_init, member in zip(init_list, members):&#13;
            mem_offset = offset + member.offset <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            compound_initializer_to_tacky(var_name, mem_offset, mem_init, instructions,&#13;
                                          symbols, type_table)&#13;
    | CompoundInit(init_list), Array(elem_t, size) -&gt; &#13;
        <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-38: Converting a compound initializer to TACKY</samp></p>&#13;
<p class="TX">The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">compound_initializer_to_tacky</samp> include <samp class="SANS_TheSansMonoCd_W5Regular_11">var_name</samp> (the name of the array or structure variable being initialized), <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> (the byte offset of the current subobject within that variable), and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> (the initializer itself). In the top-level call to initialize an entire variable, the <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> argument will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
<p class="TX">In the base case, we initialize a subobject with the value of a single expression. This expression may be a string literal that initializes an array; I’ve omitted the pseudocode for this case, which we covered back in <span class="Xref-1"><a href="chapter16.xhtml">Chapter 16</a></span>. Otherwise, we evaluate the expression and copy the result into place with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Even if the result has structure type, we can copy it to its destination with a single instruction.</p>&#13;
<p class="TX">When we encounter a compound initializer for a structure, we look up the structure’s member list in the type table. We calculate the offset of each item in the initializer list by adding the corresponding member offset to the starting <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> argument <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, we process the item recursively. I won’t talk through the case of a compound initializer for an array, since you already know how to handle that.</p>&#13;
<p class="TX">Our implementation deviates slightly from the C standard here. Under certain circumstances, the standard requires padding to be initialized to zero; <a href="chapter18.xhtml#list18-38">Listing 18-38</a> doesn’t initialize structure padding, and none of our tests check the value of padding in non-static structures.</p>&#13;
<aside class="box-rule" aria-label="box-124"><p class="BoxTitle" id="box-124"><samp class="SANS_Dogma_OT_Bold_B_11">ALL ABOUT PADDING</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The C standard tries to ensure that padding is initialized in a consistent, predictable way. Unfortunately, it doesn’t really succeed, so it’s easy to accidentally leave padding uninitialized. This is a potential security risk because</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_519" aria-label="519"/><samp class="SANS_Futura_Std_Book_11">uninitialized padding might leak sensitive data that was previously stored at that spot in memory. The 2012 blog post “C11 Defects: Initialization of Padding” by Jens Gustedt provides a good overview of this confusing corner of the standard (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://gustedt.wordpress.com/2012/10/24/c11-defects-initialization-of-padding/">https://<wbr/>gustedt<wbr/>.wordpress<wbr/>.com<wbr/>/2012<wbr/>/10<wbr/>/24<wbr/>/c11<wbr/>-defects<wbr/>-initialization<wbr/>-of<wbr/>-padding<wbr/>/</a></samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Luckily, the situation gets somewhat better in C23. This revision introduces an empty initializer of the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> <samp class="SANS_Futura_Std_Book_11">that initializes a whole union or aggregate object to zero, including any padding. This doesn’t completely address the inconsistencies that Gustedt highlighted, but it makes life easier for every C programmer who just needs to zero out a structure. For a delightful introduction to this feature (and a bunch of other changes in C23), see JeanHeyd Meneide’s blog post “Ever Closer—C23 Draws Nearer” (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://thephd.dev/ever-closer-c23-improvements">https://<wbr/>thephd<wbr/>.dev<wbr/>/ever<wbr/>-closer<wbr/>-c23<wbr/>-improvements</a></samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
</aside>&#13;
<p class="TX">At this point, you know how to convert both member access operators and compound structure initializers to TACKY. Once you’ve implemented these conversions, you can test out this compiler pass.</p>&#13;
<aside class="box" aria-label="box-65"><p class="BoxTitle" id="box-65"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 18 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h3 class="H1" id="sec32"><span id="h1-165"/><samp class="SANS_Futura_Std_Bold_B_11">Structures in the System V Calling Convention</samp></h3>&#13;
<p class="TNI">The trickiest part of assembly generation in this chapter is dealing with function calls. As always, we need to pass parameters and return values according to the System V x64 calling convention. The rules for passing and returning structures are particularly gnarly, so we’ll take a look at them before we make any changes to the backend.</p>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-196"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Classifying Structures</samp></h4>&#13;
<p class="TNI">In the System V x64 ABI, every parameter and return value has a <i>class</i>, which dictates how it’s transferred during function calls. We’ve already encountered two of the classes defined in the ABI, although I didn’t use the term <i>class</i> to describe them. Values with integer, character, and pointer types all belong to the INTEGER class; they’re transferred in general-purpose registers. Values with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> all belong to the SSE class; they’re transferred in XMM registers.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_520" aria-label="520"/>In this chapter we’ll encounter a third class, MEMORY, for large values that must be transferred in memory. We’ve passed function arguments in memory before, but passing return values in memory is a new concept; we’ll see exactly how that works in a moment.</p>&#13;
<p class="TX">The ABI presents a somewhat complicated algorithm for classifying structures and unions. We can use a simplified version of this algorithm because there are a bunch of types that we don’t handle, like <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and unions. We’ll walk through the simplified rules for classifying structures in this section. For the complete algorithm, see the documentation listed in <span class="Xref">“Additional Resources” on <a href="#pg_553">page 553</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3" id="sec34"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Splitting a Structure into Eightbytes</samp></h5>&#13;
<p class="TNI">We’ll assign a separate class to each 8-byte chunk of a structure. The ABI calls these chunks <i>eightbytes</i>. If the structure’s size isn’t exactly divisible by 8, the last eightbyte may be shorter than 8 bytes (which makes the term a little misleading). Consider <a href="chapter18.xhtml#list18-39">Listing 18-39</a>, which declares a 12-byte structure.</p>&#13;
<a id="list18-39"/>&#13;
<pre><code>struct twelve_bytes {&#13;
    int i;&#13;
    char arr[8];&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-39: A structure with two eightbytes</samp></p>&#13;
<p class="TX">The first eightbyte of this structure contains <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and the first four elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. The second eightbyte is 4 bytes long and contains the last four elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. <a href="#fig18-2">Figure 18-2</a> shows this structure’s layout in memory.</p>&#13;
<figure class="IMG"><img id="fig18-2" class="img100" src="../images/fig18-2.jpg" alt="" width="1381" height="336"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: The layout of struct twelve_bytes in memory <a href="description-44.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig18-2">Figure 18-2</a> illustrates that a nested array like <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> can span multiple eightbytes. A nested structure can too. Consider the structure declaration in <a href="chapter18.xhtml#list18-40">Listing 18-40</a>.</p>&#13;
<a id="list18-40"/>&#13;
<pre><code>struct inner {&#13;
    int i;&#13;
    char ch2;&#13;
};&#13;
&#13;
struct nested_ints {&#13;
    char ch1;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_521" aria-label="521"/>    struct inner nested;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-40: A structure type containing a nested structure that spans two eightbytes</samp></p>&#13;
<p class="TX"><a href="#fig18-3">Figure 18-3</a> shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp> will be laid out in memory.</p>&#13;
<figure class="IMG"><img class="img100" id="fig18-3" src="../images/fig18-3.jpg" alt="" width="1680" height="539"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: The layout of struct nested_ints in memory <a href="description-45.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first eightbyte of this structure holds two scalar values: <samp class="SANS_TheSansMonoCd_W5Regular_11">ch1</samp> and the nested member <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.i</samp>. The second eightbyte holds <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.ch2</samp>. When we classify a structure, we care about what scalar values each eightbyte contains, but we don’t care how those values are grouped into nested structures or arrays. As far as our classification algorithm is concerned, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested _ints</samp> is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp> type defined in <a href="chapter18.xhtml#list18-41">Listing 18-41</a>.</p>&#13;
<a id="list18-41"/>&#13;
<pre><code>struct flattened_ints {&#13;
    char c;&#13;
    int i;&#13;
    char a;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-41: A structure with the same layout as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct nested_ints</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in memory</samp></p>&#13;
<p class="TX">This structure looks identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp> in memory: its first eightbyte holds a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and its second eightbyte holds another <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h5 class="H3" id="sec35"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Eightbytes</samp></h5>&#13;
<p class="TNI">If a structure is larger than 16 bytes—in other words, if it consists of three or more eightbytes—we’ll assign every eightbyte to the MEMORY class. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large</samp> consists of four eightbytes, which are all classified as MEMORY:</p>&#13;
<pre><code>struct large {&#13;
    int i;&#13;
    double d;&#13;
    char arr[10];&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_522" aria-label="522"/>If a structure is 16 bytes or smaller, we’ll assign each eightbyte to either the INTEGER or the SSE class, according to its contents. An eightbyte belongs to the SSE class if it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and the INTEGER class if it contains anything else. For example, both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct twelve_bytes</samp>, from <a href="chapter18.xhtml#list18-39">Listing 18-39</a>, belong to the INTEGER class. We’ll assign both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp> from <a href="chapter18.xhtml#list18-40">Listing 18-40</a> and both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp> from <a href="chapter18.xhtml#list18-41">Listing 18-41</a> to the INTEGER class too, since none of them hold a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<p class="TX"><a href="chapter18.xhtml#list18-42">Listing 18-42</a> defines a few more structure types. Let’s classify each of them.</p>&#13;
<a id="list18-42"/>&#13;
<pre><code>struct two_ints {&#13;
    int i;&#13;
    int i2;&#13;
};&#13;
&#13;
struct nested_double {&#13;
    double array[1];&#13;
};&#13;
&#13;
struct two_eightbytes {&#13;
    double d;&#13;
    char c;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-42: More structure types</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_ints</samp> consists of a single eightbyte, which belongs to the INTEGER class. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_double</samp> consists of a single eightbyte in the SSE class. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> consists of two eightbytes: the first is in the SSE class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and the second is in the INTEGER class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h2-197"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Parameters of Structure Type</samp></h4>&#13;
<p class="TNI">Once we’ve classified a structure, we can figure out how to pass it as a parameter. If a structure consists of one or two eightbytes, we’ll pass each eightbyte of the structure in the next available register for its class. If a structure consists of a single eightbyte in the INTEGER class, we’ll pass it in the next general-purpose parameter passing register. If it consists of a single eightbyte in the SSE class, we’ll pass it in the next available parameter passing XMM register. If it consists of one INTEGER eightbyte and one SSE eightbyte, we’ll pass the first eightbyte in a general-purpose register and the next eightbyte in an XMM register, and so forth. If there aren’t enough registers available to pass the entire structure, we’ll push the whole thing onto the stack.</p>&#13;
<p class="TX">Let’s look at a few examples. First, in <a href="chapter18.xhtml#list18-43">Listing 18-43</a>, we reproduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> type that we defined in <a href="chapter18.xhtml#list18-42">Listing 18-42</a> and declare a function that takes a parameter with that type.</p>&#13;
<a id="list18-43"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_523" aria-label="523"/>struct two_eightbytes {&#13;
    double d;&#13;
    char c;&#13;
};&#13;
&#13;
void pass_struct(struct two_eightbytes param);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-43: A function declaration with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct two_eightbytes</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameter</samp></p>&#13;
<p class="TX">Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>, which is stored on the stack at address <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>. We might convert the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">pass _struct(x)</samp> to the assembly in <a href="chapter18.xhtml#list18-44">Listing 18-44</a>.</p>&#13;
<a id="list18-44"/>&#13;
<pre><code>movsd   -16(%rbp), %xmm0&#13;
movq    -8(%rbp), %rdi&#13;
call    pass_struct</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-44: Passing a structure parameter in two registers</samp></p>&#13;
<p class="TX">Because the first eightbyte of this structure belongs to the SSE class, we pass it in the first parameter passing XMM register, XMM0. The second eightbyte of the structure belongs to the INTEGER class, so we pass it in the first general-purpose parameter passing register, RDI.</p>&#13;
<p class="TX">Next, let’s look at <a href="chapter18.xhtml#list18-45">Listing 18-45</a>. This listing declares a function with a structure parameter that we’ll need to push onto the stack.</p>&#13;
<a id="list18-45"/>&#13;
<pre><code>struct two_longs {&#13;
    long a;&#13;
    long b;&#13;
};&#13;
&#13;
void a_bunch_of_arguments(int i0, int i1, int i2, int i3, int i4,&#13;
                          struct two_longs param, int i5);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-45: A function declaration with a structure parameter that must be passed in memory</samp></p>&#13;
<p class="TX">When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">a_bunch_of_arguments</samp>, we’ll pass parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">i0</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">i4</samp> in registers EDI, ESI, EDX, ECX, and R8D. This doesn’t leave enough registers open to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> parameter; both eightbytes belong to the INTEGER class, but only one general-purpose parameter passing register, R9, is available. Therefore, we’ll push the whole structure onto the stack. Then, since R9D is still open, we’ll use it to transfer <samp class="SANS_TheSansMonoCd_W5Regular_11">i5</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_longs</samp> with static storage duration, we could convert the function call</p>&#13;
<pre><code>a_bunch_of_arguments(0, 1, 2, 3, 4, arg, 5);</code></pre>&#13;
<p class="BodyContinued">to the assembly in <a href="chapter18.xhtml#list18-46">Listing 18-46</a>.</p>&#13;
<a id="list18-46"/>&#13;
<pre><code>movl    $0, %edi&#13;
movl    $1, %esi&#13;
movl    $2, %edx&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_524" aria-label="524"/>movl    $3, %ecx&#13;
movl    $4, %r8d&#13;
movl    $5, %r9d&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> pushq   arg+8(%rip)&#13;
pushq   arg(%rip)&#13;
call    a_bunch_of_arguments</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-46: Passing a structure on the stack</samp></p>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> lives in the data section, we access it with RIP-relative addressing. We’re using a bit of new assembly syntax here: <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp> indicates the address 8 bytes after the label <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>. Our first <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction will therefore push the second eightbyte of the structure, which contains member <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, onto the stack <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This preserves the structure’s layout in memory, as <a href="#fig18-4">Figure 18-4</a> demonstrates.</p>&#13;
<figure class="IMG"><img id="fig18-4" class="img100" src="../images/fig18-4.jpg" alt="" width="1147" height="884"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: Pushing a structure onto the stack <a href="description-46.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The two <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions in <a href="chapter18.xhtml#list18-46">Listing 18-46</a> push a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> onto the stack with the correct layout. After the callee sets up its stack frame, it can access <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, which is where we always expect to find a function’s first stack parameter.</p>&#13;
<p class="TX">If a structure belongs to the MEMORY class, we’ll always push it onto the stack. Consider the structure type declaration and function declaration in <a href="chapter18.xhtml#list18-47">Listing 18-47</a>.</p>&#13;
<a id="list18-47"/>&#13;
<pre><code>struct pass_in_memory {&#13;
    double w;&#13;
    double x;&#13;
    int y;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_525" aria-label="525"/>    long z;&#13;
};&#13;
&#13;
void accept_struct(struct pass_in_memory arg);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-47: A function declaration with a structure parameter that belongs to the MEMORY class</samp></p>&#13;
<p class="TX"><a href="chapter18.xhtml#list18-48">Listing 18-48</a> demonstrates how to pass a structure stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">-32(%rbp)</samp> as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_struct</samp>.</p>&#13;
<a id="list18-48"/>&#13;
<pre><code>pushq   -8(%rbp)&#13;
pushq   -16(%rbp)&#13;
pushq   -24(%rbp)&#13;
pushq   -32 (%rbp)&#13;
call    accept_struct</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-48: Passing a structure that belongs to the MEMORY class on the stack</samp></p>&#13;
<p class="TX">In this case, like in <a href="chapter18.xhtml#list18-46">Listing 18-46</a>, we maintain the structure’s layout in memory by pushing it onto the stack from back to front.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h4 class="H2" id="sec37"><span id="h2-198"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Structures</samp></h4>&#13;
<p class="TNI">If a structure fits into a single register, returning it is straightforward. We’ll return structures that belong to the INTEGER class in RAX and structures that belong to the SSE class in XMM0. If a structure is between 8 and 16 bytes, we’ll return it in two registers. To accommodate these structures, we’ll designate two more registers to transfer return values: RDX and XMM1. We’ll transfer each eightbyte of a structure in the next available return register of the appropriate class. For example, if the first part of a structure belongs to the SSE class and the second part belongs to the INTEGER class, we’ll transfer the first part in XMM0 and the second part in RAX. If both parts belong to the SSE class, we’ll transfer the structure in XMM0 and XMM1; if both parts belong to the INTEGER class, we’ll transfer it in RAX and RDX.</p>&#13;
<p class="TX">Things get even hairier if a structure is in the MEMORY class. In that case, the caller allocates space for the return value and passes the address of that space to the callee in the RDI register, as if it were the first integer parameter. This means the actual first integer parameter must be passed in RSI, the second in RDX, and so on. To return a value, the callee copies it into the space pointed to by RDI and copies the pointer itself into RAX. Let’s look at the example in <a href="chapter18.xhtml#list18-49">Listing 18-49</a>.</p>&#13;
<a id="list18-49"/>&#13;
<pre><code>struct large_struct {&#13;
    long array[3];&#13;
};&#13;
&#13;
struct large_struct return_a_struct(long i) {&#13;
    struct large_struct callee_result = {{0, 1, i}};&#13;
    return callee_result;&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_526" aria-label="526"/>int main(void) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> struct large_struct caller_result = return_a_struct(10);&#13;
<var>    --snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-49: Calling function that returns a structure in memory</samp></p>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large_struct</samp> is 24 bytes, we’ll return the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> function in memory. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> and assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> has reserved stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, <a href="chapter18.xhtml#list18-50">Listing 18-50</a> shows how to implement this function call.</p>&#13;
<a id="list18-50"/>&#13;
<pre><code>leaq    -24(%rbp), %rdi&#13;
movq    $10, %rsi&#13;
call    return_a_struct</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-50: Calling</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return_a_struct</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">First, we pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>, which will hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>, in RDI. We then pass the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> in the next available parameter passing register, RSI. Finally, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. <a href="#fig18-5">Figure 18-5</a> illustrates the program’s state just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.</p>&#13;
<figure class="IMG"><img class="img70" id="fig18-5" src="../images/fig18-5.jpg" alt="" width="830" height="1046"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The state of the stack and registers before calling return_a_struct <a href="description-47.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_527" aria-label="527"/>RSP and RBP point to the top and bottom of the current stack frame, as usual. RDI points to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>, which hasn’t been initialized yet. RSI holds the first argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.</p>&#13;
<p class="TX">Note that <a href="chapter18.xhtml#list18-50">Listing 18-50</a> doesn’t allocate additional stack space to hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>; it just loads the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> variable. That’s typically fine, with one caveat: according to the ABI, the memory that will hold the return value “must not overlap any data visible to the callee through other names than this argument.”  For example, if you needed to implement the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">var = foo(1, 2, &amp;var)</samp>, it would violate the ABI to pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> in RDI as the storage for the return value <i>and</i> in RCX as an ordinary argument. Instead, you’d need to allocate additional stack space to hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and copy the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> after the function returned. We don’t need to worry about this case, since we generate a new variable to hold the result of each function call during TACKY generation.</p>&#13;
<p class="TX">Now let’s look at <a href="chapter18.xhtml#list18-51">Listing 18-51</a>, which implements <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> in assembly.</p>&#13;
<a id="list18-51"/>&#13;
<pre><code>return_a_struct:&#13;
    pushq   %rbp&#13;
    movq    %rsp, %rbp&#13;
    subq    $32, %rsp&#13;
    movq    $0, -24(%rbp)&#13;
    movq    $1, -16(%rbp)&#13;
    movq    %rsi, -8(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movq    -24(%rbp), %r10&#13;
    movq    %r10, (%rdi)&#13;
    movq    -16(%rbp), %r10&#13;
    movq    %r10, 8(%rdi)&#13;
    movq    -8(%rbp), %r10&#13;
    movq    %r10, 16(%rdi)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movq    %rdi, %rax&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-51: Returning a structure in memory</samp></p>&#13;
<p class="TX">At the start of the function, we set up the stack frame, allocate stack space for the local <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_result</samp> variable at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, and then initialize it. The assembly code to return <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> starts at <span class="CodeAnnotation" aria-label="annotation1">❶</span>. First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> into the memory location that RDI points to, 8 bytes at a time; we’ll copy the first 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rdi)</samp>, the next 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rdi)</samp>, and the last 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rdi)</samp>. Then, we copy the pointer to the return value from RDI into RAX <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we execute the function epilogue, which is omitted from this listing. <a href="#fig18-6">Figure 18-6</a> illustrates the state of the program just before the function epilogue.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_528" aria-label="528"/>&#13;
<figure class="IMG"><img class="img70" id="fig18-6" src="../images/fig18-6.jpg" alt="" width="846" height="1480"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The state of the stack and registers just before returning from return_a_struct <a href="description-48.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> variable in the caller’s stack frame now holds the function’s return value, and RAX holds the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>. In this example, the RDI register holds that address too, but this isn’t required by the ABI.</p>&#13;
<p class="TX">We’ve covered everything we need to know about the calling convention for structures. Now we’re ready to work on the assembly generation pass!</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h3 class="H1" id="sec38"><span id="h1-166"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">This pass will change in a couple of ways. First, we’ll need to generate assembly to copy entire structures from one location to another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions can all transfer both scalar and aggregate values. So can the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction, which we’ll <span role="doc-pagebreak" epub:type="pagebreak" id="pg_529" aria-label="529"/>need to implement. Second, we’ll implement the System V calling convention that we just learned about.</p>&#13;
<p class="TX">We’ll start by making a few small changes to the assembly AST.</p>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h4 class="H2" id="sec39"><span id="h2-199"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Assembly AST</samp></h4>&#13;
<p class="TNI">In <a href="chapter18.xhtml#list18-46">Listing 18-46</a>, we used the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp> to access data at a constant offset from a RIP-relative label. We’ll often need these sorts of operands to access members of structures with static storage duration. The assembly AST can already specify constant offsets from most memory addresses, but not from RIP-relative addresses. We’ll remove this limitation by adding an offset to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand:</p>&#13;
<pre><code>operand = <var>--snip--</var> | Data(identifier, <b>int</b>)</code></pre>&#13;
<p class="TX">We’ll also introduce two new assembly instructions. First, we’ll add the left-shift instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>. This instruction takes an immediate value as its source operand and a memory address or register as its destination. It shifts its destination left by the number of bits specified by its source. For example, the instruction</p>&#13;
<pre><code>shlq    $8, %rax</code></pre>&#13;
<p class="BodyContinued">shifts the value in RAX 1 byte to the left, setting its lowest byte to 0. If the value in RAX were <samp class="SANS_TheSansMonoCd_W5Regular_11">0x8</samp> before this instruction, it would be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x800</samp> afterward. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction will help us copy irregularly sized structures into registers in order to pass them as arguments and return values. Because we can’t directly access every individual byte within a register, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> to shift each byte into place.</p>&#13;
<p class="TX">Second, we’ll add the two-operand form of the logical right-shift instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>. (We added the one-operand form, which shifts its operand 1 bit to the right, back in <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span>.) Similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, it shifts its destination right by the number of bits its source specifies. It will serve a similar purpose to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, helping us transfer irregularly sized structures <i>out</i> of registers and into memory.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The shl instruction also has a one-operand form, which we won’t use; it’s the counterpart to the one-operand form of shr that we’re already familiar with. Both instructions have yet another form we won’t use, which uses the CL register as the source operand.</i></p>&#13;
<p class="TX">We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>:</p>&#13;
<pre><code>binary_operator = <var>--snip--</var> | <b>Shl | ShrTwoOp</b></code></pre>&#13;
<p class="TX">The new binary <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instruction gets the rather clunky name <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp> to distinguish it from the existing unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp> instruction in the assembly AST.</p>&#13;
<p class="TX"><a href="chapter18.xhtml#list18-52">Listing 18-52</a> defines the updated assembly AST, with these changes bolded.</p>&#13;
<a id="list18-52"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_530" aria-label="530"/>program = Program(top_level*)&#13;
assembly_type = Byte | Longword | Quadword | Double | ByteArray(int size, int alignment)&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)&#13;
          | StaticConstant(identifier name, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(assembly_type src_type, assembly_type dst_type, operand src, operand dst)&#13;
            | MovZeroExtend(assembly_type src_type, assembly_type dst_type,&#13;
                            operand src, operand dst)&#13;
            | Lea(operand src, operand dst)&#13;
            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
unary_operator = Neg | Not | Shr&#13;
binary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor | <b>Shl | ShrTwoOp</b>&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier, <b>int</b>)&#13;
        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP&#13;
    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-52: The assembly AST with offsets on static operands and bit shift instructions</samp></p>&#13;
<p class="TX">Converting types and TACKY operands to assembly is pretty simple. Structure types, like array types, are converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> assembly type. To convert a structure type to assembly, you’ll need to look up its size and alignment in the type table. We’ll convert TACKY variables of structure type to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> assembly operands, just like we do with arrays. We’ll always store arrays and structures in memory rather than registers, even once we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>.</p>&#13;
<p class="TX">Some of the TACKY variables you encounter may have incomplete structure types. (Remember that it’s legal to declare an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> variable with an incomplete type and take its address, but it’s illegal to define it or use it in any other way.) Convert these variables to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operands, like other variables of structure type. You can give these variables a dummy assembly type when you add them to the backend symbol table; that dummy type will never be used.</p>&#13;
<p class="TX">Next, let’s handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instructions. Then, we’ll deal with function calls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_531" aria-label="531"/>&#13;
<h4 class="H2" id="sec40"><span id="h2-200"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Structures</samp></h4>&#13;
<p class="TNI">To copy a structure to a new location, you don’t need to consider its members’ types or offsets; you just need to copy the right number of bytes. To minimize the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions required, copy 8 bytes at a time until there are fewer than 8 bytes left to move. Then, copy 4 bytes at a time. Finally, when there are fewer than 4 bytes left to move, copy 1 byte at a time. (There’s also a 2-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in x64 assembly, but our assembly AST doesn’t support it.) For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are 20-byte structures, you should translate</p>&#13;
<pre><code>Copy(Var("a"), Var("b"))</code></pre>&#13;
<p class="BodyContinued">to the assembly in <a href="chapter18.xhtml#list18-53">Listing 18-53</a>.</p>&#13;
<a id="list18-53"/>&#13;
<pre><code>Mov(Quadword, PseudoMem("a", 0), PseudoMem("b", 0))&#13;
Mov(Quadword, PseudoMem("a", 8), PseudoMem("b", 8))&#13;
Mov(Longword, PseudoMem("a", 16), PseudoMem("b", 16))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-53: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Copy</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for non-scalar values</samp></p>&#13;
<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction copies the first 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; the second instruction copies the next 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to the corresponding offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and the final instruction copies the remaining 4 bytes. These <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions are invalid, since their source and destination operands are both in memory, but they’ll be rewritten in the instruction fix-up pass.</p>&#13;
<p class="TX">You can use the same approach to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is a 6-byte structure, you’ll translate</p>&#13;
<pre><code>Load(Var("ptr"), Var("y"))</code></pre>&#13;
<p class="TX">to <a href="chapter18.xhtml#list18-54">Listing 18-54</a>.</p>&#13;
<a id="list18-54"/>&#13;
<pre><code>Mov(Quadword, Pseudo("ptr"), Reg(AX))&#13;
Mov(Longword, Memory(AX, 0), PseudoMem("y", 0))&#13;
Mov(Byte, Memory(AX, 4), PseudoMem("y", 4))&#13;
Mov(Byte, Memory(AX, 5), PseudoMem("y", 5))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-54: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Load</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for non-scalar values</samp></p>&#13;
<p class="TX">The first instruction copies the pointer into the RAX register. Each subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction copies a chunk of data stored at some offset from the address in RAX to the corresponding offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.</p>&#13;
<p class="TX">You can also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> for non-scalar values with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions; the only difference is that you’ll add the specified offset to each instruction’s destination. To give another example with the 6-byte structure <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, you’ll translate</p>&#13;
<pre><code>CopyToOffset(src=Var("y"), dst="z", offset=8)</code></pre>&#13;
<p class="TX">to <a href="chapter18.xhtml#list18-55">Listing 18-55</a>.</p>&#13;
<a id="list18-55"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_532" aria-label="532"/>Mov(Longword, PseudoMem("y", 0), PseudoMem("z", 8))&#13;
Mov(Byte, PseudoMem("y", 4), PseudoMem("z", 12))&#13;
Mov(Byte, PseudoMem("y", 5), PseudoMem("z", 13))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-55: Implementing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyToOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for non-scalar values</samp></p>&#13;
<p class="TX">Finally, you’ll need to implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction. Like the other TACKY instructions that copy data, it accepts both scalar and non-scalar operands. I won’t talk through this instruction in detail; you should handle it basically the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>.</p>&#13;
<p class="TX">I recommend writing a helper function, which I’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>, that generates assembly instructions to copy an arbitrary number of bytes from one <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand to another. You can use this helper function to implement all five of the TACKY copying instructions. It will come in handy again when you need to pass structures in memory as arguments and return values.</p>&#13;
<p class="TX">Once you’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> and extended the other copy instructions to support non-scalar values, you’re ready to move on to function calls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h4 class="H2" id="sec41"><span id="h2-201"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Structures in Function Calls</samp></h4>&#13;
<p class="TNI">Since the rules for passing and returning structures are complex, let’s talk about our overall strategy before diving into the pseudocode. First, we’ll write a function to classify each eightbyte of a structure type. Then, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> helper function, which we introduced back in <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span> to help with parameter passing on both the caller and callee sides. Remember that this function returns three lists: operands passed in general-purpose registers, operands passed in XMM registers, and operands passed on the stack. Once we update this function, these lists may include both scalar values and eightbytes of structure values.</p>&#13;
<p class="TX">Next, we’ll introduce another helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>, to split up return values in a similar way. It will return a list of operands returned in general-purpose registers, a list of operands returned in XMM registers, and a Boolean flag that indicates whether the return value is passed in memory. This flag will be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> only when both lists are empty.</p>&#13;
<p class="TX">When <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> processes a scalar value, it will return one empty list, one list with a single element, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> flag. When it processes a structure, it might produce a more interesting result. Its main purpose is to massage both scalar and structure return values into the same shape, so we can process them in a uniform way.</p>&#13;
<p class="TX">Once these helpers are in place, we’ll update how we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> TACKY instruction to assembly. For the most part, we can pass parameters the same way as in earlier chapters. We’ll copy each operand we get from <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> into the appropriate register or push it onto the stack, without worrying about whether it’s a scalar value or part of a structure. Only a few details will change. First, we’ll account for the fact that RDI may not be available if it holds the address of the space reserved for the return value. We’ll also need to pass irregularly sized eightbytes that can’t be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_533" aria-label="533"/>transferred with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction. We’ll write a new helper function to move these eightbytes into registers.</p>&#13;
<p class="TX">Retrieving the function’s return value will require larger changes. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> to learn where we can find each part of the return value, then copy each part from the appropriate register or memory address to its final destination. This will require yet another helper function to copy irregularly sized eightbytes <i>out</i> of registers.</p>&#13;
<p class="TX">Finally, we’ll tackle things on the callee side. Here, like on the caller side, the way we process parameters will change only slightly, but the way we handle return values will change quite a bit. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> again to figure out where to put each part of the return value.</p>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h5 class="H3" id="sec42"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Structure Types</samp></h5>&#13;
<p class="TNI">We’ll start with a helper function to classify structure types. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> construct defined in <a href="chapter18.xhtml#list18-56">Listing 18-56</a> to represent the three classes we discussed earlier.</p>&#13;
<a id="list18-56"/>&#13;
<pre><code>class = MEMORY | SSE | INTEGER</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-56: The</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">construct</samp></p>&#13;
<p class="TX">The classification function will return a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> elements, one for each eightbyte of the structure being classified. To classify a structure, we’ll first consider its size and then look at the types of its members. <a href="chapter18.xhtml#list18-57">Listing 18-57</a> gives the pseudocode for this process.</p>&#13;
<a id="list18-57"/>&#13;
<pre><code>classify_structure(StructEntry(alignment, size, members)):&#13;
    if size &gt; 16:&#13;
        result = []&#13;
        while size &gt; 0:&#13;
            result.append(MEMORY)&#13;
            size -= 8&#13;
        return result&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> scalar_types = <var>&lt;flatten out list of member types&gt;</var>&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if size &gt; 8:&#13;
        if first and last type in scalar_types are Double:&#13;
            return [SSE, SSE]&#13;
        if first type in scalar_types is Double:&#13;
            return [SSE, INTEGER]&#13;
        if last type in scalar_types is Double:&#13;
            return [INTEGER, SSE]&#13;
        return [INTEGER, INTEGER]&#13;
    else if first type in scalar_types is Double:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return [SSE]&#13;
    else:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> return [INTEGER]</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-57: Classifying structure types</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp> function takes a structure definition from the type table. If the structure is larger than 16 bytes, it must be passed in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_534" aria-label="534"/>memory, so we return a list of enough MEMORY elements to cover the whole structure. For example, if the structure’s size is 17 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _structure</samp> should return <samp class="SANS_TheSansMonoCd_W5Regular_11">[MEMORY, MEMORY, MEMORY]</samp>.</p>&#13;
<p class="TX">Otherwise, the structure’s classification depends on its member types. We construct a list of every scalar type the structure contains, including the types of nested values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Suppose a structure contains two members: an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">char[3]</samp>. The resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_types</samp> list will be <samp class="SANS_TheSansMonoCd_W5Regular_11">[Pointer(Int), Char, Char, Char]</samp>.</p>&#13;
<p class="TX">If a structure is between 8 and 16 bytes, we return a list of two classes <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has a size and alignment of 8 bytes, any <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> that appears in a structure of this size must completely occupy either the first or second eightbyte. Taking advantage of this fact, we examine only the first and last elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>. If the first element is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, the first eightbyte must be in the SSE class; otherwise, it must be in the INTEGER class. Likewise, the second eightbyte is in the SSE class only if the last element of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>.</p>&#13;
<p class="TX">Finally, we classify structures that are 8 bytes or smaller. A structure of this size belongs to the SSE class if the first (and only) scalar type it contains is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Otherwise, it belongs to the INTEGER class <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">If you want, you can improve on the code in <a href="chapter18.xhtml#list18-57">Listing 18-57</a> by caching the results. You’ll need to maintain a mapping from structure tags to their classifications. The first time you classify a particular structure type, add the result to this mapping. Then, if you need to classify that structure type again, you can just retrieve the result instead of recomputing it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h5 class="H3" id="sec43"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Parameters</samp></h5>&#13;
<p class="TNI">Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> function. This function partitions a list of parameters or arguments in three, based on whether each one is passed in a general-purpose register, in an XMM register, or on the stack. Now, when it processes a value of structure type, it will split up the value into eightbytes and add each one to the correct list. <a href="chapter18.xhtml#list18-58">Listing 18-58</a> reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> from <span class="Xref-1"><a href="chapter13.xhtml#list13-29">Listing 13-29</a></span>, with changes bolded.</p>&#13;
<a id="list18-58"/>&#13;
<pre><code>classify_parameters(values, <b>return_in_memory</b>):&#13;
    int_reg_args = []&#13;
    double_reg_args = []&#13;
    stack_args = []&#13;
&#13;
    <b>if return_in_memory:</b>&#13;
        <b>int_regs_available = 5</b>&#13;
    <b>else:</b>&#13;
        <b>int_regs_available = 6</b>&#13;
&#13;
    for v in values:&#13;
        operand = convert_val(v)&#13;
        t = assembly_type_of(v)&#13;
        typed_operand = (t, operand)&#13;
&#13;
        if t == Double:&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_535" aria-label="535"/>            <var>--snip--</var>&#13;
        else <b>if t is scalar</b>:&#13;
            if length(int_reg_args) &lt; <b>int_regs_available</b>:&#13;
                int_reg_args.append(typed_operand)&#13;
            else:&#13;
                stack_args.append(typed_operand)&#13;
&#13;
        <b>else:</b>&#13;
            <b>// v is a structure</b>&#13;
            <b>// partition it into eightbytes by class</b>&#13;
            <b>classes = classify_structure(</b><var><b>&lt;struct definition for v&gt;</b></var><b>) </b><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
            <b>use_stack = True</b>&#13;
            <b>struct_size =</b><var><b> </b></var><b>t.size</b>&#13;
            <b>if classes[0] != MEMORY: </b><span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
                <b>// make tentative assignments to registers</b>&#13;
                <b>tentative_ints = []</b>&#13;
                <b>tentative_doubles = []</b>&#13;
                <b>offset = 0</b>&#13;
                <b>for class in classes:</b>&#13;
                    <b>operand = PseudoMem(</b><var><b>&lt;name of v&gt;</b></var><b>, offset) </b><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
                    <b>if class == SSE:</b>&#13;
                        <b>tentative_doubles.append(operand)</b>&#13;
                    <b>else:</b>&#13;
                        <b>eightbyte_type = get_eightbyte_type(offset, struct_size) </b><span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
                        <b>tentative_ints.append((eightbyte_type, operand))</b>&#13;
                    <b>offset += 8</b>&#13;
&#13;
                <b>// finalize them if there are enough free registers</b>&#13;
                <b>if ((length(tentative_doubles) + length(double_reg_args)) &lt;= 8 and</b>&#13;
                    <b>(length(tentative_ints) + length(int_reg_args)) &lt;= int_regs_available): </b><span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
                    <b>double_reg_args.append_all(tentative_doubles)</b>&#13;
                    <b>int_reg_args.append_all(tentative_ints)</b>&#13;
                    <b>use_stack = False</b>&#13;
&#13;
            <b>if use_stack:</b>&#13;
                <b>// add each eightbyte of the structure to stack_args</b>&#13;
                <b>offset = 0</b>&#13;
                <b>for class in classes:</b>&#13;
                    <b>operand = PseudoMem(</b><var><b>&lt;name of v&gt;</b></var><b>, offset)</b>&#13;
                    <b>eightbyte_type = get_eightbyte_type(offset, struct_size)</b>&#13;
                    <b>stack_args.append((eightbyte_type, operand)) </b><span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
                    <b>offset += 8</b>&#13;
&#13;
    return (int_reg_args, double_reg_args, stack_args)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-58: Extending</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">classify_parameters</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to support structures</samp></p>&#13;
<p class="TX">The first change to this function is the new Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp> parameter. As the name suggests, this indicates whether the function’s return value is passed in memory. If it is, that memory address will be passed in the RDI register, leaving one fewer general-purpose register available for other parameters. We’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp> accordingly. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_536" aria-label="536"/>Then, when we process parameters of integer or pointer type, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">int _regs_available</samp>, instead of the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>, as the number of usable general-purpose registers. (We’ll process parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type exactly the same way we did in <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span>, so I’ve snipped out that bit of the listing.)</p>&#13;
<p class="TX">Now we’ve reached the interesting part: processing parameters of structure type. We’ll start with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we’ll check whether the first eightbyte of the structure is in the MEMORY class <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it is, the rest of the structure must be too. If not, we’ll try to assign each eightbyte to a register. We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then add it to one of two lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_doubles</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>, based on its class. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> is a variable, rather than a constant, because there are no aggregate constants in TACKY; the name of that variable will be the base of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand.</p>&#13;
<p class="TX">When we add an eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>, we need to figure out what assembly type to associate it with. Most eightbytes are exactly 8 bytes long, so we associate them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type. But the final eightbyte in a structure might be shorter. We’ll find each eightbyte’s assembly type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> helper function <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which we’ll walk through in a moment. This function takes two arguments: the eightbyte’s offset and the total size of the structure. It will use these to figure out the eightbyte’s size, which dictates its assembly type.</p>&#13;
<p class="TX">Once we’ve partitioned the whole structure into two tentative lists, we check that we have enough free registers to accommodate both of them <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If we do, we append both lists to their non-tentative equivalents. If we don’t have enough registers available, or if the structure belongs to the MEMORY class, we add each eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> instead <span class="CodeAnnotation" aria-label="annotation6">❻</span>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_type</samp> to determine the type of each eightbyte we pass on the stack.</p>&#13;
<p class="TX">Now let’s walk through <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>, defined in <a href="chapter18.xhtml#list18-59">Listing 18-59</a>.</p>&#13;
<a id="list18-59"/>&#13;
<pre><code>get_eightbyte_type(offset, struct_size):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> bytes_from_end = struct_size - offset&#13;
    if bytes_from_end &gt;= 8:&#13;
        return Quadword&#13;
    if bytes_from_end == 4:&#13;
        return Longword&#13;
    if bytes_from_end == 1:&#13;
        return Byte&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> return ByteArray(bytes_from_end, 8)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-59: Associating an eightbyte with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">assembly_type</samp></p>&#13;
<p class="TX">The goal here is to figure out what operand size to use when moving this eightbyte into a register or onto the stack. First, we calculate the number of bytes between the start of this eightbyte and the end of the whole structure <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If there are more than 8 bytes left in the structure, this isn’t the last eightbyte, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type. If this eightbyte is exactly 8 bytes, 4 bytes, or 1 byte long, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> type, respectively.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_537" aria-label="537"/>Otherwise, the eightbyte’s size is irregular; it’s not a valid operand size for assembly instructions. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type to record the eightbyte’s exact size in bytes <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (The alignment in this <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> is a dummy value; we won’t need it later.) We can’t safely transfer an irregularly sized eightbyte with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction. As you learned in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, reading past the end of a value in memory—by pushing a 4-byte value with an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instruction, for example—could trigger a memory access violation. By the same logic, it’s not safe to transfer a 5-, 6-, or 7-byte operand with an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction or a 3-byte operand with a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction. We’ll look at how to transfer irregularly sized eightbytes in a moment.</p>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> doesn’t consider the eightbyte’s class; it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> for any full-length eightbyte, even if it belongs to the SSE class. This is correct because we use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> only to find the types of values we’re going to transfer in general-purpose registers or on the stack. When we push 8 bytes of a structure onto the stack, we don’t care whether those bytes contain a floating-point value or an integer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h5 class="H3" id="sec44"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Return Values</samp></h5>&#13;
<p class="TNI">Next, we’ll write a similar helper function to classify return values. This function is simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>. We have one value to deal with, instead of a whole list, so we don’t need to worry about running out of registers. We also don’t need to split up the value into eightbytes if it will be returned in memory, like we did in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>. <a href="chapter18.xhtml#list18-60">Listing 18-60</a> shows the pseudocode for the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> helper function.</p>&#13;
<a id="list18-60"/>&#13;
<pre><code>classify_return_value(retval):&#13;
&#13;
    t = assembly_type_of(retval)&#13;
&#13;
    if t == Double:&#13;
        operand = convert_val(retval)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> return ([], [operand], False)&#13;
    else if t is scalar:&#13;
        typed_operand = (t, convert_val(retval))&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> return ([typed_operand], [], False)&#13;
    else:&#13;
        classes = classify_structure(<var>&lt;struct definition for retval&gt;</var>)&#13;
        struct_size = t.size&#13;
        if classes[0] == MEMORY:&#13;
            // the whole structure is returned in memory,&#13;
            // not in registers&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return ([], [], True)&#13;
        else:&#13;
            // the structure is returned in registers;&#13;
            // partition it into eightbytes by class&#13;
            int_retvals = []&#13;
            double_retvals = []&#13;
            offset = 0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_538" aria-label="538"/>            for class in classes:&#13;
                operand = PseudoMem(<var>&lt;name of retval&gt;</var>, offset)&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> match class with&#13;
                | SSE -&gt;&#13;
                    double_retvals.append(operand)&#13;
                | INTEGER -&gt;&#13;
                    eightbyte_type = get_eightbyte_type(offset, struct_size)&#13;
                    int_retvals.append((eightbyte_type, operand))&#13;
                | MEMORY -&gt; fail("Internal error")&#13;
                offset += 8&#13;
            return (int_retvals, double_retvals, False)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-60: Classifying return values</samp></p>&#13;
<p class="TX">If the return value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, the first of our two lists, which contains operands returned in general-purpose registers, will be empty. The second list, which holds operands returned in XMM registers, will contain the return value. The flag signaling that the value is returned in memory will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the return value is some other scalar type, we’ll add it to the list of operands returned in general-purpose registers, along with its type. The list of operands in XMM registers will be empty, and the flag will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Otherwise, the return value must be a structure. We’ll look up its classes with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>, then check whether it belongs to the MEMORY class. If it does, we’ll return two empty lists, which indicate that nothing will be returned in registers, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> flag, which indicates that the return value will be passed in memory <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">If the structure isn’t in the MEMORY class, it will be returned in registers. We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand and add it to either <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>, according to its class <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Here, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _parameters</samp>, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> to find the assembly type of each operand in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>. Finally, we’ll return both lists, along with a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> flag.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
&#13;
<h5 class="H3" id="sec45"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp></h5>&#13;
<p class="TNI">Next, let’s update how we implement function calls in assembly. <a href="chapter18.xhtml#list18-61">Listing 18-61</a> reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp> from <span class="Xref-1"><a href="chapter13.xhtml#list13-31">Listing 13-31</a></span>, with changes bolded and some unchanged code omitted.</p>&#13;
<a id="list18-61"/>&#13;
<pre><code>convert_function_call(FunCall(fun_name, args, dst)):&#13;
    int_registers = [DI, SI, DX, CX, R8, R9]&#13;
    double_registers = [XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7]&#13;
&#13;
    <b>return_in_memory = False</b>&#13;
    <b>int_dests = []</b>&#13;
    <b>double_dests = []</b>&#13;
    <b>reg_index = 0</b>&#13;
&#13;
    <b>// classify return value</b>&#13;
    <b>if dst is not null:</b>&#13;
        <b>int_dests, double_dests, return_in_memory = classify_return_value(dst) </b><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_539" aria-label="539"/>    <b>if return_in_memory:</b>&#13;
        <b>dst_operand = convert_val(dst)</b>&#13;
        <b>emit(Lea(dst_operand, Reg(DI)))</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        <b>reg_index = 1</b>&#13;
&#13;
    // classify arguments&#13;
    int_args, double_args, stack_args = classify_parameters(args, <b>return_in_memory</b>)&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    // pass args in registers&#13;
    for (assembly_type, assembly_arg) in int_args:&#13;
        r = int_registers[reg_index]&#13;
        <b>if assembly_type is ByteArray(size, alignment):</b>&#13;
            <b>copy_bytes_to_reg(assembly_arg, r, size)</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        <b>else:</b>&#13;
            emit(Mov(assembly_type, assembly_arg, Reg(r)))&#13;
        reg_index += 1&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    // pass args on stack&#13;
    for (assembly_type, assembly_arg) in reverse(stack_args):&#13;
        <b>if assembly_type is ByteArray(size, alignment):</b>&#13;
            <b>emit(Binary(Sub, Quadword, Imm(8), Reg(SP)))</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            <b>copy_bytes(from=assembly_arg, to=Memory(SP, 0), count=size)</b>&#13;
        <b>else </b>if (assembly_arg is a Reg or Imm operand&#13;
                 or assembly_type == Quadword&#13;
                 or assembly_type == Double):&#13;
            emit(Push(assembly_arg))&#13;
        else:&#13;
            emit(Mov(assembly_type, assembly_arg, Reg(AX)))&#13;
            emit(Push(Reg(AX)))&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    // retrieve return value&#13;
    <b>if (dst is not null) and (not return_in_memory):</b>&#13;
        <b>int_return_registers = [AX, DX]</b>&#13;
        <b>double_return_registers = [XMM0, XMM1]</b>&#13;
&#13;
        <b>// retrieve values returned in general-purpose registers</b>&#13;
        <b>reg_index = 0</b>&#13;
        <b>for (t, op) in int_dests:</b>&#13;
           <b>r = int_return_registers[reg_index]</b>&#13;
           <b>if t is ByteArray(size, alignment):</b>&#13;
               <b>copy_bytes_from_reg(r, op, size)</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
           <b>else:</b>&#13;
               <b>emit(Mov(t, Reg(r), op))</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
           <b>reg_index += 1</b>&#13;
&#13;
        <b>// retrieve values returned in XMM registers</b>&#13;
        <b>reg_index = 0</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_540" aria-label="540"/>        <b>for op in double_dests:</b>&#13;
            <b>r = double_return_registers[reg_index]</b>&#13;
            <b>emit(Mov(Double, Reg(r), op))</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span>&#13;
            <b>reg_index += 1</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-61: Supporting structures in function calls</samp></p>&#13;
<p class="TX">We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> (unless the function call doesn’t have a return value because its return type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If we find that the return value will be passed in memory, we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> into an assembly operand, then emit an instruction to load its address into RDI <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp> so that we’ll pass the first integer argument in RSI instead of RDI.</p>&#13;
<p class="TX">Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>, passing it the new <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp> flag. Then, we adjust the stack pointer (I’ve omitted this step because it’s the same as in earlier chapters).</p>&#13;
<p class="TX">We then pass arguments in the general-purpose registers. If an argument has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type, its size isn’t exactly 1, 4, or 8 bytes, so transferring it into the register will take multiple instructions. We emit those instructions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> helper function <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which we’ll look at in a moment. If an argument has any other type, we transfer it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction, as in earlier chapters. The way we pass arguments in XMM registers won’t change, so I’ve snipped out that step.</p>&#13;
<p class="TX">The next step is passing arguments on the stack. The way we pass operands with type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> won’t change. To pass an irregular operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type, we first need to subtract 8 bytes from RSP to allocate the stack slot for that operand <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (Remember that the ABI reserves an entire 8-byte stack slot for each eightbyte of a structure parameter, even if the actual eightbyte is smaller than that.) To copy the operand into that stack slot, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> helper function we’ve already written. Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a global variable and its size is 3 bytes. We’ll issue these instructions to pass it as an argument on the stack:</p>&#13;
<pre><code>subq    $8, %rsp&#13;
movb    x(%rip), (%rsp)&#13;
movb    x+1(%rip), 1(%rsp)&#13;
movb    x+2(%rip), 2(%rsp)</code></pre>&#13;
<p class="TX">These <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instructions are invalid, since both operands are in memory; we’ll rewrite them in the instruction fix-up pass.</p>&#13;
<p class="TX">Next, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction and restore the stack pointer to its original location. I’ve snipped out these steps because they’re unchanged from earlier chapters.</p>&#13;
<p class="TX">Finally, we copy the return value to the destination. If the return value is transferred in memory, we don’t do anything; the callee already copied it for us. Otherwise, we iterate over the two lists of destination operands returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>—first <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp>—and retrieve each operand from the corresponding register. To retrieve an irregularly sized eightbyte from a general-purpose register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp> helper function <span class="CodeAnnotation" aria-label="annotation5">❺</span>, which we’ll define in a moment. This <span role="doc-pagebreak" epub:type="pagebreak" id="pg_541" aria-label="541"/>is the counterpart to <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>, which we used to pass parameters. We emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> value from a general-purpose register <span class="CodeAnnotation" aria-label="annotation6">❻</span> or to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> value from an XMM register <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">The code to copy the return value to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> works whether <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a structure or a scalar object. If it’s a structure, each item in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double _dests</samp> is an eightbyte of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, which we’ll populate from the corresponding return register. If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is scalar, either <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp> will have exactly one element, and the other list will be empty. In that case, this code will emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction to transfer the return value from RAX or XMM0 to its destination.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
&#13;
<h5 class="H3" id="sec46"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transferring Irregular Structures in Registers</samp></h5>&#13;
<p class="TNI">We still need to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>, which copy irregularly sized eightbytes to and from general-purpose registers. This is trickier than copying between two locations in memory, like we do in <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>, because we can’t directly access every individual byte in a general-purpose register. We can access a general-purpose register’s lowest byte with the appropriate 1-byte alias, like AL or DIL, but we can’t access its other bytes individually. (Each register’s second-lowest byte also has its own alias—for instance, AH is the second-lowest byte of RAX—but our assembly AST doesn’t support these aliases. Even if it did, we still couldn’t access the other 6 bytes.)</p>&#13;
<p class="TX">We’ll use our new bit-shifting instructions to work around this limitation. Let’s revisit the 3-byte global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from our last example. If we need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into RDI, we’ll issue the following instructions:</p>&#13;
<pre><code>movb    x+2(%rip), %dil&#13;
shlq    $8, %rdi&#13;
movb    x+1(%rip), %dil&#13;
shlq    $8, %rdi&#13;
movb    x(%rip), %dil</code></pre>&#13;
<p class="TX">We start by copying the <i>last</i> byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into the lowest byte of RDI, whose alias is DIL. Then, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction to shift RDI 1 byte to the left. This moves the byte we just copied into the second-lowest byte of RDI and zeroes out DIL. Next, we copy the middle byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL and issue another <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction. At this point, the last 2 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> are in the correct place in the register, so we just move the first byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL, and we’re done. <a href="#fig18-7">Figure 18-7</a> shows the contents of RDI (in hexadecimal) after each instruction, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> contains the bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3</samp>, and RDI’s initial value is 0.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_542" aria-label="542"/>&#13;
<figure class="IMG"><img class="img50" id="fig18-7" src="../images/fig18-7.jpg" alt="" width="606" height="1215"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Transferring a structure into a register a byte at a time <a href="description-49.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Don’t let the byte ordering here throw you off: because our system is little-endian, the least significant (rightmost) byte in RDI corresponds to the lowest memory address when we copy the value from RDI into memory, or vice versa. This means—somewhat counterintuitively—that shifting a value to the <i>left</i> moves each byte to a location that corresponds to a <i>higher</i> memory address. If, after copying this structure into RDI, we issue the instruction</p>&#13;
<pre><code>movl    %edi, -4(%rbp)</code></pre>&#13;
<p class="BodyContinued">then the contents of memory will look like <a href="#fig18-8">Figure 18-8</a>.</p>&#13;
<figure class="IMG"><img id="fig18-8" class="img100" src="../images/fig18-8.jpg" alt="" width="901" height="165"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The contents of memory after copying a structure from a register <a href="description-50.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now the structure is laid out in memory in the correct order. (This <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction also writes 1 byte of memory past the end of the structure, which is fine if you aren’t using that byte for anything else. We’ll transfer irregularly sized structures in and out of registers 1 byte at a time, but code <span role="doc-pagebreak" epub:type="pagebreak" id="pg_543" aria-label="543"/>in other translation units that we interact with may transfer them in 4- and 8-byte chunks when it’s safe to do so.)</p>&#13;
<p class="TX">That’s the basic idea of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>; now let’s implement it. <a href="chapter18.xhtml#list18-62">Listing 18-62</a> gives the pseudocode.</p>&#13;
<a id="list18-62"/>&#13;
<pre><code>copy_bytes_to_reg(src_op, dst_reg, byte_count):&#13;
    offset = byte_count - 1&#13;
    while offset &gt;= 0:&#13;
        src_byte = add_offset(src_op, offset)&#13;
        emit(Mov(Byte, src_byte, Reg(dst_reg)))&#13;
        if offset &gt; 0:&#13;
            emit(Binary(Shl, Quadword, Imm(8), Reg(dst_reg)))&#13;
        offset -= 1</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-62: Generating instructions to copy bytes from memory into a register</samp></p>&#13;
<p class="TX">This function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count</samp> bytes from <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_reg</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> is part of a structure, we can assume it’s a memory operand that accepts an offset, like <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>. We iterate over the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> in reverse order: we start at its final byte, with offset <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count - 1</samp>, and end at byte zero. We use a simple helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset</samp>, to construct the assembly operand for each byte. I won’t give you the pseudocode for this function, since it just adds the specified offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">src _op</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 2)</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset(src_op, 3)</samp> should return <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 5)</samp>.</p>&#13;
<p class="TX">Once we have the assembly operand for the current byte, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction to copy that byte into the destination register. Next, on all but the last loop iteration, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp> instruction to shift the whole register left by 8 bits. We then decrement the offset and move on to the next byte.</p>&#13;
<p class="TX">To copy bytes out of a register, we do the whole thing in reverse. Here’s how we would copy 3 bytes from RDI onto the stack at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:</p>&#13;
<pre><code>movb    %dil, -4(%rbp)&#13;
shrq    $8, %rdi&#13;
movb    %dil, -3(%rbp)&#13;
shrq    $8, %rdi&#13;
movb    %dil, -2(%rbp)</code></pre>&#13;
<p class="TX">First, we copy the lowest byte of RDI into memory. Then, we shift RDI 1 byte to the right, so DIL now contains the second-lowest byte of the structure. We repeat this process until we’ve transferred every byte. <a href="chapter18.xhtml#list18-63">Listing 18-63</a> gives the pseudocode to generate these instructions.</p>&#13;
<a id="list18-63"/>&#13;
<pre><code>copy_bytes_from_reg(src_reg, dst_op, byte_count):&#13;
    offset = 0&#13;
    while offset &lt; byte_count:&#13;
        dst_byte = add_offset(dst_op, offset)&#13;
        emit(Mov(Byte, Reg(src_reg), dst_byte))&#13;
        if offset &lt; byte_count - 1:&#13;
            emit(Binary(ShrTwoOp, Quadword, Imm(8), Reg(src_reg)))&#13;
        offset += 1</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-63: Generating instructions to copy bytes from a register into memory</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_544" aria-label="544"/>As in <a href="chapter18.xhtml#list18-62">Listing 18-62</a>, we can assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp> is a memory operand with an offset. We iterate through the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp> in order, starting with byte zero. On each iteration, we copy the lowest byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp> into the current byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>. Then, on all but the last iteration, we shift <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp> 8 bits to the right.</p>&#13;
<p class="TX">With these two helper functions, we’ve finished our implementation of function calls. Next, we’ll handle the callee side.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
&#13;
<h5 class="H3" id="sec47"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Up Function Parameters</samp></h5>&#13;
<p class="TNI">At the start of a function, we copy every parameter into that function’s stack frame. Now we’ll copy parameters of structure type too. The main wrinkle is that RDI might hold a pointer to the return value’s destination, instead of an ordinary parameter. Let’s revisit <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>, from <span class="Xref-1"><a href="chapter13.xhtml#list13-30">Listing 13-30</a></span>, and see what’s changed. <a href="chapter18.xhtml#list18-64">Listing 18-64</a> gives the new definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up _parameters</samp>, with this chapter’s changes bolded.</p>&#13;
<a id="list18-64"/>&#13;
<pre><code>set_up_parameters(parameters, <b>return_in_memory</b>):&#13;
&#13;
    // classify them&#13;
    int_reg_params, double_reg_params, stack_params = classify_parameters(parameters,&#13;
                                                                          <b>return_in_memory</b>)&#13;
&#13;
    // copy parameters from general-purpose registers&#13;
    int_regs = [DI, SI, DX, CX, R8, R9]&#13;
    reg_index = 0&#13;
&#13;
    <b>if return_in_memory:</b>&#13;
        <b>emit(Mov(Quadword, Reg(DI), Memory(BP, -8)))</b>&#13;
        <b>reg_index = 1</b>&#13;
&#13;
    for (param_type, param) in int_reg_params:&#13;
        r = int_regs[reg_index]&#13;
        <b>if param_type is ByteArray(size, alignment):</b>&#13;
            <b>copy_bytes_from_reg(r, param, size)</b>&#13;
        <b>else:</b>&#13;
            emit(Mov(param_type, Reg(r), param))&#13;
        reg_index += 1&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    // copy parameters from the stack&#13;
    offset = 16&#13;
    for (param_type, param) in stack_params:&#13;
        <b>if param_type is ByteArray(size, alignment):</b>&#13;
            <b>copy_bytes(from=Memory(BP, offset), to=param, count=size)</b>&#13;
        <b>else:</b>&#13;
            emit(Mov(param_type, Memory(BP, offset), param))&#13;
        offset += 8</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-64: Copying function parameters to the stack</samp></p>&#13;
<p class="TX">We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp> flag, which we’ll pass through to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _parameters</samp>. This flag also dictates how we’ll handle the value in RDI. If RDI <span role="doc-pagebreak" epub:type="pagebreak" id="pg_545" aria-label="545"/>points to the return value’s destination, we’ll copy it to the first open slot on the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>; we’ll retrieve it from this slot when we need to return a value. (In the next section, we’ll update the pseudo-operand replacement pass so it doesn’t clobber this pointer by assigning a local variable to the same spot.) In this case, we’ll also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>, just like we did when we passed arguments in <a href="chapter18.xhtml#list18-61">Listing 18-61</a>, so that we’ll look for ordinary parameters starting in RSI instead of RDI.</p>&#13;
<p class="TX">To copy irregularly sized operands out of registers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy _bytes_from_reg</samp> helper function from <a href="chapter18.xhtml#list18-63">Listing 18-63</a>. To copy irregularly sized operands that were passed on the stack, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> helper function. If an operand has type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, we’ll copy it into place with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction, regardless of whether it represents a scalar value or a chunk of a structure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec48">&#13;
&#13;
<h5 class="H3" id="sec48"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Return</samp></h5>&#13;
<p class="TNI"><a href="chapter18.xhtml#list18-65">Listing 18-65</a> illustrates how to convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to assembly.</p>&#13;
<a id="list18-65"/>&#13;
<pre><code>convert_return_instruction(Return(retval)):&#13;
    if retval is null:&#13;
        emit(Ret)&#13;
        return&#13;
&#13;
    int_retvals, double_retvals, return_in_memory = classify_return_value(retval)&#13;
&#13;
    if return_in_memory:&#13;
        emit(Mov(Quadword, Memory(BP, -8), Reg(AX))) <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        return_storage = Memory(AX, 0)&#13;
        ret_operand = convert_val(retval)&#13;
        t = assembly_type_of(retval)&#13;
        copy_bytes(from=ret_operand, to=return_storage, count=t.size) <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    else:&#13;
        int_return_registers = [AX, DX]&#13;
        double_return_registers = [XMM0, XMM1]&#13;
&#13;
        reg_index = 0&#13;
        for (t, op) in int_retvals: <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            r = int_return_registers[reg_index]&#13;
            if t is ByteArray(size, alignment):&#13;
                copy_bytes_to_reg(op, r, size)&#13;
            else:&#13;
                emit(Mov(t, op, Reg(r)))&#13;
            reg_index += 1&#13;
&#13;
        reg_index = 0&#13;
        for op in double_retvals: <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            r = double_return_registers[reg_index]&#13;
            emit(Mov(Double, op, Reg(r)))&#13;
            reg_index += 1&#13;
&#13;
    emit(Ret)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-65: Implementing the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Return</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_546" aria-label="546"/>Assuming the function returns a value, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we start by classifying that value. Then, we check whether we need to return it in memory or in registers. To return it in memory, we first retrieve the pointer to the destination from <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. We copy that pointer into RAX, as the System V calling convention requires <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we copy the return value into the block of memory that RAX points to. We perform this copy using the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy _bytes</samp> helper function <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">If the return value is passed in one or more registers, we iterate through the operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>, copying each one into the corresponding general-purpose register <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We then iterate through <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>, copying these values into XMM0 and XMM1 <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Once we’ve copied every part of the return value to the correct location, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec49">&#13;
&#13;
<h5 class="H3" id="sec49"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tracking Which Functions Pass Return Values in Memory</samp></h5>&#13;
<p class="TNI">Finally, we’ll extend the backend symbol table to track which functions return values in memory. <a href="chapter18.xhtml#list18-66">Listing 18-66</a> shows how to update our definition of a backend symbol table entry.</p>&#13;
<a id="list18-66"/>&#13;
<pre><code>asm_symtab_entry = ObjEntry(assembly_type, bool is_static, bool is_constant)&#13;
                 | FunEntry(bool defined, <b>bool return_on_stack</b>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-66: The updated definition of an entry in the backend symbol table</samp></p>&#13;
<p class="TX">As you’d expect, we’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if a function passes its return value on the stack and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if it passes its return value in registers or returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. The pseudo-operand replacement pass will use this flag to figure out if the quadword starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> is available or if it holds the pointer to the memory where the return value will be passed. If a function has an incomplete return type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> (which can happen if it’s declared but never defined or called), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp> flag will never be used, so we can just set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec50">&#13;
&#13;
<h4 class="H2" id="sec50"><span id="h2-202"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp></h4>&#13;
<p class="TNI">We’ve now covered all the pieces of assembly generation! <a href="chapter18.xhtml#tab18-1">Tables 18-1</a> through <a href="chapter18.xhtml#tab18-4">18-4</a> summarize the latest updates to the conversion from TACKY to assembly; as usual, new constructs and changes to the conversions for existing constructs are bolded. <span class="Xref-1"><a href="appendix-B.xhtml">Appendix B</a></span> includes the complete conversion from TACKY to assembly for this chapter, since this is the final chapter in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TT" id="tab18-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_547" aria-label="547"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,&#13;
         global,&#13;
         params,&#13;
         instructions)</samp></code></pre></td>&#13;
<td class="Basic-Table TBFL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Return value<br/>in registers<br/>or no return<br/>value</samp></p></td>&#13;
<td class="Basic-Table TBFL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global,</samp>&#13;
  <samp class="SANS_Futura_Std_Book_11">[ </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy Reg(DI) into first int param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;copy Reg(SI) into second int param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next four int</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from registers&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
    Mov(Double,&#13;
        Reg(XMM0),&#13;
       </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;first double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">param/eightbyte</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),&#13;
    Mov(Double,&#13;
        Reg(XMM1),</samp>&#13;
  <samp class="SANS_TheSansMonoCd_W7Bold_B_11">      </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;second double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">param/eightbyte</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next six double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from registers&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, </samp>&#13;
 <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;copy Memory(BP, 16) into first stack param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;copy Memory(BP, 24) into second stack param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy remaining</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from stack&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">] +&#13;
 instructions)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Return value<br/>on stack</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global,&#13;
 [</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Quadword,&#13;
       Reg(DI),&#13;
       Memory(BP, -8)),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy Reg(SI) into first int param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy Reg(DX) into second int param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
  </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">three</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">int</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from registers&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
   Mov(Double,&#13;
       Reg(XMM0),&#13;
      </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;first</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),&#13;
   Mov(Double,&#13;
       Reg(XMM1),&#13;
      </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;second double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">param/eightbyte</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),&#13;
  </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next six double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from registers&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy Memory(BP, 16) into first stack param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy Memory(BP, 24) into second stack param/eightbyte&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,&#13;
 </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy remaining</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">params/eightbytes</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> from stack&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">] +&#13;
 instructions)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_548" aria-label="548"/>&#13;
<p class="TT" id="tab18-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Return on<br/>stack</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Quadword, Memory(BP, -8), Reg(AX))&#13;
Mov(Quadword,</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;first eightbyte of return value&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    Memory(AX, 0))&#13;
Mov(Quadword,&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;second eightbyte of return value&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    Memory(AX, 8))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy rest of return value&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"/>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Return in<br/>registers</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;move integer parts of return value into RAX, RDX&gt;&#13;
&lt;move double parts of return value into XMM0, XMM1&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"/>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">No return value</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate, src, dst)</samp>&#13;
<samp class="SANS_Futura_Std_Book_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp><samp class="SANS_Futura_Std_Book_11"> negation)</samp></code></pre></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Double, src, dst)&#13;
Binary(Xor, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;negative-zero&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp>&#13;
<samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;negative-zero&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 16,&#13;
               DoubleInit(-0.0))</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scalar</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src, 0),&#13;
    PseudoMem(dst, 0))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;next chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),&#13;
    PseudoMem(dst,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining chunks&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Load(ptr, dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scalar</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Memory(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 0), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0),&#13;
    PseudoMem(dst, 0))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;next chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),&#13;
    PseudoMem(dst,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining chunks&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Store(src, ptr)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scalar</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, Memory(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 0))</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Quadword, ptr, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src, 0),&#13;
    Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;next chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),&#13;
    Memory(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining chunks&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset(src, dst,&#13;
             offset)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> <samp class="SANS_Futura_Std_Book_11">is&#13;
scalar</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, PseudoMem(dst, offset))</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">src</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is a<br/>structure</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src, 0),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    PseudoMem(dst, offset))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;next chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),&#13;
    PseudoMem(dst, offset +</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining chunks&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">CopyFromOffset(src,&#13;
               offset,&#13;
               dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is scalar</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, PseudoMem(src, offset), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is a structure</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src, offset),&#13;
    PseudoMem(dst, 0))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;next chunk type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
    PseudoMem(src, offset +</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),&#13;
    PseudoMem(dst,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first chunk size&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining chunks&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name,&#13;
        args, dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst<br/>will be<br/>returned<br/>in<br/>memory</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Lea(dst, Reg(DI))</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;move arguments to general-purpose registers,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">starting with RSI</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&gt;&#13;
&lt;move arguments to XMM registers&gt;&#13;
&lt;push arguments onto the stack&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst<br/>will be<br/>returned<br/>in<br/>registers</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;&#13;
&lt;move arguments to general-purpose registers&gt;&#13;
&lt;move arguments to XMM registers&gt;&#13;
&lt;push arguments onto the stack&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;move integer parts of return value from RAX, RDX into dst&gt;&#13;
&lt;move double parts of return value from XMM0, XMM1 into dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is<br/>absent</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;&#13;
&lt;move arguments to general-purpose registers&gt;&#13;
&lt;move arguments to XMM registers&gt;&#13;
&lt;push arguments onto the stack&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt(src, dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned&#13;
char</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Longword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned&#13;
int</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Mov(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"/>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned&#13;
long</samp></code></pre></td>&#13;
<td class="Basic-Table TBL graybg"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), src)&#13;
JmpCC(AE,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)&#13;
Cvttsd2si(Quadword, src, dst)&#13;
Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)&#13;
Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)&#13;
Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Binary(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)&#13;
Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))&#13;
Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)&#13;
Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>&#13;
<samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 8,&#13;
DoubleInit(9223372036854775808.0))</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_549" aria-label="549"/>&#13;
<p class="TT" id="tab18-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(ConstDouble(double))</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ident&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 0</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>&#13;
<samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;ident&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 8,&#13;
               DoubleInit(double))</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab18-4"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_550" aria-label="550"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structure(tag)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ByteArray(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;size from type table&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,&#13;
         </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment from type table&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment from type table</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that we now include offsets on every <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand we generate. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands at this point represent floating-point constants; these include the constants we use in the conversions for floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> in <a href="chapter18.xhtml#tab18-2">Table 18-2</a> and ordinary floating-point TACKY constants in <a href="chapter18.xhtml#tab18-3">Table 18-3</a>. These operands all have an offset of zero.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec51">&#13;
&#13;
<h4 class="H2" id="sec51"><span id="h2-203"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudo-operands</samp></h4>&#13;
<p class="TNI">We’ll make two small changes to this pass. First, we’ll supply offsets for <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> is a static variable, we’ll convert</p>&#13;
<pre><code>PseudoMem("v", 0)</code></pre>&#13;
<p class="BodyContinued">to</p>&#13;
<pre><code>Data("v", 0)</code></pre>&#13;
<p class="BodyContinued">and</p>&#13;
<pre><code>PseudoMem("v", 10)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Data("v", 10)</code></pre>&#13;
<p class="TX">Second, we need to avoid clobbering the return value pointer in <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. Before we start allocating stack space, we’ll check the backend symbol table to see whether the function’s return value will be passed in memory. If it will, we’ll reserve the quadword starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> for the return value pointer and allocate space for pseudoregisters only at addresses lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. For example, if the first pseudoregister we encounter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, we’ll map it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.</p>&#13;
<p class="TX">The instruction fix-up pass won’t change in this chapter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instructions we emit during code generation are already valid and don’t need to be fixed up, since the destination operand is always a register and the source operand is always the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.</p>&#13;
<aside class="box" aria-label="box-66"><p class="BoxTitle" id="box-66"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_551" aria-label="551"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler </b><b><var>/path/to/your_compiler</var></b><b> --chapter 18 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec52">&#13;
&#13;
<h3 class="H1" id="sec52"><span id="h1-167"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">The code emission pass requires two small changes. First, we’ll include the offsets on <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands. For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("x", 4)</samp> as:</p>&#13;
<pre><code>x+4(%rip)</code></pre>&#13;
<p class="BodyContinued">If the offset is zero, you can either include it or omit it.</p>&#13;
<p class="TX">Second, we’ll emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp> assembly instructions as <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>, respectively. These take the usual operand size suffixes.</p>&#13;
<p class="TX"><a href="chapter18.xhtml#tab18-5">Tables 18-5</a> and <a href="chapter18.xhtml#tab18-6">18-6</a> show these changes to the code emission pass. <span class="Xref-1"><a href="appendix-B.xhtml">Appendix B</a></span> includes the complete code emission pass for this chapter, since this is the final chapter of <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TT" id="tab18-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Names for Assembly Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shl</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">shl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ShrTwoOp</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab18-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 18-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Data(identifier</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, int</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;identifier&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(%rip)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">And with that, you’re done with the chapter; your compiler now supports structures!</p>&#13;
<aside class="box" aria-label="box-67"><p class="BoxTitle" id="box-67"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b><b> --chapter 18</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_552" aria-label="552"/><samp class="SANS_Futura_Std_Book_11">I recommend debugging the valid test cases for this chapter in several stages. Start with the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/no_structure_parameters</samp><samp class="SANS_Futura_Std_Book_11">. These test programs don’t include any parameters or return values of structure type, but they exercise all the other functionality you added in this chapter. They declare structures, assign to them, and access structure members using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> <samp class="SANS_Futura_Std_Book_11">operators. These tests also pass and return pointers to structures.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The last tests you should debug in the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">no_structure_parameters</samp> <samp class="SANS_Futura_Std_Book_11">directory are the multifile tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/no_structure_parameters/libraries</samp><samp class="SANS_Futura_Std_Book_11">. These tests pass pointers to structures between functions in different compilation units; they also define structures and arrays of structures as global variables. They test that each structure’s size, alignment, and layout in memory match the System V ABI, but they don’t test the changes to the calling convention.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/parameters</samp> <samp class="SANS_Futura_Std_Book_11">include parameters, but not return values, of structure type. This directory also includes multifile tests (in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/parameters/libraries</samp><samp class="SANS_Futura_Std_Book_11">), to make sure your compiler passes parameters according to the System V ABI. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/params_and_returns</samp><samp class="SANS_Futura_Std_Book_11">, including the multifile tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_18/valid/params _and_returns/libraries</samp><samp class="SANS_Futura_Std_Book_11">, include functions with both parameters and return values of structure type.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec53">&#13;
&#13;
<h3 class="H1" id="sec53"><span id="h1-168"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Unions</samp></h3>&#13;
<p class="TNI">Structure and union types have a lot in common. Their type declarations share the same syntax and declare tags in the same namespace. They follow the same typing rules and support the same operations, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operators. The difference is that the members of a structure are laid out sequentially in memory, whereas the members of a union all start at the same address, such that writing to one overwrites the others. From the compiler’s perspective, a union is basically a structure where every member’s offset is zero. This makes it relatively straightforward to extend the work you did in this chapter to support unions too. Still, this is a bigger challenge than previous extra credit features. It’s an opportunity to add a new language feature on your own.</p>&#13;
<p class="TX">If you implement union types, there are a few points you should keep in mind. First, remember that we restricted where structures can be declared to make compilation easier. The test cases for unions also follow the same restrictions; that means you don’t need to support anonymous union declarations or union declarations that are part of declarations of some other type or variable.</p>&#13;
<p class="TX">In the type checker, you’ll add union definitions to the type table. Structure and union tags share a namespace, so defining a structure and a union type with the same tag in the same scope is an error. You’ll need <span role="doc-pagebreak" epub:type="pagebreak" id="pg_553" aria-label="553"/>to track each union’s size and alignment (you can look up how to calculate these in the System V ABI). You’ll also need to type check compound initializers for unions. A union initializer should have a single element, which initializes the union’s first member. (C provides syntax to specify which union member to initialize, but you don’t have to implement it.)</p>&#13;
<p class="TX">On the backend, the System V calling convention treats unions similarly to structures; a union will be passed in memory, in two registers, or in one register, depending on its size and the types of its members. For all the gory details, see the links in <span class="Xref">“Additional Resources.”</span> Good luck!</p>&#13;
<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--union</samp> flag to test your compiler’s support for union types:</p>&#13;
<pre><code>$ <b>./test_compiler </b><var><b>/path/to/your_compiler</b></var> <b>--chapter 18 --union</b></code></pre>&#13;
<p class="TX">Or, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag to test every extra credit feature.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec54">&#13;
&#13;
<h3 class="H1" id="sec54"><span id="h1-169"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You’ve finished <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>! In this chapter, you learned how to analyze structure type declarations, manipulate aggregate objects in TACKY, and transfer structures according to the System V calling convention. Your compiler now supports every language feature this book covers, including most of the statements, expressions, and types in the C language. You can officially tell people that you’ve written a C compiler.</p>&#13;
<p class="TX">If you want, you can stop here. Or, you can move on to <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, where you’ll implement several compiler optimizations to generate more efficient assembly code. In <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span>, you’ll optimize TACKY programs by eliminating useless instructions and evaluating constant expressions at compile time. In <span class="Xref-1"><a href="chapter20.xhtml">Chapter 20</a></span>, you’ll write a register allocator, which maps pseudoregisters to hardware registers instead of locations on the stack. These optimizations aren’t specific to C or x64 assembly; you’ll find them in compilers with lots of different source and target languages.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec55">&#13;
&#13;
<h3 class="H1" id="sec55"><span id="h1-170"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">If you want to learn about the complete System V x64 calling convention, including all the rules for passing structures and unions, you have a couple of options:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">The official System V x86-64 ABI is available at <i><a href="https://gitlab.com/x86-psABIs/x86-64-ABI">https://<wbr/>gitlab<wbr/>.com<wbr/>/x86<wbr/>-psABIs<wbr/>/x86<wbr/>-64<wbr/>-ABI</a></i>. (I’ve linked to this a couple of times already.) Section 3.2.3 discusses parameter passing.</li>&#13;
<li class="ListBullet">Agner Fog has written a helpful manual describing the calling conventions of different C++ compilers (<i><a href="https://www.agner.org/optimize/calling_conventions.pdf">https://<wbr/>www<wbr/>.agner<wbr/>.org<wbr/>/optimize<wbr/>/calling<wbr/>_conventions<wbr/>.pdf</a></i>). Tables 6 and 7, in Section 7.1, cover how structures <span role="doc-pagebreak" epub:type="pagebreak" id="pg_554" aria-label="554"/>are passed and returned. The document covers C++, so parts of it aren’t relevant, but the description of how to pass plain structures and unions applies to C as well as C++.</li>&#13;
</ul>&#13;
<p class="TX">I found Fog’s summary of calling conventions easier to follow than the official ABI. If you decide to implement unions for extra credit, you’ll probably need to refer to both documents.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>