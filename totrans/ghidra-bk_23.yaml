- en: '## **19'
  prefs: []
  type: TYPE_NORMAL
- en: THE GHIDRA DECOMPILER**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Until now, we’ve focused our reverse engineering analysis on the Listing window
    and presented Ghidra’s features through the disassembly listing lens. In this
    chapter, we shift our focus to the Decompiler window and investigate how we can
    accomplish familiar analysis tasks (and some new ones) with the Decompiler and
    its associated functionality. We start with a brief overview of the decompilation
    process before moving on to the functionality available in the Decompiler window.
    We then walk through some examples to help you identify ways that the Decompiler
    window can be used to improve your reverse engineering process.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Decompiler Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s logical to assume that the content in the Decompiler window is derived
    from the Listing window, but, surprisingly, the contents of the Listing window
    and Decompiler window are derived independently, which is why they sometimes disagree
    and why both should be evaluated in context when you’re trying to determine ground
    truth. The main function of Ghidra’s Decompiler is to convert machine language
    instructions into p-code (see [Chapter 18](ch18.xhtml#ch18)) and then to convert
    the p-code to C and present it in the Decompiler window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simplified view, the decompilation process includes three distinct phases.
    In the first phase, the Decompiler uses the SLEIGH specification file to create
    a draft of the p-code and derive associated basic blocks and flows. The second
    phase focuses on simplification: unneeded content such as unreachable code is
    eliminated, and then control flows are adjusted and tuned in response to the changes.
    In the wrap-up phase, finishing touches are added, some final checks are made,
    and the final results are sent through a pretty-printing algorithm before being
    presented in the Decompiler window. Of course, this greatly simplifies a very
    complex process, but the main takeaways are the following:^([1](footnotes.xhtml#ch19fn1))'
  prefs: []
  type: TYPE_NORMAL
- en: The Decompiler is an analyzer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It starts its work with the binary and produces p-code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It converts the p-code to C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C code and any associated messages are displayed in the Decompiler window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discuss some of these steps in more detail as we navigate through Ghidra’s
    decompilation functionality. Let’s start our investigation with the analysis process
    and the primary capabilities it unleashes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the auto analysis process, there are several analyzers that pertain to
    the Decompiler window. Decompiler analysis options are managed through the Edit
    ▸ Tool Options menu, shown in [Figure 19-1](ch19.xhtml#fig19_1) with defaults
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss two of these options, Eliminate unreachable code and Simplify predication,
    next. For the remaining options, you can experiment with their results or refer
    to Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-1: Ghidra Decompiler analysis options with defaults selected*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eliminate Unreachable Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Eliminate unreachable code option excludes unreachable code from the Decompiler
    listing. For example, the following C function has two conditions that can never
    be met, which makes the corresponding conditional blocks unreachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The variable `b` is initialized to zero in a perhaps less than obvious manner.
    When `b` is tested ➊, its value can never be non zero, and the body of the corresponding
    `if` statement will never be executed. Similarly `a - a` can never be greater
    than zero, and the condition in the second `if` statement ➋ can also never evaluate
    to true. When the Eliminate unreachable code option is selected, the Decompiler
    window displays warning messages to let us know it has removed unreachable code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Simplify Predication**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This option optimizes `if`/`else` blocks by merging blocks that share the same
    condition. In the following listing, the first two `if` statements share the same
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With Simplify predication enabled, the resulting Decompiler listing shows the
    combined blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**The Decompiler Window**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand how the Decompiler Analysis Engine populates the Decompiler
    window, let’s see how you can use the window to facilitate your analysis. Navigating
    the Decompiler window is relatively easy, as it displays only one function at
    a time. To move between functions or see the function in context, it is helpful
    to correlate with the Listing window. Because the Decompiler window and the Listing
    window are linked by default, you can navigate both by using the available options
    in the CodeBrowser toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function displayed in the Decompiler window helps with analysis, but it
    may not be so easy to read at first. Any lack of information about the data types
    used by the functions that it decompiles requires Ghidra to infer those data types
    itself. As a result, the decompiler may overuse type casts, as you can see in
    the following sample statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you provide more accurate type information using the Decompiler editing options,
    you will notice that the Decompiler relies less and less on type casts, and the
    generated C code become easier to read. In the examples that follow, we’ll discuss
    some of the Decompiler window’s most useful features to clean up the generated
    source code. The ultimate goal is readable source code that is easier to comprehend,
    which reduces the amount of time needed to understand the behavior of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 1: Editing in the Decompiler Window***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider a program that accepts two integer values from the user and then calls
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function uses two integer parameters with five local variables to generate
    its output. The interdependencies can be summed up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `c` depends on the `rand()` return value, influences `d` and `e` directly,
    and influences `f` and `g` indirectly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `d` depends on `a`, `b`, and `c`, and influences `f` directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `e` depends on `a` and `c`, and influences `g` directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `f` depends on `d` directly and on `a`, `b`, and `c` indirectly, and
    influences nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `g` depends on `e` directly and on `a` and `c` indirectly, and influences
    nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the associated binary is loaded into Ghidra and the function is analyzed,
    you see the following representation of the `do_math` function in the Decompiler
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you want to do your analysis using the Decompiler, you’ll want to make sure
    the code the Decompiler is generating is as accurate as possible. Usually, this
    is done by providing as much information as possible about data types and function
    prototypes. Functions that accept a variable number of arguments, such as `printf`,
    are especially tricky for the Decompiler since the Decompiler would need to fully
    understand the semantics of the required arguments in order to estimate the number
    of supplied optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '##### **Overriding Function Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: You can see a number of `printf` statements ➊ that don’t look quite right. Each
    one has a format string but no additional arguments. Since `printf` takes a variable
    number of arguments, you can override the function signature at each calling location
    and (based on the format string) indicate that the `printf` statement should take
    one integer argument.^([2](footnotes.xhtml#ch19fn2)) To make this change, right-click
    a `printf` statement and choose **Override Signature** from the context menu to
    open the dialog shown in [Figure 19-2](ch19.xhtml#fig19_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-2: The Override Signature dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the second parameter type, `int`, to the signature (as shown in the
    figure) for each of the `printf` statements results in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the updated calls to `printf` with the correct arguments, two
    new lines have been added to the Decompiler listing as a result of overriding
    the `printf` function ➋ ➌. These statements weren’t included previously because
    Ghidra believed the results were not used. Once the Decompiler understands that
    the results are used in each `printf`, the statements become meaningful and are
    displayed in the Decompiler window.
  prefs: []
  type: TYPE_NORMAL
- en: '**Editing Variable Types and Names**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After correcting the function calls, you can continue cleaning up the listing
    by renaming (hotkey L) and retyping (hotkey CTRL-L) the parameters and the variables
    ➊ based on the names found in the `printf` format strings. As an aside, format
    strings are an extremely valuable source of information regarding the type and
    purpose of variables in any program.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes have been completed, the final `printf` statement ➍ is
    still a bit cumbersome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Right-clicking this statement allows you to override the function signature.
    The first argument in this `printf` statement is the format string, and it doesn’t
    need to be modified. Changing the rest of the arguments to type `int` results
    in the following cleaner code ([Listing 19-1](ch19.xhtml#exa19_1)) in the Decompiler
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-1: Decompiled function with updated signatures*'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to our original source code and much easier to read than
    the original Decompiler listing as the modifications of the function arguments
    have been propagated throughout the listing. One difference between the Decompiler
    listing and our original source code is that the variable `f` has been replaced
    by an equivalent expression ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlighting Slices**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you have a more understandable Decompiler window, you can begin further
    analysis. Suppose that you want to know how individual variables affect and are
    affected by other variables. A *program slice* is a collection of statements that
    contribute to the value of a variable (*backward slice*) or are affected by a
    variable (*forward slice*). In vulnerability analysis scenarios, this might manifest
    as “I have control of this variable; where does its value get used?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghidra provides five options in its right-click context menu to highlight relationships
    between variables and instructions in a function. If you right-click a variable
    in the Decompiler window, you can choose from the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlight Def-use** This option highlights all uses of the variable within
    the function. (You can use a middle mouse click to get the same effect.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlight Forward Slice** This option highlights everything that is impacted
    by the value in the selected variable. For example, if you select variable `b`
    in [Listing 19-1](ch19.xhtml#exa19_1) and choose this option, all occurrences
    of `b` and `d` will be highlighted in the listing, because a change in the value
    of `b` could also result in a change in the value of `d`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlight Backward Slice** This is the inverse of the previous option and
    highlights all of the variables that contribute to a particular value. If you
    right-click variable `e` in the final `printf` statement in [Listing 19-1](ch19.xhtml#exa19_1)
    and choose this option, all of the variables that affect the value of `e` (in
    this case `e`, `a`, and `c`) will be highlighted. Changing `a` or `c` could also
    change the value of `e`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlight Forward Inst Slice** This option highlights the entire statement
    associated with the Highlight Forward Slice option. In [Listing 19-1](ch19.xhtml#exa19_1),
    if you use this option while variable `b` is selected, all statements in which
    `b` or `d` appear will be highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highlight Backward Inst Slice** This option highlights the entire statement
    associated with the Highlight Backward Slice option. In [Listing 19-1](ch19.xhtml#exa19_1),
    selecting this option while highlighting variable `e` in the final `printf` statement
    will cause all statements in which `a`, `c`, or `e` appear to be highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a general understanding of some approaches to work with the
    Decompiler window and use it in our analysis, let’s look at a more specific example.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 2: Non-Returning Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In general, Ghidra can safely assume function calls return and therefore treat
    function calls as if they exhibit sequential flow within basic blocks. However,
    some functions, such as those marked with the `noreturn` keyword in source code,
    or ended with an obfuscated jump instruction in malware, do not return, and Ghidra
    may generate inaccurate disassembled or decompiled code. Ghidra offers three approaches
    for dealing with non-returning functions: two non-returning function analyzers
    and the capability to edit function signatures manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghidra can identify non-returning functions based on a list of known `noreturn`
    functions such as `exit` and `abort` using the Non-Returning Functions-Known analyzer.
    This analyzer is selected by default as part of auto analysis, and its job is
    straightforward: if a function name appears in its list, it marks the function
    as non-returning and does its best to correct any associated issues (for example,
    set associated calls to non-returning, find flows that might need repairing, and
    so on).'
  prefs: []
  type: TYPE_NORMAL
- en: The Non-Returning Functions-Discovered analyzer looks for clues that might indicate
    that a function doesn’t return (for example, data or bad instructions right after
    the call). What it does with the information is largely controlled by the three
    options associated with the analyzer, as shown in [Figure 19-3](ch19.xhtml#fig19_3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-3: Analysis options for Non-Returning Functions-Discovered*'
  prefs: []
  type: TYPE_NORMAL
- en: The first option ➊ allows the automatic creation of analysis bookmarks (which
    appear on the Listing window’s bookmark bar). The second option ➋ allows you to
    specify a threshold that determines whether to designate a function as non-returning
    based on a series of checks for characteristics that are likely to indicate a
    non-returning function. Finally, there is a checkbox ➌ to repair the associated
    flow damage.
  prefs: []
  type: TYPE_NORMAL
- en: When Ghidra is unable to identify a non-returning function, you have the option
    to edit the function signature yourself. If you complete analysis and have error
    bookmarks, which are used to flag bad instructions, then that is a good indication
    that something is not quite right with Ghidra’s own analysis. If the bad instruction
    follows a `CALL`, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'then you are likely to see an associated post-comment warning you about the
    situation in the Decompiler window, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you click the function name (`noReturnA` in this case) in the Decompiler
    window and then choose Edit Function Signature, you will have the option to modify
    attributes associated with the function, as shown in [Figure 19-4](ch19.xhtml#fig19_4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-4: Editing function attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the No Return box to mark the function as non-returning. Ghidra then
    inserts a pre comment, shown next, in the Decompiler window as well as a post
    comment in the Listing window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this error corrected, you can move on to other issues.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example 3: Automated Structure Creation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When analyzing decompiled C source code, you’re likely to come across statements
    that appear to contain structure field references. Ghidra helps you create a structure
    and populate it based on the associated references that the Decompiler has detected.
    Let’s walk through an example starting with the source code and Ghidra’s initial
    decompilation of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have source code that defines two struct types and then creates
    a global instance of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'One structure ➊ contains homogeneous elements, and the other ➋ contains a heterogeneous
    collection of types. The source code also contains three functions, one of which
    (`do_struct_demo`) declares a local instance of each structure type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The decompiled version of `do_struct_demo` appears in [Listing 19-2](ch19.xhtml#exa19_2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-2: Initial decompilation of* `do_struct_demo`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating to the `display_s1` function from either function call ➊➋ by double-clicking
    it in the Decompiler window yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you suspect the argument to `display_s1` might be a structure pointer,
    you can ask Ghidra to automate the process of creating a struct for you by right-clicking
    `param_1` in the function’s argument list and selecting Auto Create Structure
    from the context menu. In response, Ghidra tracks all uses of `param_1`, treats
    all arithmetic performed on the pointer as referencing a member of a struct, and
    automatically creates a new struct type containing fields at each referenced offset.
    This changes a few things in the Decompiler listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The type of the parameter has changed and is now `astruct*`, and the call to
    `printf` now contains field references. The new type has also been added to the
    Data Type Manager, and hovering over the structure name displays the field definitions,
    as shown in [Figure 19-5](ch19.xhtml#fig19_5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-5: Automatic structs in the Data Type Manager*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update the type for `local_20` and `GLOBAL_S1` to `astruct` by using
    the Retype Variable option from the right-click context menu. The results are
    shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this with [Listing 19-2](ch19.xhtml#exa19_2) shows the modification
    of the type for `local_20` ➊ and the addition of field references for both `local_20`
    ➋ ➌ and `GLOBAL_S1` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s shift focus to the decompilation of the third function, `update_s2`, shown
    in [Listing 19-3](ch19.xhtml#exa19_3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-3: Initial decompilation of* `update_s2`'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous approach to automatically create a structure for `param_1`.
    Simply right-click `param_1` in the function and choose **Auto Create Structure**
    from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Data Type Manager now has a second struct definition associated with this
    file, as shown in [Figure 19-6](ch19.xhtml#fig19_6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig19-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-6: Additional automatic structs in the Data Type Manager window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure has an `int`, a `char`, three `undefined` bytes (likely padding
    inserted by the compiler), and a `float`. To edit the structure, right-click `astruct_1`
    and choose Edit from the context menu, which opens the Structure Editor window.
    If we choose to name the `int` field `x`, the `char` field `y`, and the `float`
    field `z`, and then save the changes, the new field names will be reflected in
    the Decompiler listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This listing is much easier to read and understand than the original decompilation
    in [Listing 19-3](ch19.xhtml#exa19_3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Decompiler window, like the Listing window, provides you with a view into
    a binary, and each has its associated strengths and weaknesses. The Decompiler
    provides a higher-level view that can help you understand the general structure
    and functionality of a single function more quickly than looking at the disassembly
    (particularly for those who do not have years of experience reading disassembly
    listings). The Listing window provides a lower-level view of the entire binary,
    with all of the available detail, but this can make it more difficult to gain
    insight into the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra’s Decompiler can be used effectively with the Listing window and all
    of the other tools we have introduced throughout the book to aid you in your reverse
    engineering process. In the end, it is the reverse engineer’s role to determine
    the best approach to solving the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focused on the Decompiler window and issues associated with decompilation.
    Many of challenges can be traced to the wide variety of compilers and associated
    compiler options that directly influence the resulting binary. In the next chapter,
    we take a look at some compiler-specific behaviors and compiler build options
    to better understand the resulting binaries.
  prefs: []
  type: TYPE_NORMAL
