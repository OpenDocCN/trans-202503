["```\n{-# OPTIONS -Wall #-}\n\nmodule ElectricField where\n\nimport SimpleVec\n    ( R, Vec, (^+^), (^-^), (*^), (^*), (^/), (<.>), (><)\n    , sumV, magnitude, vec, xComp, yComp, zComp, kHat )\nimport CoordinateSystems\n    ( Position, ScalarField, VectorField\n    , displacement, shiftPosition, addVectorFields\n    , cart, sph, vf3D, vfPNGxy, vfGrad, origin, rVF )\nimport Geometry ( Curve(..), Surface(..), Volume(..) )\nimport Charge\n    ( Charge, ChargeDistribution(..)\n    , diskCap, protonOrigin, simpleDipole, lineDipole )\n```", "```\nepsilon0 :: R\nepsilon0 = 1/(mu0 * cSI**2)\n```", "```\ncSI :: R\ncSI = 299792458  -- m/s\n```", "```\nmu0 :: R\nmu0 = 4e-7 * pi  -- N/A^2\n```", "```\neFieldFromPointCharge\n    :: Charge       -- in Coulombs\n    -> Position     -- of point charge (in m)\n    -> VectorField  -- electric field (in V/m)\neFieldFromPointCharge q1 r1 r\n    = let k = 1 / (4 * pi * epsilon0)\n          d = displacement r1 r\n      in (k * q1) *^ d ^/ magnitude d ** 3\n```", "```\neField :: ChargeDistribution -> VectorField\neField (PointCharge   q   r) = eFieldFromPointCharge   q   r\neField (LineCharge    lam c) = eFieldFromLineCharge    lam c\neField (SurfaceCharge sig s) = eFieldFromSurfaceCharge sig s\neField (VolumeCharge  rho v) = eFieldFromVolumeCharge  rho v\neField (MultipleCharges cds) = addVectorFields $ map eField cds\n```", "```\neFieldPicProton2D :: IO ()\neFieldPicProton2D\n     = vfPNGxy \"eFieldPicProton2D.png\" 3e-9 pts (eField protonOrigin)\n       where\n         pts = [(r * cos th, r * sin th) | r <- [1,1.5,2]\n               , th <- [0,pi/4 .. 2*pi]]\n```", "```\neFieldPicProtonGrad :: IO ()\neFieldPicProtonGrad\n    = vfGrad (**0.2) (\\(x,y) -> cart x y 0) (\\v -> (xComp v, yComp v))\n      \"eFieldPicProtonGrad.png\" 20 (eField protonOrigin)\n```", "```\neFieldPicProton3D :: IO ()\neFieldPicProton3D = vf3D 4e-9\n                 [sph r th ph | r  <- [1,1.5,2]\n                              , th <- [0,pi/4..pi]\n                              , ph <- [0,pi/4..2*pi]] (eField protonOrigin)\n```", "```\nsimpleDipoleSodiumChloride :: ChargeDistribution\nsimpleDipoleSodiumChloride = simpleDipole (vec 0 0 2.99e-29) 2.36e-10\n```", "```\neFieldSodiumChloride :: VectorField\neFieldSodiumChloride = eField simpleDipoleSodiumChloride\n```", "```\neFieldPicSimpleDipole :: IO ()\neFieldPicSimpleDipole\n    = vfGrad (**0.2) (\\(y,z) -> cart 0 (3e-10*y) (3e-10*z))\n      (\\v -> (yComp v, zComp v)) \"eFieldPicSimpleDipole.png\" 20\n      eFieldSodiumChloride\n```", "```\neFieldIdealDipole :: Vec          -- electric dipole moment\n                  -> VectorField  -- electric field\neFieldIdealDipole p r\n    = let k = 1 / (4 * pi * epsilon0)  -- SI units\n          rMag = magnitude (rVF r)\n          rUnit = rVF r ^/ rMag\n      in k *^ (1 / rMag**3) *^ (3 *^ (p <.> rUnit) *^ rUnit ^-^ p)\n```", "```\neFieldPicIdealDipole :: IO ()\neFieldPicIdealDipole\n    = vfGrad (**0.2) (\\(y,z) -> cart 0 (3e-10*y) (3e-10*z))\n      (\\v -> (yComp v, zComp v)) \"eFieldPicIdealDipole.png\" 20\n                                     (eFieldIdealDipole kHat)\n```", "```\ntype VectorLineIntegral = VectorField -> Curve -> Vec\n```", "```\ntype CurveApprox = Curve -> [(Position,Vec)]\n```", "```\nvectorLineIntegral :: CurveApprox -> VectorField -> Curve -> Vec\nvectorLineIntegral approx vF c\n    = sumV [vF r' ^* magnitude dl' | (r',dl') <- approx c]\n```", "```\neFieldFromLineCharge\n    :: ScalarField  -- linear charge density lambda\n    -> Curve        -- geometry of the line charge\n    -> VectorField  -- electric field (in V/m)\neFieldFromLineCharge lambda c r\n    = let k = 1 / (4 * pi * epsilon0)\n          integrand r' = lambda r' *^ d ^/ magnitude d ** 3\n              where d = displacement r' r\n      in k *^ vectorLineIntegral (curveSample 1000) integrand c\n```", "```\nlineDipoleSodiumChloride :: ChargeDistribution\nlineDipoleSodiumChloride = lineDipole (vec 0 0 2.99e-29) 2.36e-10\n```", "```\neFieldLineDipole :: VectorField\neFieldLineDipole = eField lineDipoleSodiumChloride\n```", "```\ntype VectorSurfaceIntegral = VectorField -> Surface -> Vec\n```", "```\ntype SurfaceApprox = Surface -> [(Position,Vec)]\n```", "```\nvectorSurfaceIntegral :: SurfaceApprox -> VectorField -> Surface -> Vec\nvectorSurfaceIntegral approx vF s\n    = sumV [vF r' ^* magnitude da' | (r',da') <- approx s]\n```", "```\neFieldFromSurfaceCharge\n    :: ScalarField  -- surface charge density sigma\n    -> Surface      -- geometry of the surface charge\n    -> VectorField  -- electric field (in V/m)\neFieldFromSurfaceCharge sigma s r\n    = let k = 1 / (4 * pi * epsilon0)\n          integrand r' = sigma r' *^ d ^/ magnitude d ** 3\n              where d = displacement r' r\n      in k *^ vectorSurfaceIntegral (surfaceSample 200) integrand s\n```", "```\ndiskCap 0.05 0.04 2e-8 :: ChargeDistribution\n```", "```\neFieldDiskCap :: VectorField\neFieldDiskCap = eField $ diskCap 0.05 0.04 2e-8\n```", "```\nPrelude> :l ElectricField\n[ 1 of 12] Compiling Newton2          ( Newton2.hs, interpreted )\n[ 2 of 12] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[ 3 of 12] Compiling SimpleVec        ( SimpleVec.hs, interpreted ) [ 4 of 12] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[ 5 of 12] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[ 6 of 12] Compiling MOExamples       ( MOExamples.hs, interpreted )\n[ 7 of 12] Compiling Electricity      ( Electricity.hs, interpreted )\n[ 8 of 12] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )\n[ 9 of 12] Compiling Geometry         ( Geometry.hs, interpreted )\n[10 of 12] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )\n[11 of 12] Compiling Charge           ( Charge.hs, interpreted )\n[12 of 12] Compiling ElectricField    ( ElectricField.hs, interpreted )\nOk, 12 modules loaded.\n*ElectricField> eFieldDiskCap (cart 0 0 0)\nvec 0.0 0.0 (-1419.9046806406095)\n```", "```\neFieldPicDiskCap :: IO ()\neFieldPicDiskCap = vfGrad (**0.2) (\\(x,z) -> cart (0.1*x) 0 (0.1*z))\n                (\\v -> (xComp v, zComp v)) \"eFieldPicDiskCap.png\" 20\n                eFieldDiskCap\n```", "```\ntype VectorVolumeIntegral = VectorField -> Volume -> Vec\n```", "```\ntype VolumeApprox = Volume -> [(Position,R)]\n```", "```\nvectorVolumeIntegral :: VolumeApprox -> VectorField -> Volume -> Vec\nvectorVolumeIntegral approx vF vol\n    = sumV [vF r' ^* dv' | (r',dv') <- approx vol]\n```", "```\neFieldFromVolumeCharge\n    :: ScalarField  -- volume charge density rho\n    -> Volume       -- geometry of the volume charge\n    -> VectorField  -- electric field (in V/m)\neFieldFromVolumeCharge rho v r\n    = let k = 1 / (4 * pi * epsilon0)\n          integrand r' = rho r' *^ d ^/ magnitude d ** 3\n              where d = displacement r' r\n      in k *^ vectorVolumeIntegral (volumeSample 50) integrand v\n```", "```\ntype ScalarLineIntegral = ScalarField -> Curve -> R\n```", "```\nscalarLineIntegral :: CurveApprox -> ScalarField -> Curve -> R\nscalarLineIntegral approx f c\n    = sum [f r' * magnitude dl' | (r',dl') <- approx c]\n```", "```\ntype ScalarSurfaceIntegral = ScalarField -> Surface -> R\n```", "```\nscalarSurfaceIntegral :: SurfaceApprox -> ScalarField -> Surface -> R\nscalarSurfaceIntegral approx f s\n    = sum [f r' * magnitude da' | (r',da') <- approx s]\n```", "```\ntype ScalarVolumeIntegral = ScalarField -> Volume -> R\n```", "```\nscalarVolumeIntegral :: VolumeApprox -> ScalarField -> Volume -> R\nscalarVolumeIntegral approx f vol\n    = sum [f r' * dv' | (r',dv') <- approx vol]\n```", "```\n-- introduced earlier in the Chapter\ntype CurveApprox = Curve -> [(Position,Vec)]\n```", "```\ncurveSample :: Int -> Curve -> [(Position,Vec)]\ncurveSample n c\n    = let segCent :: Segment -> Position\n          segCent (p1,p2) = shiftPosition ((rVF p1 ^+^ rVF p2) ^/ 2) origin\n          segDisp :: Segment -> Vec\n          segDisp = uncurry displacement\n      in [(segCent seg, segDisp seg) | seg <- segments n c]\n```", "```\ntype Segment = (Position,Position)\n```", "```\nsegments :: Int -> Curve -> [Segment]\nsegments n (Curve g a b)\n    = let ps = map g $ linSpaced n a b\n      in zip ps (tail ps)\n```", "```\nlinSpaced :: Int -> R -> R -> [R]\nlinSpaced n x0 x1 = take (n+1) [x0, x0+dx .. x1]\n    where dx = (x1 - x0) / fromIntegral n\n```", "```\n*ElectricField> :l ElectricField\n[ 1 of 12] Compiling Newton2          ( Newton2.hs, interpreted )\n[ 2 of 12] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[ 3 of 12] Compiling SimpleVec        ( SimpleVec.hs, interpreted )\n[ 4 of 12] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[ 5 of 12] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[ 6 of 12] Compiling MOExamples       ( MOExamples.hs, interpreted )\n[ 7 of 12] Compiling Electricity      ( Electricity.hs, interpreted )\n[ 8 of 12] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )\n[ 9 of 12] Compiling Geometry         ( Geometry.hs, interpreted )\n[10 of 12] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )\n[11 of 12] Compiling Charge           ( Charge.hs, interpreted )\n[12 of 12] Compiling ElectricField    ( ElectricField.hs, interpreted )\nOk, 12 modules loaded.\n *ElectricField> linSpaced 4 0 2\n[0.0,0.5,1.0,1.5,2.0]\n*ElectricField> linSpaced 4 3 3\n[3.0,3.0,3.0,3.0,3.0]\n```", "```\n-- introduced earlier in the Chapter\ntype SurfaceApprox = Surface -> [(Position,Vec)]\n```", "```\nsurfaceSample :: Int -> Surface -> [(Position,Vec)]\nsurfaceSample n s = [(triCenter tri, triArea tri) | tri <- triangles n s]\n```", "```\ndata Triangle = Tri Position Position Position\n```", "```\ntriCenter :: Triangle -> Position\ntriCenter (Tri p1 p2 p3)\n    = shiftPosition ((rVF p1 ^+^ rVF p2 ^+^ rVF p3) ^/ 3) origin\n```", "```\ntriArea :: Triangle -> Vec  -- vector area\ntriArea (Tri p1 p2 p3) = 0.5 *^ (displacement p1 p2 >< displacement p2 p3)\n```", "```\ntriangles :: Int -> Surface -> [Triangle]\ntriangles n (Surface g sl su tl tu)\n    = let sts = [[(s,t) | t <- linSpaced n (tl s) (tu s)]\n                     | s <- linSpaced n sl su]\n          stSquares = [( sts !! j    !! k\n                       , sts !! (j+1) !! k\n                       , sts !! (j+1) !! (k+1)\n                       , sts !! j    !! (k+1))\n                      | j <- [0..n-1], k <- [0..n-1]]\n          twoTriangles (pp1,pp2,pp3,pp4)\n              = [Tri (g pp1) (g pp2) (g pp3),Tri (g pp1) (g pp3) (g pp4)]\n      in concatMap twoTriangles stSquares\n```", "```\n-- introduced earlier in the Chapter\ntype VolumeApprox = Volume -> [(Position,R)]\n```", "```\nvolumeSample :: Int -> Volume -> [(Position,R)]\nvolumeSample n v = [(tetCenter tet, tetVolume tet) | tet <- tetrahedrons n v]\n```", "```\ndata Tet = Tet Position Position Position Position\n```", "```\ntetCenter :: Tet -> Position\ntetCenter (Tet p1 p2 p3 p4)\n    = shiftPosition ((rVF p1 ^+^ rVF p2 ^+^ rVF p3 ^+^ rVF p4) ^/ 4) origin\n```", "```\ntetVolume :: Tet -> R\ntetVolume (Tet p1 p2 p3 p4)\n    = abs $ (d1 <.> (d2 >< d3)) / 6\n      where\n        d1 = displacement p1 p4\n        d2 = displacement p2 p4\n        d3 = displacement p3 p4\n```", "```\ndata ParamCube\n    = PC { v000 :: (R,R,R)\n         , v001 :: (R,R,R)\n         , v010 :: (R,R,R)\n         , v011 :: (R,R,R)\n         , v100 :: (R,R,R)\n         , v101 :: (R,R,R)\n         , v110 :: (R,R,R)\n         , v111 :: (R,R,R)\n         }\n```", "```\ntetrahedrons :: Int -> Volume -> [Tet]\ntetrahedrons n (Volume g sl su tl tu ul uu)\n    = let stus = [[[(s,t,u) | u <- linSpaced n (ul s t) (uu s t)]\n                            | t <- linSpaced n (tl s) (tu s)]\n                            | s <- linSpaced n sl su]\n          stCubes = [PC (stus !!  j    !!  k    !!  l   )\n                        (stus !!  j    !!  k    !! (l+1))\n                        (stus !!  j    !! (k+1) !!  l   )\n                        (stus !!  j    !! (k+1) !! (l+1))\n                        (stus !! (j+1) !!  k    !!  l   )\n                        (stus !! (j+1) !!  k    !! (l+1))\n                        (stus !! (j+1) !! (k+1) !!  l   )\n                        (stus !! (j+1) !! (k+1) !! (l+1))\n                    | j <- [0..n-1], k <- [0..n-1], l <- [0..n-1]]\n          tets (PC c000 c001 c010 c011 c100 c101 c110 c111)\n              = [Tet (g c000) (g c100) (g c010) (g c001)\n                ,Tet (g c011) (g c111) (g c001) (g c010)\n                ,Tet (g c110) (g c010) (g c100) (g c111)\n                ,Tet (g c101) (g c001) (g c111) (g c100)\n                ,Tet (g c111) (g c100) (g c010) (g c001)\n                ]\n      in concatMap tets stCubes\n```", "```\neField :: ChargeDistribution -> VectorField\n```", "```\ntype Field a = Position -> a\n```", "```\nclass AbstractVector a where\n    zeroVector :: a\n    add   :: a -> a -> a\n    scale :: R -> a -> a\n```", "```\nsumG :: AbstractVector a => [a] -> a\nsumG = foldr add zeroVector\n```", "```\ngeneralLineIntegral\n    :: AbstractVector a => CurveApprox -> Field a -> Curve -> a\ngeneralLineIntegral approx f c\n    = sumG [scale (magnitude dl') (f r') | (r',dl') <- approx c]\n```", "```\ndottedSurfaceIntegral :: SurfaceApprox -> VectorField -> Surface -> R\ndottedSurfaceIntegral approx vF s\n    = sum [vF r' <.> da' | (r',da') <- approx s]\n```", "```\nelectricFluxFromField :: VectorField -> Surface -> R\nelectricFluxFromField = undefined\n```", "```\nelectricFluxFromCharge :: ChargeDistribution -> Surface -> R\nelectricFluxFromCharge dist = undefined dist\n```", "```\neFieldFromSurfaceChargeP :: SurfaceApprox -> ScalarField -> Surface\n                         -> VectorField\neFieldFromSurfaceChargeP approx sigma s r\n    = sumV [eFieldFromPointCharge (sigma r' * magnitude da') r' r\n                | (r',da') <- approx s]\n```", "```\nsurfaceArea :: Surface -> R\nsurfaceArea = undefined\n```", "```\ndottedLineIntegral :: CurveApprox -> VectorField -> Curve -> R\ndottedLineIntegral approx f c = sum [f r' <.> dl' | (r',dl') <- approx c]\n```", "```\nelectricPotentialFromField :: VectorField  -- electric field\n                           -> ScalarField  -- electric potential\nelectricPotentialFromField ef r = undefined ef r\n```"]