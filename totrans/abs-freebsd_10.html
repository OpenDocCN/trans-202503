<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_201"/><strong><span class="big">10</span><br/>DISKS, PARTITIONING, AND GEOM</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">A sysadmin can’t overemphasize the importance of managing disks and filesystems. (Go ahead, try to emphasize it too much. I’ll wait.) Your disks contain your data, making reliability and flexibility paramount to the operating system. FreeBSD supports a variety of filesystems and has many different ways to handle them. In this chapter, we’ll consider the most common disk tasks every sysadmin performs.</p>
<p class="indent">First, let’s discuss the most important thing to remember about storage devices.</p>
<h3 class="h3" id="lev320"><strong>Disks Lie</strong></h3>
<p class="noindent">Once upon a time, a sysadmin could make decisions about a disk based on the information it provided. You could plug in a hard drive and query it for the number of platters, cylinders, sectors, and more. Those days are long, long past. Yes, you can perform the same query and get an answer, but those answers don’t reflect any reality. Today, a disk is a magic box that <span epub:type="pagebreak" id="page_202"/>regurgitates data on request. Some of those magic boxes contain spinning platters. Others lack moving parts. The magic boxes provide numbered sectors for storing bits and bytes. The relationship between those numbers and the contents of the box? That’s magic: inscrutable and unknowable.</p>
<p class="indent">In previous books, including earlier editions of this one, I’ve discussed the importance of proper data placement on the disk, but all of that knowledge is completely obsolete. If you still retain any of that knowledge, discard it in favor of something more useful, like the complete biographies of all the actors who appeared in any role in classic <em>Doctor Who</em>.</p>
<p class="indent">As far as disk design goes, the only thing you need to know about is <em>logical block addressing (LBA)</em>. Each sector on a disk is assigned a number. Filesystems call disk sectors by number. That’s it. Anything beneath LBA is pure guesswork on your part.</p>
<p class="indent">Unfortunately, disks now have a new category of lies they tell: sector size.</p>
<p class="indent">Up through the 1990s, disk sector sizes varied from 128 bytes to 2KB. Even the original IBM PC could understand different sector sizes on floppy disks.</p>
<p class="indent">In the early 2000s, though, manufacturers settled on 512-byte sectors. Today’s hard drives are much larger, and the files are similarly larger. In the last few years, the 512-byte sectors have mostly been replaced with 4,096-byte sectors, called <em>4K drives</em>. This sector size makes more sense for the type of data we store today.</p>
<p class="indent">The problem is, operating systems like Windows XP know that a disk sector always has been, and always will be, 512 bytes. These operating systems won’t tolerate hard drives that reported having 4KB sectors because everybody knows there’s no such thing. If you manufacture 4K drives, what do you do?</p>
<p class="indent">The same thing you always do.</p>
<p class="indent">You teach the hard drive to lie.</p>
<p class="indent">Best of all, different 4K drives lie in different ways. If the OS asks a drive its sector size, most drives state that they have 512-byte sectors. Drives that claim to have both 512-byte and 4KB sectors are probably 4K drives, struggling to tell the truth. Very few admit to having solely 4KB sectors. To complicate matters even more, some solid state drives have sectors as large as 8KB or 16KB, or they support multiple sector sizes.</p>
<p class="indent">Both of FreeBSD’s main filesystems must know the sector size of the underlying disk and the logical block address of that sector. If you use the wrong sector size on your disk, performance suffers. I could go into long detailed discussions of how this happens, but to keep it simple, always align partitions on even megabyte boundaries. You might waste a few bytes here and there, but that’s trivial compared to the truly appalling performance you’ll get from having a filesystem misaligned with the disk.</p>
<h3 class="h3" id="lev321"><strong>Device Nodes</strong></h3>
<p class="noindent">We touched briefly on device nodes in <a href="ch04.xhtml#ch04">Chapter 4</a>, but let’s consider them in more detail here. Device nodes are special files that represent a hardware device or an operating system feature. They’re used as logical interfaces to <span epub:type="pagebreak" id="page_203"/>provide features to user programs. By using a command on a device node, sending information to a device node, or reading data from a device node, you’re telling the kernel to perform an action. If the device node represents a physical device, you’re acting on that device. These actions can be very different for different devices—writing data to disk is very different than writing data to a sound card. While you can expose device nodes anywhere, the standard device nodes exist in <em>/dev</em>.</p>
<p class="indent">Before you can work with a disk or disk partition, you must know its device name. FreeBSD disk device nodes come from the names of the device driver for that type of hardware. Device driver names, in turn, often come from the type of device and not the device’s role or function.</p>
<p class="indent">Table 10-1 shows the most common disk device nodes.</p>
<p class="tabcap" id="ch10tab1"><strong>Table 10-1:</strong> Storage Device Nodes and Types</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Device node</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Man page</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/ada*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">ada(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">ATA-style direct access disks (SATA, IDE, etc.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/cd*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">cd(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Optical media drives (CD, Blu-Ray, etc.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/da*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">da(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">SCSI-style direct access disks (USB storage, SAS, etc.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/md*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">md(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Memory disks</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/mmcsd*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">mmcsd(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">MMC and SD memory cards</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/nvd*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">nvd(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">NVM express drives</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>/dev/vtbd*</em></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">virtio_blk(4)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Virtio-based virtual machine disk</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><em>/dev/xbd*</em></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">xen(4)</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Xen virtual disks</p></td>
</tr>
</tbody>
</table>
<p class="indent">Many RAID controllers present their RAID containers as SCSI devices, so they show up as <em>/dev/da</em> device nodes. Others present their disks as “SCSI plus special vendor topping,” so they get special device node names such as <em>/dev/raid</em> (ATA RAID), <em>/dev/mfid</em> (certain LSI MegaRAID cards), and so on. Check the man page for your RAID controller to see the device node it presents.</p>
<h3 class="h3" id="lev322"><strong>The Common Access Method</strong></h3>
<p class="noindent">The <em>Common Access Method (CAM)</em> is a standardized device driver architecture originally written to support the complex command set of 20th-century SCSI-2 disks. The idea was that standardizing based on this architecture would simplify writing device drivers. Only FreeBSD and DEC OSF/1 actually shipped with CAM, however, and each filled in the specification’s gaps differently.</p>
<p class="indent">FreeBSD 9 and later consolidates management of all physical disks that support CAM in the CAM interface. Use camcontrol(8) to gather information from disks and issue commands to them. The camcontrol(8) command has a variety of subcommands that let you issue instructions to hard drives.</p>
<h4 class="h4" id="lev323"><span epub:type="pagebreak" id="page_204"/><strong><em>What Disks Do You Have?</em></strong></h4>
<p class="noindent">To identify a host’s storage devices, you can trawl <em>/var/run/dmesg.boot</em> looking for disk device nodes or see which filesystems are mounted and backtrack from there. But the easiest way to identify your storage is to have camcontrol(8) ask the CAM system what disks it sees. Let’s look at one of my test systems:</p>
<pre># <span class="codestrong1">camcontrol devlist</span><br/>&lt;ATA WDC WD1003FBYZ-0 1V03&gt;        at scbus0 target 0 lun 0 (pass0,da0)<br/>&lt;ATA WDC WD1003FBYZ-0 1V03&gt;        at scbus0 target 1 lun 0 (pass1,da1)<br/>&lt;ATA WDC WD1003FBYZ-0 1V03&gt;        at scbus0 target 2 lun 0 (pass2,da2)<br/>&lt;ATA WDC WD1003FBYZ-0 1V03&gt;        at scbus0 target 3 lun 0 (pass3,da3)</pre>
<p class="indent">This output is broken up into three fields. The first gives the name of the device, as reported by the device itself. This is usually a vendor and the vendor’s model number.</p>
<p class="indent">The second section gives SCSI connection information. These drives aren’t actually SCSI drives—they’re SATA connections managed via CAM. But you now know which disk devices are plugged into which port on the SATA controller.</p>
<p class="indent">Finally, in parentheses, we have the SCSI device and what we probably want, the storage device node. This host has four disks, named da0, da1, da2, and da3.</p>
<h4 class="h4" id="lev324"><strong><em>Non-CAM Devices</em></strong></h4>
<p class="noindent">Generally speaking, everything except proprietary RAID controllers and virtual disks support CAM.</p>
<p class="indent">RAID controllers have usually embraced and extended the CAM protocol, for what the manufacturer thought was a good reason at the time. A protocol written in the early 1990s wasn’t sufficient for a 2010 RAID controller. These controllers usually have their own control programs. The RAID containers show up in <code>devlist</code> and some other camcontrol(8) subcommands.</p>
<p class="indent">Similarly, virtual disks don’t respond to CAM commands. There’s no disk to command there—you’re just writing blocks to a file. You can view the disk with <code>camcontrol devlist</code>, but that’s about it.</p>
<p class="indent">For most applications, I recommend using FreeBSD’s RAIDZ or GEOM RAID, rather than a hardware RAID controller.</p>
<h3 class="h3" id="lev325"><strong>The GEOM Storage Architecture</strong></h3>
<p class="noindent">FreeBSD has an incredibly flexible storage infrastructure system called <em>GEOM</em> (short for “disk geometry”). GEOM lives between device driver nodes and the underlying hardware, handling data exchanged between them. From this position, GEOM can arbitrarily transform input/output requests.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_205"/><strong>DEVICE CONTROL PROGRAMS</strong></p>
<p class="spara">Some storage devices have special features that aren’t addressed in the generic CAM framework. RAID controllers often have vendor-specific features, and FreeBSD includes many small programs to individually manage these controllers. You’ll find programs like mfiutil(8) and mptutil(8) for older LSI controllers, mpsutil(8) for newer LSI controllers, and so on. If you have a nonvolatile memory express (NVMe) drive, check out nvmecontrol(8).</p>
</div>
<p class="indent">GEOM is built out of kernel modules, called <em>GEOM classes</em>, that let you perform specific types of transformation or management. Disks have a GEOM class that lets the kernel put data on the disk. But if you want to encrypt your disks, that’s a GEOM class. Software-based RAID? A GEOM class. FreeBSD implements all storage modifications as GEOM classes.</p>
<p class="indent">GEOM classes are <em>stackable</em>. They use the output of one class as the input for another. You want to encrypt your hard drive and then mirror it to another hard drive? Sure! Stack an encryption module on top of your hard drive and then stack the drive-mirroring module on top of that. You want to mirror that drive across the network? Add that GEOM class to the stack. This flexible modularity makes GEOM one of FreeBSD’s most powerful features.</p>
<h4 class="h4" id="lev326"><strong><em>GEOM Autoconfiguration</em></strong></h4>
<p class="noindent">When FreeBSD finds a new storage device, either at boot or when you plug a new drive in, the GEOM subsystem checks the device for known formats, like a master boot record, a BSD disklabel, or other metadata. GEOM also checks for physical identifiers, such as the disk’s serial number. This is called <em>tasting</em>.</p>
<p class="indent">When GEOM finds identifying information, it configures the device as that metadata dictates. If a disk’s metadata says, “I’m part of a mirror called <em>garbage</em>, along with two other disks,” GEOM looks for the other disks and assembles the mirror. If GEOM can identify a storage device by format, label, or other information, it starts the device, fires up an instance of the GEOM class, makes the appropriate device nodes, and performs any other configuration it understands.</p>
<p class="indent">If GEOM can’t identify any other metadata on the disk, such as on an unformatted and unpartitioned disk, GEOM creates the device node for the storage device and leaves it alone.</p>
<p class="indent">An instance of a GEOM class is called a <em>geom</em>. The gmirror(8) class makes disks mirror each other, but the specific pair of mirrored disks named <em>garbage</em> is a geom. Each disk in that mirror is also a geom.</p>
<h4 class="h4" id="lev327"><span epub:type="pagebreak" id="page_206"/><strong><em>GEOM vs. Volume Managers</em></strong></h4>
<p class="noindent">Traditional volume managers expect you to do things their way, whether that makes sense for your environment and hardware or not. If the volume manager says that you create an encrypted disk mirror by encrypting the individual drives and then mirroring on top of them, that’s what you do. It might make more sense in your environment to mirror the drives and then encrypt them, but if that’s not what the volume manager does, too bad. Worse, some volume managers make poor choices and then implement fixes sideways to minimize the consequences of those decisions.</p>
<p class="indent">GEOM differs from volume managers in that it assumes you know what you’re doing. It gives you flexibility to arrange your storage in the manner that best fits your hardware and benefits your use case. GEOM classes let you easily insert new data transformations into your storage. You can’t, say, add an encryption layer into your commercial volume manager.</p>
<p class="indent">Volume managers cover the most common cases for hardware that existed at the time they were conceived. As time passes, though, that most common case becomes increasingly uncommon. People continue to use volume managers long after the hardware they were designed for becomes obsolete. GEOM lets you evolve your designs with your hardware, environment, and application.</p>
<p class="indent">FreeBSD includes two software suites that look much like volume managers: gvinum(8) and ZFS. Vinum was the FreeBSD volume manager in the 1990s, and while gvinum(8) reimplements it as a GEOM class, its use is strongly discouraged. ZFS is very powerful, as we saw in <a href="ch05.xhtml#ch05">Chapter 5</a>, but it does have the “do it our way” ethos of a volume manager.</p>
<p class="indent">While you can theoretically stack GEOM modules forever, you must consider your hardware resources. Mirroring a busy disk across a network can require a dedicated network interface and an otherwise empty cross-connect cable. Encrypting and decrypting data eats processor time and memory. GEOM doesn’t prevent you from thrashing your disks; it merely gives you new and interesting opportunities for doing so.</p>
<h4 class="h4" id="lev328"><strong><em>Providers, Consumers, and Slicers</em></strong></h4>
<p class="noindent">Individual geoms are either consumers, providers, or both.</p>
<p class="indent">A <em>provider</em> offers services to another geom. If you’re mirroring two hard drives, the geoms for the hard drive provide the disk to the mirror. A provider usually has a device node, such as <em>/dev/ada1p1</em>.</p>
<p class="indent">A <em>consumer</em> uses the provider’s services. A disk-mirror geom consumes the underlying disk drives. The consumer part of a geom doesn’t need a device node.</p>
<p class="indent">A geom can be both a provider and a consumer—indeed, every geom in the middle of a stack must be both. A disk-mirror geom consumes the underlying physical storage media, but it provides a mirrored disk for the filesystem to live on.</p>
<p class="indent"><span epub:type="pagebreak" id="page_207"/>FreeBSD treats all providers and consumers identically. A physical hard drive is just another provider, exactly like a mirror or encryption layer or import from the network. This characteristic lets you arbitrarily stack GEOM classes.</p>
<p class="indent">A GEOM class that subdivides a class is called a <em>slicer</em> and is usually responsible for managing partitions. The GEOM class that handles master boot record (MBR) partitions is a slicer, as is the GUID Partition Table (GPT) class. We discussed both of these partitioning methods in <a href="ch02.xhtml#ch02">Chapter 2</a>, and we’ll go deeper into both in this chapter. Slicers must make sure that disk partitions don’t overlap and that the partitions conform to the rules of the partitioning scheme.</p>
<h4 class="h4" id="lev329"><strong><em>GEOM Control Programs</em></strong></h4>
<p class="noindent">Many GEOM classes have a control program that lets you administer the module or interrogate the device. Some widely used classes use geom(8), while other classes use programs like gmirror(8) or geli(8). The <em>disk</em> GEOM class talks to the physical storage media and provides consumers for upper layers. That’s a really commonly used class. Here, I interrogate a host to see what geoms of type <em>disk</em> it has and print out the information the disk offers the operating system.</p>
<pre>   $ <span class="codestrong1">geom disk list</span><br/><span class="ent">➊</span> Geom name: da0<br/>   Providers:<br/>   1. Name: da0<br/>    <span class="ent">➋</span> Mediasize: 1000204886016 (932G)<br/>    <span class="ent">➌</span> Sectorsize: 512<br/>    <span class="ent">➍</span> Mode: r2w2e3<br/>    <span class="ent">➎</span> descr: ATA WDC WD1003FBYZ-0<br/>    <span class="ent">➏</span> lunname: ATA   WDC WD1003FBYZ-010FB0            WD-WCAW36478143<br/>    <span class="ent">➐</span> lunid: 50014ee25e60dab5<br/>    <span class="ent">➑</span> ident: WD-WCAW36478143<br/>    <span class="ent">➒</span> rotationrate: 7200<br/>    <span class="ent">➓</span> fwsectors: 63<br/>       fwheads: 255</pre>
<p class="indent">This hard drive provides a disk device called da0 <span class="ent">➊</span>. The <em>mediasize</em> field gives its size in bytes and converts it to a more convenient 932GB <span class="ent">➋</span>.</p>
<p class="indent">This disk claims to have a <em>sector size</em> of 512 bytes <span class="ent">➌</span>. Many disks lie about their sector size. Check the drive manufacturer’s documentation to determine the actual sector size. Drives might offer a <em>Stripesize</em> value of 4,096 to indicate that they’re actually 4K drives.</p>
<p class="indent">A GEOM class’s <em>mode</em> looks an awful lot like file permissions <span class="ent">➍</span>, but it’s really the number of GEOM classes reading from (r2) and writing to (w2) the device, plus the number of devices that have requested exclusive access to the device (e3).</p>
<p class="indent">The <em>descr</em> field <span class="ent">➎</span> offers the drive’s model number.</p>
<p class="indent"><span epub:type="pagebreak" id="page_208"/>The <em>lunname</em> field <span class="ent">➏</span> gives the model number plus the serial number. Yes, it’s a combination of the descr and ident fields. The hard drive really, really wants you to believe this is its name and identifier.</p>
<p class="indent">The <em>lunid</em> <span class="ent">➐</span> gives the logical-unit-number (LUN) identifier, which describes how this drive attaches to this host.</p>
<p class="indent">The disk’s <em>ident</em> <span class="ent">➑</span> is the drive’s serial number.</p>
<p class="indent">The <em>rotationrate</em> <span class="ent">➒</span> tells us how fast this drive spins. It’s a 7,200 RPM disk. Nonspinning disks, like SSDs, have a rotationrate of 0.</p>
<p class="indent">The <em>fwsectors</em> and <em>fwheads</em> fields <span class="ent">➓</span> give us the drive geometry. These are examples of the lies mentioned in the beginning of this chapter. Even SSDs offer these values.</p>
<p class="indent">Some drives offer less information. Virtual disks offer almost no information, and anything they do say, you can’t trust. (While the VM system might say this disk offers 32,212,254,720 512-byte sectors, who knows what the actual disk beneath the virtual disk has?)</p>
<h4 class="h4" id="lev330"><strong><em>GEOM Device Nodes and Stacks</em></strong></h4>
<p class="noindent">Many sysadmin tools expect to run on a disk or disk partition. Unix-like systems offer disks and partitions as device nodes. GEOM offers device nodes so that these tools remain compatible.</p>
<p class="indent">Most active GEOM modules have their own directory in <em>/dev</em>. Device nodes within that directory represent the current providers of that module. The directory is often, but not always, named after the GEOM module using it. For example, the gmirror(8) class uses <em>/dev/mirror</em>.</p>
<p class="indent">The directory name might be changed to avoid ambiguity or overlaps. The <em>glabel (GEOM label)</em> class uses <em>/dev/label</em>. The <em>/dev/gpt</em> directory contains the labels stored on GPT partitions, where <em>/dev/gptid</em> contains the numerical identifiers integral to GPT partitions.</p>
<p class="indent">Some classes don’t create a directory and instead piggyback on existing devices. The gnop(8) class creates a new node right next to the node it’s attached to but appends <em>.nop</em> to the end of the device name.</p>
<h3 class="h3" id="lev331"><strong>Hard Disks, Partitions, and Schemes</strong></h3>
<p class="noindent">While we discussed partitioning in <a href="ch09.xhtml#ch09">Chapter 9</a>, consider partitions from a disk drive perspective. The first possible SATA disk on our first SATA controller is called <em>/dev/ada0</em>. Subsequent disks are <em>/dev/ada1</em>, <em>/dev/ada2</em>, and so on. If you also have SAS disks, they’ll start their numbering over at 0.</p>
<p class="indent">Disks get further divided into <em>partitions</em>. Even average consumer-grade systems running Microsoft operating systems ship with multiple partitions on the hard drive. Sysadmins chop huge disk arrays into smaller, more manageable units with dedicated purposes—or perhaps they go the other way and merge multiple disks into one monster partition.</p>
<p class="indent">A <em>partitioning scheme</em> is the system for organizing partitions on a disk. The traditional master boot record (MBR) is one partitioning scheme. Old Apple and SPARC hardware have their own schemes. Today, the <span epub:type="pagebreak" id="page_209"/>scheme used by most hardware and operating systems is <em>GUID Partition Tables (GPT)</em>. Each scheme has its own requirements for boot blocks, hardware architecture, and partitions. This book discusses the MBR and GPT schemes, but you should be aware that other schemes exist.</p>
<p class="indent">Each disk partition gets its own device node, created by adding something to the end of the underlying device node name. Here, I look at the device node for a default FreeBSD install using UFS on a virtual disk:</p>
<pre># <span class="codestrong1">ls /dev/vtbd0*</span><br/>/dev/vtbd0      /dev/vtbd0p1    /dev/vtbd0p2    /dev/vtbd0p3</pre>
<p class="indent">We have a device node for the disk itself and then three others ending in p1, p2, and p3. What are those subdivisions? The <em>p</em> indicates that they’re GPT partitions. In a default install, p1 is the boot partition, p2 is the swap space, and p3 is the main filesystem.</p>
<p class="indent">Each partitioning scheme has its own device node extensions. We’ll read about those later this chapter.</p>
<h3 class="h3" id="lev332"><strong>The Filesystem Table: /etc/fstab</strong></h3>
<p class="noindent">FreeBSD, like most Unix-like operating systems, uses the file system table <em>/etc/fstab</em> to map on-disk partitions to filesystems and swap space. While ZFS doesn’t use <em>/etc/fstab</em>, every other FreeBSD filesystem can appear therein. Each partition in use appears on a separate line, along with mounting and management instructions.</p>
<pre>/dev/gpt/rootfs  /       ufs     rw  2  1<br/>/dev/gpt/swapfs  none    swap    sw  0  0<br/>proc             /proc   procfs  rw  0  0</pre>
<p class="indent">The first field gives the GEOM provider name. This might be a physical disk partition such as <em>/dev/ada0p1</em> or perhaps a partition of a GEOM device node. The first two lines here offer device nodes under <em>/dev/gpt</em>. They’re GPT labels, which we’ll see later this chapter. Our third entry lists the word <em>proc</em> rather than a device node: it’s the procfs(5) virtual filesystem, which we’ll examine in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>
<p class="indent">The second field gives the directory where the filesystem is available, called the <em>mount point</em>. Every partition you can read or write files on is attached to a mount point, such as <em>/usr</em>, <em>/var</em>, and so on. A few special partitions, such as swap space (line 2 here), have a mount point of none. You can’t read or write usable files to the swap space because they’re not attached to the directory tree and because the system would overwrite those files when it swapped.</p>
<p class="indent">Next, we have the filesystem type. The first line shows a type of <em>ufs</em>, or Unix File System. The second line is defined as <em>swap</em> space, while the third is type <em>procfs</em>. Other types include <em>cd9660</em> (CD disks or images), <em>nfs</em> <span epub:type="pagebreak" id="page_210"/>(Network File System mounts), and <em>ext4fs</em> (Linux filesystems). The filesystem table tells FreeBSD how to mount this partition. <a href="ch13.xhtml#ch13">Chapter 13</a> discusses alternate filesystems.</p>
<p class="indentb">The fourth field shows the mount(8) options used for this particular partition. Each filesystem has its own mount options, but here are a few that multiple filesystems use and that frequently appear in <em>/etc/fstab</em>:</p>
<p class="hang"><strong>ro</strong> The filesystem is mounted read-only. Not even root can write to it.</p>
<p class="hang"><strong>rw</strong> The filesystem is mounted read-write.</p>
<p class="hang"><strong>noauto</strong> FreeBSD won’t automatically mount the filesystem, neither at boot nor when using <code>mount -a</code>. This option is useful for removable media drives that might not have media in them at boot.</p>
<p class="indentt">The fifth field is used to tell dump(8) what backup level is needed to back up this filesystem. Dump is largely obsolete these days; people perform file-level backup with tar(1) or use more advanced backup software, like Bacula (<em><a href="http://www.bacula.org/">http://www.bacula.org/</a></em>) or Tarsnap (<em><a href="https://www.tarsnap.com/">https://www.tarsnap.com/</a></em>).</p>
<p class="indent">The last field tells the FreeBSD boot process when to check filesystem integrity. All the partitions with the same number get checked in parallel with fsck(8). The root filesystem gets marked with a 1, meaning it’s checked first. Only the root filesystem should get a 1. Any other partitions should get a 2 or higher, meaning they get checked later. Swap, read-only media, and logical filesystems don’t require integrity checking, so they get set to 0.</p>
<p class="indent">FreeBSD configures all filesystems found in <em>/etc/fstab</em> at boot. As the system runs, though, the sysadmin can mount other filesystems. And she can unmount ones listed there. That leads to our next question . . .</p>
<h3 class="h3" id="lev333"><strong>What’s Mounted Now?</strong></h3>
<p class="noindent">If not all filesystems are mounted automatically at boot, and if the sysadmin can add and remove mounted filesystems, how can you determine what’s mounted right now? Use mount(8) without any options to see all mounted filesystems.</p>
<pre># <span class="codestrong1">mount</span><br/>/dev/gpt/rootfs on / (ufs, local, journaled soft-updates)<br/>devfs on /dev (devfs, local, multilabel)</pre>
<p class="indent">This is a small UFS-based host. It has one disk partition and an instance of devfs(5) (see <a href="ch13.xhtml#ch13">Chapter 13</a>). The word <em>local</em> means that the partition is on a hard drive attached to this machine. The journaled soft-updates option is a UFS feature we’ll discuss in <a href="ch11.xhtml#ch11">Chapter 11</a>. If you’re using NFS or SMB to mount partitions, they’ll appear here.</p>
<p class="indent">More complicated hosts give larger results:</p>
<pre># <span class="codestrong1">mount</span><br/>base/ROOT/default on / (zfs, local, noatime, nfsv4acls)<br/>base/tmp on /tmp (zfs, local, noatime, nosuid, nfsv4acls)<br/><span epub:type="pagebreak" id="page_211"/>base/usr/home on /usr/home (zfs, local, noatime, nfsv4acls)<br/>base/usr/ports on /usr/ports (zfs, local, noatime, nosuid, nfsv4acls)<br/>procfs on /proc (procfs, local)<br/>devfs on /dev (devfs, local, multilabel)<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">This host uses many ZFS datasets, each with its own mount point. The mount(8) output shows selected ZFS options, such as noatime and nfsv4acls.</p>
<p class="indent">At the end of this output, we have a procfs(5) entry and one for a devfs(5) mount. A working FreeBSD system needs devfs mounted at <em>/dev</em> or it won’t work very well or for very long.</p>
<h3 class="h3" id="lev334"><strong>Disk Labeling</strong></h3>
<p class="noindent">At the lowest level, operating systems identify disks by their physical attachment to the system. Traditionally, the filesystem table says something like, “Use the disk attached at ATA port 3 as the <em>/var/log</em> filesystem.” This worked fine with less flexible hardware, but as hardware technology improved, such connections became much more flexible. If you assign drive roles based on the physical attachment, sometimes that attachment changes. I’ve had more than one mainboard explode at an inconvenient hour, forcing a desperate emergency replacement. Tracking which cable goes to which connecter under such circumstances never goes well. In older versions of FreeBSD, you needed to “wire down” devices so that a specific disk always showed up as a specific device node. This is no longer needed.</p>
<p class="indent">Today, a sysadmin uses on-disk <em>labels</em> to refer to the disk by something other than the physical attachment. A label identifies an instance of a geom. Rather than telling FreeBSD that <em>/var/www</em> is on the disk attached to SATA port 2, you declare that <em>/var/www</em> is on the disk labeled <em>website</em>. While the former easily goes wrong, the latter is mostly immune to sleepy hardware techs. One disk can have several labels simultaneously, if they’re different types of label. FreeBSD automatically derives many labels from inherent disk characteristics; the sysadmin can define others.</p>
<p class="indent">Most label types have a dedicated device node directory. Each GPT partition has a <em>globally unique identifier (GUID)</em>, and the autocreated labels for those partitions live in <em>/dev/gptid</em>. Disks get unique disk IDs based on their serial number, which gets entries in <em>/dev/diskid</em>. Manually created GPT labels appear in <em>/dev/gpt</em>.</p>
<p class="indent">Use these labels as you would any other device name. If you label the disk ada5 as <em>stuff1</em>, you can partition the disk stuff into <em>stuff1p1</em> and <em>stuff1p2</em>, use those partitions in configuration files, and more.</p>
<p class="indent">Not all labels come from GEOM. ZFS uses its own internal labeling method for filesystems and pools. You can also add labels to UFS filesystems.</p>
<p class="indent">Don’t let swapped SATA cables ruin your weekend. Label everything.</p>
<h4 class="h4" id="lev335"><span epub:type="pagebreak" id="page_212"/><strong><em>Viewing Labels</em></strong></h4>
<p class="noindent">View labels with glabel(8), a shortcut for <code>geom label</code>. Here are parts of a label from a small virtual machine. The labels on real hardware can quickly become very complex.</p>
<pre>   $ <span class="codestrong1">glabel list</span><br/><span class="ent">➊</span> Geom name: ada0p1<br/>   Providers:<br/><span class="ent">➋</span> 1. Name: gptid/b9c0c7c5-5b66-11e7-8aec-080027739ff6<br/>      Mediasize: 524288 (512K)<br/>      Sectorsize: 512<br/>   --<span class="codeitalic1">snip</span>--<br/><span class="ent">➌</span> Consumers:<br/>   1. Name: ada0p1<br/>      Mediasize: 524288 (512K)<br/>      Sectorsize: 512<br/>      Stripesize: 0<br/>      Stripeoffset: 20480<br/>      Mode: r0w0e0</pre>
<p class="indent">This host has a single geom <span class="ent">➊</span> on the disk partition <em>/dev/ada0p1</em>. It provides an appallingly long label based on the GPT partition ID <span class="ent">➋</span>. We’ll see a bunch of information on the underlying disk, such as the number of sectors on the disk, the sector size, and other information you might see in <code>geom</code> <code>disk list</code> output. This information comes from the partition, however. The physical drive information is passed up from the underlying disk.<sup><a href="footnote.xhtml#ch10fn1" id="ch10fn1a">1</a></sup></p>
<p class="indent">This drive has a single consumer <span class="ent">➌</span>, the actual underlying partition. We’re at the very bottom of this simple GEOM stack, right up against the disk, so it’s consuming itself. If you add cryptographic layers or software RAID, you’ll see what other device this geom consumes.</p>
<h4 class="h4" id="lev336"><strong><em>Sample Labels</em></strong></h4>
<p class="noindent">Here are some examples of the kinds of labels you’ll see on most FreeBSD systems.</p>
<h5 class="h5" id="lev337"><strong>Disk ID Labels</strong></h5>
<p class="noindent">A physical machine offers labels not available on virtual machines.</p>
<pre>Geom name: ada3<br/>Providers:<br/>1. Name: diskid/DISK-WD-WCAW36477141<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">The drive ada3 provides a geom called <em>diskid/DISK-WD-WCAW36477141</em>. The <em>diskid</em> geom is named after the hard drive’s serial number, based on <span epub:type="pagebreak" id="page_213"/>information provided by the drive. You can remove the disk from this machine and attach it to a completely different FreeBSD host, and that new host will generate the exact same disk ID label. Using the diskid label in your configurations guarantees that FreeBSD will use the exact disk you intend. Here’s how you might list partition 3 on this disk in <em>/etc/fstab</em>:</p>
<pre>/dev/diskid/DISK-WD-WCAW36477141p3 /usr/local ufs rw 2 2</pre>
<p class="indent">This disk could attach to the host as <em>/dev/ada3</em> or <em>/dev/ada300</em>, and FreeBSD would still mount this partition as <em>/usr/local</em>.</p>
<p class="indent">The problem with disk ID labels is that they’re painful to read and more painful to type. I’m describing them because they can appear by default, but I’d encourage you to choose a different label. Eliminate these labels from your host by setting the tunable <code>kern.geom.label.disk_ident.enable</code> to 0 in <em>/boot/loader.conf</em>.</p>
<h5 class="h5" id="lev338"><strong>GPT GUID Labels</strong></h5>
<p class="noindent">Every GPT partition includes a GUID. FreeBSD can treat the GUID as a label. Here, we see a GPT ID label for partition 1 on the disk attached as ada0:</p>
<pre>   Geom name: ada0p1<br/>   Providers:<br/><span class="ent">➊</span> 1. Name: gptid/075e7b89-30ed-11e7-a386-002590dbd594<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="indent">This disk partition is conveniently available as <em>/dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594</em> <span class="ent">➊</span>. Much like disk serial numbers, GUIDs are integral to the partition. You can move the disk to another host and still get the same GPT ID. By using the GPT ID label in configurations like <em>/etc/fstab</em>, you guarantee that FreeBSD uses this particular partition, rather than partition 1, on whatever device happens to get assigned ada0 at system boot.</p>
<p class="indent">Using a GPT ID label makes sense when you have many automatically configured disks, such as large storage arrays. On smaller systems, though, the 128-bit GUID is annoyingly long. If you decide not to use these labels, remove them from your system by setting the tunable <code>kern.geom.label.gptid.enable</code> to 0 in <em>/boot/loader.conf</em>.</p>
<p class="indent">For most hosts, I recommend assigning GPT labels.</p>
<h5 class="h5" id="lev339"><strong>GPT Labels</strong></h5>
<p class="noindent">GPT partitions let you manually assign a label name within the partition table. I highly recommend doing so whenever possible. Here’s a partition that I assigned a name:</p>
<pre>   Geom name: ada2p1<br/>   Providers:<br/><span class="ent">➊</span> 1. Name: gpt/swap2<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>I’ve assigned the label <em>swap2</em> <span class="ent">➊</span> to partition 1 on disk ada2. This label is physically stored on the disk partition. I can use this label in my configurations just like any other device name. Using manually assigned labels is much more manageable for small systems, as this <em>/etc/fstab</em> shows:</p>
<pre>/dev/gpt/swap2  none  swap  sw  0  0</pre>
<p class="indent">An assigned label is much more human-friendly than a long serial number or GUID. If you have the choice, I encourage you to label GPT partitions. We’ll assign labels when we partition disks.</p>
<h5 class="h5" id="lev340"><strong>GEOM Labels</strong></h5>
<p class="noindent">In addition to spilling the standard labels on your system, the glabel(8) command lets you configure GEOM labels. A GEOM label is specific to FreeBSD’s GEOM infrastructure and appears in <em>/dev/label</em>. Use GEOM labels with the <code>glabel label</code> command. Here, I apply the GEOM label <em>root</em> to the GPT partition da0p1:</p>
<pre># <span class="codestrong1">glabel label da0p1 root</span></pre>
<p class="indent">There’s also a <code>glabel create</code> command, but those labels disappear at system reboot.</p>
<h3 class="h3" id="lev341"><strong>GEOM Withering</strong></h3>
<p class="noindent">A provider can have multiple labels. One partition might have a label based on the disk ID of the underlying storage device (<em>/dev/diskid/somethinglong</em>), a GPT ID (<em>/dev/gptid/somethingevenlonger</em>), a manually assigned label (<em>/dev/gpt/swap0</em>), and a device node based on the underlying device’s attachment point (<em>/dev/ada0p1</em>). While any number of processes can look at a disk device simultaneously, many disk operations—such as mounting a partition—require exclusive, dedicated control of the device.</p>
<p class="indent">To prevent accessing geoms by multiple names, when you access a device by one label, the kernel removes the unused labels. This is called <em>withering</em>. If I, say, mount a swap partition using the GPT label <em>/dev/gpt/swap0</em>, all the other labels for that partition disappear from <em>/dev</em>. Anyone who tries to access the corresponding <em>/dev/gptid</em> partition will find that the device node is missing.</p>
<p class="indent">Once all exclusive locks on a device are removed, the kernel de-withers the other device labels. If I deactivate that swap space, the GPT ID and raw device name reappear.</p>
<h3 class="h3" id="lev342"><strong>The gpart(8) Command</strong></h3>
<p class="noindent">Like many operating systems, FreeBSD once had specific partitioning tools for each partitioning scheme. Today, all disk partitioning functions, for MBR and GPT alike, are included in the gpart(8) program. Embedded <span epub:type="pagebreak" id="page_215"/>devices with specialized storage might occasionally need older tools like fdisk(8) and bsdlabel(8), but gpart(8) works perfectly well for servers and desktops.</p>
<p class="indent">This common tool means you perform many functions the same way no matter which partitioning scheme you’re using. For example, no matter whether you’re working with the MBR or GPT scheme, you’ll need a way to indicate a particular partition. Both schemes let you indicate a partition with <code>-i</code> and the partition number.</p>
<p class="indent">Viewing and deleting partitions are great examples of common functions.</p>
<h4 class="h4" id="lev343"><strong><em>Viewing Partitions</em></strong></h4>
<p class="noindent">Use <code>gpart show</code> to see a brief summary of all GPT and MBR partitions on a geom. Give the name of a geom as an argument to see only the partitions on that geom. The output from <code>gpart show</code> doesn’t look that different from fdisk(8) and other more traditional disk management tools. Here, I look at a storage device by its traditional device node, but I could use diskid or gptid or any other label:</p>
<pre>   $ <span class="codestrong1">gpart show ada0</span><br/><span class="ent">➊</span> =&gt;        40  1953525088  ada0  GPT  (932G)<br/><span class="ent">➋</span>           40        1024     1  freebsd-boot  (512K)<br/><span class="ent">➌</span>         1064         984        - free -  (492K)<br/><span class="ent">➍</span>         2048     4194304     2  freebsd-swap  (2.0G)<br/><span class="ent">➎</span>      4196352  1949327360     3  freebsd-zfs  (930G)<br/><span class="ent">➏</span>   1953523712        1416        - free -  (708K)</pre>
<p class="indent">The first column gives the first block in the partition; the second, the partition size in blocks. The third gives the partition number, while the fourth gives the partition type. (We’ll discuss partition types later this chapter: for the moment, just go with the flow.) At the end, we have the disk size.</p>
<p class="indent">Our first partition begins on the disk’s sector number 40 and fills almost two billion sectors <span class="ent">➊</span>. The third field shows that this isn’t a partition on the disk, but rather an entry for the entire disk. The fourth field gives the partitioning scheme used. This is a GPT disk. The entire disk is about 932GB.</p>
<p class="indent">The second entry also starts on sector 40, and it fills 1,024 sectors <span class="ent">➋</span>. This is partition 1, and it’s of type <em>freebsd-boot</em>. If we want to boot off this disk, we need a boot loader on this partition.</p>
<p class="indent">The third entry begins on sector 1,064 and fills 984 sectors <span class="ent">➌</span>. Why 1,064? The first partition started on sector 40 and filled 1,024 sectors, so the first (1,024 + 40) 1,064 sectors are filled with other partitions. But this partition doesn’t have a partition number, and its type is <code>- free -</code>. This partition is aligned for disks with 4K sectors.</p>
<p class="indent">The fourth entry is swap space, according to the partition type <span class="ent">➍</span>. It begins on sector 2,048, is 4,194,304 sectors long, and is partition 2. You’ll often see swap space near the beginning of a disk, a hangover from the <span epub:type="pagebreak" id="page_216"/>days when partition placement on the disk impacted performance. If you’re using a virtual machine, however, putting the swap near the beginning of the disk leaves you room to expand a partition at the end of the disk.</p>
<p class="indent">The fifth entry is a FreeBSD ZFS filesystem, starting in sector 4,196,352 and going on for about 1.9 billion sectors <span class="ent">➎</span>. This freebsd-zfs partition has our data.</p>
<p class="indent">The very end of the disk has 1,416 free sectors <span class="ent">➏</span>. There’s not quite enough space to add space to the partition while still aligning the partition to the 1MB boundaries.</p>
<p class="indent">A MBR disk looks much like a GPT disk.</p>
<h4 class="h4" id="lev344"><strong><em>Other Views</em></strong></h4>
<p class="noindent">Add command line flags to modify the output of <code>gpart show</code>.</p>
<p class="indent">You can assemble each partition’s device node from the underlying device name and the partition number. If you want to see the device node rather than the partition number, add the <code>-p</code> flag.</p>
<p class="indent">To replace the partition type with the partition label, use <code>-l</code>.</p>
<p class="indent">Here, I show both the device node and the labels on this disk:</p>
<pre>$ <span class="codestrong1">gpart show -pl ada0</span><br/>=&gt;        40  1953525088    ada0  GPT  (932G)<br/>          40        1024  ada0p1  gptboot0  (512K)<br/>        1064         984          - free -  (492K)<br/>        2048     4194304  ada0p2  swap0  (2.0G)<br/>     4196352  1949327360  ada0p3  zfs0  (930G)<br/>  1953523712        1416          - free -  (708K)</pre>
<p class="indent">The partition number now contains complete device names, like <em>ada0p3</em>. Rather than the GPT partition type, you get the label applied to the GPT partition, such as <em>swap0</em> and <em>zfs0</em>.</p>
<p class="indent">To see the human-hostile GPT partition type rather than the name FreeBSD presents, use <code>-r</code>. I mostly use this when examining disks from other operating systems. It’s possible that FreeBSD will label multiple partition types as being type <em>ntfs</em>; while that’s good enough for most uses, if I’m doing digital forensics, the precise partitioning scheme might be extremely important.</p>
<p class="indent">To see a more detailed description of your GPT partitions, use <code>gpart list</code>. This creates output much like <code>glabel list</code> or other GEOM class commands.</p>
<h4 class="h4" id="lev345"><strong><em>Removing Partitions</em></strong></h4>
<p class="noindent">Maybe you screw up when creating your partitions and need to remove one. No, you haven’t created partitions yet, in either MBR or GPT, but the process you follow is the same either way. Delete partitions by number.</p>
<p class="indent">Take a look at the partition table in the previous section. We have partitions for boot, swap, and ZFS. Maybe you don’t want swap space on your boot drive. Remove that partition with the gpart delete command. Use the <code>-i</code> flag and the number of the partition you want to remove. The gpart show command said the swap space was partition 2. Let’s remove it.</p>
<pre><span epub:type="pagebreak" id="page_217"/># <span class="codestrong1">gpart delete -i 2 ada0</span><br/>ada0p2 deleted</pre>
<p class="indent">You can now resize your ZFS partition to use that space. How you resize a partition varies with the partitioning scheme.</p>
<h3 class="h3" id="lev346"><strong>Scheming Disks</strong></h3>
<p class="noindent">No, not the sort of scheming where the disk deliberately lies to you. We’re talking about the disk’s partitioning scheme. Destruction is easier than creation, in both meatspace and with storage. Before you can partition a disk, you need to assign it a partitioning scheme.</p>
<h4 class="h4" id="lev347"><strong><em>Removing the Disk Partitioning Scheme</em></strong></h4>
<p class="noindent">You could go through and painstakingly delete every partition on the disk and then obliterate the partitioning scheme. That’s a bunch of work, though. It’s much simpler to just trash the entire disk partition table.</p>
<p class="indent">You can’t erase a disk with mounted partitions. Unmount those partitions first, and remove them from any ZFS pools. Once the disk is truly unused, erase any existing partitioning table with <code>gpart destroy</code>.</p>
<pre># <span class="codestrong1">gpart destroy da3</span><br/>da3 destroyed</pre>
<p class="indent">If the command returns immediately, the disk had no partitions. It might have had a partition scheme, but no partitions. If you get a “device busy” error, either the disk is still in use or the disk has partitions. You could methodically delete all existing partitions with <code>gpart delete</code> and then destroy the partitioning scheme, but it’s easier to burn the existing scheme to the ground by adding <code>-F</code>.</p>
<pre># <span class="codestrong1">gpart destroy -F da3</span></pre>
<p class="indent">This forcibly erases all partitions and the partitioning scheme. Running <code>gpart show da3</code> will show that there’s no partition table. You can now create new disk partitions.</p>
<h4 class="h4" id="lev348"><strong><em>Assigning the Partitioning Scheme</em></strong></h4>
<p class="noindent">Before you can create disk partitions, you need to mark the disk with the type of partitioning scheme you’ll be using. Use <code>gpart create</code> with the <code>-s</code> flag and the scheme, such as <code>gpt</code> or <code>mbr</code>. Here, I mark a disk as using the GPT scheme:</p>
<pre># <span class="codestrong1">gpart create -s gpt da3</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_218"/>Use <code>gpart show</code> to verify that the disk now has a GPT partition table. You can now add GPT partitions or recreate the partition table with MBR and add those partitions. But we’ll start by diving deep into GPT.</p>
<h3 class="h3" id="lev349"><strong>The GPT Partitioning Scheme</strong></h3>
<p class="noindent">The GUID Partition Table, or GPT, is the modern standard for hard drive partitioning. This is the recommended standard for new installations. Always use the GPT partitioning scheme unless you have a deeply compelling reason not to, such as a lack of hardware support.</p>
<p class="indent">GPT supports disks up to 9.4ZB. One zettabyte is one billion terabytes. While our technology will eventually outgrow 9.4ZB, I expect GPT will last the rest of my career.</p>
<p class="indent">FreeBSD’s GPT implementation currently supports 128 partitions. Each partition gets assigned a GUID, which is a 128-bit number displayed as 32 hexadecimal characters. While GUIDs aren’t guaranteed to be truly unique across all of civilization, they’re certainly going to be unique within your organization.</p>
<p class="indent">Most modern operating systems support GPT and its predecessor, the master boot record (MBR). MBR-based systems put partition records in the first sector on the disk. If a host supports only MBR, but the first sector of a disk contains something that isn’t an MBR, the system gets confused and might refuse to boot. The GPT scheme puts a <em>protective master boot record (PMBR)</em> in the first sector of every disk. The PMBR indicates that the disk contains one MBR partition of type GPT. The second sector contains the actual GUID Partition Table. GPT also puts a backup copy of the partition table on the last sector of the disk so you can more easily recover from damage.</p>
<p class="indent">GPT requires allocating a partition for bootstrap code. The PMBR boot code searches the disk for a FreeBSD boot partition. This boot partition must be larger than the boot code, smaller than 545KB, and reserved for the FreeBSD boot loader. FreeBSD has two GPT boot loaders, gptboot(8) and gptzfsboot(8). You must install one of these on the boot partition.</p>
<p class="indent">Use gptboot(8) to start UFS-based systems. At system boot, gptboot searches for a FreeBSD partition marked with the <em>bootme</em> or <em>bootonce</em> attributes.</p>
<p class="indent">Use gptzfsboot(8) on systems running ZFS.</p>
<p class="indent">Use gpart(8) and its many subcommands to view, create, edit, and destroy GPT partitions.</p>
<h4 class="h4" id="lev350"><strong><em>GPT Device Nodes</em></strong></h4>
<p class="noindent">Each disk partition has a device node. GPT partition device nodes are an extension of the geom they’re built on, indicated by the letter <em>p</em> and the partition number. If you’ve created GPT partitions directly on the disk ada0, the first partition will be <em>/dev/ada0p1</em>, the second <em>/dev/ada0p2</em>, and so on.</p>
<p class="indent">Many systems put their partitions on an upper-layer geom. One of my systems uses SATA RAID and offers the disk as <em>/dev/raid/r0</em>. The partitions <span epub:type="pagebreak" id="page_219"/>on this drive are <em>/dev/raid/r0p1</em>, <em>/dev/raid/r0p2</em>, and so on. You might also put partitions on a device by its GUID or disk ID, giving you partitions like <em>/dev/diskid/DISK-WD-WCAW36477062p1</em>.</p>
<h4 class="h4" id="lev351"><strong><em>GPT Partition Types</em></strong></h4>
<p class="noindent">When you create a GPT partition, you must mark it with a <em>partition type</em>. The type indicates the partition’s intended use. FreeBSD makes decisions based on the partition types, so assign them correctly.</p>
<p class="indent">Strictly speaking, a partition type is another 128-bit GUID. FreeBSD marks GUIDs used as partition types with a leading exclamation point, such as <code>!516e7cb5-6ecf-11d6-8ff8-00022d09712b</code>. These partition types are common across all operating system, but most OSs provide human-friendly names for these human-hostile GUIDs. This book uses the human-friendly names; check gpart(8) for the human-hostile ones.</p>
<p class="indentb">The most common partition types you’ll see on a FreeBSD system include the following:</p>
<p class="hang"><strong>freebsd-boot</strong> FreeBSD boot loader</p>
<p class="hang"><strong>freebsd-ufs</strong> FreeBSD UFS filesystem</p>
<p class="hang"><strong>freebsd-zfs</strong> FreeBSD ZFS filesystem</p>
<p class="hang"><strong>freebsd-swap</strong> FreeBSD swap partition</p>
<p class="hang"><strong>efi</strong> An EFI system partition, used to boot from EFI</p>
<p class="indenttb">You might also see these GPT partition types. Don’t use them in modern FreeBSD, but know that their presence might help you identify just what that weird disk is and how to crack it open.</p>
<p class="hang"><strong>freebsd</strong> A GPT partition that’s divided into bsdlabel(8) partitions</p>
<p class="hang"><strong>freebsd-vinum</strong> A partition controlled by gvinum(8)</p>
<p class="hang"><strong>mbr</strong> A partition subdivided into MBR partitions</p>
<p class="hang"><strong>ntfs</strong> A partition containing a Microsoft NTFS filesystem</p>
<p class="hang"><strong>fat16, fat32</strong> Partitions containing FAT</p>
<p class="indentt">For a complete listing of recognized partition types, see gpart(8).</p>
<h4 class="h4" id="lev352"><strong><em>Creating GPT Partitions</em></strong></h4>
<p class="noindent">Partitioning disks is easy: figure out which partitions you want, create them, and go. The tricky part is living with your partitioning. Before creating partitions, decide what you’re going to do with this disk. How much space do you have? How do you want to divide it? Before you start creating partitions, write down exactly what you want to achieve.</p>
<p class="indent">Here, I’m manually partitioning a 1TB disk for a UFS FreeBSD install. It’ll need a 512KB boot partition (type <em>freebsd-boot</em>) and 8GB for swap (type <em>freebsd-swap</em>). The other partitions will be type <em>freebsd-ufs</em>: 5GB for root, 5GB for <em>/tmp</em>, 100GB for <em>/var</em>, and the rest for <em>/usr</em>. I’ll label each partition for its intended role.</p>
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Create partitions with gpart(8). Use the <code>-t</code> flag to specify the partition type, <code>-s</code> to give the size, and <code>-l</code> to assign a GPT label to the new partition. I’ll start with the boot partition.</p>
<pre># <span class="codestrong1">gpart add -t freebsd-boot -l boot -s 512K da3</span><br/>da3p1 added</pre>
<p class="indent">Use <code>gpart show</code> to check your work. Add the <code>-l</code> flag to see the GPT label.</p>
<pre># <span class="codestrong1">gpart show -l da3</span><br/>=&gt;        40  1953525088  da3  GPT  (932G)<br/>          40        1024    1  boot  (512K)<br/>        1064  1953524064       - free -  (932G)</pre>
<p class="indent">This disk has one partition, a 512K partition labeled <em>boot</em>. The command succeeded. Now add the swap space.</p>
<pre># <span class="codestrong1">gpart add -a 1m -t freebsd-swap -s 8g -l swap da3</span><br/>da3p2 added</pre>
<p class="indent">This command is much like the one to add the boot partition: we give the partition type, size, and label.</p>
<p class="indent">Hang on, though—what’s this <code>-a 1m</code> thing? The <code>-a</code> flag lets you set a partition alignment, enabling you to set where partitions can begin and end relative to the beginning of the disk. Remember back at the beginning of this chapter when I discussed that misaligning a filesystem with the physical sectors on a 4K disk could cause problems? The <code>-a 1m</code> tells gpart to create partition on an even multiple of 1MB from the beginning of the disk. You’ll have some empty space between partitions 1 and 2, as we saw in “<a href="ch10.xhtml#lev343">Viewing Partitions</a>” on <a href="ch10.xhtml#page_215">page 215</a> in this chapter, but that’s okay. That gives you room to change that partition to support UEFI if necessary (see “<a href="ch10.xhtml#lev356">Unified Extensible Firmware Interface and GPT</a>” on <a href="ch10.xhtml#page_222">page 222</a> later this chapter).</p>
<p class="indent">Retain that 1MB alignment as you create the 5GB root and <em>/tmp</em> partitions and the 100GB <em>/var</em> partition.</p>
<pre># <span class="codestrong1">gpart add -a 1m -t freebsd-ufs -s 5g -l root da3</span><br/>da3p3 added<br/># <span class="codestrong1">gpart add -a 1m -t freebsd-ufs -s 5g -l tmp da3</span><br/>da3p4 added<br/># <span class="codestrong1">gpart add -a 1m -t freebsd-ufs -s 100g -l var da3</span><br/>da3p5 added</pre>
<p class="indent">When you create the last partition, don’t give a size. This tells gpart to make the partition as large as possible.</p>
<pre># <span class="codestrong1">gpart add -a 1m -t freebsd-ufs -l usr da3</span><br/>da3p6 added</pre>
<p class="indent">You have partitioned the disk, and it’s ready for your install.</p>
<h4 class="h4" id="lev353"><span epub:type="pagebreak" id="page_221"/><strong><em>Resizing GPT Partitions</em></strong></h4>
<p class="noindent">On second thought, perhaps having a huge <em>/usr</em> partition isn’t wise. A <em>/usr</em> partition of 100GB or so would have all the room you might desire for operating system files, while leaving several hundred gigabytes for an isolated <em>/home</em> partition. I trust most of my users, but a few<sup><a href="footnote.xhtml#ch10fn2" id="ch10fn2a">2</a></sup> are just the sort to dump <em>/dev/random</em> into a file until they absorb all available space. Here, I’ll resize <em>/usr</em> to create space for <em>/home</em>.</p>
<p class="indent">Use <code>gpart resize</code> to change the size of a partition. You must know the target partition’s partition number. Running <code>gpart show da3</code> tells us that <em>/usr</em> is partition 6. Use the <code>-i</code> flag and the partition number to resize a partition.</p>
<pre># <span class="codestrong1">gpart resize -i 6 -s 100g -a 1m da3</span><br/>da3p6 resized</pre>
<p class="indent">Run <code>gpart show</code> to see the new disk size.</p>
<pre># <span class="codestrong1">gpart show da3</span><br/>--<span class="codeitalic1">snip</span>--<br/>   247465984   209715200    6  freebsd-ufs  (100G)<br/>   457181184  1496343944       - free -  (714G)</pre>
<p class="indent">This disk has 714GB free at the end. We can now create a spacious <em>/home</em> for all our troublesome users.</p>
<p class="indent">Each partition is assigned specific sectors on the disk. You can’t increase the size of a partition if there’s no free space on either side of the partition. While this sample disk has a bunch of free space after partition 6, you can’t use it to increase the size of partitions 1 through 5. You must delete and recreate partitions.</p>
<p class="indent">Changing the size of a partition doesn’t change the size of the filesystem on that partition. Shrinking a partition with a filesystem will chop off part of the filesystem. Increasing the partition size won’t expand the filesystem. Both UFS and ZFS have tools to handle increased partition sizes, but you must handle that as a separate process.</p>
<h4 class="h4" id="lev354"><strong><em>Changing Labels and Types</em></strong></h4>
<p class="noindent">You can modify a GPT partition’s type or GPT label with the <code>gpart modify</code> command. Give the partition number with <code>-i</code>. Use <code>-l</code> to give the new label. Here, I change the GPT label on partition 2 of disk vtbd0:</p>
<pre># <span class="codestrong1">gpart modify -i 2 -l rootfs vtbd0</span></pre>
<p class="indent">Similarly, change the type of partition with <code>-t</code>:</p>
<pre># <span class="codestrong1">gpart modify -i 2 -t freebsd-zfs vtbd0</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_222"/>The disk’s GPT table now declares that partition 2 is labeled <code>rootfs</code> and is of type <em>freebsd-zfs</em>.</p>
<h4 class="h4" id="lev355"><strong><em>Booting on Legacy Hardware</em></strong></h4>
<p class="noindent">Older hardware expects to see a master boot record at the start of the disk and won’t recognize a GPT partition table. FreeBSD uses a protective MBR (PMBR) to give legacy hardware a recognizable partition table and help that hardware boot a GPT-partitioned disk. A bootable disk formatted with GPT needs both a protective MBR and a GPT boot loader.</p>
<p class="indent">Install a PMBR with the <code>gpart bootcode</code> command and the <code>-b</code> flag. FreeBSD provides a PMBR as <em>/boot/pmbr</em>.</p>
<pre># <span class="codestrong1">gpart bootcode -b /boot/pmbr da3</span><br/>bootcode written to da3</pre>
<p class="indent">This disk will no longer confuse hosts that look for an MBR.</p>
<p class="indent">You also need a boot loader. UFS hosts need the <em>gptboot</em> boot loader, while ZFS hosts need <em>gptzfsboot</em>. For convenience, FreeBSD provides a copy of each in the <em>/boot</em> directory. These copies are not the on-disk boot loader, only the version of the bootloaders needed for that version of FreeBSD. Install the selected boot loader with the <code>-p</code> flag to <code>gpart bootcode</code>. Use the <code>-i</code> option to tell gpart(8) which partition to copy the boot loader to. The sample disk we used in the last section had partition 1 as type <em>freebsd-boot</em>, so we’ll use that.</p>
<pre># <span class="codestrong1">gpart bootcode -p /boot/gptboot -i 1 da3</span><br/>partcode written to da3p1</pre>
<p class="indent">You can combine <code>-p</code> and <code>-b</code> into a single command.</p>
<h4 class="h4" id="lev356"><strong><em>Unified Extensible Firmware Interface and GPT</em></strong></h4>
<p class="noindent">The <em>Unified Extensible Firmware Interface (UEFI)</em> is a newer standard for booting amd64 hardware without using BIOS emulation. FreeBSD 10 and later have early support for UEFI booting to UFS, while FreeBSD 11 can boot ZFS off of UEFI.</p>
<p class="indent">UEFI uses a partition of type <em>efi</em>, which must be 800KB or larger. Create an efi partition on a new disk with <code>gpart create</code>.</p>
<pre># <span class="codestrong1">gpart create -s gpt da0</span><br/># <span class="codestrong1">gpart add -t efi -s 800K da0</span></pre>
<p class="indent">FreeBSD provides an efi partition as <em>/boot/boot1.efifat</em>. Copy that to the new boot partition with dd(1).</p>
<pre># <span class="codestrong1">dd if=/boot/boot1.efifat of=/dev/da0p1</span></pre>
<p class="indent">Partition the rest of the disk as you desire.</p>
<p class="indent"><span epub:type="pagebreak" id="page_223"/>An efi partition is actually a FAT filesystem with a very specific directory hierarchy. Feel free to mount the file <em>boot1.efifat</em> and explore it.</p>
<h4 class="h4" id="lev357"><strong><em>Expanding GPT Disks</em></strong></h4>
<p class="noindent">We’ve seen how to expand a partition, but what about a disk? Expanding disks often happens with virtual hosts. Expand a virtual disk, and gpart(8) will complain that the disk’s GPT is invalid. GPT and GEOM store information in the first and last sectors of the disk. Expanding a virtual disk means adding sectors. The new last sector will be empty. Create a new metadata block for the last sector with <code>gpart recover</code>.</p>
<pre># <span class="codestrong1">gpart recover vtbd0</span></pre>
<p class="indent">You can now create or expand partitions on the expanded virtual disk.</p>
<p class="indent">Now that you have a handle on GPT partitions, let’s look at MBR and see why GPT seemed like such an improvement.</p>
<h3 class="h3" id="lev358"><strong>The MBR Partitioning Scheme</strong></h3>
<p class="noindent">Old hardware, or new but small hardware, might need master boot record partitioning on its disks. Intel-style hardware has used MBR partitions for decades, and millions of devices running a plethora of operating systems use it. The MBR scheme works only on disks of 2TB or smaller. Larger disks must use GPT partitioning.</p>
<h4 class="h4" id="lev359"><strong><em>What Is the Master Boot Record?</em></strong></h4>
<p class="noindent">The <em>master boot record (MBR)</em> is a file that takes up the first 512 bytes of a traditional disk, also known as <em>Sector 0</em>. The MBR contains partition information and a boot loader to allow the BIOS to find the operating system. The term <em>MBR</em> might refer to the actual first sector on the disk or the partition scheme used by that format.</p>
<p class="indent">A master boot record describes four <em>primary partitions</em>, called <em>slices</em> in the BSD community. Each slice description includes the disk sectors included in the partition and the type of filesystem expected on that slice. If a disk has only one slice on it, the MBR still lists four slices, but three of those slices have no sectors assigned to them. While the MBR format supports a linked list of up to 20 extended partitions, FreeBSD doesn’t need them thanks to BSD labels.</p>
<p class="indent">One of the four primary slices is considered active. When the system powers on, the bootstrap code looks for the active slice and tries to boot it.</p>
<p class="indent">The MBR sector also contains bootstrap code. You don’t need to allocate space specifically for a boot loader. In FreeBSD, the bootstrap code finds and executes the kernel. FreeBSD includes two different boot loaders, <em>mbr</em> and <em>boot0</em>. The mbr loader is for a host with a single operating system. <span epub:type="pagebreak" id="page_224"/>If you have multiple operating systems installed on your hardware, use the boot0 loader—or, better still, dedicate your host to FreeBSD and virtualize the other operating systems.</p>
<p class="indent">The main function of a slice is to contain a bsdlabel(8) partition.</p>
<h4 class="h4" id="lev360"><strong><em>BSD Labels</em></strong></h4>
<p class="noindent">BSD existed before either the MBR or the IBM PC. BSD used its own disk partition format, called a <em>disklabel</em>. Now that labeling disks is much more common, disklabels are also called <em>BSD labels</em> or <em>bsdlabels</em>. (If you want to start a spirited discussion, ask a room of FreeBSD developers which is more correct.) BSD systems had several partitions including at least <em>/</em> (root), <em>/usr</em>, <em>/var</em>, <em>/tmp</em>, and swap space, plus separate partitions for whatever actual work the system did.</p>
<p class="indent">When BSD was ported to the i386 platform, they could have switched disks to using MBR partitions. With extended MBR partitions, one disk could have had up to 24 partitions. Disklabel partitions were embedded throughout the kernel, however, often in icky places that nobody dared touch. The porting group decided to treat an MBR slice as a BSD disk and to partition each slice with a BSD disklabel. Sysadmins needed to create MBR partitions and then nest disklabel partitions inside those MBR partitions.<sup><a href="footnote.xhtml#ch10fn3" id="ch10fn3a">3</a></sup></p>
<p class="indent">This worked but also made the word <em>partition</em> ambiguous. Does <em>partition</em> mean an MBR partition or a disklabel partition? FreeBSD dusted off the word <em>slices</em> for MBR partitions. Each MBR slice will have its own disklabel, listing the BSD partitions contained within the slice. If you come from a Linux or Microsoft Windows background, the MBR partitions you’re familiar with are called <em>slices</em> over here.</p>
<p class="indent">You can’t label slices or disklabel partitions. These formats have no space for labels. Instead, label the ZFS or UFS filesystem on the partition.</p>
<p class="indent">It’s possible to skip slicing a disk, instead installing a disklabel directly on the hard drive. Some hardware refused to boot from such disks, so they’re called <em>dangerously dedicated</em>. With the advent of GPT, dangerously dedicated disks aren’t really used any more.</p>
<h4 class="h4" id="lev361"><strong><em>MBR Device Nodes</em></strong></h4>
<p class="noindent">Every disk, slice, and partition has a device node. The slice device node is an extension of the underlying disk, and the partition device node is an extension of the device’s node. Here are the device nodes on disk ada0 of an MBR-based system:</p>
<pre>/dev/ada0       /dev/ada0s1a    /dev/ada0s1d<br/>/dev/ada0s1     /dev/ada0s1b    /dev/ada0s1e</pre>
<p class="indent"><span epub:type="pagebreak" id="page_225"/>The first subdivision of the disk is the slice. Device nodes indicate a slice with the letter <em>s</em> and a number from 1 to 4. The first slice is s1, the second is s2, and so on. Unused MBR partitions don’t get device nodes. Here, <em>/dev/ada0s1</em> is slice 1 on the disk.</p>
<p class="indent">The second layer of subdivision is the disklabel partition inside the slice. Each partition has a unique device node name created by adding a letter to the slice’s device node. Here, we have four disklabel partitions, <em>/dev/ada0s1a</em> through <em>/dev/ada0s1e</em>. Traditionally, the node ending in <em>a</em> (<em>/dev/ada0s1a</em>) is the root partition, while the node ending in <em>b</em> (<em>/dev/ada0s1b</em>) is swap space.</p>
<p class="indent">Note that the list of device nodes doesn’t use the letter <em>c</em>. The c partition represents the entire slice. These days, you run disk partitioning tools on the slice entry rather than the disklabel for the slice.</p>
<p class="indent">Assign partitions d through h any way you like. A default disklabel can have up to seven usable partitions. With up to four slices on each drive, you can have up to 28 partitions on a drive. A disklabel can support up to 20 partitions, but you must indicate you want extra partitions when first creating the label.</p>
<h4 class="h4" id="lev362"><strong><em>MBR and Disklabel Alignment</em></strong></h4>
<p class="noindent">Slices have their own disk sector and filesystem block alignment issues. Traditionally, MBR partitions end on a cylinder boundary. Cylinder boundaries don’t mean anything on modern hardware, but even newer drives provide them as a comforting lie for older or less capable hardware. If you create MBR partitions that don’t end on a cylinder boundary, and you put that disk in a machine that requires respecting cylinder boundaries, the machine will have some sort of nervous breakdown. A disk you slice today could theoretically find its way into an older system. FreeBSD therefore arranges slices so that they end on cylinder boundaries. Cylinder boundaries not only can but probably do conflict with 4K disk sector sizes. If nothing else, the MBR itself takes up the first cylinder, or sixty-three 512-byte sectors!</p>
<p class="indent">Fortunately you rarely write to slice tables, and the performance of writing slice tables is rarely an issue. If you align your disklabel partitions within a slice to 1MB boundaries, you’ll lose a few sectors between the slice partition table and the disklabel partition, but you’ll have proper performance.</p>
<p class="indent">So: align disklabel partitions. Don’t align slices.</p>
<h4 class="h4" id="lev363"><strong><em>Creating Slices</em></strong></h4>
<p class="noindent">Use gpart(8) to manage MBR slices. To create a slice, you need a partition type and a size. FreeBSD slices use type <em>freebsd</em>. If you don’t specify a size, gpart(8) uses all available space. On an empty disk, this dedicates the whole disk to a single slice.</p>
<p class="indent">Here, I erase the existing partitioning, tell the disk to use the MBR scheme, and create a single FreeBSD slice:</p>
<pre># <span class="codestrong1">gpart destroy -F ada3</span><br/># <span class="codestrong1">gpart create -s mbr ada3</span><br/><span epub:type="pagebreak" id="page_226"/># <span class="codestrong1">gpart add -t freebsd ada3</span><br/>ada3s1 added</pre>
<p class="indent">Run <code>gpart show</code> and you’ll see that this disk now has a single slice. Add the <code>-p</code> flag to see the slice’s device node.</p>
<pre># <span class="codestrong1">gpart show -p ada3</span><br/>=&gt;        63  1953525105    ada3  MBR  (932G)<br/>          63  1953525105  ada3s1  freebsd  (932G)</pre>
<p class="indent">Our slice ada3s1 is now ready for disklabel partitions.</p>
<p class="indent">To create multiple slices, specify a size with <code>-s</code>. A common configuration for small embedded systems is to put three slices on a disk. Two smaller slices contain different versions of the operating system, while the third contains any data. Here, I divide this 1TB disk into two 150GB slices and give the rest to a third slice:</p>
<pre># <span class="codestrong1">gpart add -s 150g -t freebsd ada3</span><br/>ada3s1 added<br/># <span class="codestrong1">gpart add -s 150g -t freebsd ada3</span><br/>ada3s2 added<br/># <span class="codestrong1">gpart add -t freebsd ada3</span><br/>ada3s3 added</pre>
<h4 class="h4" id="lev364"><strong><em>Removing Slices</em></strong></h4>
<p class="noindent">Use <code>gpart delete</code> to remove unwanted slices. Give the slice number with <code>-i</code>. Here, I remove the third, larger slice from our multislice disk created in the last section:</p>
<pre># <span class="codestrong1">gpart delete -i 3 ada3</span><br/>ada3s3 deleted</pre>
<h4 class="h4" id="lev365"><strong><em>Activating Slices</em></strong></h4>
<p class="noindent">The active slice is the one that the BIOS tries to boot. Set the active slice with the <code>-a</code> active flag. Use <code>-i</code> to give the number of the active slice.</p>
<pre># <span class="codestrong1">gpart set -a active -i 1 ada3</span></pre>
<p class="indent">Change which slice gets booted by setting a different active slice.</p>
<p class="indent">The boot disk also needs a boot loader. While the MBR boot loader is different from the GPT or UEFI boot loaders, it uses the same gpart(8) <code>-b</code> flag. FreeBSD provides a copy of the MBR boot loader as <em>/boot/mbr</em>.</p>
<pre># <span class="codestrong1">gpart bootcode -b /boot/mbr ada3</span></pre>
<p class="indent">Slice 1 on disk ada3 is now bootable. Now that you’ve sliced your disk, you can create BSD labels inside the slices.</p>
<h3 class="h3" id="lev366"><span epub:type="pagebreak" id="page_227"/><strong>BSD Labels</strong></h3>
<p class="noindent">Creating BSD label (or disklabel) partitions inside a slice is much like creating slices or GPT partitions. You must tell the storage device the scheme to be used, create and remove partitions until you’re satisfied with them, and install a boot loader.</p>
<h4 class="h4" id="lev367"><strong><em>Creating a BSD Label</em></strong></h4>
<p class="noindent">Where GPT and MBR specifically provide space for partition tables, you must create a BSD label and write it to the beginning of the slice. As with any scheme, use <code>-s</code> and the name of the scheme. Install this scheme on the slice, not on the disk.</p>
<p class="indent">Suppose you want to create a BSD label on the slice ada3s1. Use the BSD scheme.</p>
<pre># <span class="codestrong1">gpart create -s bsd ada3s1</span><br/>ada3s1 created</pre>
<p class="indent">This is a default disklabel, with room for 8 disklabel partitions. You can increase the number of partitions, up to 20, by using the <code>-n</code> flag. Here, I create a whole bunch of partitions on ada3s3, the large partition.</p>
<pre># <span class="codestrong1">gpart create -n 20 -s bsd ada3s3</span><br/>ada3s3 created</pre>
<p class="indent">There are no actual disklabel partitions on this slice; there’s merely a label that can contain disklabel partitions. Now that the label exists, you can create those partitions.</p>
<h4 class="h4" id="lev368"><strong><em>Creating BSD Label Partitions</em></strong></h4>
<p class="noindent">Before blindly entering partitioning commands, plan how to partition the disk. Figuring things out on paper beforehand is much easier than figuring them out at the command line. I’m going to partition the first 150GB slice on this disk for UFS filesystems. This slice will get 5GB partitions for <em>/</em> (root), swap, and <em>/tmp</em>. The rest will go to <em>/usr</em>. Why no <em>/var</em>? I’ll dedicate the big slice, ada3s3, to <em>/var</em>. I don’t need to add a boot partition because MBR disks don’t need one.</p>
<p class="indent">To create a disklabel partition, you must specify the type with <code>-t</code> and the size with <code>-s</code>—exactly as you would for GPT partitions. FreeBSD UFS filesystems are of type <em>freebsd-ufs</em>. Let’s start with the root partition.</p>
<pre># <span class="codestrong1">gpart add -t freebsd-ufs -s 5g -a 1m ada3s1</span><br/>ada3s1 added</pre>
<p class="indent">To view this partition, you must give <code>gpart show</code> the slice device, not the disk device. Using the disk device displays the slices.</p>
<pre><span epub:type="pagebreak" id="page_228"/># <span class="codestrong1">gpart show ada3s1</span><br/>=&gt;        0  314572800  ada3s1  BSD  (150G)<br/>          0       1985          - free -  (993K)<br/>       1985   10485760       1  freebsd-ufs  (5.0G)<br/>   10487745  304085055          - free -  (145G)</pre>
<p class="indent">The third line of output shows our 5GB partition.</p>
<p class="indent">At the very beginning of this slice, we have 1,985 free blocks, or 993KB. I requested that the partition be aligned to 1MB boundaries, so gpart wasted a bit of space to meet that request. I’ll happily lose that 993KB, rather than halve the system’s performance.</p>
<p class="indent">Now create the swap partition of type <em>freebsd-swap</em>.</p>
<pre># <span class="codestrong1">gpart add -t freebsd-swap -s 5g -a1m ada3s1</span><br/>ada3s1b added</pre>
<p class="indent">The 5GB <em>/tmp</em> comes next. Then, I dump the rest of the space into a partition for <em>/usr</em> by omitting the size.</p>
<pre># <span class="codestrong1">gpart add -t freebsd-ufs -s 5g -a1m ada3s1</span><br/>ada3s1d added<br/># <span class="codestrong1">gpart add -t freebsd-ufs -a1m ada3s1</span><br/>ada3s1e added</pre>
<p class="indent">A <code>gpart show</code> reveals our disklabel partitions have wasted 63 blocks, or 32KB, at the end of the disk. Watch me not care.</p>
<p class="indent">These partitions are now ready to receive filesystems. We discuss UFS in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>
<h4 class="h4" id="lev369"><strong><em>Assigning Specific Partition Letters</em></strong></h4>
<p class="noindent">On a traditional BSD label, the <em>a</em> partition is for the root filesystem, while <em>b</em> is for swap. The <em>c</em> partition represents the entire slice. This isn’t mandatory, but I recommend not using any of these letters for any other purpose.</p>
<p class="indent">Why is this important? I once added a hard drive to a server so that we had more space for a database. We moved the database software to partition <em>a</em> and the actual data to partition <em>b</em>.<sup><a href="footnote.xhtml#ch10fn4" id="ch10fn4a">4</a></sup> When I went on vacation a few months later, the system ran short on virtual memory. I got a call from a sysadmin who had found and activated the unconfigured swap space on the new drive—but now the database data was missing. Yes, the company lost several customers and many thousands of dollars of revenue, which is sad—but more importantly, it ruined one day of my vacation and cast a shadow over the rest. This was unacceptable.</p>
<p class="indent">Don’t bother fighting these traditions, especially on a decreasingly common disk format. Don’t use the letters <em>a</em>, <em>b</em>, or <em>c</em> for partitions other than those decreed by the Berkeley elders.</p>
<p class="indent"><span epub:type="pagebreak" id="page_229"/>The gpart program is designed to work with partition numbers, not letters. When you’re creating disklabels, however, <code>gpart add</code> maps index numbers onto letters. Partition 1 is <em>a</em>, partition 2 is <em>b</em>, and so on. By specifying a partition index when you create the partition, you assign the letter to the partition.</p>
<p class="indent">If you don’t specify a partition number, <code>gpart add</code> assigns partition letters starting with <em>a</em>. You might assign your first partition number 18, but if you don’t specify a number for the next partition, it’ll wind up getting partition <em>a</em>. To avoid using <em>a</em>, <em>b</em>, or <em>c</em>, use a number for every partition you create. You can use letters only up to the number of disklabel slots the partition has. A standard disklabel can use only letters <em>a</em> through <em>h</em>, while a 20-partition label can use <em>a</em> through <em>t</em>.</p>
<p class="indent">On my three-slice system, I want to put <em>/var</em> on ada3s3. I want to use a letter other than <em>a</em>, <em>b</em>, or <em>c</em>, so I randomly pick index 18. It’s almost exactly the same as the partition for <em>/usr</em>, but we’re adding it to a different slice.</p>
<pre># <span class="codestrong1">gpart add -t freebsd-ufs -a 1m -i 18 ada3s3</span><br/>ada3s3r added</pre>
<p class="indent">To see that disklabel partition, you’ll need to run <code>gpart show ada3s3</code>. Add <code>-p</code> to see the device name.</p>
<pre># <span class="codestrong1">gpart show -p ada3s3</span><br/>=&gt;         0  1324379505   ada3s3  BSD  (632G)<br/>           0        1985           - free -  (993K)<br/>        1985  1324376064  ada3s3r  freebsd-ufs  (632G)<br/>  1324378049        1456           - free -  (728K)</pre>
<p class="indent">What do you know? The 18th letter of our alphabet is <em>R</em>.</p>
<p class="indent">With partitions, we can start to look at filesystems.<span epub:type="pagebreak" id="page_230"/></p>
</body></html>