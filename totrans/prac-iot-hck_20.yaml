- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hacking the Smart Home
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Common devices found in almost any modern home, such as TVs, refrigerators,
    coffee machines, HVAC systems, and even fitness equipment are now connected to
    each other and are capable of offering more services to users than ever before.
    You can set your desired home temperature while you’re driving, receive a notification
    when your washing machine has finished a load, turn on the lights and open window
    blinds automatically when you arrive home, or even have your TV stream a show
    directly to your phone.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, more and more businesses are equipped with similar devices,
    not just in meeting rooms, kitchens, or lounges. Many offices use IoT devices
    as part of critical systems, such as office alarms, security cameras, and door
    locks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we perform three separate attacks to show how hackers can tamper
    with popular IoT devices used in modern smart homes and businesses. These demonstrations
    build on techniques we discussed throughout the book, so they should animate some
    of what you learned in earlier chapters. First, we show you how to gain physical
    entry to a building by cloning a smart lock card and disabling an alarm system.
    Next, we retrieve and stream footage from an IP security camera. Then we describe
    an attack to gain control of a smart treadmill and cause potentially life-threatening
    injuries.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining Physical Entry to a Building
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart home security systems are undoubtedly a potential target for adversaries
    who want to gain access to a victim’s premises. Modern security systems are usually
    equipped with a touch keypad, a number of wireless door and window access sensors,
    motion radars, and an alarm base station with cellular and battery backup. The
    *base station*, which is the core of the whole system, handles all the identified
    security events. It’s internet connected and able to deliver emails and push notifications
    to the user’s mobile device. In addition, it’s often highly integrated with smart
    home assistants, such as Google Home and Amazon Echo. Many of these systems even
    support expansion kits that include face-tracking cameras with facial recognition
    capabilities, RFID-enabled smart door locks, smoke detectors, carbon monoxide
    detectors, and water leak sensors.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll use techniques introduced in Chapter 10 to identify the
    RFID card used to unlock the apartment door’s smart lock, retrieve the key that
    protects the card, and clone the card to gain access to the apartment. Then we’ll
    identify the frequency that the wireless alarm system is using and try to interfere
    with its communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a Keylock System’s RFID Tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To gain physical access to a smart home, you first have to circumvent the smart
    door lock. These systems are mounted on the inside of existing door locks and
    come with an integrated 125 kHz/13.56 MHz proximity reader that allows users to
    pair key fobs and RFID cards. They can automatically unlock the door when you
    come home and securely lock it again when you leave.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll use a Proxmark3 device, introduced in Chapter 10, to
    clone a victim’s RFID card and unlock their apartment door. You can find instructions
    on how to install and configure the Proxmark3 device in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, let’s imagine we can get close to the victim’s RFID card.
    We need to be near the wallet in which the victim stores the RFID card for only
    a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the Kind of RFID Card Used
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we must identify the type of RFID card the door lock is using by scanning
    the victim’s card using Proxmark3’s `hf` search command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Proxmark3 tool detects the existence of a MIFARE Classic 1KB card 1. The
    output also tests for a number of known card weaknesses that might allow us to
    interfere with the RFID card. Notably, we see that its *pseudorandom number generator**(PRNG)*
    is marked as weak 2. The PRNG implements the RFID card’s authentication control
    and protects the data exchange between the RFID card and the RFID reader.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Darkside Attack to Retrieve a Sector Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can leverage one of the detected weaknesses to identify the sector keys for
    this card. If we uncover the sector keys, we can entirely clone the data, and
    because the card contains all the information necessary for the door lock to identify
    the house owner, cloning the card allows adversaries to impersonate the victim.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in Chapter 10, a card’s memory is divided into sectors, and to
    read the data of one sector, the card reader has to first authenticate using the
    corresponding sector key. The easiest attack that requires no previous knowledge
    regarding the card data is the Darkside attack. The *Darkside attack* uses a combination
    of a flaw in the card’s PRNG, a weak validation control, and a number of the card’s
    error responses to extract parts of a sector’s key. The PRNG provides weak random
    numbers; additionally, each time the card is powered up, the PRNG is reset to
    the initial state. As a result, if attackers pay close attention to timing, they
    can either predict the random number generated by the PRNG or even produce the
    desired random number at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform the Darkside attack by providing the `hf mf mifare` command
    in the Proxmark3 interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to recover the key for one sector in 1 to 25 seconds. The
    key we recovered is one of the default keys for this type of RFID card 1.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Nested Authentication Attack to Retrieve the Remaining Sector Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you know at least one sector key, you can perform a faster attack called
    nested authentication to retrieve the rest of the sector keys, which you need
    to clone the data in the rest of the sectors. A *nested authentication* attack
    allows you to authenticate to one sector and hence establish an encrypted communication
    with the card. A subsequent authentication request by the adversary for another
    sector will force the authentication algorithm to execute again. (We went over
    the details of this authentication algorithm in Chapter 10.) But this time, the
    card will generate and send a challenge, which an attacker can predict as a result
    of the PRNG vulnerability. The challenge will be encrypted with the corresponding
    sector’s key. Then a number of bits will be added to this value to reach a certain
    parity. If you know the predictable challenge with its parity bits and its encrypted
    form, you can infer parts of the sector’s key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform this attack using the `hf mf nested` command, followed by a
    number of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter specifies the card memory (because it’s 1KB, we use the
    value `1`); the second parameter specifies the sector number for which the key
    is known; the third parameter defines the key type of the known key (either `A`
    or `B` in a MIFARE card); the fourth parameter is the previously extracted key;
    and the `t` parameter asks to transfer the keys into the Proxmark3 memory. When
    the execution finishes, you should see a matrix with the two key types for each
    sector.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Tag into Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s possible to load the tag into the Proxmark3 emulator’s memory using
    the `hf mf ecfill` command. The `A` parameter specifies, again, that the tool
    should use the authentication key type `A (0x60)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Testing the Cloned Card
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you can approach the door lock and emulate the cloned tag by reading and
    writing the contents stored in the Proxmark3 memory using the `hf mf sim` command.
    There’s no need to write the contents to a new card, because Proxmark3 can mimic
    the RFID card.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that not all MIFARE Classic cards are vulnerable to these two attacks.
    For attacks against other types of RFID cards and fobs, see the techniques discussed
    in Chapter 10\. For simpler key fobs that don’t enforce an authentication algorithm,
    you can also use cheap key fob duplicators, such as Keysy from TINYLABS. Explore
    the supported key fob models on its website at [https://tinylabs.io/keysy/keysy-compatibility/](https://tinylabs.io/keysy/keysy-compatibility/)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Jamming the Wireless Alarm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Darkside attack allowed you to easily gain entry to the victim’s premises.
    But the apartment might also be equipped with an alarm system that can detect
    a security breach and activate a fairly loud warning through its embedded siren.
    Also, it can rapidly inform the victims about the breach by sending a notification
    to their mobile phones. Even if you’ve circumvented the door lock, opening the
    door will cause a wireless door access sensor to trigger this alarm system.
  prefs: []
  type: TYPE_NORMAL
- en: One way to overcome this challenge is to disrupt the communication channel between
    the wireless sensors and the alarm system base station. You can do this by jamming
    the radio signals that the sensors transmit to the alarm’s base. To perform a
    *jamming attack*, you’ll have to transmit radio signals in the same frequency
    that the sensors use, and as a result, decrease the communication channel’s *signal-to-noise
    ratio**(SNR)*. The SNR is a ratio of the power of the meaningful signal that reaches
    the base station from the sensors to the power of the background noise also reaching
    the base station. A decreased SNR ratio blocks the base station from hearing communications
    from the door access sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the Alarm System’s Frequency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll set up a *software defined radio**(SDR)* using a low-cost
    RTL-SDR DVB-T dongle ([Figure 15-1](#figure15-1)). We’ll use it to listen to the
    frequency coming from the alarm so we can transmit signals of the same frequency
    later.
  prefs: []
  type: TYPE_NORMAL
- en: '![f15001](Images/f15001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: A cheap RTL-SDR DVB-T dongle and an alarm system with a wireless
    door access sensor'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replicate this experiment, you can use most DVB-T dongles equipped with
    a *Realtek RTL2832U* chipset. The driver for the RTL2832U is preinstalled in Kali
    Linux. Enter the following command to verify that your system detects the DVB-T
    dongle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To convert the radio spectrum into a digital stream that we can analyze, we
    need to download and execute the CubicSDR binary ([https://github.com/cjcliffe/CubicSDR/releases/](https://github.com/cjcliffe/CubicSDR/releases/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most wireless alarm systems use one of the few unlicensed frequency bands,
    such as the 433 MHz band. Let’s start by monitoring the frequency at 433 MHz when
    the victim opens or closes a door that is equipped with a wireless access sensor.
    To do this, use the `chmod` utility, which is preinstalled in Linux platforms,
    followed by the `+x` parameter to make the binary executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the binary using the following command; the CubicSDR interface should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The application should list the detected devices that you can use. Select the
    RTL2932U device and click **Start**, as shown in[Figure 15-2](#figure15-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15002](Images/f15002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-2: CubicSDR device selection'
  prefs: []
  type: TYPE_NORMAL
- en: To select a frequency, move the mouse pointer over the value listed in the**Set
    Center Frequency** boxand press the spacebar. Then enter the value **433MHz**,
    as shown in [Figure 15-3](#figure15-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15003](Images/f15003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-3: CubicSDR Frequency selection'
  prefs: []
  type: TYPE_NORMAL
- en: You can view the frequency in CubicSDR, as shown in [Figure 15-4](#figure15-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15004](Images/f15004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-4: The CubicSDR listening at 433 MHz'
  prefs: []
  type: TYPE_NORMAL
- en: Every time the victim opens or closes the door, you should see a little green
    peak in the diagram. Stronger peaks will appear in yellow or red, indicating the
    exact frequency that the sensor is transmitting.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting a Signal at the Same Frequency Using the Raspberry Pi
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the open source *Rpitx* software, you can transform a Raspberry Pi into
    a simple radio transmitter that can handle frequencies from 5 kHz to 1,500 MHz.
    The Raspberry Pi is a low-cost, single-board computer that is useful for many
    projects. Any Raspberry Pi model running a lite Raspbian operating system installation,
    except for the Raspberry Pi B, can currently support Rpitx.
  prefs: []
  type: TYPE_NORMAL
- en: To install and run Rpitx, first connect a wire to the exposed GPIO 4 pin on
    the Raspberry Pi, as shown in [Figure 15-5](#figure15-5). You can use any commercial
    or custom wire for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '![f15005](Images/f15005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-5: The Raspberry Pi GPIO 4 pin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `git` command to download the app from the remote repository. Then
    navigate to its folder and run the *install.sh* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now reboot the device. To start the transmission, use the `rpitx` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` parameter defines the transmission mode. In this case, we set it to
    `VFO` to transmit a constant frequency. The `-f` parameter defines the frequency
    to output on the Raspberry Pi’s GPIO 4 pin in kilohertz.
  prefs: []
  type: TYPE_NORMAL
- en: If you connect the Raspberry Pi to a monitor, you can use the Rpitx graphic
    user interface to tune the transmitter further, as shown in [Figure 15-6](#figure15-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15006](Images/f15006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-6: Rpitx GUI transmitter options'
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that the signal is transmitted at the correct frequency by making
    a new capture using the RTL-SDR DVB-T dongle. Now you can open the door without
    triggering the alarm.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Rpitx version 2 or later, you could also record a signal directly
    from the RTL-SDR DVB-T dongle and replay it at the same frequency through the
    provided graphic user interface. In this case, you wouldn’t need to use CubicSDR.
    We leave this as an exercise for you to complete. You could try this feature against
    alarm systems that offer a remote controller for activating or deactivating the
    alarm.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that more expensive, highly sophisticated alarm systems will detect
    the noise in the wireless frequency and attempt to notify the user about this
    event. To avoid this, you could attempt to jam the alarm system base station’s
    Wi-Fi connectivity by performing a deauthentication attack, as discussed in Chapter
    12\. Refer to that chapter for more information about using the Aircrack-ng suite.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Back an IP Camera Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you’re an attacker who has somehow gained access to a network that includes
    IP cameras. Now, what could constitute an impactful attack that has significant
    privacy implications and that you could conduct without even touching the cameras?
    Playing back the camera video stream, of course. Even if the cameras have no vulnerabilities
    (highly unlikely!), an attacker who gains a man-in-the-middle position on the
    network could capture traffic from any potential insecure communication channels.
    The bad (or good, depending on your perspective) news is that many current cameras
    still use unencrypted network protocols to stream their video. Capturing the network
    traffic is one thing, but being able to demonstrate to stakeholders that it’s
    possible to play back the video from that dump is another.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily achieve the man-in-the-middle position using techniques like
    ARP cache poisoning or DHCP spoofing (first introduced in Chapter 3) if the network
    has no segmentation. In the camera video stream example, we assume that this has
    already been achieved and that you’ve captured a network camera’s *pcap* file
    streaming through the Real Time Streaming Protocol (RTSP), the Real-time Transport
    Protocol (RTP), and the RTP Control Protocol (RTCP), which are discussed in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Streaming Protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTSP, RTP, and RTCP protocols usually work in conjunction with one another.
    Without delving too much into their inner workings, here is a quick primer on
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: RTSP Is a client-server protocol that acts as a network remote control for multimedia
    servers with live feeds and stored clips as data sources. You can imagine RTSP
    as the protocol overlord that can send VHS-style multimedia playback commands,
    such as play, pause, and record. RTSP usually runs over TCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RTP Performs the transmission of the media data. RTP runs over UDP and works
    in concert with RTCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RTCP Periodically sends out-of-band reports that announce statistics (for example,
    the number of packets sent and lost and the jitter) to the RTP participants. Although
    RTP is typically sent on an even-numbered UDP port, RTCP is sent over the next
    highest odd-number UDP port: you can spot this in the Wireshark dump in [Figure
    15-7](#figure15-7).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing IP Camera Network Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our setup, the IP camera has the IP address 192.168.4.180 and the client
    that is intended to receive the video stream has the IP address 192.168.5.246\.
    The client could be the user’s browser or a video player, such as VLC media player.
  prefs: []
  type: TYPE_NORMAL
- en: As a man-in-the-middle positioned attacker, we’ve captured the conversation
    that [Figure 15-7](#figure15-7) shows in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '![f15007](Images/f15007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-7: Wireshark output of a typical multimedia session established through
    RTSP and RTP'
  prefs: []
  type: TYPE_NORMAL
- en: The traffic is a typical multimedia RTSP/RTP session between a client and an
    IP camera. The client starts by sending an `RTSP OPTIONS` request 1 to the camera.
    This request asks the server about the request types it will accept. The accepted
    types are then contained in the server’s `RTSP REPLY`2.``In this case, they’re
    `DESCRIBE`*,* `SETUP`*,* `TEARDOWN`*,* `PLAY`*,* `SET_PARAMETER`*,* `GET_PARAMETER`*,*
    and `PAUSE` (some readers might find these familiar from the VHS days), as shown
    in [Figure 15-8](#figure15-8).``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
