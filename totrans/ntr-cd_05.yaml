- en: '**4 Particle Systems**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4 粒子系统**'
- en: '*That is wise. Were I to invoke logic, however, logic clearly dictates that
    the needs of the many outweigh the needs of the few.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是明智的。然而，如果我引用逻辑，逻辑显然表明，众人的需求超过少数人的需求。*'
- en: —Spock
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —斯波克
- en: '![Image](../images/pg207_Image_299.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg207_Image_299.jpg)'
- en: '**Positron (photo by Carl D. Anderson)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**正电子（照片由卡尔·D·安德森提供）**'
- en: This early 20th-century photograph from a cloud chamber offers a glimpse into
    the world of subatomic particles, capturing the first ever observed positron.
    Cloud chambers are devices that make visible the paths of charged particles as
    they move through a supersaturated vapor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这张来自云室的20世纪初照片提供了对亚原子粒子世界的一个 glimpse，捕捉到了第一次观察到的正电子。云室是一种装置，能够使带电粒子在超饱和蒸气中移动时的路径变得可见。
- en: 'In 1982, Lucasfilm researcher William T. Reeves was working on *Star Trek II:
    The Wrath of Khan*. Much of the movie revolves around the Genesis Device, a torpedo
    that, when shot at a barren, lifeless planet, has the ability to reorganize matter
    and create a habitable world for colonization. During the sequence, a wall of
    fire ripples over the planet while it’s being “terraformed.” The term **particle
    system**, an incredibly common and useful technique in computer graphics, was
    coined in the creation of this particular effect. As Reeves put it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1982年，卢卡斯影业的研究员威廉·T·里维斯正在为《星际迷航II：可汗的愤怒》工作。电影的大部分情节围绕基因装置展开，这是一种鱼雷，当它被发射到一个荒芜、无生命的星球时，能够重新组织物质，创造一个适合殖民的宜居世界。在这个情节中，随着星球的“地球化”，一堵火墙波动覆盖了星球。**粒子系统**这一在计算机图形学中极其常见且有用的技术，正是在制作这个特效时诞生的。正如里维斯所说：
- en: '*A particle system is a collection of many, many minute particles that together
    represent a fuzzy object. Over a period of time, particles are generated into
    a system, move and change from within the system, and die from the system.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*粒子系统是许许多多微小粒子的集合，这些粒子共同代表一个模糊的物体。在一段时间内，粒子被生成到系统中，在系统内部移动和变化，并从系统中消亡。*'
- en: Since the early 1980s, particle systems have been used in countless video games,
    animations, digital art pieces, and installations to model various irregular types
    of natural phenomena, such as fire, smoke, waterfalls, fog, grass, bubbles, and
    so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自1980年代初以来，粒子系统已被广泛应用于无数视频游戏、动画、数字艺术作品和装置中，用于模拟各种不规则类型的自然现象，如火焰、烟雾、瀑布、雾气、草地、气泡等等。
- en: This chapter is dedicated to looking at strategies for coding a particle system
    and managing the associated data. How do you organize your code? Where do you
    store information related to individual particles versus information related to
    the system as a whole? The examples I’ll cover will use simple dots for the particles
    and apply only the most basic behaviors. However, these characteristics shouldn’t
    limit your imagination. Just because particle systems tend to look sparkly, fly
    forward, or fall with gravity doesn’t mean that yours should have those characteristics
    too. By building on this chapter’s framework and adding more creative ways to
    render the particles and compute their behavior, you can achieve a variety of
    effects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在探讨编码粒子系统和管理相关数据的策略。你如何组织代码？你将与单个粒子相关的信息和与整个系统相关的信息存储在哪里？我将介绍的示例将使用简单的点表示粒子，并只应用最基本的行为。然而，这些特性不应限制你的想象力。粒子系统通常看起来闪闪发光、向前飞行或在重力作用下下落，并不意味着你的系统也必须具备这些特征。通过在本章的框架基础上构建，并添加更多创意的方法来渲染粒子并计算它们的行为，你可以实现各种效果。
- en: In other words, the focus of this chapter is on *how* to keep track of a system
    of many elements. What those elements do and how they look is entirely up to you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，本章的重点是*如何*跟踪一个包含许多元素的系统。这些元素的行为和外观完全由你决定。
- en: '**Why Particle Systems Matter**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**粒子系统的重要性**'
- en: A particle system is a collection of independent objects, often represented
    by dots or other simple shapes. But why does this matter? Certainly, the prospect
    of modeling some of the phenomena listed (waterfalls!) is attractive and potentially
    useful. More broadly, though, as you start developing more sophisticated simulations,
    you’re likely to find yourself working with systems of *many* things—balls bouncing,
    birds flocking, ecosystems evolving, all sorts of things in plural. The particle
    system strategies discussed here will help you in all those situations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一组独立的对象，通常通过点或其他简单的形状来表示。但这有什么重要的呢？当然，模拟一些列出的现象（比如瀑布！）的前景非常吸引人，也可能有用。但更广泛地说，当你开始开发更复杂的模拟时，你很可能会遇到处理*许多*事物的情况——弹跳的球、聚集的鸟群、进化的生态系统，所有这些都是以复数形式出现的事物。这里讨论的粒子系统策略将帮助你应对所有这些情况。
- en: In fact, just about every chapter from this one on includes sketches incorporating
    lists of objects, and that’s basically what a particle system is. Yes, I’ve already
    dipped my toe in the array waters in some of the previous chapters’ examples.
    But now it’s time to go where no array has gone before (in this book, anyway).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，从这一章开始的每一章几乎都会包含使用对象列表的草图，而这基本上就是粒子系统的形式。是的，我已经在前面的一些章节示例中稍微接触过数组的使用。但现在是时候去探索那些数组未曾涉足的领域了（至少在本书中是如此）。
- en: 'First, I want to accommodate flexible quantities of elements. Some examples
    may have zero things, sometimes one thing, sometimes ten things, and sometimes
    ten thousand things. Second, I want to take a more sophisticated, object-oriented
    approach. In addition to writing a class to describe a single particle, I want
    to write a class that describes the whole collection of particles—the particle
    system itself. The goal here is to be able to write a sketch that looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想适应灵活数量的元素。有些示例可能没有任何物体，有时是一个物体，有时是十个物体，有时是万千物体。其次，我想采用一种更复杂的面向对象的方法。除了编写一个描述单个粒子的类，我还想编写一个描述整个粒子集合——即粒子系统本身——的类。这里的目标是能够写出如下的草图：
- en: '![Image](../images/pg209_Image_300.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg209_Image_300.jpg)'
- en: No single particle is referenced in this code, and yet the result will be full
    of particles flying all over the canvas. This works because the details are hidden
    inside the `ParticleSystem` class, which holds references to lots of instances
    of the `Particle` class. Getting used to this technique of writing sketches with
    multiple classes, including classes that keep lists of instances of other classes,
    will prove useful as you get to later chapters in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中没有引用单个粒子，但结果是画布上到处飞舞着粒子。这之所以能实现，是因为细节被隐藏在`ParticleSystem`类中，它持有对许多`Particle`类实例的引用。习惯于使用多类编写草图的这种技巧，包括那些保存其他类实例列表的类，在你进入本书后面的章节时将非常有用。
- en: 'Finally, working with particle systems is also an opportunity to tackle two
    other OOP techniques: inheritance and polymorphism. With the examples you’ve seen
    up until now, I’ve always used an array of a single type of object, like an array
    of movers or an array of oscillators. With inheritance and polymorphism, I’ll
    demonstrate a convenient way to use a single list to store objects of different
    types. This way, a particle system need not be a system of only one kind of particle.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理粒子系统也是一个解决其他两种面向对象编程技术的机会：继承和多态。到目前为止，你所看到的示例中，我总是使用单一类型对象的数组，比如`mover`数组或`oscillator`数组。通过继承和多态，我将展示一种方便的方法，使用单一列表来存储不同类型的对象。这样，粒子系统就不必是只有一种粒子的系统了。
- en: '**A Single Particle**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单个粒子**'
- en: 'Before I can get rolling on coding the particle system, I need to write a class
    to describe a single particle. The good news: I’ve done this already! The `Mover`
    class from [Chapter 2](ch02.xhtml#ch02) serves as the perfect template. A particle
    is an independent body that moves about the canvas, so just like a mover, it has
    `position`, `velocity`, and `acceleration` variables; a constructor to initialize
    those variables; and methods to `show()` itself and `update()` its position.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始编写粒子系统的代码之前，我需要写一个类来描述单个粒子。好消息是：我已经做过了！[第二章](ch02.xhtml#ch02)中的`Mover`类就是一个完美的模板。粒子是一个独立的物体，在画布上移动，因此就像一个`mover`一样，它有`position`、`velocity`和`acceleration`变量；一个构造函数来初始化这些变量；还有方法来`show()`自己和`update()`位置。
- en: '![Image](../images/pg210_Image_301.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_301.jpg)'
- en: 'This is about as simple as a particle can get. From here, I could take the
    particle in several directions. I could add the `applyForce()` method to affect
    the particle’s behavior (I’ll do precisely this in a future example). I could
    also add variables to describe color and shape, or load a `p5.Image` to draw the
    particle in a more interesting way. For now, however, I’ll focus on adding just
    one additional detail: **life span**.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是粒子最简单的形式。从这里开始，我可以将粒子引导到多个方向。我可以添加`applyForce()`方法来影响粒子的行为（我将在未来的示例中做这个）。我还可以添加描述颜色和形状的变量，或者加载`p5.Image`来以更有趣的方式绘制粒子。不过，目前我会专注于添加一个额外的细节：**生命周期**。
- en: 'Some particle systems involve an **emitter** that serves as the source of the
    particles. The emitter controls the initial settings for the particles: position,
    velocity, and more. It might emit a single burst of particles, a continuous stream
    of particles, or some variation thereof. The new feature here is that particles
    born at the emitter can’t live forever. If they did, the p5.js sketch would eventually
    grind to a halt as the particles add up to an unwieldy number over time. As new
    particles are born, old particles need to be removed, creating the illusion of
    an infinite stream of particles without hurting the performance of the sketch.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些粒子系统包含一个**发射器**，它作为粒子的源。发射器控制粒子的初始设置：位置、速度等。它可能会发射一批粒子、连续的粒子流，或者其他某种变化。这里的新特性是，发射器出生的粒子不能永远活着。如果它们能永生，那么p5.js的草图最终会因为粒子数目随时间增加而停滞不前。随着新粒子的诞生，旧粒子需要被移除，从而创造出一个粒子无限流动的假象，而不影响草图的性能。
- en: 'There are many ways to decide when a particle is ready to be removed. For example,
    it could “die” when it comes into contact with another object or when it leaves
    the frame of the canvas. For now, I’ll choose to give particles a `lifespan` variable
    that acts like a timer. It will start at 255 and count down to 0 as the sketch
    progresses, at which point the particle will be considered dead. Here’s the added
    code in the `Particle` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 决定粒子何时准备被移除有很多方法。例如，它可以在与另一个物体接触时“死亡”，或者当它离开画布的边框时“死亡”。目前，我选择给粒子一个`lifespan`变量，像一个计时器一样。它将从255开始，在草图进程中逐渐减小到0，到那时粒子就会被视为死亡。以下是`Particle`类中的新增代码：
- en: '![Image](../images/pg210_Image_302.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_302.jpg)'
- en: With `lifespan` ranging from 255 to 0, it can conveniently double as the alpha
    transparency for the circle representing the particle. This way, when the particle
    is dead, it will have literally faded away.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`lifespan`的范围从255到0，它还可以方便地充当表示粒子的圆形的透明度。这样，当粒子死亡时，它就会字面上消失。
- en: 'With the addition of the `lifespan` property, I’ll need one more method, one
    that can be queried (for a true or false answer) to determine whether the particle
    is alive or dead. This will come in handy when I write a separate class to manage
    the list of particles. Writing this method is pretty easy: I just need to check
    whether the value of `lifespan` is less than 0\. If it is, return `true`; otherwise,
    return `false`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`lifespan`属性的加入，我还需要一个方法，这个方法可以查询（返回真或假）以确定粒子是活着还是死了。当我编写一个单独的类来管理粒子列表时，这将派上用场。编写这个方法其实很简单：我只需要检查`lifespan`的值是否小于0。如果是，返回`true`；否则，返回`false`：
- en: '![Image](../images/pg211_Image_304.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg211_Image_304.jpg)'
- en: Even more simply, I can just return the result of the Boolean expression!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地说，我可以直接返回布尔表达式的结果！
- en: '![Image](../images/pg211_Image_305.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg211_Image_305.jpg)'
- en: 'Before I get to the next step of making many particles, it’s worth taking a
    moment to confirm that the particle works correctly. For that, I’ll create a sketch
    featuring a single `Particle` object at a time. Here’s the full code, with a few
    small additions: giving the particle a random initial velocity, as well as adding
    `applyForce()` to simulate gravity.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一步制作许多粒子之前，值得花点时间确认粒子是否能正确工作。为此，我将创建一个只包含单个`Particle`对象的草图。以下是完整代码，做了一些小改动：给粒子一个随机的初始速度，并添加`applyForce()`来模拟重力。
- en: '![Image](../images/pg212_Image_306.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg212_Image_306.jpg)'
- en: This example creates only one particle at a time for the sake of simplicity
    and testing. Each time the particle reaches the end of its life span, the `particle`
    variable is overwritten with a new instance of the `Particle` class. This effectively
    replaces the previous `Particle` object. It’s important to understand that the
    previous `Particle` object isn’t so much deleted as it is no longer accessible
    or used within the code. The sketch essentially forgets the old particle and starts
    anew with the freshly created one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例为了简化和测试，每次只创建一个粒子。每当粒子达到其生命周期的末尾时，`particle` 变量将被一个新的 `Particle` 类实例覆盖。这实际上是替换了先前的
    `Particle` 对象。需要理解的是，先前的 `Particle` 对象并没有被真正删除，而是变得无法访问或不再在代码中使用。这个草图实际上是忘记了旧的粒子，从新创建的粒子开始。
- en: '![Image](../images/pencil.jpg) **Exercise 4.1**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.1**'
- en: Create a `run()` method in the `Particle` class that handles `update()`, `show()`,
    and `applyForce()`. What are the pros and cons of this approach?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Particle` 类中创建一个 `run()` 方法，用于处理 `update()`、`show()` 和 `applyForce()`。这种方法的优缺点是什么？
- en: '![Image](../images/pencil.jpg) **Exercise 4.2**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.2**'
- en: Add angular velocity (rotation) to the particle, and design a particle that
    isn’t a circle so its rotation is visible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为粒子添加角速度（旋转），并设计一个不是圆形的粒子，使其旋转可见。
- en: '**An Array of Particles**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**粒子数组**'
- en: 'Now that I have a class to describe a single particle, it’s time for the next
    big step: How can I keep track of many particles, without knowing in advance exactly
    how many I might have at any given time? The answer is the JavaScript array, a
    data structure that stores an arbitrarily long list of values. In JavaScript,
    an array is actually an object created from the `Array` class, and so it comes
    with many built-in methods. These methods supply all the functionality I need
    for maintaining a list of `Particle` objects, including adding particles, removing
    particles, or otherwise manipulating them. For a refresher on arrays, see the
    JavaScript array documentation on the MDN Web Docs website (*[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)*).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经有了描述单个粒子的类，接下来是下一个大步骤：如何在不事先知道具体有多少粒子的情况下跟踪多个粒子？答案是 JavaScript 数组，这是一种存储任意长度值列表的数据结构。在
    JavaScript 中，数组实际上是从 `Array` 类创建的对象，因此它具有许多内建的方法。这些方法提供了我需要的所有功能，用于维护一个 `Particle`
    对象的列表，包括添加粒子、删除粒子或以其他方式操作它们。如需复习数组，请参阅 MDN Web Docs 网站上的 JavaScript 数组文档 (*[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)*).
- en: 'As I bring arrays into the picture, I’ll use a solution to [Exercise 4.1](ch04.xhtml#ch4exe1)
    and assume a `Particle.run()` method that manages all of an individual particle’s
    functionality. While this approach also has some cons, it will keep the subsequent
    code examples more concise. To begin, I’ll use a `for` loop in `setup()` to populate
    an array with particles, then use another `for` loop in `draw()` to run each particle:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我引入数组时，我将使用解决方案来处理 [练习 4.1](ch04.xhtml#ch4exe1)，并假设有一个 `Particle.run()` 方法来管理每个粒子所有的功能。虽然这种方法也有一些缺点，但它将使后续的代码示例更加简洁。首先，我将在
    `setup()` 中使用 `for` 循环来填充一个粒子数组，然后在 `draw()` 中使用另一个 `for` 循环来运行每个粒子：
- en: '![Image](../images/pg214_Image_308.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg214_Image_308.jpg)'
- en: The `for` loop in `draw()` demonstrates how to call a method on every element
    of an array by accessing each index. I initialize a variable `i` to `0` and increment
    it by `1`, accessing each element of the array until `i` hits `particles.length`
    and so reaches the end. As it happens, there are a few other ways to do the same
    thing. This is something that I both love and hate about coding in JavaScript—it
    has so many styles and options to consider. On the one hand, this makes JavaScript
    a highly flexible and adaptable language, but on the other hand, the abundance
    of choices can be overwhelming and lead to a lot of confusion when learning.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 中的 `for` 循环演示了如何通过访问每个索引来调用数组中每个元素的方法。我将变量 `i` 初始化为 `0`，并将其递增 `1`，访问数组的每个元素，直到
    `i` 达到 `particles.length` 并到达数组的末尾。实际上，还有其他几种方法可以实现相同的操作。这也是我既喜欢又讨厌使用 JavaScript
    编程的地方——它有如此多的风格和选项需要考虑。一方面，这使得 JavaScript 成为一种高度灵活且适应性强的语言，另一方面，选择的多样性可能令人不知所措，学习时可能会感到困惑。'
- en: 'Let’s take a ride on the loop-de-loop roller coaster of choices for iterating
    over an array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来体验一下用于遍历数组的循环选择过山车：
- en: The traditional `for` loop, as just demonstrated. This is probably what you’re
    most used to, and it follows a similar syntax as other programming languages like
    Java and C.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的`for`循环，如刚才所示。这可能是你最熟悉的，它的语法与其他编程语言（如Java和C）类似。
- en: The `for...in` loop. This kind of loop allows you to iterate over all the properties
    of an object. It’s not particularly useful for arrays, so I won’t cover it here.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for...in`循环。这种循环允许你遍历对象的所有属性。它对于数组并不是特别有用，所以在这里我不会详细介绍。'
- en: The `forEach()` loop. This is a great one, and I encourage you to explore it!
    It’s an example of a higher-order function, something I’ll explain later in this
    chapter.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`循环。这是一个很棒的循环，我鼓励你去探索它！它是一个高阶函数的例子，稍后我会在本章中解释高阶函数的概念。'
- en: The `for...of` loop. This is the technique I’ll expand upon next. It provides
    a clean and concise syntax compared to the traditional `for` loop when working
    with arrays of objects.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for...of`循环。这是我接下来将要详细扩展的技术。与传统的`for`循环相比，它在处理对象数组时提供了更简洁、清晰的语法。'
- en: 'Here’s how the `for...of` loop looks:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...of`循环的样子如下：'
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To translate this code, say *each* instead of *let*, and *in* instead of *of*.
    Putting it together, you get, “For each particle in particles, update and display
    that particle.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要翻译这段代码，应该用*each*代替*let*，用*in*代替*of*。合起来就是：“对于每个粒子在粒子数组中，更新并显示该粒子。”
- en: 'Simple, elegant, concise, lovely. But before you get too excited about `for...of`
    loops, take a moment and breathe, because I have some bad news: they won’t work
    in every situation. Yes, I love `for...of` loops, and I’ll use them in some of
    the upcoming examples to iterate over the items in an array, but not just yet.
    Ultimately, I want to create a continuous stream of particles, with one new particle
    added to the array each cycle through `draw()` and old particles removed from
    the array as they die. As you’ll soon see, this is where the `for...of` loop lets
    me down.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单、优雅、简洁、可爱。但是在你对`for...of`循环感到过于兴奋之前，请先稍作停顿，深呼吸，因为我有一个坏消息要告诉你：它们并不适用于所有情况。是的，我喜欢`for...of`循环，在接下来的示例中，我将使用它们来遍历数组中的项目，但现在还不行。最终，我希望创建一个连续的粒子流，每个循环通过`draw()`向数组中添加一个新粒子，并在粒子死亡时从数组中移除旧粒子。正如你很快会看到的，这正是`for...of`循环让我失望的地方。
- en: 'Creating a new particle every frame is easy: I can just call the `Array` class’s
    `push()` method during `draw()` to add a new `Particle` object to the end of the
    array. This eliminates the need to create any particles during `setup()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧创建一个新粒子非常简单：我只需在`draw()`中调用`Array`类的`push()`方法，将一个新的`Particle`对象添加到数组的末尾。这也避免了在`setup()`中创建任何粒子：
- en: '![Image](../images/pg215_Image_309.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg215_Image_309.jpg)'
- en: Run this code for a few minutes and you’ll start to see the frame rate slow
    further and further until the program grinds to a halt. (My tests yielded horrific
    performance after 15 minutes.) The issue, of course, is that I’m adding more and
    more particles without removing any.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码几分钟，你会发现帧率越来越慢，直到程序完全停滞。（我的测试在15分钟后表现出可怕的性能问题。）问题当然是，我没有移除任何粒子，只是在不断添加更多的粒子。
- en: 'To fix this, I can use the `splice()` method to get rid of particles as they
    die. It removes one or more elements from an array starting from a given index.
    And this is why I can’t use a `for...of` loop here; `splice()` needs a reference
    to the index of the particle being removed, but `for...of` loops don’t provide
    such a reference. I’m stuck using a regular `for` loop instead:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我可以使用`splice()`方法，在粒子死亡时将其从数组中移除。该方法从给定的索引开始，移除一个或多个元素。这就是我不能在这里使用`for...of`循环的原因；`splice()`需要一个指向正在被移除粒子索引的引用，而`for...of`循环并没有提供这种引用。所以，我只能改用常规的`for`循环：
- en: '![Image](../images/pg216_Image_311.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg216_Image_311.jpg)'
- en: 'Although this code will run just fine and never grind to a halt, I’ve opened
    up a medium-sized can of worms by trying to manipulate the contents of an array
    while iterating through that very same array. This is just asking for trouble.
    Take, for example, the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码能够正常运行，并且永远不会停止，但是我通过尝试在遍历数组时操作数组内容，打开了一个中等大小的“麻烦盒子”。这无疑是在自找麻烦。例如，看看以下代码：
- en: '![Image](../images/pg216_Image_312.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg216_Image_312.jpg)'
- en: This is a somewhat extreme scenario (with flawed logic), but it proves the point.
    For each particle in the list, this code adds a new particle to the list, and
    so the `length` of the array increases. This will result in an infinite loop,
    as I can never increment past the size of the array!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有些极端的场景（逻辑存在缺陷），但它证明了这个问题。对于列表中的每个粒子，这段代码都会向列表中添加一个新的粒子，从而导致数组的 `length`
    增加。这将导致一个无限循环，因为我永远无法超过数组的大小！
- en: 'While removing elements from the array during a loop doesn’t cause the sketch
    to crash (as it would with adding), the problem is perhaps more insidious in that
    it leaves no evidence. To discover the flaw, I must first establish an important
    fact: when an element is removed from an array with `splice()`, all subsequent
    elements are shifted to the left. [Figure 4.1](ch04.xhtml#ch4fig1) shows what
    happens when particle C (index 2) is removed. Particles A and B keep the same
    index, while particles D and E shift from 3 and 4 to 2 and 3, respectively.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在循环中从数组中移除元素并不会导致程序崩溃（就像添加元素时会崩溃一样），但问题可能更为隐蔽，因为它没有留下任何证据。为了发现这个缺陷，我必须先确定一个重要事实：当通过
    `splice()` 从数组中删除一个元素时，所有后续元素都会向左移动。[图 4.1](ch04.xhtml#ch4fig1) 展示了当粒子 C（索引 2）被移除时发生的情况。粒子
    A 和 B 保持相同的索引，而粒子 D 和 E 则分别从位置 3 和 4 移动到位置 2 和 3。
- en: '![Image](../images/pg217_Image_313.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg217_Image_313.jpg)'
- en: 'Figure 4.1: When an element is removed from an array, the subsequent elements
    shift to the left to fill the empty spot.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：当从数组中移除一个元素时，后续元素会向左移动以填补空缺。
- en: 'Consider what happens as counter `i` iterates over the elements of this array:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下当计数器 `i` 遍历数组中的元素时会发生什么：
- en: '| i | **Particle** | **Action** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| i | **粒子** | **操作** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Particle A | Don’t delete! |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 粒子 A | 不删除！ |'
- en: '| 1 | Particle B | Don’t delete! |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 粒子 B | 不删除！ |'
- en: '| 2 | Particle C | Delete! Slide particles D and E over from slots 3 and 4
    to 2 and 3. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 粒子 C | 删除！将粒子 D 和 E 从位置 3 和 4 移动到位置 2 和 3。 |'
- en: '| 3 | Particle E | Don’t delete! |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 粒子 E | 不删除！ |'
- en: Notice the problem? Particle D is never checked! When C is deleted from slot
    2, D moves into slot 2 in its place, but `i` has already moved on to slot 3\.
    In practice, this may not be a total disaster, since particle D will get checked
    the next time around through `draw()`. Still, the expectation is that the code
    should iterate through every single element of the array. Skipping an element
    is unacceptable!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到问题了吗？粒子 D 从未被检查！当 C 从位置 2 被删除时，D 移动到位置 2 代替它，但 `i` 已经移动到位置 3。实际上，这可能不会导致灾难性后果，因为粒子
    D 会在下一次通过 `draw()` 时被检查。不过，期望是代码应该遍历数组中的每一个元素，跳过一个元素是不可接受的！
- en: 'This problem has two solutions. The first is to iterate through the array backward.
    Since elements slide from right to left as other elements are removed, skipping
    an element becomes impossible. Here’s how the code looks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两种解决方案。第一种是反向遍历数组。由于当其他元素被移除时，元素会从右到左滑动，因此跳过元素变得不可能。以下是代码的写法：
- en: '![Image](../images/pg217_Image_314.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg217_Image_314.jpg)'
- en: A second solution is to use a **higher-order function**. This is a function
    that receives another function as an argument (or provides a function as its return
    value). JavaScript arrays use many higher-order functions. For example, a common
    one is `sort()`, which takes as its argument a function that defines how to compare
    two elements of the array and then sorts the array according to that comparison.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是使用**高阶函数**。这是一种接受另一个函数作为参数（或将一个函数作为返回值）的函数。JavaScript 数组使用了许多高阶函数。例如，一个常见的高阶函数是
    `sort()`，它接受一个定义如何比较数组中两个元素的函数作为参数，然后根据该比较对数组进行排序。
- en: 'With the array of particles, I can use `filter()`. This higher-order function
    takes a function specifying some kind of condition as an argument, checks each
    item in an array for that condition, and returns only the item(s) for which the
    given condition is true (excluding those items that return false):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于粒子数组，我可以使用 `filter()`。这个高阶函数接受一个指定某种条件的函数作为参数，检查数组中的每个项目是否符合该条件，并返回符合条件的项目（排除那些返回
    false 的项目）：
- en: '![Image](../images/pg218_Image_315.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg218_Image_315.jpg)'
- en: This is more commonly written using JavaScript’s arrow notation. To learn more,
    you can watch my Coding Train tutorial on higher-order functions and arrow notation
    (*[https://thecodingtrain.com/hof](https://thecodingtrain.com/hof)*).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通常使用 JavaScript 的箭头函数语法来书写。要了解更多，你可以观看我关于高阶函数和箭头函数语法的 Coding Train 教程（*[https://thecodingtrain.com/hof](https://thecodingtrain.com/hof)*）。
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the purposes of this book, I’m going to stick with the `splice()` method,
    but I encourage you to explore writing your code with higher-order functions and
    arrow notation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书而言，我将继续使用`splice()`方法，但我鼓励你探索使用高阶函数和箭头表示法编写代码。
- en: '![Image](../images/pg218_Image_316.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg218_Image_316.jpg)'
- en: You might be wondering why, instead of checking each particle individually,
    I don’t just remove the oldest particle after a certain period of time (determined
    by checking the `frameCount` or array length). In this example, where the particles
    die in the same order in which they’re born, that approach would actually work.
    I could even use a different array method called `shift()`, which automatically
    removes the first element of an array. However, in many particle systems, other
    conditions or interactions may cause “younger” particles to die sooner than “older”
    particles. Checking `isDead()` in combination with `splice()` is a nice, comprehensive
    solution that offers flexibility in managing particles across a variety of scenarios.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我不在检查每个粒子时单独处理，而是在一定时间后（通过检查`frameCount`或数组长度来确定）直接移除最旧的粒子。在这个示例中，粒子以与出生顺序相同的顺序死亡，这种方法实际上是有效的。我甚至可以使用一个名为`shift()`的数组方法，它会自动移除数组中的第一个元素。然而，在许多粒子系统中，其他条件或相互作用可能导致“年轻”的粒子比“老”的粒子更早死亡。结合使用`isDead()`和`splice()`是一个很好的综合解决方案，它在各种场景下提供了管理粒子的灵活性。
- en: '**A Particle Emitter**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**粒子发射器**'
- en: 'I’ve conquered the array and used it to manage a list of `Particle` objects,
    with the ability to add and delete particles at will. I could stop here and rest
    on my laurels, but I can and should take an additional step: writing a class describing
    the list of `Particle` objects itself. At the start of this chapter, I used a
    speculative class name `ParticleSystem` to represent the overall collection of
    particles. However, a more fitting term for the functionality of emitting particles
    is `Emitter`, which I’ll use from now on.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经征服了数组，并用它来管理一个`Particle`对象的列表，能够随意地添加和删除粒子。我本可以在这里停下，满足于现状，但我可以并且应该采取进一步的步骤：编写一个类来描述`Particle`对象的列表。在本章开始时，我使用了一个假设性的类名`ParticleSystem`来表示粒子的总体集合。然而，描述粒子发射功能的更合适术语是`Emitter`，从现在起我将使用这个名称。
- en: The `Emitter` class will allow me to clean up the `draw()` function, removing
    the bulky logic of looping through all the particles. As an added bonus, it will
    also open up the possibility of having multiple particle emitters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`类将使我能够简化`draw()`函数，移除循环遍历所有粒子的庞大逻辑。作为额外的好处，它还将为拥有多个粒子发射器提供可能性。'
- en: Recall that one of the goals I set at the beginning of this chapter was to write
    `setup()` and `draw()` without referencing any individual particles. In laying
    out that goal, I teased the possibility of a beautifully simple main sketch file.
    Here it is again, only now with the `Emitter` naming convention.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我在本章开始时设定的目标之一是编写`setup()`和`draw()`函数时不引用任何单独的粒子。在设定这个目标时，我曾暗示了主草图文件可能变得简单美观的可能性。现在，它已经变成了这个样子，只不过现在采用了`Emitter`的命名惯例。
- en: '![Image](../images/pg220_Image_318.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg220_Image_318.jpg)'
- en: 'To get to this point, look at each piece of `setup()` and `draw()` from [Example
    4.2](ch04.xhtml#ch4ex2) and think about how it can fit into the `Emitter` class
    instead. Nothing about the behavior of the code should change—the only difference
    is how it’s organized:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这一点，查看[示例 4.2](ch04.xhtml#ch4ex2)中`setup()`和`draw()`的每个部分，思考它们如何更适合放入`Emitter`类中。代码行为不应该发生任何变化——唯一的区别是它的组织方式：
- en: '| **Array in** setup() **and** draw() | **Array in the** Emitter **Class**
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **setup() 和 draw() 中的数组** | **Emitter 类中的数组** |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: I could also add new features to the particle system itself. For example, it
    might be useful for the `Emitter` class to keep track of an origin point where
    particles are born. The origin point could be initialized in the constructor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以为粒子系统本身添加新特性。例如，`Emitter`类可能会跟踪一个粒子出生的原点。这个原点可以在构造函数中初始化。
- en: '![Image](../images/pg221_Image_319.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg221_Image_319.jpg)'
- en: 'The example emitter is a static source of particles, which is a nice way to
    begin working with particle systems. However, that’s not how it has to be. The
    emitter could have its own behaviors: experiencing physics, oscillating, reacting
    to user input, or exhibiting any other kind of motion demonstrated in previous
    chapters. The particles could then emanate from various positions over time, creating
    trails or other, more complex and intriguing patterns.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例发射器是一个静态的粒子源，这是开始处理粒子系统的一个不错的方式。然而，事情不必总是这样。发射器可以有自己的行为：经历物理变化、振荡、响应用户输入，或者表现出前几章中展示的任何其他类型的运动。然后，粒子可以从不同的位置发射，随着时间的推移形成轨迹或其他更复杂、更有趣的图案。
- en: '![Image](../images/pencil.jpg) **Exercise 4.3**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.3**'
- en: What if the emitter moves? Can you emit particles from the mouse position, or
    use the concepts of velocity and acceleration to move the system autonomously?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发射器移动怎么办？你能从鼠标位置发射粒子，或者利用速度和加速度的概念让系统自主移动吗？
- en: '![Image](../images/pencil.jpg) **Exercise 4.4**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.4**'
- en: Building off [Chapter 3](ch03.xhtml#ch03)’s *Asteroids* example, use a particle
    system to emit particles from the ship’s thrusters whenever a thrust force is
    applied. The particles’ initial velocity should be related to the ship’s current
    direction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第 3 章](ch03.xhtml#ch03)的*小行星*示例，使用粒子系统从飞船的推进器中发射粒子，每当施加推力时。粒子的初始速度应与飞船的当前方向相关。
- en: '**A System of Emitters**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**发射器系统**'
- en: 'So far, I’ve described an individual particle and organized its code into a
    `Particle` class. I’ve also described a system of particles and organized the
    code into an `Emitter` class. This particle system is nothing more than a collection
    of independent `Particle` objects. But as an instance of the `Emitter` class,
    isn’t a particle system itself an object? If that’s the case (and it is), there’s
    no reason I couldn’t also build a collection of many particle emitters: a system
    of systems!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我描述了一个单独的粒子，并将其代码组织到一个`Particle`类中。我还描述了一个粒子系统，并将其代码组织到一个`Emitter`类中。这个粒子系统不过是一个独立的`Particle`对象的集合。但作为`Emitter`类的实例，粒子系统不也是一个对象吗？如果是这样（而且确实如此），那就没有理由我不能再构建一个包含多个粒子发射器的集合：一个系统的系统！
- en: 'I could take this line of thinking even further, locking myself in a basement
    for days and sketching out a diagram of a system of systems of systems of systems
    of systems of systems . . . until I get this whole system thing out of my, well,
    system. After all, I could describe the world in a similar way: an organ is a
    system of cells, a human body is a system of organs, a neighborhood is a system
    of human bodies, a city is a system of neighborhoods, and so on and so forth.
    I’m not ready to go quite that far just yet, but it would still be useful to look
    at how to write a sketch that keeps track of many particle systems, each of which
    keeps track of many particles.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以进一步思考，甚至把自己锁在地下室里几天，画出一个系统的系统的系统的系统的系统的系统的图……直到我把这整个系统的概念从我的系统中“清除”出去。毕竟，我可以用类似的方式描述这个世界：一个器官是由细胞组成的系统，一个人体是由器官组成的系统，一个社区是由人体组成的系统，一个城市是由社区组成的系统，依此类推。虽然我还没准备好做得那么深入，但仍然有必要看看如何编写一个可以追踪多个粒子系统的草图，而每个粒子系统又可以追踪多个粒子。
- en: 'Consider this scenario: you start with a blank screen ([Figure 4.2](ch04.xhtml#ch4fig2)).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：你从一个空白的屏幕开始（[图 4.2](ch04.xhtml#ch4fig2)）。
- en: '![Image](../images/pg222_Image_320.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg222_Image_320.jpg)'
- en: 'Figure 4.2: Starting with a blank screen'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：从空白屏幕开始
- en: You click the mouse and generate a particle system at the mouse’s position ([Figure
    4.3](ch04.xhtml#ch4fig3)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你点击鼠标，并在鼠标位置生成一个粒子系统（[图 4.3](ch04.xhtml#ch4fig3)）。
- en: '![Image](../images/pg223_Image_321.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg223_Image_321.jpg)'
- en: 'Figure 4.3: Adding a particle system'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：添加粒子系统
- en: You keep clicking the mouse. Each time, another particle system springs up where
    you clicked ([Figure 4.4](ch04.xhtml#ch4fig4)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你不断点击鼠标。每次点击，都会在你点击的位置弹出另一个粒子系统（[图 4.4](ch04.xhtml#ch4fig4)）。
- en: '![Image](../images/pg223_Image_322.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg223_Image_322.jpg)'
- en: 'Figure 4.4: Adding more particle systems'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：添加更多粒子系统
- en: 'How to do this? In [Example 4.3](ch04.xhtml#ch4ex3), I stored a single reference
    to an `Emitter` object in the variable `emitter`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点？在[示例 4.3](ch04.xhtml#ch4ex3)中，我将一个`Emitter`对象的引用存储在变量`emitter`中：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now I’ll call the variable `emitters`, plural, and make it an array so I can
    keep track of multiple `Emitter` objects. When the sketch begins, the array is
    empty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将变量命名为`emitters`（复数），并将其设为数组，以便跟踪多个`Emitter`对象。草图开始时，数组为空。
- en: '![Image](../images/pg224_Image_323.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg224_Image_323.jpg)'
- en: 'Whenever the mouse is clicked, a new `Emitter` object is created and placed
    into the array:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每当鼠标点击时，一个新的`Emitter`对象被创建并放入数组中：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, in `draw()`, instead of referencing a single `Emitter` object, I now
    iterate over all the emitters and call `run()` on each of them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`draw()`中，我不再引用单个`Emitter`对象，而是遍历所有的发射器，并对每个发射器调用`run()`：
- en: '![Image](../images/pg224_Image_324.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg224_Image_324.jpg)'
- en: Notice that I’m back to using a `for...of` loop since no elements are being
    removed from the `emitters` array.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我又回到使用`for...of`循环，因为没有元素从`emitters`数组中被移除。
- en: '![Image](../images/pencil.jpg) **Exercise 4.5**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.5**'
- en: Rewrite [Example 4.4](ch04.xhtml#ch4ex4) so each particle system doesn’t live
    forever. Set a limit on the number of particles an individual system can generate.
    Then, when a particle system is empty (has no particles left), remove it from
    the `emitters` array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重写[示例 4.4](ch04.xhtml#ch4ex4)，使每个粒子系统不会永远存在。为每个粒子系统生成的粒子数量设置限制。然后，当一个粒子系统为空（没有剩余粒子）时，从`emitters`数组中移除它。
- en: '![Image](../images/pencil.jpg) **Exercise 4.6**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.6**'
- en: Create a simulation of an object shattering into many pieces. How can you turn
    one large shape into many small particles? Can you create several large shapes
    on the screen that each shatter when clicked?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个物体破碎成许多碎片的模拟。你如何将一个大形状转化为许多小粒子？你能否在屏幕上创建几个大形状，每个形状在被点击时都会破碎？
- en: '**Inheritance and Polymorphism**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**继承和多态**'
- en: Up to now, all the particles in my systems have been identical, with the same
    basic appearance and behaviors. Who says this has to be the case? By harnessing
    two fundamental OOP principles, inheritance and polymorphism, I can create particle
    systems with significantly more variety and interest.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我的系统中的所有粒子都是相同的，具有相同的基本外观和行为。谁说一定要这样呢？通过利用两个基本的面向对象编程（OOP）原则——继承和多态，我可以创建具有更多种类和趣味的粒子系统。
- en: Perhaps you’ve encountered these two terms in your programming life before this
    book. For example, my beginner text, *Learning Processing*, has close to an entire
    chapter (Chapter 22) dedicated to them. Still, perhaps you’ve learned about inheritance
    and polymorphism only in the abstract and never had a reason to really use them.
    If that’s true, you’ve come to the right place. Without these techniques, your
    ability to program diverse particles and particle systems is extremely limited.
    (In [Chapter 6](ch06.xhtml#ch06), I’ll also demonstrate how understanding these
    topics will help you use physics libraries.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在你编程的过程中，已经遇到过这两个术语。例如，我的初学者书籍《学习处理》（*Learning Processing*）中有近一整章（第22章）专门讲解这两个概念。不过，也许你只是抽象地了解过继承和多态，但从未有机会真正应用它们。如果是这样，你来对地方了。没有这些技术，你编程多样粒子和粒子系统的能力会非常有限。（在[第6章](ch06.xhtml#ch06)中，我还会演示如何理解这些概念能够帮助你使用物理库。）
- en: Imagine it’s a Saturday morning. You’ve just gone out for a lovely jog, had
    a delicious bowl of cereal, and are sitting quietly at your computer with a cup
    of warm chamomile tea. It’s your old friend so-and-so’s birthday, and you’ve decided
    you’d like to make a greeting card with p5.js. How about simulating some confetti?
    Purple confetti, pink confetti, star-shaped confetti, square confetti, fast confetti,
    fluttery confetti—all kinds of confetti, all with different appearances and different
    behaviors, exploding onto the screen all at once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这是一个周六早晨。你刚刚去跑步，享受了一碗美味的麦片，正在电脑前安静地坐着，手里拿着一杯温暖的洋甘菊茶。今天是你老朋友某某的生日，你决定用p5.js做一张贺卡。怎么样，模拟一下五彩纸屑？紫色纸屑、粉色纸屑、星形纸屑、方形纸屑、快速飘落的纸屑、轻盈飘动的纸屑——各种各样的纸屑，各有不同的外观和行为，全部在屏幕上同时爆发出来。
- en: 'What you have is clearly a particle system: a collection of individual pieces
    (particles) of confetti. You might be able to cleverly redesign the `Particle`
    class to have variables that store color, shape, behavior, and more. To create
    a variety of particles, you might initialize those variables with random values.
    But what if some of your particles are drastically different? It could become
    very messy to have all sorts of code for different ways of being a particle in
    the same class. Another option might be to do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到的显然是一个粒子系统：由多个单独的片段（粒子）组成的彩纸。你可能会聪明地重新设计`Particle`类，使用变量来存储颜色、形状、行为等。为了创建各种粒子，你可能会用随机值初始化这些变量。但如果某些粒子差异非常大呢？如果把各种不同的粒子行为都放在同一个类中，代码会变得非常凌乱。另一种选择可能是这样做：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a nice solution: create three classes to describe the different kinds
    of confetti that are part of your particle system. The `Emitter` constructor could
    then have some code to pick randomly from the three classes when filling the array
    (note that this probabilistic method is the same one I employed in the random
    walk examples in [Chapter 0](ch00.xhtml#ch00)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的解决方案：创建三个类来描述你的粒子系统中不同种类的彩纸。然后，`Emitter`构造函数可以包含一些代码，在填充数组时从这三个类中随机选择（注意，这种概率方法与我在[第0章](ch00.xhtml#ch00)中的随机漫步示例中使用的相同）：
- en: '![Image](../images/pg226_Image_326.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg226_Image_326.jpg)'
- en: 'Let me pause for a moment. You’ve done nothing wrong. All you wanted to do
    was wish your friend a happy birthday and enjoy writing some code. But while the
    reasoning behind this approach is quite sound, there’s a problem: Aren’t you going
    to be copying and pasting a lot of code between the confetti classes?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我稍作停顿。你没有做错什么。你只不过是想祝朋友生日快乐，并享受编写代码的乐趣。但尽管这种方法的思路是合理的，还是存在一个问题：你不是要在各个彩纸类之间复制和粘贴大量代码吗？
- en: Yes, you probably will. Even though the kinds of particles are different enough
    to merit breaking them into separate classes, they’ll likely share a ton of code.
    For example, they’ll all have vectors to keep track of position, velocity, and
    acceleration; an `update()` function that implements the motion algorithm; and
    more.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可能会这样想。即使粒子的种类足够不同，值得将它们分开成不同的类，它们很可能会共享大量的代码。例如，它们都会有向量来跟踪位置、速度和加速度；一个实现运动算法的`update()`函数；等等。
- en: This is where **inheritance** comes in. Inheritance allows you to write a class
    that takes on (*inherits*) variables and methods from another class, while also
    implementing its own custom features. You might also be wondering whether adding
    all those types of confetti to a single `particles` array actually works. After
    all, I don’t typically mix different kinds of objects in one array, as it could
    get confusing. How will the code in the `Emitter` class know which particle is
    which kind of confetti? Wouldn’t separate arrays be easier to manage?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**继承**的作用。继承让你能够编写一个类，从另一个类中(*继承*)变量和方法，同时也实现自己的定制功能。你可能还会想知道，把所有这些类型的彩纸放进一个`particles`数组中是否真的可行。毕竟，我通常不会把不同种类的对象放在同一个数组中，因为这可能会让人感到困惑。`Emitter`类中的代码如何知道哪个粒子是哪种彩纸呢？分开数组不更容易管理吗？
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In fact, separating the particles into different arrays is inconvenient; a single
    array for all the particles in the system would be far more practical. Fortunately,
    the ability to mix objects of different types in one array is an inherent feature
    of JavaScript, and **polymorphism** allows the mixed objects to be operated on
    as if they were of the same type. I can populate an array with different kinds
    of particles, and each particle will still maintain its unique behaviors and characteristics
    as defined in its respective class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，将粒子分成不同的数组并不方便；一个包含所有粒子的单一数组要实用得多。幸运的是，JavaScript具有将不同类型的对象混合在一个数组中的能力，而**多态性**使得这些混合的对象可以像同一种类型的对象一样进行操作。我可以用不同类型的粒子填充一个数组，每个粒子仍然会保持它在各自类中定义的独特行为和特征。
- en: In this section, I’ll illustrate inheritance and polymorphism in more detail,
    and then I’ll create a particle system that incorporates these concepts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我将更详细地说明继承和多态的概念，然后我会创建一个结合这些概念的粒子系统。
- en: '**Inheritance Basics**'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**继承基础**'
- en: 'To demonstrate how inheritance works, I’ll take an example from the world of
    animals: dogs, cats, monkeys, pandas, wombats, sea nettles, you name it. I’ll
    start by coding a `Dog` class. A `Dog` object will have an `age` variable (an
    integer), as well as `eat()`, `sleep()`, and `bark()` methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示继承是如何工作的，我将以动物世界中的一个例子为例：狗、猫、猴子、熊猫、袋熊、海蜇等等。我将从编写一个`Dog`类开始。一个`Dog`对象将拥有一个`age`变量（一个整数），以及`eat()`、`sleep()`和`bark()`方法：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now I’ll make a cat:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我来创建一只猫：
- en: '![Image](../images/pg228_Image_327.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg228_Image_327.jpg)'
- en: 'As I move on to rewriting the same code for fish, horses, koalas, and lemurs,
    this process will become rather tedious. A better solution is to develop a generic
    `Animal` class that can describe any type of animal. All animals eat and sleep,
    after all. I could then say this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我继续为鱼、马、考拉和狐猴编写相同的代码时，这个过程会变得相当繁琐。一个更好的解决方案是开发一个通用的`Animal`类，可以描述任何类型的动物。毕竟，所有动物都会吃和睡。我可以这样写：
- en: A dog is an animal and has all the properties of animals and can do all the
    things animals do. Also, a dog can bark.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只狗是动物，并且拥有所有动物的属性，可以做所有动物能做的事情。此外，狗还可以叫。
- en: A cat is an animal and has all the properties of animals and can do all the
    things animals do. Also, a cat can meow.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只猫是动物，并且拥有所有动物的属性，可以做所有动物能做的事情。此外，猫还可以喵喵叫。
- en: 'Inheritance makes this possible, allowing `Dog` and `Cat` to be designated
    as children (**subclasses**) of the `Animal` class. Children automatically inherit
    all variables and methods from the parent (**superclass**), but they can also
    include methods and variables not found in the parent. Like a phylogenetic tree
    of life, inheritance follows a tree structure (see [Figure 4.5](ch04.xhtml#ch4fig5)):
    dogs inherit from mammals, which inherit from animals, and so on.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使这一切成为可能，允许`Dog`和`Cat`被指定为`Animal`类的子类（**子类**）。子类自动继承父类（**超类**）的所有变量和方法，但它们也可以包含父类中没有的方法和变量。像生命的系统发育树一样，继承遵循树状结构（见[图4.5](ch04.xhtml#ch4fig5)）：狗继承自哺乳动物，哺乳动物继承自动物，依此类推。
- en: '![Image](../images/pg229_Image_328.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg229_Image_328.jpg)'
- en: 'Figure 4.5: An inheritance tree'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：继承树
- en: 'Here’s how the syntax of inheritance works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是继承语法如何工作的：
- en: '![Image](../images/pg229_Image_329.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg229_Image_329.jpg)'
- en: This code uses two new JavaScript features. First, notice the `extends` keyword,
    which specifies a parent for the class being defined. A subclass can extend only
    one superclass. However, classes can extend classes that extend other classes;
    for example, `Dog extends Animal`, `Terrier extends Dog`. Everything is inherited
    all the way down the line from `Animal` to `Terrier`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了两个新的 JavaScript 特性。首先，注意到`extends`关键字，它指定了类的父类。一个子类只能继承一个父类。然而，类可以继承继承其他类的类；例如，`Dog
    extends Animal`，`Terrier extends Dog`。从`Animal`到`Terrier`，一切都被继承下来。
- en: Second, notice the call to `super()` in the `Dog` and `Cat` constructors. This
    calls the constructor in the parent class. In other words, whatever you do in
    the parent constructor, do so in the child constructor as well. In this case,
    it isn’t necessary, but `super()` can also receive arguments if a parent constructor
    is defined that takes matching arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注意在`Dog`和`Cat`构造函数中调用了`super()`。这会调用父类中的构造函数。换句话说，无论你在父类构造函数中做了什么，都要在子类构造函数中做同样的事。在这种情况下，这并不是必要的，但如果父类构造函数定义了需要匹配参数的构造函数，`super()`也可以接收参数。
- en: 'You can expand a subclass to include additional methods beyond those contained
    in the superclass. Here I’ve added the `bark()` method to `Dog` and the `meow()`
    method to `Cat`. You can also include additional code, besides the call to `super()`,
    in a subclass’s constructor to give that subclass extra variables. For example,
    let’s assume that in addition to `age`, a `Dog` object should have a `haircolor`
    variable. The class would now look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展一个子类，包含超类中没有的额外方法。在这里，我为`Dog`类添加了`bark()`方法，为`Cat`类添加了`meow()`方法。你还可以在子类的构造函数中，除了调用`super()`，添加额外的代码，以给该子类添加额外的变量。例如，假设除了`age`之外，一个`Dog`对象还应该有一个`haircolor`变量。这个类现在会像这样：
- en: '![Image](../images/pg230_Image_331.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg230_Image_331.jpg)'
- en: Note that the parent constructor is first called via `super()`, which sets `age`
    to `0`, and then `haircolor` is set inside the `Dog` constructor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，父类构造函数首先通过`super()`调用，这会将`age`设置为`0`，然后在`Dog`构造函数中设置`haircolor`。
- en: 'If a `Dog` object eats differently than a generic `Animal` object, the parent
    method can be *overridden* by creating a different definition for the method inside
    the subclass:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg231_Image_332.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'But what if a dog eats mostly the same way as a generic animal, just with some
    extra functionality? A subclass can both run the code from its parent class’s
    method and incorporate custom code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg231_Image_333.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Similar to calling `super()` in the constructor, calling `super.eat()` inside
    the `Dog` class’s `eat()` method results in calling the `Animal` class’s `eat()`
    method. Then the subclass’s method definition can continue with any additional,
    custom code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymorphism Basics**'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve used inheritance to create a bunch of animal subclasses. Now try to
    imagine how your code would manage this diverse animal kingdom with dogs, cats,
    turtles, and kiwis all frolicking about:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg232_Image_334.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'As the day begins, the animals are all pretty hungry and looking to eat. It’s
    (enhanced!) looping time:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg232_Image_335.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: This works, but as the world expands to include many more animal species, you’ll
    be stuck writing a lot of individual loops. Is this really necessary? After all,
    the creatures are all animals, and they all like to eat. Why not have just one
    array and fill it with all kinds of animals?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg233_Image_336.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: This is polymorphism (from the Greek *polymorphos*, meaning “many forms”) in
    action. Although all the animals are grouped together in an array and processed
    in a single `for` loop, JavaScript can identify their true types and invoke the
    appropriate `eat()` method for each one. It’s that simple!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Particles with Inheritance and Polymorphism**'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that I’ve covered the theory and syntax behind inheritance and polymorphism,
    I’m ready to write a working example of them in p5.js, based on my `Particle`
    class. First, take another look at a basic `Particle` implementation, adapted
    from [Example 4.1](ch04.xhtml#ch4ex1):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The class has variables and methods that any participant in a particle system
    should have. Next, I’ll create a `Confetti` subclass that extends `Particle`.
    It will use `super()` to execute the code from the parent class’s constructor
    and will inherit most of the `Particle` class’s methods as well. However, I’ll
    give `Confetti` its own `show()` method, overriding that of its parent, so `Confetti`
    objects will be drawn as squares rather than circles:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg234_Image_337.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Let’s make this a bit more sophisticated. Say I want to have each `Confetti`
    particle rotate as it flies through the air. One option is to model angular velocity
    and acceleration, as described in [Chapter 3](ch03.xhtml#ch03). For ease, however,
    I’ll implement something less formal.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'I know a particle has an x-position somewhere between 0 and the width of the
    canvas. What if I said that when the particle’s x-position is 0, its rotation
    should be 0; when its x-position is equal to the width, its rotation should be
    equal to 4π? Does this ring a bell? As discussed in [Chapter 0](ch00.xhtml#ch00),
    whenever a value has one range that you want to map to another range, you can
    use the `map()` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道一个粒子的x坐标在0到画布宽度之间。那么，如果我说，当粒子的x坐标为0时，它的旋转角度应该是0；当它的x坐标等于宽度时，它的旋转角度应该是4π呢？这听起来熟悉吗？正如在[第0章](ch00.xhtml#ch00)中讨论的那样，当你需要将一个范围的值映射到另一个范围时，可以使用`map()`函数：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s how this code fits into the `show()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这段代码如何融入到`show()`方法中的：
- en: '![Image](../images/pg235_Image_339.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg235_Image_339.jpg)'
- en: The choice of 4π might seem arbitrary, but it’s intentional—two full rotations
    add a significant degree of spin to the particle compared to just one.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 选择4π可能看起来有些任意，但其实是故意为之——两次完整的旋转相较于一次旋转能给粒子带来更强的旋转效果。
- en: '![Image](../images/pencil.jpg) **Exercise 4.7**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.7**'
- en: Instead of using `map()` to calculate `angle`, try modeling angular velocity
    and acceleration.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`map()`来计算`angle`，尝试建模角速度和加速度。
- en: Now that I have a `Confetti` subclass that extends the base `Particle` class,
    the next step is to also add `Confetti` objects to the array of particles defined
    in the `Emitter` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经有了一个扩展自基础`Particle`类的`Confetti`子类，接下来的步骤是将`Confetti`对象添加到`Emitter`类中定义的粒子数组里。
- en: '![Image](../images/pg236_Image_340.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg236_Image_340.jpg)'
- en: Can you spot how this example is also taking advantage of polymorphism? It’s
    what allows the `Particle` and `Confetti` objects to commingle in the same `particles`
    array within the `Emitter` class. Thanks to the inheritance relationship, both
    can be considered the same type, `Particle`, and it’s safe to iterate through
    the array and call methods like `run()` and `isDead()` on each object. Together,
    inheritance and polymorphism enable a variety of particle types to be managed
    together in the one array, regardless of their original class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个例子是如何利用多态性的吗？正是它让`Particle`和`Confetti`对象可以在`Emitter`类中的同一个`particles`数组里混合。由于继承关系，它们都可以被视为同一类型`Particle`，因此可以安全地遍历数组并对每个对象调用像`run()`和`isDead()`这样的函数。继承和多态性一起使得可以在一个数组中管理各种粒子类型，而不管它们最初属于哪个类。
- en: '![Image](../images/pencil.jpg) **Exercise 4.8**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.8**'
- en: Create a particle system with more than two kinds of particles. Try varying
    the behavior of the particles in addition to the design.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含两种以上粒子的粒子系统。除了设计外，尝试改变粒子的行为。
- en: '**Particle Systems with Forces**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**带有力的粒子系统**'
- en: 'So far in this chapter, I’ve focused on structuring code in an object-oriented
    way to manage a collection of particles. While I did keep the `applyForce()` function
    in my `Particle` class, I took a couple of shortcuts to keep the code simple.
    Now I’ll add a `mass` property back in, changing the `constructor()` and `applyForce()`
    methods in the process (the rest of the class stays the same):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的重点是以面向对象的方式构建代码，以管理一组粒子。虽然我在`Particle`类中保留了`applyForce()`函数，但我为了简化代码采取了一些捷径。现在，我将重新添加一个`mass`属性，并在此过程中更改`constructor()`和`applyForce()`方法（类的其他部分保持不变）：
- en: '![Image](../images/pg237_Image_341.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg237_Image_341.jpg)'
- en: 'Now that the `Particle` class is complete, I have an important question to
    ask: Where should I call the `applyForce()` method? Where in the code is it appropriate
    to apply a force to a particle? In my view, there’s no right or wrong answer;
    it really depends on the exact functionality and goals of a particular p5.js sketch.
    My quick-and-dirty solution in the previous examples was to create and apply a
    `gravity` force in the `run()` method of each particle:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 既然`Particle`类已经完成，我有一个重要的问题要问：我应该在哪里调用`applyForce()`方法？在代码中的哪一部分应用力到粒子上才合适？在我看来，没有对错之分，这真的取决于特定p5.js草图的功能和目标。我在前面的示例中的简单解决方案是，在每个粒子的`run()`方法中创建并应用一个`gravity`力：
- en: '![Image](../images/pg238_Image_342.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg238_Image_342.jpg)'
- en: I’d like to now consider a broader, more generic solution that will allow different
    forces to be applied to individual particles in a system. For example, what if
    I were to apply a force globally every time through `draw()` to all particles
    globally?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想考虑一个更广泛、更通用的解决方案，允许对系统中的单个粒子应用不同的力。例如，如果我在每次通过`draw()`时全球性地对所有粒子应用一个力，会怎样？
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Well, it seems there’s a small problem. The `applyForce()` method is written
    inside the `Particle` class, but there’s no reference to the individual particles
    themselves, only to `emitter`, the `Emitter` object. Since I want all particles
    to receive the force, however, I can pass the force to the emitter and let it
    manage all the individual particles:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg238_Image_343.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Of course, if I call an `applyForce()` method on the `Emitter` object in `draw()`,
    I then have to define that method in the `Emitter` class. In English, that method
    needs to be able to receive a force as a `p5.Vector` and apply that force to all
    the particles. Here’s the translation into code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It almost seems silly to write this method. The code is essentially saying,
    “Apply a force to a particle system so that the system can apply that force to
    all the individual particles.” Although this may sound a bit roundabout, this
    approach is quite reasonable. After all, the emitter is in charge of managing
    the particles, so if you want to talk to the particles, you’ve got to talk to
    them through their manager. (Also, here’s a chance to use a `for...of` loop, since
    no particles are being deleted!)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the full example, including this change. (The code assumes the existence
    of the `Particle` class written earlier; there’s no need to show it again, since
    nothing has changed.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg239_Image_344.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: While this example demonstrates a hardcoded gravity force, it’s worth considering
    how other forces from previous chapters, such as wind or drag, could come into
    play. You could also experiment with varying how and when forces are applied.
    Instead of a force acting on particles continuously every frame, what if a force
    only kicked in under certain conditions or at specific moments? A lot of room
    remains here for creativity and interactivity in the way you design your particle
    systems!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Particle Systems with Repellers**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if I want to take my code one step further and add a `Repeller` object—the
    inverse of the `Attractor` object covered in [Chapter 2](ch02.xhtml#ch02)—that
    pushes away any particles that get too close? This requires a bit more sophistication
    than uniformly applying the gravity force, because the force the repeller exerts
    on a particular particle is unique and must be calculated separately for each
    particle (see [Figure 4.6](ch04.xhtml#ch4fig6)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg241_Image_346.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: A gravity force where vectors are all identical (left) and a repeller
    force where all vectors point in different directions (right)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate a new `Repeller` object into a particle system sketch, I’m going
    to need two major additions to the code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: A `Repeller` object (declared, initialized, and displayed)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method that passes the `Repeller` object into the particle emitter so that
    the repeller can apply a force to each particle object
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg241_Image_347.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Creating a `Repeller` object is easy; it’s a duplicate of the `Attractor` class
    from [Example 2.6](ch02.xhtml#ch2ex6). Since this chapter doesn’t involve the
    concept of `mass`, I’ll add a property called `power` to the `Repeller`. This
    property can be used to adjust the strength of the repellent force:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Repeller`对象很简单；它是[示例 2.6](ch02.xhtml#ch2ex6)中`Attractor`类的复制版。由于这一章不涉及`mass`概念，我将为`Repeller`类添加一个名为`power`的属性。这个属性可用于调整排斥力的强度：
- en: '![Image](../images/pg242_Image_348.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg242_Image_348.jpg)'
- en: 'The more difficult task is writing the `applyRepeller()` method. Instead of
    passing a `p5.Vector` object as an argument, as with `applyForce()`, I need to
    pass a `Repeller` object into `applyRepeller()` and ask that method to do the
    work of calculating the force between the repeller and each particle. Take a look
    at both of these methods side by side:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更困难的任务是编写`applyRepeller()`方法。与`applyForce()`不同，我不是将`p5.Vector`对象作为参数传递，而是需要将`Repeller`对象传递给`applyRepeller()`，并要求该方法计算排斥器与每个粒子之间的力。请看一下这两个方法的对比：
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'These nearly identical methods have only two differences. I mentioned one of
    them before: the argument to `applyRepeller()` is a `Repeller` object, not a `p5.Vector`
    object. The second difference is the more important one: I must calculate a custom
    `p5.Vector` force for each and every particle and apply that force. How is that
    force calculated? In a `Repeller` class method called `repel()`, it is calculated
    as the inverse of the `attract()` method from the `Attractor` class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个几乎相同的方法只有两个区别。我之前提到过其中一个：`applyRepeller()`的参数是一个`Repeller`对象，而不是`p5.Vector`对象。第二个区别是更重要的：我必须为每一个粒子计算一个自定义的`p5.Vector`力并施加这个力。这个力是如何计算的？在`Repeller`类的方法`repel()`中，它是通过取`Attractor`类的`attract()`方法的反向来计算的：
- en: '![Image](../images/pg242_Image_349.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg242_Image_349.jpg)'
- en: Notice that throughout this entire process of adding a repeller to the environment,
    I never once considered editing the `Particle` class itself. A particle doesn’t
    have to know anything about the details of its environment; it simply needs to
    manage its position, velocity, and acceleration, as well as have the ability to
    receive an external force and act on it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在整个将排斥器添加到环境的过程中，我从未考虑编辑`Particle`类本身。粒子不需要了解其环境的任何细节；它只需管理其位置、速度和加速度，并能接收外部力并对其进行作用。
- en: I’m now ready to write this example in its entirety, again leaving out the `Particle`
    class, which hasn’t changed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在准备将这个示例完整地写出，再次省略了`Particle`类，因为它没有变化。
- en: '![Image](../images/pg243_Image_351.jpg)![Image](../images/pg244_Image_352.jpg)![Image](../images/pg245_Image_353.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg243_Image_351.jpg)![Image](../images/pg244_Image_352.jpg)![Image](../images/pg245_Image_353.jpg)'
- en: Notice the addition of the `power` variable in the `Repeller` class, which controls
    the strength of the repulsion force exerted. This property becomes especially
    interesting when you have multiple attractors and repellers, each with different
    power values. For example, strong attractors and weak repellers might result in
    particles clustering around the attractors, while more powerful repellers might
    reveal patterns reminiscent of paths or channels between them. These are hints
    of what’s to come in [Chapter 5](ch05.xhtml#ch05), where I’ll further explore
    the concept of a complex system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在`Repeller`类中添加了`power`变量，它控制施加的排斥力的强度。当你有多个吸引器和排斥器，每个都有不同的力量值时，这个属性变得尤其有趣。例如，强吸引器和弱排斥器可能导致粒子聚集在吸引器周围，而更强的排斥器可能会展现出类似路径或通道的图案。这些都是[第5章](ch05.xhtml#ch05)中将要探讨的复杂系统概念的暗示。
- en: '![Image](../images/pencil.jpg) **Exercise 4.9**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.9**'
- en: Expand [Example 4.7](ch04.xhtml#ch4ex7) to include multiple repellers and attractors.
    How might you use inheritance and polymorphism to create separate `Repeller` and
    `Attractor` classes without duplicating code?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展[示例 4.7](ch04.xhtml#ch4ex7)，包括多个排斥器和吸引器。你如何使用继承和多态来创建独立的`Repeller`和`Attractor`类，而不重复代码？
- en: '![Image](../images/pencil.jpg) **Exercise 4.10**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.10**'
- en: Create a particle system in which each particle responds to every other particle.
    (I’ll explain how to do this in detail in [Chapter 5](ch05.xhtml#ch05).)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个粒子系统，使每个粒子都能响应其他每个粒子。（我将在[第5章](ch05.xhtml#ch05)中详细解释如何实现这一点。）
- en: '**Image Textures and Additive Blending**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图像纹理和加法混合**'
- en: Even though this book is almost exclusively focused on behaviors and algorithms
    rather than computer graphics and design, I don’t think I would be able to live
    with myself if I finished a discussion of particle systems without presenting
    an example of texturing each particle with an image. After all, the way you render
    a particle is a key piece of the puzzle in designing certain types of visual effects.
    For example, compare the two smoke simulations shown in [Figure 4.7](ch04.xhtml#ch4fig7).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书几乎专注于行为和算法，而非计算机图形学和设计，但如果我在讨论粒子系统时没有提供一个用图像为每个粒子贴图的示例，我觉得自己一定会不甘心。毕竟，渲染粒子的方式在设计某些类型的视觉效果时是一个关键因素。例如，比较[图4.7](ch04.xhtml#ch4fig7)中展示的两种烟雾模拟。
- en: '![Image](../images/pg246_Image_354.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg246_Image_354.jpg)'
- en: 'Figure 4.7: White circles (left) and fuzzy images with transparency (right)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：白色圆圈（左）和带有透明度的模糊图像（右）
- en: Both images were generated from identical algorithms. The only difference is
    that each particle is drawn as a plain white circle in the image on the left,
    whereas each particle is drawn as a fuzzy blob in the image on the right. [Figure
    4.8](ch04.xhtml#ch4fig8) shows the two kinds of particle textures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这两张图像是通过相同的算法生成的。唯一的区别是，左图中的每个粒子都绘制为一个普通的白色圆圈，而右图中的每个粒子则绘制为一个模糊的斑点。[图4.8](ch04.xhtml#ch4fig8)展示了这两种粒子纹理。
- en: '![Image](../images/pg246_Image_355.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg246_Image_355.jpg)'
- en: 'Figure 4.8: Two image textures: an all-white circle (left) and a fuzzy circle
    that fades out toward the edges (right)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：两种图像纹理：全白圆圈（左）和向边缘渐隐的模糊圆圈（右）
- en: 'Using an image to texture your particles can give you a lot of bang for very
    little buck in terms of the realism of the visual effect. Before you write any
    code, however, you have to make your image texture. I recommend using the PNG
    format, as p5.js will retain the alpha channel (transparency) when drawing the
    image, which is needed for blending the texture as particles are layered on top
    of one another. You can create these textures in numerous ways: you can indeed
    make them programmatically within p5.js (I include an example on the book’s website),
    but you can also use other open source or commercial graphics editing tools.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图像为粒子贴图，在视觉效果的真实感上能以极少的成本获得很大的回报。然而，在编写任何代码之前，你必须先制作好你的图像纹理。我推荐使用PNG格式，因为p5.js会保留绘制图像时的alpha通道（透明度），这对于在粒子相互叠加时进行纹理混合是必需的。你可以通过多种方式制作这些纹理：你确实可以在p5.js中通过编程生成它们（我在本书网站上提供了一个示例），但你也可以使用其他开源或商业的图形编辑工具。
- en: Once you’ve made a PNG and deposited it in your sketch’s *data* folder, you
    need only a few extra lines of code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你制作了一个PNG文件并将其放入草图的*data*文件夹中，你只需要几行额外的代码。
- en: '![Image](../images/pg247_Image_356.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg247_Image_356.jpg)'
- en: 'First, declare a variable to store the image:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个变量来存储图像：
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, load the image in `preload()`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`preload()`中加载图像：
- en: '![Image](../images/pg247_Image_357.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg247_Image_357.jpg)'
- en: 'Next, when it comes time to draw the particle, use the `img` variable instead
    of drawing a circle or rectangle:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在绘制粒子时，使用`img`变量，而不是绘制圆圈或矩形：
- en: '![Image](../images/pg247_Image_358.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg247_Image_358.jpg)'
- en: This smoke example is also a nice excuse to revisit the Gaussian distributions
    from “A Normal Distribution of Random Numbers” on [page 13](ch00.xhtml#ch00lev1sec13).
    Instead of launching the particles in a purely random direction, which produces
    a fountain-like effect, the result will appear more smokelike if the initial velocity
    vectors cluster mostly around a mean value, with a lower probability of outlying
    velocities.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个烟雾示例也是一个很好的借口，让我们重新审视一下《随机数的正态分布》中关于高斯分布的内容，见[第13页](ch00.xhtml#ch00lev1sec13)。与直接将粒子发射到完全随机的方向（会产生类似喷泉的效果）不同，如果初始速度向量大多集中在一个均值附近，且远离该均值的速度出现概率较低，最终效果看起来更像烟雾。
- en: 'Using the `randomGaussian()` function, the particle velocities can be initialized
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`randomGaussian()`函数，可以如下初始化粒子速度：
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, in this example I’ve applied a wind force to the smoke, mapped from
    the mouse’s horizontal position:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个示例中，我对烟雾应用了一个风力，风力映射自鼠标的水平位置：
- en: '![Image](../images/pg248_Image_359.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg248_Image_359.jpg)'
- en: In addition to designing the texture, you should consider its resolution. Rendering
    a large number of high-resolution textures can significantly impair performance,
    especially if the code has to resize them dynamically. The ideal scenario for
    optimal speed is to size the texture precisely to the resolution you intend to
    draw the particles in the canvas. If you want particles of varying sizes, then
    ideally you should create the texture at the maximum size of any particle.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设计纹理之外，你还应考虑其分辨率。渲染大量高分辨率纹理可能会显著影响性能，尤其是当代码需要动态调整它们的大小时。为了获得最佳速度的理想情况，是将纹理的大小精确调整为你打算在画布上绘制粒子的分辨率。如果你希望粒子的大小不同，那么理想的做法是将纹理的大小设置为粒子最大尺寸的大小。
- en: '![Image](../images/pencil.jpg) **Exercise 4.11**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.11**'
- en: Try creating other textures for different types of effects. Can you make your
    particle system look like fire instead of smoke?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为不同类型的效果创建其他纹理。你能让你的粒子系统看起来像火焰而不是烟雾吗？
- en: '![Image](../images/pencil.jpg) **Exercise 4.12**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 4.12**'
- en: Use an array of images and assign each `Particle` object a different image.
    Multiple particles will be drawing the same image, so make sure you don’t call
    `loadImage()` any more than you need to. (Once for each image file is enough!)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组图像，并为每个`Particle`对象分配不同的图像。多个粒子将绘制相同的图像，因此确保你不要重复调用`loadImage()`，每个图像文件调用一次就足够了！
- en: Finally, it’s worth noting that many algorithms can be used to blend colors
    in computer graphics. These are often referred to as **blend modes**. Normally,
    when you draw something on top of something else in p5.js, you see only the top
    layer—this is the default “blend” behavior of not blending at all. Meanwhile,
    when pixels have alpha transparency values (as they do in the smoke example),
    p5.js automatically uses an alpha compositing algorithm that combines a percentage
    of the background pixels with the new foreground pixels, based on those alpha
    values themselves.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，许多算法可以用来在计算机图形中混合颜色，这些算法通常被称为**混合模式**。通常，当你在p5.js中绘制某物时，它会覆盖在另一个物体上，你只能看到最上面的一层——这是默认的“混合”行为，即根本不进行混合。同时，当像素具有透明度值（就像在烟雾示例中一样）时，p5.js会自动使用一个alpha合成算法，将背景像素的一部分与前景像素的比例混合，这个比例由alpha值决定。
- en: However, drawing with other blend modes is possible. For example, a much-loved
    technique for particle systems is **additive blending**. This mode was pioneered
    by Robert Hodgin in his classic particle system and forces exploration, Magnetosphere
    (*[https://roberthodgin.com/project/magnetosphere](https://roberthodgin.com/project/magnetosphere)*),
    which later became the visualizer for early versions of iTunes, displaying sound-responsive,
    animated visuals.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以使用其他混合模式进行绘制。例如，粒子系统中非常受欢迎的一种技术是**加法混合**。这种模式由Robert Hodgin在他的经典粒子系统中首次提出，并在探索项目《Magnetosphere》(*[https://roberthodgin.com/project/magnetosphere](https://roberthodgin.com/project/magnetosphere)*)中得到了应用，该项目后来成为早期版本iTunes的可视化工具，展示了与声音响应的动态视觉效果。
- en: Additive blending is a simple blend algorithm that adds the pixel values of
    one layer to another, capping all values at 255\. This results in a space-age
    glow effect, with the colors getting brighter and brighter as more layers are
    added together.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合是一种简单的混合算法，它将一个层的像素值加到另一个层中，所有值都限制在255以内。这样会产生一种未来感的光晕效果，随着更多层的叠加，颜色会变得越来越亮。
- en: '![Image](../images/pg249_Image_360.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg249_Image_360.jpg)'
- en: 'Before you start drawing anything, set the blend mode by using `blendMode()`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始绘制任何内容之前，使用`blendMode()`设置混合模式：
- en: '![Image](../images/pg249_Image_361.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg249_Image_361.jpg)'
- en: 'Additive blending and particle systems provide an opportunity to discuss renderers
    in computer graphics. A **renderer** is the part of the code that’s responsible
    for drawing on the screen. The p5.js library’s default renderer, which you’ve
    so far been using without realizing it, is built on top of the standard 2D drawing
    and animation renderer included in modern web browsers. However, an additional
    rendering option called `WEBGL` is available. WebGL, which stands for *Web Graphics
    Library*, is a browser-based high-performance renderer for both 2D and 3D graphics.
    It utilizes additional features available from your computer’s graphics card.
    To enable it, add a third argument to `createCanvas()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg250_Image_362.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Typically, the WebGL renderer is necessary only if you’re drawing 3D shapes
    in your p5.js sketch. However, even for 2D sketches, the WebGL renderer can be
    useful in some cases—depending on your computer’s hardware and the specific details
    of your sketch, it can significantly improve drawing performance. A particle system
    (especially one with additive blending enabled) is exactly one of these scenarios
    where many more particles can be drawn without slowing the sketch in `WEBGL` mode.
    Keep in mind that `WEBGL` mode changes the origin point for drawing, making `(0,0)`
    the center of the canvas rather than the top-left corner. `WEBGL` mode also changes
    the way some functions behave, and it may alter the quality of the rendering.
    Additionally, some older devices or browsers don’t support WebGL, though such
    instances are rare. You can learn more in the WebGL videos at the Coding Train
    website (*[https://thecodingtrain.com/webgl](https://thecodingtrain.com/webgl)*).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 4.13**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4.9](ch04.xhtml#ch4ex9), three particles are added with a `for`
    loop each time through `draw()` to create a more layered effect. A better solution
    would be to modify the `addParticle()` method to accept an argument—for example,
    `addParticle(3)`, to determine the number of particles to add. Fill in the new
    method definition here. How might it default to one particle if no value is provided?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Image](../images/pencil.jpg) **Exercise 4.14**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Use `tint()` in combination with additive blending to create a rainbow effect.
    What happens if you try blending with other modes, such as `SUBTRACT`, `LIGHTEST`,
    `DARKEST`, `DIFFERENCE`, `EXCLUSION`, or `MULTIPLY`?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Take your creature from [Chapter 3](ch03.xhtml#ch03) and build a system of creatures.
    How do they interact with one another? Can you use inheritance and polymorphism
    to create a variety of creatures, derived from the same codebase? Develop a methodology
    for the way they compete for resources (for example, food). Can you track a creature’s
    health much like a particle’s life span, removing creatures when appropriate?
    What rules can you incorporate to control the way creatures are born into the
    system?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might consider using a particle system in the design of a creature.
    What happens if an emitter is tied to the creature’s position?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会考虑在生物的设计中使用粒子系统。如果将发射器与生物的位置绑定，会发生什么情况？
- en: '![Image](../images/pg251_Image_363.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg251_Image_363.jpg)'
