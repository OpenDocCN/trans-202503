- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fundamentals of Drawing
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 1: A Circle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a circle requires quite a bit of code in C or Java, but it’s one of
    the simplest programs in Processing. There isn’t a circle function in Processing,
    so to draw a circle we draw an ellipse that has equal width and height, which
    is the same thing as a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `setup()` function calls the predefined `size()` function to open a sketch
    window with a width of 400 pixels and a height of 300 pixels 1.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function draws a circle every time it’s called (60 times per second
    by default) with the `ellipse()` function, which has four parameters. The first
    and second parameters specify the pixel coordinates of the ellipse’s center. The
    third and fourth parameters specify the ellipse’s width and height. The call `ellipse
    (200, 150, 50, 50)` 2 draws an ellipse centered at (200, 100) that is 50 pixels
    wide and 50 pixels high, which is essentially a circle with a diameter of 50 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the background color is set to a medium grey, and the color that
    fills the circle is white. The circle is outlined by a black line.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is much like Example A, but now the background color is set to
    white, and the color that fills the circle (and any other basic closed shape)
    is set to black.
  prefs: []
  type: TYPE_NORMAL
- en: The `background()` function 1 specifies the background color with a single number
    parameter ranging from 0 to 255 that indicates levels of gray, where 0 is black
    and 255 is white. Numerical values outside of this range are illegal. In this
    case the color is set to white (`255`). The `background()` function is specified
    in the `draw()` function so that the background is redrawn each time. If `background()`
    was called in `setup()`, the background would only be drawn once, at the beginning
    of execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `fill()` function 2 specifies the fill color of basic closed shapes with
    the same single number parameter as the `background()` function. In this case
    the fill color is set to black (`0`), and it remains so until changed by another
    call to `fill()`. Thus, `fill()` could have been called just once within `setup()`
    and the effect would have been the same.
  prefs: []
  type: TYPE_NORMAL
- en: Example C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case the background color (white = `255`) 1 and fill color (black =
    `0`) 2 are specified in `setup()`. This sketch draws two ellipses, not circles,
    in the `draw()` function to show how the width and height parameters are used.
    The first call to `ellipse()` 3 draws the leftmost ellipse, which is 100 pixels
    wide and 50 pixels high. The second call to `ellipse()` 4 draws the rightmost
    ellipse, which is 50 pixels wide and 100 pixels high.
  prefs: []
  type: TYPE_NORMAL
- en: The `noFill()` function causes ellipses and other objects to be drawn without
    any fill color so that the background color shows inside the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 2: Colors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can specify a shade of grey with a single numerical component, but we can
    also specify a color by providing three numerical components to the same function.
    These components are given in the traditional order: red, then green, then blue.
    Each component fits in a single byte (8 bits), and it is represented by a number
    ranging from 0 to 255 that determines the shade of the component. Smaller values
    yield a darker color.'
  prefs: []
  type: TYPE_NORMAL
- en: The numbers (255, 0, 0) specify the brightest shade of red, while the numbers
    (254, 0, 0) specify a slightly darker shade of red. Green would be (0, 255, 0)
    and blue would be (0, 0, 255). Yellow is red and green, so a set of RGB coordinates
    for yellow would be (255, 255, 0). Magenta is red and blue, so it would be written
    as (255, 0, 255). Grey values have the three components nearly equal.
  prefs: []
  type: TYPE_NORMAL
- en: This is the RGB representation of color. There are other representations.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sketch draws circles of various colors. In the `draw()` function, the
    first three calls to `fill()` and `ellipse()` draw the first row of circles: red
    1, green 2, and blue 3. The fill color changes prior to drawing each circle.'
  prefs: []
  type: TYPE_NORMAL
- en: The second row of circles is filled with yellow 4, magenta 5, and cyan 6. Each
    color here has two nonzero color values.
  prefs: []
  type: TYPE_NORMAL
- en: The final row contains circles filled with increasingly brighter grey values
    7. Each color here has three equal color values.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use a fourth color component that represents transparency, sometimes
    referred to as the alpha channel. The components (255, 0, 0, 128) indicate that
    red is 255, green and blue are 0, and transparency is 128, or 50 percent. Higher
    numerical values indicate lower transparency. We can give any color any legal
    transparency value in addition to R, G, and B values.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch draws sets of overlapping red, green, and blue circles to show transparency.
  prefs: []
  type: TYPE_NORMAL
- en: In the `draw()` function, the first three calls to `fill()` and `ellipse()`
    1 draw the upper-left set of circles with a fill color transparency value of 20\.
  prefs: []
  type: TYPE_NORMAL
- en: The second three calls 2 draw the upper-right set of circles with a transparency
    value of 100\.
  prefs: []
  type: TYPE_NORMAL
- en: The third three calls 3 draw the lower-left set with a transparency value of
    180.
  prefs: []
  type: TYPE_NORMAL
- en: The final three calls 4 draw the lower-right set of circles with a transparency
    value of 255, which means the color is completely opaque.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 3: if Statements—Changing Colors Conditionally'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In daily life, people often deal with conditional actions, although little
    if any thought is given to the idea. We express the conditions in human language,
    of course:'
  prefs: []
  type: TYPE_NORMAL
- en: “If it is raining, we’ll watch TV, but if it is sunny, we’ll go skiing.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “If the light is red, then stop, but if it is green, just drive on through.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also use conditional actions when programming a computer. If some situation
    is true, we execute a certain section of code. The condition or situation has
    to be expressed in numerical terms, and the result is a `true` or `false` result.
    Such conditions are frequently the result of comparisons between numbers, such
    as “is *i* equal to 10” or “is the x-coordinate less than the width.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional code is dealt with using an `if` statement, which has the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Conditions can be comparisons between numbers, so the following are all conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some special symbols in use here. The `=` symbol means assignment,
    so to compare for equality a different symbol must be used: Processing uses `==`.
    To compare for inequality, the symbol `!=` is used, meaning “not equal.”'
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch uses an `if` statement to increase an integer variable, `count`,
    every time `draw()` is called, and it changes the background color from red to
    green when the count reaches 100 1.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous English condition examples illustrate a normal use of another
    idea: otherwise. One example was “If it is raining, we’ll watch TV, but if it
    is sunny, we’ll go skiing.” That example could also be phrased as “If it is raining,
    we’ll watch TV; otherwise we’ll go skiing,” meaning that if it’s not raining,
    we’ll go skiing. In most computer languages this is written as an `else` part
    to an `if` statement with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example B uses an `else` to accomplish the same task as Example A 1.
  prefs: []
  type: TYPE_NORMAL
- en: Example C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third code example alternates between red and green each time `draw()` is
    called, creating a colored flashing effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 4: Loops—Drawing 20 Circles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers often need to execute the same code over and over again, sometimes
    with small variations. A program that draws 50 ellipses within the sketch window
    could be written using fifty calls to the `ellipse()` function, one for each ellipse
    drawn. Another way is to have one statement with a call to `ellipse(),` and execute
    it 50 times in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: A loop in a program is a collection of statements that executes repeatedly from
    the first statement to the last, in the same order. You must specify the condition
    upon which the loop will exit. It’s pretty common to know in advance how many
    times the loop should execute, as in the example of drawing 50 ellipses. Sometimes
    you won’t know the number ahead of time, but you can calculate it, so the loop
    will execute *N* times, and *N* depends on some other thing. In either case, a
    counting loop is called a `for` loop in Processing because the reserved word `for`
    is used to begin the loop. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop executes 10 times: once when the variable `i=0`, again when `i=1`,
    again when `i=2`, and so on until `i=9`. When `i` is 10, the condition (`i<10`)
    becomes false and the loop ends. As a result, `statementA` executes 10 times,
    once for each value of `i` from 0 to 9\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop has four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i=0` The initialization is executed the first time through the loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i<10` The loop will continue to execute so long as the continuation condition
    is true.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i=i+1` At the end of each iteration, after the statement is executed, the
    increment will be executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`statementA` This is the code that gets executed repeatedly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expression is false at the beginning, the loop does not execute even
    once.
  prefs: []
  type: TYPE_NORMAL
- en: The statement that executes can be a compound statement, which is a collection
    of statements enclosed in braces. In fact, any time I refer to a *statement*,
    it can mean a compound statement.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple loop in Processing can draw 20 ellipses 1 starting at (20, 40) and
    ending at (210, 40). The ellipses are circles and are drawn next to each other.
    The `draw()` function exists but does not do anything 2.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make the color change for each circle by using a compound statement.
    Let’s change the green value by 10 each time a circle is drawn, starting with
    `green = 10` 1. Red and blue both stay at their maximum of 255\. The code within
    the loop needs to set the fill color, draw the circle, and adjust the fill color
    for the next iteration 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop executes for 20 values of `i`: 0 to 19 inclusive. If we were to expand
    the code to show what was being executed, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 5: Lines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing lines is a basic thing to do in graphics. A line in Processing is really
    a line segment, and it is specified by identifying two endpoints that are to be
    connected by the line. The function that draws a line is named `line()`, and it
    takes the coordinates of the endpoints as parameters (for a total of four parameters).
    The call `line (10,10, 20,20)` will draw a line in the window between coordinates
    (10, 10) and (20, 20).
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s draw some note paper. We can draw a horizontal line that runs the full
    width of the sketch window using this call, for some vertical position `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The width of the window is given by the variable `width`, and the height of
    the window is given by the variable `height`. The start of the line is `(0, y)`
    at the left of the image window `y` pixels down from the top; the end of the line
    is at `(width, y)` at the right of the window and the same *y* value.
  prefs: []
  type: TYPE_NORMAL
- en: The color for drawing lines can be specified using a call to `stroke()` with
    a color as the parameter. For example, `stroke (255,0,0`) 1 specifies that red
    lines will be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processing will tell you where the mouse cursor is within the window using the
    built-in variables `mouseX` and `mouseY` 1. Whenever a mouse button is pressed,
    Processing calls a function called `mousePressed()`, if it exists. You have to
    write it if you want to use the mouse. When a mouse button is released, Processing
    calls the `mouseReleased()` function 2. You have to write that one too. The `mousePressed()`
    and `mouseReleased()` functions are referred to as callbacks, and they offer a
    very simple way to access button presses. Additionally, press and release amount
    to touches on a touch screen device, so the program will work on touch screen
    devices as well.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses clicks (presses and releases) to draw lines. The first mouse
    click defines the starting point for the line (`x0`, `y0`) 3. The second click
    (when `x1 < 0`) 4 defines the endpoint of the line. A third click (when `x1 >=
    0`) 5 clears the endpoints and starts again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 6: Arrays—Drawing Many Circles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable can hold a value, such as a single number. If we want more values,
    we can use more variables. For example, to draw two circles, we could have two
    sets of coordinate variables, say `x0`, `y0` and `x1`, `y1`, and we could draw
    the two circles with two calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But what if we wanted to draw a circle every time the mouse button was clicked,
    and to draw it where the cursor is on the screen? We don’t know how many circles
    to draw in advance, so we don’t know how many variables to declare. Instead, we
    can keep track of *x* and *y* using what Processing calls an array. An array is
    a collection of values all having the same type. The syntax for declaring an array
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration defines an array named `x` that can hold 100 integers. The
    phrase `int [] x` means “define a new array named x,” and the phrase `new int[100]`
    defines the size, where 100 could be replaced by any constant. The preceding declaration
    could also be done in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You access the values in the array using an index, a number that specifies
    which of the values you want, starting from 0: `x[0]` is the first element (value)
    in the array with an index of `0`, `x[1]` is the second with an index of `1`,
    and so on to the last one, `x[99]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The example sketch uses two arrays, one for `x` and one for `y`, and it draws
    a circle at the coordinates where the mouse button is clicked (pressed and released).
    Initially each element in the `x` and `y` array is given the value −1 1 in `setup()`.
    This is called a sentinel value, and it indicates that there is no circle defined
    at that index. The `ncircles` variable indicates how many circles have been defined,
    which is how many mouse clicks have been recorded; it starts at 0 and is incremented
    up to the maximum number of circles (`MAXCIRCLES`, a constant defined to be 100).
    When the mouse button is released, the system calls the `mouseReleased()` callback
    function 3, which saves the current value of the mouse coordinates in the arrays
    `x` and `y` at the current position (`ncircles`) and increases `ncircles` by 1\.
    If `ncircles` becomes equal to `MAXCIRCLES`, it is reset to 0 4, which means that
    new circles will be saved over the earliest ones drawn. The old ones will, of
    course, be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw()` function first sets the background and then draws a circle at
    the mouse coordinates. Then all the elements of the `x` array are examined, and
    if the value of element `i` is greater than 0, a circle is drawn at `x[i], y[i]`
    2 using this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The constant value `MAXCIRCLES` is defined using a special `final` property
    in its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `MAXCIRCLES` can’t be changed anywhere in the program because
    it is `final`. It can (and should) be used to define the size of the two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Defining the size of the arrays using a constant means that to increase the
    number of circles allowed, you only need to change the value of `MAXCIRCLES`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 7: Lines with Rubber Banding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use the mouse to draw lines again. A line consists of a starting
    point and an endpoint, each having an x and a y component. We previously drew
    a line when the mouse was clicked on start and end points on the screen, but it
    only drew *one* line. What if we wanted to be able to draw many lines like this?
  prefs: []
  type: TYPE_NORMAL
- en: We can define a starting point when the mouse button is pressed 3 and the endpoint
    when the button is released 4, as we did before. But now we can store these points
    in arrays and draw them all during each screen update. The array `x0` saves the
    starting x-coordinate of a line, and `y0` has the corresponding y-coordinate.
    The arrays `x1` and `y1` will store the end coordinates. When the mouse button
    is pressed, we save the starting point (`x0[n]`, `y0[n]`), andwhen the mouse button
    is released, we save the endpoint as `x1[n]` and `y1[n]` and increment the value
    of `n`. This program will allow us to draw 256 lines because of the fixed size
    of the arrays.
  prefs: []
  type: TYPE_NORMAL
- en: When the starting point has been selected, we draw a line from that point to
    the current mouse coordinates to show how the line *would* look 2. This is called
    rubber banding because the line appears to stretch and contract as the mouse moves.
    When the mouse button is released, we finalize the end coordinates and draw the
    final line.
  prefs: []
  type: TYPE_NORMAL
- en: 'During each frame (the default is 30 frames per second) we draw all of the
    saved lines by calling `line (x0[i], y0[i], x1[i], y1[i])` for all `i` from `0`
    to `n-1` 1. We then draw the rubber band line if the mouse button is currently
    depressed (when `down` is set to `true`). Setting `down` to `true` happens in
    `mousePressed`, and it is set to `false` when the button is released, within `mouseReleased`.
    If `down` is `true`, a line is drawn from the last selected point to the mouse
    coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This implements the rubber banding.
  prefs: []
  type: TYPE_NORMAL
- en: As a new idea, the sketch implements an *erase* feature. If the user types the
    backspace key, the most recent line is deleted. When the system detects a key
    press, Processing calls a user-defined function named `keyPressed()` 5. A variable
    named `key` provides the value of the key that was pressed, so inside `keyPressed()`
    we check if the key is backspace, and if so we decrease the value of `n` (the
    number of lines so far) by 1\. As a result, the last line will not be drawn, and
    the next line will be saved over the erased line in the coordinate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 8: Random Circles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch draws circles at random places on the screen, with random colors.
    Randomness refers to unpredictability, and it is a complex concept. If you try
    to draw straight lines with a pencil, it is impossible that any two of them will
    be identical. There are variations that creep in and cause minor changes in each
    line. The same is true of brush strokes when painting. No two human activities
    will be exactly the same, and the differences will be unpredictable but apparent.
  prefs: []
  type: TYPE_NORMAL
- en: When using a computer, a random number generator creates numbers that are random
    with respect to each other. Random numbers can be used to simulate random events
    in games like dice or poker, to do things that a user would find unpredictable,
    or to simulate complex real-world situations. For example, things like the spacing
    between cars on a road and the appearance of raindrops on a window appear random
    because we do not understand all of the complex factors that went into the situation.
  prefs: []
  type: TYPE_NORMAL
- en: The random number generator in Processing is named `random`. The call `random
    (100)` will generate a real number between 0 and 100, not including 100\. The
    call `random (10, 20)` will return a real number between 10 and 20, but less than
    20\. The call `random (0, width)` generates a random *x* position within the sketch
    window, and `random (0, height)` generates a random *y* position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Sketch 6, this sketch stores coordinates in arrays and uses them to draw
    circles with calls to `ellipse()`, but instead of drawing circles when the mouse
    is clicked, a new circle is created automatically every second. To do this, we
    set the rate at which `draw()` is called (the frame rate) to 1 using the call
    `frameRate(1)` 1 in `setup()`. Each time `draw()` is called, we generate a new
    x- and y-coordinate using `random()` and save it in the `x` and `y` arrays 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(int)` in front of the calls to random converts the result, a `float`,
    into a new type, `int`. This is called a cast, and we are changing the floating-point
    value into an integer because we can’t use values with decimal points as coordinates.
    This can also be done using a call to the function `int()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 9: A Rectangle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could draw a rectangle by drawing four lines that represent the edges, but
    the Processing system would not consider this to be a rectangle; it has no way
    to know that the four lines are a single object. Instead, Processing has a function
    for drawing rectangles, called `rect()`. Rectangles will be filled using the current
    fill color, just as circles were.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default way to specify a rectangle is `CORNER` mode, where the first two
    parameters you supply are the coordinates of the upper-left corner of the rectangle,
    followed by the width and the height, in pixels. If you specify `CENTER` mode,
    the first two parameters are the coordinates of the center of the rectangle. `CORNERS`
    mode specifies the coordinates of the first corner, then the coordinates of the
    diagonally opposite corner. You can change the mode using one of the following
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this sketch we’ll use `CORNERS` mode 1, as specified in the `setup` function,
    and fill the rectangle with a shade of purple: `(200, 0, 160)`. As in the previous
    sketches, the `mousePressed()` function sets a Boolean `flag` variable to `true`
    when the mouse button is pressed 3, and `mouseReleased()` clears the variable
    (sets it to `false`) 5.'
  prefs: []
  type: TYPE_NORMAL
- en: The global variables `x` and `y` represent the first corner of the rectangle
    and are initialized to −1\. When the mouse button is pressed, we set `x` and `y`
    to the current value of `mouseX` and `mouseY` 4, and the `flag` variable is set
    to indicate that `x` has been set. Then the `draw()` function will draw a rectangle
    with `(x, y)` as one corner and the current mouse position `(mouseX, mouseY)`
    as the other 2. This implements the rubber band effect.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables `x1` and `y1` are the coordinates of the second corner of the
    rectangle. When the mouse is released, we see the values of `x1` and `y1` to the
    current mouse coordinates 6, and this completes the rectangle. The `draw()` function
    will draw the rectangle with the value of `x1` and `y1` as the opposite corner
    because `flag` is now false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 10: Triangles and Motion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as rectangles are drawn using the built-in `rect()` function, triangles
    are drawn using the built-in `triangle()` function. Triangles can’t be drawn using
    a height and width; their shape is determined by their three angles. As a result,
    the `triangle()` function has six arguments: the x, y coordinates of the three
    vertices (corners).'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch draws triangles using the mouse. Like the previous sketches that
    draw rectangles and lines, this sketch uses `mouseReleased()` 3 to determine when
    a point has been selected. After three clicks, a triangle will be drawn using
    the three selected points as the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: After the triangle is drawn, it begins to move downward, as if it had been pushed
    slightly. It continues to move downward until it hits the bottom border of the
    sketch window, where it disappears.
  prefs: []
  type: TYPE_NORMAL
- en: We accomplish the motion by adding a small value 1 (`delta` = 1) to the y-coordinates
    of the triangle after each time it is drawn. This draws the triangle at successively
    lower locations in the window until it appears to pass beyond the bottom edge
    of the window. In fact, the triangle still exists to the Processing system, and
    its coordinates continue to update even though it can’t be seen.
  prefs: []
  type: TYPE_NORMAL
- en: If the user of this program clicks the mouse after the triangle is drawn, the
    triangle disappears and the drawing process begins again. We restart the drawing
    process by re-initializing all of the vertices to −1 4, which indicates that they
    have not been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code is commented out inside of `draw()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the `//` at the beginning of the line, the line will execute and
    the triangle will fall faster and faster, as if being pulled by a force (for example,
    gravity). Remove the // from the line near the end of `mouseReleased()` as well
    and the initial speed will reset to 1 with each new triangle drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 11: Displaying Text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text is essential in nearly all practical computational programs and in many
    generative art and net art programs as well. Text is a primary way that humans
    communicate, and while we say that “a picture is worth a thousand words,” it is
    frequently true that a few carefully chosen words can make an otherwise incomprehensible
    image into a valuable communications tool. Think of the labels along the axis
    of a graph, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: We draw text in the sketch window in the same way that we draw lines and ellipses,
    using a simple function. The first thing you need to know is that text is drawn
    starting at a particular (*x*, *y*) location, where *x* and *y* represent the
    coordinates of the lower-left corner of the box that encloses the text *when not
    considering descenders*. Characters such as *y* and *j* extend below this box,
    and they so have *y* values greater than the value specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will draw text using a call to the function `text()` 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the coordinates of the lower left of the string are `(100, 20)`.
    The initial font and size are defaults, and these defaults are system dependent.
    Size is easy to specify using the `textSize(n)` function 1, passing the desired
    size of the characters *in pixels* (not points). The color used to draw the text
    is the current fill color, not the stroke color.
  prefs: []
  type: TYPE_NORMAL
- en: The alignment of the text can be specified using calls to the `textAlign()`
    function 3. Horizontal alignment can be `LEFT`, `CENTER`, or `RIGHT` with respect
    to the x- and y-coordinates specified in the `text()` function call; the default
    is `LEFT`. Vertical alignment can be `TOP`, `CENTER`, `BOTTOM`, or `BASELINE`
    with respect to the x- and y-coordinates specified in the `text()` function call;
    the default is `BASELINE`. `BOTTOM` is the line that defines the lowest *y* value
    for any character, such as the bottom of a descender. `BASELINE` defines the lowest
    point of a typical character with no descender. So, the call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: will center the current text from left to right (the specified *x* value is
    the center of the string) and aligned so that the specified *y* value is the bottom
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Example A illustrates how to display text in two different sizes. Example B
    shows a line drawn horizontally on each x-coordinate and vertically down each
    y-coordinate specified in the `text()` call. It shows the alignment of the text
    with respect to the specified coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 12: Manipulating Text Strings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sketch is really an introduction to character strings, which are
    a natural way for a human to communicate with a computer. A string is a sequence
    of characters; so is a word, a sentence, or a paragraph. At a high level, a string
    consists of a collection of characters in a specific order. There is a first character,
    a second, and so on until the final one is reached. The number of characters in
    this sequence is the length of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'String constants are character sequences enclosed in double quotes like this:
    `"To be or not to be"`. We can use string constants to declare variables that
    are `String`s and assign values to them. At 1, for example, we declare two string
    variables and assign string constants to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can be constructed by sticking other strings together. The `+` operator,
    when applied to strings, means concatenate or append, so the quote can be completed
    by concatenating these two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `s1` become `"To be or not to bethat is the question."` Unfortunately,
    this is not quite right, because we need a comma and a space between the two strings.
    This would be better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first character, “T”, in this new string has an index of 0, meaning it is
    in the 0 position in the string. The character “o” is in position 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A substring is a sequence of characters within the string specified by indices.
    The substring of `s1` from index 6 to 11 is the string `"or not"`, and it is found
    in Processing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of this string is six characters, and that length is returned by
    the function `length()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The character at a specific location can be found with the `charAt()` function.
    For example, `s1.charAt(3)` is “b” and `s1.charAt(18)` is “,”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings cannot be compared using the standard relational operators (because
    they are really class instances, which will be discussed later). Instead, there
    are functions for comparison. Comparing `s1` and `s2` could be accomplished like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This sketch shows some string operations and their results, drawn using the
    `text()` function discussed in Sketch 11\. The sketch includes examples of `length()`
    3, `charAt()` 4, and `substring()` 5.
  prefs: []
  type: TYPE_NORMAL
