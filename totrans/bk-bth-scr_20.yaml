- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 18 DIRECTORIES, RECURSION, AND ITERATIVE LOOPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many Batch commands have options, but most offer a slightly different flavor
    or tweak on the command. The options of the for command are a completely different
    story. The four available options impact the for command in four distinct ways.
    In this chapter, I’ll detail three of them, and the fourth will follow in the
    next, requiring its very own chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One option changes the focus of the command from files to directories, and another
    uses recursion to traverse subdirectories looking for files. You’ll also learn
    how those two options used together can traverse a directory tree looking for
    subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: The last option in this chapter morphs the for command into something unlike
    anything that I’ve yet discussed. Its functionality has little in common with
    the optionless for command or the command with its other options. It creates an
    iterative loop, executing logic as it increments or decrements an index or counter
    by a fixed amount from one number to another. This tool is nothing less than an
    absolute necessity for any coder.
  prefs: []
  type: TYPE_NORMAL
- en: The Directory Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all of the option letters are descriptive of their function, but the /D
    option stands for *directory*. While the optionless for command enumerates through
    a list of filenames, the /D option allows the command to enumerate through a list
    of directories or folders. The general syntax shows that other than the insertion
    of the option, it’s unchanged from its optionless cousin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the option, here is an example reminiscent of the prior chapter,
    an optionless for command sporting a sole wildcard character for the filename
    after a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The resulting output includes the path and filename of every file in the folder
    written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I’m making two tweaks to the optionless for loop:
    one important and one cosmetic. The important addition is the insertion of the
    /D option before the for variable. Notice that the rest of the for command itself
    is completely unchanged. The cosmetic tweak is that I’m replacing the word File
    with Directory in the echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another possible change to this code could include the replacement of %%f with
    %%d for *directory* (but I’m trying not to complicate this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The files in this folder that were displayed without the /D option are no longer
    part of the output. Now the interpreter writes every directory immediately under
    *C:\Budget\* to the console, perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This output assumes that these are the only two subdirectories, but any subdirectories
    of those subdirectories aren’t listed in the output.
  prefs: []
  type: TYPE_NORMAL
- en: The Recursion Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another useful option is /R, which conveniently stands for *recursion*. This
    option empowers the for command to search recursively through a directory and
    all its subdirectories (and their subdirectories, and so on) for files fitting
    a mask. Compared to the syntax of the optionless command, its generic syntax differs
    by more than the option itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The most significant difference is that the path to be searched now comes before
    the for variable. The interpreter is unfazed if you omit the trailing slash, but
    it’s good form to include it to make clear that it’s a path. The path can be as
    little as a drive letter followed by a colon, and you’ll need encasing double
    quotes for any embedded spaces. Inside the parentheses, the input will be one
    or more space- or comma-delimited masks of filenames without paths. For example,
    the following searches the *C:\Budget\* directory and all of its subdirectories
    for Word documents, writing all that are found to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following for command finds those misplaced photos from your trip to Italy,
    or at least any file with a *.jpg* or *.bmp* extension, and a filename starting
    with *Italy*. Because of the /R option, the command looks not just in the root
    *C:\* folder but everywhere on your *C:\* drive as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (Multiple file masks work in all for commands, regardless of the options or
    lack of options.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The for /R command has a couple other variants. The hard brackets surrounding
    the drive and path in the general syntax mean that they are optional, and if omitted,
    the current directory is assumed. Hence, the previous command is functionally
    equivalent to the following since *C:\* is the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, %%p resolves to the fully qualified path and filename for
    each found photo.
  prefs: []
  type: TYPE_NORMAL
- en: In an odd and subtle batveat, all inputs to a for /R command must contain at
    least one wildcard character. If you use an explicit filename (or any text without
    an asterisk or question mark) as input in the prior command, it returns *C:\*
    and all of its subdirectories followed by your filename, even if the file doesn’t
    exist in the directories. To find an explicit filename, you must add a wildcard
    character somewhere in the filename input. I recommend a trailing asterisk because
    it usually runs the least risk of accidentally capturing additional files.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For better or worse, the interpreter handles the recursion itself, or the
    stepping into each subfolder, hiding it from you. In [Chapter 23](chapter23.xhtml),
    I’ll return to recursion and explain how to define the actual recursive call,
    opening up many possibilities.*'
  prefs: []
  type: TYPE_NORMAL
- en: Directory Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the /D option allows for directory searches and the /R option allows for
    recursive file searches, you might expect that they can be used together for recursive
    directory searches, and you would be correct. The format follows the general syntax
    of the /R form of the command with /D coming before /R and with nothing but an
    asterisk for the input in the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code displays all subdirectories of *C:\Budget\* and all of their
    subdirectories, and so on. For instance, assuming that two particular subdirectories
    and one sub-subdirectory exist, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a curious oddity, the for /R command alone can perform this same functionality
    without the /D option, or at least something really similar. To demonstrate, I’ve
    taken the previous for command and made two small tweaks. I’ve removed the /D
    option and changed the input from an asterisk to a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s far from intuitive, but the dot inside the parentheses instructs the for
    /R command to enumerate directories instead of files. (Directory and dot both
    start with D, if that helps.) This also produces a list of subdirectories, but
    notice three peculiar differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you use the /R option with the dot as input, the first difference is that
    the interpreter now enumerates the root directory, in this instance *C:\Budget\*,
    as well as the subdirectories. Second, it returns each directory with a trailing
    backslash followed by a dot, and third, it sorts the output differently, processing
    subdirectories of a directory before processing its sibling directories. Notice
    that when using the /D and /R options in tandem with an asterisk, the interpreter
    processed *C:\Budget\Taxes\* before *C:\Budget\SubDir\SubSubDir\*, just the opposite
    of the results with the /R option with the dot.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*Everything I’ve detailed about the dot as input to the* for /R *command is
    exactly what the help would have you believe, but it isn’t entirely true. The
    dot at the end of each line of output is just a reproduction of the input. This
    is another manifestation of the batveat mentioned in the prior section. Any input
    without a wildcard character tells the command to step through all subdirectories,
    appending each with that input. The dot nicely terminates each directory in the
    prior example, but if you instead use a tilde as the input, the resulting directories
    in the output all end with a tilde, not a dot.*'
  prefs: []
  type: TYPE_NORMAL
- en: The differences in the output are subtle and, depending on your application,
    inconsequential, but they’re differences, nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: The Iterative Loop Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The /L option turns the for command into an iterative loop, an essential item
    in any coder’s toolkit and possibly the most used variant of the command. The
    loops I’ve discussed up to this point have enumerated through a list of files,
    directories, or text of some sort. However, this option turns the for command
    into a loop that increments or decrements by some numerical value or step from
    one number to another with a fixed ending value. Most coding languages implement
    iterative loops in some fashion. In fact, many also have a command called for
    specifically for this purpose. Batch is unique in that the for command does so
    much else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax to turn the command into an iterative loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Other than the addition of the /L option, the only other difference between
    this and the optionless for command is the data inside of the parentheses, where
    three comma-delimited numbers now make up the input. The first is the start, or
    beginning index; the second is the step, or the amount by which that index increments
    for each iteration of the loop; and the last is the end, or last possible value
    the index can take.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, this for /L loop starts with the value 1, each iteration steps
    by 2, and it ends at 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This command sets the for variable, %%i, to 1 during the first iteration of
    the loop; then it increments or steps by 2 so that %%i resolves to 3 the second
    time through. That matches the ending value, so the loop doesn’t execute again.
    Here’s the output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following for command starts with the variable set to 10 and then increments
    by 1 up to 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This iterates through the indices of 10, 11, and 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrement the index, assign a negative value to the step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the index descending from 2 to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All three of the numerical inputs can be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This for loop executes for these three indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the following start and step values, it’s clear that the for command
    generates an increasing sequence of positive multiples of 10, starting with 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What’s less clear is exactly where the sequence ends. The end value of 35 isn’t
    a multiple of 10, so it isn’t in the sequence, but once the index is greater than
    35, the loop ends, so 30 is the last number in the sequence. The command would’ve
    been functionally equivalent if the end value had been 30, 39, or any integer
    in between, but for clarity, 30 would’ve been the best option. Also, notice that
    I omitted the spaces after the commas in the input. I usually include the spaces
    for readability, but this example demonstrates that they aren’t needed (and easily
    forgotten).
  prefs: []
  type: TYPE_NORMAL
- en: Power Function Routine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unfortunately, Batch doesn’t support the power function. In [Chapter 6](chapter6.xhtml),
    I mentioned that we could write a short routine for the task, and here is the
    promised routine, which uses an iterative loop. It accepts three parameters: the
    base of the exponential, the exponent, and the name of the return variable containing
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (If the return parameter has you bamboozled, return to [Chapter 11](chapter11.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: I’m initializing the return parameter to 1. Then the loop starts at 1, increments
    by 1, and increases up to the value of the exponent or the second parameter. Hence,
    the loop executes *n* times if the exponent is *n*. The command inside the loop
    multiplies the return parameter by the base of the exponential or the first parameter.
    Hence, if the base is *b*, this for loop multiples together *n* copies of *b*.
    When the loop is done, the return parameter contains *b**^n*, and the routine
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find 53, call the routine passing these three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code multiplies 3 copies of 5 and writes Five cubed = 125 to the console.
  prefs: []
  type: TYPE_NORMAL
- en: A Case Study
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a seven-year-old mathematical prodigy in the late 18th century, the great
    mathematician Carl Friedrich Gauss received, along with the rest of his class,
    some busywork from the teacher. The students were to add up all of the numbers
    from 1 to 100\. Moments later, the teacher looked up and saw all of the children
    busily adding with their chalk and slate, except for one. He approached the young
    Gauss, preparing a stern reprimand, only to notice the correct answer of 5,050
    written on the boy’s piece of slate.
  prefs: []
  type: TYPE_NORMAL
- en: Gauss had realized that there were 50 pairs of numbers adding up to 101 (100
    + 1, 99 + 2, ..., 51 + 50). He quickly multiplied 50 by 101, wrote down the answer,
    and sat back waiting for his peers to finish, probably wondering what was taking
    them so long.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other variations of this story, and it may be apocryphal, but if
    any of those other students had had access to a Windows computer, they may have
    been able to complete the task even before the young genius—that is, if they could
    have quickly typed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This loop iterates the %%i index from 1 to 100, where the set /A command tallies
    up all of the indices. Before the loop, the set command explicitly initializes
    sum to 0, thus guaranteeing that the final result is the desired value. Gauss’s
    tech-savvy classmates could’ve then rewritten the output The sum is 5050. on their
    pieces of slate in a time comparable to Gauss himself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about three options of the for command. The /D
    option allows the command to enumerate through directories instead of files, and
    the /R option uses recursion to traverse subdirectories. I even demonstrated two
    methods of recursively enumerating directories.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to create an iterative loop with the /L option and all
    of its facets. I used the for command with this option to create a routine for
    raising one number to another, and I even got in a quick mathematical history
    lesson and a little Batch arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves one option left, and you’ll learn all about it in the next chapter.
    It allows for the reading of files and much more.
  prefs: []
  type: TYPE_NORMAL
