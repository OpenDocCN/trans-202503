<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="117" id="Page_117"/>8</span><br/>&#13;
<span class="ChapterTitle">Table Design That Works for You</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Obsession with order and detail can be a good thing. When you’re running out the door, it’s reassuring to see your keys hanging on the hook where you <em>always</em> leave them. The same holds true for database design. When you need to excavate a nugget of information from dozens of tables and millions of rows, you’ll appreciate a dose of that same detail obsession. With data organized into a finely tuned, smartly named set of tables, the analysis experience becomes much more manageable.</p>&#13;
<p>In this chapter, I’ll build on <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> by introducing best practices for organizing and speeding up SQL databases, whether they’re yours or ones you inherit for analysis. We’ll dig deeper into table design by exploring naming rules and conventions, ways to maintain the integrity of your data, and how to add indexes to tables to speed up queries.</p>&#13;
<h2 id="h1-501065c08-0001"><span epub:type="pagebreak" title="118" id="Page_118"/>Following Naming Conventions</h2>&#13;
<p class="BodyFirst">Programming languages tend to have their own style patterns, and even various factions of SQL coders prefer certain conventions when naming tables, columns, and other objects (called <em>identifiers</em>). Some like <em>camel case</em>, as in <code>berrySmoothie</code>, where words are strung together and the first letter of each word is capitalized except for the first word. <em>Pascal case</em>, as in <code>BerrySmoothie</code>, follows a similar pattern but capitalizes the first letter too. With <em>snake case</em>, as in <code>berry_smoothie</code>, all the words are lowercase and separated by underscores.</p>&#13;
<p>You’ll find passionate supporters of each naming convention, with some preferences tied to individual database applications or programming languages. For example, Microsoft uses Pascal case in the documentation for its SQL Server database. In this book, for PostgreSQL-related reasons I’ll explain in a moment, we’re using snake case, as in the table <code>us_counties_pop_est_2019</code>. Whichever convention you prefer or find yourself required to use, it’s important to apply it consistently. Be sure to check whether your organization has a style guide or offer to collaborate on one, and then follow it religiously.</p>&#13;
<p>Mixing styles or following none generally leads to a mess. For example, imagine connecting to a database and finding the following collection of tables:</p>&#13;
<ol class="none">&#13;
<li><code>Customers</code></li>&#13;
<li><code>customers</code></li>&#13;
<li><code>custBackup</code></li>&#13;
<li><code>customer_analysis</code></li>&#13;
<li><code>customer_test2</code></li>&#13;
<li><code>customer_testMarch2012</code></li>&#13;
<li><code>customeranalysis</code></li>&#13;
</ol>&#13;
<p>You would have questions. For one, which table actually holds the current data on customers? A disorganized naming scheme—and a general lack of tidiness—makes it hard for others to dive into your data and makes it challenging for you to pick up where you left off.</p>&#13;
<p>Let’s explore considerations related to naming identifiers and suggestions for best practices.</p>&#13;
<h3 id="h2-501065c08-0001">Quoting Identifiers Enables Mixed Case</h3>&#13;
<p class="BodyFirst">Regardless of any capitalization you supply, PostgreSQL treats identifiers as lowercase unless you place double quotes around the identifier. Consider these two <code>CREATE TABLE</code> statements for PostgreSQL:</p>&#13;
<pre><code>CREATE TABLE customers (&#13;
    customer_id text,&#13;
<var>    --snip--</var>&#13;
);&#13;
&#13;
<span epub:type="pagebreak" title="119" id="Page_119"/>CREATE TABLE Customers (&#13;
    customer_id text,&#13;
<var>    --snip--</var>&#13;
);</code></pre>&#13;
<p>When you execute these statements in order, the first command creates a table called <code>customers</code>. The second statement, rather than creating a separate table called <code>Customers</code>, will throw an error: <code>relation "customers" already exists</code>. Because you didn’t quote the identifier, PostgreSQL treats <code>customers</code> and <code>Customers</code> as the same identifier, disregarding the case. To preserve the uppercase letter and create a separate table named <code>Customers</code>, you must surround the identifier with quotes, like this:</p>&#13;
<pre><code>CREATE TABLE "Customers" (&#13;
    customer_id serial,&#13;
<var>    --snip--</var>&#13;
);</code></pre>&#13;
<p>However, because this requires that to query <code>Customers</code> rather than <code>customers</code>, you have to quote its name in the <code>SELECT</code> statement:</p>&#13;
<pre><code>SELECT * FROM "Customers";</code></pre>&#13;
<p>That can be a chore to remember and makes a user vulnerable to a mix-up. Make sure your tables have names that are clear and distinct from other tables in the database.</p>&#13;
<h3 id="h2-501065c08-0002">Pitfalls with Quoting Identifiers</h3>&#13;
<p class="BodyFirst">Quoting identifiers also allows you to use characters not otherwise allowed, including spaces. That may appeal to some folks, but there are negatives. You may want to throw quotes around <code>"trees planted"</code> as a column name in a reforestation database, but then all users will have to provide quotes on every reference to that column. Omit the quotes in a query, and the database will respond with an error, identifying <code>trees</code> and <code>planted</code> as separate columns and responding that <code>trees</code> does not exist. A more readable and reliable option is to use snake case, as in <code>trees_planted</code>.</p>&#13;
<p>Quotes also let you use SQL <em>reserved keywords</em>, which are words that have special meaning in SQL. You’ve already encountered several, such as <code>TABLE</code>, <code>WHERE</code>, or <code>SELECT</code>. Most database developers frown on using reserved keywords as identifiers. At a minimum it’s confusing, and at worst neglecting or forgetting to quote that keyword later may result in an error because the database will interpret the word as a command instead of an identifier.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	For PostgreSQL, you can find a list of keywords documented at <a href="https://www.postgresql.org/docs/current/sql-keywords-appendix.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-keywords-appendix.html</a>. In addition, many code editors and database tools, including pgAdmin, automatically highlight keywords in a particular color.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c08-0003"><span epub:type="pagebreak" title="120" id="Page_120"/>Guidelines for Naming Identifiers</h3>&#13;
<p class="BodyFirst">Given the extra burden of quoting and its potential problems, it’s best to keep your identifier names simple, unquoted, and consistent. Here are my recommendations:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">Use snake case.</span>  Snake case is readable and reliable, as shown in the earlier <code>trees_planted</code> example. It’s used throughout the official PostgreSQL documentation and helps make multiword names easy to understand: <code>video_on_demand</code> makes more sense at a glance than <code>videoondemand</code>.</li>&#13;
<li><span class="RunInHead">Make names easy to understand and avoid cryptic abbreviations.</span>  If you’re building a database related to travel, <code>arrival_time</code> is a clearer column name than <code>arv_tm</code>.</li>&#13;
<li><span class="RunInHead">For table names, use plurals.</span>  Tables hold rows, and each row represents one instance of an entity. So, use plural names for tables, such as <code>teachers</code>, <code>vehicles</code>, or <code>departments</code>. I do make exceptions at times. For example, to preserve the names of imported CSV files, I use them as a table name, especially when they are one-off imports.</li>&#13;
<li><span class="RunInHead">Mind the length. </span>  The maximum number of characters allowed for an identifier name varies by database application: the SQL standard is 128 characters, but PostgreSQL limits you to 63, and older Oracle systems have a maximum of 30. If you’re writing code that may get reused in another database system, lean toward shorter identifier names.</li>&#13;
<li><span class="RunInHead">When making copies of tables, use names that will help you manage them later.</span>  One method is to append a <var>_YYYY_MM_DD</var> date to the table name when you create the copy, such as <code>vehicle_parts_2021_04_08</code>. An additional benefit is that the table names will sort in date order.</li>&#13;
</ol>&#13;
<h2 id="h1-501065c08-0002">Controlling Column Values with Constraints</h2>&#13;
<p class="BodyFirst">You can maintain further control over the data a column will accept by using certain constraints. A column’s data type broadly defines the kind of data it will accept: integers versus characters, for example. Additional constraints let us further specify acceptable values based on rules and logical tests. With constraints, we can avoid the “garbage in, garbage out” phenomenon, which happens when poor-quality data results in inaccurate or incomplete analysis. Well-designed constraints help maintain the quality of the data and ensure the integrity of the relationships among tables.</p>&#13;
<p>In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you learned about <em>primary</em> and <em>foreign keys</em>, which are two of the most commonly used constraints. SQL also has the following constraint types:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>CHECK</code></span></span>  Allows only those rows where a supplied Boolean expression evaluates to <code>true</code></li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>UNIQUE</code></span></span>  Ensures that values in a column or group of columns are unique in each row in the table</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>NOT NULL</code></span></span>  Prevents <code>NULL</code> values in a column</li>&#13;
</ol>&#13;
<p><span epub:type="pagebreak" title="121" id="Page_121"/>We can add constraints in two ways: as a <em>column constraint</em> or as a <em>table constraint</em>. A column constraint applies only to that column. We declare it with the column name and data type in the <code>CREATE TABLE</code> statement, and it gets checked whenever a change is made to the column. With a table constraint, we can supply criteria that apply to one or more columns. We declare it in the <code>CREATE TABLE</code> statement immediately after defining all the table columns, and it gets checked whenever a change is made to a row in the table.</p>&#13;
<p>Let’s explore these constraints, their syntax, and their usefulness in table design.</p>&#13;
<h3 id="h2-501065c08-0004">Primary Keys: Natural vs. Surrogate</h3>&#13;
<p class="BodyFirst">As explored in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, a <em>primary key</em> is a column or collection of columns whose values uniquely identify each row in a table. A primary key is a constraint, and it imposes two rules on the column or columns that make up the key:</p>&#13;
<ul>&#13;
<li>Values must be unique for each row.</li>&#13;
<li>No column can have missing values.</li>&#13;
</ul>&#13;
<p>In a table of products stored in a warehouse, the primary key could be a column of unique product codes. In the simple primary key examples in “Relating Tables with Key Columns” in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, our tables had a primary key made from a single ID column with an integer inserted by us, the user. Often, the data will suggest the best path and help us decide whether to use a <em>natural key</em> or a <em>surrogate key</em> as the primary key.</p>&#13;
<h4 id="h3-501065c08-0001">Using Existing Columns for Natural Keys</h4>&#13;
<p class="BodyFirst">A natural key uses one or more of the table’s existing columns that meet the criteria for a primary key: unique for every row and never empty. Values in the columns can change as long as the new value doesn’t cause a violation of the constraint.</p>&#13;
<p>A natural key might be a driver’s license identification number issued by a local Department of Motor Vehicles. Within a governmental jurisdiction, such as a state in the United States, we’d reasonably expect that all drivers would receive a unique ID on their licenses, which we could store as <code>driver_id</code>. However, if we were compiling a national driver’s license database, we might not be able to make that assumption; several states could independently issue the same ID code. In that case, the <code>driver_id</code> column may not have unique values and cannot be used as the natural key. As a solution, we could create a <em>composite primary key</em> by combining <code>driver_id</code> with a column holding the state name, which would give us a unique combination for each row. For example, both rows in this table have a unique combination of the <code>driver_id</code> and <code>st</code> columns:</p>&#13;
<pre><code>driver_id   st  first_name  last_name&#13;
----------  --  ----------  ---------&#13;
10302019    NY  Patrick     Corbin&#13;
10302019    FL  Howard      Kendrick</code></pre>&#13;
<p><span epub:type="pagebreak" title="122" id="Page_122"/>We’ll visit both approaches in this chapter, and as you work with data, keep an eye out for values suitable for natural keys. A part number, a serial number, or a book’s ISBN are all good examples.</p>&#13;
<h4 id="h3-501065c08-0002">Introducing Columns for Surrogate Keys</h4>&#13;
<p class="BodyFirst">A <em>surrogate</em> key is a single column that you fill with artificial values; we might use it when a table doesn’t have data that supports creating a natural primary key. The surrogate key might be a sequential number autogenerated by the database. We’ve already done this with the serial data type and the <code>IDENTITY</code> syntax (covered in “Auto-Incrementing Integers” in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>). A table using an autogenerated integer for a surrogate key might look like this:</p>&#13;
<pre><code>id  first_name  last_name&#13;
--  ----------  ---------&#13;
 1  Patrick     Corbin&#13;
 2  Howard      Kendrick&#13;
 3  David       Martinez</code></pre>&#13;
<p>Some developers like to use a <em>universally unique identifier (UUID)</em>, which is a code comprised of 32 hexadecimal digits in groups separated by hyphens. Often, UUIDs are used to identify computer hardware or software and look like the following:</p>&#13;
<pre><code>2911d8a8-6dea-4a46-af23-d64175a08237</code></pre>&#13;
<p>PostgreSQL offers a UUID data type as well as two modules that generate UUIDs: <code>uuid-ossp</code> and <code>pgcrypto</code>. The PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-uuid.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-uuid.html</a> is a good starting point for diving deeper.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Exercise caution when considering UUIDs for a surrogate key. Because of their size, they are inefficient compared with options such as <code>bigint</code>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h4 id="h3-501065c08-0003">Evaluating the Pros and Cons of Key Types</h4>&#13;
<p class="BodyFirst">There are well-reasoned arguments for using either type of primary key, but both have drawbacks. Points to consider about natural keys include the following:</p>&#13;
<ul>&#13;
<li>The data already exists in the table, so you don’t need to add a column to create a key.</li>&#13;
<li>Because the natural key data has meaning, it can reduce the need to join tables when querying.</li>&#13;
<li>If your data changes in a way that violates the requirements for a key—the sudden appearance of duplicate values, for instance—you’ll be forced to change the setup of the table.</li>&#13;
</ul>&#13;
<p><span epub:type="pagebreak" title="123" id="Page_123"/>Here are points to consider about surrogate keys: </p>&#13;
<ul>&#13;
<li>Because a surrogate key doesn’t have any meaning in itself and its values are independent of the data in the table, you’re not limited by the key structure if your data changes later.</li>&#13;
<li>Key values are guaranteed to be unique.</li>&#13;
<li>Adding a column for a surrogate key requires more space.</li>&#13;
</ul>&#13;
<p>In a perfect world, a table should have one or more columns that can serve as a natural key, such as a unique product code in a table of products. But real-world limitations arise all the time. In a table of employees, it might be difficult to find any single column, or even multiple columns, that would be unique on a row-by-row basis to serve as a primary key. In such cases where you can’t reconsider the table structure, you may need to use a surrogate key.</p>&#13;
<h4 id="h3-501065c08-0004">Creating a Single-Column Primary Key </h4>&#13;
<p class="BodyFirst">Let’s work through several primary key examples. In “Understanding JOIN Types” in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you created primary keys on the <code>district_2020</code> and <code>district_2035</code> tables to try <code>JOIN</code> types. In fact, these were surrogate keys: in both tables, you created columns called <code>id</code> to use as the key and used the keywords <code>CONSTRAINT </code><var>key_name</var><code> PRIMARY KEY</code> to declare them as primary keys.</p>&#13;
<p>There are two ways to declare constraints: as a column constraint or as a table constraint. In <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>, we try both methods, declaring a primary key on a table similar to the driver’s license example mentioned earlier. Because we expect the driver’s license IDs to always be unique, we’ll use that column as a natural key.</p>&#13;
<pre><code>CREATE TABLE natural_key_example (&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> license_id text CONSTRAINT license_key PRIMARY KEY,&#13;
    first_name text,&#13;
    last_name text&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> DROP TABLE natural_key_example;&#13;
&#13;
CREATE TABLE natural_key_example (&#13;
    license_id text,&#13;
    first_name text,&#13;
    last_name text,&#13;
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> CONSTRAINT license_key PRIMARY KEY (license_id)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Declaring a single-column natural key as a primary key</p>&#13;
<p>We first create a table called <code>natural_key_example</code> and use the column constraint syntax <code>CONSTRAINT</code> to declare <code>license_id</code> as the primary key <span class="CodeAnnotation" aria-label="annotation1">1</span> followed by a name for the constraint and the keywords <code>PRIMARY KEY</code>. This syntax makes it easy to understand at a glance which column is designated as <span epub:type="pagebreak" title="124" id="Page_124"/>the primary key. Note that you can omit the <code>CONSTRAINT</code> keyword and name for the key and simply use <code>PRIMARY KEY</code>:</p>&#13;
<pre><code>license_id text PRIMARY KEY</code></pre>&#13;
<p>In that case, PostgreSQL will name the primary key on its own, using the convention of the table name followed by <code>_pkey</code>.</p>&#13;
<p>Next, we delete the table from the database with <code>DROP TABLE</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to prepare for the table constraint example.</p>&#13;
<p>To add a table constraint, we declare the <code>CONSTRAINT</code> after listing all the columns <span class="CodeAnnotation" aria-label="annotation3">3</span>, with the column we want to use as the key in parentheses. (Again, you can omit the <code>CONSTRAINT</code> keyword and key name.) In this example, we end up with the same <code>license_id</code> column for the primary key. You must use the table constraint syntax when you want to create a primary key using more than one column; in that case, you would list the columns in parentheses, separated by commas. We’ll explore that in a moment.</p>&#13;
<p>First, let’s look at how the qualities of a primary key—unique for every row and no <code>NULL</code> values—protect you from harming your data’s integrity. <a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> has two <code>INSERT</code> statements.</p>&#13;
<pre><code>INSERT INTO natural_key_example (license_id, first_name, last_name)&#13;
VALUES ('T229901', 'Gem', 'Godfrey');&#13;
&#13;
INSERT INTO natural_key_example (license_id, first_name, last_name)&#13;
VALUES ('T229901', 'John', 'Mitchell');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: An example of a primary key violation</p>&#13;
<p>When you execute the first <code>INSERT</code> statement on its own, the server loads a row into the <code>natural_key_example</code> table without any issue. When you attempt to execute the second, the server replies with an error:</p>&#13;
<pre><code>ERROR:  duplicate key value violates unique constraint "license_key"&#13;
DETAIL:  Key (license_id)=(T229901) already exists.</code></pre>&#13;
<p>Before adding the row, the server checked whether a <code>license_id</code> of <code>T229901</code> was already present in the table. Because it was and because a primary key by definition must be unique for each row, the server rejected the operation. The rules of the fictional DMV state that no two drivers can have the same license ID, so checking for and rejecting duplicate data is one way for the database to enforce that rule.</p>&#13;
<h4 id="h3-501065c08-0005">Creating a Composite Primary Key</h4>&#13;
<p class="BodyFirst">If a single column doesn’t meet the requirements for a primary key, we can create a <em>composite primary key</em>.</p>&#13;
<p>We’ll make a table that tracks student school attendance. The combination of <code>student_id</code> and <code>school_day</code> columns gives us a unique value for each row, which records whether a student was in school on that day in a column called <code>present</code>. To create a composite primary key, you must declare it using the table constraint syntax, as shown in <a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a>. </p>&#13;
<pre><code><span epub:type="pagebreak" title="125" id="Page_125"/>CREATE TABLE natural_key_composite_example (&#13;
    student_id text,&#13;
    school_day date,&#13;
    present boolean,&#13;
    CONSTRAINT student_key PRIMARY KEY (student_id, school_day)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: Declaring a composite primary key as a natural key</p>&#13;
<p>Here we pass two (or more) columns as arguments rather than one. We’ll simulate a key violation by attempting to insert a row where the combination of values in the two key columns—<code>student_id</code> and <code>school_day</code>—is not unique to the table. Run the <code>INSERT</code> statements in <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a> one at a time (by highlighting them in pgAdmin before clicking <b>Execute/Refresh</b>).</p>&#13;
<pre><code>INSERT INTO natural_key_composite_example (student_id, school_day, present)&#13;
VALUES(775, '2022-01-22', 'Y');&#13;
&#13;
INSERT INTO natural_key_composite_example (student_id, school_day, present)&#13;
VALUES(775, '2022-01-23', 'Y');&#13;
&#13;
INSERT INTO natural_key_composite_example (student_id, school_day, present)&#13;
VALUES(775, '2022-01-23', 'N');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: Example of a composite primary key violation</p>&#13;
<p>The first two <code>INSERT</code> statements execute fine because there’s no duplication of values in the combination of the key columns. But the third statement causes an error because the <code>student_id</code> and <code>school_day</code> values it contains match a combination that already exists in the table: </p>&#13;
<pre><code>ERROR:  duplicate key value violates unique constraint "student_key"&#13;
DETAIL:  Key (student_id, school_day)=(775, 2022-01-23) already exists.</code></pre>&#13;
<p>You can create composite keys with more than two columns. The limit to the number of columns you can use depends on your database.</p>&#13;
<h4 id="h3-501065c08-0006">Creating an Auto-Incrementing Surrogate Key</h4>&#13;
<p class="BodyFirst">As you learned in “Auto-Incrementing Integers” in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, there are two ways to have a PostgreSQL database add an automatically increasing unique value to a column. The first is to set the column to one of the PostgreSQL-specific serial data types: <code>smallserial</code>, <code>serial</code>, and <code>bigserial</code>. The second is to use the <code>IDENTITY</code> syntax; because it is part of the ANSI SQL standard, we’ll employ this for our examples.</p>&#13;
<p>Use <code>IDENTITY</code> with one of the integer types <code>smallint</code>, <code>integer</code>, and <code>bigint</code>. For a primary key, it may be tempting to try to save disk space by using <code>integer</code>, which handles numbers as large as 2,147,483,647. But many a database developer has received a late-night call from a user frantic to know why an application is broken, only to discover that the database is trying to generate a number one greater than the data type’s maximum. So, if it’s remotely possible that your table will grow past 2.147 billion rows, it’s wise <span epub:type="pagebreak" title="126" id="Page_126"/>to use <code>bigint</code>, which accepts numbers as high as 9.2 <em>quintillion</em>. You can set it and forget it, as shown in the first column defined in <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a>.</p>&#13;
<pre><code>CREATE TABLE surrogate_key_example (&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> order_number bigint GENERATED ALWAYS AS IDENTITY,&#13;
    product_name text,&#13;
    order_time timestamp with time zone,&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> CONSTRAINT order_number_key PRIMARY KEY (order_number)&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> INSERT INTO surrogate_key_example (product_name, order_time)&#13;
VALUES ('Beachball Polish', '2020-03-15 09:21-07'),&#13;
       ('Wrinkle De-Atomizer', '2017-05-22 14:00-07'),&#13;
       ('Flux Capacitor', '1985-10-26 01:18:00-07');&#13;
&#13;
SELECT * FROM surrogate_key_example;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Declaring a <code>bigint</code> column as a surrogate key using <code>IDENTITY</code></p>&#13;
<p><a href="#listing8-5">Listing 8-5</a> shows how to declare an auto-incrementing <code>bigint</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> column called <code>order_number</code> using the <code>IDENTITY</code> syntax and then set the column as the primary key <span class="CodeAnnotation" aria-label="annotation2">2</span>. When you insert data into the table <span class="CodeAnnotation" aria-label="annotation3">3</span>, you omit <code>order_number</code> from the list of columns and values. The database will create a new value for that column as each row is inserted, and that value will be one greater than the largest already created for the column.</p>&#13;
<p>Run <code>SELECT * FROM surrogate_key_example;</code> to see how the column fills in automatically:</p>&#13;
<pre><code>order_number    product_name           order_time&#13;
------------ ------------------- ----------------------&#13;
           1 Beachball Polish    2020-03-15 09:21:00-07&#13;
           2 Wrinkle De-Atomizer 2017-05-22 14:00:00-07&#13;
           3 Flux Capacitor      1985-10-26 01:18:00-07</code></pre>&#13;
<p>We see these sorts of auto-incrementing order numbers reflected in the receipts for the purchases we make every day. Now you know how it’s done.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	In your query results, the timestamps in the <code>order_time</code> column will vary based on the time zone configuration of your PostgreSQL installation, as discussed in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>A few details worth noting: if you delete a row, the database won’t fill the gap in the <code>order_number</code> sequence, nor will it change any of the existing values in that column. It will generally add one to the largest existing value in the sequence (though there are exceptions related to operations, including restoring a database from a backup). Also, we used the syntax <code>GENERATED ALWAYS AS IDENTITY</code>. As discussed in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, this prevents a user from inserting a value in <code>order_number</code> without manually overriding the setting. Generally, you want to prevent such meddling to avoid problems. Let’s say a user were to manually insert a value of <code>4</code> into the <code>order_number</code> column of your existing <code>surrogate_key_example</code> table. That manual insert will not <span epub:type="pagebreak" title="127" id="Page_127"/>increment the <code>IDENTITY</code> sequence for the <code>order_number</code> column; that occurs only when the database generates a new value. Thus, on the next row insert, the database also would try to also insert a <code>4</code>, as that’s the next number in the sequence. The result will be an error, because a duplicate value violates the primary key constraint.</p>&#13;
<p>You can, however, allow manual insertions by restarting the <code>IDENTITY</code> sequence. You might allow this in case you need to insert a row that was mistakenly deleted. <a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a> shows how to add a row to the table that has an <code>order_number</code> of <code>4</code>, which is the next value in the sequence.</p>&#13;
<pre><code>INSERT INTO surrogate_key_example&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> OVERRIDING SYSTEM VALUE&#13;
VALUES (4, 'Chicken Coop', '2021-09-03 10:33-07');&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> ALTER TABLE surrogate_key_example ALTER COLUMN order_number RESTART WITH 5;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> INSERT INTO surrogate_key_example (product_name, order_time)&#13;
VALUES ('Aloe Plant', '2020-03-15 10:09-07');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: Restarting an <code>IDENTITY</code> sequence</p>&#13;
<p>You start with an <code>INSERT</code> statement that includes the keywords <code>OVERRIDING SYSTEM VALUE</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Next we include the <code>VALUES</code> clause and specify the integer <code>4</code> for the first column, <code>order_number</code>, in the <code>VALUES</code> list, which overrides the <code>IDENTITY</code> restriction. We’re using <code>4</code>, but we could choose any number that’s not already present in the column.</p>&#13;
<p>After the insert, you need to reset the <code>IDENTITY</code> sequence so that it begins at a number larger than the <code>4</code> you just inserted. To do this, use an <code>ALTER TABLE ... ALTER COLUMN</code> statement <span class="CodeAnnotation" aria-label="annotation2">2</span> that includes the keywords <code>RESTART WITH 5</code>. An <code>ALTER TABLE</code> modifies tables and columns in various ways, which we’ll explore more thoroughly in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, “Inspecting and Modifying Data.” Here, you use it to change the beginning number of the <code>IDENTITY</code> sequence; so, when the next row gets added to the table, the value for <code>order_number</code> will be <code>5</code>. Finally, insert a new row <span class="CodeAnnotation" aria-label="annotation3">3</span> and omit a value for the <code>order_number</code>, as you did in <a href="#listing8-5">Listing 8-5</a>.</p>&#13;
<p>If you select all rows again from the <code>surrogate_key_example</code> table, you’ll see that the <code>order_number</code> column populated as intended:</p>&#13;
<pre><code>order_number    product_name           order_time&#13;
------------ ------------------- ----------------------&#13;
           1 Beachball Polish    2020-03-15 09:21:00-07&#13;
           2 Wrinkle De-Atomizer 2017-05-22 14:00:00-07&#13;
           3 Flux Capacitor      1985-10-26 01:18:00-07&#13;
           4 Chicken Coop        2021-09-03 10:33:00-07&#13;
           5 Aloe Plant          2020-03-15 10:09:00-07</code></pre>&#13;
<p>This task isn’t one you necessarily want to tackle often, but it’s good to know if the need arises.</p>&#13;
<h3 id="h2-501065c08-0005"><span epub:type="pagebreak" title="128" id="Page_128"/>Foreign Keys</h3>&#13;
<p class="BodyFirst">We use <em>foreign keys</em> to establish relationships between tables. A foreign key is one or more columns whose values match those in another table’s primary key or other unique key. Foreign key values must already exist in the primary key or other unique key of the table it references. If not, the value is rejected. With this constraint, SQL enforces <em>referential integrity</em>—ensuring that data in related tables doesn’t end up unrelated, or orphaned. We won’t end up with rows in one table that have no relation to rows in the other tables we can join them to.</p>&#13;
<p><a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a> shows two tables from a hypothetical database tracking motor vehicle activity.</p>&#13;
<pre><code>CREATE TABLE licenses (&#13;
    license_id text,&#13;
    first_name text,&#13;
    last_name text,&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> CONSTRAINT licenses_key PRIMARY KEY (license_id)&#13;
);&#13;
&#13;
CREATE TABLE registrations (&#13;
    registration_id text,&#13;
    registration_date timestamp with time zone,&#13;
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> license_id text REFERENCES licenses (license_id),&#13;
    CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> INSERT INTO licenses (license_id, first_name, last_name)&#13;
VALUES ('T229901', 'Steve', 'Rothery');&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> INSERT INTO registrations (registration_id, registration_date, license_id)&#13;
VALUES ('A203391', '2022-03-17', 'T229901');&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> INSERT INTO registrations (registration_id, registration_date, license_id)&#13;
VALUES ('A75772', '2022-03-17', 'T000001');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: A foreign key example</p>&#13;
<p>The first table, <code>licenses</code>, uses a driver’s unique <code>license_id</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> as a natural primary key. The second table, <code>registrations</code>, is for tracking vehicle registrations. A single license ID might be connected to multiple vehicle registrations, because each licensed driver can register multiple vehicles—this is called a <em>one-to-many relationship</em> (<span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>). </p>&#13;
<p>Here’s how that relationship is expressed via SQL: in the <code>registrations</code> table, we designate the column <code>license_id</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> as a foreign key by adding the <code>REFERENCES</code> keyword, followed by the table name and column for it to reference.</p>&#13;
<p>Now, when we insert a row into <code>registrations</code>, the database will test whether the value inserted into <code>license_id</code> already exists in the <code>license_id</code> primary key column of the <code>licenses</code> table. If it doesn’t, the database returns an error, which is important. If any rows in <code>registrations</code> didn’t correspond <span epub:type="pagebreak" title="129" id="Page_129"/>to a row in <code>licenses</code>, we’d have no way to write a query to find the person who registered the vehicle.</p>&#13;
<p>To see this constraint in action, create the two tables and execute the <code>INSERT</code> statements one at a time. The first adds a row to <code>licenses</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> that includes the value <code>T229901</code> for the <code>license_id</code>. The second adds a row to <code>registrations</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> where the foreign key contains the same value. So far, so good, because the value exists in both tables. But we encounter an error with the third insert, which tries to add a row to <code>registrations</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> with a value for <code>license_id</code> that’s not in <code>licenses</code>:</p>&#13;
<pre><code>ERROR:  insert or update on table "registrations" violates foreign key constraint "registrations_license_id_fkey"&#13;
DETAIL:  Key (license_id)=(T000001) is not present in table "licenses".</code></pre>&#13;
<p>The resulting error is actually helpful: the database is enforcing referential integrity by preventing a registration for a nonexistent license holder. But it also indicates a few practical implications. First, it affects the order in which we insert data. We cannot add data to a table that contains a foreign key before the other table referenced by the key has the related records, or we’ll get an error. In this example, we’d have to create a driver’s license record before inserting a related registration record (if you think about it, that’s what your local department of motor vehicles probably does).</p>&#13;
<p>Second, the reverse applies when we delete data. To maintain referential integrity, the foreign key constraint prevents us from deleting a row from <code>licenses</code> before removing any related rows in <code>registrations</code>, because doing so would leave an orphaned record. We would have to delete the related row in <code>registrations</code> first and then delete the row in <code>licenses</code>. However, ANSI SQL provides a way to handle this order of operations automatically using the <code>ON DELETE</code> <code>CASCADE</code> keywords.</p>&#13;
<h3 id="h2-501065c08-0006">How to Automatically Delete Related Records with CASCADE</h3>&#13;
<p class="BodyFirst">To delete a row in <code>licenses</code> and have that action automatically delete any related rows in <code>registrations</code>, we can specify that behavior by adding <code>ON DELETE CASCADE</code> when defining the foreign key constraint.</p>&#13;
<p>Here’s how we would modify the <a href="#listing8-7">Listing 8-7</a> <code>CREATE TABLE</code> statement for <code>registrations</code>, adding the keywords at the end of the definition of the <code>license_id</code> column:</p>&#13;
<pre><code>CREATE TABLE registrations (&#13;
    registration_id text,&#13;
    registration_date date,&#13;
    license_id text REFERENCES licenses (license_id) ON DELETE CASCADE,&#13;
    CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)&#13;
);</code></pre>&#13;
<p>Deleting a row in <code>licenses</code> should also delete all related rows in <code>registrations</code>. This allows us to delete a driver’s license without first having to manually remove any registrations linked to it. It also maintains data integrity by ensuring deleting a license doesn’t leave orphaned rows in <code>registrations</code>.</p>&#13;
<h3 id="h2-501065c08-0007"><span epub:type="pagebreak" title="130" id="Page_130"/>The CHECK Constraint</h3>&#13;
<p class="BodyFirst">A <code>CHECK</code> constraint evaluates whether data added to a column meets the expected criteria, which we specify with a logical test. If the criteria aren’t met, the database returns an error. The <code>CHECK</code> constraint is extremely valuable because it can prevent columns from getting loaded with nonsensical data. For example, a baseball player’s total number of hits shouldn’t be negative, so you should limit that data to values of zero or greater. Or, in most schools, <code>Z</code> isn’t a valid letter grade for a course (although my barely passing algebra grade felt like it), so we might insert constraints that only accept the values A–F.</p>&#13;
<p>As with primary keys, we can implement a <code>CHECK</code> constraint at the column or table level. For a column constraint, declare it in the <code>CREATE TABLE</code> statement after the column name and data type: <code>CHECK (</code><var>logical expression</var><code>)</code>. As a table constraint, use the syntax <code>CONSTRAINT </code><var>constraint_name</var><code> CHECK (</code><var>logical expression</var><code>)</code> after all columns are defined.</p>&#13;
<p><a href="#listing8-8" id="listinganchor8-8">Listing 8-8</a> shows a <code>CHECK</code> constraint applied to two columns in a table we might use to track the user role and salary of employees within an organization. It uses the table constraint syntax for the primary key and the <code>CHECK</code> constraint.</p>&#13;
<pre><code>CREATE TABLE check_constraint_example (&#13;
    user_id bigint GENERATED ALWAYS AS IDENTITY,&#13;
    user_role text,&#13;
    salary numeric(10,2),&#13;
    CONSTRAINT user_id_key PRIMARY KEY (user_id),&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> CONSTRAINT check_role_in_list CHECK (user_role IN('Admin', 'Staff')),&#13;
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> CONSTRAINT check_salary_not_below_zero CHECK (salary &gt;= 0)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: Examples of <code>CHECK</code> constraints</p>&#13;
<p>We create the table and set the <code>user_id</code> column as an auto-incrementing surrogate primary key. The first <code>CHECK</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> tests whether values entered into the <code>user_role</code> column match one of two predefined strings, <code>Admin</code> or <code>Staff</code>, by using the SQL <code>IN</code> operator. The second <code>CHECK</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> tests whether values entered in the <code>salary</code> column are greater than or equal to 0, because a negative amount wouldn’t make sense. Both tests are an example of a <em>Boolean expression</em>, a statement that evaluates as either true or false. If a value tested by the constraint evaluates as <code>true</code>, the check passes.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Developers may differ on whether check logic belongs in the database, in the application in front of the database, such as a human resources system, or both. One advantage of checks in the database is that the database will maintain data integrity in the case of changes to the application, new applications that use the database, or users directly accessing the database.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>When values are inserted or updated, the database checks them against the constraint. If the values in either column violate the constraint—or, <span epub:type="pagebreak" title="131" id="Page_131"/>for that matter, if the primary key constraint is violated—the database will reject the change.</p>&#13;
<p>If we use the table constraint syntax, we also can combine more than one test in a single <code>CHECK</code> statement. Say we have a table related to student achievement. We could add the following:</p>&#13;
<pre><code>CONSTRAINT grad_check CHECK (credits &gt;= 120 AND tuition = 'Paid')</code></pre>&#13;
<p>Notice that we combine two logical tests by enclosing them in parentheses and connecting them with <code>AND</code>. Here, both Boolean expressions must evaluate as <code>true</code> for the entire check to pass. You can also test values across columns, as in the following example where we want to make sure an item’s sale price is a discount on the original, assuming we have columns for both values:</p>&#13;
<pre><code>CONSTRAINT sale_check CHECK (sale_price &lt; retail_price)</code></pre>&#13;
<p>Inside the parentheses, the logical expression checks that the sale price is less than the retail price.</p>&#13;
<h3 id="h2-501065c08-0008">The UNIQUE Constraint</h3>&#13;
<p class="BodyFirst">We can also ensure that a column has a unique value in each row by using the <code>UNIQUE</code> constraint. If ensuring unique values sounds similar to the purpose of a primary key, it is. But <code>UNIQUE</code> has one important difference. In a primary key, no values can be <code>NULL</code>, but a <code>UNIQUE</code> constraint permits multiple <code>NULL</code> values in a column. This is useful in cases where we won’t always have values but want to ensure that the ones we do have are unique.</p>&#13;
<p>To show the usefulness of <code>UNIQUE</code>, look at the code in <a href="#listing8-9" id="listinganchor8-9">Listing 8-9</a>, which is a table for tracking contact info.</p>&#13;
<pre><code>CREATE TABLE unique_constraint_example (&#13;
    contact_id bigint GENERATED ALWAYS AS IDENTITY,&#13;
    first_name text,&#13;
    last_name text,&#13;
    email text,&#13;
    CONSTRAINT contact_id_key PRIMARY KEY (contact_id),&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> CONSTRAINT email_unique UNIQUE (email)&#13;
);&#13;
&#13;
INSERT INTO unique_constraint_example (first_name, last_name, email)&#13;
VALUES ('Samantha', 'Lee', 'slee@example.org');&#13;
&#13;
INSERT INTO unique_constraint_example (first_name, last_name, email)&#13;
VALUES ('Betty', 'Diaz', 'bdiaz@example.org');&#13;
&#13;
INSERT INTO unique_constraint_example (first_name, last_name, email)&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> VALUES ('Sasha', 'Lee', 'slee@example.org');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: A <code>UNIQUE</code> constraint example</p>&#13;
<p><span epub:type="pagebreak" title="132" id="Page_132"/>In this table, <code>contact_id</code> serves as a surrogate primary key, uniquely identifying each row. But we also have an <code>email</code> column, the main point of contact with each person. We’d expect this column to contain only unique email addresses, but those addresses might change over time. So, we use <code>UNIQUE</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to ensure that any time we add or update a contact’s email, we’re not providing one that already exists. If we try to insert an email that already exists <span class="CodeAnnotation" aria-label="annotation2">2</span>, the database will return an error:</p>&#13;
<pre><code>ERROR:  duplicate key value violates unique constraint "email_unique"&#13;
DETAIL:  Key (email)=(slee@example.org) already exists.</code></pre>&#13;
<p>Again, the error shows the database is working for us.</p>&#13;
<h3 id="h2-501065c08-0009">The NOT NULL Constraint</h3>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you learned about <code>NULL</code>, a special SQL value that represents missing data or unknown values. We know that <code>NULL</code> is not allowed for primary key values because they need to uniquely identify each row in a table. But there may be other times when you’ll want to disallow empty values in a column. For example, in a table listing each student in a school, requiring that columns containing first and last names be filled for each row makes sense. To require a value in a column, SQL provides the <code>NOT NULL</code> constraint, which simply prevents a column from accepting empty values.</p>&#13;
<p><a href="#listing8-10" id="listinganchor8-10">Listing 8-10</a> demonstrates the <code>NOT NULL</code> syntax.</p>&#13;
<pre><code>CREATE TABLE not_null_example (&#13;
    student_id bigint GENERATED ALWAYS AS IDENTITY,&#13;
    first_name text NOT NULL,&#13;
    last_name text NOT NULL,&#13;
    CONSTRAINT student_id_key PRIMARY KEY (student_id)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-10">Listing 8-10</a>: A <code>NOT NULL</code> constraint example</p>&#13;
<p>Here, we declare <code>NOT NULL</code> for the <code>first_name</code> and <code>last_name</code> columns because it’s likely we’d require those pieces of information in a table tracking student information. If we attempt an <code>INSERT</code> on the table and don’t include values for those columns, the database will notify us of the violation.</p>&#13;
<h3 id="h2-501065c08-0010">How to Remove Constraints or Add Them Later</h3>&#13;
<p class="BodyFirst">You can remove a constraint or later add one to an existing table using <code>ALTER TABLE</code>, the command you used earlier in the chapter in “Creating an Auto-incrementing Surrogate Key” to reset the <code>IDENTITY</code> sequence.</p>&#13;
<p>To remove a primary key, foreign key, or <code>UNIQUE</code> constraint, you write an <code>ALTER TABLE</code> statement in this format:</p>&#13;
<pre><code>ALTER TABLE <var>table_name</var> DROP CONSTRAINT <var>constraint_name</var>;</code></pre>&#13;
<p><span epub:type="pagebreak" title="133" id="Page_133"/>To drop a <code>NOT NULL</code> constraint, the statement operates on the column, so you must use the additional <code>ALTER COLUMN</code> keywords, like so:</p>&#13;
<pre><code>ALTER TABLE <var>table_name</var> ALTER COLUMN <var>column_name</var> DROP NOT NULL;</code></pre>&#13;
<p>Let’s use these statements to modify the <code>not_null_example</code> table you just made, as shown in <a href="#listing8-11" id="listinganchor8-11">Listing 8-11</a>.</p>&#13;
<pre><code>ALTER TABLE not_null_example DROP CONSTRAINT student_id_key;&#13;
ALTER TABLE not_null_example ADD CONSTRAINT student_id_key PRIMARY KEY (student_id);&#13;
ALTER TABLE not_null_example ALTER COLUMN first_name DROP NOT NULL;&#13;
ALTER TABLE not_null_example ALTER COLUMN first_name SET NOT NULL;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-11">Listing 8-11</a>: Dropping and adding a primary key and a <code>NOT NULL</code> constraint</p>&#13;
<p>Execute the statements one at a time. Each time, you can view the changes to the table definition in pgAdmin by clicking the table name once and then clicking the <b>SQL</b> tab above the query window. (Note that it will display a more verbose syntax for the table definition than what you used when creating the table.)</p>&#13;
<p>With the first <code>ALTER TABLE</code> statement, we use <code>DROP CONSTRAINT</code> to remove the primary key named <code>student_id_key</code>. We then add the primary key back using <code>ADD CONSTRAINT</code>. We’d use that same syntax to add a constraint to any existing table.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	You can add a constraint to an existing table only if the data in the target column obeys the limits of the constraint. For example, you can’t place a primary key constraint on a column that has duplicate or empty values.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>In the third statement, <code>ALTER COLUMN</code> and <code>DROP NOT NULL</code> remove the <code>NOT NULL</code> constraint from the <code>first_name</code> column. Finally, <code>SET NOT NULL</code> adds the constraint.</p>&#13;
<h2 id="h1-501065c08-0003">Speeding Up Queries with Indexes</h2>&#13;
<p class="BodyFirst">In the same way that a book’s index helps you find information more quickly, you can speed up queries by adding an <em>index</em>—a separate data structure the database manages—to one or more columns in a table. The database uses the index as a shortcut rather than scanning each row to find data. That’s admittedly a simplistic picture of what, in SQL databases, is a nontrivial topic. We could spend several chapters delving into the workings of SQL indexes and tuning databases for performance, but instead I’ll offer general guidance on using indexes and a PostgreSQL-specific example that demonstrates their benefits.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The ANSI SQL standard doesn’t specify a syntax for creating indexes, nor does it specify how a database system should implement them. Nevertheless, indexes are a feature of all major database systems, including Microsoft SQL Server, MySQL, Oracle, and SQLite, with similarities to the syntax and behavior described here.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c08-0011"><span epub:type="pagebreak" title="134" id="Page_134"/>B-Tree: PostgreSQL’s Default Index</h3>&#13;
<p class="BodyFirst">You’ve already created several indexes, perhaps without knowing. Each time you add a primary key or <code>UNIQUE</code> constraint, PostgreSQL (as well as most database systems) creates an index on the column or columns included in the constraint. Indexes are stored separately from the table data and are accessed automatically (if needed) when you run a query and updated every time a row is added, removed, or updated.</p>&#13;
<p>In PostgreSQL, the default index type is the <em>B-tree index</em>. It’s created automatically on the columns designated for the primary key or a <code>UNIQUE</code> constraint, and it’s also the type created by default with the <code>CREATE INDEX</code> statement. B-tree, short for <em>balanced tree</em>, is so named because when you search for a value, the structure looks from the top of the tree down through branches until it locates the value. (Of course, the process is a lot more complicated than that.) A B-tree index is useful for data that can be ordered and searched using equality and range operators, such as <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>&gt;=</code>, <code>&gt;</code>, and <code>BETWEEN</code>. It also works with <code>LIKE</code> if there’s no wildcard in the pattern at the beginning of the search string. An example is <code>WHERE chips LIKE 'Dorito%'</code>.</p>&#13;
<p>PostgreSQL also supports additional index types, such as the <em>Generalized Inverted Index (GIN)</em> and the <em>Generalized Search Tree</em> <em>(GiST)</em>. Each has distinct uses, and I’ll incorporate them in later chapters on full-text search and queries using geometry types.</p>&#13;
<p>For now, let’s see a B-tree index speed up a simple search query. For this exercise, we’ll use a large dataset comprising more than 900,000 New York City street addresses, compiled by the OpenAddresses project at <a href="https://openaddresses.io/" class="LinkURL">https://openaddresses.io/</a>. The file with the data, <em>city_of_new_york.csv</em>, is available for you to download along with all the resources for this book from <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<p>After you’ve downloaded the file, use the code in <a href="#listing8-12" id="listinganchor8-12">Listing 8-12</a> to create a <code>new_york_addresses</code> table and import the address data. The import will take longer than the tiny datasets you’ve loaded so far because the CSV file is about 50MB.</p>&#13;
<pre><code>CREATE TABLE new_york_addresses (&#13;
    longitude numeric(9,6),&#13;
    latitude numeric(9,6),&#13;
    street_number text,&#13;
    street text,&#13;
    unit text,&#13;
    postcode text,&#13;
    id integer CONSTRAINT new_york_key PRIMARY KEY&#13;
);&#13;
&#13;
COPY new_york_addresses&#13;
FROM '<em>C:\YourDirectory\</em>city_of_new_york.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-12">Listing 8-12</a>: Importing New York City address data</p>&#13;
<p>When the data loads, run a quick <code>SELECT</code> query to visually check that you have 940,374 rows and seven columns. A common use for this data might <span epub:type="pagebreak" title="135" id="Page_135"/>be to search for matches in the <code>street</code> column, so we’ll use that example for exploring index performance.</p>&#13;
<h4 id="h3-501065c08-0007">Benchmarking Query Performance with EXPLAIN</h4>&#13;
<p class="BodyFirst">We’ll measure the performance before and after adding an index by using the PostgreSQL-specific <code>EXPLAIN</code> command, which lists the <em>query plan</em> for a specific database query. The query plan might include how the database plans to scan the table, whether or not it will use indexes, and so on. When we add the <code>ANALYZE</code> keyword, <code>EXPLAIN</code> will carry out the query and show the actual execution time.</p>&#13;
<h4 id="h3-501065c08-0008">Recording Some Control Execution Times</h4>&#13;
<p class="BodyFirst">We’ll use the three queries in <a href="#listing8-13" id="listinganchor8-13">Listing 8-13</a> to analyze query performance before and after adding an index. We’re using typical <code>SELECT</code> queries with a <code>WHERE</code> clause with <code>EXPLAIN ANALYZE</code> included at the beginning. These keywords tell the database to execute the query and display statistics about the query process and how long it took to execute, rather than show the results.</p>&#13;
<pre><code>EXPLAIN ANALYZE SELECT * FROM new_york_addresses&#13;
WHERE street = 'BROADWAY';&#13;
&#13;
EXPLAIN ANALYZE SELECT * FROM new_york_addresses&#13;
WHERE street = '52 STREET';&#13;
&#13;
EXPLAIN ANALYZE SELECT * FROM new_york_addresses&#13;
WHERE street = 'ZWICKY AVENUE';</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-13">Listing 8-13</a>: Benchmark queries for index performance</p>&#13;
<p>On my system, the first query returns these stats in the pgAdmin output pane:</p>&#13;
<pre><code>Gather (cost=1000.00..15184.08 rows=3103 width=46) (actual time=9.000..388.448 rows=3336 loops=1)&#13;
  Workers Planned: 2&#13;
  Workers Launched: 2&#13;
  -&gt;  Parallel Seq Scan on new_york_addresses  (cost=0.00..13873.78 <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
     rows=1293 width=46) (actual time=2.362..367.258 rows=1112 loops=3)&#13;
        Filter: (street = 'BROADWAY'::text)&#13;
        Rows Removed by Filter: 312346&#13;
Planning Time: 0.401 ms&#13;
Execution Time: 389.232 ms <span class="CodeAnnotationCode" aria-label="annotation2">2</span></code></pre>&#13;
<p>Not all the output is relevant here, so I won’t decode it all, but two lines are pertinent. The first indicates that to find any rows where <code>street = 'BROADWAY'</code>, the database will conduct a sequential scan <span class="CodeAnnotation" aria-label="annotation1">1</span> of the table. That’s a synonym for a full table scan: the database will examine each row and remove any where <code>street</code> doesn’t match <code>BROADWAY</code>. The execution time (on my computer about 389 milliseconds) <span class="CodeAnnotation" aria-label="annotation2">2</span> is how long the query took to run. Your time will depend on factors including your computer hardware.</p>&#13;
<p><span epub:type="pagebreak" title="136" id="Page_136"/>For the test, run each query in <a href="#listing8-13">Listing 8-13</a> several times and record the fastest execution time for each. You’ll notice that execution times for the same query will vary slightly on each run. That can be the result of several factors, from other processes running on the server to the effect of data being held in memory after a prior run of the query.</p>&#13;
<h4 id="h3-501065c08-0009">Adding the Index</h4>&#13;
<p class="BodyFirst">Now, let’s see how adding an index changes the query’s search method and execution time. <a href="#listing8-14" id="listinganchor8-14">Listing 8-14</a> shows the SQL statement for creating the index with PostgreSQL.</p>&#13;
<pre><code>CREATE INDEX street_idx ON new_york_addresses (street);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-14">Listing 8-14</a>: Creating a B-tree index on the <code>new_york_addresses</code> table</p>&#13;
<p>Notice that it’s similar to the commands for creating constraints. We give the <code>CREATE INDEX</code> keywords followed by a name we choose for the index, in this case <code>street_idx</code>. Then <code>ON</code> is added, followed by the target table and column.</p>&#13;
<p>Execute the <code>CREATE INDEX</code> statement, and PostgreSQL will scan the values in the <code>street</code> column and build the index from them. We need to create the index only once. When the task finishes, rerun each of the three queries in <a href="#listing8-13">Listing 8-13</a> and record the execution times reported by <code>EXPLAIN ANALYZE</code>. Here’s an example:</p>&#13;
<pre><code>Bitmap Heap Scan on new_york_addresses  (cost=76.47..6389.39 rows=3103 width=46) (actual time=1.355..4.802 rows=3336 loops=1)&#13;
  Recheck Cond: (street = 'BROADWAY'::text)&#13;
  Heap Blocks: exact=2157&#13;
  -&gt;  Bitmap Index Scan on street_idx  (cost=0.00..75.70 rows=3103 width=0) <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
      (actual time=0.950..0.950 rows=3336 loops=1)&#13;
        Index Cond: (street = 'BROADWAY'::text)&#13;
Planning Time: 0.109 ms&#13;
Execution Time: 5.113 ms <span class="CodeAnnotationCode" aria-label="annotation2">2</span></code></pre>&#13;
<p>Do you notice a change? First, we see that the database is now using an index scan on <code>street_idx</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> instead of visiting each row in a sequential scan. Also, the query speed is now markedly faster <span class="CodeAnnotation" aria-label="annotation2">2</span>. <a href="#table8-1" id="tableanchor8-1">Table 8-1</a> shows the fastest execution times (rounded) from my computer before and after adding the index.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: Measuring Index Performance</p></figcaption>&#13;
<table id="table-501065c08-0001" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Query filter</b></td>&#13;
<td><b>Before index</b></td>&#13;
<td><b>After index</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>WHERE street = 'BROADWAY'</code></td>&#13;
<td>92 ms</td>&#13;
<td>5 ms</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>WHERE street = '52 STREET'</code></td>&#13;
<td>94 ms</td>&#13;
<td>1 ms</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>WHERE street = 'ZWICKY AVENUE'</code></td>&#13;
<td>93 ms</td>&#13;
<td>&lt;1 ms</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" title="137" id="Page_137"/>The execution times are much, much better, nearly a tenth of a second faster or more per query. Is a tenth of a second that impressive? Well, whether you’re seeking answers in data using repeated querying or creating a database system for thousands of users, the time savings adds up.</p>&#13;
<p>If you ever need to remove an index from a table—perhaps if you’re testing the performance of several index types—use the <code>DROP INDEX</code> command followed by the name of the index to remove.</p>&#13;
<h3 id="h2-501065c08-0012">Considerations When Using Indexes</h3>&#13;
<p class="BodyFirst">You’ve seen that indexes have significant performance benefits, so does that mean you should add an index to every column in a table? Not so fast! Indexes are valuable, but they’re not always needed. In addition, they do enlarge the database and impose a maintenance cost on writing data. Here are a few tips for judging when to uses indexes:</p>&#13;
<ul>&#13;
<li>Consult the documentation for the database system you’re using to learn about the kinds of indexes available and which to use on particular data types. PostgreSQL, for example, has five more index types in addition to B-tree. One, called GiST, is particularly suited to the geometry data types discussed later in the book. Full-text search, which you’ll learn in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>, also benefits from indexing.</li>&#13;
<li>Consider adding indexes to columns you’ll use in table joins. Primary keys are indexed by default in PostgreSQL, but foreign key columns in related tables are not and are a good target for indexes.</li>&#13;
<li>An index on a foreign key will help avoid an expensive sequential scan during a cascading delete.</li>&#13;
<li>Add indexes to columns that will frequently end up in a query <code>WHERE</code> clause. As you’ve seen, search performance is significantly improved via indexes.</li>&#13;
<li>Use <code>EXPLAIN ANALYZE</code> to test the performance under a variety of configurations. Optimization is a process! If an index isn’t being used by the database—and it’s not backing up a primary key or other constraint—you can drop it to reduce the size of your database and speed up inserts, updates, and deletes.</li>&#13;
</ul>&#13;
<h2 id="h1-501065c08-0004">Wrapping Up</h2>&#13;
<p class="BodyFirst">With the tools you’ve added to your toolbox in this chapter, you’re ready to ensure that the databases you build or inherit are best suited for your collection and exploration of data. It’s crucial to define constraints that match the data and the expectation of users by not allowing values that don’t make sense, making sure values are filled in, and setting up proper relationships between tables. You’ve also learned how to make your queries run faster and how to consistently organize your database objects. That’s a boon for you and for others who share your data.</p>&#13;
<p><span epub:type="pagebreak" title="138" id="Page_138"/>This chapter concludes the first part of the book, which focused on giving you the essentials to dig into SQL databases. We’ll continue building on these foundations as we explore more complex queries and strategies for data analysis. In the next chapter, we’ll use SQL aggregate functions to assess the quality of a dataset and get usable information from it.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>Try it Yourself</h2>&#13;
<p class="BoxBodyFirst">Are you ready to test yourself on the concepts covered in this chapter? Consider the following two tables from a database you’re making to keep track of your vinyl LP collection. Start by reviewing these <code>CREATE TABLE</code> statements:</p>&#13;
<pre><code>CREATE TABLE albums (&#13;
    album_id bigint GENERATED ALWAYS AS IDENTITY,&#13;
    catalog_code text,&#13;
    title text,&#13;
    artist text,&#13;
    release_date date,&#13;
    genre text,&#13;
    description text&#13;
);&#13;
&#13;
CREATE TABLE songs (&#13;
    song_id bigint GENERATED ALWAYS AS IDENTITY,&#13;
    title text,&#13;
    composers text,&#13;
    album_id bigint&#13;
);</code></pre>&#13;
<p>The <code>albums</code> table includes information specific to the overall collection of songs on the disc. The <code>songs</code> table catalogs each track on the album. Each song has a title and a column for its composers, who might be different than the album artist.</p>&#13;
<p>Use the tables to answer these questions:</p>&#13;
<ol>&#13;
<li value="1">Modify these <code>CREATE TABLE</code> statements to include primary and foreign keys plus additional constraints on both tables. Explain why you made your choices.</li>&#13;
<li value="2">Instead of using <code>album_id</code> as a surrogate key for your primary key, are there any columns in <code>albums</code> that could be useful as a natural key? What would you have to know to decide?</li>&#13;
<li value="3">To speed up queries, which columns are good candidates for indexes?</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>