- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GRAPH
    COLORING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Graph coloring* is a conceptually simple but computationally complex problem
    with a range of real-world applications. At its core, it consists of assigning
    a color to each node in an undirected graph such that no pair of nodes sharing
    an edge have the same color. Variations of this problem include minimizing the
    number of colors used or finding an assignment using only a fixed number of colors.'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily visualize the importance of the graph-coloring problem in terms
    of a map of Europe. We need to assign each country a color such that no two adjacent
    countries have the same color. If we use green for both France and Belgium, viewers
    may not be able to see the border. Beyond maps, the constraints enforced by the
    graph-coloring problem lend themselves to a range of real-world optimization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins by formally defining the graph-coloring problem and discussing
    real-world use cases in more depth. We then examine several approaches to solving
    the task and discuss why the problem of using a fixed number of colors (or minimizing
    the number used) is surprisingly difficult.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Graph-Coloring Problem</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *graph-coloring problem* consists of assigning colors to each of the |*V*
    | nodes in an undirected graph such that no two nodes sharing an edge have the
    same color. Formally, we can define the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a graph, defined by a set of nodes *V* and edges *E*, and a set of colors
    *C*, find an assignment of nodes to colors such that for any two nodes *u* ∈*V*
    and *v* ∈*V* connected by an edge, (*u*, *v*) ∈ *E*, then *color*(*u*) ≠ *color*(*v*).
  prefs: []
  type: TYPE_NORMAL
- en: We can define the *minimum graph-coloring problem* as finding the minimum number
    of colors such that a graph has a valid graph coloring.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we use the graph node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    field to store the color for that node. Colors will be represented by integers
    starting at 1, with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    indicating an unassigned node (<samp class="SANS_TheSansMonoCd_W5Regular_11">node.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-1](#list16-1) defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">is_graph_coloring_valid()</samp>
    function that checks whether a graph has a valid coloring. This checker both provides
    a good overview of the mechanics of the graph-coloring problem and is also a helpful
    utility function for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Checking whether
    a graph’s coloring is valid</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate through each node in the graph, first checking whether the node has
    any color assigned ❶. If not, the graph’s coloring is incomplete and thus invalid.
    If the node does have a color, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate through each of the node’s neighbors and check whether the two
    nodes share a color ❷. If two neighbors share a color, the coloring is invalid,
    and the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    If the code makes it through every neighbor for every node without finding a match,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We represent different node colors in the illustrations in this chapter using
    hashing arranged in different orientations, as shown in [Figure 16-1](#fig16-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). Node 0 has vertical hashing and is labeled with the color
    1, while its neighbor node 1 has horizontal hashing and is labeled with the color
    2.](../images/f16001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: A graph with a
    valid assignment of colors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For the figures in this chapter, we’ll note the color number outside each node
    and number the colors starting from 1.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the graph-coloring formulation to model a range of real-world problems,
    including coloring maps, making seating arrangements at conferences, assigning
    parking spaces, and protecting valuable treasure within a labyrinth.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring Maps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The classic use case for graph coloring stems from the daily needs of cartographers
    and map publishers throughout the world. To distinguish areas on a map, different
    regions must be shaded with different colors. For a map of New England like that
    shown in [Figure 16-2](#fig16-2), we might choose to color Connecticut in green
    and Rhode Island in orange.
  prefs: []
  type: TYPE_NORMAL
- en: '![A map showing the six states in New England with a graph overlaid. The node
    MA has neighbors CT, RI, VT, and NH.](../images/f16002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: A map of New England
    and the overlaid graph representation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can translate the map-coloring problem into a graph-coloring problem by creating
    a node for each region and adding edges between any two regions that share a border.
    In [Figure 16-2](#fig16-2), the Rhode Island node has edges to the nodes for both
    Connecticut and Massachusetts. The cartographer’s goal then becomes finding a
    valid graph coloring.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing Seating
    Arrangements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The annual convention of Coffee-Drinking Data Structure Enthusiasts is a joyous
    but surprisingly political affair. Deep divergences exist within the community
    in terms of preferences for both coffee and data structures, including rivalries
    between the light and dark roast camps, over 30 different groups of loudly declared
    favorite data structures, and the inevitable fighting over programming languages
    that finds a way into any discussion about computer science. Not all differences
    in preference lead to an argument, but the ones that do result in hours of pedantic
    shouting. Every year the organizers face the daunting task of assigning tables
    at the opening banquet such that there will be no loud feuds.
  prefs: []
  type: TYPE_NORMAL
- en: The organizers have long used this gathering as an opportunity to test new graph-coloring
    algorithms. Modeling each attendee as a node and a strong difference in opinion
    as an edge, the Conference Chair for Banquet Seating tries to find an assignment
    of attendees to tables such that no two people at the same table have a strong
    disagreement. The nodes’ colors are the table assignments.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case, the organizer could break up the tables into the smallest
    coherent factions. They might assign a table for the sole espresso-drinking, Fortran-writing
    hash table fan in attendance. This is equivalent to assigning the node a completely
    unique color. However, this approach is needlessly wasteful, resulting in almost
    as many tables as attendees. The aforementioned hash table fan gets along quite
    well with espresso and dark roast coffee drinkers, users of Fortran or Cobol,
    and aficionados of most data structures. The Conference Chair’s goal is to minimize
    the number of tables (graph colors) while ensuring that no shouting matches ensue.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Parking
    Spaces</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Data Structures and Coffee bookstore sees a consistent stream of customers
    throughout the day. To meet demand, the owners decide to bring on more staff.
    After extensive interviews, the owners hire six employees. They draw up a schedule
    with those new hires working set shifts throughout the day as shown in [Figure
    16-3(a)](#fig16-3). One question remains, however: How many parking spaces should
    they set aside for staff?'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a chart with size bars spanning different horizontal ranges. (b)
    shows a graph with six nodes with edges connecting nodes whose bars overlap.](../images/f16003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: Employee work
    times (a) and the corresponding graph of parking conflicts (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using their data structures expertise, the owners quickly reduce the question
    to a graph-coloring problem. As shown in [Figure 16-3(b)](#fig16-3), each employee
    becomes a node in the graph with edges between any two employees whose schedules
    overlap and thus will need parking spaces at the same time. For example, the schedule
    of employee 1 overlaps with that of employees 2, 3, and 5\. However, it does not
    overlap with employees 0 or 4, which means that employee 1 could share a parking
    space with either of the latter two employees. If the owners can find a graph
    coloring containing at most *C* colors, then they can safely reserve at most *C*
    parking spaces.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Magical
    Labyrinths</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An evil wizard decides to construct a magical labyrinth to protect their most
    prized possession, a horn that plays their favorite song. Seeking to protect the
    Horn of Beautiful Music from relentless adventurers, the wizard fills their labyrinth
    with an assortment of traps and monsters.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard quickly runs into a problem, however. Due to the large number of
    passageways (edges), many of the rooms (nodes) connect. They do not want to be
    seen as lazy by having the same monsters in two adjacent rooms. Skill in labyrinth
    creation is a reputational necessity; even the most junior adventurers lose respect
    for architects who fill room after room with the same challenges. Yet the wizard
    is looking to keep costs down by bulk-ordering monsters. They need to determine
    the smallest number of monsters (colors) they can use such that no two adjacent
    rooms contain the same monster.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Graph-Coloring Algorithms</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computer scientists and mathematicians have developed a range of algorithms
    to solve graph-coloring problems. However, each solution comes with trade-offs.
    Some algorithms use heuristics that find solutions but might require too many
    colors; others are expensive on large graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph coloring is an *NP-hard problem*, which informally means that there is
    no known algorithm whose worst-case running time scales as polynomial with respect
    to the size of the data. There is literally an exponential number of states to
    consider: |*V* |*^C* states for a problem with |*V* | nodes and *C* colors. Yet
    it is not all bad news. While this problem is constrained by its behavior in worst-case
    scenarios, many of the algorithms perform well in practice and can be applied
    to numerous everyday problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms in this section search for valid graph colorings. If they find
    one, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to
    indicate their success and set the color assignments in the nodes’ <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    field, rather than returning the assignments in a separate data structure. The
    algorithms return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if
    they are unable to find a valid set of assignments.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive
    Search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *exhaustive search* through all possible node-to-color assignments is a
    comprehensive approach that is guaranteed to find a valid graph coloring if one
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">product</samp>
    function of Python’s itertools package to enumerate every possible combination
    of color assignments ❶. Initially, every value of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    is assigned to the first color (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    During each iteration, the counter changes.
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the code copies the assignments into the node labels ❷ and checks whether
    they are valid ❸. If so, it immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    to indicate it has found a solution. Otherwise, the loop continues forward to
    the next combination. If the code does not find a successful combination, it returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Before doing so, it
    resets all the node’s label assignments to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    because there is no valid coloring ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the cost of an exhaustive search can be prohibitively expensive as
    the size of the graph grows. If the graph has |*V* | nodes and uses *C* colors,
    we could end up testing |*V* |*^C* assignments before either finding a valid one
    or determining that no *C*-color assignment will work. [Figure 16-4](#fig16-4)
    shows the first six iterations of an exhaustive search with three colors on the
    five-node graph from [Figure 16-1](#fig16-1). The search starts with all nodes
    the same color, as shown in [Figure 16-4(a)](#fig16-4), and moves through the
    assignments.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph where all nodes have vertical
    hashing and are labeled with color = 1 for assignments of [1, 1, 1, 1, 1]. (B)
    shows the same graph with node 0 now with horizontal hashing and labeled with
    color = 2 for assignments of [2, 1, 1, 1, 1]. (C) shows assignments of [1, 2,
    1, 1, 1]. (D) shows assignments of [2, 2, 1, 1, 1]. (E) shows assignments of [1,
    1, 2, 1, 1]. (F) shows assignments of [2, 1, 2, 1, 1].](../images/f16004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: The first six
    iterations of an exhaustive search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 16-4](#fig16-4), exhaustive search can waste a significant
    amount of time checking one obvious bad state after another. It provides simplicity
    and completeness at the cost of efficiency. Unless our graph has no edges, it’s
    clearly not possible for all the nodes to share the same color. Imagine the frustration
    of a human using this approach as they are forced to test yet another combination
    they know won’t work because there is a clear conflict somewhere else in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking Search</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can also implement the iterator-based exhaustive search from the previous
    section using a *recursive backtracking search*. Unlike the depth-first searches
    used in earlier chapters, especially [Chapter 4](chapter4.xhtml), this backtracking
    search does not explore individual nodes through their neighbors. Instead, the
    search state is the set of color assignments itself. We recursively explore all
    possible assignments of colors to nodes, backtracking when the solution is infeasible.
    Each state in our search corresponds to a partial assignment of colors to nodes,
    as shown in [Figure 16-5](#fig16-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree of options. The root level shows five blank spaces. The next level
    contains nodes filling the first entry with 1, 2, 3\. The second level shows the
    first three nodes with the first entry set to 1 and the second entry set to 1,
    2, and 3, respectively.](../images/f16005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: A backtracking
    search branching out over different assignments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can first model the same search space as the iterator-based exhaustive search,
    using a depth-first search without any pruning (we’ll improve on this approach
    shortly). This search progresses to an adjacent state by assigning a color to
    the next unassigned node, as shown in [Listing 16-2](#list16-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: A recursive exhaustive
    search of color assignments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_dfs()</samp> code
    uses a recursive search to assign each color to each node. It starts with the
    base case, checking whether all nodes have been assigned and, if so, whether the
    assignment is valid. If there are more nodes to assign, then the code iterates
    through all possible colors for the current node. For each color, the code then
    continues the recursive search on the next node (by index). It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if the assignment leads to a valid solution ❶. If the search has not found a valid
    assignment, it resets the current node’s color to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    ❷ and backtracks by returning <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The backtracking search implementation in [Listing 16-2](#list16-2) is only
    an alternative implementation of the iterator-based exhaustive search. It doesn’t
    improve efficiency. [Figure 16-6](#fig16-6) shows how the search will iterate
    through the same first dead end as did the exhaustive search in [Figure 16-4](#fig16-4).
    After it progresses all the way to the dead end in [Figure 16-6(e)](#fig16-6),
    the algorithm backtracks and tries a new assignment for node 4, as shown in [Figure
    16-6(f)](#fig16-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with
    color = 1\. (B) shows the same graph with node 0 labeled with color = 1 and node
    1 labeled with color = 1\. (C) shows assignments [1, 1, 1, None, None]. (D) shows
    the assignments [1, 1, 1, 1, None]. (E) shows the assignments [1, 1, 1, 1, 1].
    (F) shows the assignments [1, 1, 1, 1, 2].](../images/f16006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: The first six
    steps of the backtracking search coloring on a graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, we can modify this search to greatly improve efficiency by *pruning*
    early and exploring only valid paths. Before assigning a color to a node, we can
    check whether that assignment produces a conflict. If so, we can skip not only
    that assignment but also all later recursions from it, as shown in [Figure 16-7](#fig16-7),
    where we skip the entire subtree of possibilities stemming from assigning color
    = 1 to both nodes 0 and 1\. Instead, once we have assigned color = 1 to node 0,
    we consider only colors 2 and 3 for the adjacent node 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree where each node shows the five-node graph with some of the colors
    filled in. The root has no nodes colored. Its children consist of graphs with
    colors 1, 2, and 3, respectively. The tree node where both nodes 0 and 1 are assigned
    color 1 is grayed out and the branch is crossed out.](../images/f16007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: The first few
    steps of a backtracking search with pruning for graph coloring</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for *backtracking search with pruning* requires a small change. Before
    assigning a color to a node, we check whether any neighbors already have that
    assignment. This simple check prevents us from progressing down deep dead ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code again starts with the base case, checking whether all nodes have been
    assigned and, if so, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    The code does not need to check for the validity of the current assignment, because
    it will do that before assigning each color.
  prefs: []
  type: TYPE_NORMAL
- en: If there are more nodes to explore (assign), then the code iterates through
    all the possible colors for the current node. It first checks whether any neighboring
    node uses this color and, if so, marks it as unusable for the current node ❶.
    If the color is usable, the code continues with the recursive exploration, assigning
    the color to the node ❷ and recursively proceeding to the next node ❸. As with
    the approach in [Listing 16-2](#list16-2), the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if it finds a valid assignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if it is forced to backtrack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-8](#fig16-8) shows a backtracking search with pruning on an example
    graph with five nodes and *C* = 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'During its first few steps, the search progresses through assigning valid colors
    to node 0 in [Figure 16-8(a)](#fig16-8), node 1 in [Figure 16-8(b)](#fig16-8),
    node 2 in [Figure 16-8(c)](#fig16-8), and node 3 in [Figure 16-8(d)](#fig16-8).
    When it reaches node 4, it realizes it is at a dead end: none of the three potential
    colors can be assigned to this node. The search backtracks to where it assigned
    node 3, but this doesn’t help because at that point, node 3 had only one possible
    valid assignment. The search backtracks again and tries a different assignment
    for node 2 in [Figure 16-8(e)](#fig16-8). When the search hits its next dead end
    in [Figure 16-8(f)](#fig16-8), it backtracks all the way to where it assigned
    node 1 and tries a new color there, as shown in [Figure 16-8(g)](#fig16-8). With
    the new node 1 assignment, the search can find assignments for the remaining nodes
    without trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The figure has 10 subfigures, each showing a different coloring or partial
    coloring of the graph. The graph has edges (0, 3), (1, 2), (1, 4), (2, 3), (2,
    4), and (3, 4).](../images/f16008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: Ten steps of a
    backtracking search graph-coloring algorithm with pruning</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking search with pruning is like a methodical conference planner with
    a good eraser. They start by making initial table assignments one by one. For
    each assignment, they check whether there is a known conflict at the table. If
    so, they skip that assignment and avoid wasted effort—there is no point in searching
    for the rest of a solution if they already know it will result in a screaming
    match over the merits of B-trees versus red-black trees. This validity check only
    helps so much, however. The planner still reaches dead ends where the current
    person has no valid table. An ardent LISP programmer will have nowhere to go if
    every table already has at least one Python aficionado. The conference planner
    takes out their trusty eraser, sighs deeply, and starts backtracking to an earlier
    point where they could have made a different assignment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Beyond these exact but computationally expensive solutions, we can consider
    heuristic approaches. The *greedy approach* to graph coloring considers one node
    at a time, picking the first color that does not violate any constraints with
    the already assigned neighbors. Unlike the exhaustive algorithms described in
    this section, we define this greedy search without respect to a maximum number
    of colors. While it will always find some solution, the search’s greedy nature
    means it will not always use the smallest possible number of colors.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the greedy search approach starts with a helper function that finds
    the first valid color for a node by determining which colors are used by its neighbors,
    then choosing the first color not in that set, as shown in [Listing 16-3](#list16-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Finding a valid
    color assignment for a node</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    function collects the colors seen in the neighboring nodes in a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>,
    which allows it to easily insert new colors and check whether a color has already
    been used. The code then iterates through all the node’s neighbors. For each neighbor,
    it adds that node’s color to the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    set. It skips unassigned nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>)
    because they do not provide a conflict ❶. The code finishes by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to find the first color that does not occur in the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    set ❷. While this is not terribly efficient, the loop will always find *some*
    color that could be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the helper function, this greedy search can be implemented in a single
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_greedy()</samp>
    function iterates through all nodes using the index variable <samp class="SANS_TheSansMonoCd_W5Regular_11">idx</samp>.
    For each node, it calls the helper function from [Listing 16-3](#list16-3) to
    find the first color that does not conflict with an assigned neighbor. For consistency
    with other algorithms in this chapter, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    to indicate that it has found a valid coloring.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the greedy algorithm through the eyes of the Conference Chair
    for Banquet Seating at the data structure convention. The organizer iterates through
    the list of attendees one by one, assigning each to a table before moving on to
    the next. For each attendee, they review the list of available tables and check
    whether a conflict would arise with any of the attendees already assigned there.
    This is equivalent to checking whether the current attendee (node) has a conflict
    (shares an edge) with any of the table’s other occupants (already assigned nodes).
    If so, the organizer moves on to the next table on the list. If they run out of
    tables, they sigh, mumble unkind words about the absurdity of programming language
    fights, and add a new table to the floor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-9](#fig16-9) illustrates this greedy search. During the first iteration
    in [Figure 16-9(a)](#fig16-9), the code assigns a color to node 0\. In [Figure
    16-9(b)](#fig16-9), it then considers node 1\. Since that node shares an edge
    with node 0, the search cannot reuse color = 1\. Instead, it assigns node 1 to
    color = 2\. When it considers node 2 in [Figure 16-9(c)](#fig16-9), the only assigned
    neighbor has color = 2, so the search can assign node 2 color = 1\. This search
    continues until it has assigned all nodes a color, as shown in [Figure 16-9(e)](#fig16-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with
    color = 1\. (B) shows the same graph with node 0 labeled with color = 1 and node
    1 labeled with color = 2\. (C) shows the assignments [1, 2, 1, None, None]. (D)
    shows the assignments [1, 2, 1, 2, None]. (E) shows the assignments [1, 2, 1,
    2, 3].](../images/f16009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: The five steps
    of a greedy coloring algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Given enough colors, the greedy algorithm will find a valid coloring for the
    graph. However, this assignment is not guaranteed to use the fewest colors. Instead,
    the order in which the nodes are assigned has a significant impact on how many
    colors the greedy algorithm will require. Consider [Figure 16-10](#fig16-10),
    which shows two valid ways of coloring the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Both subfigures show graphs with five nodes and edges (0, 3), (1, 2), (1,
    4), (2, 3), (2, 4), and (3, 4). (A) shows the graph with assignments [1, 1, 2,
    3, 4]. (B) shows the graph with assignments [1, 3, 2, 3, 1]. ](../images/f16010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: A graph where
    the greedy coloring approach finds a solution with four colors (a) while there
    exists a solution with only three (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-10(a)](#fig16-10) shows the graph coloring produced by the greedy
    algorithm. Because the search assigns the same color to nodes 0 and 1, it must
    use a fourth color on node 4\. In contrast, depth-first search with pruning would
    find an optimal coloring requiring only three colors, as shown in [Figure 16-10(b)](#fig16-10).
    The trade-off is speed versus optimality. While the greedy search will occasionally
    use more than the minimum number of colors, its lack of backtracking makes it
    faster.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Node Removal</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another heuristic algorithm worth discussing is the *removal algorithm* proposed
    by a team of scientists at IBM to find nonconflicting assignments of variables
    to CPU registers in a compiler. This algorithm works by iteratively simplifying
    the problem if possible. As with the example of assigning parking spaces, the
    paper’s authors defined register assignment as a graph-coloring problem that uses
    nodes to represent variables, edges to capture which variables were in use at
    the same time, and colors to represent each of the CPU’s registers. The number
    of colors is fixed at *C* by the chip’s architecture. The algorithm’s goal is
    to determine whether it can find a graph coloring that uses *C* or fewer colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in their paper “Register Allocation via Coloring” by George Chaitin
    et al., the IBM team proposed a multistep approach to register allocation that
    includes a node removal algorithm for generating the color assignments. This algorithm
    relies on the insight that if a node has fewer than *C* edges, we can trivially
    assign it a color after we have assigned colors to its neighbors. We simply review
    its neighbors’ colors and use any color that doesn’t occur among those nodes,
    reusing our <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    function from [Listing 16-3](#list16-3). Therefore, we can initially ignore a
    node with fewer than *C* edges and focus on the more difficult cases: nodes with
    *C* or more neighbors. In fact, we can go one step further and temporarily remove
    any node with fewer than *C* edges from the graph, along with its edges, while
    we deal with the remaining nodes. We then re-add that node when it is time to
    assign its color.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on this insight, the algorithm iteratively checks the nodes in the current
    graph and removes any that have *C* or fewer edges, along with those edges. It
    adds these nodes to a stack to revisit once it has dealt with the more difficult
    cases. As it removes nodes and edges, new nodes will drop below the *C* neighbor
    threshold and can be removed as well. It knows that it will be able to easily
    find a color for those nodes using <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    when it returns to them after assigning colors to the neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: If the algorithm can remove every node from the graph, we know it has a valid
    coloring with *C* colors. If the search tracks what it removes in a stack, it
    can pop items from the stack to reverse the operations and reassemble the graph,
    using it to effectively re-add the nodes to the graph and assign colors along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the removal algorithm uses this two-phase approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by creating multiple helper data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp>
    array stores a Boolean for each node, allowing the code to quickly check whether
    a node is still in the graph. The list <samp class="SANS_TheSansMonoCd_W5Regular_11">node_stack</samp>
    stores information about the nodes removed from the graph and the order in which
    they were removed. The code also makes a copy of the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>),
    allowing it to remove edges without modifying the original graph ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The code then enters a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that continues as long as the function has removed at least one node in the
    previous iteration (as tracked by the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">removed_one</samp>).
    Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, the
    code iterates through each node in the graph, checking whether that node has already
    been removed and how many neighbors it has ❷. If the node has not been removed
    and has fewer than *C* (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>)
    neighbors, the code adds the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">node
    _stack</samp>, removes all its edges ❸, and marks the node as removed. Technically,
    the code removes only the edges from the graph; the nodes’ removals are captured
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp> array.
    This allows us to stably iterate over the graph’s nodes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and doesn’t impact the accuracy of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: If the code does not manage to remove all the nodes from the graph and add them
    to the stack, it has failed in finding a valid color assignment ❹. In this case,
    the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If
    there is a valid assignment, the code assigns the colors one at a time ❺. As it
    pops each node from the stack, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    from [Listing 16-3](#list16-3) to choose a valid color. Since the node had fewer
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp> neighbors
    when it was added to the stack, it now must have fewer than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>
    neighbors that have been assigned a color. Thus <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    will choose a valid color in the range [1, <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>].
  prefs: []
  type: TYPE_NORMAL
- en: We can picture the removal algorithm in the context of our conference planner
    by employing the key phrase “I’ll just deal with this attendee later.” Any time
    the conference planner sees an attendee with fewer than *C* conflicts, they dismissively
    say, “This person isn’t going to be a problem. I can find a table for them. I’ll
    just deal with them after I’ve handled the difficult attendees.” Outsiders might
    see this as procrastination, but graph-coloring enthusiasts recognize it as a
    key algorithmic insight.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figures 16-11](#fig16-11) shows the first phase of this code’s operation for
    *C* = 3\. In this stage, the nodes are removed one at a time. During the first
    iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop,
    three nodes are removed. Node 2 has fewer than *C* neighbors and is added to the
    stack in [Figure 16-11(b)](#fig16-11). Node 3 is removed next in [Figure 16-11(c)](#fig16-11).
    At this point, node 4 has fewer than *C* neighbors and can also be removed, as
    shown in [Figure 16-11(d)](#fig16-11).'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the five-node graph with edges (0, 1), (0, 3), (0, 4), (1, 2),
    (1, 4), (2, 4), and (3, 4). Each subsequent subfigure shows the graph with one
    additional node removed and the corresponding number added to the stack. (B) has
    node 2 removed. (C) has node 3 removed. (D) has node 4 removed. (E) has node 0
    removed. (F) has no nodes remaining.](../images/f16011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-11: The first phase
    of the removal graph-coloring algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm has now passed through each node in the graph one time. Since
    it has removed at least one node during this iteration, it restarts from node
    0 and checks again. In [Figure 16-11(e)](#fig16-11) it removes node 0, which has
    only one remaining neighbor. Finally, it removes node 1 in [Figure 16-11(f)](#fig16-11).
  prefs: []
  type: TYPE_NORMAL
- en: The second phase of the algorithm, shown in [Figure 16-12](#fig16-12), labels
    and “re-adds” the nodes. The algorithm starts by popping node 1 from the stack
    and assigning it color 1, as shown in [Figure 16-12(a)](#fig16-12). In [Figure
    16-12(b)](#fig16-12), the algorithm pops node 0 from the stack and assigns node
    0 the first color that does not conflict with a neighbor. This process continues
    for nodes 4, 3, and 2 in [Figures 16-12(c)](#fig16-12), [16-12(d)](#fig16-12),
    and [16-12(e)](#fig16-12), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the graph with one additional node re-added and colored.
    (A) shows node 1 with color 1\. (B) Adds Node 0 with color 2\. (C) adds node 4
    with color 3\. (D) adds node 3 with color 1\. (E) adds node 2 with color 2.>](../images/f16012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-12: The second phase
    of the removal graph-coloring algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this heuristic approach is not sufficient to solve every graph.
    A graph coloring can sometimes use fewer than *C* colors despite a cluster of
    interconnected nodes with at least *C* edges. In [Figure 16-13](#fig16-13), for
    example, the removal algorithm would fail for *C* = 3 despite a valid coloring
    with only two colors. Since every node has three neighbors, the removal algorithm
    cannot remove any. It is stuck.
  prefs: []
  type: TYPE_NORMAL
- en: '![A bipartite graph with six nodes and nine edges.](../images/f16013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-13: An example graph
    for which the removal algorithm fails</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Yet it is obvious that we could create a valid assignment for the graph in [Figure
    16-13](#fig16-13) with only two colors. We could assign all nodes on the left
    a color of 1 and all nodes on the right a color of 2\. Because the edges connect
    only left nodes to right nodes, there would be no conflicts. In fact, we could
    solve this particular case with the bipartite labeling algorithm from [Chapter
    15](chapter15.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem of finding an assignment of graph nodes to colors has a range of
    real-world use cases, from planning out magical labyrinths to assigning parking
    spaces. What makes this problem interesting is that there is no known algorithm
    that efficiently solves every case. Instead, we need to rely on either exhaustive
    searches or heuristics. This has led to the development of a variety of approaches
    aimed at providing good performance under different real-world conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we examine similar assignment problems that do not have
    a known efficient solution. We look at a range of different branching searches
    based on the backtracking depth-first search from this chapter, as well as considering
    a variety of heuristics and the use of randomized algorithms to find solutions.
  prefs: []
  type: TYPE_NORMAL
