- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GRAPH
    COLORING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">图着色</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Graph coloring* is a conceptually simple but computationally complex problem
    with a range of real-world applications. At its core, it consists of assigning
    a color to each node in an undirected graph such that no pair of nodes sharing
    an edge have the same color. Variations of this problem include minimizing the
    number of colors used or finding an assignment using only a fixed number of colors.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*图着色* 是一个概念上简单但计算上复杂的问题，具有广泛的现实世界应用。它的核心是为无向图中的每个节点分配一个颜色，确保任何一对共享边的节点具有不同的颜色。该问题的变体包括最小化使用的颜色数量或仅使用固定数量的颜色进行分配。'
- en: We can easily visualize the importance of the graph-coloring problem in terms
    of a map of Europe. We need to assign each country a color such that no two adjacent
    countries have the same color. If we use green for both France and Belgium, viewers
    may not be able to see the border. Beyond maps, the constraints enforced by the
    graph-coloring problem lend themselves to a range of real-world optimization tasks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过欧洲地图轻松地形象化图着色问题的重要性。我们需要为每个国家分配一个颜色，使得没有两个相邻的国家有相同的颜色。如果我们把法国和比利时都涂成绿色，观众可能无法看到它们之间的边界。除了地图之外，图着色问题所施加的约束条件适用于许多现实世界的优化任务。
- en: This chapter begins by formally defining the graph-coloring problem and discussing
    real-world use cases in more depth. We then examine several approaches to solving
    the task and discuss why the problem of using a fixed number of colors (or minimizing
    the number used) is surprisingly difficult.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先正式定义图着色问题，并更深入地讨论现实世界中的应用案例。然后，我们将探讨几种解决该任务的方法，并讨论为什么使用固定数量颜色的问题（或最小化使用的颜色数量）令人惊讶地困难。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Graph-Coloring Problem</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">图着色问题</samp>
- en: 'The *graph-coloring problem* consists of assigning colors to each of the |*V*
    | nodes in an undirected graph such that no two nodes sharing an edge have the
    same color. Formally, we can define the problem as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图着色问题* 包括为无向图中的每个 |*V* | 节点分配颜色，使得没有两个共享边的节点有相同的颜色。正式地，我们可以将该问题定义如下：'
- en: Given a graph, defined by a set of nodes *V* and edges *E*, and a set of colors
    *C*, find an assignment of nodes to colors such that for any two nodes *u* ∈*V*
    and *v* ∈*V* connected by an edge, (*u*, *v*) ∈ *E*, then *color*(*u*) ≠ *color*(*v*).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由节点集合 *V* 和边集合 *E* 定义的图，以及一个颜色集合 *C*，找到一个节点与颜色的分配，使得对于任何两个节点 *u* ∈*V* 和
    *v* ∈*V*，如果它们通过边连接（*u*, *v*) ∈ *E*，则 *color*(*u*) ≠ *color*(*v*)。
- en: We can define the *minimum graph-coloring problem* as finding the minimum number
    of colors such that a graph has a valid graph coloring.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *最小图着色问题* 定义为找到最小数量的颜色，使得图具有有效的图着色。
- en: In this chapter, we use the graph node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    field to store the color for that node. Colors will be represented by integers
    starting at 1, with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    indicating an unassigned node (<samp class="SANS_TheSansMonoCd_W5Regular_11">node.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用图节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> 字段来存储该节点的颜色。颜色将通过整数表示，从1开始，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp> 的值表示未分配的节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">node.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>）。
- en: '[Listing 16-1](#list16-1) defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">is_graph_coloring_valid()</samp>
    function that checks whether a graph has a valid coloring. This checker both provides
    a good overview of the mechanics of the graph-coloring problem and is also a helpful
    utility function for testing.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表16-1](#list16-1) 定义了一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_graph_coloring_valid()</samp>
    函数，用于检查图是否具有有效的着色。这个检查器既提供了图着色问题的机械过程的良好概述，也为测试提供了一个有用的实用函数。'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Checking whether
    a graph’s coloring is valid</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表16-1：检查图的着色是否有效</samp>
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate through each node in the graph, first checking whether the node has
    any color assigned ❶. If not, the graph’s coloring is incomplete and thus invalid.
    If the node does have a color, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate through each of the node’s neighbors and check whether the two
    nodes share a color ❷. If two neighbors share a color, the coloring is invalid,
    and the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    If the code makes it through every neighbor for every node without finding a match,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历图中的每个节点，首先检查节点是否分配了颜色
    ❶。如果没有，图的着色是不完整的，因此无效。如果节点有颜色，代码使用第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历该节点的每个邻居，并检查两个节点是否共享相同的颜色 ❷。如果两个邻居共享相同的颜色，着色无效，代码返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果代码遍历了每个节点的每个邻居且没有找到匹配，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: We represent different node colors in the illustrations in this chapter using
    hashing arranged in different orientations, as shown in [Figure 16-1](#fig16-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章插图中使用不同方向排列的哈希值表示不同的节点颜色，如[图 16-1](#fig16-1)所示。
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). Node 0 has vertical hashing and is labeled with the color
    1, while its neighbor node 1 has horizontal hashing and is labeled with the color
    2.](../images/f16001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和边（0, 1）、（0, 3）、（0, 4）、（1, 2）、（1, 4）、（2, 4）和（3, 4）的图。节点 0 有垂直哈希标记并标注颜色
    1，而它的邻居节点 1 有水平哈希标记并标注颜色 2。](../images/f16001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: A graph with a
    valid assignment of colors</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-1：一个有效颜色分配的图</samp>
- en: For the figures in this chapter, we’ll note the color number outside each node
    and number the colors starting from 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的图示，我们将标记每个节点外部的颜色编号，并从 1 开始编号颜色。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">应用案例</samp>
- en: We can use the graph-coloring formulation to model a range of real-world problems,
    including coloring maps, making seating arrangements at conferences, assigning
    parking spaces, and protecting valuable treasure within a labyrinth.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用图着色模型来描述一系列现实世界的问题，包括地图着色、会议座位安排、分配停车位，以及保护迷宫中的宝贵财宝。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring Maps</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">地图着色</samp>
- en: The classic use case for graph coloring stems from the daily needs of cartographers
    and map publishers throughout the world. To distinguish areas on a map, different
    regions must be shaded with different colors. For a map of New England like that
    shown in [Figure 16-2](#fig16-2), we might choose to color Connecticut in green
    and Rhode Island in orange.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色的经典应用案例来自于世界各地制图师和地图出版商的日常需求。为了区分地图上的不同区域，必须使用不同的颜色对各个区域进行着色。以[图 16-2](#fig16-2)所示的新英格兰地图为例，我们可以选择将康涅狄格州涂成绿色，将罗德岛涂成橙色。
- en: '![A map showing the six states in New England with a graph overlaid. The node
    MA has neighbors CT, RI, VT, and NH.](../images/f16002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![显示新英格兰六个州的地图，图上覆盖了一个图。节点 MA 的邻居有 CT、RI、VT 和 NH。](../images/f16002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: A map of New England
    and the overlaid graph representation</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-2：新英格兰地图及其叠加的图表示</samp>
- en: We can translate the map-coloring problem into a graph-coloring problem by creating
    a node for each region and adding edges between any two regions that share a border.
    In [Figure 16-2](#fig16-2), the Rhode Island node has edges to the nodes for both
    Connecticut and Massachusetts. The cartographer’s goal then becomes finding a
    valid graph coloring.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为每个区域创建一个节点，并在共享边界的任何两个区域之间添加边，将地图着色问题转化为图着色问题。在[图 16-2](#fig16-2)中，罗德岛节点与康涅狄格州和马萨诸塞州的节点之间有边连接。制图师的目标就是找到一个有效的图着色。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing Seating
    Arrangements</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组织座位安排</samp>
- en: The annual convention of Coffee-Drinking Data Structure Enthusiasts is a joyous
    but surprisingly political affair. Deep divergences exist within the community
    in terms of preferences for both coffee and data structures, including rivalries
    between the light and dark roast camps, over 30 different groups of loudly declared
    favorite data structures, and the inevitable fighting over programming languages
    that finds a way into any discussion about computer science. Not all differences
    in preference lead to an argument, but the ones that do result in hours of pedantic
    shouting. Every year the organizers face the daunting task of assigning tables
    at the opening banquet such that there will be no loud feuds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每年举办的“咖啡饮用数据结构爱好者大会”是一个充满欢乐但出乎意料地充满政治斗争的活动。社区内对咖啡和数据结构的偏好存在深刻分歧，包括轻烘焙和深烘焙阵营之间的对立，超过30个不同的热衷数据结构小组，以及不可避免地在任何计算机科学讨论中出现的编程语言之争。并非所有的偏好差异都会引发争执，但那些引发争执的会导致数小时的迂腐争吵。每年，组织者都面临着一个艰巨的任务——在开幕宴会上分配桌子，确保没有激烈的争论。
- en: The organizers have long used this gathering as an opportunity to test new graph-coloring
    algorithms. Modeling each attendee as a node and a strong difference in opinion
    as an edge, the Conference Chair for Banquet Seating tries to find an assignment
    of attendees to tables such that no two people at the same table have a strong
    disagreement. The nodes’ colors are the table assignments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组织者长期以来一直利用这次聚会作为测试新图着色算法的机会。将每个与会者建模为一个节点，并将强烈的意见分歧建模为一条边，宴会座位安排的会议主席试图找到一个与会者分配到桌子的方案，确保同一桌子上的两个人没有强烈的意见分歧。节点的颜色代表桌子的分配。
- en: In the simplest case, the organizer could break up the tables into the smallest
    coherent factions. They might assign a table for the sole espresso-drinking, Fortran-writing
    hash table fan in attendance. This is equivalent to assigning the node a completely
    unique color. However, this approach is needlessly wasteful, resulting in almost
    as many tables as attendees. The aforementioned hash table fan gets along quite
    well with espresso and dark roast coffee drinkers, users of Fortran or Cobol,
    and aficionados of most data structures. The Conference Chair’s goal is to minimize
    the number of tables (graph colors) while ensuring that no shouting matches ensue.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，组织者可以将桌子分成最小的连贯群体。他们可能会为仅仅是喝浓缩咖啡、写Fortran程序的哈希表爱好者分配一张桌子。这相当于给该节点分配一个完全独特的颜色。然而，这种方法是多余且浪费的，几乎会为每个与会者分配一张桌子。上述的哈希表爱好者与浓缩咖啡和深烘焙咖啡饮用者、Fortran或Cobol用户以及大多数数据结构的爱好者相处得相当融洽。会议主席的目标是最小化桌子的数量（图的颜色），同时确保不会引发激烈的争吵。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Parking
    Spaces</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分配停车位</samp>
- en: 'The Data Structures and Coffee bookstore sees a consistent stream of customers
    throughout the day. To meet demand, the owners decide to bring on more staff.
    After extensive interviews, the owners hire six employees. They draw up a schedule
    with those new hires working set shifts throughout the day as shown in [Figure
    16-3(a)](#fig16-3). One question remains, however: How many parking spaces should
    they set aside for staff?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构与咖啡书店全天都有稳定的顾客流量。为了满足需求，店主决定雇佣更多的员工。经过广泛的面试，店主雇佣了六名员工。他们制定了一个时间表，安排这些新员工在一天内按固定班次工作，如[图16-3(a)](#fig16-3)所示。然而，仍然有一个问题：他们应为员工预留多少个停车位？
- en: '![(A) shows a chart with size bars spanning different horizontal ranges. (b)
    shows a graph with six nodes with edges connecting nodes whose bars overlap.](../images/f16003.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个具有跨越不同水平范围的大小条形图。 (b) 显示了一个包含六个节点的图，节点之间通过边连接，边连接的是条形图重叠的节点。](../images/f16003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: Employee work
    times (a) and the corresponding graph of parking conflicts (b)</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-3：员工工作时间（a）与相应的停车冲突图（b）</samp>
- en: Using their data structures expertise, the owners quickly reduce the question
    to a graph-coloring problem. As shown in [Figure 16-3(b)](#fig16-3), each employee
    becomes a node in the graph with edges between any two employees whose schedules
    overlap and thus will need parking spaces at the same time. For example, the schedule
    of employee 1 overlaps with that of employees 2, 3, and 5\. However, it does not
    overlap with employees 0 or 4, which means that employee 1 could share a parking
    space with either of the latter two employees. If the owners can find a graph
    coloring containing at most *C* colors, then they can safely reserve at most *C*
    parking spaces.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 利用他们的数据结构专业知识，业主们迅速将问题简化为图着色问题。如[图16-3(b)](#fig16-3)所示，每个员工都成为图中的一个节点，任何两个日程有重叠的员工之间都会有一条边，这样他们就需要在相同时间占用停车位。例如，员工1的日程与员工2、3和5的日程有重叠。但与员工0或4的日程没有重叠，这意味着员工1可以与后两位员工共享一个停车位。如果业主能够找到一个最多包含*C*种颜色的图着色方案，那么他们就可以安全地预留最多*C*个停车位。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning Magical
    Labyrinths</samp>
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规划魔法迷宫</samp>
- en: An evil wizard decides to construct a magical labyrinth to protect their most
    prized possession, a horn that plays their favorite song. Seeking to protect the
    Horn of Beautiful Music from relentless adventurers, the wizard fills their labyrinth
    with an assortment of traps and monsters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一位邪恶的巫师决定建造一个魔法迷宫来保护他们最珍贵的宝物，一只能演奏他们最喜欢歌曲的号角。为了保护“美妙音乐之角”免受无情冒险者的侵扰，巫师在迷宫中布满了各种陷阱和怪物。
- en: The wizard quickly runs into a problem, however. Due to the large number of
    passageways (edges), many of the rooms (nodes) connect. They do not want to be
    seen as lazy by having the same monsters in two adjacent rooms. Skill in labyrinth
    creation is a reputational necessity; even the most junior adventurers lose respect
    for architects who fill room after room with the same challenges. Yet the wizard
    is looking to keep costs down by bulk-ordering monsters. They need to determine
    the smallest number of monsters (colors) they can use such that no two adjacent
    rooms contain the same monster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，巫师很快就遇到了一个问题。由于大量的通道（边），许多房间（节点）相互连接。它们不希望因为两个相邻房间有相同的怪物而被认为是懒惰的。迷宫设计的技巧是声誉的必要条件；即使是最初级的冒险者，也会对那些一个接一个地在房间里放置相同挑战的建筑师失去尊重。然而，巫师希望通过批量订购怪物来降低成本。他们需要确定能够使用的最少数量的怪物（颜色），以确保没有两个相邻的房间包含相同的怪物。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Graph-Coloring Algorithms</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">图着色算法</samp>
- en: Computer scientists and mathematicians have developed a range of algorithms
    to solve graph-coloring problems. However, each solution comes with trade-offs.
    Some algorithms use heuristics that find solutions but might require too many
    colors; others are expensive on large graphs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家和数学家们开发了多种算法来解决图着色问题。然而，每种解决方案都有其权衡。有些算法使用启发式方法来找到解，但可能需要过多的颜色；另一些则在大规模图形中计算代价较高。
- en: 'Graph coloring is an *NP-hard problem*, which informally means that there is
    no known algorithm whose worst-case running time scales as polynomial with respect
    to the size of the data. There is literally an exponential number of states to
    consider: |*V* |*^C* states for a problem with |*V* | nodes and *C* colors. Yet
    it is not all bad news. While this problem is constrained by its behavior in worst-case
    scenarios, many of the algorithms perform well in practice and can be applied
    to numerous everyday problems.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色是一个*NP难问题*，这意味着非正式地说，目前没有已知的算法能够在最坏情况下其运行时间随着数据规模的增加而呈多项式增长。实际上，需要考虑的状态数是指数级的：对于一个有|*V*|个节点和*C*种颜色的问题，需要考虑|*V*|*^C*种状态。然而，这并非全是坏消息。尽管该问题在最坏情况下受限于其行为，但许多算法在实践中表现良好，并且可以应用于许多日常问题。
- en: The algorithms in this section search for valid graph colorings. If they find
    one, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to
    indicate their success and set the color assignments in the nodes’ <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    field, rather than returning the assignments in a separate data structure. The
    algorithms return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if
    they are unable to find a valid set of assignments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的算法用于寻找有效的图着色。如果找到了一个有效的着色，它会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    来表示成功，并将颜色分配设置在节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    字段中，而不是返回一个单独的数据结构。如果无法找到有效的分配集，算法将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exhaustive
    Search</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">穷举搜索</samp>'
- en: 'An *exhaustive search* through all possible node-to-color assignments is a
    comprehensive approach that is guaranteed to find a valid graph coloring if one
    exists:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*穷举搜索* 是一种全面的方法，能够确保在存在有效图着色的情况下找到一个解：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">product</samp>
    function of Python’s itertools package to enumerate every possible combination
    of color assignments ❶. Initially, every value of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    is assigned to the first color (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    During each iteration, the counter changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用 Python 的 itertools 包中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">product</samp>
    函数来枚举所有可能的颜色分配组合❶。最初，<samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    的每个值都被分配给第一个颜色（<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。在每次迭代中，计数器会发生变化。
- en: In each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the code copies the assignments into the node labels ❷ and checks whether
    they are valid ❸. If so, it immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    to indicate it has found a solution. Otherwise, the loop continues forward to
    the next combination. If the code does not find a successful combination, it returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Before doing so, it
    resets all the node’s label assignments to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    because there is no valid coloring ❹.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环的迭代中，代码将分配值复制到节点标签中❷，并检查这些分配是否有效❸。如果有效，立即返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> 表示已经找到了解决方案。否则，循环继续执行下一种组合。如果代码没有找到成功的组合，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。在此之前，它会将所有节点的标签分配重置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，因为没有有效的着色❹。
- en: Of course, the cost of an exhaustive search can be prohibitively expensive as
    the size of the graph grows. If the graph has |*V* | nodes and uses *C* colors,
    we could end up testing |*V* |*^C* assignments before either finding a valid one
    or determining that no *C*-color assignment will work. [Figure 16-4](#fig16-4)
    shows the first six iterations of an exhaustive search with three colors on the
    five-node graph from [Figure 16-1](#fig16-1). The search starts with all nodes
    the same color, as shown in [Figure 16-4(a)](#fig16-4), and moves through the
    assignments.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着图的大小增大，穷举搜索的代价可能会变得非常昂贵。如果图有 |*V* | 个节点并使用 *C* 种颜色，那么我们可能需要测试 |*V* |*^C*
    个分配组合，才能找到一个有效的解或确定没有任何 *C* 颜色分配能工作。[图 16-4](#fig16-4) 显示了对五节点图进行穷举搜索的前六次迭代，使用了三种颜色，图来自
    [图 16-1](#fig16-1)。搜索从所有节点为同一颜色开始，如 [图 16-4(a)](#fig16-4) 所示，接着进行不同的分配。
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph where all nodes have vertical
    hashing and are labeled with color = 1 for assignments of [1, 1, 1, 1, 1]. (B)
    shows the same graph with node 0 now with horizontal hashing and labeled with
    color = 2 for assignments of [2, 1, 1, 1, 1]. (C) shows assignments of [1, 2,
    1, 1, 1]. (D) shows assignments of [2, 2, 1, 1, 1]. (E) shows assignments of [1,
    1, 2, 1, 1]. (F) shows assignments of [2, 1, 2, 1, 1].](../images/f16004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点的图及其边（0, 1）、（0, 3）、（0, 4）、（1, 2）、（1, 4）、（2, 4）、（3, 4）。(A) 显示了五节点图，其中所有节点都使用垂直哈希并标记为颜色
    = 1，对应于 [1, 1, 1, 1, 1] 的分配。(B) 显示相同的图，其中节点 0 现在使用水平哈希，并标记为颜色 = 2，对应于 [2, 1, 1,
    1, 1] 的分配。(C) 显示 [1, 2, 1, 1, 1] 的分配。(D) 显示 [2, 2, 1, 1, 1] 的分配。(E) 显示 [1, 1,
    2, 1, 1] 的分配。(F) 显示 [2, 1, 2, 1, 1] 的分配。](../images/f16004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: The first six
    iterations of an exhaustive search</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-4：穷举搜索的前六次迭代</samp>
- en: As shown in [Figure 16-4](#fig16-4), exhaustive search can waste a significant
    amount of time checking one obvious bad state after another. It provides simplicity
    and completeness at the cost of efficiency. Unless our graph has no edges, it’s
    clearly not possible for all the nodes to share the same color. Imagine the frustration
    of a human using this approach as they are forced to test yet another combination
    they know won’t work because there is a clear conflict somewhere else in the graph.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图16-4](#fig16-4)所示，穷举搜索可能会浪费大量时间检查一个接一个明显错误的状态。它提供了简单性和完整性，但代价是效率。如果我们的图没有边，那么显然所有节点都无法共享相同的颜色。想象一下，使用这种方法的人类会感到多么沮丧，因为他们被迫测试一个又一个他们知道不会成功的组合，因为图的某个地方明显存在冲突。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking Search</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">回溯搜索</samp>
- en: We can also implement the iterator-based exhaustive search from the previous
    section using a *recursive backtracking search*. Unlike the depth-first searches
    used in earlier chapters, especially [Chapter 4](chapter4.xhtml), this backtracking
    search does not explore individual nodes through their neighbors. Instead, the
    search state is the set of color assignments itself. We recursively explore all
    possible assignments of colors to nodes, backtracking when the solution is infeasible.
    Each state in our search corresponds to a partial assignment of colors to nodes,
    as shown in [Figure 16-5](#fig16-5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用*递归回溯搜索*来实现前一节中的基于迭代器的穷举搜索。与前几章中使用的深度优先搜索，尤其是[第4章](chapter4.xhtml)中的深度优先搜索不同，这种回溯搜索并不会通过相邻节点探索单独的节点。相反，搜索状态就是颜色分配的集合。我们递归地探索所有可能的颜色分配，遇到不可行的解时进行回溯。我们搜索中的每个状态都对应于节点的部分颜色分配，如[图16-5](#fig16-5)所示。
- en: '![A tree of options. The root level shows five blank spaces. The next level
    contains nodes filling the first entry with 1, 2, 3\. The second level shows the
    first three nodes with the first entry set to 1 and the second entry set to 1,
    2, and 3, respectively.](../images/f16005.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![一棵选项树。根级别显示五个空白位置。下一层包含节点，填充第一个条目为 1、2、3。第二层显示前三个节点，第一个条目的值为 1，第二个条目的值分别为
    1、2 和 3。](../images/f16005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: A backtracking
    search branching out over different assignments</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-5：回溯搜索在不同分配上分支</samp>
- en: We can first model the same search space as the iterator-based exhaustive search,
    using a depth-first search without any pruning (we’ll improve on this approach
    shortly). This search progresses to an adjacent state by assigning a color to
    the next unassigned node, as shown in [Listing 16-2](#list16-2).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先将相同的搜索空间建模为基于迭代器的穷举搜索，使用深度优先搜索而不进行任何剪枝（稍后我们会改进这种方法）。这种搜索通过给下一个未分配的节点分配颜色来进入相邻状态，如[清单16-2](#list16-2)所示。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: A recursive exhaustive
    search of color assignments</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-2：颜色分配的递归穷举搜索</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_dfs()</samp> code
    uses a recursive search to assign each color to each node. It starts with the
    base case, checking whether all nodes have been assigned and, if so, whether the
    assignment is valid. If there are more nodes to assign, then the code iterates
    through all possible colors for the current node. For each color, the code then
    continues the recursive search on the next node (by index). It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if the assignment leads to a valid solution ❶. If the search has not found a valid
    assignment, it resets the current node’s color to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    ❷ and backtracks by returning <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_dfs()</samp> 代码使用递归搜索为每个节点分配颜色。它从基本情况开始，检查是否所有节点都已分配颜色，如果是，检查分配是否有效。如果还有节点需要分配，代码将迭代当前节点的所有可能颜色。对于每种颜色，代码将继续在下一个节点（按索引顺序）上进行递归搜索。如果分配导致有效解，它返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❶。如果搜索未找到有效的分配，它将当前节点的颜色重置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> ❷ 并通过返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    来回溯。
- en: The backtracking search implementation in [Listing 16-2](#list16-2) is only
    an alternative implementation of the iterator-based exhaustive search. It doesn’t
    improve efficiency. [Figure 16-6](#fig16-6) shows how the search will iterate
    through the same first dead end as did the exhaustive search in [Figure 16-4](#fig16-4).
    After it progresses all the way to the dead end in [Figure 16-6(e)](#fig16-6),
    the algorithm backtracks and tries a new assignment for node 4, as shown in [Figure
    16-6(f)](#fig16-6).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-2](#list16-2)中的回溯搜索实现仅仅是基于迭代器的穷举搜索的另一种实现方式。它并没有提高效率。 [图 16-6](#fig16-6)
    显示了搜索如何迭代通过与穷举搜索在 [图 16-4](#fig16-4) 中相同的第一个死胡同。经过所有步骤后，到达了 [图 16-6(e)](#fig16-6)
    中的死胡同，算法回溯并尝试为节点 4 分配新的值，如 [图 16-6(f)](#fig16-6) 所示。'
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with
    color = 1\. (B) shows the same graph with node 0 labeled with color = 1 and node
    1 labeled with color = 1\. (C) shows assignments [1, 1, 1, None, None]. (D) shows
    the assignments [1, 1, 1, 1, None]. (E) shows the assignments [1, 1, 1, 1, 1].
    (F) shows the assignments [1, 1, 1, 1, 2].](../images/f16006.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和边（0, 1）、（0, 3）、（0, 4）、（1, 2）、（1, 4）、（2, 4）和（3, 4）的图。 (A) 显示了只有节点
    0 被标记为 color = 1 的五节点图。 (B) 显示了相同的图，其中节点 0 被标记为 color = 1，节点 1 被标记为 color = 1。
    (C) 显示了分配 [1, 1, 1, None, None]。 (D) 显示了分配 [1, 1, 1, 1, None]。 (E) 显示了分配 [1, 1,
    1, 1, 1]。 (F) 显示了分配 [1, 1, 1, 1, 2]。](../images/f16006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: The first six
    steps of the backtracking search coloring on a graph</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-6：图着色的回溯搜索的前六个步骤</samp>
- en: However, we can modify this search to greatly improve efficiency by *pruning*
    early and exploring only valid paths. Before assigning a color to a node, we can
    check whether that assignment produces a conflict. If so, we can skip not only
    that assignment but also all later recursions from it, as shown in [Figure 16-7](#fig16-7),
    where we skip the entire subtree of possibilities stemming from assigning color
    = 1 to both nodes 0 and 1\. Instead, once we have assigned color = 1 to node 0,
    we consider only colors 2 and 3 for the adjacent node 1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过 *剪枝* 来大大提高效率，仅探索有效路径。在给节点分配颜色之前，我们可以检查该分配是否会导致冲突。如果是，我们不仅跳过该分配，还跳过由此产生的所有后续递归，如
    [图 16-7](#fig16-7) 所示，我们跳过了从给节点 0 和节点 1 都分配颜色 = 1 开始的整个子树。而是，一旦我们给节点 0 分配了颜色 =
    1，我们只考虑颜色 2 和 3 来分配给相邻的节点 1。
- en: '![A tree where each node shows the five-node graph with some of the colors
    filled in. The root has no nodes colored. Its children consist of graphs with
    colors 1, 2, and 3, respectively. The tree node where both nodes 0 and 1 are assigned
    color 1 is grayed out and the branch is crossed out.](../images/f16007.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![一棵树，其中每个节点显示了带有部分颜色填充的五节点图。根节点没有任何节点被着色。它的子节点包括分别带有颜色 1、2 和 3 的图。树节点中，节点
    0 和 1 都分配了颜色 1 的情况被灰色显示，并且该分支被划掉。](../images/f16007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: The first few
    steps of a backtracking search with pruning for graph coloring</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-7：带有剪枝的回溯搜索在图着色中的前几个步骤</samp>
- en: 'The code for *backtracking search with pruning* requires a small change. Before
    assigning a color to a node, we check whether any neighbors already have that
    assignment. This simple check prevents us from progressing down deep dead ends:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*回溯搜索与剪枝*的代码需要做一个小的修改。在给节点分配颜色之前，我们需要检查是否有任何邻居已经有了该分配。这个简单的检查可以防止我们深入到死胡同：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code again starts with the base case, checking whether all nodes have been
    assigned and, if so, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    The code does not need to check for the validity of the current assignment, because
    it will do that before assigning each color.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次从基本情况开始，检查是否所有节点都已分配，如果是，返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。代码不需要检查当前分配的有效性，因为它会在分配每个颜色之前进行检查。
- en: If there are more nodes to explore (assign), then the code iterates through
    all the possible colors for the current node. It first checks whether any neighboring
    node uses this color and, if so, marks it as unusable for the current node ❶.
    If the color is usable, the code continues with the recursive exploration, assigning
    the color to the node ❷ and recursively proceeding to the next node ❸. As with
    the approach in [Listing 16-2](#list16-2), the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if it finds a valid assignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if it is forced to backtrack.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还有更多节点需要探索（分配），则代码会遍历当前节点的所有可能颜色。它首先检查是否有任何邻接节点使用此颜色，如果有，则将该颜色标记为不可用于当前节点❶。如果颜色可用，代码会继续进行递归探索，将该颜色分配给节点❷，并递归地继续到下一个节点❸。与[清单16-2](#list16-2)中的方法一样，如果代码找到有效的分配，它会返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，如果必须回溯，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: '[Figure 16-8](#fig16-8) shows a backtracking search with pruning on an example
    graph with five nodes and *C* = 3.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-8](#fig16-8)展示了一个带有剪枝的回溯搜索示例，图中有五个节点，*C* = 3。'
- en: 'During its first few steps, the search progresses through assigning valid colors
    to node 0 in [Figure 16-8(a)](#fig16-8), node 1 in [Figure 16-8(b)](#fig16-8),
    node 2 in [Figure 16-8(c)](#fig16-8), and node 3 in [Figure 16-8(d)](#fig16-8).
    When it reaches node 4, it realizes it is at a dead end: none of the three potential
    colors can be assigned to this node. The search backtracks to where it assigned
    node 3, but this doesn’t help because at that point, node 3 had only one possible
    valid assignment. The search backtracks again and tries a different assignment
    for node 2 in [Figure 16-8(e)](#fig16-8). When the search hits its next dead end
    in [Figure 16-8(f)](#fig16-8), it backtracks all the way to where it assigned
    node 1 and tries a new color there, as shown in [Figure 16-8(g)](#fig16-8). With
    the new node 1 assignment, the search can find assignments for the remaining nodes
    without trouble.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最初的几步中，搜索过程通过为[图16-8(a)](#fig16-8)中的节点0、[图16-8(b)](#fig16-8)中的节点1、[图16-8(c)](#fig16-8)中的节点2，以及[图16-8(d)](#fig16-8)中的节点3分配有效颜色来进行。当它到达节点4时，它意识到自己已经到了死胡同：这三个潜在的颜色都无法分配给该节点。搜索回溯到它为节点3分配颜色的地方，但这并没有帮助，因为在那个时刻，节点3只有一个有效的分配。搜索再次回溯，并尝试为[图16-8(e)](#fig16-8)中的节点2进行不同的分配。当搜索遇到[图16-8(f)](#fig16-8)中的下一个死胡同时，它会回溯到为节点1分配颜色的地方，并尝试在那里使用一种新颜色，如[图16-8(g)](#fig16-8)所示。通过新的节点1分配，搜索可以顺利为剩余的节点找到分配。
- en: '![The figure has 10 subfigures, each showing a different coloring or partial
    coloring of the graph. The graph has edges (0, 3), (1, 2), (1, 4), (2, 3), (2,
    4), and (3, 4).](../images/f16008.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![该图有10个子图，每个子图展示了图的不同着色或部分着色。图中有边 (0, 3)，(1, 2)，(1, 4)，(2, 3)，(2, 4)，和 (3,
    4)。](../images/f16008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: Ten steps of a
    backtracking search graph-coloring algorithm with pruning</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-8：带剪枝的回溯搜索图着色算法的十个步骤</samp>
- en: Backtracking search with pruning is like a methodical conference planner with
    a good eraser. They start by making initial table assignments one by one. For
    each assignment, they check whether there is a known conflict at the table. If
    so, they skip that assignment and avoid wasted effort—there is no point in searching
    for the rest of a solution if they already know it will result in a screaming
    match over the merits of B-trees versus red-black trees. This validity check only
    helps so much, however. The planner still reaches dead ends where the current
    person has no valid table. An ardent LISP programmer will have nowhere to go if
    every table already has at least one Python aficionado. The conference planner
    takes out their trusty eraser, sighs deeply, and starts backtracking to an earlier
    point where they could have made a different assignment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 带剪枝的回溯搜索就像一个有着好橡皮擦的有条理的会议策划人。他们从一个一个地做初步的桌位分配开始。对于每个分配，他们都会检查桌上是否存在已知的冲突。如果有，他们跳过该分配，避免浪费时间——如果他们已经知道会导致围绕B树与红黑树优缺点的激烈争论，那么继续寻找剩下的解决方案就没有意义了。然而，这种有效性检查也仅能帮助到一定程度。策划人仍然会遇到死胡同，当前的与会者没有有效的座位。如果每张桌子上已经坐满了至少一位Python爱好者，那热衷的LISP程序员就无路可走了。会议策划人拿出他们
    trusty 的橡皮擦，深深地叹了口气，开始回溯到一个更早的时刻，在那个地方他们本可以做出不同的分配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">贪心搜索</samp>
- en: Beyond these exact but computationally expensive solutions, we can consider
    heuristic approaches. The *greedy approach* to graph coloring considers one node
    at a time, picking the first color that does not violate any constraints with
    the already assigned neighbors. Unlike the exhaustive algorithms described in
    this section, we define this greedy search without respect to a maximum number
    of colors. While it will always find some solution, the search’s greedy nature
    means it will not always use the smallest possible number of colors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些准确但计算开销大的解决方案外，我们还可以考虑启发式方法。*贪心法*图着色一次考虑一个节点，选择第一个不会与已分配邻居违反任何约束的颜色。与本节描述的穷举算法不同，我们定义的这个贪心搜索并不考虑最大颜色数。虽然它总能找到某个解决方案，但由于其贪心性质，它不一定总是使用最小的颜色数。
- en: The code for the greedy search approach starts with a helper function that finds
    the first valid color for a node by determining which colors are used by its neighbors,
    then choosing the first color not in that set, as shown in [Listing 16-3](#list16-3).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心搜索方法的代码从一个辅助函数开始，该函数通过确定邻居使用的颜色来找到节点的第一个有效颜色，然后选择该集合中没有的第一个颜色，如[第16-3节](#list16-3)所示。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Finding a valid
    color assignment for a node</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第16-3节：为节点找到有效的颜色分配</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    function collects the colors seen in the neighboring nodes in a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>,
    which allows it to easily insert new colors and check whether a color has already
    been used. The code then iterates through all the node’s neighbors. For each neighbor,
    it adds that node’s color to the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    set. It skips unassigned nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>)
    because they do not provide a conflict ❶. The code finishes by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to find the first color that does not occur in the <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    set ❷. While this is not terribly efficient, the loop will always find *some*
    color that could be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> 函数将相邻节点中已使用的颜色收集到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> 数据结构 <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    中，这使得它能够轻松插入新颜色并检查某个颜色是否已被使用。然后，代码会遍历所有该节点的邻居。对于每个邻居，它将该邻居的颜色添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp>
    集合中。它会跳过未分配颜色的节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor.label</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>），因为这些节点不会造成冲突
    ❶。代码最后通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环来查找第一个不在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">used_colors</samp> 集合中的颜色 ❷。虽然这种方式效率不是特别高，但该循环总能找到*某种*可以使用的颜色。
- en: 'Given the helper function, this greedy search can be implemented in a single
    loop:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 给定辅助函数后，这种贪心搜索可以在一个循环中实现：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_greedy()</samp>
    function iterates through all nodes using the index variable <samp class="SANS_TheSansMonoCd_W5Regular_11">idx</samp>.
    For each node, it calls the helper function from [Listing 16-3](#list16-3) to
    find the first color that does not conflict with an assigned neighbor. For consistency
    with other algorithms in this chapter, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    to indicate that it has found a valid coloring.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">graph_color_greedy()</samp> 函数使用索引变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idx</samp> 遍历所有节点。对于每个节点，它调用[第16-3节](#list16-3)中的辅助函数，找到第一个不与已分配邻居冲突的颜色。为了与本章中的其他算法保持一致，函数返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，表示已找到有效的着色。
- en: We can visualize the greedy algorithm through the eyes of the Conference Chair
    for Banquet Seating at the data structure convention. The organizer iterates through
    the list of attendees one by one, assigning each to a table before moving on to
    the next. For each attendee, they review the list of available tables and check
    whether a conflict would arise with any of the attendees already assigned there.
    This is equivalent to checking whether the current attendee (node) has a conflict
    (shares an edge) with any of the table’s other occupants (already assigned nodes).
    If so, the organizer moves on to the next table on the list. If they run out of
    tables, they sigh, mumble unkind words about the absurdity of programming language
    fights, and add a new table to the floor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过数据结构大会上宴会座位安排的会议主席的视角来形象化贪心算法。组织者逐一遍历与会者名单，在将每位与会者安排到一张桌子后，再继续安排下一位。对于每位与会者，组织者查看可用的桌子列表，并检查是否与已安排在某桌的与会者发生冲突。这相当于检查当前与会者（节点）是否与该桌的其他占用者（已安排的节点）发生冲突（共享边）。如果发生冲突，组织者将转到下一张桌子。如果桌子安排完毕，组织者会叹气，嘟囔着一些不友好的话，关于编程语言争斗的荒谬，并在场地上添加一张新桌子。
- en: '[Figure 16-9](#fig16-9) illustrates this greedy search. During the first iteration
    in [Figure 16-9(a)](#fig16-9), the code assigns a color to node 0\. In [Figure
    16-9(b)](#fig16-9), it then considers node 1\. Since that node shares an edge
    with node 0, the search cannot reuse color = 1\. Instead, it assigns node 1 to
    color = 2\. When it considers node 2 in [Figure 16-9(c)](#fig16-9), the only assigned
    neighbor has color = 2, so the search can assign node 2 color = 1\. This search
    continues until it has assigned all nodes a color, as shown in [Figure 16-9(e)](#fig16-9).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-9](#fig16-9)说明了这个贪心搜索过程。在[图16-9(a)](#fig16-9)的第一次迭代中，代码为节点0分配颜色。在[图16-9(b)](#fig16-9)中，接着考虑节点1。由于该节点与节点0共享一条边，因此搜索不能重用颜色=1，而是为节点1分配颜色=2。当在[图16-9(c)](#fig16-9)中考虑节点2时，唯一已分配的邻居颜色为2，因此搜索可以为节点2分配颜色=1。这个过程持续进行，直到为所有节点分配颜色，如[图16-9(e)](#fig16-9)所示。'
- en: '![A graph with five nodes and edges (0, 1), (0, 3), (0, 4), (1, 2), (1, 4),
    (2, 4), and (3, 4). (A) shows the five-node graph with only node 0 labeled with
    color = 1\. (B) shows the same graph with node 0 labeled with color = 1 and node
    1 labeled with color = 2\. (C) shows the assignments [1, 2, 1, None, None]. (D)
    shows the assignments [1, 2, 1, 2, None]. (E) shows the assignments [1, 2, 1,
    2, 3].](../images/f16009.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和边（0, 1），（0, 3），（0, 4），（1, 2），（1, 4），（2, 4）和（3, 4）的图。（A）展示了只有节点0被标记为颜色=1的五节点图。（B）展示了同样的图，节点0标记为颜色=1，节点1标记为颜色=2。（C）展示了分配为[1,
    2, 1, None, None]的分配。（D）展示了分配为[1, 2, 1, 2, None]的分配。（E）展示了分配为[1, 2, 1, 2, 3]的分配。](../images/f16009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: The five steps
    of a greedy coloring algorithm</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-9：贪心着色算法的五个步骤</samp>
- en: Given enough colors, the greedy algorithm will find a valid coloring for the
    graph. However, this assignment is not guaranteed to use the fewest colors. Instead,
    the order in which the nodes are assigned has a significant impact on how many
    colors the greedy algorithm will require. Consider [Figure 16-10](#fig16-10),
    which shows two valid ways of coloring the same graph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有足够颜色的情况下，贪心算法将为图找到有效的着色。然而，这种分配并不保证使用最少的颜色。相反，节点分配的顺序对贪心算法需要多少颜色有显著影响。请参见[图16-10](#fig16-10)，它展示了同一图的两种有效着色方法。
- en: '![Both subfigures show graphs with five nodes and edges (0, 3), (1, 2), (1,
    4), (2, 3), (2, 4), and (3, 4). (A) shows the graph with assignments [1, 1, 2,
    3, 4]. (B) shows the graph with assignments [1, 3, 2, 3, 1]. ](../images/f16010.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![两个子图都展示了包含五个节点和边（0, 3），（1, 2），（1, 4），（2, 3），（2, 4）和（3, 4）的图。（A）展示了分配为[1,
    1, 2, 3, 4]的图。（B）展示了分配为[1, 3, 2, 3, 1]的图。](../images/f16010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: A graph where
    the greedy coloring approach finds a solution with four colors (a) while there
    exists a solution with only three (b)</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图16-10：一个图，其中贪心着色方法使用四种颜色（a）找到了解决方案，而实际上只需三种颜色（b）即可得到解决方案</samp>
- en: '[Figure 16-10(a)](#fig16-10) shows the graph coloring produced by the greedy
    algorithm. Because the search assigns the same color to nodes 0 and 1, it must
    use a fourth color on node 4\. In contrast, depth-first search with pruning would
    find an optimal coloring requiring only three colors, as shown in [Figure 16-10(b)](#fig16-10).
    The trade-off is speed versus optimality. While the greedy search will occasionally
    use more than the minimum number of colors, its lack of backtracking makes it
    faster.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-10(a)](#fig16-10)展示了贪心算法生成的图着色。由于搜索为节点0和1分配了相同的颜色，它必须在节点4上使用第四种颜色。相比之下，采用深度优先搜索并进行剪枝的算法会找到一个仅需三种颜色的最优着色，如
    [图16-10(b)](#fig16-10) 所示。两者的权衡是速度与最优性的选择。虽然贪心搜索有时会使用超过最少颜色数的颜色，但它没有回溯过程，因此执行速度更快。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Node Removal</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">节点移除</samp>
- en: Another heuristic algorithm worth discussing is the *removal algorithm* proposed
    by a team of scientists at IBM to find nonconflicting assignments of variables
    to CPU registers in a compiler. This algorithm works by iteratively simplifying
    the problem if possible. As with the example of assigning parking spaces, the
    paper’s authors defined register assignment as a graph-coloring problem that uses
    nodes to represent variables, edges to capture which variables were in use at
    the same time, and colors to represent each of the CPU’s registers. The number
    of colors is fixed at *C* by the chip’s architecture. The algorithm’s goal is
    to determine whether it can find a graph coloring that uses *C* or fewer colors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得讨论的启发式算法是IBM团队提出的*移除算法*，用于在编译器中为CPU寄存器分配变量，以避免冲突。该算法通过迭代地简化问题来工作（如果可能的话）。就像为停车位分配空间的例子一样，论文的作者将寄存器分配定义为一个图着色问题，节点代表变量，边表示哪些变量在同一时刻被使用，而颜色则代表每个CPU的寄存器。颜色的数量由芯片架构固定为*C*。该算法的目标是确定是否能找到一种着色方式，使得使用的颜色数不超过*C*。
- en: 'As discussed in their paper “Register Allocation via Coloring” by George Chaitin
    et al., the IBM team proposed a multistep approach to register allocation that
    includes a node removal algorithm for generating the color assignments. This algorithm
    relies on the insight that if a node has fewer than *C* edges, we can trivially
    assign it a color after we have assigned colors to its neighbors. We simply review
    its neighbors’ colors and use any color that doesn’t occur among those nodes,
    reusing our <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    function from [Listing 16-3](#list16-3). Therefore, we can initially ignore a
    node with fewer than *C* edges and focus on the more difficult cases: nodes with
    *C* or more neighbors. In fact, we can go one step further and temporarily remove
    any node with fewer than *C* edges from the graph, along with its edges, while
    we deal with the remaining nodes. We then re-add that node when it is time to
    assign its color.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如乔治·蔡廷（George Chaitin）等人在其论文《通过着色进行寄存器分配》中所讨论的那样，IBM团队提出了一种多步骤的寄存器分配方法，其中包括一个用于生成颜色分配的节点移除算法。该算法基于一个洞察力：如果一个节点的边数少于*C*，在为其邻居分配颜色后，我们可以轻松地为它分配一个颜色。我们只需要查看其邻居的颜色，并使用任何在这些邻居中没有出现过的颜色，重新利用我们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> 函数，参考
    [Listing 16-3](#list16-3)。因此，我们可以最初忽略那些边数少于*C*的节点，专注于处理那些更复杂的情况：拥有*C*个或更多邻居的节点。实际上，我们可以更进一步，暂时从图中移除所有边数少于*C*的节点及其边，处理完其他节点后再重新加入这些节点，并为它们分配颜色。
- en: Based on this insight, the algorithm iteratively checks the nodes in the current
    graph and removes any that have *C* or fewer edges, along with those edges. It
    adds these nodes to a stack to revisit once it has dealt with the more difficult
    cases. As it removes nodes and edges, new nodes will drop below the *C* neighbor
    threshold and can be removed as well. It knows that it will be able to easily
    find a color for those nodes using <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    when it returns to them after assigning colors to the neighbors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一洞察力，该算法会迭代检查当前图中的节点，并移除所有边数少于*C*的节点以及它们的边。它会将这些节点加入栈中，待处理完更复杂的情况后再重新访问。随着节点和边的移除，新的节点会低于*C*邻居的阈值，也可以被移除。它知道，在为邻居分配颜色后，当回到这些节点时，可以轻松地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> 为这些节点分配颜色。
- en: If the algorithm can remove every node from the graph, we know it has a valid
    coloring with *C* colors. If the search tracks what it removes in a stack, it
    can pop items from the stack to reverse the operations and reassemble the graph,
    using it to effectively re-add the nodes to the graph and assign colors along
    the way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法能够从图中移除每个节点，那么我们就知道它具有有效的*C*色彩。如果搜索跟踪它在栈中移除的内容，它可以从栈中弹出项目，逆转操作并重新组装图，通过这种方式有效地重新将节点添加到图中，并在此过程中分配颜色。
- en: 'The code for the removal algorithm uses this two-phase approach:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 移除算法的代码使用了这种两阶段的方法：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code starts by creating multiple helper data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp>
    array stores a Boolean for each node, allowing the code to quickly check whether
    a node is still in the graph. The list <samp class="SANS_TheSansMonoCd_W5Regular_11">node_stack</samp>
    stores information about the nodes removed from the graph and the order in which
    they were removed. The code also makes a copy of the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>),
    allowing it to remove edges without modifying the original graph ❶.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建了多个辅助数据结构。<samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp>
    数组为每个节点存储一个布尔值，允许代码快速检查节点是否仍然在图中。<samp class="SANS_TheSansMonoCd_W5Regular_11">node_stack</samp>
    列表存储了被移除的节点的信息以及它们被移除的顺序。代码还创建了图的副本（<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>），允许它移除边而不修改原始图❶。
- en: The code then enters a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that continues as long as the function has removed at least one node in the
    previous iteration (as tracked by the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">removed_one</samp>).
    Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, the
    code iterates through each node in the graph, checking whether that node has already
    been removed and how many neighbors it has ❷. If the node has not been removed
    and has fewer than *C* (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>)
    neighbors, the code adds the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">node
    _stack</samp>, removes all its edges ❸, and marks the node as removed. Technically,
    the code removes only the edges from the graph; the nodes’ removals are captured
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp> array.
    This allows us to stably iterate over the graph’s nodes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and doesn’t impact the accuracy of the algorithm.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码进入一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，只要函数在前一次迭代中移除了至少一个节点（通过布尔值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">removed_one</samp> 跟踪）。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环中，代码遍历图中的每个节点，检查该节点是否已经被移除以及它有多少个邻居❷。如果节点没有被移除且邻居数量少于 *C*（<samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>）个，代码会将节点添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">node_stack</samp> 中，移除它的所有边❸，并将节点标记为已移除。从技术上讲，代码仅移除图中的边；节点的移除通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">removed</samp> 数组捕获。这使我们能够在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中稳定地遍历图中的节点，并且不会影响算法的准确性。
- en: If the code does not manage to remove all the nodes from the graph and add them
    to the stack, it has failed in finding a valid color assignment ❹. In this case,
    the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If
    there is a valid assignment, the code assigns the colors one at a time ❺. As it
    pops each node from the stack, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    from [Listing 16-3](#list16-3) to choose a valid color. Since the node had fewer
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp> neighbors
    when it was added to the stack, it now must have fewer than <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>
    neighbors that have been assigned a color. Thus <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    will choose a valid color in the range [1, <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码未能将图中的所有节点移除并将其添加到堆栈中，则说明它在寻找有效颜色分配时失败了 ❹。在这种情况下，代码返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果存在有效的分配，代码会一次为每个节点分配颜色
    ❺。每次从堆栈中弹出一个节点时，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp>
    来选择一个有效的颜色，来自[清单 16-3](#list16-3)。由于当节点被加入堆栈时，其邻居少于 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>，因此它现在必须有少于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp> 个已分配颜色的邻居。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">first_unused_color()</samp> 将在[1, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_colors</samp>]范围内选择一个有效的颜色。
- en: We can picture the removal algorithm in the context of our conference planner
    by employing the key phrase “I’ll just deal with this attendee later.” Any time
    the conference planner sees an attendee with fewer than *C* conflicts, they dismissively
    say, “This person isn’t going to be a problem. I can find a table for them. I’ll
    just deal with them after I’ve handled the difficult attendees.” Outsiders might
    see this as procrastination, but graph-coloring enthusiasts recognize it as a
    key algorithmic insight.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用关键短语 “我稍后再处理这个与会者” 来在会议计划者的背景下想象移除算法。每当会议计划者看到一个冲突少于 *C* 的与会者时，他们会不屑地说：“这个人不会成为问题的。我可以为他们找一个桌子。我会在处理完困难的与会者之后再处理他们。”
    外部人可能会认为这是拖延，但图着色爱好者会把它看作是一个关键的算法性洞察。
- en: '[Figures 16-11](#fig16-11) shows the first phase of this code’s operation for
    *C* = 3\. In this stage, the nodes are removed one at a time. During the first
    iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop,
    three nodes are removed. Node 2 has fewer than *C* neighbors and is added to the
    stack in [Figure 16-11(b)](#fig16-11). Node 3 is removed next in [Figure 16-11(c)](#fig16-11).
    At this point, node 4 has fewer than *C* neighbors and can also be removed, as
    shown in [Figure 16-11(d)](#fig16-11).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-11](#fig16-11) 显示了此代码操作的第一阶段，其中 *C* = 3。在这个阶段，节点是一次一个地被移除。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环的第一次迭代中，移除了三个节点。节点 2 的邻居少于 *C*，因此它被加入到堆栈中，如[图 16-11(b)](#fig16-11)所示。接下来，在[图
    16-11(c)](#fig16-11)中移除了节点 3。此时，节点 4 的邻居少于 *C*，也可以被移除，如[图 16-11(d)](#fig16-11)所示。'
- en: '![(A) shows the five-node graph with edges (0, 1), (0, 3), (0, 4), (1, 2),
    (1, 4), (2, 4), and (3, 4). Each subsequent subfigure shows the graph with one
    additional node removed and the corresponding number added to the stack. (B) has
    node 2 removed. (C) has node 3 removed. (D) has node 4 removed. (E) has node 0
    removed. (F) has no nodes remaining.](../images/f16011.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了包含边 (0, 1)、(0, 3)、(0, 4)、(1, 2)、(1, 4)、(2, 4) 和 (3, 4) 的五节点图。每个后续的小图显示了图中移除了一个额外的节点，并且相应的节点被添加到堆栈中。(B)
    移除了节点 2。(C) 移除了节点 3。(D) 移除了节点 4。(E) 移除了节点 0。(F) 不再有节点剩余。](../images/f16011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-11: The first phase
    of the removal graph-coloring algorithm</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-11：移除图着色算法的第一阶段</samp>
- en: The algorithm has now passed through each node in the graph one time. Since
    it has removed at least one node during this iteration, it restarts from node
    0 and checks again. In [Figure 16-11(e)](#fig16-11) it removes node 0, which has
    only one remaining neighbor. Finally, it removes node 1 in [Figure 16-11(f)](#fig16-11).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法现在已经遍历了图中的每个节点一次。由于它在这次迭代中移除了至少一个节点，因此它从节点 0 重新开始，并再次检查。在[图 16-11(e)](#fig16-11)中，它移除了节点
    0，该节点只有一个剩余的邻居。最后，在[图 16-11(f)](#fig16-11)中，它移除了节点 1。
- en: The second phase of the algorithm, shown in [Figure 16-12](#fig16-12), labels
    and “re-adds” the nodes. The algorithm starts by popping node 1 from the stack
    and assigning it color 1, as shown in [Figure 16-12(a)](#fig16-12). In [Figure
    16-12(b)](#fig16-12), the algorithm pops node 0 from the stack and assigns node
    0 the first color that does not conflict with a neighbor. This process continues
    for nodes 4, 3, and 2 in [Figures 16-12(c)](#fig16-12), [16-12(d)](#fig16-12),
    and [16-12(e)](#fig16-12), respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第二阶段，如[图 16-12](#fig16-12)所示，是标记并“重新添加”节点。算法首先从栈中弹出节点 1，并将其标记为颜色 1，如[图 16-12(a)](#fig16-12)所示。在[图
    16-12(b)](#fig16-12)中，算法从栈中弹出节点 0，并将节点 0 分配为不与邻居冲突的第一个颜色。这个过程继续在[图 16-12(c)](#fig16-12)、[16-12(d)](#fig16-12)和[16-12(e)](#fig16-12)中依次进行，分别为节点
    4、3 和 2 着色。
- en: '![Each subfigure shows the graph with one additional node re-added and colored.
    (A) shows node 1 with color 1\. (B) Adds Node 0 with color 2\. (C) adds node 4
    with color 3\. (D) adds node 3 with color 1\. (E) adds node 2 with color 2.>](../images/f16012.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了图中一个附加的节点重新加入并着色。（A）显示节点 1 使用颜色 1。 （B）加入节点 0 使用颜色 2。 （C）加入节点 4 使用颜色
    3。 （D）加入节点 3 使用颜色 1。 （E）加入节点 2 使用颜色 2。](../images/f16012.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-12: The second phase
    of the removal graph-coloring algorithm</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-12：移除图着色算法的第二阶段</samp>
- en: Unfortunately, this heuristic approach is not sufficient to solve every graph.
    A graph coloring can sometimes use fewer than *C* colors despite a cluster of
    interconnected nodes with at least *C* edges. In [Figure 16-13](#fig16-13), for
    example, the removal algorithm would fail for *C* = 3 despite a valid coloring
    with only two colors. Since every node has three neighbors, the removal algorithm
    cannot remove any. It is stuck.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种启发式方法并不足以解决所有图。即使在有一个至少有 *C* 条边的互联节点集群的情况下，图着色有时也可以使用少于 *C* 种颜色。例如，在[图
    16-13](#fig16-13)中，尽管仅用两种颜色就可以完成有效的着色，但当 *C* = 3 时，移除算法会失败。因为每个节点都有三个邻居，移除算法无法删除任何节点。它陷入了死胡同。
- en: '![A bipartite graph with six nodes and nine edges.](../images/f16013.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和九条边的二分图。](../images/f16013.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-13: An example graph
    for which the removal algorithm fails</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 16-13：一个移除算法失败的示例图</samp>
- en: Yet it is obvious that we could create a valid assignment for the graph in [Figure
    16-13](#fig16-13) with only two colors. We could assign all nodes on the left
    a color of 1 and all nodes on the right a color of 2\. Because the edges connect
    only left nodes to right nodes, there would be no conflicts. In fact, we could
    solve this particular case with the bipartite labeling algorithm from [Chapter
    15](chapter15.xhtml).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很明显，我们可以为[图 16-13](#fig16-13)创建一个有效的着色方案，只需使用两种颜色即可。我们可以将所有左侧节点分配为颜色 1，所有右侧节点分配为颜色
    2。由于边仅连接左侧节点和右侧节点，便不会发生冲突。实际上，我们可以使用[第 15 章](chapter15.xhtml)中的二分图标记算法来解决这个特殊的案例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: The problem of finding an assignment of graph nodes to colors has a range of
    real-world use cases, from planning out magical labyrinths to assigning parking
    spaces. What makes this problem interesting is that there is no known algorithm
    that efficiently solves every case. Instead, we need to rely on either exhaustive
    searches or heuristics. This has led to the development of a variety of approaches
    aimed at providing good performance under different real-world conditions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图节点着色问题在现实世界中有多种应用场景，从规划魔法迷宫到分配停车位。这个问题之所以有趣，是因为没有已知的算法能够高效地解决所有情况。相反，我们必须依赖于穷举搜索或启发式方法。这促使我们开发了各种方法，以在不同的现实世界条件下提供良好的性能。
- en: In the next chapter we examine similar assignment problems that do not have
    a known efficient solution. We look at a range of different branching searches
    based on the backtracking depth-first search from this chapter, as well as considering
    a variety of heuristics and the use of randomized algorithms to find solutions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨类似的任务分配问题，这些问题目前没有已知的高效解法。我们将研究基于本章回溯深度优先搜索的多种不同分支搜索方法，并考虑各种启发式方法和使用随机算法来寻找解决方案。
