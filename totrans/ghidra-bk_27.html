<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_505"/>
<h2 class="h2" id="ch22"><strong><span class="big">22</span><br/>PATCHING BINARIES</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindents">Occasionally when reverse engineering a binary, you may decide that you want to modify the behavior of the original binary. Behavioral modification is usually accomplished by patching the binary to insert, remove, or modify existing instructions. Many motivations exist for making such modifications—some more controversial than others—including the following:</p>
<ul>
<li><p class="noindent">Modifying a malware sample to eliminate anti-debug techniques that prevent the malware from being studied</p></li>
<li><p class="noindent">Patching vulnerabilities in software for which you have no source code</p></li>
<li><p class="noindent">Customizing an application’s splash screen or string content</p></li>
<li><p class="noindent">Modifying game logic for the purposes of cheating</p></li>
<li><p class="noindent">Unlocking hidden features</p></li>
<li><p class="noindent">Bypassing licensing checks or other anti-piracy protections</p></li>
</ul>
<span epub:type="pagebreak" id="page_506"/>
<p class="indent">In this chapter, we have no intention of teaching you how to do anything unethical, but we discuss the high-level challenges of modifying a binary to reflect any changes that you have made within Ghidra. <a href="ch14.xhtml#ch14">Chapter 14</a> introduced the <code>setByte</code> API function, and <a href="ch21.xhtml#ch21">Chapter 21</a> showed how different styles of emulation scripts were able to modify the content of a program loaded into Ghidra. These techniques modify the content that has been imported into Ghidra and have no effect whatsoever on the original binary file that Ghidra processed during the import process. To complete the patching process, you’ll learn how to get Ghidra to write changes back to a file on disk. We also discuss the challenges that different types of patches might pose.</p>
<h3 class="h3" id="ch22lev416"><strong>Planning Your Patch</strong></h3>
<p class="noindent">The patching process typically involves the following steps:</p>
<ol>
<li><p class="noindent">Determine the type of patch you intend to make. This will often be determined by your rationale for patching, as discussed previously.</p></li>
<li><p class="noindent">Identify the exact program location(s) that needs to be patched. This typically involves some amount of research and analysis of the program to be patched.</p></li>
<li><p class="noindent">Plan the content of your patch. Content changes may require new data, new machine code, or both. In any case, your changes must be well thought out to prevent the program from exhibiting any unintended behavior.</p></li>
<li><p class="noindent">Use Ghidra to replace existing program content (data or code) with your replacement content.</p></li>
<li><p class="noindent">Use Ghidra to verify that your changes appear to be correctly implemented.</p></li>
<li><p class="noindent">Use Ghidra to export your changes into a new binary file.</p></li>
<li><p class="noindent">Verify that the new binary file behaves as intended, repeating from step 2 as necessary.</p></li>
</ol>
<p class="indent">In some patching scenarios, many of these steps will be almost trivial; in others, they will be much more challenging. In the sections that follow, we review those steps that Ghidra can help you with and discuss situations that may push you or Ghidra to your limits. We’ll start with step 2 and review some of the ways that Ghidra helps you locate items of interest in a patching context.</p>
<h3 class="h3" id="ch22lev417"><strong>Finding Things to Change</strong></h3>
<p class="noindent">The exact nature of your patch will dictate what you need to patch. Custom­izing splash screens or strings requires that you locate the original data that needs changing. Changing the logic of a program requires modifying or inserting code to change the program’s behavior. In this case, a significant <span epub:type="pagebreak" id="page_507"/>amount of reverse engineering may be required just to find any program locations that need to be modified. Many of Ghidra’s capabilities that facilitate these activities have been covered in previous chapters. Let’s review some of the capabilities useful for patching.</p>
<h4 class="h4" id="ch22lev418"><strong><em>Searching Memory</em></strong></h4>
<p class="noindent">When your patch involves modifying program data, your primary means of identifying where to apply your patches will be some form of memory search. The most general memory search is the CodeBrowser’s Search ▸ Memory menu option (hotkey S), shown in <a href="ch22.xhtml#fig22_1">Figure 22-1</a> (with Advanced options expanded). The Search Memory dialog was previously discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>
<div class="image"><img src="Images/fig22-1.jpg" alt="image" width="694" height="588"/></div>
<p class="figcap" id="fig22_1"><em>Figure 22-1: The Search Memory dialog</em></p>
<p class="indent">The Search Memory dialog is most useful in a patching context when you are searching for specific, known data within the binary, such as known strings or hex sequences. A successful search will reposition all linked displays to the location of the matching bytes, or in the case of Search All, open a new dialog containing a list of all addresses at which the matched content may be found. For very large binaries, it may be useful to limit the scope of your search to specific regions (Instructions, Defined Data, Undefined Data, and so on) within the program that are likely to contain a match by deselecting any uninteresting code unit types.</p>
<span epub:type="pagebreak" id="page_508"/>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>While Search ▸ Memory provides the most configurable general-purpose search capability in Ghidra, it is a search across the raw byte content of the database, and other search types may be more suited to the type of data you are looking for. For example, Search ▸ Memory is the wrong choice if you want to search within the body of comments that you have entered into the program. Refer to “<a href="ch06.xhtml#ch06lev115">Search Program Text</a>” on <a href="ch06.xhtml#page_115">page 115</a> for more information on searching within the disassembly listing itself.</em></p>
</div>
<h4 class="h4" id="ch22lev419"><strong><em>Searching for Direct References</em></strong></h4>
<p class="noindent">In <a href="ch20.xhtml#ch20">Chapter 20</a>, we used Search ▸ For Direct References to scan the program’s binary content for all occurrences of a specific address. The most common use for this search type is to locate pointers to interesting data when Ghidra has failed to create a cross-reference to the data. In a patching context, this is most often used to fully understand and update all references to a data or code location to maintain proper relationships between code and data in the patched binary.</p>
<h4 class="h4" id="ch22lev420"><strong><em>Searching for Instruction Patterns</em></strong></h4>
<p class="noindent">Ghidra’s Search ▸ For Instruction Patterns feature finds a specific sequence of instructions by matching a pattern. When defining an instruction pattern, you need to strike a delicate balance between patterns that are too specific and patterns that are too general. Let’s look at an example to illustrate this idea. Assume we have a listing that includes a <code>cleanup_and_exit</code> function that exits the program:</p>
<pre>   int test_even(int v) {<br/>
       return (v % 2 == 0);<br/>
   }<br/>
   int test_multiple_10(int v) {<br/>
       return (v % 10 == 0);<br/>
   }<br/>
   int test_lt_100(int v) {<br/>
       return v &lt; 100;<br/>
   }<br/>
   int test_gte_20(int v) {<br/>
       return v &gt;= 20;<br/>
   }<br/>
<span class="ent">➊</span> void cleanup_and_exit(int rv, char* s) {<br/>
       printf("Result: %s\n", s);<br/>
       exit(rv);<br/>
   }<br/>
   void do_testing() {<br/>
       int v;<br/>
       srand(time(0));<br/>
       v = rand() % 150;<br/>
       printf("Testing %d\n", v);<br/>
     <span class="ent">➋</span> if (!test_even(v)) {<br/>
           cleanup_and_exit(-1, "failed even test");<br/>
       }<br/>
       if (test_multiple_10(v)) {<br/>
            cleanup_and_exit(-2, "failed not multiple of 10 test");<br/>
<span epub:type="pagebreak" id="page_509"/>
       }<br/>
       if (!test_lt_100(v)) {<br/>
           cleanup_and_exit(-3, "failed &lt;100 test");<br/>
       }<br/>
       if (!test_gte_20(v)) {<br/>
           cleanup_and_exit(-4, "failed &gt; 20 test");<br/>
       }<br/>
       // all tests passed so do interesting work here<br/>
     <span class="ent">➌</span> system("/bin/sh");<br/>
       cleanup_and_exit(0, "success!");<br/>
   }<br/>
   int main() {<br/>
       do_testing();<br/>
       return 0;<br/>
   }</pre>
<p class="indent">The function <code>do_testing</code> conducts a series of tests <span class="ent">➋</span>. If any of the tests fail, the <code>cleanup_and_exit</code> function <span class="ent">➊</span> is called and execution ends. If all tests succeed, some very interesting code <span class="ent">➌</span> will execute. Our patching challenge is to determine where we need to patch to ensure that all of the tests pass so that we can reach the interesting code.</p>
<p class="indent">If we load the binary into Ghidra, we can search for all calls to <code>cleanup_and_exit</code> to determine what we need to patch in order for all of the tests to pass regardless of the number of tests. We have several options to consider:</p>
<ul>
<li><p class="noindent">We could just go to that function and patch it to return so that a failed test doesn’t exit the program but rather continues. This isn’t an optimal solution because the function is also used for a legitimate exit at the end of the program after it completes the interesting work.</p></li>
<li><p class="noindent">We could use search functionality or XREFs to <code>cleanup_and_exit</code>. This would give us all of the calls, but we wish to patch only some of them.</p></li>
<li><p class="noindent">We could identify an instruction pattern that the calls have in common and use Search ▸ For Instruction Patterns to find the correct calls to patch.</p></li>
</ul>
<p class="indent">To use this search functionality, we need to identify a useful pattern. Each test we are trying to pass takes the following form in the Listing window:</p>
<pre>001008af  CALL   test_even<br/>
001008b4  TEST   EAX,EAX<br/>
001008b6  JNZ    LAB_001008c9<br/>
001008b8  LEA    RSI,[s_failed_even_test_00100a00]<br/>
001008bf  MOV    EDI,0xffffffff<br/>
001008c4  CALL   cleanup_and_exit</pre>
<p class="indent">Let’s try searching for that sequence by selecting the instruction sequence and Search ▸ For Instruction Patterns. This automatically populates the Instruction Pattern Search dialog, as shown in <a href="ch22.xhtml#fig22_2">Figure 22-2</a>.</p>
<span epub:type="pagebreak" id="page_510"/>
<div class="image"><img src="Images/fig22-2.jpg" alt="image" width="844" height="490"/></div>
<p class="figcap" id="fig22_2"><em>Figure 22-2: Instruction Pattern Search dialog with all fields selected</em></p>
<p class="indent">If we click Search All, we see only one result (the specific location that we selected when we started the search), as shown in <a href="ch22.xhtml#fig22_3">Figure 22-3</a>.</p>
<div class="image"><img src="Images/fig22-3.jpg" alt="image" width="694" height="288"/></div>
<p class="figcap" id="fig22_3"><em>Figure 22-3: Instruction pattern search results from all fields selected</em></p>
<p class="indent">Our issue is that we are including operands that do not remain constant between the test cases. For example, the operand to the first call is the address of a specific test function. We can deselect individual components (mnemonics and operands) of any instruction in the pattern to make it more general, as shown in <a href="ch22.xhtml#fig22_4">Figure 22-4</a>. Anything that has been deselected is treated as a wildcard in subsequent searches.</p>
<span epub:type="pagebreak" id="page_511"/>
<div class="image"><img src="Images/fig22-4.jpg" alt="image" width="844" height="429"/></div>
<p class="figcap" id="fig22_4"><em>Figure 22-4: Instruction Pattern Search dialog with some operands deselected</em></p>
<p class="indent">If we click Search All with operand fields disabled, we see the three results shown in <a href="ch22.xhtml#fig22_5">Figure 22-5</a>.</p>
<div class="image"><img src="Images/fig22-5.jpg" alt="image" width="694" height="325"/></div>
<p class="figcap" id="fig22_5"><em>Figure 22-5: Instruction pattern search results with some operands deselected</em></p>
<p class="indent">The search still fails to identify the call to <code>test_multiple_10</code>, which uses a <code>JZ</code> rather than a <code>JNZ</code> instruction. Deselecting the mnemonic field for the <code>JNZ</code> instruction and rerunning the search yields the results shown in <a href="ch22.xhtml#fig22_6">Figure 22-6</a>, which includes the four calls we wish to patch and does not include the final call to <code>cleanup_and_exit</code> that we do not want to patch.</p>
<span epub:type="pagebreak" id="page_512"/>
<div class="image"><img src="Images/fig22-6.jpg" alt="image" width="694" height="364"/></div>
<p class="figcap" id="fig22_6"><em>Figure 22-6: Instruction pattern search results with</em> <code>JNZ</code> <em>and some operands deselected</em></p>
<p class="indent">This search functionality has a number of uses beyond locating candidate instruction patterns for patching. It can be used for vulnerability analysis, finding specific functionality, and other searches to identify instruction patterns important to reverse engineers.</p>
<h4 class="h4" id="ch22lev421"><strong><em>Finding Specific Behaviors</em></strong></h4>
<p class="noindent">A program’s behavior is defined by the instructions that it executes combined with the data on which it executes. When your patching task involves modifying a program’s behavior, locating the exact behavior that you want to modify is usually much more difficult than locating data that you wish to change. Because we can never predict the exact instruction sequence that a compiler might generate for any source code, it is challenging to use Ghidra’s automated search features to pinpoint an exact location to apply a code patch. Locating specific behaviors boils down to plain-old analysis of the functions in the program using techniques covered throughout this book.</p>
<p class="indent">Other than a careful analysis of all functions in the binary or a careful traversal of the call tree, beginning with a well-known function such as <code>main</code>, the two most common techniques for identifying functions of interest are relying on the function’s name (assuming the binary has symbols) and using cross-references from “interesting” data to backtrack to potentially interesting functions. For example, if we are interested in locating the authentication-related functions within a binary, we might search for common strings associated with authentication such as <code>"Please enter your</code> <code>password:</code><code>"</code> and <code>"Authentication failed"</code>. Strings similar to these often bookend an authentication process, and locating functions that reference these strings may significantly reduce our search space for other authentication-related functions.</p>
<p class="indent">Here again, the nature of the data that might lead you to find interesting functions will depend on your particular patching scenario. Regardless of the approaches you use to locate a function that is a candidate for your <span epub:type="pagebreak" id="page_513"/>patch, you should always verify that the function does in fact implement the behavior you wish to modify. In particular, you should always be wary of the names that programmers assign to functions, as there is no requirement for a function’s behavior to match its name.</p>
<h3 class="h3" id="ch22lev422"><strong>Applying Your Patch</strong></h3>
<p class="noindent">At long last, your hard work and perseverance have paid off, and you have located the code or data that you wish to modify. What now? Assuming you have already developed the replacement content that you intend to patch into the binary, and know precisely where you want to place it, it’s time to exercise the Ghidra features that modify the program.</p>
<p class="indent">The first thing you need to consider is the size of your new content relative to the content you are replacing. If the new content’s size is less than or equal to the original content’s size, you are in good shape because your patch will fit within the memory footprint of the original content. However, things get a bit tricky when your patch is larger than the original content, and we will dedicate some time to this case shortly.</p>
<h4 class="h4" id="ch22lev423"><strong><em>Making Basic Changes</em></strong></h4>
<p class="noindent">Whether you have a pile of bytes in hand or need some help from an assembler, you’ll eventually need to get your content into Ghidra. For short runs of bytes, you may find it easier to use Ghidra’s built-in byte editor or assembler. For longer runs, you’ll probably want to automate. The next few sections describe some of Ghidra’s byte-level editing features.</p>
<h5 class="h5" id="ch22lev424"><strong>Byte Viewer</strong></h5>
<p class="noindent">The Ghidra Byte Viewer (Window ▸ Bytes), shown in <a href="ch22.xhtml#fig22_7">Figure 22-7</a>, provides a standard hex dump view of the raw byte content at the current listing location, synchronized with every other linked window.</p>
<div class="image"><img src="Images/fig22-7.jpg" alt="image" width="694" height="261"/></div>
<p class="figcap" id="fig22_7"><em>Figure 22-7: The Ghidra Byte Viewer</em></p>
<p class="indent">The Byte Viewer can also double as a hex editor by toggling the Edit Mode tool <span class="ent">➊</span>, and it’s a convenient option when you need to change a few bytes at a time.</p>
<span epub:type="pagebreak" id="page_514"/>
<p class="indent">Inconveniently, Ghidra will not allow you to edit any bytes that are part of an existing instruction. The workaround for this limitation is to clear the associated instruction in the Listing window (right-click Clear Code Bytes or press hotkey C). The Byte Viewer Options tool <span class="ent">➋</span> is used to open the dialog shown in <a href="ch22.xhtml#fig22_8">Figure 22-8</a>, which allows you to customize your Byte Viewer display.</p>
<div class="image"><img src="Images/fig22-8.jpg" alt="image" width="405" height="464"/></div>
<p class="figcap" id="fig22_8"><em>Figure 22-8: Byte Viewer Options dialog</em></p>
<p class="indent">Selecting the Ascii option adds an ASCII dump to the Byte Viewer (see <a href="ch22.xhtml#fig22_9">Figure 22-9</a>), which then doubles as an ASCII editor while in edit mode.</p>
<div class="image"><img src="Images/fig22-9.jpg" alt="image" width="844" height="298"/></div>
<p class="figcap" id="fig22_9"><em>Figure 22-9: Byte Viewer with ASCII dump enabled</em></p>
<p class="indent">Once you have finished entering your new values, you should toggle out of Edit Mode and return to the Listing window to verify that your changes are correct.</p>
<span epub:type="pagebreak" id="page_515"/>
<h5 class="h5" id="ch22lev425"><strong>Scripting Your Changes</strong></h5>
<p class="noindent">Unless your patch is very short, the most efficient means of modifying the original bytes in Ghidra is to have a script do it for you. Given a patch in the form of a byte array, and the start address of the patch, the following function applies the patch within Ghidra:</p>
<pre>public void patchBytes(Address start, byte[] patch) throws Exception {<br/>
    Address end = start.add(patch.length);<br/>
  <span class="ent">➊</span> clearListing(start, end);<br/>
    setBytes(start, patch);<br/>
}</pre>
<p class="indent">You may include this function in a script that creates the array of patch bytes from a source of your choosing (for example, by declaring an initialized array or by loading the contents of a file). The <code>clearListing</code> call <span class="ent">➊</span> is necessary as Ghidra will not allow you to modify bytes that are part of an existing instruction or data item. Once the script completes, you will need to manually format the patched bytes as either code or data and verify the correctness of your patch.</p>
<h5 class="h5" id="ch22lev426"><strong>Using the Assembler</strong></h5>
<p class="noindent">When you want to patch the code in a binary, you will most likely find yourself thinking in terms of replacing one assembly language instruction with another (for example, replacing <code>CALL _exit</code> with <code>NOP</code>), which is not necessarily incorrect but tends to gloss over some of the complexities associated with patching code. When the time comes to actually apply your patch to the program, you can’t paste in your replacement assembly language statements; instead, you must paste in the corresponding machine code bytes, which means you’ll probably want to use an assembler to generate machine code versions of all your replacement instructions.</p>
<p class="indent">One approach is to use an external editor to write your replacement assembly statements, assemble them with an external assembler (for example, <code>nasm</code> or <code>as</code>), extract the raw machine code,<sup><a id="ch22fn1a" href="footnotes.xhtml#ch22fn1">1</a></sup> and finally patch them into the program, perhaps using a script as discussed earlier. An alternative approach is to use Ghidra’s built-in assembler capability, which is accessed by right-clicking any instruction and selecting the Patch Instruction menu option.</p>
<p class="indent">Just as SLEIGH specifications tell Ghidra how to translate machine code into assembly language, they also enable Ghidra to perform assembly-to-machine-code translations—that is, act like an assembler. The first time you choose the Patch Instruction option for a given architecture, Ghidra will build an assembler based on that architecture’s SLEIGH specification. You will initially be presented with a message similar to the one shown in <a href="ch22.xhtml#fig22_10">Figure 22-10</a>.</p>
<span epub:type="pagebreak" id="page_516"/>
<div class="image"><img src="Images/fig22-10.jpg" alt="image" width="694" height="203"/></div>
<p class="figcap" id="fig22_10"><em>Figure 22-10: The Assembler Rating dialog</em></p>
<p class="indent">The Ghidra developers have run tests on the accuracy of Ghidra-generated assemblers. If a processor’s assembler has been tested, it is assigned one of the following ratings (in decreasing order of accuracy): platinum, gold, silver, bronze, and poor. Any untested assemblers are marked <em>unrated</em>. More information about Ghidra assembler ratings, along with the current rating for all available assemblers, may be found in Ghidra Help.</p>
<p class="indent">Once you dismiss the Assembler Rating dialog, Ghidra builds the required assembler capability from the current processor’s SLEIGH specification. While you wait for the assembler to be built, Ghidra displays the informative wait dialog similar to the one shown in <a href="ch22.xhtml#fig22_11">Figure 22-11</a>.</p>
<div class="image"><img src="Images/fig22-11.jpg" alt="image" width="405" height="319"/></div>
<p class="figcap" id="fig22_11"><em>Figure 22-11: The Assemble wait dialog</em></p>
<p class="indent">Once your assembler has been built, Ghidra replaces the selected instruction in the Listing window with two text input boxes (see <a href="ch22.xhtml#fig22_12">Figure 22-12</a>) that allow you to edit the instruction’s mnemonic and operands. The <span class="smallcaps">ESC</span> key discards your changes before they are assembled, while the <span class="smallcaps">ENTER</span> key assembles your new instruction and replaces the old instruction’s machine code bytes with those of the new instruction.</p>
<span epub:type="pagebreak" id="page_517"/>
<div class="image"><img src="Images/fig22-12.jpg" alt="image" width="507" height="123"/></div>
<p class="figcap" id="fig22_12"><em>Figure 22-12: Assembling a new instruction</em></p>
<p class="indent">Because they derive from the same specification as the corresponding disassembler, Ghidra’s assemblers recognize the same assembly syntax used in the Ghidra Listing window. Ghidra’s assemblers are case sensitive and provide auto-completion options as you enter your new instructions. After you enter an instruction, Ghidra returns you to the normal Listing window view, and you can reselect Patch Instruction if there are additional instructions you want to modify. For short patches, Ghidra’s assembler offers a convenient way to simultaneously assemble your instructions and modify the program.</p>
<h5 class="h5" id="ch22lev427"><strong>Instruction Replacement Pitfalls</strong></h5>
<p class="noindent">While Ghidra’s assembler makes quick work of modifying a single instruction, the new replacement instruction can be shorter, longer, or the same size as the old instruction. The third case, in which the replacement and original instructions are the same size, is not interesting. (The first two problems can arise only on architectures without a fixed instruction size, such as x86.)</p>
<p class="indent">Consider the first case, in which your replacement instruction is shorter than the original instruction, as reflected in the following listing:</p>
<pre><span class="codestrong1">;BEFORE</span>:<br/>
0804851b  83 45 f4 01   ADD<span class="ent">➊</span>  dword ptr [EBP + local_10],0x1<br/>
0804851f  83 45 f0 01   ADD    dword ptr [EBP + local_14],0x1<br/>
<br/>
<span class="codestrong1">;AFTER</span><br/>
0804851b  66<span class="ent">➋</span> 90       NOP<span class="ent">➋</span><br/>
0804851d  f4            ??<span class="ent">➋</span>   F4h<br/>
0804851e  01            ??     01h<br/>
0804851f  83 45 f0 01   ADD    dword ptr [EBP + local_14],0x1<br/>
<br/>
<span class="codestrong1">;FIXED</span>:<br/>
0804851b  66 90         NOP<br/>
0804851d  90            NOP<span class="ent">➎</span><br/>
0804851e  90            NOP<br/>
0804851f  83 45 f0 01   ADD    dword ptr [EBP + local_14],0x1</pre>
<span epub:type="pagebreak" id="page_518"/>
<p class="indent">In this case, a 4-byte <code>ADD</code> instruction <span class="ent">➊</span> is being replaced by a 2-byte <code>NOP</code> <span class="ent">➌</span>. Ghidra’s assembler has done its best to fill the available space by inserting an x86 prefix byte (<code>66</code>) <span class="ent">➋</span> ahead of the x86 opcode for <code>NOP</code> (<code>90</code>). Unfortunately, the replacement instruction is still too short to account for the two remaining bytes <span class="ent">➍</span> of the original instruction, one of which translates to a <code>HLT</code> (use the hotkey D to disassemble it), and the other that Ghidra can’t disassemble, indicating that it does not represent a valid instruction. If you were to patch the original binary in this way and run it, it would almost certainly crash upon reaching this location.</p>
<p class="indent">Ghidra provides no clues—other than the <code>??</code> characters that appear in the listing—that a problem may exist, as Ghidra does not understand your motivation for making this change and the “correct” solution depends on your particular use case. If you are modifying instructions within the listing without the intention to export, you could use Ghidra’s fallthrough override option from the right-click context menu to bypass the unneeded bytes.<sup><a id="ch22fn2a" href="footnotes.xhtml#ch22fn2">2</a></sup> Alternatively, you can ask Ghidra to disassemble the undefined bytes, but it’s highly unlikely that they will disassemble into an instruction that you will find useful. The most common solution in this situation is to replace all excess bytes from the original instruction with <code>NOP</code>s <span class="ent">➎</span> to pad to the start of the next instruction.</p>
<p class="indent">When your replacement instruction is longer than the original instruction, it introduces a new set of challenges, as shown here:</p>
<pre><span class="codestrong1">;BEFORE</span>:<br/>
08048502 6a 01          PUSH<span class="ent">➊</span> 0x1<br/>
08048504 ff 75 f0       PUSH<span class="ent">➋</span> dword ptr [EBP + local_14]<br/>
08048507 ff 75 08       PUSH   dword ptr [EBP + param_1]<br/>
0804850a e8 51 fe ff ff CALL   read<br/>
<br/>
<span class="codestrong1">;AFTER</span>:<br/>
08048502 68 00 01 00 00 PUSH<span class="ent">➌</span> 0x100<br/>
08048507 ff 75 08       PUSH   dword ptr [EBP + param_1]<br/>
0804850a e8 51 fe ff ff CALL   read</pre>
<p class="indent">In this case, the goal of the patch is to read 256 (<code>0x100</code>) bytes rather than 1 byte. The original, 2-byte <code>PUSH</code> instruction <span class="ent">➊</span> that places the third argument to <code>read</code> (the length argument) onto the stack is replaced by a 5-byte <code>PUSH</code> <span class="ent">➌</span> to push a larger constant. The additional bytes in the replacement instruction completely overwrite the instruction that was responsible for the second argument to <code>read</code> (the read buffer) <span class="ent">➋</span>.</p>
<p class="indent">The resulting code not only fails to provide <code>read</code> with enough arguments, but also passes an integer where a pointer is expected. As with the previous example, this will almost certainly cause the patched program to crash. Potential solutions to this particular patching problem are nontrivial and are discussed in the next section.</p>
<span epub:type="pagebreak" id="page_519"/>
<h4 class="h4" id="ch22lev428"><strong><em>Making Nontrivial Changes</em></strong></h4>
<p class="noindent">The moment the size of your patch grows larger than the instruction(s) or data that you are replacing, your life gets more complicated. In most cases, this doesn’t mean that your patch will be impossible to implement, but considerably more thought and effort will be needed to implement the patch properly. In this section, we discuss several approaches for handling this “patch is too large” problem, based on whether the patch contains code or data.</p>
<h5 class="h5" id="ch22lev429"><strong>Oversized Code Patches</strong></h5>
<p class="noindent">When your patch is too big to fit on top of the instructions you want to modify, you have no choice but to locate or create an unused region of sufficient size, patch your code into this empty region, and then insert a jump (known as a <em>hook</em>) at the original patch location to transfer control to your actual patch. In most cases, you will also need to append a jump to your replacement code to transfer control back to an appropriate location in the hooked function. <a href="ch22.xhtml#fig22_13">Figure 22-13</a> shows the notional flow of a patched function with a jump hook installed.</p>
<div class="image"><img src="Images/fig22-13.jpg" alt="image" width="345" height="204"/></div>
<p class="figcap" id="fig22_13"><em>Figure 22-13: Function with installed patch</em></p>
<p class="indent">The available unused space for your oversized code patch must</p>
<ul>
<li><p class="noindent">Be at least as large as your patch</p></li>
<li><p class="noindent">Reside at an address that will be executable at runtime</p></li>
<li><p class="noindent">Be initialized from file content; otherwise, your patch won’t get loaded at runtime</p></li>
</ul>
<p class="indent">The easiest place to begin your search for large, unused, executable blocks of bytes is with any <em>code caves</em> that may be present in the binary. A code cave exists when an executable section in a binary, such as the <code>.text</code> section, is padded to adhere to section alignment requirements mandated by the executable file’s format. Code caves are very common in Windows PE binaries, as they frequently require every section of the binary to be a multiple of 512 bytes in size.</p>
<p class="indent">The first place to look for a code cave is usually the end of the <code>.text</code> section. You can easily navigate to the end of the <code>.text</code> section (or any other section) by double-clicking the section name in the CodeBrowser’s Program Trees window and then scrolling to the end of the Listing window.</p>
<span epub:type="pagebreak" id="page_520"/>
<p class="indent">In our sample PE binary, the Listing window shows the following at the end of the <code>.text</code> section:</p>
<pre>140012df8 ??     00h<br/>
140012df9 ??     00h<br/>
140012dfa ??     00h<br/>
140012dfb ??     00h<br/>
140012dfc ??     00h<br/>
140012dfd ??     00h<br/>
140012dfe ??     00h<br/>
140012dff ??     00h</pre>
<p class="indent">The listing tells us the following:</p>
<ul>
<li><p class="noindent">The bytes are unclassified by Ghidra (<code>??</code>).</p></li>
<li><p class="noindent">The bytes are initialized to <code>00h</code>.</p></li>
<li><p class="noindent">The <code>.text</code> section ends at address <code>140012dff</code>, which satisfies the file alignment requirement that the section is a multiple of 512 bytes in size (<code>140012e00</code> is a multiple of <code>0x200</code>).</p></li>
</ul>
<p class="indent">Navigating to the previous instruction by scrolling up (or choosing the I tool in the CodeBrowser with search direction set to Up), we arrive at the following:</p>
<pre>140012cbd POP    RBP<br/>
140012cbe RET<span class="ent">➊</span><br/>
140012cbf ??     CCh<br/>
140012cc0 ??     00h</pre>
<p class="indent">The <code>RET</code> <span class="ent">➊</span> is the last meaningful instruction in this particular binary, and we can now compute the size of this binary’s code cave as <code>0x140012e00 - 0x140012cbf = 0x141</code> (or 321 bytes). This means that we can easily patch as many as 321 bytes of new code into this binary. Assuming that we patched our new code in at address <code>0x140012cbf</code>, we would need to patch a jump to <code>0x140012cbf</code> somewhere in the binary’s existing code to ensure that execution flow eventually reaches our patch.</p>
<p class="indent">When a code cave can’t be found, or isn’t large enough to hold your patch, you will need to get a little creative in order to find enough space to fit your patch. Depending on the compiler options used to build the binary, you may be able to spread your patch across space gathered from <em>inter-function alignment gaps</em>. Inter-function alignment gaps exist when compilers choose to align the start of every function to an address that is a multiple of 2 (often 16). When function alignment is being forced, there will be an average of <code>align</code> / 2 bytes and as many as <code>align</code> – 1 bytes of padding inserted between each function in the binary. The following listing shows an optimal (from a patching perspective) alignment gap (<code>align</code> = 16) between two adjacent functions:</p>
<pre>  1400010a0 RET<br/>
<span class="ent">➊</span> 1400010a1 ??     CCh<br/>
<span epub:type="pagebreak" id="page_521"/>
  1400010a2 ??     CCh<br/>
  1400010a3 ??     CCh<br/>
  1400010a4 ??     CCh<br/>
  1400010a5 ??     CCh<br/>
  1400010a6 ??     CCh<br/>
  1400010a7 ??     CCh<br/>
  1400010a8 ??     CCh<br/>
  1400010a9 ??     CCh<br/>
  1400010aa ??     CCh<br/>
  1400010ab ??     CCh<br/>
  1400010ac ??     CCh<br/>
  1400010ad ??     CCh<br/>
  1400010ae ??     CCh<br/>
<span class="ent">➋</span> 1400010af ??     CCh<br/>
       **************************************************************<br/>
       *                   FUNCTION                                 *<br/>
       **************************************************************</pre>
<p class="indent">All of the bytes from <code>1400010a1</code> <span class="ent">➊</span> through <code>1400010af</code> <span class="ent">➋</span> may be safely overwritten with patch code.</p>
<p class="indent">Additional methods exist for squeezing patch code into a binary—some involving expanding existing program sections or injecting entirely new ones. Any technique that manipulates sections in such a manner also requires you to update the binary’s section headers to make sure they remain consistent with any modifications that have been made. Accordingly, these techniques are very file-format specific and require a detailed understanding of file header data structures.</p>
<h5 class="h5" id="ch22lev430"><strong>Oversized Data Patches</strong></h5>
<p class="noindent">Patching data is easier than patching code in some respects, and more difficult in others. For structured data types, your primary concerns are correct size and byte ordering of each member of the structure, and since the size of a structure is determined at compile time, you don’t need to worry about oversized replacement structures. When patching string data, it is recommended that any replacement data fit entirely within the footprint of the original string. If your new string is larger than the original string, you may be fortunate to find a few bytes of padding between the end of the string and the next data item, but you must be careful not to corrupt any data that the program depends upon. If your data simply does not fit into the memory footprint of the original data, you will be forced to find a new location for it, but moving data properly can be difficult.</p>
<p class="indent">All global data items are referred to by their offsets from the program’s code or data sections. To relocate a data item, in addition to finding sufficient unused space, you’ll need to locate every reference to the original data item and patch it to refer to the new data item. Ghidra cross-references go a long way toward identifying every reference to a global, but will fail to identify derived pointers (pointers resulting from pointer arithmetic).</p>
<p class="indent">Once all of your patches have been entered in Ghidra and you’re happy with the resulting program listing, you’ll want to push your changes into the original binary to verify that your patches behave as expected.</p>
<span epub:type="pagebreak" id="page_522"/>
<h3 class="h3" id="ch22lev431"><strong>Exporting Files</strong></h3>
<p class="noindent">To confirm that any of your changes will have the desired effect on the binary’s behavior, you’ll need to update the original binary to reflect your changes. In this section, we discuss some of Ghidra’s export features as they relate to patching.</p>
<p class="indent">Ghidra’s File ▸ Export Program menu option offers the capability to export a program’s information in any of several formats. The resulting Export dialog is shown in <a href="ch22.xhtml#fig22_14">Figure 22-14</a>.</p>
<div class="image"><img src="Images/fig22-14.jpg" alt="image" width="608" height="282"/></div>
<p class="figcap" id="fig22_14"><em>Figure 22-14: The Ghidra Export dialog</em></p>
<p class="indent">The Export dialog is also accessible from the Project Manager by right-clicking the file you wish to export and selecting Export from the context menu. In the dialog, you are asked to specify the export format and the output file location, and to indicate whether you wish to limit the scope of your export to a range you have selected in the CodeBrowser. Some export formats offer additional options for more fine-grained control over the export process.</p>
<h4 class="h4" id="ch22lev432"><strong><em>Ghidra Export Formats</em></strong></h4>
<p class="noindentb">Ghidra supports the following export formats, though only one (binary) is particularly useful for binary patching:</p>
<p class="uln-indent"><strong>Ascii</strong> The Ascii export format can be used to save a textual representation of the program, similar to what is displayed in the Listing window, with options to choose which fields to include in the output file.</p>
<p class="uln-indent"><strong>Binary</strong> The Binary export format, which produces a binary file, is the most useful for patching applications and is discussed in its own section.</p>
<p class="uln-indent"><strong>C/C++</strong> The C/C++ export format is used to save the Decompiler-generated source representation of the program along with declarations for all types known to the Data Type Manager. This option is also available from the Decompiler window.</p>
<p class="uln-indent"><strong>Ghidra Zip File</strong> A Ghidra <em>zip</em> file is a serialized Java object representation of your program suitable for import into other Ghidra instances.</p>
<span epub:type="pagebreak" id="page_523"/>
<p class="uln-indent"><strong>HTML</strong> The HTML export format generates an HTML representation of the program listing. Options similar to those available in the Ascii exporter allow you to choose which fields to include in the output file. Labels and cross-references are represented as hyperlinks to provide a basic navigational capability throughout the generated output.</p>
<p class="uln-indent"><strong>Intel Hex</strong> The Intel Hex format defines an ASCII representation for binary data, commonly used for programming EEPROM.</p>
<p class="uln-indent"><strong>XML</strong> The XML exporter outputs the contents of the program in a structured XML format, with options to choose which program constructs should be included in the generated file. This functionality is also available for individual functions in the Decompiler window to facilitate debugging function decompilation. Although Ghidra includes a corresponding XML loader, this exporter includes the following warning: “Warning: XML is lossy and intended only for transferring data to external tools. GZF is the recommended format for saving and sharing program data.”</p>
<h4 class="h4" id="ch22lev433"><strong><em>The Binary Export Format</em></strong></h4>
<p class="noindent">Ghidra’s Binary export is used to write a program’s underlying binary content to a file. All of the program’s initialized memory blocks (see Window ▸ Memory Map) are concatenated to form the output file. Whether the output file is identical to the original file that was imported depends on the loader module used to import the file. The Raw Binary loader is guaranteed to re-create the original input file because it loads every byte of the original file into a single memory block. Other loaders may or may not load every file byte (for example, the PE loader does, while the ELF loader does not).</p>
<p class="indent">When it comes time to apply any changes you have made with Ghidra, you need to ensure that the file you generate contains your patches and that it will execute. If you are patching a PE file, a Binary export will generate a patched version of the original binary. Similarly, if you imported your program using the Raw Binary loader, a Binary export will generate a patched version of the original binary. Of course, as discussed in <a href="ch17.xhtml#ch17">Chapter 17</a>, when using the Raw Binary loader, you may need to perform most of the memory layout for the program manually, so there is a trade-off. Fortunately, it’s possible to script up a solution that works with any loader.</p>
<h4 class="h4" id="ch22lev434"><strong><em>Script-Assisted Export</em></strong></h4>
<p class="noindent">Rather than performing an exhaustive test of every Ghidra loader to understand whether the memory blocks created by the loader span the entire range of file bytes, we can create a Ghidra script that will save a patched version of our program for us. This script provides a loader-agnostic capability for generating patched files with Ghidra. It will always process the entire range of original file bytes regardless of the current memory map layout known to Ghidra.</p>
<span epub:type="pagebreak" id="page_524"/>
<pre>public void run() throws Exception {<br/>
    Memory mem = currentProgram.getMemory();<br/>
  <span class="ent">➊</span> java.util.List&lt;FileBytes&gt; fbytes = mem.getAllFileBytes();<br/>
    if (fbytes.size() != 1) {<br/>
        return;<br/>
    }<br/>
  <span class="ent">➋</span> FileBytes fb = fbytes.get(0);<br/>
  <span class="ent">➌</span> File of = askFile("Choose output file", "Save");<br/>
    FileOutputStream fos = new FileOutputStream(of, false);<br/>
    writePatchFile(fb, fos);<br/>
    fos.close();<br/>
}</pre>
<p class="indent">The script begins by obtaining the program’s list of <code>FileBytes</code> <span class="ent">➊</span>. A <code>FileBytes</code> object encapsulates all of the bytes from the imported program file and tracks both the original and modified value of each byte in the file. As Ghidra allows you to import several files into a single program, this script processes only the bytes from the first file you imported into the program (first range of file bytes) <span class="ent">➋</span>.</p>
<p class="indent">After prompting for an output file <span class="ent">➌</span>, the <code>FileBytes</code> object and open <code>OutputStream</code> are passed to our <code>writePatchFile</code> function to handle the finer details of generating the patched executable.</p>
<p class="indent">To present a mapped memory view of a program, Ghidra loaders may process a program’s relocation table entries in a manner similar to a runtime loader. The result of this processing is that program locations marked for fixup (locations that have relocation table entries) are modified by Ghidra from their original file values to proper relocated values. When we generate the patched version of the binary, we do not want to include any bytes that Ghidra has modified for relocation purposes.</p>
<p class="indent">The <code>writePatchFile</code> function, shown next, begins by generating the set of addresses that are patched at runtime (and by Ghidra) in accordance with the program’s relocation table:</p>
<pre>public void writePatchFile(FileBytes fb, OutputStream os) throws Exception {<br/>
    Memory mem = currentProgram.getMemory();<br/>
    Iterator&lt;Relocation&gt; relocs;<br/>
  <span class="ent">➊</span> relocs = currentProgram.getRelocationTable().getRelocations();<br/>
    HashSet&lt;Long&gt; exclusions = new HashSet&lt;Long&gt;();<br/>
    while (relocs.hasNext()) {<br/>
        Relocation r = relocs.next();<br/>
      <span class="ent">➋</span> AddressSourceInfo info = mem.getAddressSourceInfo(r.getAddress());<br/>
        for (long offset = 0; offset &lt; r.getBytes().length; offset++) {<br/>
          <span class="ent">➌</span> exclusions.add(info.getFileOffset() + offset);<br/>
        }<br/>
    }<br/>
  <span class="ent">➍</span> saveBytes(fb, os, exclusions);<br/>
}</pre>
<p class="indent">After obtaining an iterator over the program’s relocation table <span class="ent">➊</span>, the <code>AddressSourceInfo</code> for each relocation entry is obtained <span class="ent">➋</span>.</p>
<span epub:type="pagebreak" id="page_525"/>
<p class="indent">An <code>AddressSourceInfo</code> object provides a mapping of a program address to the disk file and the offset into that file from which the corresponding program byte was loaded. The file offset of each relocation byte is added to a set of offsets <span class="ent">➌</span> to be ignored when generating the final patched file. The function concludes by calling the <code>saveBytes</code> function <span class="ent">➍</span> to write the final patched version of the current program file. The <code>saveBytes</code> function is shown in the following listing:</p>
<pre>public void saveBytes(FileBytes fb, OutputStream os, Set&lt;Long&gt; exclusions)<br/>
                      throws Exception {<br/>
    long begin = fb.getFileOffset();<br/>
    long end = begin + fb.getSize();<br/>
  <span class="ent">➊</span> for (long offset = begin; offset &lt; end; offset++) {<br/>
      <span class="ent">➋</span> int orig = fb.getOriginalByte(offset) &amp; 0xff;<br/>
      <span class="ent">➌</span> int mod = fb.getModifiedByte(offset) &amp; 0xff;<br/>
        if (!exclusions.contains(offset) &amp;&amp; orig != mod) {<br/>
          <span class="ent">➍</span> os.write(mod);<br/>
        }<br/>
        else {<br/>
          <span class="ent">➎</span> os.write(orig);<br/>
        }<br/>
    }<br/>
}</pre>
<p class="indent">The function iterates over the entire range of file bytes <span class="ent">➊</span> to determine whether to save the original or modified byte to the output file.</p>
<p class="indent">At each file offset, methods of the <code>FileBytes</code> class are used to obtain the original byte value <span class="ent">➋</span>, loaded from the imported file, and the current byte value <span class="ent">➌</span>, which may have been modified by Ghidra or the Ghidra user. If the original value differs from the current value <em>and</em> the byte is not associated with a relocation entry, the modified byte is written to the output file <span class="ent">➍</span>; otherwise, the original byte is written to the output file <span class="ent">➎</span>.</p>
<p class="indent">To wrap up this section, let’s look at an example of patching a binary and confirming that the patch runs as we expect it to.</p>
<h3 class="h3" id="ch22lev435"><strong>Example: Patching a Binary</strong></h3>
<p class="noindent">Let’s look at an example that demonstrates patching in context. Assume that you have a piece of malware that checks for a debugger and, if one is present, exits without allowing you to examine its behavior. The following source code outlines that functionality in a trivial program:</p>
<pre>int is_debugger_present() {<br/>
    return ptrace(PTRACE_TRACEME, 0, 0, 0) == -1;<br/>
}<br/>
void do_work() {<br/>
  <span class="ent">➊</span> if (is_debugger_present()) {<br/>
         printf("No debugging allowed - exiting!\n\n");<br/>
         exit(-1);<br/>
    }<br/>
<span epub:type="pagebreak" id="page_526"/>
    // do interesting things here<br/>
    printf("Confirmed that there is no debugger, so do\n"<br/>
           "interesting things here that we don't want\n"<br/>
           "analysts to see!\n\n");<br/>
}<br/>
int main() {<br/>
    do_work();<br/>
    return 0;<br/>
}</pre>
<p class="indent">The code checks for a debugger <span class="ent">➊</span> and exits if it finds one. Otherwise, it goes about its nefarious business. The following shows the output of the program running alone (without a debugger):</p>
<pre># <span class="codestrong1">./debug_check_x64</span><br/>
  Confirmed that there is no debugger, so do<br/>
  interesting things here that we don't want<br/>
  analysts to see!</pre>
<p class="indent">When the program runs under a debugger, we see a different response:</p>
<pre># <span class="codestrong1">gdb ./debug_check_x64</span><br/>
  Reading symbols from ./debug_check_x64...(no debugging symbols found)...done.<br/>
  (gdb) run<br/>
  Starting program: /ghidrabook/CH22/debug_check_x64<br/>
  No debugging allowed - exiting!<br/>
  [Inferior 1 (process 434) exited with code 0377]<br/>
  (gdb)</pre>
<p class="indent">If we load the binary into Ghidra, we see the following in the Listing window:</p>
<pre>     undefined do_work()<br/>
        undefined  AL:1 &lt;RETURN&gt;<br/>
001006f8  PUSH   RBP<br/>
001006f9  MOV    RBP,RSP<br/>
001006fc  MOV    EAX,0x0<br/>
00100701  CALL   is_debugger_present<br/>
00100706  TEST   EAX,EAX<br/>
00100708  JZ     LAB_00100720<br/>
0010070a  LEA    RDI,[s_No_debugging_allowed_-_exiting!_001007d8]<br/>
00100711  CALL   puts<br/>
00100716  MOV    EDI,0xffffffff<br/>
0010071b  CALL   exit<br/>
   -- Flow Override: CALL_RETURN (CALL_TERMINATOR)<br/>
        LAB_00100720<br/>
00100720  LEA    RDI,[s_Confirmed_that_there_is_no_debug_001008<br/>
00100727  CALL   puts<br/>
0010072c  NOP<br/>
0010072d  POP    RBP<br/>
0010072e  RET</pre>
<span epub:type="pagebreak" id="page_527"/>
<p class="indent">The Decompiler window provides the following corresponding code:</p>
<pre>void do_work(void)<br/>
{<br/>
  int iVar1;<br/>
<br/>
  iVar1 = is_debugger_present();<br/>
  if (iVar1 != 0) {<br/>
    puts("No debugging allowed - exiting!\n");<br/>
                    /* WARNING: Subroutine does not return */<br/>
    exit(-1);<br/>
  }<br/>
  puts("Confirmed that there is no debugger, so do\n"<br/>
       "interesting things here that we don't want\n"<br/>
       "analysts to see!\n"<br/>
      );<br/>
  return;<br/>
}</pre>
<p class="indent">To patch this binary to bypass the check, you could <code>NOP</code> the call to the <code>is_debugger_present</code> function, change the test condition, or change the contents of the <code>is_debugger_present</code> function. If you use the Patch Instruction option from the right-click context menu, it is easy to replace the <code>JZ</code> with a <code>JNZ</code> (effectively flipping the condition to run only if it is being debugged), as shown in <a href="ch22.xhtml#fig22_15">Figure 22-15</a>.</p>
<div class="image"><img src="Images/fig22-15.jpg" alt="image" width="507" height="327"/></div>
<p class="figcap" id="fig22_15"><em>Figure 22-15: Patch Instruction option after replacing</em> <code>JZ</code> <em>with</em> <code>JNZ</code></p>
<p class="indent">This would result in the following code in the Decompiler window:</p>
<pre>void do_work(void)<br/>
{<br/>
  int iVar1;<br/>
<br/>
  iVar1 = is_debugger_present();<br/>
  if (iVar1 == 0) {<br/>
    puts("No debugging allowed - exiting!\n");<br/>
                    /* WARNING: Subroutine does not return */<br/>
<span epub:type="pagebreak" id="page_528"/>
    exit(-1);<br/>
  }<br/>
  puts("Confirmed that there is no debugger, so do\n"<br/>
       "interesting things here that we don't want\n"<br/>
       "analysts to see!\n"<br/>
      );<br/>
  return;<br/>
}</pre>
<p class="indent">If we then export the file as a binary using our export script and run it again, we see the following two listings, which demonstrate the behavior we were hoping to accomplish with our patch:</p>
<pre># <span class="codestrong1">./debug_check_x64.patched</span><br/>
  No debugging allowed - exiting!<br/>
<br/>
# <span class="codestrong1">gdb ./debug_check_x64.patched</span><br/>
  Reading symbols from ./debug_check_x64.patched...(no debugging symbols found)...done.<br/>
  (gdb) run<br/>
  Starting program: /ghidrabook/CH22/debug_check_x64.patched<br/>
  Confirmed that there is no debugger, so do<br/>
  interesting things here that we don't want<br/>
  analysts to see!<br/>
<br/>
  [Inferior 1 (process 445) exited normally]<br/>
  (gdb)</pre>
<p class="indent">While there are many external tools (for example, <code>VBinDiff</code>) available to confirm that only 1 byte was changed within the file for this example, you can also use Ghidra's internal tools to reach the same conclusion. The next chapter focuses on methods to accomplish this goal.</p>
<h3 class="h3" id="ch22lev436"><strong>Summary</strong></h3>
<p class="noindent">Regardless of your particular motivation for patching a binary, your patch will require careful planning and deployment. Ghidra provides everything you need to plan your patch; to draft your patch using hex editing, Ghidra’s built-in assembler, or scripting; to view the effects of each change; and to possibly revert changes using Undo before generating a patch version of your original binary. The next chapter demonstrates how you can use Ghidra to compare the unpatched and patched versions of your binaries as well as discusses Ghidra’s capabilities for more advanced binary differencing and version tracking.</p>
</div>



  </body></html>