- en: Chapter 9. Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 元编程
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Metaprogramming becomes much easier to understand once you learn how Ruby
    implements it internally.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一旦你了解 Ruby 如何在内部实现元编程，它就变得更容易理解了。*'
- en: One of the most confusing and daunting subjects Ruby developers face is *metaprogramming*.
    Metaprogramming, as indicated by the prefix *meta*, literally means to program
    at a different or higher level of abstraction. Ruby provides many different ways
    for you to do this, allowing your program to inspect and change itself dynamically.
    In Ruby, your program can change itself!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 开发者面临的最令人困惑和令人畏惧的主题之一是*元编程*。如同前缀 *meta* 所示，元编程字面意思是以不同或更高的抽象层次进行编程。Ruby
    提供了许多不同的方式来实现这一点，使得程序能够动态地检查和改变自己。在 Ruby 中，程序可以改变自己！
- en: Some of Ruby’s metaprogramming features allow your program to query for information
    about itself—for example, information about methods, instance variables, and superclasses.
    Other metaprogramming features allow you to perform normal tasks, such as defining
    a method or a constant, in an alternative and more flexible manner. Finally, methods
    such as `eval` allow your program to write new Ruby code from scratch, calling
    the parser and compiler at run time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的一些元编程特性允许程序查询关于自身的信息——例如，关于方法、实例变量和超类的信息。其他元编程特性则允许你以一种替代的、更灵活的方式执行正常的任务，例如定义方法或常量。最后，像
    `eval` 这样的函数允许你的程序从头开始编写新的 Ruby 代码，在运行时调用解析器和编译器。
- en: In this chapter, we’ll focus on two important aspects of metaprogramming. First,
    we’ll look at how you can alter the standard method definition process, the most
    common and practical use for metaprogramming. We’ll learn what Ruby normally does
    to assign a method to a class and how this is related to lexical scope. Then,
    we’ll look at alternative ways to define methods using metaclasses and singleton
    classes. We’ll also learn how Ruby implements the new, experimental refinements
    feature, allowing you to define methods and activate them later if you wish.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注元编程的两个重要方面。首先，我们将探讨如何改变标准的方法定义过程，这是元编程最常见和最实用的用途。我们将学习 Ruby 通常如何将方法分配给类，以及这与词法作用域的关系。接着，我们将看看如何使用元类和单例类以替代方式定义方法。我们还将学习
    Ruby 如何实现新的实验性特性——修饰符功能，允许你定义方法并在稍后激活它们（如果你愿意的话）。
- en: Roadmap
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Alternative Ways to Define Methods](ch09.html#alternative_ways_to_define_methods
    "Alternative Ways to Define Methods")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义方法的替代方式](ch09.html#alternative_ways_to_define_methods "定义方法的替代方式")'
- en: '[Ruby’s Normal Method Definition Process](ch09.html#rubyapostrophes_normal_method_definition
    "Ruby’s Normal Method Definition Process")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 的正常方法定义过程](ch09.html#rubyapostrophes_normal_method_definition "Ruby 的正常方法定义过程")'
- en: '[Defining Class Methods Using an Object Prefix](ch09.html#defining_class_methods_using_an_object_p
    "Defining Class Methods Using an Object Prefix")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用对象前缀定义类方法](ch09.html#defining_class_methods_using_an_object_p "使用对象前缀定义类方法")'
- en: '[Defining Class Methods Using a New Lexical Scope](ch09.html#defining_class_methods_using_a_new_lexic
    "Defining Class Methods Using a New Lexical Scope")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用新的词法作用域定义类方法](ch09.html#defining_class_methods_using_a_new_lexic "使用新的词法作用域定义类方法")'
- en: '[Defining Methods Using Singleton Classes](ch09.html#defining_methods_using_singleton_classes
    "Defining Methods Using Singleton Classes")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用单例类定义方法](ch09.html#defining_methods_using_singleton_classes "使用单例类定义方法")'
- en: '[Defining Methods Using Singleton Classes in a Lexical Scope](ch09.html#defining_methods_using_singleton-id00037
    "Defining Methods Using Singleton Classes in a Lexical Scope")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在词法作用域中使用单例类定义方法](ch09.html#defining_methods_using_singleton-id00037 "在词法作用域中使用单例类定义方法")'
- en: '[Creating Refinements](ch09.html#creating_refinements "Creating Refinements")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建修饰符](ch09.html#creating_refinements "创建修饰符")'
- en: '[Using Refinements](ch09.html#using_refinements "Using Refinements")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用修饰符](ch09.html#using_refinements "使用修饰符")'
- en: '[Experiment 9-1: Who Am I? How self Changes with Lexical Scope](ch09.html#experiment_9-1_who_am_iquestion_mark_how
    "Experiment 9-1: Who Am I? How self Changes with Lexical Scope")'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验 9-1: 我是谁？self 在词法作用域中的变化](ch09.html#experiment_9-1_who_am_iquestion_mark_how
    "实验 9-1: 我是谁？self 在词法作用域中的变化")'
- en: '[self in the Top Scope](ch09.html#self_in_the_top_scope "self in the Top Scope")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[顶层作用域中的 self](ch09.html#self_in_the_top_scope "顶层作用域中的 self")'
- en: '[self in a Class Scope](ch09.html#self_in_a_class_scope "self in a Class Scope")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类作用域中的 self](ch09.html#self_in_a_class_scope "类作用域中的 self")'
- en: '[self in a Metaclass Scope](ch09.html#self_in_a_metaclass_scope "self in a
    Metaclass Scope")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[元类作用域中的self](ch09.html#self_in_a_metaclass_scope "元类作用域中的self")'
- en: '[self Inside a Class Method](ch09.html#self_inside_a_class_method "self Inside
    a Class Method")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类方法中的self](ch09.html#self_inside_a_class_method "类方法中的self")'
- en: '[Metaprogramming and Closures: eval, instance_eval, and binding](ch09.html#metaprogramming_and_closures_evalcomma_i
    "Metaprogramming and Closures: eval, instance_eval, and binding")'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[元编程与闭包：eval、instance_eval和binding](ch09.html#metaprogramming_and_closures_evalcomma_i
    "元编程与闭包：eval、instance_eval和binding")'
- en: '[Code That Writes Code](ch09.html#code_that_writes_code "Code That Writes Code")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[写代码的代码](ch09.html#code_that_writes_code "写代码的代码")'
- en: '[Figure 9-16](ch09.html#calling_eval_and_accessing_values_from_t "Figure 9-16. Calling
    eval and accessing values from the parent scope")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图 9-16](ch09.html#calling_eval_and_accessing_values_from_t "图 9-16. 调用eval并访问父作用域中的值")'
- en: '[An instance_eval Example](ch09.html#instanceunderscoreeval_example "An instance_eval
    Example")'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[instance_eval 示例](ch09.html#instanceunderscoreeval_example "instance_eval
    示例")'
- en: '[Another Important Part of Ruby Closures](ch09.html#another_important_part_of_ruby_closures
    "Another Important Part of Ruby Closures")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby闭包的另一个重要部分](ch09.html#another_important_part_of_ruby_closures "Ruby闭包的另一个重要部分")'
- en: '[instance_eval Changes self to the Receiver](ch09.html#instanceunderscoreeval_changes_self_to_t
    "instance_eval Changes self to the Receiver")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[instance_eval 将self改为接收者](ch09.html#instanceunderscoreeval_changes_self_to_t
    "instance_eval 将self改为接收者")'
- en: '[instance_eval Creates a Singleton Class for a New Lexical Scope](ch09.html#instanceunderscoreeval_creates_a_singlet
    "instance_eval Creates a Singleton Class for a New Lexical Scope")'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[instance_eval 为新的词法作用域创建单例类](ch09.html#instanceunderscoreeval_creates_a_singlet
    "instance_eval 为新的词法作用域创建单例类")'
- en: '[How Ruby Keeps Track of Lexical Scope for Blocks](ch09.html#how_ruby_keeps_track_of_lexical_scope_fo
    "How Ruby Keeps Track of Lexical Scope for Blocks")'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby如何跟踪块的词法作用域](ch09.html#how_ruby_keeps_track_of_lexical_scope_fo "Ruby如何跟踪块的词法作用域")'
- en: '[Experiment 9-2: Using a Closure to Define a Method](ch09.html#experiment_9-2_using_a_closure_to_define
    "Experiment 9-2: Using a Closure to Define a Method")'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验 9-2：使用闭包定义方法](ch09.html#experiment_9-2_using_a_closure_to_define "实验 9-2：使用闭包定义方法")'
- en: '[Using define_method](ch09.html#using_defineunderscoremethod "Using define_method")'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用define_method](ch09.html#using_defineunderscoremethod "使用define_method")'
- en: '[Methods Acting as Closures](ch09.html#methods_acting_as_closures "Methods
    Acting as Closures")'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[作为闭包的方式的函数](ch09.html#methods_acting_as_closures "作为闭包的方式的函数")'
- en: '[Summary](ch09.html#summary-id00038 "Summary")'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch09.html#summary-id00038 "总结")'
- en: 'In the second half of this chapter, we’ll see how you can write code that writes
    code with the `eval` method: metaprogramming in its purest form. We’ll also see
    how metaprogramming and closures are related. Like blocks, lambdas, and procs,
    `eval` and its related metaprogramming methods create a closure when you call
    them. In fact, we’ll learn how you can use the same mental model we developed
    in [Chapter 8](ch08.html "Chapter 8. How Ruby Borrowed a Decades-Old Idea from
    Lisp") for blocks to understand many of Ruby’s metaprogramming features.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下半部分，我们将看到如何使用`eval`方法编写写代码的代码：这是元编程的最纯粹形式。我们还将看到元编程与闭包是如何相关的。像块、lambda和proc一样，`eval`及其相关的元编程方法在调用时会创建一个闭包。事实上，我们将学习如何使用在[第8章](ch08.html
    "第8章。Ruby如何借用Lisp中的一个几十年的旧概念")中开发的相同思维模型来理解Ruby的许多元编程特性。
- en: Alternative Ways to Define Methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义方法的替代方法
- en: 'Normally we define methods in Ruby using the `def` keyword. After `def`, we
    specify a name for the new method followed by the method body. By using some of
    Ruby’s metaprogramming features, however, we can define methods in alternative
    ways. We can create class methods instead of normal methods; we can create methods
    for a single object instance; and, as we’ll see in [Experiment 9-2: Using a Closure
    to Define a Method](ch09.html#experiment_9-2_using_a_closure_to_define "Experiment
    9-2: Using a Closure to Define a Method"), we can create methods that can access
    the surrounding environment using a closure.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`def`关键字在Ruby中定义方法。`def`后面是新方法的名称，接着是方法体。然而，通过使用Ruby的一些元编程特性，我们可以以不同的方式定义方法。我们可以创建类方法而非普通方法；我们可以为单个对象实例创建方法；正如我们在[实验
    9-2：使用闭包定义方法](ch09.html#experiment_9-2_using_a_closure_to_define "实验 9-2：使用闭包定义方法")中看到的，我们还可以创建能够访问周围环境的闭包方法。
- en: Next, we’ll look at what happens inside Ruby when you define a method in each
    of these ways using metaprogramming. In each case, studying what Ruby does internally
    will make Ruby’s metaprogramming syntax easier to understand. But before we tackle
    metaprogramming, let’s learn more about how Ruby normally defines a method. This
    knowledge will serve as a foundation when we learn alternative ways to define
    a method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在使用元编程定义方法时，Ruby 内部发生了什么。在每种情况下，研究 Ruby 内部的操作将使 Ruby 的元编程语法更容易理解。但在我们研究元编程之前，让我们先了解
    Ruby 如何正常地定义方法。这些知识将为我们学习替代方法定义方式奠定基础。
- en: Ruby’s Normal Method Definition Process
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 的普通方法定义过程
- en: '[Example 9-1](ch09.html#adding_a_method_to_a_class_using_the_def "Example 9-1. Adding
    a method to a class using the def keyword") shows a very simple Ruby class containing
    a single method.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-1](ch09.html#adding_a_method_to_a_class_using_the_def "示例 9-1。使用 def
    关键字向类添加方法")展示了一个非常简单的 Ruby 类，包含一个方法。'
- en: Example 9-1. Adding a method to a class using the `def` keyword
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1。使用 `def` 关键字向类添加方法
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How does Ruby execute this small program? And how does it know to assign the
    `display` method to the `Quote` class?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 如何执行这个小程序？它是如何知道将 `display` 方法分配给 `Quote` 类的？
- en: When Ruby executes the `class` keyword, it creates a new lexical scope for the
    new `Quote` class (see [Figure 9-1](ch09.html#ruby_creates_a_new_lexical_scope_when_yo
    "Figure 9-1. Ruby creates a new lexical scope when you define a class.")). Ruby
    sets the `nd_clss` pointer in the lexical scope to point to an `RClass` structure
    for the new `Quote` class. Because it’s a new class, the `RClass` structure initially
    has an empty method table, as shown on the right side of the figure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 执行 `class` 关键字时，它为新的 `Quote` 类创建了一个新的词法作用域（见[图 9-1](ch09.html#ruby_creates_a_new_lexical_scope_when_yo
    "图 9-1。Ruby 在你定义类时会创建一个新的词法作用域。")）。Ruby 在词法作用域中设置 `nd_clss` 指针，使其指向新的 `Quote`
    类的 `RClass` 结构。由于这是一个新类，`RClass` 结构最初有一个空的方法表，如图的右侧所示。
- en: Next, Ruby executes the `def` keyword, which is used to define the `display`
    method. But how does Ruby create normal methods? What happens internally when
    you call `def`?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 执行 `def` 关键字，它用于定义 `display` 方法。但 Ruby 如何创建普通方法？当你调用 `def` 时，内部发生了什么？
- en: '![Ruby creates a new lexical scope when you define a class.](httpatomoreillycomsourcenostarchimages1854229.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![当你定义一个类时，Ruby 会创建一个新的词法作用域。](httpatomoreillycomsourcenostarchimages1854229.png.jpg)'
- en: Figure 9-1. Ruby creates a new lexical scope when you define a class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1。Ruby 在你定义类时会创建一个新的词法作用域。
- en: By default, when you use `def`, you provide just the name of the new method.
    (We’ll see in the next section that you can also specify an object prefix along
    with the new method name.) Providing just the name of the new method with `def`
    instructs Ruby to use the current lexical scope to find the target class, as shown
    in [Figure 9-2](ch09.html#by_defaultcomma_ruby_uses_the_current_le "Figure 9-2. By
    default, Ruby uses the current lexical scope to find the target class for a new
    method.").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你使用 `def` 时，只提供新方法的名称。（我们将在下一节看到，你还可以指定对象前缀与新方法名称一起使用。）只提供新方法名称的 `def`
    指示 Ruby 使用当前的词法作用域来查找目标类，如[图 9-2](ch09.html#by_defaultcomma_ruby_uses_the_current_le
    "图 9-2。默认情况下，Ruby 使用当前的词法作用域来查找新方法的目标类。")所示。
- en: '![By default, Ruby uses the current lexical scope to find the target class
    for a new method.](httpatomoreillycomsourcenostarchimages1854231.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![默认情况下，Ruby 使用当前的词法作用域来查找新方法的目标类。](httpatomoreillycomsourcenostarchimages1854231.png.jpg)'
- en: Figure 9-2. By default, Ruby uses the current lexical scope to find the target
    class for a new method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2。默认情况下，Ruby 使用当前的词法作用域来查找新方法的目标类。
- en: When Ruby initially compiles [Example 9-1](ch09.html#adding_a_method_to_a_class_using_the_def
    "Example 9-1. Adding a method to a class using the def keyword"), it creates a
    separate snippet of YARV code for the `display` method. Later, when executing
    the `def` keyword, Ruby assigns this code to the target class, `Quote`, saving
    the given method name in the method table (see [Figure 9-3](ch09.html#ruby_adds_new_methods_to_the_method_tabl
    "Figure 9-3. Ruby adds new methods to the method table for the target class.")).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 初次编译[示例 9-1](ch09.html#adding_a_method_to_a_class_using_the_def "示例 9-1。使用
    def 关键字向类添加方法")时，它为 `display` 方法创建了一个单独的 YARV 代码片段。稍后，当执行 `def` 关键字时，Ruby 将此代码分配给目标类
    `Quote`，并将给定的方法名称保存到方法表中（见[图 9-3](ch09.html#ruby_adds_new_methods_to_the_method_tabl
    "图 9-3。Ruby 将新方法添加到目标类的方法表中。")）。
- en: '![Ruby adds new methods to the method table for the target class.](httpatomoreillycomsourcenostarchimages1854233.png.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby将新方法添加到目标类的方法表中。](httpatomoreillycomsourcenostarchimages1854233.png.jpg)'
- en: Figure 9-3. Ruby adds new methods to the method table for the target class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3. Ruby将新方法添加到目标类的方法表中。
- en: When we execute this method, Ruby looks up the method as described in [Ruby’s
    Method Lookup Algorithm](ch06.html#rubyapostrophes_method_lookup_algorithm "Ruby’s
    Method Lookup Algorithm"). Because `display` now appears in the method table for
    `Quote`, Ruby can find the method and execute it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个方法时，Ruby会根据[Ruby的方法查找算法](ch06.html#rubyapostrophes_method_lookup_algorithm
    "Ruby’s Method Lookup Algorithm")查找该方法。因为`display`现在出现在`Quote`的函数表中，Ruby能够找到并执行该方法。
- en: 'In sum, to define new methods in your program using the `def` keyword, Ruby
    follows this three-step process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，使用`def`关键字在你的程序中定义新方法时，Ruby遵循以下三步过程：
- en: It compiles each method’s body into a distinct snippet of YARV instructions.
    (This occurs when Ruby parses and compiles your program.)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将每个方法的主体编译成一个独立的YARV指令片段。（当Ruby解析并编译你的程序时，就会发生这种情况。）
- en: It uses the current lexical scope to obtain a pointer to a class or module.
    (This occurs when Ruby encounters a `def` keyword while executing your program.)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用当前的词法作用域来获取指向类或模块的指针。（当Ruby在执行你的程序时遇到`def`关键字时，就会发生这种情况。）
- en: It saves the new method’s name—actually, an integer ID value that maps to the
    name—in the method table for that class.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将新方法的名称——实际上是映射到名称的整数ID值——保存在该类的方法表中。
- en: Defining Class Methods Using an Object Prefix
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象前缀定义类方法
- en: Now that we understand how Ruby’s method definition process normally works,
    let’s learn alternative ways to define methods using metaprogramming. As we saw
    in [Figure 9-2](ch09.html#by_defaultcomma_ruby_uses_the_current_le "Figure 9-2. By
    default, Ruby uses the current lexical scope to find the target class for a new
    method."), Ruby normally assigns new methods to the class that corresponds to
    the current lexical scope. However, sometimes you’ll decide to add a method to
    a different class—for example, when you define a class method. (Remember that
    Ruby saves class methods in a class’s metaclass.) [Example 9-2](ch09.html#adding_a_class_method_using_def_self
    "Example 9-2. Adding a class method using def self") shows an example of creating
    a class method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了Ruby方法定义过程的正常工作方式，让我们通过元编程来学习一些替代的定义方法。如同我们在[图 9-2](ch09.html#by_defaultcomma_ruby_uses_the_current_le
    "Figure 9-2. By default, Ruby uses the current lexical scope to find the target
    class for a new method.")中所看到的，Ruby通常将新方法分配给与当前词法作用域对应的类。然而，有时你会决定将方法添加到另一个类中——例如，在定义类方法时。（记住，Ruby会将类方法保存在类的元类中。）[示例
    9-2](ch09.html#adding_a_class_method_using_def_self "Example 9-2. Adding a class
    method using def self")展示了如何创建类方法的一个例子。
- en: Example 9-2. Adding a class method using `def self`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2. 使用`def self`添加类方法
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we use `def` to
    define the new method, but this time we use a `self` prefix. This prefix tells
    Ruby to add the method to the class of the object you specify in the prefix rather
    than using the current lexical scope. [Figure 9-4](ch09.html#providing_an_object_prefix_to_def_instru
    "Figure 9-4. Providing an object prefix to def instructs Ruby to add the new method
    to the object’s class.") shows how Ruby does this internally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 中，我们使用`def`来定义新方法，但这一次我们使用`self`前缀。这个前缀告诉Ruby将方法添加到你在前缀中指定的对象的类中，而不是使用当前的词法作用域。[图
    9-4](ch09.html#providing_an_object_prefix_to_def_instru "Figure 9-4. Providing
    an object prefix to def instructs Ruby to add the new method to the object’s class.")展示了Ruby如何在内部实现这一点。
- en: 'This behavior is very different from the standard method definition process!
    When you provide an object prefix to `def`, Ruby uses the following algorithm
    to decide where to put the new method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与标准的方法定义过程非常不同！当你为`def`提供对象前缀时，Ruby使用以下算法来决定将新方法放置到哪里：
- en: Ruby evaluates the prefix expression. In [Example 9-2](ch09.html#adding_a_class_method_using_def_self
    "Example 9-2. Adding a class method using def self") we use the `self` keyword.
    While Ruby is executing code inside the `class Quote` scope, `self` is set to
    the `Quote` class. (We could have provided any Ruby expression here instead of
    `self`.) In [Figure 9-4](ch09.html#providing_an_object_prefix_to_def_instru "Figure 9-4. Providing
    an object prefix to def instructs Ruby to add the new method to the object’s class."),
    the arrow extending up from `self` to the `RClass` structure indicates the value
    of `self` is `Quote`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 评估前缀表达式。在 [示例 9-2](ch09.html#adding_a_class_method_using_def_self "示例 9-2。使用
    def self 添加类方法") 中，我们使用了 `self` 关键字。当 Ruby 在 `class Quote` 的作用域内执行代码时，`self` 被设置为
    `Quote` 类。（我们本可以在这里提供任何 Ruby 表达式，而不仅仅是 `self`。）在 [图 9-4](ch09.html#providing_an_object_prefix_to_def_instru
    "图 9-4。提供对象前缀给 def 会指示 Ruby 将新方法添加到对象的类中。") 中，从 `self` 到 `RClass` 结构的箭头表示 `self`
    的值是 `Quote`。
- en: '![Providing an object prefix to def instructs Ruby to add the new method to
    the object’s class.](httpatomoreillycomsourcenostarchimages1854235.png.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![提供对象前缀给 def 会指示 Ruby 将新方法添加到对象的类中。](httpatomoreillycomsourcenostarchimages1854235.png.jpg)'
- en: Figure 9-4. Providing an object prefix to `def` instructs Ruby to add the new
    method to the object’s class.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9-4。提供对象前缀给 `def` 会指示 Ruby 将新方法添加到对象的类中。
- en: Ruby finds the class of this object. In [Example 9-2](ch09.html#adding_a_class_method_using_def_self
    "Example 9-2. Adding a class method using def self"), because `self` is a class
    itself (`Quote`), the class of the object is actually the metaclass for `Quote`.
    [Figure 9-4](ch09.html#providing_an_object_prefix_to_def_instru "Figure 9-4. Providing
    an object prefix to def instructs Ruby to add the new method to the object’s class.")
    indicates this with the arrow extending to the right from the `RClass` structure
    for `Quote`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 查找该对象的类。在 [示例 9-2](ch09.html#adding_a_class_method_using_def_self "示例 9-2。使用
    def self 添加类方法") 中，由于 `self` 本身是一个类（`Quote`），对象的类实际上是 `Quote` 的元类。[图 9-4](ch09.html#providing_an_object_prefix_to_def_instru
    "图 9-4。提供对象前缀给 def 会指示 Ruby 将新方法添加到对象的类中。") 通过箭头从 `Quote` 的 `RClass` 结构向右延伸来表示这一点。
- en: Ruby saves the new method in that class’s method table. In this case, Ruby places
    the `display` method in the metaclass for `Quote`, making `display` a new class
    method.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 将新方法保存到该类的函数表中。在这种情况下，Ruby 将 `display` 方法放置在 `Quote` 的元类中，使得 `display`
    成为一个新的类方法。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you call `Quote.class`, Ruby will return `Class`. All classes are officially
    instances of the `Class` class. Metaclasses are an internal concept, normally
    hidden from your Ruby program. To see the metaclass for `Quote`, you can call
    `Quote.singleton_class` instead, which will return `#<Class:Quote>`.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你调用 `Quote.class`，Ruby 会返回 `Class`。所有类实际上都是 `Class` 类的实例。元类是一个内部概念，通常对你的
    Ruby 程序隐藏。要查看 `Quote` 的元类，你可以调用 `Quote.singleton_class`，它将返回 `#<Class:Quote>`。*'
- en: Defining Class Methods Using a New Lexical Scope
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的词法作用域定义类方法
- en: '[Example 9-3](ch09.html#defining_a_class_method_using_cl-id00035 "Example 9-3. Defining
    a class method using class << self") shows a different way to assign `display`
    as a class method of `Quote`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-3](ch09.html#defining_a_class_method_using_cl-id00035 "示例 9-3。使用 class
    << self 定义类方法") 展示了一种不同的方法，将 `display` 分配为 `Quote` 的类方法。'
- en: Example 9-3. Defining a class method using `class << self`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3。使用 `class << self` 定义类方法
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) `class << self`
    declares a new lexical scope, just as `class Quote` does at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    In [Ruby’s Normal Method Definition Process](ch09.html#rubyapostrophes_normal_method_definition
    "Ruby’s Normal Method Definition Process"), we saw that using `def` in the scope
    created by `class Quote` assigns new methods to `Quote`. But what class does Ruby
    assign methods to inside the scope created by `class << self`? The answer is `self`’s
    class. Because at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) `self`
    is set to `Quote`, `self`’s class is the metaclass of `Quote`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，`class << self`
    声明了一个新的词法作用域，就像在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处的
    `class Quote` 一样。在 [Ruby 的正常方法定义过程](ch09.html#rubyapostrophes_normal_method_definition
    "Ruby 的正常方法定义过程") 中，我们看到在由 `class Quote` 创建的作用域中使用 `def` 会将新方法分配给 `Quote`。但是，在
    `class << self` 创建的作用域中，Ruby 将方法分配给哪个类呢？答案是 `self` 的类。因为在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处，`self` 被设置为 `Quote`，所以 `self` 的类就是 `Quote` 的元类。
- en: '[Figure 9-5](ch09.html#ruby_creates_a_new_lexical_scope_for_a_c "Figure 9-5. Ruby
    creates a new lexical scope for a class’s metaclass when you use class << self.")
    shows how `class << self` creates a new lexical scope for the metaclass of `Quote`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](ch09.html#ruby_creates_a_new_lexical_scope_for_a_c "图 9-5. 使用 class
    << self 时，Ruby 为类的 metaclass 创建了一个新的词法作用域") 显示了 `class << self` 如何为 `Quote` 的
    metaclass 创建一个新的词法作用域。'
- en: '![Ruby creates a new lexical scope for a class’s metaclass when you use class
    << self.](httpatomoreillycomsourcenostarchimages1854237.png.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用 class << self 为类的 metaclass 创建了一个新的词法作用域。](httpatomoreillycomsourcenostarchimages1854237.png.jpg)'
- en: Figure 9-5. Ruby creates a new lexical scope for a class’s metaclass when you
    use `class << self`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5. 使用 `class << self` 时，Ruby 为类的 metaclass 创建了一个新的词法作用域。
- en: 'In this figure, Ruby’s `class <<` metaprogramming syntax functions as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，Ruby 的 `class <<` 元编程语法的作用如下：
- en: Ruby first evaluates the expression that appears after `class <<`. In [Example 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "Example 9-3. Defining a class method using class << self") this is the expression
    `self`, which evaluates to the `Quote` class, just as it did using the object
    prefix syntax in [Example 9-2](ch09.html#adding_a_class_method_using_def_self
    "Example 9-2. Adding a class method using def self"). The long arrow extending
    to the right from `self` to the `RClass` structure indicates the value of `self`
    is the `Quote` class.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 首先求值出 `class <<` 后面的表达式。在[示例 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "示例 9-3. 使用 class << self 定义类方法")中，这个表达式是 `self`，它的值是 `Quote` 类，就像在[示例 9-2](ch09.html#adding_a_class_method_using_def_self
    "示例 9-2. 使用 def self 添加类方法")中使用对象前缀语法时一样。图中从 `self` 到 `RClass` 结构的长箭头指示了 `self`
    的值是 `Quote` 类。
- en: Ruby finds the class for the object the expression evaluates to. In [Example 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "Example 9-3. Defining a class method using class << self") this will be the class
    of `Quote`, or `Quote`’s metaclass, indicated by the arrow extending down from
    `Quote` to the metaclass for `Quote` on the right side of the figure.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 会找到表达式求值后的对象所属的类。在[示例 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "示例 9-3. 使用 class << self 定义类方法")中，这将是 `Quote` 类，或者是 `Quote` 的 metaclass，图中从 `Quote`
    到 `Quote` 的 metaclass 向下延伸的箭头指示了这一点。
- en: Ruby creates a new lexical scope for this class. In this example, the lexical
    scope uses the metaclass of `Quote`, indicated by the arrow extending to the right
    from `nd_clss` in the new scope.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 为这个类创建了一个新的词法作用域。在这个示例中，词法作用域使用的是 `Quote` 的 metaclass，如图中从 `nd_clss` 向右延伸到新作用域的箭头所示。
- en: Now we can use the new lexical scope to define a series of class methods using
    `def` as usual. In [Example 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "Example 9-3. Defining a class method using class << self") Ruby will assign the
    `display` method directly to the metaclass of `Quote`. This is a different way
    of defining a class method for `Quote`. You might find `class << self` a bit more
    confusing than `def self`, but it is a convenient way to create a series of class
    methods by declaring them all inside the inner, metaclass lexical scope.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用新的词法作用域来像往常一样使用 `def` 定义一系列的类方法。在[示例 9-3](ch09.html#defining_a_class_method_using_cl-id00035
    "示例 9-3. 使用 class << self 定义类方法")中，Ruby 会将 `display` 方法直接分配给 `Quote` 的 metaclass。这是定义
    `Quote` 类方法的一种不同方式。你可能会觉得 `class << self` 比 `def self` 更让人困惑，但它是通过在内部的 metaclass
    词法作用域内声明所有类方法来创建一系列类方法的便捷方式。
- en: Defining Methods Using Singleton Classes
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单例类定义方法
- en: We’ve seen how metaprogramming allows you to declare class methods by adding
    methods to the class’s class or metaclass. Ruby also allows you to add methods
    to a single object instance, as shown in [Example 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "Example 9-4. Adding a method to a single object instance").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，元编程允许你通过向类的类或 metaclass 添加方法来声明类方法。Ruby 还允许你向单个对象实例添加方法，如在[示例 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "示例 9-4. 向单个对象实例添加方法")中所示。
- en: Example 9-4. Adding a method to a single object instance
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4. 向单个对象实例添加方法
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we declare the
    `Quote` class; then, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we create an instance of `Quote`: `some_quote`. At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    this time, however, we create a new method for the `some_quote` instance, not
    the `Quote` class. As a result, only `some_quote` will have the `display` method;
    no other instances of `Quote` will have it.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，我们声明了 `Quote`
    类；然后在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，我们创建了 `Quote`
    的一个实例：`some_quote`。然而，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    处，我们为 `some_quote` 实例创建了一个新方法，而不是为 `Quote` 类创建方法。因此，只有 `some_quote` 会有 `display`
    方法；`Quote` 的其他实例将没有这个方法。
- en: 'Internally, Ruby implements this behavior using a hidden class called the *singleton
    class*, which is like a metaclass for a single object. Here’s the difference:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 内部通过一个名为 *单例类* 的隐藏类来实现这种行为，它类似于单个对象的元类。以下是它们的区别：
- en: A *singleton class* is a special hidden class that Ruby creates internally to
    hold methods defined only for a particular object.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Singleton class*（单例类）是 Ruby 内部创建的一个特殊隐藏类，用于存放仅为特定对象定义的方法。'
- en: A *metaclass* is a singleton class in the case when that object is itself a
    class.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Metaclass*（元类）是一个单例类，当该对象本身是一个类时就会出现这种情况。'
- en: All metaclasses are singleton classes, but not all singleton classes are metaclasses.
    Ruby automatically creates a metaclass for every class you create and uses it
    to hold class methods that you might declare later. On the other hand, Ruby creates
    a singleton class only when you define a method on a single object, as shown in
    [Example 9-4](ch09.html#adding_a_method_to_a_single_object_insta "Example 9-4. Adding
    a method to a single object instance"). Ruby also creates a singleton class when
    you use `instance_eval` or related methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元类都是单例类，但并不是所有单例类都是元类。Ruby 会为你创建的每个类自动创建一个元类，并将类方法存储在元类中，供你稍后声明。另一方面，Ruby
    仅在你为单个对象定义方法时创建单例类，如 [示例 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "示例 9-4. 为单个对象实例添加方法") 所示。当你使用 `instance_eval` 或相关方法时，Ruby 也会创建单例类。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Most Ruby developers use the terms* singleton class *and* metaclass *interchangeably,
    and when you call the `singleton_class` method, Ruby will return either a singleton
    class or a metaclass. However, internally Ruby’s C source code does make a distinction
    between singleton classes and metaclasses.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数 Ruby 开发者将* singleton class *和* metaclass *这两个术语互换使用，当你调用 `singleton_class`
    方法时，Ruby 会返回一个单例类或元类。然而，Ruby 的 C 源代码在内部确实区分了单例类和元类。*'
- en: '[Figure 9-6](ch09.html#providing_an_object_prefix_to_de-id00036 "Figure 9-6. Providing
    an object prefix to def instructs Ruby to add the new method to the object’s singleton
    class.") shows how Ruby creates a singleton class when executing [Example 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "Example 9-4. Adding a method to a single object instance"). Ruby evaluates the
    expression provided as a prefix to `def`: `some_quote`. Because `some_quote` is
    an object instance, Ruby creates a new singleton class for `some_quote` and then
    assigns the new method to this singleton class. Using the `def` keyword with an
    object prefix instructs Ruby either to use a metaclass (if the prefix is a class)
    or to create a singleton class (if the prefix is some other object).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-6](ch09.html#providing_an_object_prefix_to_de-id00036 "图 9-6. 为 `def`
    提供对象前缀会指示 Ruby 将新方法添加到对象的单例类中。") 展示了 Ruby 在执行 [示例 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "示例 9-4. 为单个对象实例添加方法") 时如何创建单例类。Ruby 评估作为 `def` 前缀提供的表达式：`some_quote`。因为 `some_quote`
    是一个对象实例，Ruby 为 `some_quote` 创建了一个新的单例类，然后将新方法分配给这个单例类。使用带有对象前缀的 `def` 关键字会指示 Ruby
    使用元类（如果前缀是类）或创建单例类（如果前缀是其他对象）。'
- en: '![Providing an object prefix to def instructs Ruby to add the new method to
    the object’s singleton class.](httpatomoreillycomsourcenostarchimages1854239.png.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![为 `def` 提供对象前缀会指示 Ruby 将新方法添加到对象的单例类中。](httpatomoreillycomsourcenostarchimages1854239.png.jpg)'
- en: Figure 9-6. Providing an object prefix to `def` instructs Ruby to add the new
    method to the object’s singleton class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6. 为 `def` 提供对象前缀会指示 Ruby 将新方法添加到对象的单例类中。
- en: Defining Methods Using Singleton Classes in a Lexical Scope
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在词法作用域中使用单例类定义方法
- en: You can also declare a new lexical scope for adding methods to a single object
    instance using the `class <<` syntax, as shown in [Example 9-5](ch09.html#adding_a_singleton_method_using_class_le
    "Example 9-5. Adding a singleton method using class <<").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `class <<` 语法为单个对象实例声明新的词法作用域，以便添加方法，如 [示例 9-5](ch09.html#adding_a_singleton_method_using_class_le
    "示例 9-5. 使用 class << 添加单例方法") 所示。
- en: Example 9-5. Adding a singleton method using `class <<`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5. 使用 `class <<` 添加单例方法
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between this code and that in [Example 9-4](ch09.html#adding_a_method_to_a_single_object_insta
    "Example 9-4. Adding a method to a single object instance") appears at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    when we use the `class <<` syntax with the expression `some_quote`, which evaluates
    to a single object instance. As shown in [Figure 9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l
    "Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote."),
    `class << some_quote` instructs Ruby to create a new singleton class along with
    a new lexical scope.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 [示例 9-4](ch09.html#adding_a_method_to_a_single_object_insta "示例 9-4. 向单个对象实例添加方法")
    中的代码的区别出现在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，当我们使用
    `class <<` 语法与表达式 `some_quote` 结合时，`some_quote` 会被求值为一个单个对象实例。如 [图 9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l
    "图 9-7. Ruby 为 some_quote 创建了一个新的单例类和词法作用域") 所示，`class << some_quote` 指示 Ruby
    创建一个新的单例类以及一个新的词法作用域。
- en: On the left side of [Figure 9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l
    "Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote."),
    you can see some of the code from [Example 9-5](ch09.html#adding_a_singleton_method_using_class_le
    "Example 9-5. Adding a singleton method using class <<"). Ruby first evaluates
    the expression `some_quote` and finds it is an object, not a class. [Figure 9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l
    "Figure 9-7. Ruby creates a new singleton class and lexical scope for some_quote.")
    indicates this with the long arrow pointing to the `RObject` structure for `some_quote`.
    Because it is not a class, Ruby creates a new singleton class for `some_quote`
    and also creates a new lexical scope. Next, it sets the class for the new scope
    to be the new singleton class. If a singleton class for `some_quote` already exists,
    Ruby will reuse it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l "图 9-7. Ruby 为
    some_quote 创建了一个新的单例类和词法作用域") 的左侧，您可以看到来自 [示例 9-5](ch09.html#adding_a_singleton_method_using_class_le
    "示例 9-5. 使用 class << 添加单例方法") 的部分代码。Ruby 首先计算表达式 `some_quote`，并发现它是一个对象，而不是类。[图
    9-7](ch09.html#ruby_creates_a_new_singleton_class_and_l "图 9-7. Ruby 为 some_quote
    创建了一个新的单例类和词法作用域") 使用指向 `some_quote` 的 `RObject` 结构的长箭头来表示这一点。由于它不是一个类，Ruby 会为
    `some_quote` 创建一个新的单例类，并且还会创建一个新的词法作用域。接下来，它将新作用域的类设置为新的单例类。如果 `some_quote` 的单例类已经存在，Ruby
    会重用它。
- en: '![Ruby creates a new singleton class and lexical scope for some_quote.](httpatomoreillycomsourcenostarchimages1854241.png.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 为 some_quote 创建了一个新的单例类和词法作用域。](httpatomoreillycomsourcenostarchimages1854241.png.jpg)'
- en: Figure 9-7. Ruby creates a new singleton class and lexical scope for `some_quote`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7. Ruby 为 `some_quote` 创建了一个新的单例类和词法作用域。
- en: Creating Refinements
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Refinements
- en: Ruby 2.0’s *refinements* feature gave us the ability to define methods and add
    them to a class later if we wish. To see how this works, we’ll use the same `Quote`
    class and `display` method we used in [Example 9-1](ch09.html#adding_a_method_to_a_class_using_the_def
    "Example 9-1. Adding a method to a class using the def keyword"), repeated here
    for convenience.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 2.0 的 *refinements* 特性使我们能够在以后定义方法并将其添加到类中。如果我们想查看如何实现这一点，我们将使用与 [示例 9-1](ch09.html#adding_a_method_to_a_class_using_the_def
    "示例 9-1. 使用 def 关键字向类添加方法") 中相同的 `Quote` 类和 `display` 方法，方便起见，下面再次列出。
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now suppose elsewhere in our Ruby application we want to override or change
    what `display` does without changing the `Quote` class everywhere. Ruby provides
    an elegant way to do this, as shown in [Example 9-6](ch09.html#refining_a_class_inside_a_module
    "Example 9-6. Refining a class inside a module").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设在我们的 Ruby 应用程序的其他地方，我们希望覆盖或更改 `display` 方法的行为，而不需要在整个 `Quote` 类中进行更改。Ruby
    提供了一种优雅的方式来实现这一点，如 [示例 9-6](ch09.html#refining_a_class_inside_a_module "示例 9-6.
    在模块内部优化类") 所示。
- en: Example 9-6. Refining a class inside a module
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6. 在模块内部优化类
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `refine Quote do`, we use the `refine` method and pass the `Quote` class
    as a parameter. This defines new behavior for `Quote` that we can activate later.
    [Figure 9-8](ch09.html#ruby_creates_a_special_module_when_you_c "Figure 9-8. Ruby
    creates a special module when you call refine and updates the type of the target
    class’s methods.") shows what happens internally when we call `refine`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refine Quote do`中，我们使用 `refine` 方法并传递 `Quote` 类作为参数。这为 `Quote` 定义了新的行为，稍后我们可以激活它。[图9-8](ch09.html#ruby_creates_a_special_module_when_you_c
    "图9-8. Ruby 在你调用 refine 时创建一个特殊的模块，并更新目标类方法的类型") 展示了我们调用 `refine` 时内部发生的事情。
- en: '![Ruby creates a special module when you call refine and updates the type of
    the target class’s methods.](httpatomoreillycomsourcenostarchimages1854243.png.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在你调用 refine 时创建一个特殊的模块，并更新目标类方法的类型。](httpatomoreillycomsourcenostarchimages1854243.png.jpg)'
- en: Figure 9-8. Ruby creates a special module when you call `refine` and updates
    the type of the target class’s methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8. Ruby 在你调用 `refine` 时创建一个特殊的模块，并更新目标类方法的类型。
- en: 'Working our way through [Figure 9-8](ch09.html#ruby_creates_a_special_module_when_you_c
    "Figure 9-8. Ruby creates a special module when you call refine and updates the
    type of the target class’s methods.") from the top-left corner down, we see the
    following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从左上角开始，逐步解析 [图9-8](ch09.html#ruby_creates_a_special_module_when_you_c "图9-8.
    Ruby 在你调用 refine 时创建一个特殊的模块，并更新目标类方法的类型")，我们可以看到以下内容：
- en: The `refine` method creates a new lexical scope (the shaded rectangle).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refine`方法创建了一个新的词法作用域（阴影矩形区域）。'
- en: Ruby creates a new “refinement” module and uses that as the class for this new
    scope.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 创建一个新的“refinement”模块，并使用它作为这个新作用域的类。
- en: Ruby saves a pointer to the `Quote` class in `refined_class` inside the new
    refinement module.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 将指向`Quote`类的指针保存在新 refinement 模块中的`refined_class`。
- en: As you define new methods in the refine block, Ruby saves them in the refinement
    module. But it also follows the `refined_class` pointer and updates the same methods
    in the target class to use the method type `VM_METHOD_TYPE_REFINED`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 refine 块中定义新的方法时，Ruby 会将它们保存在 refinement 模块中。但它也会跟随 `refined_class` 指针，并更新目标类中的相同方法，使其使用方法类型
    `VM_METHOD_TYPE_REFINED`。
- en: Using Refinements
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Refinements
- en: You can decide to activate these “refined” methods in a specific part of your
    program with the `using` method, as shown in [Example 9-7](ch09.html#activating_a_refined_method
    "Example 9-7. Activating a refined method").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以决定在程序的特定部分使用 `using` 方法激活这些“refined”方法，如 [示例9-7](ch09.html#activating_a_refined_method
    "示例9-7. 激活一个refined方法") 所示。
- en: Example 9-7. Activating a refined method
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-7. 激活一个refined方法
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we first call display at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    Ruby uses the original method. Then, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we activate the refinement with `using`, which causes Ruby to use the updated
    method when we call display again at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 调用 display
    时，Ruby 使用原始方法。然后，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处我们通过`using`激活 refinement，这导致 Ruby 在我们再次调用 display 时，使用更新后的方法，如 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    所示。
- en: The `using` method attaches the refinements from the specified module to the
    current lexical scope. As I write this, the current version of Ruby, 2.0, allows
    you to use refinements only in the top-level scope, as in this example; `using`
    is a method of the top-level `main` object. (Future versions may allow you to
    use refinements in any lexical scope in your program.) [Figure 9-9](ch09.html#using_method_associates_a_moduleapos
    "Figure 9-9. The using method associates a module’s refinements with the top-level
    lexical scope.") shows how Ruby internally associates the refinement with the
    top-level lexical scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`方法将指定模块的 refinement 关联到当前的词法作用域。当我写这段话时，当前版本的 Ruby 2.0 只允许在顶级作用域中使用
    refinement，如这个例子所示；`using`是顶级`main`对象的方法。（未来版本可能允许在程序的任何词法作用域中使用 refinement。）[图9-9](ch09.html#using_method_associates_a_moduleapos
    "图9-9. `using`方法将模块的refinements与顶级词法作用域关联")展示了 Ruby 如何在内部将 refinement 与顶级词法作用域关联。'
- en: '![The using method associates a module’s refinements with the top-level lexical
    scope.](httpatomoreillycomsourcenostarchimages1854245.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![`using`方法将模块的refinements与顶级词法作用域关联。](httpatomoreillycomsourcenostarchimages1854245.png.jpg)'
- en: Figure 9-9. The `using` method associates a module’s refinements with the top-level
    lexical scope.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9. `using`方法将模块的refinements与顶级词法作用域关联。
- en: Notice how each lexical scope contains an `nd_refinements` pointer, which tracks
    the refinements active in that scope. The `using` method sets `nd_refinements`,
    which would otherwise be `nil`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个词法作用域中都包含一个 `nd_refinements` 指针，它跟踪该作用域中活跃的 refinements。`using` 方法会设置 `nd_refinements`，否则它的值为
    `nil`。
- en: And finally, [Figure 9-10](ch09.html#ruby_looks_for_a_method_in_the_refine_bl
    "Figure 9-10. Ruby looks for a method in the refine block when the original method
    is marked with VM_METHOD_TYPE_REFINED.") shows how Ruby’s method dispatch algorithm
    finds the updated method when I call it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[图 9-10](ch09.html#ruby_looks_for_a_method_in_the_refine_bl "图 9-10。当原始方法标记为
    VM_METHOD_TYPE_REFINED 时，Ruby 会在 refine 块中查找方法。") 展示了当我调用方法时，Ruby 的方法分发算法如何找到更新后的方法。
- en: Ruby uses a complex method dispatch process when you call methods. One portion
    of this algorithm looks for `VM_METHOD_TYPE_REFINED` methods. When it encounters
    a refined method, Ruby looks in the current lexical scope for any active refinements.
    If it finds an active refinement, Ruby calls the refined method; otherwise, it
    calls the original method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用方法时，Ruby 使用一个复杂的方法分发过程。该算法的一部分查找 `VM_METHOD_TYPE_REFINED` 方法。当它遇到已修改的方法时，Ruby
    会在当前词法作用域中查找任何活跃的 refinements。如果它找到了活跃的 refinement，Ruby 会调用已修改的方法；否则，它会调用原始方法。
- en: '![Ruby looks for a method in the refine block when the original method is marked
    with VM_METHOD_TYPE_REFINED.](httpatomoreillycomsourcenostarchimages1854247.png.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![当原始方法标记为 VM_METHOD_TYPE_REFINED 时，Ruby 会在 refine 块中查找方法。](httpatomoreillycomsourcenostarchimages1854247.png.jpg)'
- en: Figure 9-10. Ruby looks for a method in the refine block when the original method
    is marked with `VM_METHOD_TYPE_REFINED`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10。当原始方法标记为`VM_METHOD_TYPE_REFINED`时，Ruby 会在 refine 块中查找方法。
- en: 'Experiment 9-1: Who Am I? How self Changes with Lexical Scope'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 9-1：我是谁？`self` 如何随词法作用域变化
- en: We’ve seen various ways to define methods in Ruby. We created methods in the
    usual way using the `def` keyword. Then, we looked at how to create methods on
    a metaclass and on a singleton class and how to use refinements.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见过多种在 Ruby 中定义方法的方式。我们使用常规的 `def` 关键字创建了方法。然后，我们看到了如何在元类和单例类上创建方法，以及如何使用
    refinements。
- en: 'While each technique adds the method to a different class, each also follows
    a simple rule: Ruby adds the new method to the class corresponding to the current
    lexical scope for each technique. (The `def` keyword, however, assigns the method
    to a different class when you use a prefix.) With refinements, the current scope’s
    class is actually the special module created to hold the refined methods. In fact,
    this is one of the important roles lexical scope plays in Ruby: It identifies
    which class or module we are currently adding methods to.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每种技术将方法添加到不同的类中，但每种方法也遵循一个简单的规则：Ruby 会根据当前的词法作用域将新方法添加到相应的类中。（然而，当你使用前缀时，`def`
    关键字会将方法分配给另一个类。）在 refinements 中，当前作用域的类实际上是创建用来存放已修改方法的特殊模块。事实上，这正是词法作用域在 Ruby
    中扮演的重要角色之一：它标识了我们当前正在向哪个类或模块添加方法。
- en: We also know that the `self` keyword returns the current object—the receiver
    of the method currently being executed by Ruby. Recall that YARV saves the current
    value of `self` for each level of your Ruby call stack in the `rb_control_frame_t`
    structure. Is this object the same as the class for the current lexical scope?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，`self` 关键字返回当前对象——当前由 Ruby 执行的方法的接收者。回想一下，YARV 会在你的 Ruby 调用栈的每个级别中保存 `self`
    的当前值，这些值保存在 `rb_control_frame_t` 结构中。那么，这个对象是否与当前词法作用域的类相同？
- en: self in the Top Scope
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶级作用域中的 `self`
- en: Let’s see how the value of `self` changes as we run a simple program beginning
    with [Example 9-8](ch09.html#simple_ruby_program_with_only_one_lexi "Example 9-8. A
    simple Ruby program with only one lexical scope").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在运行一个简单程序时，`self` 的值如何变化，这个程序从 [示例 9-8](ch09.html#simple_ruby_program_with_only_one_lexi
    "示例 9-8：只有一个词法作用域的简单 Ruby 程序") 开始。
- en: Example 9-8. A simple Ruby program with only one lexical scope
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8：只有一个词法作用域的简单 Ruby 程序
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To keep things simple, I’ve shown the output from the console inline. You can
    see that Ruby creates a `top self` object before it starts to execute your code.
    This object serves as the receiver for method calls in the top-level scope. Ruby
    represents this object with the string `main`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我已经在控制台中展示了输出。你可以看到，Ruby 在开始执行你的代码之前会创建一个 `top self` 对象。这个对象作为顶级作用域中方法调用的接收者。Ruby
    使用字符串 `main` 来表示这个对象。
- en: The `Module.nesting` call returns an array showing the lexical scope stack—that
    is, which modules are “nested” until that point in the code. This array will contain
    an element for each lexical scope in the lexical scope stack. Because we’re at
    the top level of the script, Ruby returns an empty array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module.nesting` 调用返回一个数组，显示词法作用域栈——即，代码中到该点为止“嵌套”的模块。这个数组将包含词法作用域栈中每个词法作用域的元素。因为我们处于脚本的顶层，Ruby
    返回一个空数组。'
- en: '[Figure 9-11](ch09.html#at_the_top_levelcomma_ruby_sets_self_to "Figure 9-11. At
    the top level, Ruby sets self to the main object and has a single entry in the
    lexical scope stack.") shows the lexical scope stack and the value `self` for
    this simple program.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-11](ch09.html#at_the_top_levelcomma_ruby_sets_self_to "图 9-11。在顶层，Ruby
    将 self 设置为 main 对象，并在词法作用域栈中有一个条目。") 显示了该简单程序的词法作用域栈和 `self` 的值。'
- en: '![At the top level, Ruby sets self to the main object and has a single entry
    in the lexical scope stack.](httpatomoreillycomsourcenostarchimages1854249.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![在顶层，Ruby 将 self 设置为 main 对象，并在词法作用域栈中有一个条目。](httpatomoreillycomsourcenostarchimages1854249.png.jpg)'
- en: Figure 9-11. At the top level, Ruby sets `self` to the `main` object and has
    a single entry in the lexical scope stack.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-11。在顶层，Ruby 将 `self` 设置为 `main` 对象，并在词法作用域栈中有一个条目。
- en: 'On the right of this figure, you see the `main` object: the current value of
    `self`. On the left side is the lexical scope stack, which contains just a single
    entry for the top-level scope. Ruby sets the class of the top scope to the class
    of the `main` object, which is the `Object` class.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图的右侧，您可以看到 `main` 对象：当前 `self` 的值。左侧是词法作用域栈，其中仅包含一个顶层作用域的条目。Ruby 将顶层作用域的类设置为
    `main` 对象的类，也就是 `Object` 类。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Recall when you declare a new method using the `def` keyword, Ruby adds the
    method to the class for the current lexical scope. We’ve just seen the class for
    the top-level lexical scope is `Object`. Therefore, we can conclude that when
    you define a method at the top level of your script, outside of any class or module,
    Ruby adds the method to the `Object` class. You can call methods you define at
    the top level from anywhere because `Object` is a superclass of every other class.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下，当你使用 `def` 关键字声明一个新方法时，Ruby 会将方法添加到当前词法作用域的类中。我们刚刚看到，顶层词法作用域的类是 `Object`。因此，我们可以得出结论，当你在脚本的顶层定义方法时，方法会被添加到
    `Object` 类中，因为 `Object` 是每个其他类的超类。你可以从任何地方调用在顶层定义的方法。*'
- en: self in a Class Scope
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类作用域中的 self
- en: Now let’s define a new class and see what happens to the value of `self` and
    the lexical scope stack, as shown in [Example 9-9](ch09.html#declaring_a_new_class_changes_self_and_c
    "Example 9-9. Declaring a new class changes self and creates a new entry in the
    lexical scope stack.").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个新类，看看 `self` 和词法作用域栈的变化，正如 [示例 9-9](ch09.html#declaring_a_new_class_changes_self_and_c
    "示例 9-9。声明一个新类会更改 self，并在词法作用域栈中创建一个新条目。") 中所示。
- en: Example 9-9. Declaring a new class changes `self` and creates a new entry in
    the lexical scope stack.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9。声明一个新类会更改 `self` 并在词法作用域栈中创建一个新条目。
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output from the print statements is shown inline. We see at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    that Ruby has changed `self` to `Quote`—the new class—and we see at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    that there’s a new level added to the lexical scope stack. [Figure 9-12](ch09.html#now_self_is_the_same_as_the_class_for_th
    "Figure 9-12. Now self is the same as the class for the current lexical scope.")
    shows a summary.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 打印语句的输出显示在线。我们可以在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    中看到，Ruby 已将 `self` 更改为 `Quote`——新的类——并且我们可以在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    中看到，词法作用域栈中新增了一个层级。[图 9-12](ch09.html#now_self_is_the_same_as_the_class_for_th
    "图 9-12。现在，self 在当前词法作用域中与类相同。") 显示了一个总结。
- en: '![Now self is the same as the class for the current lexical scope.](httpatomoreillycomsourcenostarchimages1854251.png.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![现在，self 在当前词法作用域中与类相同。](httpatomoreillycomsourcenostarchimages1854251.png.jpg)'
- en: Figure 9-12. Now `self` is the same as the class for the current lexical scope.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-12。现在，`self` 在当前词法作用域中与类相同。
- en: On the left side of this figure, we see the lexical scope stack. The top scope
    is on the top left, and under it we see the new lexical scope created by the `class`
    keyword. Meanwhile, on the right side of the figure, we see how the value of `self`
    changes when we call `class`. On the top level, `self` was set to the `main` object,
    but when we call `class`, Ruby changes `self` to the new class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图的左侧，我们可以看到词法作用域栈。最顶层的作用域位于左上方，下面是由`class`关键字创建的新词法作用域。同时，在图的右侧，我们可以看到调用`class`时`self`的值是如何变化的。在最顶层，`self`被设置为`main`对象，但当我们调用`class`时，Ruby将`self`改为新的类。
- en: self in a Metaclass Scope
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类作用域中的self
- en: Let’s use the `class << self` syntax to create a new metaclass scope. [Example 9-10](ch09.html#declaring_a_metaclass_scope
    "Example 9-10. Declaring a metaclass scope") shows the same program with a few
    more lines of code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`class << self`语法来创建一个新的元类作用域。[示例9-10](ch09.html#declaring_a_metaclass_scope
    "示例9-10. 声明元类作用域")展示了包含更多代码行的相同程序。
- en: Example 9-10. Declaring a metaclass scope
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-10. 声明元类作用域
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we see that Ruby
    has changed the value of `self` again. The syntax `#<Class:Quote>` indicates that
    `self` was set to `Quote`’s metaclass. At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we see that Ruby has also added another level to the lexical scope stack. [Figure 9-13](ch09.html#new_lexical_scope_is_created_for_the_m
    "Figure 9-13. A new lexical scope is created for the metaclass.") shows the next
    level in the stack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 我们看到Ruby再次改变了`self`的值。语法`#<Class:Quote>`表示`self`被设置为`Quote`的元类。在
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 我们看到Ruby还为词法作用域栈添加了另一个级别。[图9-13](ch09.html#new_lexical_scope_is_created_for_the_m
    "图9-13. 为元类创建了一个新的词法作用域。")展示了栈中的下一个级别。
- en: '![A new lexical scope is created for the metaclass.](httpatomoreillycomsourcenostarchimages1854253.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![为元类创建了一个新的词法作用域。](httpatomoreillycomsourcenostarchimages1854253.png.jpg)'
- en: Figure 9-13. A new lexical scope is created for the metaclass.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13. 为元类创建了一个新的词法作用域。
- en: On the left, we can see that Ruby created a new scope when it executed `class
    << self`. The right side of the figure shows the value of `self` in the new scope,
    the metaclass for `Quote`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们可以看到Ruby在执行`class << self`时创建了一个新的作用域。图的右侧显示了新作用域中`self`的值，即`Quote`的元类。
- en: self Inside a Class Method
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法中的self
- en: Now for one more test. Suppose we add a class method to the `Quote` class and
    then call it as shown in [Example 9-11](ch09.html#declaring_and_calling_a_class_method
    "Example 9-11. Declaring and calling a class method"). (The output is at the bottom
    because the `p` statements aren’t called until we call `class_method`.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再进行一次测试。假设我们向`Quote`类添加一个类方法，然后按[示例9-11](ch09.html#declaring_and_calling_a_class_method
    "示例9-11. 声明和调用类方法")所示调用它。（输出位于底部，因为`p`语句直到我们调用`class_method`时才会执行。）
- en: Example 9-11. Declaring and calling a class method
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-11. 声明和调用类方法
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we see that Ruby
    sets `self` back to the `Quote` class when we call `class_method`. This makes
    sense: When we call a method on a receiver, Ruby always sets `self` to be the
    receiver. Because we call a class method in this case, Ruby sets the receiver
    to that class.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 我们看到当我们调用`class_method`时，Ruby将`self`重新设置为`Quote`类。这是有道理的：当我们在接收者上调用方法时，Ruby总是将`self`设置为接收者。因为在这个例子中我们调用了一个类方法，所以Ruby将接收者设置为该类。
- en: At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) we see that Ruby
    hasn’t changed the lexical scope stack. It’s still set to `[#<Class:Quote>, Quote]`,
    as shown in [Figure 9-14](ch09.html#when_you_call_a_methodcomma_ruby_changes "Figure 9-14. When
    you call a method, Ruby changes self but doesn’t create a new scope.").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 我们看到Ruby没有改变词法作用域栈。它仍然设置为`[#<Class:Quote>,
    Quote]`，正如[图9-14](ch09.html#when_you_call_a_methodcomma_ruby_changes "图9-14. 当你调用方法时，Ruby会改变self，但不会创建新的作用域。")中所示。
- en: '![When you call a method, Ruby changes self but doesn’t create a new scope.](httpatomoreillycomsourcenostarchimages1854255.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![当你调用方法时，Ruby会改变self，但不会创建新的作用域。](httpatomoreillycomsourcenostarchimages1854255.png.jpg)'
- en: Figure 9-14. When you call a method, Ruby changes `self` but doesn’t create
    a new scope.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-14. 当你调用方法时，Ruby会改变`self`，但不会创建新的作用域。
- en: Notice that the lexical scope hasn’t changed but `self` has been changed to
    `Quote`, the receiver of the method call.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，词法作用域没有改变，但`self`已经变成了`Quote`，即方法调用的接收者。
- en: 'You can use these general rules to keep track of `self` and lexical scope:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些通用规则来跟踪`self`和词法作用域：
- en: Inside a class or module scope, `self` will always be set to that class or module.
    Ruby creates a new lexical scope when you use the `class` or `module` keywords
    and sets the class for that scope to the new class or module.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类或模块作用域内部，`self`始终会被设置为该类或模块。Ruby 在你使用`class`或`module`关键字时会创建一个新的词法作用域，并将该作用域的类设置为新的类或模块。
- en: Inside a method (including a class method), Ruby will set `self` to the receiver
    of that method call.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个方法内部（包括类方法），Ruby 会将`self`设置为该方法调用的接收者。
- en: 'Metaprogramming and Closures: eval, instance_eval, and binding'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程和闭包：eval，instance_eval 和 binding
- en: In [Chapter 8](ch08.html "Chapter 8. How Ruby Borrowed a Decades-Old Idea from
    Lisp") we learned that blocks are Ruby’s implementation of closures, and we saw
    how blocks bring together a function with the environment where that function
    was referenced. In Ruby, metaprogramming and closures are closely related. Many
    of Ruby’s metaprogramming constructs also act as closures, giving the code inside
    them access to the referencing environment. We’ll learn about three important
    metaprogramming features and how each gives you access to the referencing environment
    by acting as a closure in just the way blocks do.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章. Ruby 如何从 Lisp 借用一个几十年的旧思想")中，我们学到了块是 Ruby 实现闭包的方式，并且我们看到了块如何将函数与函数引用所在的环境结合起来。在
    Ruby 中，元编程和闭包是紧密相关的。许多 Ruby 的元编程构造也充当闭包，使其内部的代码可以访问引用的环境。我们将学习三个重要的元编程特性，以及每个特性如何通过充当闭包来像块一样访问引用的环境。
- en: Code That Writes Code
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写代码的代码
- en: 'In Ruby, the `eval` method is metaprogramming in its purest form: You pass
    a string to `eval`, and Ruby immediately parses, compiles, and executes the code,
    as shown in [Example 9-12](ch09.html#parsing_and_compiling_code_using_eval "Example 9-12. Parsing
    and compiling code using eval").'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，`eval`方法是元编程的最纯粹形式：你将一个字符串传递给`eval`，Ruby 会立即解析、编译并执行这段代码，正如[示例 9-12](ch09.html#parsing_and_compiling_code_using_eval
    "示例 9-12. 使用eval解析和编译代码")所示。
- en: Example 9-12. Parsing and compiling code using `eval`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-12. 使用`eval`解析和编译代码
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We dynamically construct the string `puts 2+2` and pass it to `eval`. Ruby then
    evaluates the string. That is, it tokenizes, parses, and compiles it using the
    same Bison grammar rules and parse engine that it did when it first processed
    the primary Ruby script. Once this process is finished and Ruby has another new
    set of YARV bytecode instructions, it executes the new code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们动态构建字符串`puts 2+2`并将其传递给`eval`。然后 Ruby 会评估这个字符串。也就是说，它会使用与首次处理 Ruby 主脚本时相同的
    Bison 语法规则和解析引擎来对其进行标记、解析和编译。完成这个过程后，Ruby 会生成一组新的 YARV 字节码指令，并执行新的代码。
- en: But one very important detail about `eval` isn’t obvious in [Example 9-12](ch09.html#parsing_and_compiling_code_using_eval
    "Example 9-12. Parsing and compiling code using eval"). Specifically, Ruby evaluates
    the new code string in the same context from where you called `eval`. To see what
    I mean, look at [Example 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope
    via a closure, too.").
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于`eval`有一个非常重要的细节，在[示例 9-12](ch09.html#parsing_and_compiling_code_using_eval
    "示例 9-12. 使用eval解析和编译代码")中并不明显。具体来说，Ruby 会在你调用`eval`的相同上下文中评估新的代码字符串。要理解我的意思，请看看[示例 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "示例 9-13. 这里并不明显，但eval也通过闭包访问周围的作用域。")。
- en: Example 9-13. It isn’t obvious here, but `eval` accesses the surrounding scope
    via a closure, too.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-13. 这里并不明显，但`eval`也通过闭包访问周围的作用域。
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You would expect the result from running this code to be 5, but notice the difference
    between [Example 9-12](ch09.html#parsing_and_compiling_code_using_eval "Example 9-12. Parsing
    and compiling code using eval") and [Example 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope
    via a closure, too."). [Example 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "Example 9-13. It isn’t obvious here, but eval accesses the surrounding scope
    via a closure, too.") refers to the local variables `a` and `b` from the surrounding
    scope, and Ruby can access their values. [Figure 9-15](ch09.html#ruby_saves_the_local_variables_acomma_bc
    "Figure 9-15. Ruby saves the local variables a, b, and str on YARV’s internal
    stack as usual.") shows how YARV’s internal stack looks just before calling `eval`
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期望运行此代码的结果是 5，但请注意 [示例 9-12](ch09.html#parsing_and_compiling_code_using_eval
    "示例 9-12. 使用 eval 解析和编译代码") 和 [示例 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "示例 9-13. 这里看似不明显，但 eval 也通过闭包访问周围的作用域。") 之间的区别。[示例 9-13](ch09.html#it_isnapostrophet_obvious_herecomma_but
    "示例 9-13. 这里看似不明显，但 eval 也通过闭包访问周围的作用域。") 涉及周围作用域中的局部变量 `a` 和 `b`，Ruby 可以访问它们的值。[图
    9-15](ch09.html#ruby_saves_the_local_variables_acomma_bc "图 9-15. Ruby 像往常一样将局部变量
    a、b 和 str 保存在 YARV 的内部栈中。") 展示了 YARV 内部栈在调用 `eval` 之前的样子，如 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    所示。
- en: '![Ruby saves the local variables a, b, and str on YARV’s internal stack as
    usual.](httpatomoreillycomsourcenostarchimages1854257.png.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 像往常一样将局部变量 a、b 和 str 保存在 YARV 的内部栈中。](httpatomoreillycomsourcenostarchimages1854257.png.jpg)'
- en: Figure 9-15. Ruby saves the local variables `a`, `b`, and `str` on YARV’s internal
    stack as usual.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-15. Ruby 像往常一样将局部变量 `a`、`b` 和 `str` 保存在 YARV 的内部栈中。
- en: As expected, we see that Ruby has saved the values of `a`, `b`, and `str` on
    the stack to the left. On the right, we have the `rb_control_frame_t` structure,
    which represents the outer, or main, scope of this script.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们看到 Ruby 将 `a`、`b` 和 `str` 的值保存在左侧的栈中。在右侧，我们有 `rb_control_frame_t`
    结构体，它代表了该脚本的外部（或主）作用域。
- en: '[Figure 9-16](ch09.html#calling_eval_and_accessing_values_from_t "Figure 9-16. Calling
    eval and accessing values from the parent scope") shows what happens when we call
    the `eval` method.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-16](ch09.html#calling_eval_and_accessing_values_from_t "图 9-16. 调用 eval
    并访问父作用域的值") 展示了当我们调用 `eval` 方法时发生的情况。'
- en: '![Calling eval and accessing values from the parent scope](httpatomoreillycomsourcenostarchimages1854259.png.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![调用 eval 并访问父作用域的值](httpatomoreillycomsourcenostarchimages1854259.png.jpg)'
- en: Figure 9-16. Calling `eval` and accessing values from the parent scope
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-16. 调用 `eval` 并访问父作用域的值
- en: Calling `eval` invokes the parser and compiler on the text we pass it. When
    the compiler finishes, Ruby creates a new stack frame (`rb_control_frame_t`) for
    use in running the new compiled code (as shown at the top). Notice, however, that
    Ruby sets the `EP` in this new stack frame to point to the lower stack frame where
    the variables `a` and `b` are. This pointer allows the code passed to `eval` to
    access these values.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `eval` 会对我们传递的文本执行解析和编译。当编译器完成后，Ruby 会为执行新编译的代码创建一个新的栈帧（`rb_control_frame_t`）（如上所示）。然而请注意，Ruby
    将这个新栈帧中的 `EP` 设置为指向包含 `a` 和 `b` 变量的较低栈帧。这个指针允许传递给 `eval` 的代码访问这些值。
- en: Ruby’s use of `EP` here should look familiar. Aside from parsing and compiling
    the code dynamically, `eval` works the same way as if we had passed a block to
    some function, as in [Example 9-14](ch09.html#code_inside_a_block_can_access_variables
    "Example 9-14. Code inside a block can access variables from the surrounding scope.").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 在这里使用的 `EP` 应该看起来很熟悉。除了动态解析和编译代码，`eval` 的工作方式与我们将一个块传递给某个函数时相同，就像在 [示例
    9-14](ch09.html#code_inside_a_block_can_access_variables "示例 9-14. 块内部的代码可以访问周围作用域的变量。")
    中那样。
- en: Example 9-14. Code inside a block can access variables from the surrounding
    scope.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-14. 块内部的代码可以访问周围作用域的变量。
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In other words, the `eval` method creates a closure: the combination of a function
    and the environment where that function was referenced. In this case, the function
    is the newly compiled code, and the environment is where we call `eval` from.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`eval` 方法创建了一个闭包：它是函数与该函数所在环境的结合体。在这种情况下，函数是新编译的代码，而环境是我们调用 `eval` 的地方。
- en: Calling eval with binding
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 binding 调用 eval
- en: 'The `eval` method can take a second parameter: a *binding*. A binding is a
    closure without a function—that is, it’s just the referencing environment. Think
    of bindings as a pointer to a YARV stack frame. Passing a binding value to Ruby
    indicates that you don’t want to use the current context as the closure’s environment
    but instead want to use some other referencing environment. [Example 9-15](ch09.html#using_binding_to_access_variables_from_s
    "Example 9-15. Using binding to access variables from some other environment")
    shows an example.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval` 方法可以接受第二个参数：一个 *绑定*。绑定是没有函数的闭包——也就是说，它只是一个引用环境。可以将绑定看作是指向 YARV 栈帧的指针。将绑定值传递给
    Ruby 表示你不希望使用当前上下文作为闭包的环境，而是希望使用其他引用环境。[示例 9-15](ch09.html#using_binding_to_access_variables_from_s
    "示例 9-15. 使用 binding 访问来自其他环境的变量") 展示了一个例子。'
- en: Example 9-15. Using `binding` to access variables from some other environment
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-15. 使用 `binding` 访问来自其他环境的变量
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function `get_binding` contains the local variables `a` and `b`, but it
    also returns a binding at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    At the bottom of the listing, we again want Ruby to dynamically compile and execute
    the code string and print out the result. By passing the binding returned by `get_binding`
    to `eval`, we tell Ruby to evaluate `puts a+b` in the context of the `get_binding`
    function. If we had called `eval` without the binding, it would have created new,
    empty local variables `a` and `b`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_binding` 函数包含了局部变量 `a` 和 `b`，但它也在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    返回一个绑定。在代码的底部，我们希望 Ruby 动态编译并执行代码字符串，并打印出结果。通过将 `get_binding` 返回的绑定传递给 `eval`，我们告诉
    Ruby 在 `get_binding` 函数的上下文中评估 `puts a+b`。如果我们在没有绑定的情况下调用 `eval`，它将创建新的空的局部变量
    `a` 和 `b`。'
- en: Ruby makes a persistent copy of this environment in the heap because you might
    call `eval` long after the current frame has been popped off the stack. Even though
    `get_binding` has already returned in this example, Ruby can still access the
    values of `a` and `b` when it executes the code parsed and compiled by `eval`
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 会在堆中创建当前环境的持久副本，因为你可能会在当前栈帧已经被弹出之后很久才调用 `eval`。即使在这个例子中 `get_binding` 已经返回，Ruby
    仍然可以在执行由 `eval` 解析和编译的代码时访问 `a` 和 `b` 的值，正如在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    中所示。
- en: '[Figure 9-17](ch09.html#calling_binding_saves_a_copy_of_the_curr "Figure 9-17. Calling
    binding saves a copy of the current stack frame in the heap.") shows what happens
    internally when we call `binding`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-17](ch09.html#calling_binding_saves_a_copy_of_the_curr "图 9-17. 调用 binding
    会将当前栈帧的副本保存到堆中。") 展示了调用 `binding` 时发生的内部操作。'
- en: '![Calling binding saves a copy of the current stack frame in the heap.](httpatomoreillycomsourcenostarchimages1854261.png.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![调用 binding 会将当前栈帧的副本保存到堆中。](httpatomoreillycomsourcenostarchimages1854261.png.jpg)'
- en: Figure 9-17. Calling `binding` saves a copy of the current stack frame in the
    heap.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-17. 调用 `binding` 会将当前栈帧的副本保存到堆中。
- en: This figure resembles what Ruby does when you call `lambda` (see [Figure 8-18](ch08.html#once_messageunderscorefunction_returnsco
    "Figure 8-18. Once message_function returns, the surrounding code holds a reference
    to the proc object.")), except that Ruby creates an `rb_binding_t` C structure
    instead of an `rb_proc_t` structure. The binding structure is simply a wrapper
    around the internal environment structure—the heap copy of the stack frame. The
    binding structure also contains the file name and line number of the location
    from where you called `binding`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图形类似于当你调用 `lambda` 时 Ruby 的操作（参见 [图 8-18](ch08.html#once_messageunderscorefunction_returnsco
    "图 8-18. 一旦 message_function 返回，周围的代码会持有对 proc 对象的引用")），不同之处在于 Ruby 创建的是一个 `rb_binding_t`
    C 结构，而不是 `rb_proc_t` 结构。这个绑定结构仅仅是对内部环境结构的一个包装——栈帧在堆中的副本。绑定结构还包含了你调用 `binding`
    的文件名和行号。
- en: As with the proc object, Ruby uses the `RTypedData` structure to wrap a Ruby
    object around the `rb_binding_t` C structure (see [Figure 9-18](ch09.html#ruby_uses_rtypeddata_to_wrap_a_ruby_obje
    "Figure 9-18. Ruby uses RTypedData to wrap a Ruby object around the rb_binding_t
    structure.")).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 proc 对象一样，Ruby 使用 `RTypedData` 结构将 Ruby 对象包装在 `rb_binding_t` C 结构中（参见 [图 9-18](ch09.html#ruby_uses_rtypeddata_to_wrap_a_ruby_obje
    "图 9-18. Ruby 使用 RTypedData 将 Ruby 对象包装在 rb_binding_t 结构中")）。
- en: The binding object allows you to create a closure and then obtain and treat
    its environment as a data value. However, the closure created by the binding doesn’t
    contain any code; it has no function. You might think of the binding object as
    an indirect way to access, save, and pass around Ruby’s internal `rb_env_t` structure.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定对象允许你创建一个闭包，然后将其环境作为数据值获取并处理。然而，由绑定创建的闭包不包含任何代码；它没有功能。你可以将绑定对象视为一种间接方式，用于访问、保存和传递
    Ruby 内部的 `rb_env_t` 结构。
- en: '![Ruby uses RTypedData to wrap a Ruby object around the rb_binding_t structure.](httpatomoreillycomsourcenostarchimages1854263.png.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用 RTypedData 将 Ruby 对象包装在 rb_binding_t 结构中。](httpatomoreillycomsourcenostarchimages1854263.png.jpg)'
- en: Figure 9-18. Ruby uses `RTypedData` to wrap a Ruby object around the `rb_binding_t`
    structure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-18。Ruby 使用 `RTypedData` 将 Ruby 对象包装在 `rb_binding_t` 结构中。
- en: An instance_eval Example
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`instance_eval` 示例'
- en: 'Now for a variation on the `eval` method: `instance_eval` is shown in action
    in [Example 9-16](ch09.html#code_inside_instanceunderscoreeval_h "Example 9-16. The
    code inside instance_eval has access to obj’s instance variable.").'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一个 `eval` 方法的变体：`instance_eval` 在 [示例 9-16](ch09.html#code_inside_instanceunderscoreeval_h
    "示例 9-16。`instance_eval` 内部的代码可以访问 `obj` 的实例变量。") 中展示了它的实际应用。
- en: Example 9-16. The code inside `instance_eval` has access to `obj`’s instance
    variable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-16。`instance_eval` 内部的代码可以访问 `obj` 的实例变量。
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s what’s going on:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we create a Ruby
    class called `Quote` that saves the first half of the string in an instance variable
    in `initialize` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 我们创建了一个 Ruby 类
    `Quote`，它在 `initialize` 中将字符串的前半部分保存在实例变量中，见 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。
- en: At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) we create an instance
    of the `Quote` class and then call `instance_eval` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg),
    passing a block. The `instance_eval` method is similar to `eval`, except that
    it evaluates the given string in the context of the receiver, or the object we
    call it on. As shown here, we can pass a block to `instance_eval` instead of a
    string if we don’t want to dynamically parse and compile code.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 我们创建了一个 `Quote`
    类的实例，然后在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) 调用 `instance_eval`，并传递一个块。`instance_eval`
    方法与 `eval` 类似，不同之处在于它在接收者的上下文中评估给定的字符串，或者说我们调用它的对象。如这里所示，如果不想动态解析和编译代码，我们可以将一个块传递给
    `instance_eval`，而不是传递一个字符串。
- en: The block we pass to `instance_eval` prints out the string at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg),
    accessing the first half of the string from the `obj`’s instance variable and
    the second half from the surrounding scope, or environment.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递给 `instance_eval` 的块打印出 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    中的字符串，访问了 `obj` 的实例变量中的字符串前半部分，以及从周围的作用域或环境中获取的后半部分。
- en: 'How can this possibly work? It seems that the block passed to `instance_eval`
    has two environments: the quote instance and the surrounding code environment.
    In other words, the `@str` variable comes from one place and `str2` from another.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能起作用呢？似乎传递给 `instance_eval` 的块有两个环境：quote 实例和周围的代码环境。换句话说，`@str` 变量来自一个地方，而
    `str2` 变量来自另一个地方。
- en: Another Important Part of Ruby Closures
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 闭包的另一个重要部分
- en: 'This example highlights another important part of closure environments in Ruby:
    the current value of `self`. Recall that the `rb_control_frame_t` structure for
    each stack frame, or level, in your Ruby call stack contains a `self` pointer,
    along with the `PC`, `SP`, and `EP` pointers and other values (see [Figure 9-19](ch09.html#rbunderscorecontrolunderscoreframeun
    "Figure 9-19. The rb_control_frame_t structure")).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了 Ruby 中闭包环境的另一个重要部分：当前的 `self` 值。回想一下，Ruby 调用栈中每个栈帧或级别的 `rb_control_frame_t`
    结构包含一个 `self` 指针，以及 `PC`、`SP` 和 `EP` 指针及其他值（见 [图 9-19](ch09.html#rbunderscorecontrolunderscoreframeun
    "图 9-19。`rb_control_frame_t` 结构")）。
- en: '![The rb_control_frame_t structure](httpatomoreillycomsourcenostarchimages1854265.png.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![`rb_control_frame_t` 结构](httpatomoreillycomsourcenostarchimages1854265.png.jpg)'
- en: Figure 9-19. The `rb_control_frame_t` structure
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-19。`rb_control_frame_t` 结构
- en: The `self` pointer records the current value of `self` in your Ruby project;
    it indicates which object is the owner of the method Ruby is currently executing
    at that time. Each level in your Ruby call stack can contain a different value
    for `self`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`指针记录了你在Ruby项目中`self`的当前值；它指示哪个对象是当前执行方法的拥有者。你Ruby调用栈中的每一层都可能包含不同的`self`值。'
- en: Recall that whenever you create a closure Ruby sets the `EP`, or environment
    pointer, in the `rb_block_t` structure to the referencing environment, giving
    the code inside the block access to the surrounding variables. And, as it turns
    out, Ruby also copies the value of `self` into `rb_block_t`. This means that the
    current object is also a part of closures in Ruby. [Figure 9-20](ch09.html#in_rubycomma_closure_environments_includ
    "Figure 9-20. In Ruby, closure environments include both the stack frame and the
    current object from the referencing code.") looks at what closures contain in
    Ruby.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每当你创建一个闭包时，Ruby会在`rb_block_t`结构中设置`EP`（环境指针），指向引用环境，使得块内的代码可以访问外部变量。实际上，Ruby还会将`self`的值复制到`rb_block_t`中。这意味着当前对象也是Ruby闭包的一部分。[图9-20](ch09.html#in_rubycomma_closure_environments_includ
    "图9-20. 在Ruby中，闭包环境包含了栈帧和来自引用代码的当前对象。")展示了在Ruby中闭包包含的内容。
- en: '![In Ruby, closure environments include both the stack frame and the current
    object from the referencing code.](httpatomoreillycomsourcenostarchimages1854267.png.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![在Ruby中，闭包环境包含了栈帧和来自引用代码的当前对象。](httpatomoreillycomsourcenostarchimages1854267.png.jpg)'
- en: Figure 9-20. In Ruby, closure environments include both the stack frame and
    the current object from the referencing code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-20. 在Ruby中，闭包环境包含了栈帧和来自引用代码的当前对象。
- en: 'Because the `rb_block_t` structure contains the value of `self` from the referencing
    environment, code inside a block can access the values and methods of the object
    that was active when the closure was created or referenced. This ability probably
    seems obvious for a block: The current object before and after you call a block
    doesn’t change. However, if you use a lambda, proc, or binding, Ruby will remember
    what the current object was when you created it. And, as we’ll see shortly with
    `instance_eval`, Ruby can sometimes change `self` when you create a closure, giving
    your code access to a different object’s values and methods.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`rb_block_t`结构包含了来自引用环境的`self`值，所以块中的代码可以访问在创建或引用闭包时处于活动状态的对象的值和方法。这个功能对于块来说可能看起来是显而易见的：在你调用一个块之前和之后，当前对象并没有改变。然而，如果你使用lambda、proc或binding，Ruby会记住你创建它时的当前对象是什么。而正如我们稍后会看到的，使用`instance_eval`时，Ruby有时会在你创建闭包时改变`self`，使你的代码可以访问不同对象的值和方法。
- en: instance_eval Changes self to the Receiver
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instance_eval 将self改变为接收者
- en: When you call `instance_eval` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    in [Example 9-16](ch09.html#code_inside_instanceunderscoreeval_h "Example 9-16. The
    code inside instance_eval has access to obj’s instance variable."), Ruby creates
    both a closure and a new lexical scope. For example, as you can see in [Figure 9-21](ch09.html#stack_frame_created_by_running_insta
    "Figure 9-21. The stack frame created by running instance_eval has a new value
    for self."), the new stack frame for the code inside `instance_eval` uses new
    values for both `EP` and `self`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[示例9-16](ch09.html#code_inside_instanceunderscoreeval_h "示例9-16. instance_eval中的代码可以访问obj的实例变量")中的![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)调用`instance_eval`时，Ruby同时创建了一个闭包和一个新的词法作用域。例如，正如你在[图9-21](ch09.html#stack_frame_created_by_running_insta
    "图9-21. 运行instance_eval创建的栈帧为self使用了新的值")中看到的，`instance_eval`中的代码所创建的新栈帧为`EP`和`self`都使用了新的值。
- en: On the left of the figure, we see that executing `instance_eval` creates a closure.
    This result should be no surprise. Passing a block to `instance_eval` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    in [Example 9-16](ch09.html#code_inside_instanceunderscoreeval_h "Example 9-16. The
    code inside instance_eval has access to obj’s instance variable.") creates a new
    level on the stack and sets `EP` to the referencing environment, giving the code
    inside the block access to the variables `str2` and `obj`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，我们看到执行`instance_eval`时创建了一个闭包。这个结果应该不令人惊讶。将一个块传递给`instance_eval`时，在[示例9-16](ch09.html#code_inside_instanceunderscoreeval_h
    "示例9-16. instance_eval中的代码可以访问obj的实例变量")中的![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)会在栈上创建一个新的层次，并将`EP`设置为引用环境，从而使块内的代码可以访问变量`str2`和`obj`。
- en: '![The stack frame created by running instance_eval has a new value for self.](httpatomoreillycomsourcenostarchimages1854269.png.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![执行 `instance_eval` 时创建的栈帧具有新的 `self` 值。](httpatomoreillycomsourcenostarchimages1854269.png.jpg)'
- en: Figure 9-21. The stack frame created by running `instance_eval` has a new value
    for `self`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-21. 执行 `instance_eval` 时创建的栈帧具有新的 `self` 值。
- en: However, as you can see on the right of the figure, `instance_eval` also changes
    the value of `self` in the new closure. When the code inside the `instance_eval`
    block runs, `self` points to the receiver of `instance_eval`, or `obj`, in [Example 9-16](ch09.html#code_inside_instanceunderscoreeval_h
    "Example 9-16. The code inside instance_eval has access to obj’s instance variable.").
    This allows the code inside `instance_eval` to access the values inside the receiver.
    In [Example 9-16](ch09.html#code_inside_instanceunderscoreeval_h "Example 9-16. The
    code inside instance_eval has access to obj’s instance variable."), the code at
    ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg) can access both `@str`
    from inside `obj` and `str2` from the surrounding code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如你在图示右侧所见，`instance_eval` 还会改变新闭包中 `self` 的值。当 `instance_eval` 块内的代码运行时，`self`
    指向 `instance_eval` 的接收者，或者称为 `obj`，如[示例 9-16](ch09.html#code_inside_instanceunderscoreeval_h
    "示例 9-16. `instance_eval` 内部的代码可以访问 obj 的实例变量.")所示。这使得 `instance_eval` 内的代码能够访问接收者内部的值。在[示例
    9-16](ch09.html#code_inside_instanceunderscoreeval_h "示例 9-16. `instance_eval`
    内部的代码可以访问 obj 的实例变量.")中，位于 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    的代码可以访问 `obj` 内的 `@str` 和外部代码中的 `str2`。
- en: instance_eval Creates a Singleton Class for a New Lexical Scope
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`instance_eval` 为新的词法作用域创建单例类'
- en: The `instance_eval` method also creates a new singleton class and sets it as
    the class for a new lexical scope, as shown in [Figure 9-22](ch09.html#instanceunderscoreeval_creates_a_lexical
    "Figure 9-22. instance_eval creates a lexical scope for a new singleton class.").
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance_eval` 方法还会创建一个新的单例类，并将其作为新词法作用域的类，如[图 9-22](ch09.html#instanceunderscoreeval_creates_a_lexical
    "图 9-22. `instance_eval` 为新的单例类创建词法作用域.")所示。'
- en: '![instance_eval creates a lexical scope for a new singleton class.](httpatomoreillycomsourcenostarchimages1854271.png.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![instance_eval 为新的单例类创建词法作用域。](httpatomoreillycomsourcenostarchimages1854271.png.jpg)'
- en: Figure 9-22. `instance_eval` creates a lexical scope for a new singleton class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-22. `instance_eval` 为新的单例类创建词法作用域。
- en: While executing `instance_eval`, Ruby creates a new lexical scope, as shown
    by the shaded rectangle inside the `instance_eval` block. If we had passed a string
    to `instance_eval`, Ruby would have parsed and compiled the string and then created
    a new lexical scope in the same way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `instance_eval` 时，Ruby 创建了一个新的词法作用域，如 `instance_eval` 块内阴影矩形所示。如果我们将一个字符串传递给
    `instance_eval`，Ruby 将解析并编译这个字符串，然后以相同的方式创建新的词法作用域。
- en: 'Along with the new lexical scope, Ruby creates a singleton class for the receiver,
    `obj`. The singleton class allows you to define new methods for the receiver object
    (see [Figure 9-22](ch09.html#instanceunderscoreeval_creates_a_lexical "Figure 9-22. instance_eval
    creates a lexical scope for a new singleton class.")): The `def new_method` call
    inside the `instance_eval` block adds `new_method` to the singleton class for
    `obj`. As a singleton class, `obj` will have the new method, but no other objects
    or classes in the program will have access to it. (The metaprogramming methods
    `class_eval` and `module_eval` work in a similar way and also create a new lexical
    scope; however, they just use the target class or module for the new scope and
    don’t create a metaclass or singleton class.)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的词法作用域的创建，Ruby 为接收者 `obj` 创建了一个单例类。这个单例类允许你为接收对象定义新方法（参见[图 9-22](ch09.html#instanceunderscoreeval_creates_a_lexical
    "图 9-22. `instance_eval` 为新的单例类创建词法作用域.")）：`instance_eval` 块中的 `def new_method`
    调用将 `new_method` 添加到 `obj` 的单例类中。作为一个单例类，`obj` 将拥有这个新方法，但程序中的其他对象或类将无法访问它。（元编程方法
    `class_eval` 和 `module_eval` 也以类似的方式工作，同样创建新的词法作用域；然而，它们只是使用目标类或模块作为新的作用域，并不会创建元类或单例类。）
- en: How Ruby Keeps Track of Lexical Scope for Blocks
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 如何追踪块的词法作用域
- en: Let’s take a closer look at how Ruby represents lexical scopes internally. [Figure 9-23](ch09.html#rubyapostrophes_c_source_code_internally
    "Figure 9-23. Ruby’s C source code internally uses a separate structure called
    cref to track lexical scopes.") shows the lexical scope Ruby creates for the `Quote`
    class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看 Ruby 如何在内部表示词法作用域。[图 9-23](ch09.html#rubyapostrophes_c_source_code_internally
    "图 9-23. Ruby 的 C 源代码在内部使用一种名为 cref 的结构来跟踪词法作用域.") 展示了 Ruby 为 `Quote` 类创建的词法作用域。
- en: '![Ruby’s C source code internally uses a separate structure called cref to
    track lexical scopes.](httpatomoreillycomsourcenostarchimages1854273.png.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby的C源代码在内部使用一个独立的结构体`cref`来跟踪词法作用域。](httpatomoreillycomsourcenostarchimages1854273.png.jpg)'
- en: Figure 9-23. Ruby’s C source code internally uses a separate structure called
    `cref` to track lexical scopes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-23. Ruby的C源代码在内部使用一个独立的结构体`cref`来跟踪词法作用域。
- en: You can see the `display` method’s code snippet represented as a rectangle on
    the left side of the figure, inside the class `Quote` declaration. On the right
    side of the rectangle, you can see a small arrow pointing to a structure labeled
    `cref`, which is the actual lexical scope. This, in turn, contains a pointer to
    the `Quote` class (`nd_clss`) and to the parent lexical scope (`nd_next`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`display`方法的代码片段被表示为左侧矩形框中的内容，位于`class Quote`声明内。在矩形框的右侧，你可以看到一个指向标记为`cref`的结构的小箭头，它表示实际的词法作用域。这个结构包含指向`Quote`类（`nd_clss`）和父词法作用域（`nd_next`）的指针。
- en: As indicated by the figure, Ruby’s C source code internally represents lexical
    scopes using these `cref` structures. The small arrow on the left shows that each
    piece of code in your program refers to a `cref` structure with a pointer. This
    pointer keeps track of which lexical scope that piece of code belongs to.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Ruby的C源代码在内部通过这些`cref`结构来表示词法作用域。左侧的小箭头显示，程序中的每段代码都通过指针引用一个`cref`结构，这个指针跟踪着该段代码属于哪个词法作用域。
- en: 'Notice one important detail about [Figure 9-23](ch09.html#rubyapostrophes_c_source_code_internally
    "Figure 9-23. Ruby’s C source code internally uses a separate structure called
    cref to track lexical scopes."): Both the code snippet and lexical scope inside
    the `class Quote` declaration refer to a single `RClass` structure. There’s a
    one-to-one correspondence between code, lexical scope, and class. Every time Ruby
    executes the code inside the `class Quote` declaration, it uses the same copy
    of the `RClass` structure, the one for `Quote`. This behavior seems obvious; the
    code inside a class declaration always refers to the same class.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关于[图9-23](ch09.html#rubyapostrophes_c_source_code_internally "图9-23. Ruby的C源代码在内部使用一个独立的结构体`cref`来跟踪词法作用域")的一个重要细节：`class
    Quote`声明中的代码片段和词法作用域都指向同一个`RClass`结构体。代码、词法作用域和类之间存在一一对应的关系。每次Ruby执行`class Quote`声明中的代码时，它使用的是`Quote`类的相同`RClass`结构体。这种行为看起来显而易见；类声明中的代码总是引用相同的类。
- en: For blocks, however, things aren’t so simple. Using metaprogramming methods
    such as `instance_eval`, you can specify a different lexical scope for the same
    piece of code—a block, for example—to use each time it is executed. [Figure 9-24](ch09.html#blockapostrophes_code_canapostrophet
    "Figure 9-24. The block’s code can’t refer to a single lexical scope because the
    scope’s class depends on the value of obj.") shows the problem.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于代码块来说，事情就不那么简单了。通过使用诸如`instance_eval`之类的元编程方法，你可以为同一段代码（例如一个代码块）指定不同的词法作用域，每次执行时都可以使用不同的作用域。[图9-24](ch09.html#blockapostrophes_code_canapostrophet
    "图9-24. 代码块的代码无法引用单一的词法作用域，因为作用域的类依赖于`obj`的值")展示了这个问题。
- en: '![The block’s code can’t refer to a single lexical scope because the scope’s
    class depends on the value of obj.](httpatomoreillycomsourcenostarchimages1854275.png.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![代码块的代码无法引用单一的词法作用域，因为作用域的类依赖于`obj`的值。](httpatomoreillycomsourcenostarchimages1854275.png.jpg)'
- en: Figure 9-24. The block’s code can’t refer to a single lexical scope because
    the scope’s class depends on the value of `obj`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-24. 代码块的代码无法引用单一的词法作用域，因为作用域的类依赖于`obj`的值。
- en: We learned in the previous section that Ruby creates a singleton class for the
    lexical scope created by `instance_eval`. However, this code might be run many
    times for different values of `obj`. In fact, your program might execute this
    code at the same time in different threads. This requirement means that Ruby can’t
    keep a pointer to a single `cref` structure for the block as it does for a class
    definition. This block scope will refer to different classes at different times.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中了解到，Ruby为通过`instance_eval`创建的词法作用域创建了一个单例类。然而，这段代码可能会为不同的`obj`值多次执行。实际上，你的程序可能会在不同的线程中同时执行这段代码。这就要求Ruby不能像处理类定义那样为代码块保持对单一`cref`结构的指针。这个代码块的作用域在不同时间会引用不同的类。
- en: 'Ruby solves this problem by saving a pointer to the lexical scope used by blocks
    in a different place: as an entry on YARV’s internal stack (see [Figure 9-25](ch09.html#ruby_tracks_lexical_scope_for_blocks_usi
    "Figure 9-25. Ruby tracks lexical scope for blocks using the svar/cref entry on
    the stack, not using the block’s code snippet.")).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 通过将块使用的词法作用域的指针保存在不同的位置来解决这个问题：作为 YARV 内部堆栈上的一个条目（参见 [图 9-25](ch09.html#ruby_tracks_lexical_scope_for_blocks_usi
    "图 9-25. Ruby 使用堆栈上的 svar/cref 条目来跟踪块的词法作用域，而不是使用块的代码片段。")）。
- en: '![Ruby tracks lexical scope for blocks using the svar/cref entry on the stack,
    not using the block’s code snippet.](httpatomoreillycomsourcenostarchimages1854277.png.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用堆栈上的 svar/cref 条目来跟踪块的词法作用域，而不是使用块的代码片段。](httpatomoreillycomsourcenostarchimages1854277.png.jpg)'
- en: Figure 9-25. Ruby tracks lexical scope for blocks using the `svar/cref` entry
    on the stack, not using the block’s code snippet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-25. Ruby 使用堆栈上的 `svar/cref` 条目来跟踪块的词法作用域，而不是使用块的代码片段。
- en: On the left side of the figure, you can see the call to `instance_eval` and
    the code snippet for the block inside. In the center of the figure is the `cref`
    structure for the lexical scope. On the right side, you can see YARV saves a pointer
    to the scope in the second entry on its stack, labeled `svar/cref`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，你可以看到调用 `instance_eval` 和块内的代码片段。在图的中央是表示词法作用域的 `cref` 结构。在图的右侧，你可以看到
    YARV 在堆栈的第二个条目中保存了指向词法作用域的指针，标记为 `svar/cref`。
- en: 'Recall from [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code")
    that the second entry on YARV’s internal stack contains one of two values: `svar`
    or `cref`. As we saw in [Experiment 3-2: Exploring Special Variables](ch03.html#experiment_3-2_exploring_special_variabl
    "Experiment 3-2: Exploring Special Variables"), `svar` saves a pointer to a table
    of special variables, such as the result of the last regular expression match,
    while executing a method. But while executing a block, YARV saves the `cref` value
    here instead. Usually this value isn’t important because blocks normally use the
    lexical scope of the surrounding code. But when executing `instance_eval` and
    a few other metaprogramming features, such as `module_eval` and `instance_exec`,
    Ruby sets `cref` in this way to the current lexical scope.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [第 3 章](ch03.html "第 3 章. Ruby 如何执行你的代码") 回顾一下，YARV 的内部堆栈的第二个条目包含两种值之一：`svar`
    或 `cref`。正如我们在 [实验 3-2：探索特殊变量](ch03.html#experiment_3-2_exploring_special_variabl
    "实验 3-2：探索特殊变量") 中看到的那样，`svar` 保存指向特殊变量表的指针，例如执行方法时上一个正则表达式匹配的结果。而在执行块时，YARV 则在这里保存
    `cref` 值。通常，这个值并不重要，因为块通常使用周围代码的词法作用域。但是，在执行 `instance_eval` 和一些其他元编程特性时，比如 `module_eval`
    和 `instance_exec`，Ruby 会将 `cref` 设置为当前的词法作用域。
- en: 'Experiment 9-2: Using a Closure to Define a Method'
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 9-2：使用闭包定义方法
- en: Another common metaprogramming pattern in Ruby is to dynamically define methods
    in a class using `define_method`. For example, [Example 9-17](ch09.html#ruby_class_that_displays_a_string_from
    "Example 9-17. A Ruby class that displays a string from an instance variable")
    shows a simple Ruby class that prints out a string when you call `display`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 中另一个常见的元编程模式是使用 `define_method` 动态地在类中定义方法。例如，[示例 9-17](ch09.html#ruby_class_that_displays_a_string_from
    "示例 9-17. 一个从实例变量显示字符串的 Ruby 类") 展示了一个简单的 Ruby 类，当你调用 `display` 时，它会打印出一个字符串。
- en: Example 9-17. A Ruby class that displays a string from an instance variable
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-17. 一个从实例变量显示字符串的 Ruby 类
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is similar to that in [Example 9-1](ch09.html#adding_a_method_to_a_class_using_the_def
    "Example 9-1. Adding a method to a class using the def keyword"), except that
    we use an instance variable `@str` to hold the string value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于 [示例 9-1](ch09.html#adding_a_method_to_a_class_using_the_def "示例 9-1.
    使用 `def` 关键字向类添加方法") 中的代码，只不过我们使用实例变量 `@str` 来保存字符串值。
- en: Using define_method
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `define_method`
- en: We could have used metaprogramming to define `display` in a more verbose but
    dynamic way, as shown in [Example 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "Example 9-18. Using define_method to create a method").
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用元编程以更冗长但动态的方式定义 `display`，就像在 [示例 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "示例 9-18. 使用 define_method 创建一个方法") 中所示。
- en: Example 9-18. Using `define_method` to create a method
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-18. 使用 `define_method` 创建一个方法
- en: '[PRE18]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call `define_method` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    instead of the normal `def` keyword. Because the name of the new method is passed
    as the argument `:display`, we can dynamically construct the method name from
    some data values or iterate over an array of method names, calling `define_method`
    for each one.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处调用`define_method`，而不是正常的`def`关键字。由于新方法的名称作为参数`:display`传递，我们可以从一些数据值动态构建方法名称，或者遍历一个方法名称数组，为每个名称调用`define_method`。
- en: But there is another subtle difference between `def` and `define_method`. For
    `define_method` we provide the body of the method as a block; that is, we use
    a `do` keyword at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    This syntax difference may seem minor, but remember that blocks are actually closures.
    Adding `do` introduces a closure, meaning that the code inside the new method
    has access to the environment outside. This is not the case with the `def` keyword.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但`def`和`define_method`之间有另一个微妙的区别。对于`define_method`，我们通过块提供方法体；也就是说，我们在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处使用`do`关键字。这个语法差异看似微不足道，但请记住，块实际上是闭包。添加`do`关键字引入了一个闭包，这意味着新方法内部的代码可以访问外部的环境。而`def`关键字则无法做到这一点。
- en: There are no local variables present in [Example 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "Example 9-18. Using define_method to create a method") when we call `define_method`,
    but suppose that another place in our application did have values that we wanted
    to use inside our new method. By using a closure, Ruby makes an internal copy
    of the surrounding environment on the heap, which the new method will be able
    to access.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`define_method`时，[示例 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "示例 9-18. 使用 define_method 创建方法")中没有本地变量，但假设我们在应用程序的其他地方确实有一些值，并希望在新方法中使用这些值。通过使用闭包，Ruby
    会在堆上创建周围环境的内部副本，新方法可以访问这个副本。
- en: Methods Acting as Closures
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法作为闭包
- en: Now for another test. [Example 9-19](ch09.html#now_commercial_atstr_has_only_the_first
    "Example 9-19. Now @str has only the first half of the string.") stores only the
    first half of the string in the instance variable. In a moment, we’ll write a
    new method for the `Quote` class to access this.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行另一个测试。[示例 9-19](ch09.html#now_commercial_atstr_has_only_the_first "示例 9-19.
    现在 @str 只有字符串的前一半")将字符串的前一半存储在实例变量中。稍后，我们将为`Quote`类编写一个新方法来访问这个变量。
- en: Example 9-19. Now `@str` has only the first half of the string.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-19. 现在 `@str` 只有字符串的前一半。
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 9-20](ch09.html#using_a_closure_with_defineunderscoremet "Example 9-20. Using
    a closure with define_method") shows how we can use a closure to access both the
    instance variable and the surrounding environment.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-20](ch09.html#using_a_closure_with_defineunderscoremet "示例 9-20. 使用闭包与
    define_method")展示了我们如何使用闭包来访问实例变量和周围的环境。'
- en: Example 9-20. Using a closure with `define_method`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-20. 使用闭包与`define_method`
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because `define_method` is a private method in the `Module` class, we need to
    use the confusing `send` syntax at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Earlier, at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) in [Example 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "Example 9-18. Using define_method to create a method"), we were able to call
    `define_method` directly because we used it inside the class’s scope. We can’t
    do that from other places in the application. By using `send`, the `create_method_using_a_closure`
    method can call a private method that it wouldn’t normally have had access to.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`define_method`是`Module`类的私有方法，我们需要使用令人困惑的`send`语法在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处。早些时候，在
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处，在[示例 9-18](ch09.html#using_defineunderscoremethod_to_create_a
    "示例 9-18. 使用 define_method 创建方法")中，我们能够直接调用`define_method`，因为我们在类的作用域内使用了它。而在应用程序的其他地方，我们不能直接这么做。通过使用`send`，`create_method_using_a_closure`方法可以调用一个它通常无法访问的私有方法。
- en: 'But more importantly, notice that the `str2` variable is preserved in the heap
    for the new method to use even after `create_method_using_a_closure` returns:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，请注意即使`create_method_using_a_closure`返回后，`str2`变量仍然保留在堆中供新方法使用：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Internally, Ruby treats this as a call to `lambda`. That is, this code functions
    the same way as if I had written the code in [Example 9-21](ch09.html#passing_a_proc_to_defineunderscoremethod
    "Example 9-21. Passing a proc to define_method").
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Ruby 将其视为对`lambda`的调用。也就是说，这段代码的功能就像我在[示例 9-21](ch09.html#passing_a_proc_to_defineunderscoremethod
    "示例 9-21. 将 proc 传递给 define_method")中编写的代码一样。
- en: Example 9-21. Passing a proc to `define_method`
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-21. 将一个 proc 传递给 `define_method`
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 9-21](ch09.html#passing_a_proc_to_defineunderscoremethod "Example 9-21. Passing
    a proc to define_method") separates the code that creates the closure and defines
    the method. Because at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we pass three arguments to `define_method`, Ruby expects the third to be a proc
    object. While this is an even more verbose way to write this code, it’s a bit
    less confusing because calling `lambda` makes it clear that Ruby will create a
    closure.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-21](ch09.html#passing_a_proc_to_defineunderscoremethod "示例 9-21. 将一个
    proc 传递给 define_method") 将创建闭包和定义方法的代码分开。因为在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    我们向 `define_method` 传递了三个参数，Ruby 期望第三个参数是一个 proc 对象。虽然这种写法更加冗长，但由于调用 `lambda`
    明确表示 Ruby 会创建一个闭包，因此它显得稍微不那么令人困惑。'
- en: Finally, when we call the `new` method at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    Ruby resets the `self` pointer from the closure to receiver object, similar to
    the way that `instance_eval` works. This allows the new method to access `@str`
    as you would expect.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 调用 `new`
    方法时，Ruby 会将 `self` 指针从闭包重置为接收者对象，类似于 `instance_eval` 的工作方式。这使得 `new` 方法能够像预期的那样访问
    `@str`。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we’ve seen how the concept of closures—the idea central to the
    way blocks, lambdas, and procs work in Ruby—also applies to methods such as `eval`,
    `instance_eval`, and `define_method`. The same underlying concept explains how
    these different Ruby methods work. In a similar way, the concept of lexical scope
    underpins all of the ways that Ruby allows you to create a method and assign it
    to a class. Understanding the concept of lexical scope should make the different
    uses of Ruby’s `def` keyword and `class <<` syntax easier to understand.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到闭包的概念——这一概念在 Ruby 中块、lambda 和 proc 的工作原理中至关重要——同样适用于 `eval`、`instance_eval`
    和 `define_method` 等方法。相同的底层概念解释了这些不同的 Ruby 方法是如何工作的。同样，词法作用域的概念是 Ruby 中所有创建方法并将其赋值给类的方式的基础。理解词法作用域的概念应该使你更容易理解
    Ruby 中 `def` 关键字和 `class <<` 语法的不同用法。
- en: While metaprogramming might seem complex at first, learning how Ruby works internally
    can help us understand what Ruby’s metaprogramming features actually do. What
    seems initially like a large set of different, unrelated methods in a confusing
    API turn out to be related by a few important ideas. Studying Ruby internals allows
    us to see these concepts and to understand what they mean.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然元编程刚开始看起来可能很复杂，但了解 Ruby 的内部工作原理可以帮助我们理解 Ruby 的元编程特性到底做了什么。最初看似一组庞大且不相关的方法，在一个混乱的
    API 中，最终会发现它们是由一些重要的思想联系起来的。研究 Ruby 的内部机制使我们能够看到这些概念，并理解它们的含义。
