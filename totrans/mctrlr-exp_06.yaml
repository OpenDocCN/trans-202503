- en: '**6 NipPEr Is a buTt liCkeR**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss a buffer overflow vulnerability in a Dish Network
    smart-card, which was the subject of the famous lawsuit between EchoStar and NDS.
    The first public explanation of this bug was a short forum post, NipperClauz (2000),
    but thanks to the trial, we have far more detailed documentation in the form of
    a secret NDS internal tech report, Mordinson (1998).
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s set the stage. This smart-card was used in North America for Dish
    Network’s satellite TV service, where it would calculate a short-lived decryption
    key for the receiver. The chip inside is an ST16CF54 chip from ST Microelectronics,
    then known as SGS Thomson. The instruction set is mostly compatible with Motorola
    6805, except for the additional instructions TSA (`0x9E`) and MUL (`0x42`). The
    chip contains 16kB of user ROM, 8kB of system ROM, 4kB of EEPROM/OTP, and 480
    bytes of SRAM. The user ROM was developed by Nagra while the system ROM was developed
    by SGS Thomson.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6.1](ch06.xhtml#ch6fig1) shows the memory layout of the chip, and [Figure
    6.2](ch06.xhtml#ch6fig2) the EEPROM layout. Note that the EEPROM is mirrored to
    three additional address ranges, such that each EEPROM byte can be read from four
    unique addresses. A similar mirroring effect, sometimes called ghosting, will
    become very important later in this chapter, just as it was in [Chapter 5](ch05.xhtml#ch05).'
  prefs: []
  type: TYPE_NORMAL
- en: EEPROM patches consist of a single byte for the patch number, and a byte pair
    for the handler address of that patch. They are called before sensitive functions
    in a switch table, but there is no mechanism for patching ROM bugs that are not
    preceded by calls to the patch handler.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0064-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: ST16CF54 Memory Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0064-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Nagra1/Rom3 EEPROM Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Delayered ST16CF54A'
  prefs: []
  type: TYPE_NORMAL
- en: A treasure trove of documentation for this card can be found in Guy (2000b),
    and an annotated disassembly of the complete ROM is available in Guy (2000a).
    The only public documentation used to be a three-page marketing brief, but a copy
    of the real datasheet was exposed in court records in STMicro (1996). It is complete
    except for a missing companion document that describes the system ROM.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Bug**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bug itself is an overflow in a statically allocated byte buffer that first
    holds the incoming APDU packet, and is later reused for the outgoing reply. That
    much is a textbook buffer overflow, but there are a few complications to work
    around.
  prefs: []
  type: TYPE_NORMAL
- en: First, the buffer sits at `0x019C`, where it is the very last thing in SRAM.
    Smart-card packets can be up to 255 bytes long, but there are only 100 bytes before
    SRAM ends at `0x01FF`. After that, the official memory map shows a large gap before
    the system ROM.
  prefs: []
  type: TYPE_NORMAL
- en: The trick here, which makes the bug exploitable, is that SRAM is ghosted in
    memory. Past the end of SRAM and 132 bytes into our 100-byte buffer, a write to
    `0x0220` is the same as a write to `0x0020` or a write to `0x0420`. So even though
    the buffer that we are overflowing comes *after* global variables and the call
    stack, we can use the ghosting effect to loop back to the beginning of memory
    and corrupt useful things.
  prefs: []
  type: TYPE_NORMAL
- en: There is no ghosting effect for the registers that sit from `0x00` to `0x1F`,
    so we won’t need to carefully choose those values in the same way that we’ll try
    to preserve SRAM.
  prefs: []
  type: TYPE_NORMAL
- en: One other effect worth watching is that a global variable early in SRAM holds
    the index into the receive buffer. The packet is received one byte at a time;
    when that variable is overwritten, the target location will jump for the rest
    of the byte copies. This is useful for shaving some bytes off of the packet, but
    if you ignore it, your exploit will go off the rails and land in the wrong location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0067-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Forum Posting of NipperClauz (2000)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NipperClauz Exploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the theory, let’s dig into the first public example,
    NipperClauz (2000). The forum posting is reproduced in [Figure 6.4](ch06.xhtml#ch6fig4),
    and in this section we’ll disassemble it to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: These first three bytes are the transaction header, where `0xC4` is the length.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0068-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After that, we have many lines of counting bytes that look like garbage, sometimes
    interrupted by a more meaningful byte. Many of these bytes don’t matter, but the
    latter ones do overwrite global variables, and having the wrong value there might
    break the exploit by crashing the application or adjusting UART timing.
  prefs: []
  type: TYPE_NORMAL
- en: Shellcode begins halfway through line 35, and it calls back into the ROM’s function
    for transmitting a byte at `0x42d7` to remain quite short.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0068-02.jpg)![Image](../images/f0069-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The exploit ends with some filler and a checksum byte.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0069-02.jpg)![Image](../images/f0069-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NDS Headend Exploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Appendix F of Mordinson (1998) describes a different exploit for the same bug.
    The following is the original exploit from that report in the `nasm` assembler
    format, with minor changes to comments.
  prefs: []
  type: TYPE_NORMAL
- en: Note how clean the comments are, explaining nearly every instruction and providing
    the exact address at which it is loaded into memory. Rather than call back into
    the ROM’s function for transmitting a byte, it instead implements its own function
    for this at `0x01c8`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0070-01.jpg)![Image](../images/f0071-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**A Modern Exploit in Go**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both of those exploits will successfully dump the card’s EEPROM. This book is
    about writing exploits, not running them, so I ordered a dozen satellite receivers
    and assorted card collections until I found some that were vulnerable. In this
    section, we’ll cover Goodspeed (2022), my exploit for the cards, which runs on
    modern computers with USB smart-card adapters, dumping not just the EEPROM but
    also the user ROM and what SRAM it doesn’t corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: To get your own card, simply collect a bunch of them and then read the Answer
    To Reset (ATR) of the cards. You’re looking for one whose ROM reads as `DNASP003`
    (meaning ROM3) and whose EEPROM version reads as `Rev272` or earlier. A few of
    my cards falsely present a later EEPROM revision to pretend that they have been
    patched, so don’t always believe the version number when it tells you the card
    is not vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: These cards have already been hacked for TV piracy, of course. Hacked cards
    can also be recognized when the electronic serial number disagrees with the printed
    serial number.
  prefs: []
  type: TYPE_NORMAL
- en: The first complication is that the Headend and NipperClauze exploits dump back
    all EEPROM in a single transaction. Smart-card transactions have a one byte length
    field and a checksum, so the response is a lot more data than the length field
    ought to allow and the checksum is always wrong. That wasn’t a problem when these
    were written in the Nineties, but modern smart-card adapters use USB instead of
    a serial port. USB’s smart-card standard (CCID) abstracts away packets, requiring
    that all lengths and checksums be correct.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, I reduced my transactions to 64 bytes and wrote shellcode that
    accepts a base address for the dump. Like the other exploits, mine does not support
    clean continuation. I found it convenient to avoid continuation hassles by simply
    resetting the card for every transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0073-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Revision 369 EEPROM Dump'
  prefs: []
  type: TYPE_NORMAL
- en: You will note that my shellcode does not include the three byte header or one
    byte footer of the other examples. This is because the PCSC daemon automatically
    applies the header and checksum to the transaction. As the shellcode dumps just
    64 bytes per execution, the start address must be written into the `ld a, (target+1,
    x)` instruction in the loop, where `0xFFFF` sits in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: To transmit a reply back to the host, the shellcode jumps into a user ROM function
    at `0x757f`. This is the normal function that the ROM uses for transmitting its
    messages, which is a little smaller than reusing the function for transmitting
    a byte, as the NipperClauz shellcode does. It’s also smaller than implementing
    a completely custom transmitting function, as in the Headend exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0074-01.jpg)![Image](../images/f0075-01.jpg)'
  prefs: []
  type: TYPE_IMG
