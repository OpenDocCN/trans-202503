<html><head></head><body>
<h2 class="h2" id="ch7"><span epub:type="pagebreak" id="page_79"/><span class="big">7</span><br/>EXPLORING MODULES</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">In the preceding chapter, you learned about functions. Functions break a script into manageable units, giving you more efficient, more readable code. But there’s no reason a good function should exist in only a script or single session. In this chapter, you’ll learn about <em>modules</em>, groups of similar functions that are packaged together and distributed for others to use across many scripts.</span></p>&#13;
<p class="indent">In its purest form, a PowerShell module is just a text file with a <em>.psm1</em> file extension and some optional, extra metadata. Other types of modules that don’t fit this description are known as <em>binary modules</em> and <em>dynamic modules</em>, but they are outside the scope of this book.</p>&#13;
<p class="indent">Any command that hasn’t been explicitly placed in your session almost certainly comes from a module. Many of the commands you’ve been using throughout this book are part of Microsoft’s internal modules that come with PowerShell, but there are also third-party modules and the ones you create yourself. To use a module, you first have to install it. Then, when a <span epub:type="pagebreak" id="page_80"/>command inside a module needs to be used, that module has to be imported into your session; as of PowerShell v3, PowerShell auto-imports modules when a command is referenced.</p>&#13;
<p class="indent">You’ll begin this chapter by looking at the models that are already installed in your system. Then, you’ll take apart a model to see its different parts before finally looking at how to download and install PowerShell modules from the PowerShell Gallery.</p>&#13;
<h3 class="h3" id="ch7lev1">Exploring Default Modules</h3>&#13;
<p class="noindent">PowerShell comes with numerous modules installed by default. In this section, you’ll see how to discover and import modules from your session.</p>&#13;
<h4 class="h4" id="ch7lev1sec1">Finding Modules in Your Session</h4>&#13;
<p class="noindent">You can see the modules imported into your current session by using the <code>Get-Module</code> cmdlet (which is itself part of a module). The <code>Get-Module</code> cmdlet is a command that allows you to see all the modules on your system available to you in your current session.</p>&#13;
<p class="indent">Start a fresh PowerShell session and run <code>Get-Module</code>, as in <a href="ch07.xhtml#ch7list1">Listing 7-1</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module</span>&#13;
&#13;
ModuleType Version    Name                                ExportedCommands&#13;
---------- -------    ----                                ----------------&#13;
Manifest   3.1.0.0    Microsoft.PowerShell.Management     {Add-Computer, Add-Content...&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch7list1"><em>Listing 7-1: Viewing imported modules with the <code>Get-Module</code> command</em></p>&#13;
<p class="indent">Each line you see from this <code>Get-Module</code> output is a module that has been imported into the current session, which means all the commands inside that module are immediately available to you. The <code>Microsoft.PowerShell.Management</code> and <code>Microsoft.PowerShell.Utility</code> modules are imported in any PowerShell session by default.</p>&#13;
<p class="indent">Notice the <code>ExportedCommands</code> column in <a href="ch07.xhtml#ch7list1">Listing 7-1</a>. These are the commands you can use from the module. You can easily find all of these commands by using <code>Get-Command</code> and specifying the module name. Let’s check out all the exported commands inside the <code>Microsoft.PowerShell.Management</code> module in <a href="ch07.xhtml#ch7list2">Listing 7-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Command -Module Microsoft.PowerShell.Management</span>&#13;
&#13;
CommandType     Name                 Version    Source&#13;
-----------     ----                 -------    ------&#13;
Cmdlet          Add-Computer         3.1.0.0    Microsoft.PowerShell.Management&#13;
Cmdlet          Add-Content          3.1.0.0    Microsoft.PowerShell.Management &#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch7list2"><em>Listing 7-2: Viewing commands inside a PowerShell module</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>These are all the commands that are exported from that module; these are the ones that can be explicitly called from outside the module. Some module authors choose to include functions inside their modules that a user cannot use. Any function that is not exported to a user, and only does work inside a script or module, is called a <em>private function</em>, or what some developers refer to as a <em>helper function</em>.</p>&#13;
<p class="indent">Using <code>Get-Module</code> without any parameters will return all modules that are imported, but what about the modules that have been installed but not imported?</p>&#13;
<h4 class="h4" id="ch7lev1sec2">Finding Modules on Your Computer</h4>&#13;
<p class="noindent">To get a list of all modules that are installed and can be imported into your session, you can use <code>Get-Module</code> with the <code>ListAvailable</code> parameter, as in <a href="ch07.xhtml#ch7list3">Listing 7-3</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module –ListAvailable</span>&#13;
   Directory: C:\Program Files\WindowsPowerShell\Modules&#13;
&#13;
ModuleType Version    Name              ExportedCommands&#13;
---------- -------    ----              ----------------&#13;
Script     1.2        PSReadline        {Get-PSReadlineKeyHandler,Set-PSReadlineKeyHandler...&#13;
&#13;
&#13;
   Directory:\Modules&#13;
&#13;
&#13;
ModuleType Version    Name              ExportedCommands&#13;
---------- -------    ----              ----------------&#13;
Manifest   1.0.0.0    ActiveDirectory   {Add-ADCentralAccessPolicyMember...&#13;
Manifest   1.0.0.0    AppBackgroundTask {Disable-AppBackgroundTaskDiagnosticLog...&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch7list3"><em>Listing 7-3: Using <code>Get-Module</code> to view all available modules</em></p>&#13;
<p class="indent">The <code>ListAvailable</code> parameter tells PowerShell to check a few folders for any subfolders with <em>.psm1</em> files in them. PowerShell will then read each of those modules from the filesystem and return a list of each module’s name, some metadata, and all the functions that can be used from that module.</p>&#13;
<p class="indentb">PowerShell looks for modules on disk in a few default locations, depending on the type of module:</p>&#13;
<p class="noindenti"><strong>System modules</strong> Nearly all modules that come installed by default with PowerShell will be located in <em>C:\Windows\System32\WindowsPowerShell\1.0\Modules</em>. This module path is typically dedicated for internal PowerShell modules only. Technically, you could place modules in this folder, but it’s not recommended you do so.</p>&#13;
<p class="noindenti"><span epub:type="pagebreak" id="page_82"/><strong>All Users modules</strong> Modules are also stored in <em>C:\Program Files\WindowsPowerShell\Modules</em>. This path is loosely called the <em>All Users</em> module path, and it’s where you put any modules you’d like available to all users who log into the computer.</p>&#13;
<p class="noindentib"><strong>Current User modules</strong> Lastly, you can store modules in <em>C:\Users\&lt;LoggedInUser&gt;\Documents\WindowsPowerShell\Modules</em>. Inside this folder, you’ll find all modules that you’ve created or downloaded that are available to only the current user. Placing modules in this path allows for some separation if multiple users with different requirements will be logging into the computer.</p>&#13;
<p class="indent">When <code>Get-Module -ListAvailable</code> is called, PowerShell will read all these folder paths and return all the modules in each. However, these aren’t the only possible module paths, just the defaults.</p>&#13;
<p class="indent">You can tell PowerShell to add a new module path by using the <code>$PSModulePath</code> environment variable, which defines each module folder separated by a semicolon, as shown in <a href="ch07.xhtml#ch7list4">Listing 7-4</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$env:PSModulePath</span>&#13;
C:\Users\Adam\Documents\WindowsPowerShell\Modules;&#13;
C:\Program Files\WindowsPowerShell\Modules\Modules;&#13;
C:\Program Files (x86)\Microsoft SQL Server\140\Tools\PowerShell\Modules\</pre>&#13;
<p class="caption" id="ch7list4"><em>Listing 7-4: The <code>PSModulePath</code> environment variable</em></p>&#13;
<p class="indent">You can add folders to the <code>PSModulePath</code> environment variable by doing a little string parsing, although this technique may be a little advanced. Here’s a quick one-liner:</p>&#13;
<pre>PS&gt;<span class="codestrong1"> $env:PSModulePath + ';C;\MyNewModulePath'.</span></pre>&#13;
<p class="indent">However, be aware that this adds the new folder in only the current session. To make this change persistent, you need to use the <code>SetEnvironmentVariable()</code> method on the <code>Environment</code> .NET class, like so:</p>&#13;
<pre>PS&gt; $CurrentValue = [Environment]::GetEnvironmentVariable("PSModulePath", "Machine")&#13;
PS&gt; [Environment]::SetEnvironmentVariable("PSModulePath", $CurrentValue + ";C:\&#13;
MyNewModulePath", "Machine")</pre>&#13;
<p class="indent">Let’s now see how to use the modules you have by importing them.</p>&#13;
<h4 class="h4" id="ch7lev1sec3">Importing Modules</h4>&#13;
<p class="noindent">Once a module folder path is in the <code>PSModulePath</code> environment variable, you have to import the module into the current session. Nowadays, because of <span epub:type="pagebreak" id="page_83"/>PowerShell’s auto-importing feature, if you have a module installed, you can usually call the function you want first, and PowerShell will auto-import the module it belongs to. Still, it’s important to understand how importing works.</p>&#13;
<p class="indent">Let’s use a default PowerShell module called <code>Microsoft.PowerShell.Management</code>. In <a href="ch07.xhtml#ch7list5">Listing 7-5</a>, you’ll run <code>Get-Module</code> twice: once in a fresh PowerShell session, and once after using the <code>cd</code> command, an alias for <code>Set-Location</code>, a command found in the <code>Microsoft.PowerShell.Management</code> module. Look what happens:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module</span>&#13;
&#13;
ModuleType Version    Name                                ExportedCommands&#13;
---------- -------    ----                                ----------------&#13;
Manifest   3.1.0.0    Microsoft.PowerShell.Utility        {Add-Member, Add-Type...&#13;
Script     1.2        PSReadline                          {Get-PSReadlineKeyHandler... &#13;
&#13;
&#13;
PS&gt; cd\&#13;
PS&gt; Get-Module&#13;
&#13;
ModuleType Version    Name                                ExportedCommands&#13;
---------- -------    ----                                ----------------&#13;
Manifest   3.1.0.0    Microsoft.PowerShell.Management     {Add-Computer, Add-Content...&#13;
Manifest   3.1.0.0    Microsoft.PowerShell.Utility        {Add-Member, Add-Type...&#13;
Script     1.2        PSReadline                          {Get-PSReadlineKeyHandler....</pre>&#13;
<p class="caption" id="ch7list5"><em>Listing 7-5: PowerShell auto-imports <code>Microsoft.PowerShell.Management</code> after using <code>cd</code>.</em></p>&#13;
<p class="indent">As you can see, <code>Microsoft.PowerShell.Management</code> is auto-imported after you use <code>cd</code>. The auto-import feature usually works. But if you’re expecting a command inside a module to be available and it’s not, a problem with the module might be preventing the command’s import.</p>&#13;
<p class="indent">To manually import a module, use the <code>Import-Module</code> command, as in <a href="ch07.xhtml#ch7list6">Listing 7-6</a>.</p>&#13;
<pre>PS&gt; Import-Module -Name Microsoft.PowerShell.Management&#13;
PS&gt; Import-Module -Name Microsoft.PowerShell.Management -Force&#13;
PS&gt; Remove-Module -Name Microsoft.PowerShell.Management</pre>&#13;
<p class="caption" id="ch7list6"><em>Listing 7-6: Importing a module manually, reimporting it, and removing it</em></p>&#13;
<p class="indent">You’ll notice this listing also uses the <code>Force</code> parameter and the <code>Remove</code><code>-Module</code> command. If the module has been changed (say you’ve made changes to a custom module), you can use the <code>Import-Module</code> command with the <code>Force</code> parameter to unload and reimport the module. The <code>Remove-Module</code> unloads a module from a session, although this command is not used often.</p>&#13;
<h3 class="h3" id="ch7lev2"><span epub:type="pagebreak" id="page_84"/>The Components of a PowerShell Module</h3>&#13;
<p class="noindent">Now that you’ve learned how to use a PowerShell module, let’s see what they look like.</p>&#13;
<h4 class="h4" id="ch7lev2sec4">The .psm1 File</h4>&#13;
<p class="noindent">Any text file with a .<em>psm1</em> file extension can be a PowerShell module. For this file to be useful, it must have functions inside it. While not strictly required, all functions inside a module should be built around the same concept. For example, <a href="ch07.xhtml#ch7list7">Listing 7-7</a> shows some functions dealing with software installation.</p>&#13;
<pre>function Get-Software {&#13;
    param()&#13;
}&#13;
&#13;
function Install-Software {&#13;
    param()&#13;
}&#13;
&#13;
function Remove-Software {&#13;
    param()&#13;
}</pre>&#13;
<p class="caption" id="ch7list7"><em>Listing 7-7: Functions dealing with software installation</em></p>&#13;
<p class="indent">Notice that the noun in each command’s name stays the same, and only the verb changes. This is best practice when building modules. If you find yourself needing to change the noun, then you should start thinking about breaking one module into multiple modules.</p>&#13;
<h4 class="h4" id="ch7lev2sec5">The Module Manifest</h4>&#13;
<p class="noindent">Besides a <em>.psm1</em> file full of functions, you’ll also have a module manifest, or a <em>.psd1</em> file. A <em>module manifest</em> is an optional but recommended text file written in the form of a PowerShell hashtable. This hashtable contains elements that describe metadata about the module.</p>&#13;
<p class="indent">It’s possible to create a module manifest from scratch, but PowerShell has a <code>New-ModuleManifest</code> command that can generate a template for you. Let’s use <code>New-ModuleManifest</code> to build a module manifest for our software package, as in <a href="ch07.xhtml#ch7list8">Listing 7-8</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-ModuleManifest -Path</span> 'C:\Program Files\WindowsPowerShell\Modules\Software\Software.psd1' &#13;
-Author 'Adam Bertram' -RootModule Software.psm1 &#13;
-Description 'This module helps in deploying software.'</pre>&#13;
<p class="caption" id="ch7list8"><em>Listing 7-8: Using the <code>New-ModuleManifest</code> to build a module manifest</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>This command creates a <em>.psd1</em> file that looks like this:</p>&#13;
<pre>#&#13;
# Module manifest for module 'Software'&#13;
#&#13;
# Generated by: Adam Bertram&#13;
#&#13;
# Generated on: 11/4/2019&#13;
#&#13;
&#13;
@{&#13;
&#13;
# Script module or binary module file associated with this manifest.&#13;
RootModule = 'Software.psm1'&#13;
&#13;
# Version number of this module.&#13;
ModuleVersion = '1.0'&#13;
&#13;
# Supported PSEditions&#13;
# CompatiblePSEditions = @()&#13;
&#13;
# ID used to uniquely identify this module&#13;
GUID = 'c9f51fa4-8a20-4d35-a9e8-1a960566483e'&#13;
&#13;
# Author of this module&#13;
Author = 'Adam Bertram'&#13;
&#13;
# Company or vendor of this module&#13;
CompanyName = 'Unknown'&#13;
&#13;
# Copyright statement for this module&#13;
Copyright = '(c) 2019 Adam Bertram. All rights reserved.'&#13;
&#13;
# Description of the functionality provided by this module&#13;
Description = 'This modules helps in deploying software.'&#13;
&#13;
# Minimum version of the Windows PowerShell engine required by this module&#13;
# PowerShellVersion = ''&#13;
&#13;
# Name of the Windows PowerShell host required by this module&#13;
# PowerShellHostName = ''&#13;
<span class="codeitalic1">--snip--</span>&#13;
}</pre>&#13;
<p class="indent">As you can see when running the command, there are plenty of fields for which I didn’t provide parameters. We’re not going to go in depth on module manifests. For now, just know that, at a minimum, always define the <code>RootModule</code>, <code>Author</code>, <code>Description</code>, and perhaps the <code>version</code>. All of these attributes are optional, but it’s always good practice to get in the habit of adding as much information to the module manifest as possible.</p>&#13;
<p class="indent">Now that you’ve seen the anatomy of a module, let’s see how to download and install one.</p>&#13;
<h3 class="h3" id="ch7lev3"><span epub:type="pagebreak" id="page_86"/>Working with Custom Modules</h3>&#13;
<p class="noindent">Thus far, you’ve been working with only the modules installed in PowerShell by default. In this section, you’ll see how to find, install, and uninstall custom modules.</p>&#13;
<h4 class="h4" id="ch7lev3sec6">Finding Modules</h4>&#13;
<p class="noindent">One of the best parts of modules is sharing them: why waste your time solving a problem that’s already been solved? Chances are, if you’re running into a problem, the PowerShell Gallery has a solution. The <em>PowerShell Gallery</em> (<em><a href="https://www.powershellgallery.com/">https://www.powershellgallery.com/</a></em>) is a repository of thousands of PowerShell modules and scripts that anyone with an account can freely upload to or download from. It has modules written by single individuals, and modules written by gigantic corporations like Microsoft.</p>&#13;
<p class="indent">Lucky for us, you can also use the Gallery from PowerShell itself. PowerShell has a built-in module called <code>PowerShellGet</code> that provides simple-to-use commands to interact with the PowerShell Gallery. <a href="ch07.xhtml#ch7list9">Listing 7-9</a> uses <code>Get-Command</code> to pull up the <code>PowerShellGet</code> commands.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Command -Module PowerShellGet</span>&#13;
&#13;
CommandType     Name                           Version    Source&#13;
-----------     ----                           -------    ------&#13;
Function        Find-Command                   1.1.3.1    powershellget&#13;
Function        Find-DscResource               1.1.3.1    powershellget&#13;
Function        Find-Module                    1.1.3.1    powershellget&#13;
Function        Find-RoleCapability            1.1.3.1    powershellget&#13;
Function        Find-Script                    1.1.3.1    powershellget&#13;
Function        Get-InstalledModule            1.1.3.1    powershellget&#13;
Function        Get-InstalledScript            1.1.3.1    powershellget&#13;
Function        Get-PSRepository               1.1.3.1    powershellget&#13;
Function        Install-Module                 1.1.3.1    powershellget&#13;
Function        Install-Script                 1.1.3.1    powershellget&#13;
Function        New-ScriptFileInfo             1.1.3.1    powershellget&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch7list9"><em>Listing 7-9: The <code>PowerShellGet</code> commands</em></p>&#13;
<p class="indent">The <code>PowerShellGet</code> module includes commands for finding, saving, and installing modules, as well as publishing your own. You’re not quite ready to publish modules yet (you haven’t even created your own!), so we’ll focus on how to find and install modules from the PowerShell Gallery.</p>&#13;
<p class="indent">To find a module, you use the <code>Find-Module</code> command, which allows you to search the PowerShell Gallery for modules matching a specific name. If you’re looking for modules to manage a VMware infrastructure, for example, you can use wildcards with the <code>Name</code> parameter to find all modules in the PowerShell Gallery that have the word <em>VMware</em> in them, as in <a href="ch07.xhtml#ch7list10">Listing 7-10</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_87"/>PS&gt; <span class="codestrong1">Find-Module -Name *VMware*</span>&#13;
&#13;
Version      Name                                Repository      Description&#13;
-------      ----                                ----------      -----------&#13;
6.5.2.6...   VMware.VimAutomation.Core           PSGallery       This Windows... &#13;
1.0.0.5...   VMware.VimAutomation.Sdk            PSGallery       This Windows...&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch7list10"><em>Listing 7-10: Using <code>Find-Module</code> to locate modules related to VMware</em></p>&#13;
<p class="indent">The <code>Find-Module</code> command doesn’t download anything; it just shows you what’s in the PowerShell Gallery. In the next section, you’ll see how to install the modules.</p>&#13;
<h4 class="h4" id="ch7lev3sec7">Installing Modules</h4>&#13;
<p class="noindent">Once you have a module you want to install, you can use the <code>Install-Module</code> command to install it. The <code>Install-Module</code> command can take a <code>Name</code> parameter, but let’s use the pipeline and simply send the objects that <code>Find-Module</code> returns directly to the <code>Install-Module</code> command (<a href="ch07.xhtml#ch7list11">Listing 7-11</a>).</p>&#13;
<p class="indent">Note that you may receive a warning about an untrusted repository. You will receive this untrusted warning because, by default, the <code>Find-Module</code> command uses a PowerShell repository that is untrusted, meaning you must explicitly tell PowerShell to trust all packages inside that repository. Otherwise, it will prompt you to run <code>Set-PSRepository</code>, as shown in <a href="ch07.xhtml#ch7list11">Listing 7-11</a>, to change the installation policy for that repository.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Find-Module -Name VMware.PowerCLI | Install-Module</span>&#13;
&#13;
Untrusted repository You are installing the modules from an untrusted repository. If you trust&#13;
this repository, change its InstallationPolicy value by running the Set-PSRepository cmdlet.&#13;
Are you sure you want to install the modules from 'https://www.powershellgallery.com/api/v2/'?&#13;
[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is "N"): <span class="codestrong1">a</span>&#13;
Installing package 'VMware.PowerCLI'&#13;
Installing dependent package 'VMware.VimAutomation.Cloud' [oooooooooooooooooooooooooooooooooooo&#13;
ooooooooooooooooooooooooo] Installing package 'VMware.VimAutomation.Cloud'&#13;
Downloaded 1003175.00 MB out of 1003175.00 MB. [ooooooooooooooooooooooooooooooooooooooooooooooo&#13;
oooooooooooooooooooooo]</pre>&#13;
<p class="caption" id="ch7list11"><em>Listing 7-11: Installing a module by using the <code>Install-Module</code> command</em></p>&#13;
<p class="indent">By default, the command in <a href="ch07.xhtml#ch7list11">Listing 7-11</a> will download the module and place it into the All Users module path in <em>C:\Program Files</em>. To check that the module is in this path, you can use the following command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module -Name VMware.PowerCLI -ListAvailable | Select-Object –Property ModuleBase</span>&#13;
&#13;
ModuleBase&#13;
----------&#13;
C:\Program Files\WindowsPowerShell\Modules\VMware.PowerCLI\6.5.3.6870460</pre>&#13;
<h4 class="h4" id="ch7lev3sec8"><span epub:type="pagebreak" id="page_88"/>Uninstalling Modules</h4>&#13;
<p class="noindent">Newcomers to PowerShell often get confused by the difference between removing and uninstalling a module. As you saw in “Importing Modules” on <a href="ch07.xhtml#page_82">page 82</a>, you can use <code>Remove-Module</code> to <em>remove</em> a module from the PowerShell session. But this only unloads the module from the session; it doesn’t remove the module from your disk.</p>&#13;
<p class="indent">To take a module off the disk—or <em>uninstall</em> it—you have to use the <code>Uninstall-Module</code> cmdlet. <a href="ch07.xhtml#ch7list12">Listing 7-12</a> uninstalls the module you just installed.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Uninstall-Module -Name VMware.PowerCLI</span></pre>&#13;
<p class="caption" id="ch7list12"><em>Listing 7-12: Uninstalling a module</em></p>&#13;
<p class="indent">Only modules downloaded from the PowerShell Gallery will be uninstalled via <code>Uninstall-Module</code>—the default modules are there to stay!</p>&#13;
<h3 class="h3" id="ch7lev4">Creating Your Own Module</h3>&#13;
<p class="noindent">So far, you’ve been working with other people’s modules. Of course, one of the amazing things about PowerShell modules is you can create your own and share it with the rest of the world. You’ll spend <a href="part3.xhtml#part3">Part III</a> of this book building a real-world module, but for now, let’s see how to turn your Software module into a real module.</p>&#13;
<p class="indent">As you saw earlier, a typical PowerShell module consists of a folder (the <em>module container</em>), <em>.psm1</em> file (the module), and a <em>.psd1</em> file (the module manifest). If the module folder is in one of the three locations (System, All Users, or Current User), PowerShell will automatically see this and import it.</p>&#13;
<p class="indent">Let’s first create the module folder. The module folder must be the same name as the module itself. Since I tend to make modules available for all users on a system, you’ll add it to the All Users module path, like so:</p>&#13;
<pre>PS&gt; <span class="codestrong1">mkdir 'C:\Program Files\WindowsPowerShell\Modules\Software'</span></pre>&#13;
<p class="indent">Once you create the folder, make a blank <em>.psm1</em> file that will eventually hold your functions:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Add-Content 'C:\Program Files\WindowsPowerShell\Modules\Software\Software.psm1'</span></pre>&#13;
<p class="indent">Next, create the module manifest just as you did in <a href="ch07.xhtml#ch7list8">Listing 7-8</a>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-ModuleManifest -Path</span> 'C:\Program Files\WindowsPowerShell\Modules\Software\Software.psd1' &#13;
-Author 'Adam Bertram' -RootModule Software.psm1 &#13;
-Description 'This module helps in deploying software.'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>At this point, PowerShell should be able to see your module, but notice it does not see any exported commands yet:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module -Name Software -List</span>&#13;
&#13;
&#13;
    Directory: C:\Program Files\WindowsPowerShell\Modules&#13;
&#13;
&#13;
ModuleType Version    Name                      ExportedCommands&#13;
---------- -------    ----                      ----------------&#13;
Script     1.0        Software</pre>&#13;
<p class="indent">Let’s add the three functions you used earlier into the <em>.psm1</em> file and see if PowerShell recognizes them now:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module -Name Software -List</span>&#13;
&#13;
&#13;
    Directory: C:\Program Files\WindowsPowerShell\Modules&#13;
&#13;
&#13;
ModuleType Version    Name                      ExportedCommands&#13;
---------- -------    ----                      ----------------&#13;
Script     1.0        Software                  {Get-Software...</pre>&#13;
<p class="indent">PowerShell has exported all the commands inside your module and made them available for use. If you want to go the extra mile and choose which commands get exported, you can also open your module manifest and find the <code>FunctionsToExport</code> key. In there, you can define each command, separated by a comma, which will then dictate which commands get exported. Although not mandatory, it provides a more granular approach to exporting module functions.</p>&#13;
<p class="indent">Congrats! You’ve just created your first module! It won’t do much unless you fill the functions in with real functionality, a fun challenge for you to do on your own.</p>&#13;
<h3 class="h3" id="ch7lev5">Summary</h3>&#13;
<p class="noindent">In this chapter, you learned about modules, groups of like-minded code that prevent you from wasting time on problems that have already been solved. You saw the basic anatomy of a module, as well as how to install, import, remove, and uninstall them. You even made your own basic module!</p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8">Chapter 8</a>, you’ll learn how to access remote computers by using PowerShell remoting.<span epub:type="pagebreak" id="page_90"/></p>&#13;
</body></html>