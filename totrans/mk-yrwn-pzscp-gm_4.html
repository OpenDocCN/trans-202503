<html><head></head><body>
<p class="timage5"><img alt="Image" src="../images/pg063-01.jpg"/></p>&#13;
<h2 class="h2a" id="ch04"><span epub:type="pagebreak" id="page_63"/><span class="big">4</span><br/>Robot Heist: Creating Rules and Obstacles</h2>&#13;
<p class="noindent">In this chapter, you’ll build the <em>Robot Heist</em> game from the ground up. You’ll make two robot objects that the player will use to navigate each level. You’ll also create the backdrop and other objects, such as crates, guns, and panels. You’ll use PuzzleScript rules to make these objects interact with one another in interesting ways.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>Recall from <a href="ch02.xhtml">Chapter 2</a> that the <span class="literal">RULES</span> section in your code is where you write instructions to change one set of objects into another.</p>&#13;
<h3 class="h3" id="ch4.1">How Robot Heist Works</h3>&#13;
<p class="noindent">In <em>Robot Heist</em>, two robots work together to rob a Data Bank. Each robot has different capabilities, so the player needs to switch between them to solve puzzles. There are security robots and lasers to avoid, and a treasure to steal. You’ll find the game at <em><a href="http://tinyurl.com/robotheist/">http://tinyurl.com/robotheist/</a></em>. This is what the game looks like.</p>&#13;
<p class="imagel"><img alt="Image" src="../images/pg064-01.jpg"/></p>&#13;
<p class="caption"><em>Example level in</em> Robot Heist</p>&#13;
<p class="indent">The game begins with only one robot named Vertibot because we want the player to learn the basics before introducing a second robot. Vertibot can push objects vertically (up and down). Later in the game, the player meets another robot named Horibot that can push objects horizontally (left and right). To take advantage of their different pushing capabilities, the player must make Vertibot and Horibot work together to solve the game’s puzzles.</p>&#13;
<h3 class="h3" id="ch4.2"><span epub:type="pagebreak" id="page_65"/>Brainstorming Objects and Interactions</h3>&#13;
<p class="noindent">Before I started working on my <em>Robot Heist</em> game, I thought carefully about what objects I wanted in the game. I didn’t just want objects that were cool: I wanted objects that worked together in intriguing ways. Choosing your game’s objects is like casting a play, and a play in which none of the characters talk to each other would be very boring.</p>&#13;
<p class="image"><img alt="Image" src="../images/pg065-01.jpg"/></p>&#13;
<p class="indent">The objects I came up with were the robots (the player characters), crates to push, gates to open and close, security lasers, and patrolling guard robots. Each of these objects interacts with the others in the following ways:</p>&#13;
<p class="bqpara"><strong>Robots (the player)</strong> Robots can push crates and open gates. They need to avoid lasers and guards.</p>&#13;
<p class="bqpara"><strong>Crates</strong> Robots can push crates to block lasers or hold gates open. Crates can also block guards, so robots can put them in a guard’s path to confuse them.</p>&#13;
<p class="bqpara"><span epub:type="pagebreak" id="page_66"/><strong>Gates</strong> Robots and guards can open and close gates. Crates can be used to keep gates open. Gates block lasers when they’re closed but let lasers through when they’re open.</p>&#13;
<p class="bqpara"><strong>Lasers</strong> A laser will catch the robots if one of them tries to cross it, but robots can block a laser with a crate or a gate. Guards can block lasers as well, so the robots can sometimes sneak past while a guard is blocking the laser.</p>&#13;
<p class="bqpara"><strong>Guards</strong> Guards can open and close gates or block lasers. Guards can catch robots, so robots should avoid them. Robots can use crates to block the guards’ paths.</p>&#13;
<p class="indentt">This is my cast of characters! Because I can make them all interact with each other, I should be able to make a lot of fun levels.</p>&#13;
<h3 class="h3" id="ch4.3">Getting Started</h3>&#13;
<p class="noindent">PuzzleScript remembers the last 20 versions you’ve saved, but it’ll forget any versions after that. You can click the <strong>Load</strong> menu at the top of the window to see your saved versions.</p>&#13;
<p class="indent">Before you start a new project, be sure to make a copy of the previous one! The easiest way to do this is to click <strong>Share</strong> as if you were sharing your game and keep a copy of the link. When you click the link, you should see the <strong>hack</strong> button that lets you access your game’s code again.</p>&#13;
<div class="note">&#13;
<p class="note1"><strong><span class="snote">NOTE:</span></strong> You could also copy all the code and email it to yourself. Click the <strong>Export</strong> button to create an HTML copy of your game. To find the game code in your HTML file, open it using a plain text editor. The text between “sourceCode=” and “;compile” is your game code! Copy and paste the unformatted code into a free formatting tool like <em><a href="https://www.freeformatter.com/javascript-escape.html">https://www.freeformatter.com/javascript-escape.html</a></em> and then click <strong>UNESCAPE</strong>. You should now see the complete code of your game.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>After you’ve backed up your old project, you can start the new one. Click <strong>Load Example</strong>▸<strong>Blank Project</strong> to start a new game from scratch.</p>&#13;
<p class="imagel"><img alt="Image" src="../images/pg067-01.jpg"/></p>&#13;
<p class="caption"><em>Creating a new project</em></p>&#13;
<p class="indent">Give your new game a title and an author. You can add these at the beginning of your code, like this:</p>&#13;
<pre><span class="purplebold">title</span> <span class="orangeitalic">Robot Heist</span>&#13;
<span class="purplebold">author</span> <span class="orangeitalic">anna anthropy</span></pre>&#13;
<p class="indent">Keep in mind that the title and author should go before your code’s <span class="literal">OBJECTS</span> section. Now that you’ve labeled your new game, you’re ready to start adding objects to the game.</p>&#13;
<h4 class="h4" id="ch4.3.1">Creating Objects</h4>&#13;
<p class="noindent">Objects are a very important part of your code because they outline all the items that make up your game. Whenever you add a new element to your game, you’ll follow these steps to create an object for it in your code’s <span class="literal">OBJECTS</span> section.</p>&#13;
<ol>&#13;
<li class="noindent">Add an object to the <span class="literal">OBJECTS</span> section, giving it a name and appearance.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_68"/>Add the object to the <span class="literal">LEGEND</span> section so it appears in the level editor.</li>&#13;
<li class="noindent">Add the object to the <span class="literal">COLLISIONLAYERS</span> section. PuzzleScript won’t run if there are objects that don’t have a collision layer, because it won’t know what to do if they touch another object.</li>&#13;
<li class="noindent">Write the rules that tell PuzzleScript what the object should do.</li>&#13;
</ol>&#13;
<p class="indent">To start, let’s add the most basic objects we need: a background and some sort of solid wall.</p>&#13;
<pre><span class="lightgray">=======</span>&#13;
<span class="purplebold"><span class="codestrong1">OBJECTS</span></span>&#13;
<span class="lightgray">=======</span>&#13;
<span class="green">Background</span>&#13;
<span class="green1">Green</span>&#13;
<span class="green">Wall</span>&#13;
<span class="lightgreen">LightGreen</span> <span class="darkgreen">DarkGreen</span>&#13;
<span class="lightgreen">0000</span><span class="darkgreen">1</span>&#13;
<span class="lightgreen">0000</span><span class="darkgreen">1</span>&#13;
<span class="lightgreen">0000</span><span class="darkgreen">1</span>&#13;
<span class="lightgreen">0000</span><span class="darkgreen">1</span>&#13;
<span class="darkgreen">11111</span></pre>&#13;
<p class="indent">Your background and wall can look like these, or you can use your own colors. Keep in mind that if you give an object just a color but no numbered pixels, the object will just look like a solid square of that color. For example, in the example level shown at the beginning of this chapter, I made the background <span class="literal">Green</span> without including numbered pixels, which means it will be a solid green. But I list two colors for the wall: <span class="literal">LightGreen</span> and <span class="literal">DarkGreen</span>. Then I use a grid of numbers below that to specify that the outer pixels will be in dark green to make a border around the light green interior.</p>&#13;
<p class="indent">Before we can use these objects, we need to add them to the <span class="literal">LEGEND</span> section.</p>&#13;
<h4 class="h4" id="ch4.3.2"><span epub:type="pagebreak" id="page_69"/>Creating the Legend</h4>&#13;
<p class="noindent">Adding an object to the legend makes it appear in the level editor so we can draw with it. Let’s add the background and wall to the <span class="literal">LEGEND</span> section and assign a symbol to each, as shown here:</p>&#13;
<pre><span class="lightgray">=======</span>&#13;
<span class="purplebold"><span class="codestrong1">LEGEND</span></span>&#13;
<span class="lightgray">=======</span>&#13;
<span class="green">.</span> <span class="white">=</span> <span class="green">Background</span>&#13;
<span class="green">#</span> <span class="white">=</span> <span class="green">Wall</span></pre>&#13;
<p class="indent">Not all objects need to be in the legend. For example, some objects never appear at the very start of a level, so we don’t need them in the level editor. We’ll make some objects like that soon.</p>&#13;
<p class="indent">Now add your new objects to the <span class="literal">COLLISIONLAYERS</span> section:</p>&#13;
<pre><span class="lightgray">================</span>&#13;
<span class="purplebold"><span class="codestrong1">COLLISIONLAYERS</span></span>&#13;
<span class="lightgray">================</span>&#13;
<span class="green">Background</span>&#13;
<span class="green">Wall</span></pre>&#13;
<p class="indent">Keep in mind that objects collide with each other only if they’re on the same collision layer. Because the background and wall objects are on different layers (each on its own line of code), they can share the same space without colliding. This allows the wall to sit on top of a background tile, which acts as the floor.</p>&#13;
<p class="indent">We don’t need to add any rules for these objects, because we don’t need them to do anything but display on the screen. Any other solid object we add from this point forward will need to be on the same collision layer as the wall because the walls should be able to block other objects from moving through them.</p>&#13;
<p class="indent">Now that we have our basic building blocks, we can run our game, right? Not so fast! PuzzleScript won’t let you run a game unless it has a player object. Let’s figure out how our two player robots are going to work!</p>&#13;
<h3 class="h3" id="ch4.4"><span epub:type="pagebreak" id="page_70"/>Player Swapping</h3>&#13;
<p class="noindent">Think about what we need the player objects to do. We want two robots that are onscreen at the same time, but the player can control only one at a time. The player can switch between the two robots at any time.</p>&#13;
<p class="image"><img alt="image" src="../images/pg070-01.jpg"/></p>&#13;
<p class="indent">One way to think about this scenario is that only one robot is <em>awake</em> at any given time while the other one is <em>asleep.</em> (Just like the cats in <em>Herding Cats</em>!) When the player presses the <em>action key</em>, the sleeping robot wakes up and the awake robot goes to sleep.</p>&#13;
<p class="indent">We can program the action key (either X or the spacebar) to do whatever we want, and the player can press it during the game. In our game, we’ll use the action key to allow the player to switch between robots. This means we need four objects in total to pull off this wacky scheme. Because we have two different robots, each needs two possible states: awake or asleep.</p>&#13;
<p class="indent">Our robots will also need something to push around, so let’s make a crate object while we’re creating the four robot objects. Add the four robot objects and the crate object to your game, using the following code.</p>&#13;
<pre><span class="green">Vertibot</span>&#13;
<span class="blue">blue</span> <span class="pink">pink</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
<span epub:type="pagebreak" id="page_71"/><span class="lightgray">.</span><span class="pink">1</span><span class="blue">0</span><span class="pink">1</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="pink">111</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
&#13;
<span class="green">VertibotSleeping</span>&#13;
<span class="blue">blue</span> <span class="lightgray">gray</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.1</span><span class="blue">0</span><span class="lightgray">1.</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.111.</span>&#13;
<span class="lightgray">.</span><span class="blue">000</span><span class="lightgray">.</span>&#13;
&#13;
<span class="green">Horibot</span>&#13;
<span class="orange">orange</span> <span class="blue">blue</span>&#13;
<span class="lightgray">.....</span>&#13;
<span class="orange">0</span><span class="blue">1</span><span class="orange">0</span><span class="blue">1</span><span class="orange">0</span>&#13;
<span class="orange">00000</span>&#13;
<span class="orange">0</span><span class="blue">111</span><span class="orange">0</span>&#13;
<span class="lightgray">.....</span>&#13;
&#13;
<span class="green">HoribotSleeping</span>&#13;
<span class="orange">orange</span> <span class="lightgray">gray</span>&#13;
<span class="lightgray">.....</span>&#13;
<span class="orange">0</span><span class="lightgray">1</span><span class="orange">0</span><span class="lightgray">1</span><span class="orange">0</span>&#13;
<span class="orange">00000</span>&#13;
<span class="orange">0</span><span class="lightgray">111</span><span class="orange">0</span>&#13;
<span class="lightgray">.....</span>&#13;
&#13;
<span class="green">Crate</span>&#13;
<span class="yellow">yellow</span> <span class="brown">brown</span>&#13;
<span class="yellow">00000</span>&#13;
<span class="yellow">0</span><span class="brown">111</span><span class="yellow">0</span>&#13;
<span class="yellow">0</span><span class="brown">111</span><span class="yellow">0</span>&#13;
<span class="yellow">0</span><span class="brown">111</span><span class="yellow">0</span>&#13;
<span class="yellow">00000</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>As you can see, I drew the Vertibot to look tall and thin and the Horibot to look short and stout to make it easy to tell them apart. I made the sleeping version of each robot look different from the awake version by making the sleeping robots gray. The player should be able to tell just by looking at the colors which robot is awake and which is asleep. The crate is a square object that has a yellow border around its brown interior.</p>&#13;
<h4 class="h4" id="ch4.4.1">Updating the Legend</h4>&#13;
<p class="noindent">Now we need to put our new objects in the legend so we can use them in our levels. I picked the letter <em>I</em> for Vertibots because it’s tall and vertical and an <em>H</em> for Horibot. Let’s update the <span class="literal">LEGEND</span> section, as shown here:</p>&#13;
<pre><span class="lightgray">=======</span>&#13;
<span class="purplebold"><span class="codestrong1">LEGEND</span></span>&#13;
<span class="lightgray">=======</span>&#13;
<span class="green">.</span> <span class="white">=</span> <span class="green">Background</span>&#13;
<span class="green">#</span> <span class="white">=</span> <span class="green">Wall</span>&#13;
<span class="green">I</span> <span class="white">=</span> <span class="green">Vertibot</span>&#13;
<span class="green">H</span> <span class="white">=</span> <span class="green">HoribotSleeping</span>&#13;
<span class="green">*</span> <span class="white">=</span> <span class="green">Crate</span></pre>&#13;
<p class="indent">Any objects we add to the legend should now appear in the level editor. You might notice that we only added two robot objects to the legend: the awake Vertibot and the asleep Horibot. The reason is that what we’re drawing in the level editor is the starting position for each level. In other words, we’re designing the way the level looks at the very beginning of play. Whenever a level begins, one robot should be awake and the other asleep. For consistency, I decided that at the start of each level, Vertibot will always be the robot that’s awake and Horibot will always be asleep.</p>&#13;
<p class="indent">PuzzleScript won’t let us run our game until we have a player object. Without it, PuzzleScript won’t know which of the two objects to move when the player presses the keys. Fortunately, the legend lets us define groups. You can use a group to contain multiple objects, which you can then refer to by the same name. For example, we can create a group called <span class="literal">Player</span> and add both robots to it by adding the following code to the <span class="literal">LEGEND</span> section:</p>&#13;
<pre><span class="green">Player</span> <span class="white">=</span> <span class="green">Vertibot</span> <span class="purple">or</span> <span class="green">Horibot</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>By writing <span class="literal">Vertibot or Horibot</span>, we specify that only one of the awake versions of the robots counts as a player. Because <span class="literal">VertibotSleeping</span> and <span class="literal">HoribotSleeping</span> don’t count as players, they won’t move when the player runs the game.</p>&#13;
<p class="indent">PuzzleScript lets you have as many players onscreen as you like at the same time. But in our game, the two robots won’t ever be awake at the same time. Whichever one is awake will act as the player and move when the player presses the arrow keys.</p>&#13;
<h4 class="h4" id="ch4.4.2">Updating the Collision Layers</h4>&#13;
<p class="noindent">Because PuzzleScript won’t run if an object doesn’t have a collision layer, we need to put all our newly added objects into the <span class="literal">COLLISIONLAYERS</span> section. We want the robots to bump into walls and to be able to push crates around, so we should make sure the robots, crates, and walls are all on the same collision layer, as shown here:</p>&#13;
<pre><span class="lightgray">================</span>&#13;
<span class="purplebold"><span class="codestrong1">COLLISIONLAYERS</span></span>&#13;
<span class="lightgray">================</span>&#13;
<span class="green">Background</span>&#13;
<span class="green">Wall</span><span class="white">,</span> <span class="green">Vertibot</span><span class="white">,</span> <span class="green">VertibotSleeping</span><span class="white">,</span> <span class="green">Horibot</span><span class="white">,</span> <span class="green">HoribotSleeping</span><span class="white">,</span> <span class="green">Crate</span></pre>&#13;
<p class="indent">Right now, the only object that should be on a separate collision layer is the background, which is on its own line of code. Save your game, and click <strong>Rebuild</strong> to make sure everything in your game works. If it does, a <span class="literal">Successful Compilation</span> message should appear under the game window.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg073-01.jpg"/></p>&#13;
<p class="caption"><em>Successful Compilation message</em></p>&#13;
<p class="indent">If something is wrong with the code, such as if any of the objects are not in the <span class="literal">COLLISIONLAYERS</span> section or if you forgot to add a player to the <span class="literal">LEGEND</span> section, you might see a bright red error message pop up that looks like this.</p>&#13;
<p class="imagel"><span epub:type="pagebreak" id="page_74"/><img alt="image" src="../images/pg074-01.jpg"/></p>&#13;
<p class="caption"><em>Compilation Error message</em></p>&#13;
<p class="indent">We’re done updating the <span class="literal">COLLISIONLAYERS</span> section, so let’s create an action key that allows the player to switch between robots.</p>&#13;
<h4 class="h4" id="ch4.4.3">Writing Rules to Switch Characters</h4>&#13;
<p class="noindent">As mentioned earlier, we can program an action key to do whatever we want it to. Pressing either the X key or spacebar triggers action in PuzzleScript. The player can use whichever one they’re more comfortable with. While the player uses the arrow keys to move around, they can use the action key to jump, pull a switch, put on a hat, or do whatever the rules say happens when the player presses the action key.</p>&#13;
<p class="indent">In our game, the action key will switch between characters by waking up one robot and putting the other to sleep. Keep in mind that the action key won’t do anything until we write rules telling PuzzleScript what it should do. So let’s add the following rules in the <span class="literal">RULES</span> section:</p>&#13;
<pre><span class="lightgray">======</span>&#13;
<span class="purplebold"><span class="codestrong1">RULES</span></span>&#13;
<span class="lightgray">======</span>&#13;
<span class="blueitalic">(switching characters)</span>&#13;
<span class="white">[</span><span class="fuschia">action</span> <span class="green">Horibot</span><span class="white">]</span> <span class="white">[</span> <span class="green">VertibotSleeping</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">HoribotSleeping</span> <span class="white">] [</span> <span class="green">Vertibot</span> <span class="white">]</span>&#13;
<span class="white">[</span><span class="fuschia">action</span> <span class="green">Vertibot</span><span class="white">]</span> <span class="white">[</span> <span class="green">HoribotSleeping</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">VertibotSleeping</span> <span class="white">]</span> <span class="white">[</span> <span class="green">Horibot</span> <span class="white">]</span></pre>&#13;
<p class="indent">PuzzleScript ignores anything in parentheses, so <span class="literal">(switching characters)</span> is just a note to me to help me remember what this part of the code does when I look at it later.</p>&#13;
<p class="indent">The two lines of code below the note check to see when the player presses the action key and then switches each robot to its sleeping and awake state. In PuzzleScript, the action key is based on a condition, just like movement. For example, if <span class="literal">&gt; Horibot</span> represents a moving Horibot, <span class="literal">action Horibot</span> represents a Horibot that’s doing the action.</p>&#13;
<p class="indent">If the awake Horibot has the action condition, it becomes <span class="literal">HoribotSleeping</span>, and <span class="literal">VertibotSleeping</span> becomes <span class="literal">Vertibot</span>, <span epub:type="pagebreak" id="page_75"/>the awake version. And if <span class="literal">Vertibot</span> is the one doing the action, then it goes to sleep and the sleeping Horibot wakes up.</p>&#13;
<p class="indent">Note that because the characters are enclosed in separate square brackets, they don’t need to be next to each other for the switching rule to work. In PuzzleScript rules, we use sets of brackets to group objects together. A series of objects in the same set of brackets, divided by a vertical bar, indicates objects that are next to each other on the level’s grid (for example, <span class="literal">[ Vertibot | HoribotSleeping ]</span>). If we put the two objects together <em>without</em> the vertical bar, it means the two objects are sharing the same space (for example, <span class="literal">[ Vertibot Background ]</span>). We’ll talk more about this format shortly!</p>&#13;
<p class="indent">If we put one object in its own set of brackets and one in another set of brackets, that just means two objects are in two different grid spaces (for example, <span class="literal">[ Vertibot ] [ HoribotSleeping ]</span>). They could be next to each other, or they could be across the level from each other. All PuzzleScript checks for is that they’re on the same level at the same time.</p>&#13;
<p class="indent">But because both characters are listed in each rule, they both need to be in the same level for the switch to work. This automatically means that if only one character is in the level, the program will ignore these rules. That’s perfect if we want to design levels with only one of the characters, like we do in this case!</p>&#13;
<p class="indent">Note that even if the objects are in different places, there need to be as many objects on the left side of the rule as on the right side. If you entered <span class="literal">[ Vertibot ] [ HoribotSleeping ] -&gt; [ VertibotSleeping ]</span>, PuzzleScript would give you an error message. It wouldn’t know what to do with <span class="literal">HoribotSleeping</span>!</p>&#13;
<p class="indent">Let’s take a moment to make sure the rules we wrote are working.</p>&#13;
<h3 class="h3" id="ch4.5">Building a Test Level</h3>&#13;
<p class="noindent">To test our rules, we’ll create a quick test level to make sure everything in the game works so far. Enter this text in the <span class="literal">LEVELS</span> section:</p>&#13;
<pre><span class="lightgray">======</span>&#13;
<span class="purplebold"><span class="codestrong1">LEVELS</span></span>&#13;
<span class="lightgray">======</span>&#13;
<span epub:type="pagebreak" id="page_76"/><span class="lightgray">#########</span>&#13;
<span class="lightgray">#.......#</span>&#13;
<span class="lightgray">#.I...H.#</span>&#13;
<span class="lightgray">#.......#</span>&#13;
<span class="lightgray">#...*...#</span>&#13;
<span class="lightgray">#.......#</span>&#13;
<span class="lightgray">#########</span></pre>&#13;
<p class="indent">This level includes all the objects we’ve added so far. Recall from the legend that the <span class="literal">I</span> and <span class="literal">H</span> are the robots, the <span class="literal">*</span> is a crate, the <span class="literal">#</span> is the wall, and the <span class="literal">.</span> is the background. Click <strong>Save</strong> and then click <strong>Run</strong>. Now when you start the game, you should see something like this.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg076-01.jpg"/></p>&#13;
<p class="caption"><em>Test level</em></p>&#13;
<p class="indent">This level doesn’t look as pretty as it will in the finished game, but for now we just want to make sure the basics work. Try pressing the arrow keys to move the characters around and X or the spacebar to switch between them. Move one character around, switch to the other, move <em>that</em> character around, and then switch back. The robots shouldn’t be able to move through the walls or the crate because they’re on the same collision layer.</p>&#13;
<p class="indent">But we don’t want the crate to simply stop the robots. We want the robots to be able to <em>push</em> the crate around! Let’s add a few rules to make that happen.</p>&#13;
<h3 class="h3" id="ch4.6"><span epub:type="pagebreak" id="page_77"/>Adding Pushing Rules</h3>&#13;
<p class="noindent">Here are some rules that let both robots push crates:</p>&#13;
<pre><span class="blueitalic">(pushing)</span>&#13;
<span class="fuschia">horizontal</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="green">Crate</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Crate</span> <span class="white">]</span>&#13;
<span class="fuschia">vertical</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="green">Crate</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Crate</span> <span class="white">]</span></pre>&#13;
<p class="indent">This rule is similar to the one we saw in the demo game in <a href="ch01.xhtml">Chapter 1</a> except this one includes <span class="literal">horizontal</span> and <span class="literal">vertical</span>. A PuzzleScript rule is applied in four different directions. We can specify which direction to apply a rule by giving PuzzleScript a specific direction, like <span class="literal">left</span> or <span class="literal">right</span> or <span class="literal">down</span>. In this case, <span class="literal">horizontal</span> means left and right, and <span class="literal">vertical</span> means up and down. This rule tells the program that a moving Horibot can only move a crate left and right, and a moving Vertibot can only move a crate up and down.</p>&#13;
<p class="indent">Click <strong>Save</strong> and then click <strong>Rebuild</strong>. Try pushing the crate around. Each robot should be able to push the crate in two directions: left and right horizontally or up and down vertically.</p>&#13;
<h4 class="h4" id="ch4.6.1">Making Groups of Pushable Objects</h4>&#13;
<p class="noindent">Now our robots can push crates, but what if the awake robot could push around the robot that’s asleep? This would create even more chances for teamwork and would cut down on traffic jams. For example, if the sleeping robot is in the way of the awake robot, instead of having to switch to the sleeping robot to move it, the player could just push it out of the way.</p>&#13;
<p class="indent">In the legend, we used a group to tell PuzzleScript that both Vertibot and Horibot count as players. Similarly, we can update the legend to say that crates and sleeping robots count as pushable objects. Note that the pushable group is a group we’re making up. The word “pushable” doesn’t mean anything to PuzzleScript until we tell it what it means. After we define a pushable group, we can write rules telling the robots to push pushables in general instead of just crates.</p>&#13;
<p class="indent">Add this line to the <span class="literal">LEGEND</span> section to tell PuzzleScript that crates and sleeping robots all count as pushables.</p>&#13;
<pre><span class="green">Pushable</span> <span class="white">=</span> <span class="green">Crate</span> <span class="purple">or</span> <span class="green">VertibotSleeping</span> <span class="purple">or</span> <span class="green">HoribotSleeping</span></pre>&#13;
<p class="image"><span epub:type="pagebreak" id="page_78"/><img alt="image" src="../images/pg078-01.jpg"/></p>&#13;
<p class="indent">Now when we write a rule using the word <span class="literal">Pushable</span>, we tell PuzzleScript to check for any of those three objects. Let’s go back and change the pushing rules we wrote earlier so they check for pushables instead of crates. Replace all instances of <span class="literal">Crate</span> with <span class="literal">Pushable</span> so the code looks like this:</p>&#13;
<pre><span class="blueitalic">(pushing)</span>&#13;
<span class="fuschia">horizontal</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="green">Pushable</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">]</span>&#13;
<span class="fuschia">vertical</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="green">Pushable</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">]</span></pre>&#13;
<p class="indent">A robot that is moving toward an object can now push that object if it’s defined as <span class="literal">Pushable</span>, which includes crates and the robot’s sleeping partner. Click <strong>Rebuild</strong> and try it out. Of course, Horibot should only be able to push a sleeping Vertibot horizontally, and Vertibot should only be able to push a sleeping Horibot vertically.</p>&#13;
<h4 class="h4" id="ch4.6.2">Allowing Characters to Push Multiple Objects</h4>&#13;
<p class="noindent">What happens when you try pushing the crate into a sleeping robot or a sleeping robot into the crate? It stops, and you can’t push it any farther. As they are now, the rules only allow a character to push a single <span epub:type="pagebreak" id="page_79"/>pushable at a time. But the ability to push in one direction or the other is each robot’s only superpower. So they should be able to push as many objects as they want, as long as it’s in the right direction.</p>&#13;
<p class="indent">To allow robots to push multiple objects at a time, add this line of code to the <span class="literal">RULES</span> section, under the pushing rules we already have:</p>&#13;
<pre><span class="blueitalic">(pushing)</span>&#13;
<span class="fuschia">horizontal</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="green">Pushable</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Horibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">]</span>&#13;
<span class="fuschia">vertical</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="green">Pushable</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Vertibot</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">|</span> <span class="green">Pushable</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">|</span> <span class="fuschia">&gt;</span> <span class="green">Pushable</span> <span class="white">]</span></pre>&#13;
<p class="indent">Note that this rule isn’t directional because Vertibot and Horibot already have rules telling them which directions they can push. Remember that PuzzleScript runs rules in order from top to bottom, and we want this new rule to happen after pushing starts. The rule checks whether one pushable is being pushed into another, and if it is, the rule tells the second pushable to move in the same direction. And because PuzzleScript can run each rule as many times as possible, if the second pushable is pushed into a third, that third one will also move in the same direction, and so on. Now our robots can push as many objects as they want, as long as there’s room.</p>&#13;
<h3 class="h3" id="ch4.7">Creating Win Conditions</h3>&#13;
<p class="noindent">How does the player win a <em>Robot Heist</em> level and go on to the next one? We can specify this by defining our win condition. In our game, a player satisfies the win condition, or completes a level, when both characters make it to the exit, which is a physical location in the level.</p>&#13;
<p class="indent">To add this condition to <em>Robot Heist</em>, we first need to make a new <span class="literal">Exit</span> object, as shown here.</p>&#13;
<pre><span class="white">Crate</span>&#13;
<span class="white">yellow brown</span>&#13;
<span class="white">00000</span>&#13;
<span class="white">01110</span>&#13;
<span class="white">01110</span>&#13;
<span class="white">01110</span>&#13;
<span epub:type="pagebreak" id="page_80"/><span class="white">00000</span>&#13;
<span class="white">.....</span>&#13;
&#13;
<span class="green">Exit</span>&#13;
<span class="white">white</span> <span class="black">black</span>&#13;
<span class="white">0</span><span class="black">1</span><span class="white">0</span><span class="black">1</span><span class="white">0</span>&#13;
<span class="black">1</span><span class="white">0</span><span class="black">1</span><span class="white">0</span><span class="black">1</span>&#13;
<span class="white">0</span><span class="black">1</span><span class="white">0</span><span class="black">1</span><span class="white">0</span>&#13;
<span class="black">1</span><span class="white">0</span><span class="black">1</span><span class="white">0</span><span class="black">1</span>&#13;
<span class="white">0</span><span class="black">1</span><span class="white">0</span><span class="black">1</span><span class="white">0</span></pre>&#13;
<p class="indent">When the robots are on the exit, the level is finished! I made my exit look like a black-and-white checkered flag.</p>&#13;
<p class="image"><img alt="image" src="../images/pg080-01.jpg"/></p>&#13;
<p class="indent">Add the <span class="literal">Exit</span> object to your <span class="literal">LEGEND</span> section, like this:</p>&#13;
<pre><span class="white">=======</span>&#13;
<span class="white">LEGEND</span>&#13;
<span class="white">=======</span>&#13;
<span class="white">. = Background</span>&#13;
<span class="white"># = Wall</span>&#13;
<span epub:type="pagebreak" id="page_81"/><span class="white">I = Vertibot</span>&#13;
<span class="white">H = HoribotSleeping</span>&#13;
<span class="white">* = Crate</span>&#13;
<span class="green">X</span> <span class="white">=</span> <span class="green">Exit</span>&#13;
<span class="white">Player = Vertibot or Horibot</span>&#13;
<span class="white">Pushable = Crate or VertibotSleeping or HoribotSleeping</span></pre>&#13;
<p class="indent">Of course, I used <span class="literal">X</span> for <span class="literal">Exit</span>.</p>&#13;
<h4 class="h4" id="ch4.7.1">Adding Exit to a Collision Layer</h4>&#13;
<p class="noindent">As with every object we add to a game, we need to assign <span class="literal">Exit</span> to a collision layer. But we’ll put it on a different collision layer than the robots because we want them to be able to stand on top of the exit. You can think of the exit as a checkered pattern painted on the ground at the end of a racetrack. Update the <span class="literal">COLLISIONLAYERS</span> section like this:</p>&#13;
<pre><span class="white">================</span>&#13;
<span class="white">COLLISIONLAYERS</span>&#13;
<span class="white">================</span>&#13;
<span class="white">Background</span>&#13;
<span class="green">Exit</span>&#13;
<span class="white">Wall, Vertibot, VertibotSleeping, Horibot, HoribotSleeping, Crate</span></pre>&#13;
<p class="indent">The placement of <span class="literal">Exit</span> gives it its own layer, which means the other objects won’t be able to collide with it. In fact, the higher up an object is in the <span class="literal">COLLISIONLAYERS</span> section’s list, the farther back it will be drawn in the game. For example, the background layer in the game is all the way in the back. The exit layer is in front of the background layer, and the solid objects (robots and crates) layer is in front of the exit layer.</p>&#13;
<p class="indent">Now we’re ready to write the win condition. It should state that both robots need to be on the <span class="literal">Exit</span> object to win the level. We could try something like this:</p>&#13;
<pre><span class="lightgray">==============</span>&#13;
<span class="purplebold"><span class="codestrong1">WINCONDITIONS</span></span>&#13;
<span class="lightgray">==============</span>&#13;
<span class="purple">all</span> <span class="green">Vertibot</span> <span class="purple">on</span> <span class="green">Exit</span>&#13;
<span class="purple">all</span> <span class="green">HoribotSleeping</span> <span class="purple">on</span> <span class="green">Exit</span></pre><p class="indent"><span epub:type="pagebreak" id="page_82"/>But this condition will work only if Vertibot is awake and Horibot is asleep. What if the opposite is true? Or what if only one of the robots is in the level? We need code that’s a little more versatile.</p>&#13;
<h4 class="h4" id="ch4.7.2">Creating the Buddy Group for the Win Condition</h4>&#13;
<p class="noindent">Fortunately, we can use groups for the win condition too. Just like we made a pushable group to turn crates and sleeping robots into pushable objects, we can make a new group to make robots count as the same thing, whether they’re sleeping or awake. Let’s update the legend by adding the following line:</p>&#13;
<pre><span class="white">Player = Horibot or Vertibot</span>&#13;
<span class="white">Pushable = Crate or HoribotSleeping or VertibotSleeping</span>&#13;
<span class="green">Buddy</span> <span class="white">=</span> <span class="green">Player</span> <span class="purple">or</span> <span class="green">HoribotSleeping</span> <span class="purple">or</span> <span class="green">VertibotSleeping</span></pre>&#13;
<p class="indent">Note that because <span class="literal">Player</span> already includes <span class="literal">Horibot</span> and <span class="literal">Vertibot</span>, we can just use <span class="literal">Player</span> to create a new group called <span class="literal">Buddy</span> that includes both robots. Now, whenever we refer to a <span class="literal">Buddy</span>, we’re referring to any robot in either state, asleep or awake.</p>&#13;
<p class="indent">Let’s update our <span class="literal">WINCONDITIONS</span> section using <span class="literal">Buddy</span>:</p>&#13;
<pre><span class="lightgray">==============</span>&#13;
<span class="purplebold"><span class="codestrong1">WINCONDITIONS</span></span>&#13;
<span class="lightgray">==============</span>&#13;
<span class="purple">all</span> <span class="green">Buddy</span> <span class="purple">on</span> <span class="green">Exit</span></pre>&#13;
<p class="indent">The code <span class="literal">all Buddy</span> refers to all <span class="literal">Buddy</span> objects currently in the level. If there’s only one robot in a level, <span class="literal">all Buddy</span> means just that one robot. If both robots are in the level, <span class="literal">all Buddy</span> means both of them. Because sleeping and awake robots count as <span class="literal">Buddy</span> objects, it doesn’t matter what state they’re in. As long as all the <span class="literal">Buddy</span> objects in the current level are on an <span class="literal">Exit</span> object, the win condition is satisfied.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>One more thing! To make sure that both robots can fit on the exit, each level needs to have at least two <span class="literal">Exit</span> spaces. Add two <span class="literal">Exit</span> spaces to your level, as shown here:</p>&#13;
<pre><span class="lightgray">======</span>&#13;
<span class="purplebold"><span class="codestrong1">LEVELS</span></span>&#13;
<span class="lightgray">======</span>&#13;
<span class="lightgray">#########</span>&#13;
<span class="lightgray">#.......#</span>&#13;
<span class="lightgray">#.I...H.#</span>&#13;
<span class="lightgray">#.......#</span>&#13;
<span class="lightgray">#...*...#</span>&#13;
<span class="lightgray">#X.....X#</span>&#13;
<span class="lightgray">#########</span></pre>&#13;
<p class="indent">You can either add two Xs to your <span class="literal">LEVELS</span> section code, or you could add the <span class="literal">Exit</span> spaces using the level editor (see <a href="ch03.xhtml">Chapter 3</a> to review how to do this). Here’s what the updated level should like:</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg083-01.jpg"/></p>&#13;
<p class="caption"><em>Creating exits for each robot</em></p>&#13;
<p class="indent">Now that we’ve created <span class="literal">Exit</span> objects and defined our win condition, let’s make our game even more fun to play by creating gates that open and close.</p>&#13;
<h3 class="h3" id="ch4.8"><span epub:type="pagebreak" id="page_84"/>Making Gates That Open and Close</h3>&#13;
<p class="noindent">We decided that creating gates that open and close would help foster teamwork between the two robots. Because these gates can open only when a robot is holding them open, one robot must hold the gate open while the other goes through.</p>&#13;
<p class="indent">Gates are a great idea for our game, but how do they actually work? To keep the idea simple, you can think of a gate as a type of wall that can be turned on and off. When it’s on, it’s in the same collision layer as the robots and other solid objects, acting like a wall. But when it’s off, it’s on another collision layer, so the robots can walk over it. In its off state, the gate acts more like a floor.</p>&#13;
<p class="indent">We also need some sort of trigger, or switch, for the gate opening and closing. Have you ever seen a movie where someone steps on a hidden panel in the floor, and then a secret passage opens or a bunch of poison darts fly out of the wall? We’ll use this idea to make our trigger a switch panel that robots can step on to open gates. This is a good solution because it means that other solid objects, like crates and guards, can also activate these switches. When the game finds a solid object on top of a panel, the gates will be in floor mode. If there’s no object on a switch panel, the gates will be in wall mode.</p>&#13;
<p class="image"><img alt="image" src="../images/pg084-01.jpg"/></p>&#13;
<h4 class="h4" id="ch4.8.1"><span epub:type="pagebreak" id="page_85"/>Creating the Gate Objects</h4>&#13;
<p class="noindent">We’ve identified three different objects we need to make our gates work. Similar to how we have two versions of each robot (asleep and awake), we need two versions of our gate: open and closed. We’ll put the closed version on the same collision layer as the robots. The open version will be on a different collision layer. The third object we need is the trigger panel that opens the gates.</p>&#13;
<p class="indent">Let’s start by adding these objects to our game and describing what they look like.</p>&#13;
<pre><span class="green">GateClosed</span>&#13;
<span class="blue">blue</span> <span class="darkblue">darkblue</span>&#13;
<span class="blue">0000</span><span class="darkblue">1</span>&#13;
<span class="blue">0000</span><span class="darkblue">1</span>&#13;
<span class="blue">0000</span><span class="darkblue">1</span>&#13;
<span class="blue">0000</span><span class="darkblue">1</span>&#13;
<span class="darkblue">11111</span>&#13;
&#13;
<span class="green">GateOpen</span>&#13;
<span class="darkblue">darkblue</span> <span class="black">black</span>&#13;
<span class="darkblue">0000</span><span class="black">1</span>&#13;
<span class="darkblue">0000</span><span class="black">1</span>&#13;
<span class="darkblue">0000</span><span class="black">1</span>&#13;
<span class="darkblue">0000</span><span class="black">1</span>&#13;
<span class="black">11111</span>&#13;
&#13;
<span class="green">Panel</span>&#13;
<span class="blue">blue</span>&#13;
<span class="blue">00000</span>&#13;
<span class="blue">0</span><span class="lightgray">...</span><span class="blue">0</span>&#13;
<span class="blue">0</span><span class="lightgray">...</span><span class="blue">0</span>&#13;
<span class="blue">0</span><span class="lightgray">...</span><span class="blue">0</span>&#13;
<span class="blue">00000</span></pre>&#13;
<p class="caption"><em>Creating gates and panel objects</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>When objects work together in some way, like the panel and the gate, it’s a good idea to make them look similar. This helps the player make the connection between the two objects. Here, I made <span class="literal">GateClosed</span> and <span class="literal">Panel</span> in the same color so they match. I also made <span class="literal">GateOpen</span> blue but in a darker shade so it’s similar to the background. This will let the player know they can pass over it.</p>&#13;
<h4 class="h4" id="ch4.8.2">Adding the Gates to the Legend and the Collision Layers</h4>&#13;
<p class="noindent">Now we need to add these objects to the legend so we can use them in the level editor. I chose the letter <em>T</em> (<span class="literal">T</span>) for the gate because it looks kind of like a fence and a forward slash (<span class="literal">/</span>) for the panel because it looks like a lever you might pull.</p>&#13;
<pre><span class="green">T</span> <span class="white">=</span> <span class="green">GateClosed</span>&#13;
<span class="green">/</span> <span class="white">=</span> <span class="green">Panel</span></pre>&#13;
<p class="indent">We don’t need a symbol for an open gate because the gates will start out closed, and we’re only defining the start of each level.</p>&#13;
<p class="indent">Finally, we need to add our new objects to the <span class="literal">COLLISIONLAYERS</span> section. Update the <span class="literal">COLLISIONLAYERS</span> section by adding the highlighted objects, like this:</p>&#13;
<pre><span class="green">Background</span>&#13;
<span class="green">Exit</span><span class="white">,</span> <span class="green">Panel</span><span class="white">,</span> <span class="green">GateOpen</span>&#13;
<span class="green">Wall</span><span class="white">,</span> <span class="green">Vertibot</span><span class="white">,</span> <span class="green">VertibotSleeping</span><span class="white">,</span> <span class="green">Horibot</span><span class="white">,</span> <span class="green">HoribotSleeping</span><span class="white">,</span>&#13;
<span class="green">Crate</span><span class="white">,</span> <span class="green">GateClosed</span></pre>&#13;
<p class="indent">Because we want the robots to be able to step on or walk through the panel and any open gates, they’re in a different layer than the robots. But we want the robots to collide with closed gates, so <span class="literal">GateClosed</span> is in the same layer as the robots. Keep in mind that the closer a collision layer is to the top of the list, the farther back it is. This is why we need to make sure that the objects the robots can step on appear above the robots in code, not below.</p>&#13;
<h4 class="h4" id="ch4.8.3"><span epub:type="pagebreak" id="page_87"/>Writing Rules for Gates</h4>&#13;
<p class="noindent">Now we can write the rules that tell our panels and gates what to do. So how do our gates work?</p>&#13;
<ul>&#13;
<li class="noindent">Solid object on a panel means gates are open</li>&#13;
<li class="noindent">No solid object on any panels means gates are closed</li>&#13;
</ul>&#13;
<p class="indent">Which solid objects can activate a panel? The robots, definitely, and crates, so robots can use them to keep gates open. It’d be fun to have guards operate panels, too. It sounds like we need a new group to contain all the objects that can activate a panel. Let’s define a new group called <span class="literal">Depressor</span> by adding the following to the legend (I’ve called the group “Depressor” because these objects can <em>depress</em> a panel in the floor, not because they’re depressing):</p>&#13;
<pre><span class="green">Depressor</span> <span class="white">=</span> <span class="green">Player</span> <span class="purple">or</span> <span class="green">Pushable</span></pre>&#13;
<p class="indent">Again, I use two groups I’ve already defined to name all the objects I want to include in the <span class="literal">Depressor</span> group. The first is <span class="literal">Player</span>, which includes the awake versions of both robots, and the second is <span class="literal">Pushable</span>, which includes the sleeping versions of both robots, plus crates. This is handy because if I ever introduce another pushable object, I only need to update the <span class="literal">Pushable</span> group. Because the <span class="literal">Pushable</span> group is in the <span class="literal">Depressor</span> group, it will get updated automatically!</p>&#13;
<p class="image"><img alt="image" src="../images/pg087-01.jpg"/></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>Now let’s translate our ideas into rules PuzzleScript can understand by adding the following code:</p>&#13;
<pre><span class="blueitalic">(gates)</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Panel</span> <span class="fuschia">no</span> <span class="green">Depressor</span> <span class="white">] [</span> <span class="green">GateOpen</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Panel</span> <span class="fuschia">no</span>&#13;
<span class="green">Depressor</span> <span class="white">] [</span> <span class="green">GateClosed</span> <span class="white">]</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Panel</span> <span class="green">Depressor</span> <span class="white">] [</span> <span class="green">GateClosed</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Panel Depressor</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="green">GateOpen</span> <span class="white">]</span></pre>&#13;
<p class="indent">The first rule states that when there’s no depressor on a panel, open gates should change to closed gates. The second rule states that when there <em>is</em> a depressor on a panel, closed gates should change to opened gates.</p>&#13;
<p class="indent">Recall how we check for two objects next to each other. For example, in <span class="literal">[ SleepingCat | WakerUpper ]</span> the vertical bar indicates that the two objects are in two different spaces but right next to each other. So if we don’t use a line to separate two objects, that would mean that they’re in the same space. So <span class="literal">[Panel Depressor]</span> means that the space contains a panel and a depressor stepping on that panel. Similarly, <span class="literal">[Panel no Depressor]</span> means that there’s a panel in a space with no depressor on top of it. Naturally, two objects can share the same space only if they’re on different collision layers, which is why we put the panels and the depressors on different collision layers in the previous section.</p>&#13;
<p class="indent">When we put two separate, bracketed items next to each other, like <span class="literal">[Panel Depressor]</span> and <span class="literal">[GateClosed]</span>, it means we’re looking for both states occurring at the same time anywhere in the level but not necessarily next to each other. So <span class="literal">[Panel Depressor] [GateClosed]</span> checks for instances where there’s a depressor on a panel <em>anywhere</em> and a closed gate <em>anywhere</em>. If that condition is met, we transform the closed gate into an open one.</p>&#13;
<p class="indent">The full rule is <span class="literal">late [ Panel Depressor ] [ GateClosed ] -&gt; [ Panel Depressor ] [ GateOpen ]</span>. Notice that on the right side of the arrow, <span class="literal">GateClosed</span> has changed to <span class="literal">GateOpen</span>, but the panel and the depressor haven’t changed. We don’t want them to change, so to indicate that to PuzzleScript, we write them in the same way on both sides of the arrow.</p>&#13;
<p class="indent">Also, notice that both rules are late. You learned in <a href="ch03.xhtml">Chapter 3</a> that late rules happen after movement, not before. Because we want gates to open after a robot has stepped onto a panel, we run this rule late.</p>&#13;
<h4 class="h4" id="ch4.8.4"><span epub:type="pagebreak" id="page_89"/>Testing the Gates</h4>&#13;
<p class="noindent">Let’s build a new test level to make sure our gates and panels work the way we want. I drew a level with both robots, a long gate, a panel, and a crate for the robots to push onto the panel, as shown here:</p>&#13;
<pre><span class="lightgray">###########</span>&#13;
<span class="lightgray">#.......T.#</span>&#13;
<span class="lightgray">#.i.....T.#</span>&#13;
<span class="lightgray">#.......T.#</span>&#13;
<span class="lightgray">#...*...T.#</span>&#13;
<span class="lightgray">#.......T.#</span>&#13;
<span class="lightgray">#.h.../.T.#</span>&#13;
<span class="lightgray">#.......T.#</span>&#13;
<span class="lightgray">###########</span></pre>&#13;
<p class="indent">You can either type this in to the <span class="literal">LEVELS</span> section manually, or you can use the level editor. (Press <strong>E</strong> to switch into editing mode, and then click the <strong>S</strong> button in the corner to see a text version of your level.)</p>&#13;
<p class="indent">Now <em>playtest</em> your level. Playtesting is about trying as many features as possible in the game to make sure they work. Try to do as many actions as you can think of to see how the code handles different scenarios. Imagine you’re a detective, carefully trying to find the hidden bugs. There’s one in the game right now. Can you find it?</p>&#13;
<p class="indent">To find the bug, have one robot stand on the panel and hold the gate open. Next, move the other robot on top of an open gate.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg089-01.jpg"/></p>&#13;
<p class="caption"><em>Holding a gate open</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>Then have both robots stand right on top of the open gate. Finally, switch back to the first robot and have them step off the panel. What happens?</p>&#13;
<p class="indent"><em>Boosh!</em> The robot disappears forever because the closed gate object is on the same collision layer as the character object. Two objects on the same collision layer can’t share the same space, so when the open gate becomes a closed gate, the robot disappears.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg090-01.jpg"/></p>&#13;
<p class="caption"><em>Finding the bug</em></p>&#13;
<p class="indent">To fix this bug, we need to tell PuzzleScript to do something normally <em>except</em> in a specific case. In this case, we want the <span class="literal">GateOpen</span> to become a <span class="literal">GateClosed</span> <em>except</em> when there’s already a depressor on top of it. In other words, when a depressor is on top of an open gate, the gate should not close to prevent the depressor from disappearing.</p>&#13;
<p class="indent">Let’s update our rule with this exception by changing <span class="literal">[ GateOpen ]</span> to <span class="literal">[ GateOpen no Depressor ]</span>, as shown here:</p>&#13;
<pre><span class="blueitalic">(gates)</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Panel</span> <span class="fuschia">no</span> <span class="green">Depressor</span> <span class="white">] [</span> <span class="green">GateOpen</span> <span class="fuschia">no</span> <span class="green">Depressor</span> <span class="white">]</span> <span class="red">-&gt;</span>&#13;
 <span class="white">[</span> <span class="green">Panel</span> <span class="fuschia">no</span> <span class="green">Depressor</span> <span class="white">]</span>&#13;
 <span class="white">[</span> <span class="green">GateClosed</span> <span class="white">]</span></pre>&#13;
<p class="indent">Updating the rule to <span class="literal">[ GateOpen no Depressor ]</span> tells PuzzleScript that if no depressor is on top of a panel, only the open gates without a depressor on them should close, <em>except</em> any that have depressors standing on them. Click <strong>Rebuild</strong> to rerun your game, and try to replicate the bug by trying to do the same action that caused the robot to disappear <span epub:type="pagebreak" id="page_91"/>previously. Now when an object is on top of an open gate, for example, the gate won’t be able to close, even when another object is activating the switch. But when nothing is on top of the open gate, the gate should close.</p>&#13;
<h3 class="h3" id="ch4.9">Adding the Security Lasers</h3>&#13;
<p class="noindent">Now that we’ve created crates and gates, and written rules for how they interact, we’re ready to introduce <em>security lasers</em>, a threat that the robots can avoid using the gates and crates! To do this, we’ll make a laser gun that shoots out lasers at every turn. If a laser hits a robot, the player loses! But if the laser hits another solid object, like a crate or gate, it’ll stop there.</p>&#13;
<h4 class="h4" id="ch4.9.1">Creating the Laser Objects</h4>&#13;
<p class="noindent">Let’s start by drawing our objects. We’ll need three objects:</p>&#13;
<pre><span class="green">Gun</span>&#13;
<span class="gray">grey</span> <span class="darkgray">darkgray</span>&#13;
<span class="lightgray">..</span><span class="gray">0</span><span class="lightgray">..</span>&#13;
<span class="lightgray">.</span><span class="darkgray">1</span><span class="gray">0</span><span class="darkgray">1</span><span class="gray">.</span>&#13;
<span class="gray">00</span><span class="darkgray">1</span><span class="gray">00</span>&#13;
<span class="lightgray">.</span><span class="darkgray">1</span><span class="gray">0</span><span class="darkgray">1</span><span class="lightgray">.</span>&#13;
<span class="lightgray">..</span><span class="gray">0</span><span class="lightgray">..</span>&#13;
&#13;
<span class="green">LaserVertical</span>&#13;
<span class="red">red</span>&#13;
<span class="lightgray">..</span><span class="red">0</span><span class="lightgray">..</span>&#13;
<span class="lightgray">..</span><span class="red">0</span><span class="lightgray">..</span>&#13;
<span class="lightgray">..</span><span class="red">0</span><span class="lightgray">..</span>&#13;
<span class="lightgray">..</span><span class="red">0</span><span class="lightgray">..</span>&#13;
<span class="lightgray">..</span><span class="red">0</span><span class="lightgray">..</span>&#13;
&#13;
<span class="green">LaserHorizontal</span>&#13;
<span class="red">red</span>&#13;
<span class="lightgray">.....</span>&#13;
<span class="lightgray">.....</span>&#13;
<span epub:type="pagebreak" id="page_92"/><span class="red">00000</span>&#13;
<span class="lightgray">.....</span>&#13;
<span class="lightgray">.....</span></pre>&#13;
<p class="indent">The laser gun (<span class="literal">Gun</span>) is shaped like a cross, and the two lasers (<span class="literal">LaserVertical</span> and <span class="literal">LaserHorizontal</span>) are beams of red light. The vertical laser, as you can imagine, fires up and down, and the horizontal laser fires left and right.</p>&#13;
<h4 class="h4" id="ch4.9.2">Adding Lasers to the Legend</h4>&#13;
<p class="noindent">Because we only need to add objects to the legend that will be at the very beginning of the level, we only need to add the guns, which definitely will be at the start of the level. The lasers appear only when the guns fire them, so we don’t need to give them a symbol here. I used a plus sign (<span class="literal">+</span>) to represent the gun because it’s also plus-shaped.</p>&#13;
<pre><span class="green">+</span> <span class="white">=</span> <span class="green">Gun</span></pre>&#13;
<p class="indent">Can you think of any groups we should add to the legend before we start writing our rules? For example, it would be useful to create a group for objects that block the laser, like walls, closed gates, and crates. We’ll group these objects into a new group called <span class="literal">Blocker</span>, as shown here:</p>&#13;
<pre><span class="green">Blocker</span> <span class="white">=</span> <span class="green">Wall</span> <span class="purple">or</span> <span class="green">GateClosed</span> <span class="purple">or</span> <span class="green">Crate</span> <span class="purple">or</span> <span class="green">Gun</span></pre>&#13;
<p class="indent">This line tells PuzzleScript that the <span class="literal">Wall</span>, <span class="literal">GateClosed</span>, and <span class="literal">Crate</span> will all be able to block the lasers. We don’t use the <span class="literal">Pushable</span> group here because it includes Vertibot and Horibot in their sleeping forms, and we want them to trigger an alarm if a laser hits them. Note that we also want the <span class="literal">Gun</span> to be able to block lasers, because we want the lasers to shoot <em>from</em> our guns, not <em>through</em> them.</p>&#13;
<p class="indent">Because we have two different kinds of lasers, let’s add them to the group <span class="literal">Laser</span> to easily refer to both. This should make it easier to check whether something has been hit by a laser. Without this group, we’d have to do two separate checks, one for each kind of laser.</p>&#13;
<pre><span class="green">Laser</span> <span class="white">=</span> <span class="green">LaserVertical</span> <span class="purple">or</span> <span class="green">LaserHorizontal</span></pre>&#13;
<h4 class="h4" id="ch4.9.3"><span epub:type="pagebreak" id="page_93"/>Adding Lasers to the Collision Layers</h4>&#13;
<p class="noindent">Now let’s add our new objects to the <span class="literal">COLLISIONLAYERS</span> section.</p>&#13;
<pre><span class="green">Background</span>&#13;
<span class="green">Exit</span><span class="white">,</span> <span class="green">Panel</span><span class="white">,</span> <span class="green">GateOpen</span>&#13;
<span class="green">LaserVertical</span>&#13;
<span class="green">LaserHorizontal</span>&#13;
<span class="green">Vertibot</span><span class="white">,</span> <span class="green">VertibotSleeping</span><span class="white">,</span> <span class="green">Horibot</span><span class="white">,</span> <span class="green">HoribotSleeping</span><span class="white">,</span> <span class="green">Crate</span><span class="white">,</span>&#13;
<span class="green">Wall</span><span class="white">,</span> <span class="green">GateClosed</span><span class="white">,</span> <span class="green">Gun</span></pre>&#13;
<p class="indent">We place the gun on the same layer as all the other solid objects that the robots can bump into. The different lasers are on different layers because we want the laser beams to be able to pass through the solid objects.</p>&#13;
<p class="indent">Notice that each laser is on its own collision layer. The reason is that if they were on the same layer, the vertical laser beam would be able to block the horizontal laser, and vice versa! In real life, lasers are just beams of light, and one laser can’t block another, or can it? If any scientists are reading this, please let me know!</p>&#13;
<h4 class="h4" id="ch4.9.4">Writing Laser Rules</h4>&#13;
<p class="noindent">The laser objects we made are just a single piece of a laser beam, which is big enough to fit only a single space in a given level. If we put a bunch of them in a row, we’ll have a much longer laser. We want the lasers to keep going until they hit a <span class="literal">Blocker</span>. The following rules make this happen:</p>&#13;
<pre><span class="blueitalic">(lasers)</span>&#13;
<span class="fuschia">horizontal</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">Blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span>&#13;
<span class="fuschia">vertical</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">Blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserVertical</span> <span class="white">]</span></pre>&#13;
<p class="indent">First, we need to make the laser guns fire. A gun fires laser beams in whatever directions aren’t blocked by a blocker. PuzzleScript checks a rule in all four directions (up, down, left, and right) unless you tell it to do otherwise. We don’t want the horizontal lasers to shoot up and down or the vertical lasers to shoot left and right. So we tell PuzzleScript that <span epub:type="pagebreak" id="page_94"/>horizontal lasers fire horizontally and vertical lasers fire vertically using <span class="literal">horizontal</span> and <span class="literal">vertical</span>, respectively.</p>&#13;
<p class="indent">In this case, <span class="literal">horizontal [ Gun | no Blocker ] -&gt; [ Gun | LaserHorizontal ]</span> checks that there’s no blocker next to a gun, and if this is true, the space next to the gun turns into a horizontal laser beam. We use the same idea for the vertical laser beam.</p>&#13;
<h4 class="h4" id="ch4.9.5">Testing the Lasers</h4>&#13;
<p class="noindent">Let’s return to our <span class="literal">LEVELS</span> section to test our laser rules. Add a laser to the test level by updating the code to look like this:</p>&#13;
<pre><span class="lightgray">#############</span>&#13;
<span class="lightgray">#.......T...#</span>&#13;
<span class="lightgray">#.i.....T...#</span>&#13;
<span class="lightgray">#.......T.+.#</span>&#13;
<span class="lightgray">#...*...T...#</span>&#13;
<span class="lightgray">#.......T...#</span>&#13;
<span class="lightgray">#.h.../.T...#</span>&#13;
<span class="lightgray">#.......T...#</span>&#13;
<span class="lightgray">#############</span></pre>&#13;
<p class="indent">I’ve put the laser behind the gate so I can test whether gates block lasers like they’re supposed to. Click <strong>Rebuild</strong> to run the game, and you should see something like this.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg094-01.jpg"/></p>&#13;
<p class="caption"><em>Test level with laser gun</em></p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_95"/><img alt="image" src="../images/pg095-01.jpg"/></p>&#13;
<p class="indent">As you can see, the lasers fire, but the beams extend only a single space in each direction. The laser beams are too short! We need to add a rule that makes the beams extend until they eventually hit a blocker. All the objects in PuzzleScript are the same size. To create a longer laser, we’ll put a bunch of laser objects in a line. We need to add a rule that does that.</p>&#13;
<p class="indent">Again, we’ll create separate rules for vertical and horizontal lasers. If every laser extended in every direction, it would be <em>extremely dangerous</em>, as you can imagine. Instead, we’ll extend horizontal lasers left and right and extend vertical lasers up and down. Add the following lines of code below your existing laser rules:</p>&#13;
<pre><span class="blueitalic">(lasers)</span>&#13;
<span class="green">horizontal</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span>&#13;
<span class="green">vertical</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserVertical</span> <span class="white">]</span>&#13;
<span class="green">vertical</span> <span class="white">[</span> <span class="green">LaserVertical</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">LaserVertical</span> <span class="white">|</span>&#13;
<span class="green">LaserVertical</span> <span class="white">]</span>&#13;
<span class="green">horizontal</span> <span class="white">[</span> <span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span>&#13;
<span class="white">[</span><span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>These additional rules check for empty spaces next to the laser beams. As we did when we checked for a panel with no depressors on it using <span class="literal">[ Panel no Depressor ]</span>, we use <span class="literal">[ LaserVertical | no blocker ]</span> to check for a laser with no blocker objects next to it. If there’s no blocker in the space next to the laser beam, we extend the laser into that space by changing <span class="literal">no blocker</span> to a <span class="literal">LaserVertical</span> or <span class="literal">LaserHorizontal</span>. But if there <em>is</em> a blocker in the space, the rule would stop there.</p>&#13;
<p class="indent">PuzzleScript runs a single rule over and over until it stops before moving on to the next rule. So this rule continues to run for all adjacent spaces in a laser’s path as long as there’s no blocker in those spaces. As a result of this rule, a continuous laser beam shoots out from the gun horizontally and vertically.</p>&#13;
<p class="indent">To test the updated laser rules, click <strong>Rebuild</strong> and check whether the laser beams extend to the wall. Also, try using the panel to open the gate. The laser should extend through the opened gate.</p>&#13;
<h4 class="h4" id="ch4.9.6">Fixing the Laser Bug</h4>&#13;
<p class="noindent">There’s still a problem with the lasers. If you step off the panel, the gate closes and blocks the laser, but the laser beam continues on the other side of the gate.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg096-01.jpg"/></p>&#13;
<p class="caption"><em>Test level showing a laser bug</em></p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_97"/><img alt="image" src="../images/pg097-01.jpg"/></p>&#13;
<p class="indent">The game design process often involves adding some code to your game, checking how it works, making little changes, and then checking it again. Every time we do this, we get a little closer to making our game exactly how we want it. In this case, we need to tweak our laser rules so a closed gate completely blocks a laser beam.</p>&#13;
<p class="indent">To do that, we need to remind ourselves what a single turn in a PuzzleScript game looks like. PuzzleScript runs a turn whenever the player presses a key (either the arrow keys or the action key). This is what happens in a turn:</p>&#13;
<ol>&#13;
<li class="noindent">PuzzleScript marks any player objects that are trying to move (in the rules, this looks like <span class="literal">&gt; Vertibot</span> instead of <span class="literal">Vertibot</span>).</li>&#13;
<li class="noindent">PuzzleScript runs every rule in order from top to bottom as many times as it can.</li>&#13;
<li class="noindent">Anything marked to move moves.</li>&#13;
<li class="noindent">PuzzleScript runs any <em>late</em> moves in order from top to bottom as many times as it can.</li>&#13;
</ol>&#13;
<p class="indent">The problem with our current rules is that we never get rid of lasers after they’re cut off by a blocker object. Let’s add the following rule that does that:</p>&#13;
<pre><span class="blueitalic">(lasers)</span>&#13;
<span class="white">[</span> <span class="green">laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[ ]</span>&#13;
<span class="green">horizontal</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span>&#13;
<span class="green">vertical</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserVertical</span> <span class="white">]</span>&#13;
&#13;
<span epub:type="pagebreak" id="page_98"/><span class="green">vertical</span> <span class="white">[</span> <span class="green">LaserVertical</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">LaserVertical</span> <span class="white">|</span>&#13;
<span class="green">LaserVertical</span> <span class="white">]</span>&#13;
<span class="green">horizonta l</span> <span class="white">[</span> <span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span>&#13;
<span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span></pre>&#13;
<p class="indent">Here, we use the <span class="literal">laser</span> group we defined earlier. This simple addition tells PuzzleScript that any laser beams no longer attached to a gun should disappear. The rule also tells PuzzleScript to change the lasers into empty spaces to get rid of the laser beams after they’ve been blocked by a closed gate. Then PuzzleScript creates new lasers that extend out to erase all the lasers left over from the previous turn. The square brackets represent an empty space, so <span class="literal">[ laser ] -&gt; [ ]</span> tells PuzzleScript to find all the laser objects and get rid of them. Then, we’ll redraw our lasers based on the <em>current</em> layout of the level.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> and run this test again! Try standing on and moving off the panel a few times. We’re a bit closer, but the program is still a little wonky. When the robot steps off the panel, the beams <em>are</em> cut off, but it doesn’t happen until the next turn!</p>&#13;
<p class="image"><img alt="image" src="../images/pg098-01.jpg"/></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Fortunately, there’s an easy solution to fixing this delay. On any given turn, PuzzleScript runs through each rule and then objects move according to the rules. Right now the rules governing our lasers are happening <em>before</em> the robots move on or off of the panel. Let’s make sure those rules happen <em>after</em> movement, which we can accomplish by simply making the laser rules happen <em>late</em>, as shown here:</p>&#13;
<pre><span class="blueitalic">(lasers)</span>&#13;
<span class="white">[</span> <span class="green">laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[ ]</span>&#13;
<span class="fuschia">late</span> <span class="green">horizontal</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span>&#13;
<span class="green">LaserHorizontal</span> <span class="white">]</span>&#13;
<span class="fuschia">late</span> <span class="green">vertical</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Gun</span> <span class="white">|</span> <span class="green">LaserVertical</span> <span class="white">]</span>&#13;
&#13;
<span class="fuschia">late</span> <span class="green">vertical</span> <span class="white">[</span> <span class="green">LaserVertical</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span>&#13;
<span class="green">LaserVertical</span> <span class="white">|</span> <span class="green">LaserVertical</span> <span class="white">]</span>&#13;
<span class="fuschia">late</span> <span class="green">horizontal</span> <span class="white">[</span> <span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="fuschia">no</span> <span class="green">blocker</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span>&#13;
<span class="green">LaserHorizontal</span> <span class="white">|</span> <span class="green">LaserHorizontal</span> <span class="white">]</span></pre>&#13;
<p class="indent">Notice also that the lasers don’t fire immediately. They wait until after you’ve made a move and then fire. To have the lasers begin firing right away, just add <span class="literal">run_rules_on_level_start</span> to the very beginning of your PuzzleScript code, under the name of your game, as shown here:</p>&#13;
<pre><span class="purplebold">title</span> <span class="orangeitalic">Robot Heist</span>&#13;
<span class="purplebold">author</span> <span class="orangeitalic">anna anthropy</span>&#13;
<span class="purplebold">run_rules_on_level_start</span>&#13;
<span class="purplebold">norepeat_action</span></pre>&#13;
<p class="indent">You might have noticed when you hold down the action button to switch characters, the selection flickers back and forth quite quickly. The <span class="literal">norepeat_action</span> command makes sure the action button switches character only once, no matter how long you press it.</p>&#13;
<p class="indent">When you’re done, try the following challenges.</p>&#13;
<h3 class="h3" id="ch4.10"><span epub:type="pagebreak" id="page_100"/>Bonus Challenges</h3>&#13;
<p class="noindent">Try making four different lasers, each of which shoots in only one direction: up, down, left, and right.</p>&#13;
<p class="indent">In the finished <em>Robot Heist</em> game, there are two kinds of gates and panels, pink and blue. There are also some gates that close instead of open when a Depressor steps on a panel. See if you can figure out how to do this in your own game!</p>&#13;
<p class="indent">If you need help, try clicking the <strong>hack</strong> link in <em>Robot Heist</em> (<em><a href="http://tinyurl.com/robotheist/">http://tinyurl.com/robotheist/</a></em>) to see how this code works.</p>&#13;
<h3 class="h3" id="ch4.11">What You Learned</h3>&#13;
<p class="noindent">So far you successfully created the basic building blocks of the <em>Robot Heist</em> game, including the two robot objects the player will use to navigate the level, the background and wall that provide the backdrop, and other objects, such as crates, guns, and panels. You learned to write rules for each of these objects so they interact with one another in interesting ways. You also created obstacles, such as lasers, which some objects can block. But right now, our lasers aren’t a real threat because they don’t do anything.</p>&#13;
<p class="indent">In the next chapter, you’ll explore the concept of <em>losing</em> in game design and learn how to raise the stakes for the player. You’ll also explore PuzzleScript’s “realtime” mode by creating obstacles that move on their own. See you there!</p>&#13;
</body></html>