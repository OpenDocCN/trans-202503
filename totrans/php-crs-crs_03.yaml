- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 DATA TYPES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 种数据类型
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore the data types available in PHP. We’ll also consider
    how to force a value into a specified data type (*type casting*), as well as situations
    where PHP automatically attempts to convert data types to make the various parts
    of expressions work together (*type juggling*).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 PHP 中可用的数据类型。我们还将考虑如何强制将一个值转换为指定的数据类型（*类型转换*），以及 PHP 在何种情况下会自动尝试转换数据类型，以便让表达式的各个部分能够协同工作（*类型自动转换*）。
- en: A *data type* is a categorization of a value in a program that specifies how
    the PHP engine is to interpret that value and therefore which operations can be
    applied to it. For example, if a value is an integer, the PHP engine knows that
    operations such as addition and multiplication are permitted and that the outcomes
    of those operations are themselves integers; meanwhile, the PHP engine knows that
    the outcome of division on an integer might be another integer or a floating-point
    (decimal) number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*是程序中值的分类，用于指定 PHP 引擎如何解释该值，从而确定可以对其应用哪些操作。例如，如果一个值是整数，PHP 引擎知道可以进行加法和乘法等操作，而且这些操作的结果仍然是整数；同时，PHP
    引擎知道，整数除法的结果可能是另一个整数或浮动小数（十进制）数值。'
- en: Understanding which data types are available—and knowing when and how a value’s
    data type can change—is essential as you work with inputs, perform calculations,
    and output data. If you don’t know the type of data you’re manipulating or how
    that data responds to various operations, you might get unexpected results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 了解哪些数据类型可用——以及何时和如何改变一个值的数据类型——在处理输入、执行计算和输出数据时至关重要。如果你不了解正在操作的数据类型，或者不知道这些数据在执行不同操作时如何反应，你可能会得到意外的结果。
- en: '### PHP Data Types'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### PHP 数据类型'
- en: 'In [Chapter 1](chapter1.xhtml), we stored the word "matt" in a variable and
    assigned the number 99 to a constant. These values are of different data types:
    one is a string, and the other an integer. In all, PHP has 10 built-in data types
    divided into three categories, as shown in [Figure 2-1](#fig2-1).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](chapter1.xhtml)中，我们将单词“matt”存储在一个变量中，并将数字 99 赋值给一个常量。这些值属于不同的数据类型：一个是字符串，另一个是整数。总的来说，PHP
    有 10 种内置数据类型，分为三类，如[图 2-1](#fig2-1)所示。
- en: '![](../images/figure2-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure2-1.jpg)'
- en: 'Figure 2-1: PHP data types'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：PHP 数据类型
- en: For now, we’ll mostly focus on the four *scalar* data types, which can hold
    only one value at a time. We’ll also pay some attention to the special NULL data
    type. In later chapters, you’ll learn about two of the *compound* data types,
    array (in [Chapters 8](chapter8.xhtml) and [9](chapter9.xhtml)) and object (in
    [Part V](part5.xhtml)), which can store and manipulate collections of multiple
    values. The resource special type and the callable and iterable compound types
    are used only in complex and special cases and won’t be considered in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们主要关注四种*标量*数据类型，它们一次只能保存一个值。我们还会关注一下特殊的 NULL 数据类型。在后面的章节中，你将学习两种*复合*数据类型——数组（在[第
    8 章](chapter8.xhtml)和[第 9 章](chapter9.xhtml)中）和对象（在[第 V 部分](part5.xhtml)中），它们可以存储和操作多个值的集合。资源特殊类型以及可调用和可迭代的复合类型仅用于复杂和特殊的场景，在本书中不会讨论。
- en: Scalar Data Types
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标量数据类型
- en: The four scalar (single-value) data types are string, int, float, and bool.
    The string type is for text, the int type is for whole numbers (integers), the
    float type is for floating-point (decimal) numbers, and the bool type is for Boolean
    true/false values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 四种标量（单值）数据类型分别是字符串、整数、浮点数和布尔值。字符串类型用于文本，整数类型用于整数，浮点数类型用于浮动小数（十进制）数字，而布尔值类型则用于布尔真/假值。
- en: 'Let’s use PHP’s *interactive mode* to explore the scalar data types. This mode
    allows you to enter individual PHP statements at the command line and immediately
    see the results. We’ll use interactive mode in the coming chapters to quickly
    demonstrate basic concepts and get instant feedback, instead of having to write
    full PHP scripts. Enter php -a at the command line to turn on interactive mode
    and then enter the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PHP 的*交互模式*来探索标量数据类型。该模式允许你在命令行中输入单个 PHP 语句并立即查看结果。我们将在接下来的章节中使用交互模式来快速演示基本概念并获取即时反馈，而不需要编写完整的
    PHP 脚本。只需在命令行中输入 `php -a` 启动交互模式，然后输入以下内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we once again assign the value "matt" to the $username variable. We then
    use PHP’s built-in gettype() function to print out the variable’s type. The output
    confirms that $username contains a string.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次将“matt”赋值给$username变量。然后我们使用PHP内置的gettype()函数打印出变量的类型。输出确认$username包含的是字符串。
- en: If you’ve previously seen or written code in strongly typed languages like Java
    or C#, you may have noticed that you don’t have to specify the data type when
    assigning a value to a variable. PHP is a *loosely typed* language, meaning that
    the same variable can store values of different data types at different times
    and that the PHP engine will automatically infer the data type of an expression.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前看过或者写过像Java或C#这样的强类型语言的代码，你可能已经注意到，在给变量赋值时不需要指定数据类型。PHP是一种*宽松类型*的语言，这意味着相同的变量可以在不同的时间存储不同数据类型的值，而PHP引擎会自动推断表达式的数据类型。
- en: NOTE
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*We can also explicitly declare data types in PHP, something we’ll do starting
    in [Chapter 5](chapter5.xhtml) when we begin writing functions. For now, though,
    as we work with simple variables, we’ll let the interpreter infer data types.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们也可以在PHP中显式声明数据类型，稍后在[第5章](chapter5.xhtml)中，我们将开始编写函数时这样做。不过现在，当我们处理简单的变量时，我们将让解释器推断数据类型。*'
- en: 'In the case of the $username variable, the value "matt" is inferred to be a
    string. We can similarly assign variables numeric values with or without decimals,
    and PHP will interpret them as integers or floats as appropriate:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在$唯一用户名（$username）变量的例子中，值“matt”被推断为字符串。我们可以类似地为变量赋予数字值，无论是否有小数，PHP会根据情况将其解释为整数或浮动数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we see that $age, with its whole-number value, has been interpreted as
    an integer, and $price, whose value includes a decimal, has been interpreted as
    ... a *double*? Although the documentation refers to floating-point values as
    being of the float data type, for historical reasons (PHP is an old language!)
    the function gettype() returns double when used on floats—a reference to the double-precision
    format for storing floating-point values. PHP has only one kind of floating-point
    data type, however, so while other programming languages may have different precision
    and memory representations for floats, doubles, reals, and so on, all floating-point
    values in PHP are of the float data type (no matter what the gettype() function
    says).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到变量$age的值是整数，因此它被解释为一个整数，而$price的值包含小数，所以它被解释为…一个*双精度浮点数*？尽管文档中将浮动值称为float数据类型，但出于历史原因（PHP是一种古老的语言！），当在浮动值上使用gettype()函数时，它返回double——这是指用于存储浮动值的双精度格式。然而，PHP只有一种浮动点数据类型，因此尽管其他编程语言可能对浮动数、双精度数、实数等有不同的精度和内存表示，但在PHP中，所有浮动点值都是float数据类型（无论gettype()函数怎么说）。
- en: 'Let’s try creating a variable of the bool type next. Enter the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试创建一个布尔类型的变量。请输入以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we use gettype() on the $isDutyFree variable, we see boolean displayed.
    This is an alias for bool in PHP; the two are mostly interchangeable, but to avoid
    some cases where aliases don’t work, always write bool in your code (and I’ll
    do so in this book).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在$isDutyFree变量上使用gettype()时，我们看到输出为布尔值。这是PHP中bool类型的别名；两者通常可以互换使用，但为了避免一些别名不起作用的情况，请始终在代码中使用bool（在本书中我也会这样做）。
- en: 'More curiously, notice that when we try to print the value of $isDutyFree,
    we see the number 1 rather than true in the output. This isn’t an error. It’s
    related to the way bool values are converted, or *juggled*, into strings. The
    print command expects a string, so whatever we provide after the keyword print
    is automatically converted into a string expression by the PHP engine. For the
    bool type, true is converted to the string "1", and false is converted to an empty
    string (that is, a string with no content, denoted by a set of quotation marks
    with nothing in between: ""). We’ll discuss conversion to another data type through
    manual casting and automatic type juggling in more detail later in the chapter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，注意当我们尝试打印$isDutyFree的值时，我们在输出中看到的数字是1，而不是true。这并不是错误。这与布尔值如何被转换或*转换成字符串*有关。print命令期望一个字符串，因此无论我们在print关键字后提供什么，PHP引擎都会将其自动转换为字符串表达式。对于布尔类型，true会被转换为字符串“1”，而false会被转换为空字符串（即一个没有内容的字符串，表示为一对空的引号：“”）。我们将在本章稍后讨论通过手动强制转换和自动类型转换进行的类型转换。
- en: 'To see the actual Boolean value of $isDutyFree, use the built-in var_dump()
    function instead of print. This useful function outputs information about a variable.
    It’s helpful when learning PHP and for debugging purposes to know the value of
    a variable at a certain point in the execution of your code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看$ isDutyFree的实际布尔值，请使用内置的var_dump()函数，而不是print。这个有用的函数会输出有关变量的信息。当学习PHP和调试时，知道变量在代码执行的某一时刻的值非常有帮助：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output from var_dump() confirms that the data type of $isDutyFree is bool
    and that its value is true.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: var_dump()的输出确认$ isDutyFree的数据类型是bool，并且其值为true。
- en: The Special NULL Type
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特殊的NULL类型
- en: 'PHP has a special data type represented in code by the constant NULL or null
    (it’s case insensitive). A variable is NULL in three situations. In the first,
    a variable has never been assigned a value, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有一种特殊的数据类型，用常量NULL或null（不区分大小写）表示。在三种情况下，一个变量是NULL。第一种情况是，变量从未被赋值，如此处所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we try var_dump() on $lastName without giving the variable a value, we
    first get a warning that $lastName is undefined. Then we see that the variable,
    not having been given a value, evaluates to NULL.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对$ lastName使用var_dump()而没有为该变量赋值时，首先会收到一个警告，表示$ lastName未定义。然后我们会看到该变量因为没有被赋值而评估为NULL。
- en: 'Second, a variable is NULL if it’s been explicitly assigned the constant NULL
    as its value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果一个变量显式地将常量NULL赋值给它，那么它的值就是NULL：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we see an important difference between a variable never having been given
    a value, as in the previous example, and a variable containing the value NULL.
    In the first case, var_dump() produces a warning, whereas in this case we don’t
    get a warning; we just see the variable’s value (NULL) printed out. Assigning
    a variable the value NULL is fine, just like assigning a variable another value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个重要的区别，即一个变量从未被赋值（如前面示例所示），与一个变量包含NULL值之间的差异。在前一种情况，var_dump()会产生警告，而在这种情况下我们不会收到警告；我们只会看到变量的值（NULL）被打印出来。将NULL赋给一个变量是可以的，就像给变量赋其他值一样。
- en: 'Finally, a variable will be NULL if it has been *unset*, or cleared of its
    value, with the built-in unset() function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一个变量被*unset*，即使用内置的unset()函数清除了其值，那么它将变为NULL：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we give $lastName a value and then use unset() to get rid of that value.
    When we try to use var_dump() on $lastName after unsetting it, we get the same
    warning as before and see that it evaluates to NULL. Unsetting a variable is the
    same as never having given it a value in the first place.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为$ lastName赋一个值，然后使用unset()将其值删除。当我们尝试在unset之后对$ lastName使用var_dump()时，我们会收到与之前相同的警告，并看到它的值为NULL。删除变量就像从未给它赋过值一样。
- en: When working with variables and data items in more complex programs, you’ll
    sometimes need to design logic to handle encounters with NULL. For example, if
    you’re creating a connection to a database but have a problem connecting, the
    connection variable will be set to NULL. In another example, if you expect to
    be passed a reference to an object (such as the logged-in user) but no such object
    exists, then a variable will be NULL. We’ll explore these kinds of situations
    in [Parts V](part5.xhtml) and [VI](part6.xhtml), when we discuss object-oriented
    programming and databases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的程序中处理变量和数据项时，有时需要设计逻辑来处理遇到NULL的情况。例如，如果你在创建数据库连接时遇到问题，连接变量将被设置为NULL。在另一个例子中，如果你期望传递一个对象的引用（例如，已登录的用户），但没有这样的对象存在，那么该变量将为NULL。我们将在[第五部分](part5.xhtml)和[第六部分](part6.xhtml)中讨论面向对象编程和数据库时，探讨这些情况。
- en: Functions to Test for a Data Type
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试数据类型的函数
- en: 'PHP has many functions that produce true or false based on whether the provided
    variable or expression is of a certain data type. These include is_string(), is_int(),
    is_float(), is_bool(), and is_null(). Such functions are useful if you need to
    confirm that a variable is of a particular type before trying to work with it
    or, conversely, if you need to check that a variable isn’t NULL. Here are some
    examples of these functions in action:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有许多函数根据提供的变量或表达式是否属于某种数据类型来返回true或false。这些函数包括is_string()、is_int()、is_float()、is_bool()和is_null()。这些函数非常有用，如果你需要在操作变量之前确认它是某种特定类型，或者反之，你需要检查变量是否不是NULL。以下是这些函数的示例：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our variable $gpa contains a decimal value, so only is_float() is true for it.
    Similarly, $middleName contains NULL, so passing it to is_null() yields true.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量$ gpa包含一个小数值，因此只有is_float()为true。同样，$ middleName包含NULL，因此将其传递给is_null()会返回true。
- en: 'Some of PHP’s type-checking functions are true for broader categories of data
    types. For example, the is_numeric() function is true for variables of type int
    or float:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的一些类型检查函数适用于更广泛的数据类型。例如，is_numeric()函数对int或float类型的变量返回true：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we see both the decimal value 3.5 and the whole-number value 21 pass the
    is_numeric() test. The same function is also true for strings that contain only
    numeric characters, but not if non-numeric characters are mixed in:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到十进制值3.5和整数值21都通过了is_numeric()测试。对于仅包含数字字符的字符串，is_numeric()同样返回true，但如果混入了非数字字符，则返回false：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When $price contains the string "9.99", is_numeric() is true. When we add the
    word *dollars* to the end of the string, however, is_numeric() becomes false.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当$price包含字符串"9.99"时，is_numeric()返回true。然而，当我们在字符串末尾添加*美元*这个词时，is_numeric()变为false。
- en: Type Juggling
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'In some situations, the PHP engine automatically converts a value from one
    data type to another. This is known as *type juggling*. Consider this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，PHP引擎会自动将一个值从一种数据类型转换为另一种数据类型。这被称为*类型转换*。请看这个示例：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we try to add the string "1" and the integer 3. When the PHP engine evaluates
    this expression and stores the result in $answer, it will see the plus-sign operator
    (+) and assume that numeric addition is meant to take place. The PHP engine will
    therefore examine the two operands (the values on either side of the plus sign)
    and try to interpret them as numbers (floats or integers). The 3 is already an
    integer, but the string "1" will be converted (juggled) into an integer to allow
    the addition to take place. In the end, we get the integer 4 as an answer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将字符串"1"和整数3相加。当PHP引擎计算这个表达式并将结果存储到$answer时，它会看到加号运算符（+），并假设进行的是数值加法。因此，PHP引擎会检查这两个操作数（加号两边的值），并尝试将它们解释为数字（浮动数或整数）。3已经是一个整数，但字符串"1"会被转换（转换）成一个整数，以允许加法操作进行。最终，我们得到整数4作为答案。
- en: 'In six kinds of situations, PHP automatically juggles expressions into different
    types: numeric contexts, string contexts, comparative contexts, logic contexts,
    function contexts, and bitwise (integral and string) contexts. We’ll consider
    some of these contexts next.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在六种情况下，PHP会自动将表达式转换为不同的类型：数值上下文、字符串上下文、比较上下文、逻辑上下文、函数上下文和位运算（整数和字符串）上下文。接下来我们将讨论其中的一些上下文。
- en: '#### Numeric Contexts'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 数值上下文'
- en: When an expression includes an arithmetic operator, PHP will try to juggle the
    operands to integers or floats. This often happens when one or more of the operands
    are strings, as in the "1" + 3 example we just looked at. We’ll see an example
    of this in action when function parameters are coerced into integers in [Chapter
    5](chapter5.xhtml). Boolean values can also be juggled into integers; true becomes
    the integer 1, and false becomes the integer 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含算术运算符时，PHP会尝试将操作数转换为整数或浮动数。这通常发生在一个或多个操作数是字符串的情况下，正如我们刚才看到的"1" + 3示例。我们将在[第5章](chapter5.xhtml)中看到一个示例，说明函数参数如何被强制转换为整数。布尔值也可以转换为整数；true变为整数1，false变为整数0。
- en: 'Two important questions arise when juggling in numeric contexts: Will the result
    become an int or a float, and what happens when a string includes both numeric
    and non-numeric characters?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值上下文中，有两个重要的问题：结果会变成整数（int）还是浮动数（float），当字符串同时包含数字和非数字字符时会发生什么？
- en: Integer vs. Float
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数与浮动数
- en: 'If either operand in an arithmetic expression is a float (or isn’t interpretable
    as an integer), both values will be juggled into floats, and a float operation
    is performed. Otherwise, both values will be juggled into integers, and an integer
    operation is performed. For example, when both operands are integers, the result
    is an integer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算术表达式中的任一操作数是浮动数（或不能解释为整数），则两个值都会被转换为浮动数，并执行浮动数运算。否则，两个值都会被转换为整数，并执行整数运算。例如，当两个操作数都是整数时，结果是整数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When one operand is an integer, and the other is a numeric string that evaluates
    to an integer, both operators become integers. The result is also an integer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作数是整数，另一个操作数是能转换为整数的数值字符串时，两个操作数都会变成整数，结果也是整数：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Leading and trailing whitespace is ignored when strings are juggled into numbers,
    so we’ll get the same result if we add spaces at either end of the string:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串转换为数字时，会忽略前导和尾随的空白字符，因此如果我们在字符串的两端添加空格，仍然会得到相同的结果：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the extra spaces in the string before and after the 1 character
    make no difference. The string is still juggled to the integer 1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串中“1”字符前后多余的空格没有影响，字符串仍然会转换为整数1。
- en: 'When both operands are numbers and one of the operands is a float, both operands
    become floats. The result is also a float:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个操作数都是数字且其中一个操作数是浮动数时，两个操作数都会转换为浮动数，结果也是浮动数：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To arrive at this result of 2.5, the integer 1 is juggled to a float behind
    the scenes, before the addition operation is performed. The same process occurs
    when one operand is an integer and the other is a numeric string that evaluates
    to a float. Both operands become floats, and the result is a float:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到2.5的结果，整数1会在幕后被转换为浮动数，然后才进行加法运算。当一个操作数是整数，另一个是可评估为浮动数的数字字符串时，也会发生相同的过程。两个操作数都会转换为浮动数，结果是浮动数：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In short, if float arithmetic is needed, PHP uses float arithmetic. Otherwise,
    it uses integer arithmetic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果需要浮动数运算，PHP会使用浮动数运算。否则，使用整数运算。
- en: Numeric, Leading Numeric, and Non-numeric Strings
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数字、前导数字和非数字字符串
- en: PHP differentiates between *numeric strings*, whose entire contents evaluate
    to an integer or a float, and *leading numeric strings*, which begin with numeric
    characters but also include non-numeric characters such as letters or special
    symbols. When a leading numeric string is juggled to an integer or float, everything
    from the first non-numeric character on is dropped. If a string *starts* with
    a non-numeric character, however, the entire string is considered *non-numeric*,
    even if it also contains numbers, and it can’t be juggled to a number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PHP区分*数字字符串*（其内容完全评估为整数或浮动数）和*前导数字字符串*（以数字字符开头，但也包括非数字字符，如字母或特殊符号）。当前导数字字符串被转换为整数或浮动数时，从第一个非数字字符开始的部分会被丢弃。如果一个字符串*以非数字字符*开头，那么整个字符串被视为*非数字*，即使它也包含数字，也无法转换为数字。
- en: NOTE
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The exception to this rule about non-numeric characters at the start of a
    string is the special case of a string beginning with spaces, followed by numeric
    characters. Such a string will be treated as a numeric string, since leading (or
    trailing) spaces are ignored.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于字符串以非数字字符开头的规则的例外是以空格开头并后跟数字字符的特殊情况。这样的字符串会被视为数字字符串，因为前导（或尾随）空格会被忽略。*'
- en: 'Let’s try numeric addition with a leading numeric string that evaluates to
    an integer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个前导数字字符串进行数字加法，该字符串评估为整数：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here "1 dollar" is a leading numeric string. When used in an arithmetic expression,
    the "1" at the beginning is juggled to an integer, while the " dollar" at the
    end is ignored. Notice that PHP raises a warning about this but goes ahead with
    the type conversion anyway. Since both operands can be juggled into integers,
    the result is an integer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里“1 dollar”是一个前导数字字符串。当用于算术表达式时，开头的“1”会转换为整数，而结尾的“ dollar”会被忽略。请注意，PHP会对此发出警告，但仍然进行类型转换。由于两个操作数都可以转换为整数，结果是整数。
- en: 'Addition with a leading numeric string that evaluates to a float works the
    same way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 带有前导数字字符串的加法（该字符串可评估为浮动数）也以相同的方式工作：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, "9.99 dollars" is a leading numeric string whose beginning evaluates
    to the float 9.99. Since both operands can be juggled into floats, the result
    is a float. Again, PHP raises a warning because of the leading numeric string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“9.99 dollars”是一个前导数字字符串，其开头评估为浮动数9.99。由于两个操作数都可以转换为浮动数，因此结果是浮动数。同样，由于前导数字字符串，PHP会发出警告。
- en: 'By contrast, if you try to use a non-numeric string in an arithmetic expression,
    you’ll get a TypeError, meaning the operation can’t be performed with the given
    data types. This halts the execution of the code. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你尝试在算术表达式中使用非数字字符串，将会得到一个类型错误，意味着无法使用给定的数据类型执行操作。这会中断代码的执行。下面是一个示例：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here "April 1" is a non-numeric string because it starts with letters, not
    numbers. The string can’t be evaluated as a number, so it triggers an error. The
    same error happens if we use an empty string (""):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里“April 1”是一个非数字字符串，因为它以字母开头，而不是数字。该字符串无法评估为数字，因此会触发错误。如果我们使用空字符串（""）也会发生相同的错误：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An empty string does *not* evaluate to 0 as it does in some other languages.
    It’s a non-numeric string, so it leads to a TypeError in arithmetic expressions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串*不*像其他一些语言那样评估为0。它是一个非数字字符串，因此在算术表达式中会导致类型错误。
- en: String Contexts
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串上下文
- en: In a few cases, PHP automatically juggles values into strings. First, expressions
    involving print or echo statements are juggled to strings, since these commands
    expect anything that follows to be a string. You’ve already seen, for example,
    that values of type bool are juggled to the string "1" (for true) or "" (for false)
    when they’re part of a print statement. Similarly, numbers are juggled to their
    string equivalents.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，PHP 会自动将值转换为字符串。首先，涉及打印或回显语句的表达式会被转换为字符串，因为这些命令期望后续的内容是字符串。例如，您已经看到，当布尔类型的值作为打印语句的一部分时，它们会被转换为字符串
    "1"（表示 true）或 ""（表示 false）。类似地，数字也会转换为其字符串等价物。
- en: Second, expressions involving the string concatenation operator (.) are also
    juggled to strings, as are expressions whose values are being parsed inside strings.
    We’ll discuss these topics in [Chapter 3](chapter3.xhtml).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，涉及字符串连接运算符（.）的表达式也会被转换为字符串，就像在字符串内部解析的表达式一样。我们将在[第 3 章](chapter3.xhtml)中讨论这些主题。
- en: Comparative Contexts
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较上下文
- en: Type juggling also occurs when comparing two values of different data types.
    Comparative expressions evaluate to a Boolean true or false, which you then typically
    use for decision-making logic (as we’ll discuss in [Chapter 4](chapter4.xhtml)).
    The PHP engine knows an expression is comparative when it sees a *comparison operator*,
    such as == for *equal* or > for *greater than*. PHP has rules that determine how
    these expressions are juggled and evaluated, depending on the data types involved.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换还会发生在比较两种不同数据类型的值时。比较表达式会评估为布尔值 true 或 false，通常您将其用于决策逻辑（如我们将在[第 4 章](chapter4.xhtml)中讨论的）。当
    PHP 引擎看到一个*比较运算符*，例如 ==（表示*等于*）或 >（表示*大于*）时，它会知道这是一个比较表达式。PHP 有规则来确定这些表达式如何根据涉及的数据类型进行转换和评估。
- en: Identical vs. Equal Values
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 相同值与相等值
- en: PHP makes an important distinction between values that are identical and values
    that are equal. Two expressions are considered *identical* only if (*before* any
    type juggling) they’re of the same data type and contain the same value. By contrast,
    two expressions are considered *equal* if they contain the same value *after*
    type juggling.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 在相同值和相等值之间做出了重要区分。只有当两个表达式在*类型转换之前*是相同的数据类型并且包含相同的值时，它们才被视为*相同*。相比之下，两个表达式如果在*类型转换之后*包含相同的值，则被视为*相等*。
- en: 'We use different operators to test for identity and equality. The triple equal
    sign (===) is the *identical operator*, while the double equal sign (==) is the
    *equal operator*. Consider these examples comparing the string "1" and the integer
    1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的运算符来测试身份和相等性。三重等号 (===) 是 *相同运算符*，而双等号 (==) 是 *等于运算符*。考虑以下比较字符串 "1" 和整数
    1 的示例：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we try the comparison with the identical operator. This evaluates to
    false, since the operands are of different data types. Next, we try the comparison
    with the equal operator. This time it evaluates to true, since PHP juggles the
    string "1" into an integer before making the comparison.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试使用相同运算符进行比较。由于操作数的数据类型不同，因此评估结果为 false。接下来，我们尝试使用等于运算符进行比较。这一次，结果为 true，因为
    PHP 会在进行比较之前将字符串 "1" 转换为整数。
- en: 'PHP also has operators for not-identical (!==) and not-equal (!=). Consider
    these comparisons between an integer and a float:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 还有用于“不相同” (!==) 和“不等于” (!=) 的运算符。考虑这些整数和浮点数之间的比较：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the not-identical operator, the comparison is true, since the values are
    of different data types. Using the not-equal operator, the numbers are first juggled
    to the same type. This gives them the same value, so the not-equal comparison
    is false.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不相同运算符时，比较结果为 true，因为值的类型不同。使用不等于运算符时，数字首先被转换为相同类型。这样它们就具有相同的值，因此不等于比较结果为
    false。
- en: NOTE
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The PHP* <> *operator is equivalent to the* != *operator; both mean “not equal.”
    Personally, I always use the* != *operator, since an exclamation mark (*!*) by
    itself means “not” in other contexts too.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP* <> *运算符等价于* != *运算符；两者都表示“不同”。就个人而言，我总是使用* != *运算符，因为感叹号（*!*）在其他上下文中也表示“不是”。*'
- en: Strings vs. Numbers
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串与数字
- en: 'Since PHP 8.0, when comparing a string with a number, a numeric comparison
    is made if the string is a numeric string. Otherwise, a string comparison is made.
    We saw a numeric comparison when we tested the equality of the integer 1 and the
    numeric string "1". If we try the same comparison with a leading numeric string,
    the result will be false:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 8.0起，当将字符串与数字进行比较时，如果该字符串是数字字符串，则进行数字比较。否则，进行字符串比较。我们在测试整数1和数字字符串"1"的相等性时看到过数字比较。如果我们尝试使用一个以数字开头的字符串进行相同的比较，结果将为假：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Though "1 dollar" starts with a number, it isn’t a fully numeric string. As
    such, PHP juggles the integer 1 to the string "1" and makes a string comparison.
    The strings aren’t equal, so we get false.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管"1 dollar"以数字开始，但它不是一个完全的数字字符串。因此，PHP将整数1转换为字符串"1"并进行字符串比较。这两个字符串不相等，因此结果为假。
- en: 'Two important implications of using only numeric comparisons for fully numeric
    strings are that any leading or trailing spaces are ignored and that an empty
    string is *not* considered a numeric string and so is not equal to a numeric 0,
    as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用数字比较完全数字字符串有两个重要的影响，即任何前导或尾部的空格会被忽略，并且空字符串*不*被认为是数字字符串，因此它不等于数字0，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this comparison, since the empty string isn’t numeric, the integer 0 is juggled
    into the string "0". Then strings "0" and "" are compared and found to be not
    equal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个比较中，由于空字符串不是数字，整数0被转换成字符串"0"。然后，字符串"0"和""被比较并发现它们不相等。
- en: Less Than and Greater Than
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小于和大于
- en: 'When working with numbers, using the less-than (<), greater-than (>), less-than-or-equal-to
    (<=), or greater-than-or-equal-to (>=) operators is straightforward, since it’s
    very clear whether one number is less than, equal to, or greater than another.
    Here are some examples:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数字时，使用小于(<)、大于(>)、小于或等于(<=)或大于或等于(>=)运算符是直接的，因为是否一个数字小于、等于或大于另一个数字非常清晰。以下是一些例子：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use these operators with non-numeric data types, in which case
    PHP has a variety of rules for evaluating the comparisons. For example, the Boolean
    true is considered greater than false and also greater than NULL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这些运算符用于非数字数据类型，在这种情况下，PHP有多种规则来评估比较。例如，布尔值true被认为大于false，也大于NULL：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Strings are compared with each other one character at a time, with later letters
    in the alphabet considered greater than earlier letters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串之间是逐个字符进行比较的，字母表中后面的字母被认为大于前面的字母：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lowercase letters are considered greater than capital letters, however:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母被认为大于大写字母，但是：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Strings are typically considered greater than any number, as in these cases:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通常被认为大于任何数字，如以下情况所示：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Exceptions to such general rules of thumb exist, however. As we’ve already
    discussed, when a fully numeric string is compared to a number, the string is
    first juggled to a number and then a numeric comparison is made. Here, for example,
    the string "15" becomes the integer 15 for the purposes of comparison:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一些对这些通用规则的例外。如我们之前讨论过的，当完全数字的字符串与数字进行比较时，字符串会先转换为数字，然后进行数字比较。例如，字符串"15"会变为整数15用于比较：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another exception is strings beginning with a special character such as these:
    ! # $ % & '' () * + , - . /. Such a string is always considered less than a number:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个例外是以特殊字符开头的字符串，如：! # $ % & '' () * + , - . /。这种字符串总是被认为小于数字：'
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If a number is compared with a leading numeric string (one that starts with
    numbers but contains other characters), the number is juggled to a string, and
    the strings are compared character by character:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字与一个以数字开头但包含其他字符的字符串进行比较，数字会被转换为字符串，字符串逐字符比较：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first case, the integer 10 is converted to the string "10" before comparison
    with the string "1a". The first characters are the same, but the character a (a
    letter) is considered greater than the character 0 (a number). In the second case,
    the 2 in the string "20" (after juggling) is considered greater than the 1 in
    the string "1a", so the expression is false.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，整数10在与字符串"1a"比较之前被转换为字符串"10"。第一个字符相同，但字符a（字母）被认为大于字符0（数字）。在第二个例子中，字符串"20"中的数字2（经过转换）被认为大于字符串"1a"中的数字1，因此该表达式为假。
- en: Knowing these string-number and Boolean comparison rules is useful, but relying
    on them can be dangerous. It’s safer to use validation logic to convert strings
    to numbers first and then make simple numeric comparisons. For example, we’ll
    test that the price received from a web form is numeric in [Chapter 12](chapter12.xhtml).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些字符串-数字和布尔比较规则是有用的，但依赖它们可能是危险的。最好使用验证逻辑先将字符串转换为数字，然后进行简单的数字比较。例如，我们将在[第12章](chapter12.xhtml)中测试从网页表单接收的价格是否为数字。
- en: The Spaceship Operator
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 飞船操作符
- en: 'A relatively new addition to the PHP language is the *spaceship operator* (<=>).
    Instead of true or false, this operator gives an integer value of 0, 1, or -1
    depending on the two expressions being compared. If both expressions are the same
    (after any type juggling), the operator gives a 0; if the first expression is
    greater than the second, it gives a 1; or if the second expression is greater
    than the first, it gives a -1. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PHP语言中相对较新的一个特性是*飞船操作符*（<=>）。与 true 或 false 不同，使用该操作符时，根据比较的两个表达式，会返回0、1或-1的整数值。如果两个表达式相同（经过任何类型转换后），该操作符返回0；如果第一个表达式大于第二个，返回1；如果第二个表达式大于第一个，返回-1。例如：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first case, we see -1 as the output, since 11 is less than 22. In the
    second case, we see 1 as the output, since 55 is greater than 22. In the last
    case, we see 0 as the output, since "22" is the same as 22 after type juggling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例中，我们看到输出是-1，因为11小于22。在第二个案例中，我们看到输出是1，因为55大于22。在最后一个案例中，我们看到输出是0，因为"22"和22经过类型转换后是相同的。
- en: The spaceship operator may seem like a strange amalgam of the less-than, greater-than,
    and equal-to operators. However, it’s particularly useful when sorting collections
    of data into a desired sequence, since certain sorting functions require exactly
    this 0, 1, or -1 encoding scheme.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船操作符可能看起来像是小于、大于和等于操作符的奇怪结合。然而，它在将数据集合排序为所需的顺序时特别有用，因为某些排序函数需要这种0、1或-1的编码方案。
- en: Logical and Other Contexts
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑和其他上下文
- en: 'When a logical value of true or false is expected, PHP will juggle values of
    other types to the bool type. The three logical type-juggling contexts are as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当期望逻辑值为真或假时，PHP将把其他类型的值转换为布尔类型。这三种逻辑类型转换上下文如下：
- en: Logical operators, such as AND (&&) and OR (||)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑操作符，如 AND (&&) 和 OR (||)
- en: The ternary operator (?)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元操作符（?）
- en: Conditional statements such as if and switch
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句，如 if 和 switch
- en: We’ll cover all of these logic contexts in [Chapter 4](chapter4.xhtml).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](chapter4.xhtml)中讲解所有这些逻辑上下文。
- en: Type juggling also may occur in function contexts and bitwise contexts. We’ll
    explore the function context (when arguments are evaluated against function signatures)
    in [Chapter 5](chapter5.xhtml). The bitwise context is rarely used in web applications
    and is beyond the scope of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换也可能发生在函数上下文和位运算上下文中。我们将在[第5章](chapter5.xhtml)探讨函数上下文（即在函数签名中评估参数）。位运算上下文在网页应用中很少使用，超出了本书的范围。
- en: Type Casting
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: '*Type casting* refers to explicitly converting an expression or variable to
    a desired data type. Manual type casting stands in contrast to the type juggling
    performed automatically by the PHP engine. To cast the value of an expression
    to a particular type, provide the new data type in parentheses before the expression.
    For instance, (float)21 ensures that the value 21 will be treated as a float instead
    of an integer. Here are some examples of casting various scalar data types:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是指显式地将一个表达式或变量转换为所需的数据类型。手动类型转换与PHP引擎自动执行的类型转换相对立。要将表达式的值转换为特定类型，只需在表达式前加上括号并指定新数据类型。例如，(float)21确保值21被处理为浮动数，而不是整数。以下是转换各种标量数据类型的示例：'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that casting from a float to an integer truncates anything after the
    decimal point, effectively rounding down to the nearest whole number ❶. When casting
    from a number to a Boolean, 0 becomes false ❷, while any other numeric value (including
    negative numbers!) becomes true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从浮动数转换为整数时，会截断小数点后的所有内容，实际上是向下舍入到最接近的整数 ❶。当从数字转换为布尔值时，0变为 false ❷，而任何其他数字值（包括负数！）都变为
    true。
- en: Type casting is one of the lesser-used features of PHP. One example of its use
    could be to easily obtain the integer part of a float, such as the whole number
    of seconds when comparing two timestamps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是PHP中较少使用的特性之一。它的一个使用示例是轻松获取浮动数的整数部分，例如在比较两个时间戳时，获取秒数的整数部分。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced you to PHP’s four scalar data types, as well as the
    special NULL type. You saw the difference between variables containing NULL and
    variables evaluating to NULL by virtue of being undefined or unset, and you practiced
    testing whether a variable is of a particular type by using functions like is_int()
    and is_null(). Later, this will help you write code that carefully tests values
    to manage situations that may occur when receiving input from users or external
    data sources such as databases.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了PHP的四种标量数据类型，以及特殊的NULL类型。你了解了包含NULL的变量与因未定义或未设置而评估为NULL的变量之间的区别，并且通过使用像is_int()和is_null()这样的函数，练习了测试变量是否为特定类型。稍后，这将帮助你编写代码，仔细测试值以应对从用户或外部数据源（如数据库）接收输入时可能出现的情况。
- en: This chapter also showed you how an expression’s data type can change, either
    automatically through juggling or manually through casting. You learned about
    the contexts where type juggling can occur and rules for evaluating expressions
    with different data types. Understanding when and how types are juggled will help
    you avoid unexpected results when working with data of mixed types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向你展示了表达式的数据类型如何变化，可以通过类型转换自动或手动地进行。你学习了类型转换可能发生的上下文，以及评估不同数据类型的表达式的规则。理解何时以及如何进行类型转换将帮助你避免在处理混合类型数据时出现意外的结果。
- en: Exercises
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Write a script to use integer casting to round down a float. Do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   编写一个脚本，使用整数转换将浮动数字向下取整。执行以下操作：
- en: a.   Create a $scoreFloat variable containing 55.9.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: a.   创建一个包含55.9的$scoreFloat变量。
- en: b.   Create a second variable, $scoreInt, containing the value of $scoreFloat
    cast into an integer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: b.   创建第二个变量$scoreInt，将$scoreFloat转换为整数并赋值给它。
- en: c.   Print out the type of $scoreFloat, then its value, then a newline character.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: c.   打印出$scoreFloat的类型，然后是它的值，再输出一个换行符。
- en: d.   Print out the type of $scoreInt, then its value, then a newline character.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: d.   打印出$scoreInt的类型，然后是它的值，再输出一个换行符。
- en: 'Your program output should look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序输出应如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 2.   Assign the $age variable the integer 21, and var_dump its value. Then assign
    NULL to this variable, and var_dump it again. Finally, unset the variable and
    var_dump it once more. Note that the output differs when the variable is assigned
    NULL and when it’s unset.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将$age变量赋值为整数21，并使用`var_dump`输出其值。然后将该变量赋值为NULL，再次使用`var_dump`输出。最后，使用`unset`删除该变量，再次使用`var_dump`输出。请注意，当变量赋值为NULL与被unset时，输出结果是不同的。
