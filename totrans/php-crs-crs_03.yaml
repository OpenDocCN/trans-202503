- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 DATA TYPES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 种数据类型
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore the data types available in PHP. We’ll also consider
    how to force a value into a specified data type (*type casting*), as well as situations
    where PHP automatically attempts to convert data types to make the various parts
    of expressions work together (*type juggling*).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 PHP 中可用的数据类型。我们还将考虑如何强制将一个值转换为指定的数据类型（*类型转换*），以及 PHP 在何种情况下会自动尝试转换数据类型，以便让表达式的各个部分能够协同工作（*类型自动转换*）。
- en: A *data type* is a categorization of a value in a program that specifies how
    the PHP engine is to interpret that value and therefore which operations can be
    applied to it. For example, if a value is an integer, the PHP engine knows that
    operations such as addition and multiplication are permitted and that the outcomes
    of those operations are themselves integers; meanwhile, the PHP engine knows that
    the outcome of division on an integer might be another integer or a floating-point
    (decimal) number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*是程序中值的分类，用于指定 PHP 引擎如何解释该值，从而确定可以对其应用哪些操作。例如，如果一个值是整数，PHP 引擎知道可以进行加法和乘法等操作，而且这些操作的结果仍然是整数；同时，PHP
    引擎知道，整数除法的结果可能是另一个整数或浮动小数（十进制）数值。'
- en: Understanding which data types are available—and knowing when and how a value’s
    data type can change—is essential as you work with inputs, perform calculations,
    and output data. If you don’t know the type of data you’re manipulating or how
    that data responds to various operations, you might get unexpected results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 了解哪些数据类型可用——以及何时和如何改变一个值的数据类型——在处理输入、执行计算和输出数据时至关重要。如果你不了解正在操作的数据类型，或者不知道这些数据在执行不同操作时如何反应，你可能会得到意外的结果。
- en: '### PHP Data Types'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### PHP 数据类型'
- en: 'In [Chapter 1](chapter1.xhtml), we stored the word "matt" in a variable and
    assigned the number 99 to a constant. These values are of different data types:
    one is a string, and the other an integer. In all, PHP has 10 built-in data types
    divided into three categories, as shown in [Figure 2-1](#fig2-1).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](chapter1.xhtml)中，我们将单词“matt”存储在一个变量中，并将数字 99 赋值给一个常量。这些值属于不同的数据类型：一个是字符串，另一个是整数。总的来说，PHP
    有 10 种内置数据类型，分为三类，如[图 2-1](#fig2-1)所示。
- en: '![](../images/figure2-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure2-1.jpg)'
- en: 'Figure 2-1: PHP data types'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：PHP 数据类型
- en: For now, we’ll mostly focus on the four *scalar* data types, which can hold
    only one value at a time. We’ll also pay some attention to the special NULL data
    type. In later chapters, you’ll learn about two of the *compound* data types,
    array (in [Chapters 8](chapter8.xhtml) and [9](chapter9.xhtml)) and object (in
    [Part V](part5.xhtml)), which can store and manipulate collections of multiple
    values. The resource special type and the callable and iterable compound types
    are used only in complex and special cases and won’t be considered in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们主要关注四种*标量*数据类型，它们一次只能保存一个值。我们还会关注一下特殊的 NULL 数据类型。在后面的章节中，你将学习两种*复合*数据类型——数组（在[第
    8 章](chapter8.xhtml)和[第 9 章](chapter9.xhtml)中）和对象（在[第 V 部分](part5.xhtml)中），它们可以存储和操作多个值的集合。资源特殊类型以及可调用和可迭代的复合类型仅用于复杂和特殊的场景，在本书中不会讨论。
- en: Scalar Data Types
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标量数据类型
- en: The four scalar (single-value) data types are string, int, float, and bool.
    The string type is for text, the int type is for whole numbers (integers), the
    float type is for floating-point (decimal) numbers, and the bool type is for Boolean
    true/false values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 四种标量（单值）数据类型分别是字符串、整数、浮点数和布尔值。字符串类型用于文本，整数类型用于整数，浮点数类型用于浮动小数（十进制）数字，而布尔值类型则用于布尔真/假值。
- en: 'Let’s use PHP’s *interactive mode* to explore the scalar data types. This mode
    allows you to enter individual PHP statements at the command line and immediately
    see the results. We’ll use interactive mode in the coming chapters to quickly
    demonstrate basic concepts and get instant feedback, instead of having to write
    full PHP scripts. Enter php -a at the command line to turn on interactive mode
    and then enter the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PHP 的*交互模式*来探索标量数据类型。该模式允许你在命令行中输入单个 PHP 语句并立即查看结果。我们将在接下来的章节中使用交互模式来快速演示基本概念并获取即时反馈，而不需要编写完整的
    PHP 脚本。只需在命令行中输入 `php -a` 启动交互模式，然后输入以下内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we once again assign the value "matt" to the $username variable. We then
    use PHP’s built-in gettype() function to print out the variable’s type. The output
    confirms that $username contains a string.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve previously seen or written code in strongly typed languages like Java
    or C#, you may have noticed that you don’t have to specify the data type when
    assigning a value to a variable. PHP is a *loosely typed* language, meaning that
    the same variable can store values of different data types at different times
    and that the PHP engine will automatically infer the data type of an expression.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We can also explicitly declare data types in PHP, something we’ll do starting
    in [Chapter 5](chapter5.xhtml) when we begin writing functions. For now, though,
    as we work with simple variables, we’ll let the interpreter infer data types.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the $username variable, the value "matt" is inferred to be a
    string. We can similarly assign variables numeric values with or without decimals,
    and PHP will interpret them as integers or floats as appropriate:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we see that $age, with its whole-number value, has been interpreted as
    an integer, and $price, whose value includes a decimal, has been interpreted as
    ... a *double*? Although the documentation refers to floating-point values as
    being of the float data type, for historical reasons (PHP is an old language!)
    the function gettype() returns double when used on floats—a reference to the double-precision
    format for storing floating-point values. PHP has only one kind of floating-point
    data type, however, so while other programming languages may have different precision
    and memory representations for floats, doubles, reals, and so on, all floating-point
    values in PHP are of the float data type (no matter what the gettype() function
    says).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating a variable of the bool type next. Enter the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we use gettype() on the $isDutyFree variable, we see boolean displayed.
    This is an alias for bool in PHP; the two are mostly interchangeable, but to avoid
    some cases where aliases don’t work, always write bool in your code (and I’ll
    do so in this book).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'More curiously, notice that when we try to print the value of $isDutyFree,
    we see the number 1 rather than true in the output. This isn’t an error. It’s
    related to the way bool values are converted, or *juggled*, into strings. The
    print command expects a string, so whatever we provide after the keyword print
    is automatically converted into a string expression by the PHP engine. For the
    bool type, true is converted to the string "1", and false is converted to an empty
    string (that is, a string with no content, denoted by a set of quotation marks
    with nothing in between: ""). We’ll discuss conversion to another data type through
    manual casting and automatic type juggling in more detail later in the chapter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the actual Boolean value of $isDutyFree, use the built-in var_dump()
    function instead of print. This useful function outputs information about a variable.
    It’s helpful when learning PHP and for debugging purposes to know the value of
    a variable at a certain point in the execution of your code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output from var_dump() confirms that the data type of $isDutyFree is bool
    and that its value is true.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The Special NULL Type
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PHP has a special data type represented in code by the constant NULL or null
    (it’s case insensitive). A variable is NULL in three situations. In the first,
    a variable has never been assigned a value, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we try var_dump() on $lastName without giving the variable a value, we
    first get a warning that $lastName is undefined. Then we see that the variable,
    not having been given a value, evaluates to NULL.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, a variable is NULL if it’s been explicitly assigned the constant NULL
    as its value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we see an important difference between a variable never having been given
    a value, as in the previous example, and a variable containing the value NULL.
    In the first case, var_dump() produces a warning, whereas in this case we don’t
    get a warning; we just see the variable’s value (NULL) printed out. Assigning
    a variable the value NULL is fine, just like assigning a variable another value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a variable will be NULL if it has been *unset*, or cleared of its
    value, with the built-in unset() function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we give $lastName a value and then use unset() to get rid of that value.
    When we try to use var_dump() on $lastName after unsetting it, we get the same
    warning as before and see that it evaluates to NULL. Unsetting a variable is the
    same as never having given it a value in the first place.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When working with variables and data items in more complex programs, you’ll
    sometimes need to design logic to handle encounters with NULL. For example, if
    you’re creating a connection to a database but have a problem connecting, the
    connection variable will be set to NULL. In another example, if you expect to
    be passed a reference to an object (such as the logged-in user) but no such object
    exists, then a variable will be NULL. We’ll explore these kinds of situations
    in [Parts V](part5.xhtml) and [VI](part6.xhtml), when we discuss object-oriented
    programming and databases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Functions to Test for a Data Type
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PHP has many functions that produce true or false based on whether the provided
    variable or expression is of a certain data type. These include is_string(), is_int(),
    is_float(), is_bool(), and is_null(). Such functions are useful if you need to
    confirm that a variable is of a particular type before trying to work with it
    or, conversely, if you need to check that a variable isn’t NULL. Here are some
    examples of these functions in action:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our variable $gpa contains a decimal value, so only is_float() is true for it.
    Similarly, $middleName contains NULL, so passing it to is_null() yields true.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of PHP’s type-checking functions are true for broader categories of data
    types. For example, the is_numeric() function is true for variables of type int
    or float:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的一些类型检查函数适用于更广泛的数据类型。例如，is_numeric()函数对int或float类型的变量返回true：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we see both the decimal value 3.5 and the whole-number value 21 pass the
    is_numeric() test. The same function is also true for strings that contain only
    numeric characters, but not if non-numeric characters are mixed in:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到十进制值3.5和整数值21都通过了is_numeric()测试。对于仅包含数字字符的字符串，is_numeric()同样返回true，但如果混入了非数字字符，则返回false：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When $price contains the string "9.99", is_numeric() is true. When we add the
    word *dollars* to the end of the string, however, is_numeric() becomes false.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当$price包含字符串"9.99"时，is_numeric()返回true。然而，当我们在字符串末尾添加*美元*这个词时，is_numeric()变为false。
- en: Type Juggling
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'In some situations, the PHP engine automatically converts a value from one
    data type to another. This is known as *type juggling*. Consider this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，PHP引擎会自动将一个值从一种数据类型转换为另一种数据类型。这被称为*类型转换*。请看这个示例：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we try to add the string "1" and the integer 3. When the PHP engine evaluates
    this expression and stores the result in $answer, it will see the plus-sign operator
    (+) and assume that numeric addition is meant to take place. The PHP engine will
    therefore examine the two operands (the values on either side of the plus sign)
    and try to interpret them as numbers (floats or integers). The 3 is already an
    integer, but the string "1" will be converted (juggled) into an integer to allow
    the addition to take place. In the end, we get the integer 4 as an answer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将字符串"1"和整数3相加。当PHP引擎计算这个表达式并将结果存储到$answer时，它会看到加号运算符（+），并假设进行的是数值加法。因此，PHP引擎会检查这两个操作数（加号两边的值），并尝试将它们解释为数字（浮动数或整数）。3已经是一个整数，但字符串"1"会被转换（转换）成一个整数，以允许加法操作进行。最终，我们得到整数4作为答案。
- en: 'In six kinds of situations, PHP automatically juggles expressions into different
    types: numeric contexts, string contexts, comparative contexts, logic contexts,
    function contexts, and bitwise (integral and string) contexts. We’ll consider
    some of these contexts next.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在六种情况下，PHP会自动将表达式转换为不同的类型：数值上下文、字符串上下文、比较上下文、逻辑上下文、函数上下文和位运算（整数和字符串）上下文。接下来我们将讨论其中的一些上下文。
- en: '#### Numeric Contexts'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 数值上下文'
- en: When an expression includes an arithmetic operator, PHP will try to juggle the
    operands to integers or floats. This often happens when one or more of the operands
    are strings, as in the "1" + 3 example we just looked at. We’ll see an example
    of this in action when function parameters are coerced into integers in [Chapter
    5](chapter5.xhtml). Boolean values can also be juggled into integers; true becomes
    the integer 1, and false becomes the integer 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式包含算术运算符时，PHP会尝试将操作数转换为整数或浮动数。这通常发生在一个或多个操作数是字符串的情况下，正如我们刚才看到的"1" + 3示例。我们将在[第5章](chapter5.xhtml)中看到一个示例，说明函数参数如何被强制转换为整数。布尔值也可以转换为整数；true变为整数1，false变为整数0。
- en: 'Two important questions arise when juggling in numeric contexts: Will the result
    become an int or a float, and what happens when a string includes both numeric
    and non-numeric characters?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值上下文中，有两个重要的问题：结果会变成整数（int）还是浮动数（float），当字符串同时包含数字和非数字字符时会发生什么？
- en: Integer vs. Float
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数与浮动数
- en: 'If either operand in an arithmetic expression is a float (or isn’t interpretable
    as an integer), both values will be juggled into floats, and a float operation
    is performed. Otherwise, both values will be juggled into integers, and an integer
    operation is performed. For example, when both operands are integers, the result
    is an integer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算术表达式中的任一操作数是浮动数（或不能解释为整数），则两个值都会被转换为浮动数，并执行浮动数运算。否则，两个值都会被转换为整数，并执行整数运算。例如，当两个操作数都是整数时，结果是整数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When one operand is an integer, and the other is a numeric string that evaluates
    to an integer, both operators become integers. The result is also an integer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作数是整数，另一个操作数是能转换为整数的数值字符串时，两个操作数都会变成整数，结果也是整数：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Leading and trailing whitespace is ignored when strings are juggled into numbers,
    so we’ll get the same result if we add spaces at either end of the string:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串转换为数字时，会忽略前导和尾随的空白字符，因此如果我们在字符串的两端添加空格，仍然会得到相同的结果：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the extra spaces in the string before and after the 1 character
    make no difference. The string is still juggled to the integer 1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When both operands are numbers and one of the operands is a float, both operands
    become floats. The result is also a float:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To arrive at this result of 2.5, the integer 1 is juggled to a float behind
    the scenes, before the addition operation is performed. The same process occurs
    when one operand is an integer and the other is a numeric string that evaluates
    to a float. Both operands become floats, and the result is a float:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In short, if float arithmetic is needed, PHP uses float arithmetic. Otherwise,
    it uses integer arithmetic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Numeric, Leading Numeric, and Non-numeric Strings
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PHP differentiates between *numeric strings*, whose entire contents evaluate
    to an integer or a float, and *leading numeric strings*, which begin with numeric
    characters but also include non-numeric characters such as letters or special
    symbols. When a leading numeric string is juggled to an integer or float, everything
    from the first non-numeric character on is dropped. If a string *starts* with
    a non-numeric character, however, the entire string is considered *non-numeric*,
    even if it also contains numbers, and it can’t be juggled to a number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The exception to this rule about non-numeric characters at the start of a
    string is the special case of a string beginning with spaces, followed by numeric
    characters. Such a string will be treated as a numeric string, since leading (or
    trailing) spaces are ignored.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try numeric addition with a leading numeric string that evaluates to
    an integer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here "1 dollar" is a leading numeric string. When used in an arithmetic expression,
    the "1" at the beginning is juggled to an integer, while the " dollar" at the
    end is ignored. Notice that PHP raises a warning about this but goes ahead with
    the type conversion anyway. Since both operands can be juggled into integers,
    the result is an integer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition with a leading numeric string that evaluates to a float works the
    same way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, "9.99 dollars" is a leading numeric string whose beginning evaluates
    to the float 9.99. Since both operands can be juggled into floats, the result
    is a float. Again, PHP raises a warning because of the leading numeric string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, if you try to use a non-numeric string in an arithmetic expression,
    you’ll get a TypeError, meaning the operation can’t be performed with the given
    data types. This halts the execution of the code. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here "April 1" is a non-numeric string because it starts with letters, not
    numbers. The string can’t be evaluated as a number, so it triggers an error. The
    same error happens if we use an empty string (""):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An empty string does *not* evaluate to 0 as it does in some other languages.
    It’s a non-numeric string, so it leads to a TypeError in arithmetic expressions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: String Contexts
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a few cases, PHP automatically juggles values into strings. First, expressions
    involving print or echo statements are juggled to strings, since these commands
    expect anything that follows to be a string. You’ve already seen, for example,
    that values of type bool are juggled to the string "1" (for true) or "" (for false)
    when they’re part of a print statement. Similarly, numbers are juggled to their
    string equivalents.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Second, expressions involving the string concatenation operator (.) are also
    juggled to strings, as are expressions whose values are being parsed inside strings.
    We’ll discuss these topics in [Chapter 3](chapter3.xhtml).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Comparative Contexts
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Type juggling also occurs when comparing two values of different data types.
    Comparative expressions evaluate to a Boolean true or false, which you then typically
    use for decision-making logic (as we’ll discuss in [Chapter 4](chapter4.xhtml)).
    The PHP engine knows an expression is comparative when it sees a *comparison operator*,
    such as == for *equal* or > for *greater than*. PHP has rules that determine how
    these expressions are juggled and evaluated, depending on the data types involved.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Identical vs. Equal Values
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PHP makes an important distinction between values that are identical and values
    that are equal. Two expressions are considered *identical* only if (*before* any
    type juggling) they’re of the same data type and contain the same value. By contrast,
    two expressions are considered *equal* if they contain the same value *after*
    type juggling.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We use different operators to test for identity and equality. The triple equal
    sign (===) is the *identical operator*, while the double equal sign (==) is the
    *equal operator*. Consider these examples comparing the string "1" and the integer
    1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we try the comparison with the identical operator. This evaluates to
    false, since the operands are of different data types. Next, we try the comparison
    with the equal operator. This time it evaluates to true, since PHP juggles the
    string "1" into an integer before making the comparison.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP also has operators for not-identical (!==) and not-equal (!=). Consider
    these comparisons between an integer and a float:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the not-identical operator, the comparison is true, since the values are
    of different data types. Using the not-equal operator, the numbers are first juggled
    to the same type. This gives them the same value, so the not-equal comparison
    is false.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The PHP* <> *operator is equivalent to the* != *operator; both mean “not equal.”
    Personally, I always use the* != *operator, since an exclamation mark (*!*) by
    itself means “not” in other contexts too.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Strings vs. Numbers
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Since PHP 8.0, when comparing a string with a number, a numeric comparison
    is made if the string is a numeric string. Otherwise, a string comparison is made.
    We saw a numeric comparison when we tested the equality of the integer 1 and the
    numeric string "1". If we try the same comparison with a leading numeric string,
    the result will be false:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Though "1 dollar" starts with a number, it isn’t a fully numeric string. As
    such, PHP juggles the integer 1 to the string "1" and makes a string comparison.
    The strings aren’t equal, so we get false.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Two important implications of using only numeric comparisons for fully numeric
    strings are that any leading or trailing spaces are ignored and that an empty
    string is *not* considered a numeric string and so is not equal to a numeric 0,
    as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this comparison, since the empty string isn’t numeric, the integer 0 is juggled
    into the string "0". Then strings "0" and "" are compared and found to be not
    equal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Less Than and Greater Than
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When working with numbers, using the less-than (<), greater-than (>), less-than-or-equal-to
    (<=), or greater-than-or-equal-to (>=) operators is straightforward, since it’s
    very clear whether one number is less than, equal to, or greater than another.
    Here are some examples:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use these operators with non-numeric data types, in which case
    PHP has a variety of rules for evaluating the comparisons. For example, the Boolean
    true is considered greater than false and also greater than NULL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Strings are compared with each other one character at a time, with later letters
    in the alphabet considered greater than earlier letters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lowercase letters are considered greater than capital letters, however:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Strings are typically considered greater than any number, as in these cases:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Exceptions to such general rules of thumb exist, however. As we’ve already
    discussed, when a fully numeric string is compared to a number, the string is
    first juggled to a number and then a numeric comparison is made. Here, for example,
    the string "15" becomes the integer 15 for the purposes of comparison:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another exception is strings beginning with a special character such as these:
    ! # $ % & '' () * + , - . /. Such a string is always considered less than a number:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If a number is compared with a leading numeric string (one that starts with
    numbers but contains other characters), the number is juggled to a string, and
    the strings are compared character by character:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first case, the integer 10 is converted to the string "10" before comparison
    with the string "1a". The first characters are the same, but the character a (a
    letter) is considered greater than the character 0 (a number). In the second case,
    the 2 in the string "20" (after juggling) is considered greater than the 1 in
    the string "1a", so the expression is false.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these string-number and Boolean comparison rules is useful, but relying
    on them can be dangerous. It’s safer to use validation logic to convert strings
    to numbers first and then make simple numeric comparisons. For example, we’ll
    test that the price received from a web form is numeric in [Chapter 12](chapter12.xhtml).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The Spaceship Operator
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A relatively new addition to the PHP language is the *spaceship operator* (<=>).
    Instead of true or false, this operator gives an integer value of 0, 1, or -1
    depending on the two expressions being compared. If both expressions are the same
    (after any type juggling), the operator gives a 0; if the first expression is
    greater than the second, it gives a 1; or if the second expression is greater
    than the first, it gives a -1. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first case, we see -1 as the output, since 11 is less than 22. In the
    second case, we see 1 as the output, since 55 is greater than 22. In the last
    case, we see 0 as the output, since "22" is the same as 22 after type juggling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The spaceship operator may seem like a strange amalgam of the less-than, greater-than,
    and equal-to operators. However, it’s particularly useful when sorting collections
    of data into a desired sequence, since certain sorting functions require exactly
    this 0, 1, or -1 encoding scheme.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Logical and Other Contexts
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a logical value of true or false is expected, PHP will juggle values of
    other types to the bool type. The three logical type-juggling contexts are as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators, such as AND (&&) and OR (||)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ternary operator (?)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements such as if and switch
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover all of these logic contexts in [Chapter 4](chapter4.xhtml).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Type juggling also may occur in function contexts and bitwise contexts. We’ll
    explore the function context (when arguments are evaluated against function signatures)
    in [Chapter 5](chapter5.xhtml). The bitwise context is rarely used in web applications
    and is beyond the scope of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Type Casting
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Type casting* refers to explicitly converting an expression or variable to
    a desired data type. Manual type casting stands in contrast to the type juggling
    performed automatically by the PHP engine. To cast the value of an expression
    to a particular type, provide the new data type in parentheses before the expression.
    For instance, (float)21 ensures that the value 21 will be treated as a float instead
    of an integer. Here are some examples of casting various scalar data types:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that casting from a float to an integer truncates anything after the
    decimal point, effectively rounding down to the nearest whole number ❶. When casting
    from a number to a Boolean, 0 becomes false ❷, while any other numeric value (including
    negative numbers!) becomes true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Type casting is one of the lesser-used features of PHP. One example of its use
    could be to easily obtain the integer part of a float, such as the whole number
    of seconds when comparing two timestamps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced you to PHP’s four scalar data types, as well as the
    special NULL type. You saw the difference between variables containing NULL and
    variables evaluating to NULL by virtue of being undefined or unset, and you practiced
    testing whether a variable is of a particular type by using functions like is_int()
    and is_null(). Later, this will help you write code that carefully tests values
    to manage situations that may occur when receiving input from users or external
    data sources such as databases.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also showed you how an expression’s data type can change, either
    automatically through juggling or manually through casting. You learned about
    the contexts where type juggling can occur and rules for evaluating expressions
    with different data types. Understanding when and how types are juggled will help
    you avoid unexpected results when working with data of mixed types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a script to use integer casting to round down a float. Do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: a.   Create a $scoreFloat variable containing 55.9.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: b.   Create a second variable, $scoreInt, containing the value of $scoreFloat
    cast into an integer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: c.   Print out the type of $scoreFloat, then its value, then a newline character.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: d.   Print out the type of $scoreInt, then its value, then a newline character.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program output should look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 2.   Assign the $age variable the integer 21, and var_dump its value. Then assign
    NULL to this variable, and var_dump it again. Finally, unset the variable and
    var_dump it once more. Note that the output differs when the variable is assigned
    NULL and when it’s unset.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
