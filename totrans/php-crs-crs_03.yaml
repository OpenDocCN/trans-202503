- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 DATA TYPES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore the data types available in PHP. We’ll also consider
    how to force a value into a specified data type (*type casting*), as well as situations
    where PHP automatically attempts to convert data types to make the various parts
    of expressions work together (*type juggling*).
  prefs: []
  type: TYPE_NORMAL
- en: A *data type* is a categorization of a value in a program that specifies how
    the PHP engine is to interpret that value and therefore which operations can be
    applied to it. For example, if a value is an integer, the PHP engine knows that
    operations such as addition and multiplication are permitted and that the outcomes
    of those operations are themselves integers; meanwhile, the PHP engine knows that
    the outcome of division on an integer might be another integer or a floating-point
    (decimal) number.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding which data types are available—and knowing when and how a value’s
    data type can change—is essential as you work with inputs, perform calculations,
    and output data. If you don’t know the type of data you’re manipulating or how
    that data responds to various operations, you might get unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '### PHP Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](chapter1.xhtml), we stored the word "matt" in a variable and
    assigned the number 99 to a constant. These values are of different data types:
    one is a string, and the other an integer. In all, PHP has 10 built-in data types
    divided into three categories, as shown in [Figure 2-1](#fig2-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: PHP data types'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’ll mostly focus on the four *scalar* data types, which can hold
    only one value at a time. We’ll also pay some attention to the special NULL data
    type. In later chapters, you’ll learn about two of the *compound* data types,
    array (in [Chapters 8](chapter8.xhtml) and [9](chapter9.xhtml)) and object (in
    [Part V](part5.xhtml)), which can store and manipulate collections of multiple
    values. The resource special type and the callable and iterable compound types
    are used only in complex and special cases and won’t be considered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar Data Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The four scalar (single-value) data types are string, int, float, and bool.
    The string type is for text, the int type is for whole numbers (integers), the
    float type is for floating-point (decimal) numbers, and the bool type is for Boolean
    true/false values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use PHP’s *interactive mode* to explore the scalar data types. This mode
    allows you to enter individual PHP statements at the command line and immediately
    see the results. We’ll use interactive mode in the coming chapters to quickly
    demonstrate basic concepts and get instant feedback, instead of having to write
    full PHP scripts. Enter php -a at the command line to turn on interactive mode
    and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we once again assign the value "matt" to the $username variable. We then
    use PHP’s built-in gettype() function to print out the variable’s type. The output
    confirms that $username contains a string.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve previously seen or written code in strongly typed languages like Java
    or C#, you may have noticed that you don’t have to specify the data type when
    assigning a value to a variable. PHP is a *loosely typed* language, meaning that
    the same variable can store values of different data types at different times
    and that the PHP engine will automatically infer the data type of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We can also explicitly declare data types in PHP, something we’ll do starting
    in [Chapter 5](chapter5.xhtml) when we begin writing functions. For now, though,
    as we work with simple variables, we’ll let the interpreter infer data types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the $username variable, the value "matt" is inferred to be a
    string. We can similarly assign variables numeric values with or without decimals,
    and PHP will interpret them as integers or floats as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that $age, with its whole-number value, has been interpreted as
    an integer, and $price, whose value includes a decimal, has been interpreted as
    ... a *double*? Although the documentation refers to floating-point values as
    being of the float data type, for historical reasons (PHP is an old language!)
    the function gettype() returns double when used on floats—a reference to the double-precision
    format for storing floating-point values. PHP has only one kind of floating-point
    data type, however, so while other programming languages may have different precision
    and memory representations for floats, doubles, reals, and so on, all floating-point
    values in PHP are of the float data type (no matter what the gettype() function
    says).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating a variable of the bool type next. Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we use gettype() on the $isDutyFree variable, we see boolean displayed.
    This is an alias for bool in PHP; the two are mostly interchangeable, but to avoid
    some cases where aliases don’t work, always write bool in your code (and I’ll
    do so in this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'More curiously, notice that when we try to print the value of $isDutyFree,
    we see the number 1 rather than true in the output. This isn’t an error. It’s
    related to the way bool values are converted, or *juggled*, into strings. The
    print command expects a string, so whatever we provide after the keyword print
    is automatically converted into a string expression by the PHP engine. For the
    bool type, true is converted to the string "1", and false is converted to an empty
    string (that is, a string with no content, denoted by a set of quotation marks
    with nothing in between: ""). We’ll discuss conversion to another data type through
    manual casting and automatic type juggling in more detail later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the actual Boolean value of $isDutyFree, use the built-in var_dump()
    function instead of print. This useful function outputs information about a variable.
    It’s helpful when learning PHP and for debugging purposes to know the value of
    a variable at a certain point in the execution of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output from var_dump() confirms that the data type of $isDutyFree is bool
    and that its value is true.
  prefs: []
  type: TYPE_NORMAL
- en: The Special NULL Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PHP has a special data type represented in code by the constant NULL or null
    (it’s case insensitive). A variable is NULL in three situations. In the first,
    a variable has never been assigned a value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we try var_dump() on $lastName without giving the variable a value, we
    first get a warning that $lastName is undefined. Then we see that the variable,
    not having been given a value, evaluates to NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, a variable is NULL if it’s been explicitly assigned the constant NULL
    as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we see an important difference between a variable never having been given
    a value, as in the previous example, and a variable containing the value NULL.
    In the first case, var_dump() produces a warning, whereas in this case we don’t
    get a warning; we just see the variable’s value (NULL) printed out. Assigning
    a variable the value NULL is fine, just like assigning a variable another value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a variable will be NULL if it has been *unset*, or cleared of its
    value, with the built-in unset() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we give $lastName a value and then use unset() to get rid of that value.
    When we try to use var_dump() on $lastName after unsetting it, we get the same
    warning as before and see that it evaluates to NULL. Unsetting a variable is the
    same as never having given it a value in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: When working with variables and data items in more complex programs, you’ll
    sometimes need to design logic to handle encounters with NULL. For example, if
    you’re creating a connection to a database but have a problem connecting, the
    connection variable will be set to NULL. In another example, if you expect to
    be passed a reference to an object (such as the logged-in user) but no such object
    exists, then a variable will be NULL. We’ll explore these kinds of situations
    in [Parts V](part5.xhtml) and [VI](part6.xhtml), when we discuss object-oriented
    programming and databases.
  prefs: []
  type: TYPE_NORMAL
- en: Functions to Test for a Data Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PHP has many functions that produce true or false based on whether the provided
    variable or expression is of a certain data type. These include is_string(), is_int(),
    is_float(), is_bool(), and is_null(). Such functions are useful if you need to
    confirm that a variable is of a particular type before trying to work with it
    or, conversely, if you need to check that a variable isn’t NULL. Here are some
    examples of these functions in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our variable $gpa contains a decimal value, so only is_float() is true for it.
    Similarly, $middleName contains NULL, so passing it to is_null() yields true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of PHP’s type-checking functions are true for broader categories of data
    types. For example, the is_numeric() function is true for variables of type int
    or float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see both the decimal value 3.5 and the whole-number value 21 pass the
    is_numeric() test. The same function is also true for strings that contain only
    numeric characters, but not if non-numeric characters are mixed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When $price contains the string "9.99", is_numeric() is true. When we add the
    word *dollars* to the end of the string, however, is_numeric() becomes false.
  prefs: []
  type: TYPE_NORMAL
- en: Type Juggling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some situations, the PHP engine automatically converts a value from one
    data type to another. This is known as *type juggling*. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we try to add the string "1" and the integer 3. When the PHP engine evaluates
    this expression and stores the result in $answer, it will see the plus-sign operator
    (+) and assume that numeric addition is meant to take place. The PHP engine will
    therefore examine the two operands (the values on either side of the plus sign)
    and try to interpret them as numbers (floats or integers). The 3 is already an
    integer, but the string "1" will be converted (juggled) into an integer to allow
    the addition to take place. In the end, we get the integer 4 as an answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In six kinds of situations, PHP automatically juggles expressions into different
    types: numeric contexts, string contexts, comparative contexts, logic contexts,
    function contexts, and bitwise (integral and string) contexts. We’ll consider
    some of these contexts next.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Numeric Contexts'
  prefs: []
  type: TYPE_NORMAL
- en: When an expression includes an arithmetic operator, PHP will try to juggle the
    operands to integers or floats. This often happens when one or more of the operands
    are strings, as in the "1" + 3 example we just looked at. We’ll see an example
    of this in action when function parameters are coerced into integers in [Chapter
    5](chapter5.xhtml). Boolean values can also be juggled into integers; true becomes
    the integer 1, and false becomes the integer 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two important questions arise when juggling in numeric contexts: Will the result
    become an int or a float, and what happens when a string includes both numeric
    and non-numeric characters?'
  prefs: []
  type: TYPE_NORMAL
- en: Integer vs. Float
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If either operand in an arithmetic expression is a float (or isn’t interpretable
    as an integer), both values will be juggled into floats, and a float operation
    is performed. Otherwise, both values will be juggled into integers, and an integer
    operation is performed. For example, when both operands are integers, the result
    is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When one operand is an integer, and the other is a numeric string that evaluates
    to an integer, both operators become integers. The result is also an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Leading and trailing whitespace is ignored when strings are juggled into numbers,
    so we’ll get the same result if we add spaces at either end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the extra spaces in the string before and after the 1 character
    make no difference. The string is still juggled to the integer 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'When both operands are numbers and one of the operands is a float, both operands
    become floats. The result is also a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To arrive at this result of 2.5, the integer 1 is juggled to a float behind
    the scenes, before the addition operation is performed. The same process occurs
    when one operand is an integer and the other is a numeric string that evaluates
    to a float. Both operands become floats, and the result is a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In short, if float arithmetic is needed, PHP uses float arithmetic. Otherwise,
    it uses integer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric, Leading Numeric, and Non-numeric Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PHP differentiates between *numeric strings*, whose entire contents evaluate
    to an integer or a float, and *leading numeric strings*, which begin with numeric
    characters but also include non-numeric characters such as letters or special
    symbols. When a leading numeric string is juggled to an integer or float, everything
    from the first non-numeric character on is dropped. If a string *starts* with
    a non-numeric character, however, the entire string is considered *non-numeric*,
    even if it also contains numbers, and it can’t be juggled to a number.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The exception to this rule about non-numeric characters at the start of a
    string is the special case of a string beginning with spaces, followed by numeric
    characters. Such a string will be treated as a numeric string, since leading (or
    trailing) spaces are ignored.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try numeric addition with a leading numeric string that evaluates to
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here "1 dollar" is a leading numeric string. When used in an arithmetic expression,
    the "1" at the beginning is juggled to an integer, while the " dollar" at the
    end is ignored. Notice that PHP raises a warning about this but goes ahead with
    the type conversion anyway. Since both operands can be juggled into integers,
    the result is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition with a leading numeric string that evaluates to a float works the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, "9.99 dollars" is a leading numeric string whose beginning evaluates
    to the float 9.99. Since both operands can be juggled into floats, the result
    is a float. Again, PHP raises a warning because of the leading numeric string.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, if you try to use a non-numeric string in an arithmetic expression,
    you’ll get a TypeError, meaning the operation can’t be performed with the given
    data types. This halts the execution of the code. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here "April 1" is a non-numeric string because it starts with letters, not
    numbers. The string can’t be evaluated as a number, so it triggers an error. The
    same error happens if we use an empty string (""):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An empty string does *not* evaluate to 0 as it does in some other languages.
    It’s a non-numeric string, so it leads to a TypeError in arithmetic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: String Contexts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a few cases, PHP automatically juggles values into strings. First, expressions
    involving print or echo statements are juggled to strings, since these commands
    expect anything that follows to be a string. You’ve already seen, for example,
    that values of type bool are juggled to the string "1" (for true) or "" (for false)
    when they’re part of a print statement. Similarly, numbers are juggled to their
    string equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Second, expressions involving the string concatenation operator (.) are also
    juggled to strings, as are expressions whose values are being parsed inside strings.
    We’ll discuss these topics in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Comparative Contexts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Type juggling also occurs when comparing two values of different data types.
    Comparative expressions evaluate to a Boolean true or false, which you then typically
    use for decision-making logic (as we’ll discuss in [Chapter 4](chapter4.xhtml)).
    The PHP engine knows an expression is comparative when it sees a *comparison operator*,
    such as == for *equal* or > for *greater than*. PHP has rules that determine how
    these expressions are juggled and evaluated, depending on the data types involved.
  prefs: []
  type: TYPE_NORMAL
- en: Identical vs. Equal Values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PHP makes an important distinction between values that are identical and values
    that are equal. Two expressions are considered *identical* only if (*before* any
    type juggling) they’re of the same data type and contain the same value. By contrast,
    two expressions are considered *equal* if they contain the same value *after*
    type juggling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use different operators to test for identity and equality. The triple equal
    sign (===) is the *identical operator*, while the double equal sign (==) is the
    *equal operator*. Consider these examples comparing the string "1" and the integer
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we try the comparison with the identical operator. This evaluates to
    false, since the operands are of different data types. Next, we try the comparison
    with the equal operator. This time it evaluates to true, since PHP juggles the
    string "1" into an integer before making the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP also has operators for not-identical (!==) and not-equal (!=). Consider
    these comparisons between an integer and a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the not-identical operator, the comparison is true, since the values are
    of different data types. Using the not-equal operator, the numbers are first juggled
    to the same type. This gives them the same value, so the not-equal comparison
    is false.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The PHP* <> *operator is equivalent to the* != *operator; both mean “not equal.”
    Personally, I always use the* != *operator, since an exclamation mark (*!*) by
    itself means “not” in other contexts too.*'
  prefs: []
  type: TYPE_NORMAL
- en: Strings vs. Numbers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Since PHP 8.0, when comparing a string with a number, a numeric comparison
    is made if the string is a numeric string. Otherwise, a string comparison is made.
    We saw a numeric comparison when we tested the equality of the integer 1 and the
    numeric string "1". If we try the same comparison with a leading numeric string,
    the result will be false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Though "1 dollar" starts with a number, it isn’t a fully numeric string. As
    such, PHP juggles the integer 1 to the string "1" and makes a string comparison.
    The strings aren’t equal, so we get false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two important implications of using only numeric comparisons for fully numeric
    strings are that any leading or trailing spaces are ignored and that an empty
    string is *not* considered a numeric string and so is not equal to a numeric 0,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this comparison, since the empty string isn’t numeric, the integer 0 is juggled
    into the string "0". Then strings "0" and "" are compared and found to be not
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: Less Than and Greater Than
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When working with numbers, using the less-than (<), greater-than (>), less-than-or-equal-to
    (<=), or greater-than-or-equal-to (>=) operators is straightforward, since it’s
    very clear whether one number is less than, equal to, or greater than another.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use these operators with non-numeric data types, in which case
    PHP has a variety of rules for evaluating the comparisons. For example, the Boolean
    true is considered greater than false and also greater than NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are compared with each other one character at a time, with later letters
    in the alphabet considered greater than earlier letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lowercase letters are considered greater than capital letters, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are typically considered greater than any number, as in these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Exceptions to such general rules of thumb exist, however. As we’ve already
    discussed, when a fully numeric string is compared to a number, the string is
    first juggled to a number and then a numeric comparison is made. Here, for example,
    the string "15" becomes the integer 15 for the purposes of comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another exception is strings beginning with a special character such as these:
    ! # $ % & '' () * + , - . /. Such a string is always considered less than a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If a number is compared with a leading numeric string (one that starts with
    numbers but contains other characters), the number is juggled to a string, and
    the strings are compared character by character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the integer 10 is converted to the string "10" before comparison
    with the string "1a". The first characters are the same, but the character a (a
    letter) is considered greater than the character 0 (a number). In the second case,
    the 2 in the string "20" (after juggling) is considered greater than the 1 in
    the string "1a", so the expression is false.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these string-number and Boolean comparison rules is useful, but relying
    on them can be dangerous. It’s safer to use validation logic to convert strings
    to numbers first and then make simple numeric comparisons. For example, we’ll
    test that the price received from a web form is numeric in [Chapter 12](chapter12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The Spaceship Operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A relatively new addition to the PHP language is the *spaceship operator* (<=>).
    Instead of true or false, this operator gives an integer value of 0, 1, or -1
    depending on the two expressions being compared. If both expressions are the same
    (after any type juggling), the operator gives a 0; if the first expression is
    greater than the second, it gives a 1; or if the second expression is greater
    than the first, it gives a -1. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we see -1 as the output, since 11 is less than 22. In the
    second case, we see 1 as the output, since 55 is greater than 22. In the last
    case, we see 0 as the output, since "22" is the same as 22 after type juggling.
  prefs: []
  type: TYPE_NORMAL
- en: The spaceship operator may seem like a strange amalgam of the less-than, greater-than,
    and equal-to operators. However, it’s particularly useful when sorting collections
    of data into a desired sequence, since certain sorting functions require exactly
    this 0, 1, or -1 encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Logical and Other Contexts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a logical value of true or false is expected, PHP will juggle values of
    other types to the bool type. The three logical type-juggling contexts are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators, such as AND (&&) and OR (||)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ternary operator (?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements such as if and switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover all of these logic contexts in [Chapter 4](chapter4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Type juggling also may occur in function contexts and bitwise contexts. We’ll
    explore the function context (when arguments are evaluated against function signatures)
    in [Chapter 5](chapter5.xhtml). The bitwise context is rarely used in web applications
    and is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Type Casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Type casting* refers to explicitly converting an expression or variable to
    a desired data type. Manual type casting stands in contrast to the type juggling
    performed automatically by the PHP engine. To cast the value of an expression
    to a particular type, provide the new data type in parentheses before the expression.
    For instance, (float)21 ensures that the value 21 will be treated as a float instead
    of an integer. Here are some examples of casting various scalar data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that casting from a float to an integer truncates anything after the
    decimal point, effectively rounding down to the nearest whole number ❶. When casting
    from a number to a Boolean, 0 becomes false ❷, while any other numeric value (including
    negative numbers!) becomes true.
  prefs: []
  type: TYPE_NORMAL
- en: Type casting is one of the lesser-used features of PHP. One example of its use
    could be to easily obtain the integer part of a float, such as the whole number
    of seconds when comparing two timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced you to PHP’s four scalar data types, as well as the
    special NULL type. You saw the difference between variables containing NULL and
    variables evaluating to NULL by virtue of being undefined or unset, and you practiced
    testing whether a variable is of a particular type by using functions like is_int()
    and is_null(). Later, this will help you write code that carefully tests values
    to manage situations that may occur when receiving input from users or external
    data sources such as databases.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also showed you how an expression’s data type can change, either
    automatically through juggling or manually through casting. You learned about
    the contexts where type juggling can occur and rules for evaluating expressions
    with different data types. Understanding when and how types are juggled will help
    you avoid unexpected results when working with data of mixed types.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a script to use integer casting to round down a float. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Create a $scoreFloat variable containing 55.9.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Create a second variable, $scoreInt, containing the value of $scoreFloat
    cast into an integer.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Print out the type of $scoreFloat, then its value, then a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: d.   Print out the type of $scoreInt, then its value, then a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 2.   Assign the $age variable the integer 21, and var_dump its value. Then assign
    NULL to this variable, and var_dump it again. Finally, unset the variable and
    var_dump it once more. Note that the output differs when the variable is assigned
    NULL and when it’s unset.
  prefs: []
  type: TYPE_NORMAL
