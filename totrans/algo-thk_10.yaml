- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: RANDOMIZATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机化**'
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: Think back to when we learned about binary search in [Chapter 7](ch07.xhtml).
    Rather than answering the question, “What is the optimal solution?” we instead
    asked, “Is this specific value the optimal solution?” While we were solving the
    Feeding Ants problem, you may have thought that my picking values out of thin
    air was outlandish, wondering how that was going to work at all. But it works
    great, as we now know.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第7章](ch07.xhtml)学习的二分查找。当时我们不是在回答“最优解是什么？”的问题，而是在问“这个特定的值是不是最优解？”在解决喂蚂蚁问题时，你可能会觉得我随意挑选值的做法很荒唐，想知道那到底怎么可能有效。但事实证明，这种做法非常有效，现在我们知道了。
- en: You want something that’s even more outlandish than binary search? How about
    just straight-up guessing a completely random solution. How could that possibly
    work? What is it about specific problems that makes this random guessing a viable
    strategy? And could random guessing still help us solve a problem even if we already
    have a solution? The surprising conclusions await.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要比二分查找更荒唐的东西吗？那就直接猜一个完全随机的解法吧。那怎么可能行得通呢？究竟是什么使得在特定问题下，随机猜测能成为一种可行的策略？即使我们已经有了解法，随机猜测还能帮我们解决问题吗？令人惊讶的结论在等着我们。
- en: '**Problem 1: Yōkan**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**问题1：羊羹**'
- en: Yōkan is a Japanese candy. It’s sweet. It has kind of a jelly or gummy texture.
    Buy a nice big block and cut it into little pieces and pair it with some fruit
    and chill it for a nice refreshing . . . oh, sorry. Back to algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 羊羹是一种日本糖果，味道甜美，质地类似果冻或橡皮糖。买一块大块的羊羹，切成小块，搭配一些水果，冷藏一下，享受一份清爽的……哦，抱歉，我们还是回到算法吧。
- en: This is DMOJ problem `dmpg15g6`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`dmpg15g6`。
- en: '*The Problem*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: Two friends have found a Yōkan consisting of *n* pieces. The pieces are numbered
    1, 2, . . . , *n*. Each piece of the Yōkan has a specific flavor, and each friend
    will eat only those pieces that are the same flavor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两个朋友找到了一个包含*n*块的羊羹。这些块按顺序编号为1, 2, ... , *n*。每一块羊羹有一个特定的味道，每个朋友只会吃那些味道相同的部分。
- en: A slab of Yōkan consists of all of the pieces from Piece *l* to Piece *r*. A
    friend is *happy* with a slab if they can find at least one-third of that slab’s
    pieces that have the same flavor. For example, if a slab has 9 pieces, then a
    friend would need to find 9/3 = 3 pieces of the same flavor. For both friends
    to be happy with the slab, they would each need to find their own one-third of
    pieces that have the same flavor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一块羊羹由从第*l*块到第*r*块的所有部分组成。如果一个朋友能找到至少三分之一的羊羹部分有相同的味道，那么他们会对这块羊羹感到*高兴*。例如，如果一块羊羹有9块，那么朋友需要找到9/3
    = 3块味道相同的部分。为了让两个朋友都对这块羊羹感到高兴，他们需要各自找到三分之一的味道相同的部分。
- en: The friends will query about various slabs; for each, we need to determine whether
    both of them would be happy with that slab.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 朋友们将查询不同的羊羹部分；对于每个部分，我们需要确定他们两个是否都会对这块羊羹感到高兴。
- en: Input
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing *n*, the number of pieces in the Yōkan, and *m*, the number
    of possible piece flavors. *n* and *m* are between 1 and 200,000.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，即羊羹的块数，和*m*，即可能的味道数。*n*和*m*的范围在1到200,000之间。
- en: A line containing *n* integers giving the flavors of the Yōkan pieces from Piece
    1 to Piece *n*. Each integer is a flavor between 1 and *m*.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*个整数，表示从第1块到第*n*块的羊羹部分的味道。每个整数表示一种味道，范围在1到*m*之间。
- en: A line containing *q*, the number of queries that the friends have. *q* is between
    1 and 200,000.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*q*，即朋友们的查询数。*q*的范围在1到200,000之间。
- en: '*q* lines, one for each query. Each such line contains the integers *l* and
    *r*, indicating the slab from Piece *l* to Piece *r*.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*行，每行对应一个查询。每一行包含两个整数*l*和*r*，表示从第*l*块到第*r*块的羊羹部分。'
- en: Output
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'The output for each query is on its own line. For each query:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查询的输出单独一行。对于每个查询：
- en: If both friends are happy with this slab, output `YES`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个朋友都对这块羊羹感到高兴，输出`YES`。
- en: Otherwise, output `NO`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，输出`NO`。
- en: The time limit for solving the test case is 1.4 seconds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为1.4秒。
- en: '*Randomly Choosing a Piece*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*随机选择一块*'
- en: 'Let’s start with a test case:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个测试用例开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Yōkan here has 14 pieces. It looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的羊羹有14块，长得像这样：
- en: '![Image](../images/pg377-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg377-01.jpg)'
- en: 'There are three queries to process. The first query starts at Piece 3 and ends
    at Piece 11\. We’re therefore interested in this slab of the Yōkan:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理三个查询。第一个查询从第3块开始，到第11块结束。因此，我们关心的是这块羊羹：
- en: '![Image](../images/pg377-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg377-02.jpg)'
- en: This slab has 9 pieces, so we want to determine whether each friend can find
    9/3 = 3 pieces of the same flavor. And they can! The first friend could eat 3
    pieces of Flavor 1\. The second friend could eat 3 pieces of Flavor 2\. (There
    are 4 pieces of Flavor 2 there, but that fourth one is overkill for what we need.)
    For this query, we would therefore output `YES`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这块羊羹有 9 块，因此我们要确定每个朋友是否能找到 9/3 = 3 块相同口味的部分。而他们是可以的！第一个朋友可以吃 3 块口味 1，第二个朋友可以吃
    3 块口味 2。（这里有 4 块口味 2，但第四块对于我们来说多余了。）因此，针对这个问题，我们的输出应该是 `YES`。
- en: Think about how we might write code to determine whether the friends are happy
    with this slab. In general, it would be too slow to do this by checking each piece
    in the slab one by one; after all, a slab can have up to 200,000 pieces in it.
    This is a familiar roadblock for us by this point in the book; the usual thing
    to do would be to use some fancy data structure to make the queries fast.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们如何编写代码来判断朋友们是否满意这块羊羹。一般来说，通过逐一检查羊羹中的每一块来做这个判断会太慢了；毕竟，一块羊羹可能有多达 20 万块部分。到目前为止，这个问题我们已经很熟悉了；通常做法是使用一些巧妙的数据结构来加速查询。
- en: But we’re going to do something far less usual here. I’d like you to look at
    that Yōkan slab again and randomly pick one of its pieces. Pieces of Flavor 1
    and pieces of Flavor 2 are prevalent here, so you may have ended up picking a
    piece of one of those two flavors. If you did, then you just found a way to satisfy
    the first friend. If not, please randomly pick another piece of that Yōkan slab.
    You may have gotten Flavor 1 or Flavor 2 that time. Still no? Then try a third
    time. If you’re choosing randomly, you’re bound to pick Flavor 1 or Flavor 2 within
    a small number of tries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们这里要做一些不太寻常的事情。我希望你再次看那块羊羹，并随机挑选其中的一块。羊羹中有口味 1 和口味 2 的部分，所以你可能会挑到其中一个口味。如果是的话，那你就找到了满足第一个朋友的方法。如果没有，请再随机挑选一块羊羹。你可能会得到口味
    1 或口味 2。还是没有？那就再试第三次。如果你是随机挑选的话，你很快就会在少数几次尝试中挑到口味 1 或口味 2。
- en: 'Let’s say that you’ve found Flavor 1 for the first friend. Now, do it again,
    this time for the second friend. It’ll be a little more difficult this time: the
    three Flavor 1 pieces are gone, so you’ll have to land on Flavor 2\. Still, try
    picking a random piece a few times, and I’m sure you’ll eventually pick one of
    Flavor 2.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经为第一个朋友找到了口味 1。现在，再做一次，这次为第二个朋友。这个过程会稍微困难一些：因为三个口味 1 的部分已经没有了，所以你必须选择口味
    2。不过，还是试着随机挑选几次，我相信你最终会挑到口味 2 的一块。
- en: 'The program that we’ll write to solve this problem is going to do exactly what
    you just did: picking pieces randomly, trying to find one whose flavor makes each
    friend happy.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要写的程序将做的事情与你刚才做的完全一样：随机挑选部分，试图找到一种口味让每个朋友都感到满意。
- en: Suppose that the two friends are happy with a given Yōkan slab. This means that
    there’s a single flavor that shows up for 2/3 of the pieces, or two different
    flavors that each show up for 1/3 of the pieces. Regardless, we have a 2/3 chance
    of making the first friend happy by just choosing a piece at random. If we succeed,
    then we’re done with the first friend and we move to the second friend. If we
    fail, well, we’ll just try again, and we’ll have a new 2/3 chance of success.
    If we fail that second time, we’ll try a third time, and a fourth time, until
    we succeed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这两位朋友都对这块羊羹感到满意。这意味着羊羹中有一个口味在 2/3 的部分出现，或者有两个不同的口味各自出现在 1/3 的部分。不管怎样，我们都有
    2/3 的机会通过随机选择一块来让第一个朋友满意。如果成功了，那我们就完成了第一个朋友的任务，接着转向第二个朋友。如果失败了，我们就再试一次，这时我们有新的
    2/3 的成功机会。如果第二次也失败了，我们就再试第三次、第四次，直到成功为止。
- en: We’ll figure out how many attempts we need later. For now, though, I can promise
    that it won’t be very many. The intuition for this can come from a coin-tossing
    experiment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会弄清楚需要多少次尝试。不过，现在我可以保证，次数不会太多。这个直觉可以通过掷硬币实验来理解。
- en: Imagine that you were playing a game with a fair coin. If you toss the coin
    and it comes up heads, you win. If you toss the coin and it comes up tails, you
    have to try again. Think of the coin coming up heads as making the friend happy,
    and the coin coming up tails as not making the friend happy and having to try
    again. How many times do you expect to have to toss the coin before it comes up
    heads? Not many, right? If there’s a flavor in the slab that makes a friend happy,
    we’ll toss only so many tails in a row before we find a heads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We were in the middle of working through a test case before all of that randomizing
    and coin-tossing talk, so let’s finish that before continuing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The second query starts at Piece 8 and ends at Piece 11\. The corresponding
    slab is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg378-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the two friends are not happy with this one. Each friend needs
    to find at least 4/3 = ![Image](../images/page_378_1.jpg) pieces of the same flavor;
    as the available number of pieces of each flavor is an integer, what we really
    need is at least 2 pieces of the same flavor. We can do this for the first friend
    with Flavor 2, but we’re stuck for the second friend. We need to output `NO` here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The third query starts at Piece 5 and ends at Piece 6\. That’s this part of
    the Yōkan:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg378-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Each friend needs just one piece of a given flavor. We can therefore use Flavor
    1 to make both friends happy: we can give one piece to the first friend and the
    other to the second friend! The correct output is therefore `YES`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating Random Numbers*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll need a way to generate random numbers in order to randomly pick Yōkan
    pieces. We’ll use C’s `rand` function to do this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If we call `rand` with an integer `x`, we’re asking for `rand` to give us one
    of `x` possibilities. Specifically, we’ll get back a random integer in the range
    `0` to `x - 1`. For example, if we call `rand(4)`, we’ll get back a `0`, `1`,
    `2`, or `3`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we use `rand` to pick a random piece of a slab? Let’s use the term
    *width* to refer to the number of pieces in a slab. For example, the slab from
    Piece 8 to Piece 11 has a width of 4\. In this case, we’d need `rand` to give
    us back `8`, `9`, `10`, or `11`. We can start by calling `rand(4)`, because we
    need `rand` to give us one of four possibilities. That would give us a `0`, `1`,
    `2`, or `3`. This is a good start, but those numbers are not in the right range.
    To fix that, we can just add 8 to move that value into the 8–11 range that we
    need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In code, generating a random number for a given width `width` and starting point
    `left` can be done as in [Listing 10-1](ch10.xhtml#ch010ex01).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Randomly choosing a piece*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The code carries out the plan that we just outlined: it generates a random
    number from `0` to `width - 1`, then adds the starting point `left` to it ❶.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Determining Number of Pieces*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that we’re working on a particular query. We’re going to choose a random
    piece in that query’s slab. Does the flavor of that piece make one or both of
    the friends happy? To answer that, we’ll need to be able to quickly determine
    how many times that flavor shows up in the slab.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理一个特定的查询。我们将选择该查询块中的一个随机片段。这个片段的味道是否让其中一个或两个朋友开心？为了回答这个问题，我们需要能够快速确定该味道在块中出现的次数。
- en: It will therefore be convenient for us to have a sorted array for each flavor
    that gives us the pieces of that flavor. I’ll call such an array a *flavor array*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们来说，拥有一个每个味道的排序数组将非常方便，它可以为我们提供该味道的片段。我称这种数组为*味道数组*。
- en: 'Let’s go back to the Yōkan from our test case:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到测试用例中的羊羹：
- en: '![Image](../images/pg379-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg379-01.jpg)'
- en: 'The array for Flavor 1 would be `[1, 5, 6, 9, 13, 14]`; the array for Flavor
    2 would be `[4, 7, 10, 11]`; and so on. As promised, each of these arrays is sorted:
    the piece numbers are in order from smallest to largest. We’ll see how to generate
    these flavor arrays later; for now let’s just assume they exist.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 味道1的数组是`[1, 5, 6, 9, 13, 14]`；味道2的数组是`[4, 7, 10, 11]`；依此类推。如同承诺的那样，这些数组已经排序：片段编号按从小到大的顺序排列。稍后我们会看到如何生成这些味道数组；现在我们暂且假设它们已经存在。
- en: 'We can use such an array to determine the number of pieces of a given flavor
    that lie within a slab. For example, we could use the array `[1, 5, 6, 9, 13,
    14]` to conclude that there are three pieces of Flavor 1 in the 3-11 slab: the
    pieces 5, 6, and 9.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的数组来确定给定味道在某个块中的片段数量。例如，我们可以使用数组`[1, 5, 6, 9, 13, 14]`得出结论：在3-11块中有三个味道1的片段：片段5、片段6和片段9。
- en: 'Let’s take stock. We have the query that we want to solve. We have a random
    flavor that we care about checking. We have the flavor array: a sorted array of
    piece numbers of that flavor. And we need to determine how many of those pieces
    are in the range of the query.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们盘点一下。我们有了要解决的查询。我们有一个随机的味道，需要检查它。我们有了味道数组：一个排序的该味道的片段编号数组。我们需要确定这些片段中有多少个在查询范围内。
- en: We could do this using a linear search through the flavor array. But that would
    be too slow—a linear amount of work per query.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过线性查找味道数组来做到这一点。但那会太慢——每次查询都需要线性时间。
- en: If you think back to [Chapter 7](ch07.xhtml), you might wonder whether we can
    call on a binary search here. We can indeed, because the array is sorted! Well,
    actually, we’ll need to call binary search twice rather than once, but that won’t
    change the fact that we’ll be able to find what we need in logarithmic time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想一下[第7章](ch07.xhtml)，你可能会想知道是否可以在这里使用二分查找。的确可以，因为数组是排序的！实际上，我们需要调用二分查找两次，而不是一次，但这不会改变我们能够在对数时间内找到所需内容的事实。
- en: We’re going to write a binary search function that takes a flavor array `pieces`
    and an integer `at_least` and returns the index of the leftmost value in the array
    that’s greater than or equal to `at_least`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个二分查找函数，传入一个味道数组`pieces`和一个整数`at_least`，返回数组中第一个大于或等于`at_least`的值的索引。
- en: Before we do, we should make sure that the specification of that function actually
    does what we need. To that end, let’s use it to figure out how many pieces of
    Flavor 1 are in the 3-11 slab.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该确保这个函数的规范确实能满足我们的需求。为此，让我们用它来找出3-11块中味道1的片段数量。
- en: To figure out where the pieces of Flavor 1 begin in that slab, we can call our
    function with the array `[1, 5, 6, 9, 13, 14]` and an `at_least` value of `3`.
    We’ll get a result of `1`. This tells us that the piece at index 1 is the first
    piece of this flavor whose number is at least 3\. That piece is Piece 5, which
    is indeed the first piece that we’re looking for.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出味道1在该块中的片段起始位置，我们可以调用我们的函数，传入数组`[1, 5, 6, 9, 13, 14]`和`at_least`值为`3`。我们将得到结果`1`。这告诉我们，索引为1的片段是这个味道中编号至少为3的第一个片段。这个片段是片段5，它确实是我们要找的第一个片段。
- en: Where do the pieces of Flavor 1 end in that slab? We can figure that out, too!
    Just call our function with the same array, but this time an `at_least` value
    of `12`. Why 12? Because that’s the first piece *not* in the slab. If we make
    this call, we’ll get a result of `4`. This refers to the piece at index 4, which
    is Piece 13\. That’s the first piece of this flavor that’s not in the 3-11 slab.
    In general, to figure out where a flavor ends, we’ll call our binary search function
    with an `at_least` value that’s 1 larger than the right end of the slab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Flavor 1的片段在该区间结束在哪里？我们也可以算出来！只需用相同的数组调用我们的函数，不过这次设置`at_least`值为`12`。为什么是12？因为那是第一个**不**在该区间内的片段。如果我们这样调用，就会得到`4`的结果。这指的是索引4处的片段，即片段13。这是这个味道在3-11区间外的第一个片段。一般来说，要弄清楚某个味道的结束位置，我们可以调用二分查找函数，传入比区间右端大1的`at_least`值。
- en: Now we know where the relevant pieces start (index 1) and where the relevant
    pieces end (just to the left of index 4). If we subtract 1 from 4, we get an answer
    of 3, which is exactly the number of pieces of Flavor 1 in the 3-11 slab.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道相关片段的起始位置（索引1）和结束位置（就在索引4的左边）。如果从4中减去1，我们得到3，这正是3-11区间中Flavor 1的片段数量。
- en: 'Let’s write the code for our binary search function. (Soon, we’ll see the function
    that calls this function twice.) As you learned in “Searching for a Solution”
    on [page 250](ch07.xhtml#sec107), the right way to write a binary search function
    is to first figure out the invariant. Our invariant will have two parts: that
    all values at indices less than `low` are `< at_least`, and that all values at
    indices `high` or greater are `>= at_least`. See [Listing 10-2](ch10.xhtml#ch010ex02)
    for the code. In addition to the aforementioned `pieces` and `at_least` parameters,
    we have a parameter `num_pieces` that gives the number of pieces in the `pieces`
    array.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写二分查找函数的代码。（稍后，我们将看到调用此函数两次的函数。）正如你在《寻找解决方案》中所学到的，在[第250页](ch07.xhtml#sec107)，编写二分查找函数的正确方法是先找出不变式。我们的不变式将包含两部分：所有`low`索引之前的值都小于`<
    at_least`，以及所有`high`或更大的索引上的值都大于等于`>= at_least`。参见[示例10-2](ch10.xhtml#ch010ex02)中的代码。除了前述的`pieces`和`at_least`参数外，我们还有一个参数`num_pieces`，它给出了`pieces`数组中片段的数量。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: Searching for the first satisfying value*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-2：查找第一个满足条件的值*'
- en: We need to make both parts of the invariant true above the loop. For the first
    part, notice that the invariant isn’t making any claim about the value at index
    `low`; it makes a claim only about the values to the left of index `low`. For
    that reason, we can set `low` to `0` above the loop ❶; there’s nothing to the
    left of `low` now, so this part of the invariant is satisfied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在循环之前使不变式的两部分都成立。对于第一部分，注意不变式并没有对`low`索引上的值做任何声明；它仅对`low`左边的值做出声明。因此，我们可以在循环之前将`low`设置为`0`
    ❶；现在`low`左边没有任何值，所以这一部分的不变式得到了满足。
- en: 'For the second part, the invariant claims something about all of the values
    at indices `high` or greater. Since we don’t know anything about any value in
    the array, we need to make this part of the invariant claim nothing. We can do
    this by setting `high` to just beyond the right end of the array ➋: now there
    are no valid indices between `high` and the end of the array.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，不变式对`high`或更大的索引上的所有值进行了声明。由于我们对数组中的任何值都不了解，我们需要让这一部分的不变式声明为空。我们可以通过将`high`设置为数组右端之外的位置来实现
    ➋：这样`high`和数组末尾之间就没有有效索引了。
- en: The code inside the `while` loop maintains the invariant. I encourage you to
    check this for yourself if you like, but you’ve had a lot of binary search practice
    already so I don’t blame you if you’d rather not!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环中的代码保持着不变式。我鼓励你如果愿意，可以自己检查这一点，但你已经有了很多二分查找的练习，所以如果你不想检查，我也不怪你！'
- en: The `while` loop condition ➌ ensures that `low` and `high` are equal when the
    loop terminates. The invariant tells us that all values to the left of `low` are
    too small and that `low` is the first index of the value that’s `>= at_least`.
    This is why we return `low` when the function terminates ➍.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环条件 ➌ 确保当循环终止时，`low`和`high`相等。不变式告诉我们，所有在`low`左边的值都太小，并且`low`是第一个`>=
    at_least`的值的索引。这就是为什么当函数终止时我们返回`low`的原因 ➍。'
- en: Next, as promised, we’re going to make two calls of that function to figure
    out how many pieces of a given flavor are within the range of a given slab. See
    [Listing 10-3](ch10.xhtml#ch010ex03) for the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如之前承诺的，我们将调用该函数两次，以确定某种味道的片段在给定区间内的数量。参见[示例10-3](ch10.xhtml#ch010ex03)中的代码。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Determining number of pieces of a given flavor that are in range*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-3：确定给定口味的块数在范围内的情况*'
- en: Here, the `pieces` parameter is the flavor array, and the `left` and `right`
    parameters indicate the leftmost and rightmost pieces of the slab. The code first
    finds the index in the slab where the flavor starts ❶. Then it finds the index
    immediately to the right of where the flavor ends in the slab ➋. Finally, it subtracts
    the first of these indices from the second to determine the number of pieces of
    the flavor in the slab ➌.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`pieces`参数是口味数组，`left`和`right`参数表示该块的最左和最右边的块。代码首先找到块中口味开始的位置的索引❶。然后找到口味结束位置的右边的索引➋。最后，它从第二个索引中减去第一个索引来确定该块中该口味的块数➌。
- en: '*Guessing Flavors*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*猜测口味*'
- en: 'At this point, we know what to do once we’ve guessed a flavor: use binary search
    to check whether the guessed flavor makes one or both friends happy. Now we need
    to work on the code that makes the guesses.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们已经知道该怎么做：一旦我们猜到一个口味，就用二分查找来检查猜测的口味是否让一位或两位朋友感到高兴。现在我们需要处理生成这些猜测的代码。
- en: 'Our overall strategy can be broken down into three steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整体策略可以分为三个步骤：
- en: '**Step 1**   Figure out the number of pieces that we need to make one friend
    happy.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**   计算出让一位朋友高兴所需要的块数。'
- en: '**Step 2**   Try to make the first friend happy. Start by guessing a piece.
    If the flavor of that piece makes the friend happy, then we are done; otherwise,
    guess again. Keep guessing until we succeed or until we run out of guesses. It’s
    possible for us to find a flavor that’s so prevalent that it makes not just the
    first friend happy, but *both* friends happy. If that happens, we pump out a `YES`
    and stop right there, without doing Step 3.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**   尝试让第一位朋友高兴。首先猜测一块。如果该块的口味让朋友高兴，那么我们完成了；否则，再猜一次。一直猜直到成功或者猜测用完为止。我们有可能找到一个口味，它如此常见，不仅让第一位朋友高兴，还能让*两位*朋友都高兴。如果发生这种情况，我们就输出`YES`并停止，而不执行步骤3。'
- en: '**Step 3**   Try to make the second friend happy using the same strategy that
    we used for the first friend. If we happen to guess the flavor that made the first
    friend happy, then we need to ignore it and move on to our next attempt because
    that flavor isn’t prevalent enough to make both friends happy.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**   尝试使用我们为第一位朋友使用的相同策略来让第二位朋友高兴。如果我们恰好猜到了让第一位朋友高兴的口味，那么我们需要忽略它并继续下一次尝试，因为这个口味并不常见到足以让两位朋友都高兴。'
- en: 'We’ll write the function for the following signature:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为以下签名编写函数：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s what each parameter is for:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个参数的用途：
- en: yokan   The array of Yōkan flavors; `yokan[1]` is the flavor of the first piece,
    `yokan[2]` is the flavor of the second piece, and so on. (We start at index 1
    rather than 0 because the pieces are numbered from 1 in this problem.) We need
    this array so that we can choose a random piece.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: yokan   Yōkan口味的数组；`yokan[1]`是第一块的口味，`yokan[2]`是第二块的口味，依此类推。（我们从索引1开始而不是0，因为在这个问题中，块的编号从1开始。）我们需要这个数组，以便可以选择一个随机的块。
- en: pieces_for_flavor   The array of flavor arrays. Each flavor array is sorted
    from smallest piece number to largest piece number. For example, `pieces_for_flavor[1]`
    might be the array `[1, 5, 6, 9, 13, 14]`, telling us all of the pieces that are
    of Flavor 1\. We need these arrays so that we can binary search them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pieces_for_flavor   口味数组的数组。每个口味数组都按从小到大的块编号排序。例如，`pieces_for_flavor[1]`可能是数组`[1,
    5, 6, 9, 13, 14]`，表示所有的口味1的块。我们需要这些数组，以便能够进行二分查找。
- en: num_of_flavor   An array giving the number of pieces of each flavor; `num_of_flavor[1]`
    is the number of pieces of Flavor 1, `num_of_flavor[2]` is the number of pieces
    of Flavor 2, and so on. That is, this array tells us how many elements are in
    each of the flavor arrays.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: num_of_flavor   给出每个口味块数的数组；`num_of_flavor[1]`是口味1的块数，`num_of_flavor[2]`是口味2的块数，依此类推。也就是说，这个数组告诉我们每个口味数组中有多少元素。
- en: left   The beginning index of the current query.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: left   当前查询的起始索引。
- en: right   The ending index of the current query.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: right   当前查询的结束索引。
- en: The code for this function is in [Listing 10-4](ch10.xhtml#ch010ex04). Look
    out for the three steps—figure out the happy threshold, make the first friend
    happy, make the second friend happy—as you read through the code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码在[列表10-4](ch10.xhtml#ch010ex04)中。阅读代码时要注意三个步骤——找出使朋友高兴的临界值，首先让第一位朋友高兴，然后让第二位朋友高兴。
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-4: Solving the problem*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-4：解决问题*'
- en: For Step 1, we determine the number of pieces that will make a friend happy
    ❶.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 1 步，我们确定使朋友开心的块的数量 ❶。
- en: For Step 2, we start guessing flavors for the first friend ➋. The `for` loop
    uses a `NUM_ATTEMPTS` constant that we haven’t defined yet. We’ll decide on this
    number after we finish walking through this function. In the `for` loop, we choose
    a random piece from the current slab ➌, then call our `num_in_range` helper function
    to get the number of pieces in the slab that have the same flavor as that random
    piece ➍.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 2 步，我们开始为第一个朋友猜测口味 ➋。`for` 循环使用了一个尚未定义的 `NUM_ATTEMPTS` 常量。我们将在完成这个函数的讲解后再决定这个数字。在
    `for` 循环中，我们从当前的 Yōkan 块中选择一个随机块 ➌，然后调用我们的 `num_in_range` 辅助函数，获取该块中与随机块相同口味的块的数量
    ➍。
- en: 'Did our random flavor make one or both of the friends happy? We first check
    whether the flavor was so prevalent that it makes both friends happy. Specifically,
    if the flavor shows up 2/3 of the time (that is, twice the threshold value), it
    can be used to make both friends happy ➎. In this case, we’re done: we just output
    `YES` and return. If the flavor doesn’t make both friends happy, it might still
    be good enough to make the first friend happy, so we check for that next ➏. We
    also record the flavor that we found for the first friend ❼.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的随机口味是否让一个或两个朋友开心？首先，我们检查该口味是否如此普遍，以至于能让两个朋友都开心。具体来说，如果该口味出现的频率为 2/3（也就是两倍的阈值），那么它可以用来让两个朋友都开心
    ➎。这样的话，我们就完成了：我们直接输出`YES`并返回。如果这个口味没有让两个朋友都开心，它可能仍然足够让第一个朋友开心，所以我们接下来检查这一点 ➏。我们还记录下为第一个朋友找到的口味
    ❼。
- en: If in all our guessing we weren’t able to find a flavor for the first friend,
    then we output `NO` and stop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在所有的猜测中，我们未能为第一个朋友找到口味，那么我们输出`NO`并停止。
- en: If we were able to find a flavor for the first friend, then we proceed to Step
    3 ❽, where we try to find a flavor for the second friend. The logic is quite similar
    to what we did for the first friend. The only addition is to ensure that we don’t
    inadvertently use the flavor that we already used for the first friend ❾.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为第一个朋友找到了口味，那么我们继续进行第 3 步 ❽，尝试为第二个朋友找到口味。这个逻辑和我们为第一个朋友所做的非常相似。唯一的不同是要确保我们不会不小心使用已经为第一个朋友使用过的口味
    ❾。
- en: If we get to the bottom of the function, it means that we weren’t able to find
    a flavor for the second friend. We output `NO` in this case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达函数的底部，意味着我们未能为第二个朋友找到口味。在这种情况下，我们输出`NO`。
- en: '*How Many Attempts Do We Need?*'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*我们需要多少次尝试？*'
- en: Let’s finally answer the question of how many attempts we need to ensure a ridiculously
    high probability of success.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回答需要多少次尝试才能确保极高的成功概率。
- en: We’ll assume that each query asks about a slab of the Yōkan where exactly one
    third of the pieces are of some flavor *x*, exactly one third are of some other
    flavor *y*, and the rest of the pieces are distributed among a bunch of other
    flavors. That will be the hardest type of query of all for us. We may get lucky
    and run into a query where one flavor shows up 50 percent or 70 percent or 85
    percent of the time, and for those we’ll have an easier time with our guessing.
    But we’re focusing on the hardest type of query because if we can nail that one,
    then we know that we can nail any others.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个查询询问的是一个 Yōkan 的块，其中恰好三分之一的块是某种口味 *x*，另三分之一是另一种口味 *y*，其余的块则分布在其他各种口味之间。这将是我们面临的最难的查询类型。我们可能会碰巧遇到一个查询，其中某种口味出现了
    50%、70% 或 85% 的时间，对于这些情况，我们的猜测会更容易一些。但我们专注于最难的查询类型，因为如果我们能解决这个，那么我们就知道其他的查询也能解决。
- en: Don’t worry if you haven’t worked with probability before. A *probability* is
    just a value in the range 0 to 1\. If something has a probability of 0 then it
    never occurs; if something has a probability of 1 then it occurs every time. You
    can multiply a probability value by 100 to turn it into a percentage. For example,
    when tossing a coin there is a 0.5 probability that it comes up heads; multiplied
    by 100, we see it equivalently has a 0.5 × 100 = 50 percent chance of coming up
    heads. We need a couple of other rules of probability as well, but I’ll explain
    those as we go along.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心如果你以前没有做过概率相关的工作。*概率*只是一个在 0 到 1 之间的值。如果某件事的概率是 0，那么它永远不会发生；如果某件事的概率是 1，那么它每次都会发生。你可以将概率值乘以
    100 来转换成百分比。例如，当抛硬币时，正面朝上的概率是 0.5；乘以 100，我们就可以看到它有 0.5 × 100 = 50% 的机会正面朝上。我们还需要一些其他的概率规则，但我会在之后解释这些。
- en: 'Let’s just pick a number of guesses out of nowhere and see how well we do.
    How about 10? We’ll first figure out the probability that we make the first friend
    happy. On our first guess, we have a 2/3 probability of success. That’s because
    2/3 of the pieces in the slab are of one of the two flavors that each show up
    1/3 of the time. What’s our probability of failure? There are only two outcomes
    here: success and failure. They have to add up to 1, because there’s a 100 percent
    chance that one of these two outcomes happens. So we can find the probability
    of failure by subtracting the probability of success from 1\. That gives us a
    1 – 2/3 = 1/3 probability of failure.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the probability of failure on all 10 guesses? For that to happen, we
    need to have failed on each guess independently. There’s a 1/3 probability that
    we fail on the first guess, a 1/3 probability that we fail on the second guess,
    a 1/3 probability that we fail on the third guess, and so on. There’s a rule that
    we can use here to figure out the probability that we fail on all of these 10
    independent guesses: just multiply all of the probabilities together. We see that
    the probability of failing on all 10 guesses is (1/3)^(10), which is about 0.000017.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are able to calculate our probability of success for this friend: 1
    – 0.000017 = 0.999983.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This is a better-than-99.99 percent probability of success. We’re doing great!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: What’s the probability that we make the second friend happy given that we made
    the first friend happy? For this one, the probability of success on each attempt
    is 1/3, not 2/3, because the pieces of the first friend’s flavor are gone. If
    you run through the calculation starting with 1/3 rather than 2/3, you should
    find a probability of success for the second friend of about 0.982658\. That’s
    over 98.2 percent! We’re still looking good.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: It’s nice that we now have both the probability of success for the first friend
    and the probability of success for the second friend given success on the first
    friend. But what we care about more is the probability of success for both friends.
    To find that, we can multiply our two success probabilities together. Doing so,
    we find that the overall probability of making both friends happy is 0.999983
    × 0.982658 = 0.982641.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: This probability is more than 98.2 percent. Pretty good, right? Unfortunately,
    no. If we had to process one query, then this probability would be just fine.
    But we may need to process a massive 200,000 queries. And we need to get every
    single one of them right. If we get even one wrong, then we fail the test case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you’re throwing a ball into a basket and you have a 98.2 percent probability
    of success on each throw. You throw one ball. That one’s probably going in. Now
    imagine that you throw 100 balls. You’re probably going to botch at least a couple
    of those throws. And if you threw 200,000 balls? Your probability of getting every
    single one into the basket is near 0.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: While 10 attempts was a good try, it isn’t enough. We need more. Through some
    trial and error, I’ve settled on using 60 attempts for each friend. If you run
    through the calculations using 60 guesses instead of 10, you should find a success
    probability for each query of about 0.99999999997.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a lot of 9s! But we need them all because otherwise we’d take a massive
    probability hit when going from 1 query to 200,000\. To find our probability of
    success for 200,000 queries, we can raise our per-query probability of success
    to the power of 200,000: 0.99999999997^(200,000) = 0.999994.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we’ve lost a few 9s. Still, this is a staggeringly high probability,
    and this time it is for the probability that we get every single query right,
    not just one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re finally ready to set our `NUM_ATTEMPTS` constant. Let’s use `60`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Filling the Flavor Arrays*'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re almost ready for the `main` function; we just need one more little helper
    function first.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: That helper function will take `yokan` (the Yōkan array) and `num_pieces` (the
    number of pieces in the Yōkan) and produce the `pieces_for_flavor` flavor arrays
    that we used in the `solve` function. See [Listing 10-5](ch10.xhtml#ch010ex05)
    for the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-5: Filling in the flavor arrays*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The function assumes that each array in `pieces_for_flavor` already has memory
    assigned to it; that’s a responsibility of the `main` function that’s coming up
    next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We use a local `cur_of_flavor` array ❶ to track the number of pieces we’ve found
    so far of each flavor. Inside the `for` loop, we use this array to determine the
    index in which to store the current piece number ➋.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve made it to the `main` function! Check it out in [Listing 10-6](ch10.xhtml#ch010ex06).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-6: The* main *function*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use C’s `rand` function, we need to use the `srand` function to
    initialize the random number generator with a seed. The seed determines the sequence
    of random numbers that are generated. We don’t want to use the same seed every
    time, otherwise we’ll generate the same sequence of numbers each time. What works
    well is to use the current time as the seed so that the random numbers change
    each time we run the program. We do that using C’s `time` function ❶. To use that
    function, you’ll need to add `#include <time.h>` at the top of your program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: There are two important `for` loops here. The first one ➋ fills in the `yokan`
    array and also uses the `num_of_flavor` array to keep track of the number of pieces
    of each flavor. Why do we need to know the number of pieces of each flavor? It’s
    because, without knowing that, we wouldn’t know how big to make each flavor array.
    The second `for` loop ➌ is responsible for allocating memory for the flavor arrays.
    It uses `num_of_flavor` to determine exactly how big each flavor array should
    be ➍.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Following these `for` loops, we call our helper function to fill in the flavor
    arrays whose memory we just allocated ➎.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: And then we’re off to the queries! For each one, we call our `solve` function
    ➏ to print `YES` or `NO` as needed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'If you submit our code to the judge, you should find that it passes all test
    cases within the time limit. If your code is correct and you somehow fail a test
    case, take a screenshot: you’ll probably never see that again.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Randomization
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main types of randomized algorithms. We just learned about one
    of them. Let’s expand on that one here and preview the other.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*Monte Carlo Algorithms*'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type of algorithm that we used to solve Yōkan, where there’s a chance that
    we get the answer wrong, is called a *Monte Carlo Algorithm*. The key question
    when using such an algorithm is: How many attempts should we use? There’s a tradeoff
    between the number of attempts and the probability of success: as we crank up
    the number of attempts, we increase the probability of success but slow down the
    algorithm. We generally want to find a sweet spot where the probability of success
    is high enough but our algorithm is still fast. Of course, what counts as a “high
    enough” probability of success depends on what we’re using the algorithm for.
    Solving a programming competition problem? Ninety-nine percent probability of
    success is fine. (If the algorithm fails, who cares: just run it again.) For algorithms
    that impact the health and safety of people, though, 99 percent is not okay.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In our solution to Yōkan, if we answer `YES`, then we’re guaranteed to be correct.
    We only answer `YES` when we’re staring at the very flavors that show why the
    friends are happy with the slab. By contrast, if we answer `NO`, then we might
    be wrong. It might be the case that the friends aren’t happy with the slab—but
    it could also be that we just got unlucky and kept picking bad flavors. Because
    only one of the two types of answers can be wrong, we say that our algorithm has
    *one-sided errors*. There are Monte Carlo algorithms that can be wrong in both
    the “yes” and “no” cases; those are said to have *two-sided errors*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: A Monte Carlo algorithm helped us solve Yōkan because the probability of randomly
    finding a useful flavor is so high. It might not seem that a 1/3 or 2/3 probability
    of success is that great, and indeed an algorithm that worked only one-third or
    two-thirds of the time wouldn’t cut it. But remember that these probabilities
    are only our starting point. By the time we’re done with our repeated attempts,
    we’ll have converted that wonderful per-attempt probability to a wonderful per-answer
    probability.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo algorithms are useful for other problems as well. Consider a graph
    with *n* nodes and imagine dividing the nodes into two groups. There are about
    2*^n* ways to make this division, because for each of the *n* nodes we have two
    options for where to put it. Such a division of nodes into two groups is called
    a *cut*. The *minimum cut problem* asks which of these 2*^n* divisions has the
    fewest edges that cross from one group to the other. Now, if we just randomly
    chose a cut, we’d have a per-attempt probability of success of 1/2*^n*, which
    is terrible and not a promising start to a Monte Carlo algorithm. There *is* a
    Monte Carlo algorithm for this problem, though, and it hinges on the surprising
    fact that the per-attempt probability of success can be driven up to 1/*n*². Relative
    to 1/2*^n*, a probability of success of 1/*n*² is high indeed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: If you can find a way to come up with a “surprisingly high” per-attempt probability
    of success, then you’re well on your way to developing a useful Monte Carlo algorithm.
    Just crank up the number of attempts until you get the overall probability of
    success that you want.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '*Las Vegas Algorithms*'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A Monte Carlo algorithm is always fast and almost always correct. A *Las Vegas
    Algorithm*, by contrast, is always correct and almost always fast. (These algorithms
    were given casino-related names to evoke the idea of gambling: with a Monte Carlo
    algorithm we’re gambling with correctness, and with a Las Vegas algorithm we’re
    gambling with speed.)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we had an algorithm that was quite fast for the vast majority of test
    cases but quite slow for the few remaining test cases. We might be okay to deploy
    this algorithm; we just have to hope that the Achilles’ heel test cases don’t
    happen very often.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: But we can do better than that, and one way is through the use of a Las Vegas
    algorithm. In such an algorithm, we randomize the decisions that the algorithm
    makes as it runs. Because the algorithm has no fixed sequence of steps, no one
    can craft a test case that’ll reliably slow it down because no one knows what
    decisions the algorithm will make on that test case!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Why can Las Vegas algorithms be effective? I like Ethan Epperly’s article “Why
    Randomized Algorithms?” (see *[https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/](https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/)*).
    Suppose you were playing many rounds of Rock Paper Scissors against your friend.
    One approach would be to use a fixed pattern, like rock, paper, scissors, rock,
    paper, scissors, rock, paper . . . This might work for a little while—but eventually
    your friend will figure out what you’re doing, and then you’ll never win a round
    again. They’ll just keep picking the option that beats you. A better approach
    is to randomly decide what to do on each round. If you do that, you’re using a
    Las Vegas algorithm. Your friend will have no clue what’s coming next! In our
    code for such an algorithm, we’ll randomize the choices that we make so that no
    fixed test case can force us into poor performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Way back in [Chapter 1](ch01.xhtml), we solved two problems using hash tables.
    In each one, we chose one specific hash function and just went for it. A malicious
    actor could bring those solutions to a crawl by intentionally causing a huge number
    of hash collisions. It’s possible to address that through a Las Vegas algorithm:
    rather than committing to a single hash function for all of time, sitting there
    waiting for someone to figure out what we’re doing, we let our program randomly
    choose which hash function to use each time it runs. Doing so is called *random
    hashing*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Random hashing is a frequently used Las Vegas algorithm. But there’s one Las
    Vegas algorithm used even more frequently than that. We’re going to see that one
    in Problem 2\. First, let’s talk about whether we really do need randomization
    in the first place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '*Deterministic vs. Randomized Algorithms*'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *deterministic algorithm* is an algorithm that doesn’t use randomness. Every
    algorithm we looked at in the first nine chapters of this book is a deterministic
    algorithm, and wow did we get a lot of mileage from those. Why not just forget
    about randomized algorithms and stick with deterministic ones, then? Why play
    around with guessing stuff and getting a 99.9999 percent probability of success
    when we can just have 100 percent success with a deterministic algorithm?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that a fast randomized algorithm can be easier to develop than
    a fast deterministic algorithm. If you’re interested, you might try solving Yōkan
    without using randomization. It’s certainly possible but requires additional ideas
    not needed in the randomized algorithm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: There are problems where the efficiency gulf between the currently best randomized
    algorithm and the currently best deterministic algorithm is huge. For example,
    to determine whether a number is prime, there’s a randomized algorithm that runs
    in *O*(*n*²) time, but the best we’ve been able to do in terms of deterministic
    algorithms is *O*(*n*⁶).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, it’s difficult to find a way to quickly solve our next problem with
    a deterministic algorithm. Good thing we don’t have to. Let’s do some more randomization!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Caps and Bottles'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is DMOJ problem `cco09p4`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have *n* caps and *n* bottles. Each cap and bottle has a unique size, and
    there is exactly one cap that perfectly fits each bottle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to match the caps to their corresponding bottles. (I’ve seen this
    problem alternately phrased as matching nuts and bolts, keys and locks, hats and
    people’s heads, you name it. Feel free to use one of these if it works as a better
    visual for you.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The caps and bottles have very similar sizes, so we cannot make comparisons
    between two caps or between two bottles. The only thing we can do is try to put
    a cap on a bottle to learn whether the cap is too small, the right size, or too
    big for the bottle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, we interact with the judge by making queries and progressively
    reporting our answer until we are done. (It’s kind of like how we interacted with
    the judge when solving Cave Doors in [Chapter 7](ch07.xhtml), but here we communicate
    with the judge by using input and output rather than by calling functions.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because input and output are interleaved in this problem, we’ll look at them
    together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: To start, we read the integer *n*, which tells us the number of caps and bottles
    that we must match. *n* is between 1 and 10,000\. The caps are numbered from 1
    to *n*, as are the bottles.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: After reading *n*, we can interact with the judge in two ways.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Query**   We can make a query by outputting `0 cap_num bottle_num`. This
    asks the judge to tell us about the relationship between the cap numbered `cap_num`
    and the bottle numbered `bottle_num`. We need to read from the input to get the
    answer to our query. We’ll get a –1 if the cap is too small for the bottle, a
    0 if it matches the bottle, or a 1 if it’s too big for the bottle.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Report**   We can tell the judge part of our answer by outputting `1 cap_num
    bottle_num`, which means that we are matching the cap numbered `cap_num` with
    the bottle numbered `bottle_num`. The judge doesn’t produce anything for us to
    read in response.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We need to eventually make *n* reports to the judge in order to match each of
    the *n* caps with some distinct bottle. We can mix and match queries and reports
    as we prefer; that is, there’s no requirement to make all queries before all reports
    or anything like that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We are allowed to make at most 500,000 queries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving a Subtask*'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For most problems in this book, we read from standard input, do what the problem
    asks, and output the answer on standard output. Oftentimes, such as for each problem
    in the previous chapter, what we read from standard input are operations that
    tell us what to do next. The interaction for this Caps and Bottles problem is
    a little different. Rather than being asked to respond to queries, we are the
    ones making the queries to the judge.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The last time we had a nonstandard interaction with the judge was when we solved
    Cave Doors in [Chapter 7](ch07.xhtml). There, we first solved a small subtask,
    rather than the whole problem, to give us confidence that we were interacting
    correctly. Let’s start that way here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The first subtask for this problem guarantees that *n* will be at most 700\.
    The first algorithm that we come up with might make a lot of queries; the hope
    is that with only 700 caps and bottles we’ll be able to pass at least those test
    cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We need to figure out which bottle goes with each cap. Well, why not go through
    the caps one by one, and just ask about each bottle for each cap? If we do that,
    we get the code in [Listing 10-7](ch10.xhtml#ch010ex07).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-7: Solving subtask 1*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we’ve got the interaction right. We start by reading the value
    of `n` ❶, which tells us how many caps and bottles we’re dealing with. Then we
    have a double `for` loop that considers matching each cap with each bottle. For
    each such cap-bottle pair, we query the judge ➋. We know that the judge will then
    produce a response, so we read that next ➌. If we’ve found a match, we tell the
    judge about it ➍.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit of a mind-bend to test this program locally, but let’s do it anyway.
    We need to play the role of the judge, responding consistently to the queries
    that the program makes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work through a test case with three caps and bottles. To “play judge,”
    we need to settle on some sizes for the caps and bottles so that we can respond
    consistently to the queries. The program will never know what these sizes are,
    but as the judge we need them so that we know whether a cap is too small or too
    large. Let’s agree that the cap sizes are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg392-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'and that the bottle sizes are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg392-02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: If the program handles this test case correctly, it will match Cap 1 with Bottle
    2, Cap 2 with Bottle 1, and Cap 3 with Bottle 3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Run our program. Type `3` from the keyboard to indicate that `n` is `3`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Now the program starts making queries. You’ll see those show up as part of the
    program’s output. The first one is `0 1 1`, which is asking us for the relationship
    between Cap 1 and Bottle 1\. Cap 1 (size 23) is smaller than Bottle 1 (size 85),
    so we need to type `-1` here. Go ahead—and once you do, we’ll be asked another
    query.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The next query we get is `0 1 2`, which asks us about Cap 1 and Bottle 2\. This
    cap and bottle match, so type `0`. The program correctly reports that Cap 1 and
    Bottle 2 are matched.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our program has figured out how to match Cap 1, it should move on
    to Cap 2\. That’s exactly what it does, as we can see from the next query: `0
    2 1`. Cap 2 and Bottle 1 match, so we need to type `0` in response. The program
    now correctly reports a match between Cap 2 and Bottle 1.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: All the program has to figure out now is what to do with Cap 3\. It asks the
    query `0 3 1`, to which we must type `-1` because Cap 3 is smaller than Bottle
    1\. Then it asks `0 3 2`, and again we type `-1`. Finally, we get the query `0
    3 3`; as Cap 3 and Bottle 3 match, we type `0`. When we do so, the program should
    correctly report that Cap 3 is matched with Bottle 3 . . . and we’re done! The
    program has successfully matched the caps and bottles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge, you should pass a few test cases.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The reason we don’t pass more is because of the requirement that we make at
    most 500,000 queries. We can tell from our nested `for` loops that we have an
    *O*(*n*²) algorithm here. With 10,000 caps and bottles, we might make up to 10,
    000² = 100,000,000 queries. That’s way too many! We’ll need new ideas to complete
    the remaining subtasks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we stay with our idea of choosing a cap and then figuring out which bottle
    matches it, we need to make better use of the information that the judge gives
    us.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Piles of Caps and Bottles
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the algorithm that we used to solve the subtask, we ask the judge about the
    relationship between Cap 1 and Bottle 1, Cap 1 and Bottle 2, Cap 1 and Bottle
    3, and so on, until we find the bottle that matches Cap 1\. Maybe we finally find
    the match with bottle 5,000\. That was a lot of work! For the cost of 5,000 queries,
    we match one cap and one bottle, and that’s all we get. We’re back to square one
    for the next cap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We’re throwing away a lot of information on our way to matching that first cap,
    though, and that’s information we can use to make it easier for us to match other
    caps later. In particular, so far we’re not doing anything with the “too small”
    and “too big” information that the judge gives us.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were doing this by hand, how could you use this information from the
    judge? One thing you might do is form two piles of bottles: one of small bottles
    and one of big bottles. suppose we find that Cap 1 is too small for Bottle 1\.
    Throw that bottle into the big pile. Then maybe we find that Cap 1 is too big
    for Bottle 2\. That bottle goes into the small pile. Cap 1 is too big for Bottle
    3? That bottle goes into the small pile, as well. Do this for every bottle.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Now what we have are two piles of bottles. Maybe these are subproblems? The
    hope is that we could solve each subproblem and thereby solve the original problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This may feel like the setup to a dynamic-programming solution. But it’s not,
    because the two subproblems are not overlapping. Solving one of them doesn’t help
    us at all with the other one. Recursion, then? Can we use that?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'For recursion to work, we need each subproblem to be a smaller version of the
    original problem. Our original problem had a bunch of caps and bottles. But, so
    far, our subproblems have only bottles. Where are the caps to go with those bottles?
    We need to find a way to split the caps into small caps and large caps, too. Once
    we do that, we’ll truly have our two subproblems: one for the small caps and bottles
    and one for the big caps and bottles.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Here are the overall steps that we’ll use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**   Choose a cap for our subproblem.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**   Go through the bottles. If the cap is smaller than the bottle,
    put the bottle in the pile of big bottles; if the cap is bigger than the bottle,
    put the bottle in the pile of small bottles. At some point during this step, we’re
    going to find the bottle that matches the cap. Call this the *matching bottle*.
    Report the match between the cap and the matching bottle.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: At the end of Step 2, we’ll have the two piles of bottles that we need. Now
    for the caps . . .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**   Go through the caps. If the current cap is smaller than the matching
    bottle, put the cap in the pile of small caps; if the current cap is bigger than
    the matching bottle, put the cap in the pile of big caps. At the end of this step,
    we’ll have the two piles of caps that we need.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**   Recursively solve the subproblem on the small caps and small bottles.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**   Recursively solve the subproblem on the big caps and big bottles.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Like binary search, this is an example of a divide and conquer algorithm. We’re
    dividing the caps and bottles into smaller, independent subproblems and then conquering
    each of those subproblems recursively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There’s a bit of setup we need to do before we can implement our algorithm;
    let’s get that out of the way first. See [Listing 10-8](ch10.xhtml#ch010ex08)
    for our `main` function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-8: The* main *function*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important arrays here: `cap_nums` and `bottle_nums` ❶. We will
    initialize these arrays so that they contain all cap numbers ➋ and all bottle
    numbers ➌, respectively. This is our starting point for the caps and bottles that
    we’re working with. In the code that we’ll see next, we’ll be making recursive
    calls on smaller subsets of those caps and bottles.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Our Algorithm
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s turn our five-step algorithm into code. See [Listing 10-9](ch10.xhtml#ch010ex09).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-9: Solution 1*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Prior to our code that implements our five steps, we have some `malloc` calls.
    We need those so that we have memory for the piles of caps and bottles that we’ll
    form.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: For Step 1, we must choose a cap. We can make that easy if we just choose the
    first cap. Yeah, let’s just do that ❶ and move on. Nothing to see here.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: For Step 2, we use a `for` loop to go through all of the bottles ➋. For each
    cap, there are three possibilities for the if statement inside this loop. In the
    first, we find a match ➌, so we tell the judge about the match and remember the
    matching bottle for later. In the second, the cap is too small for the bottle,
    so we throw the bottle into the pile of big bottles. In the third, the cap is
    too big for the bottle, so we throw the bottle into the pile of small bottles.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is similar to Step 2, but this time we go through all of the caps ➍ rather
    than all of the bottles. If the cap is too small for the bottle, we throw the
    cap into the pile of small caps. If the cap is too big for the bottle, we throw
    the cap into the pile of big caps. Be careful not to mix these up! It’s easy to
    mess up a `-1` or a `1` and throw caps or bottles in the wrong piles.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For Step 4, we solve the “small caps and small bottles” subproblem with a recursive
    call ➎.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: And finally, for Step 5, we solve the “big caps and big bottles” subproblem
    through another recursive call ➏.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Get the small stuff in one subproblem, get the big stuff in another
    subproblem, and solve both subproblems recursively. Pretty slick, right? . . .
    Right?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately it isn’t quite slick enough. If you submit our code to the judge,
    you will find that it times out before passing all test cases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We are very close to nailing this problem, though. All we need to add is randomization.
    Why is our current solution not quite there? And how will randomization fix it?
    Those answers are next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Adding Randomization*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we see how to add randomization, let’s understand exactly the kind of
    test case that defeats Solution 1.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Why Solution 1 Is Slow
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Each call of our `solve` function operates on some caps and some bottles. Our
    choice of cap splits the caps and bottles into two groups: the group with the
    small caps and bottles and the group with the big caps and bottles. No matter
    which cap we choose, we get this correct behavior.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: That said, the cap we choose does have a major impact on the number of queries
    that we’ll need to solve the problem. The algorithm that we used to solve the
    subtask ([Listing 10-7](ch10.xhtml#ch010ex07)) was an *O*(*n*²) algorithm, and
    it was too slow. So to offer an explanation for why Solution 1 is too slow, what
    we can do is demonstrate that it, too, has test cases on which it takes *O*(*n*²)
    time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The test case we’ll use may intuitively feel like it should be an easy one.
    But that intuition is wrong.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'As always for this problem, we’ll have *n* caps and *n* bottles. The sizes
    of the caps will increase from Cap 1 to Cap *n*. For example, we can say that
    Cap 1 has size 1, Cap 2 has size 2, Cap 3 has size 3, and so on. Let’s do similarly
    for the bottles: Bottle 1 has size 1, Bottle 2 has size 2, Bottle 3 has size 3,
    and so on.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now, what will our Solution 1 algorithm do? On the first call of `solve`, it
    will choose Cap 1 on which to split the caps and bottles. It’ll loop through the
    caps, which costs *n* queries, and then it’ll loop through the bottles, which
    costs another *n* queries. So that’s 2*n* queries so far. And what of our subproblems?
    Do they have similar sizes or are they very lopsided?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: They are lopsided! There are no caps or bottles that are smaller than the chosen
    cap. So the “smaller caps and bottles” subproblem is empty. The “bigger caps and
    bottles” subproblem, then, has everything—all remaining *n* – 1 caps and bottles.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens on that subproblem with *n* – 1 caps and bottles? Again, we’re
    going to pick the first cap, which is Cap 2 this time. We’ll make *n* – 1 queries
    as we make our way through the first `for` loop and then another *n* – 1 queries
    as we make our way through the second loop. That’s 2(*n* – 1) queries for this
    subproblem. And, again, the two subproblems stemming from this one are as lopsided
    as can be: an empty subproblem and a subproblem with *n* – 2 caps and bottles.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is very similar to the one on [page 307](ch08.xhtml#sec129)
    that clobbered us when we were solving Building Treaps. In each case, we were
    hoping for a nice, even split of our problem into two subproblems. When we don’t
    get that, we end up doing a quadratic amount of work. Here, we’ll make 2*n* queries,
    then 2(*n* – 1) queries, then 2(*n* – 2) queries, and so on. The total number
    of queries we’ll make is 2(1 + 2 + 3 + . . . + *n*), which is *O*(*n*²).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Darn! All of that fancy splitting and recursing, and yet we’re still stuck at
    *O*(*n*²).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: What We Will Randomize
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In Solution 1, we chose the first cap and split our problem around it. That
    first cap determines what counts as “small” and “big.” As we just saw, if that
    cap does a poor job of splitting, then our algorithm can be quadratic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder whether we can avoid that poor behavior by making a “smarter”
    choice of cap. Maybe we should have chosen the rightmost cap? Unfortunately not:
    the test case from the prior subsection would wreck that, too. Maybe we should
    have chosen the cap in the middle? Sure, but then someone could craft a test case
    where the middle caps are always the smallest caps. Then we’d be back to quadratic
    land again.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do here is to choose our caps randomly! Each time we need
    a cap, we’ll call `rand` to get it. If we do that, no test case can reliably cause
    poor performance because on each run we’ll make different choices for how the
    algorithm executes. This converts our deterministic algorithm into a Las Vegas
    algorithm.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this use of randomization with the kind of randomization that we used
    when solving Yōkan. In Yōkan, the randomization determined whether we got the
    right answer. In Caps and Bottles, we always get the right answer; the randomization
    determines how fast we get it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Randomization
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need just two changes to Solution 1\. First, we need to add the call of `srand`
    to the `main` function in [Listing 10-8](ch10.xhtml#ch010ex08), just as we did
    when solving Yōkan.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we need to choose a random cap in [Listing 10-9](ch10.xhtml#ch010ex09).
    Rather than choosing the first cap:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'we choose a random one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you make those two changes and submit the updated code to the judge, you
    should find that it passes all test cases. Randomization has done it again!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, in solving this problem we’ve also managed to secretly learn
    one of the most famous algorithms in computer science. Let’s go there next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key idea in our solution to Caps and Bottles is to choose a cap and then
    use that cap to split the problem into two subproblems: one subproblem with the
    small stuff and the other with the big stuff. This idea most famously powers a
    sorting algorithm called *Quicksort*.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementing Quicksort*'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quicksort is one of many algorithms that can be used to sort an array; in practice,
    it’s one of the . . . quickest. In Caps and Bottles, the item that’s used to split
    the problem is a cap; in Quicksort, the value that’s used to split the array is
    called the *pivot*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The code for Quicksort is similar to the code we used to solve Caps and Bottles.
    Check it out in [Listing 10-10](ch10.xhtml#ch010ex010).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-10: Quicksort*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We choose a random pivot index ❶ and move the pivot to the left end of the array
    ➋. We want the pivot out of the way like that so that we don’t lose track of it—we’ll
    need to put it in the correct place later.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Next, we go through all of the other values in the array ➌, adding each to `big_values`
    or `small_values` as appropriate. Once that’s done, we make our two recursive
    calls to sort the small values and sort the big values.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do next is paste everything together: first the small values,
    then the pivot, then the big values. We copy the small values to the beginning
    of the `values` array ➍, then copy the pivot ➎, then copy the big values ➏.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see why our solution to Caps and Bottles is so fast. While we’ll
    couch our discussion in terms of Caps and Bottles, what we learn about its runtime
    directly applies to the runtime of Quicksort as well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '*Worst-Case and Expected Runtime*'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our solution to Caps and Bottles is a Las Vegas algorithm. The runtime depends
    on how well each of our randomly chosen caps splits the problem into the two subproblems.
    If we choose terrible cap after terrible cap, we get *O*(*n*²) runtime. But that’s
    the worst-case behavior; the whole reason we introduced randomization was to make
    it extremely unlikely that this would actually happen. Rather than focusing on
    the worst-case runtime of such an algorithm, then, algorithm designers tend to
    focus on the *expected runtime*, which tells us what we can expect to happen in
    practice.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we expect in practice for our randomized solution to Caps and Bottles?
    We already know what happens if we’re shockingly unlucky: we get *O*(*n*²) performance.
    What happens if we’re shockingly lucky, picking caps that perfectly split each
    problem in half?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we’ll choose our cap and make our 2*n* queries, as we always do. If
    that cap perfectly splits the problem in half, then we’ll need to work on two
    subproblems each with *n*/2 caps and bottles. Each of those two subproblems will
    generate 2*n*/2 = *n* queries of their own before they in turn recurse. So those
    two subproblems with *n*/2 caps and bottles will generate 2*n* queries, just like
    our original problem did.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Now, if each subproblem with *n*/2 caps and bottles is split perfectly, then
    we get four problems of size *n*/4\. Each of those four will generate 2*n*/4 =
    *n*/2 queries before they recurse, for a total of 2*n* queries.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we make 2*n* queries for our original problem of size *n*, 2*n*
    queries in total for our subproblems of size *n*/2, 2*n* queries in total for
    our subproblems of size *n*/4, and so on. We can only do this about log *n* times
    before we reach base case subproblems. So, we do 2*n* queries a total of log *n*
    times, for a total of *O*(*n* log *n*) queries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Another way to see this *O*(*n* log *n*) bound is through a *recursion tree*.
    Such a tree characterizes how much work is done in each call of a recursive function.
    When we have perfect splits all the way down, our recursion tree looks like the
    one in [Figure 10-1](ch10.xhtml#ch010fig01).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig01.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: A recursion tree with perfect splits*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each node splits into two nodes below, representing the fact that
    each problem splits into two. The quantity in each node indicates the number of
    queries that are directly made to solve that subproblem. The 2*n* at the top,
    for example, means that the initial call makes 2*n* queries. It’s not saying that
    the total number of queries made in the entire algorithm is 2*n*, only that the
    initial call makes 2*n* queries of its own prior to recursing. Notice that each
    level in this tree—the node at the top, the two nodes below that, and the four
    nodes below those—make a total of 2*n* queries. If we drew the entire tree, it
    would have about log *n* levels in it. In all, then, we have *O*(*n* log *n*)
    queries.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Now, *O*(*n* log *n*) is a wonderful thing, but all I’ve argued so far is that
    this is what happens when the algorithm gets super lucky with perfect splits.
    The algorithm is generally not going to get this lucky, though, just as it’s generally
    not going to get super unlucky with horrible cap choices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the expected runtime is very close to what is predicted by
    the super lucky case rather than the super unlucky case. For example, let’s imagine
    that each time we choose a cap, one subproblem will end up with 90 percent of
    the caps and bottles and the other subproblem will end up with the remaining 10
    percent of the caps and bottles. You might consider that pretty unlucky. But even
    in this case, our algorithm is *O*(*n* log *n*)! Our biggest subproblem would
    go from size *n*, to size *n*/(10/9), to size *n*/(10/9)², and so on. That is,
    rather than dividing by 2 each time, we’re dividing by 10/9\. How many times do
    we need to do this to get down to a base case? It’s still logarithmic! The base
    of the log changes—it goes from log[2] to log[10/9]—but it’s still log. Yes: even
    if we get *this* unlucky, we’re still not going to hit *O*(*n*²).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I teach randomization in my algorithms classes, I often have at least a
    few flummoxed students. “Really, Dan? Picking random numbers? This feels like
    the kind of thing I would have tried *before* learning about real algorithms.”
    But as I hoped I’ve demonstrated in this chapter, randomization is no rookie move.
    Compared to deterministic algorithms, randomized algorithms can be faster and
    easier to design.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.xhtml), I gave this advice: if you see an opportunity to
    use binary search to solve a problem, just do it. Who cares if there’s a slightly
    more efficient solution that doesn’t use binary search. I offer similar advice
    here: if you see an opportunity to use randomization, and you can tolerate the
    randomness in correctness or runtime, just do it. Who cares if there’s a deterministic
    algorithm: even if you can come up with one (which may not be easy!), it’ll probably
    be slower in practice anyway.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yōkan is originally from the 2015 Don Mills Programming Gala programming competition,
    Gold Division. Caps and Bottles is originally from the 2009 Canadian Computing
    Olympiad.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a way to cut down the amount of memory needed by our solution to Caps
    and Bottles. It’s a neat trick that applies to implementations of Quicksort as
    well. Check it out in “Caps and Bottles: In-Place Sorting” in [Appendix B](app02.xhtml).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'For a deep dive into sorting algorithms, I recommend *Compared to What?: An
    Introduction to the Analysis of Algorithms* by Gregory J.E. Rawlins (1991). It’s
    an oldie but a goodie. There are many sorting algorithms: some of them are slow,
    some of them are fast; some of them merge sorted pieces, some of them split and
    sort the pieces. The book compares and contrasts many sorting algorithms. This
    is also the book that originally introduced me to the Caps and Bottles problem.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
