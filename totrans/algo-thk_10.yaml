- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RANDOMIZATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Think back to when we learned about binary search in [Chapter 7](ch07.xhtml).
    Rather than answering the question, “What is the optimal solution?” we instead
    asked, “Is this specific value the optimal solution?” While we were solving the
    Feeding Ants problem, you may have thought that my picking values out of thin
    air was outlandish, wondering how that was going to work at all. But it works
    great, as we now know.
  prefs: []
  type: TYPE_NORMAL
- en: You want something that’s even more outlandish than binary search? How about
    just straight-up guessing a completely random solution. How could that possibly
    work? What is it about specific problems that makes this random guessing a viable
    strategy? And could random guessing still help us solve a problem even if we already
    have a solution? The surprising conclusions await.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 1: Yōkan**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yōkan is a Japanese candy. It’s sweet. It has kind of a jelly or gummy texture.
    Buy a nice big block and cut it into little pieces and pair it with some fruit
    and chill it for a nice refreshing . . . oh, sorry. Back to algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `dmpg15g6`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two friends have found a Yōkan consisting of *n* pieces. The pieces are numbered
    1, 2, . . . , *n*. Each piece of the Yōkan has a specific flavor, and each friend
    will eat only those pieces that are the same flavor.
  prefs: []
  type: TYPE_NORMAL
- en: A slab of Yōkan consists of all of the pieces from Piece *l* to Piece *r*. A
    friend is *happy* with a slab if they can find at least one-third of that slab’s
    pieces that have the same flavor. For example, if a slab has 9 pieces, then a
    friend would need to find 9/3 = 3 pieces of the same flavor. For both friends
    to be happy with the slab, they would each need to find their own one-third of
    pieces that have the same flavor.
  prefs: []
  type: TYPE_NORMAL
- en: The friends will query about various slabs; for each, we need to determine whether
    both of them would be happy with that slab.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of pieces in the Yōkan, and *m*, the number
    of possible piece flavors. *n* and *m* are between 1 and 200,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* integers giving the flavors of the Yōkan pieces from Piece
    1 to Piece *n*. Each integer is a flavor between 1 and *m*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *q*, the number of queries that the friends have. *q* is between
    1 and 200,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* lines, one for each query. Each such line contains the integers *l* and
    *r*, indicating the slab from Piece *l* to Piece *r*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The output for each query is on its own line. For each query:'
  prefs: []
  type: TYPE_NORMAL
- en: If both friends are happy with this slab, output `YES`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, output `NO`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 1.4 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Randomly Choosing a Piece*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Yōkan here has 14 pieces. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg377-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three queries to process. The first query starts at Piece 3 and ends
    at Piece 11\. We’re therefore interested in this slab of the Yōkan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg377-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This slab has 9 pieces, so we want to determine whether each friend can find
    9/3 = 3 pieces of the same flavor. And they can! The first friend could eat 3
    pieces of Flavor 1\. The second friend could eat 3 pieces of Flavor 2\. (There
    are 4 pieces of Flavor 2 there, but that fourth one is overkill for what we need.)
    For this query, we would therefore output `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how we might write code to determine whether the friends are happy
    with this slab. In general, it would be too slow to do this by checking each piece
    in the slab one by one; after all, a slab can have up to 200,000 pieces in it.
    This is a familiar roadblock for us by this point in the book; the usual thing
    to do would be to use some fancy data structure to make the queries fast.
  prefs: []
  type: TYPE_NORMAL
- en: But we’re going to do something far less usual here. I’d like you to look at
    that Yōkan slab again and randomly pick one of its pieces. Pieces of Flavor 1
    and pieces of Flavor 2 are prevalent here, so you may have ended up picking a
    piece of one of those two flavors. If you did, then you just found a way to satisfy
    the first friend. If not, please randomly pick another piece of that Yōkan slab.
    You may have gotten Flavor 1 or Flavor 2 that time. Still no? Then try a third
    time. If you’re choosing randomly, you’re bound to pick Flavor 1 or Flavor 2 within
    a small number of tries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you’ve found Flavor 1 for the first friend. Now, do it again,
    this time for the second friend. It’ll be a little more difficult this time: the
    three Flavor 1 pieces are gone, so you’ll have to land on Flavor 2\. Still, try
    picking a random piece a few times, and I’m sure you’ll eventually pick one of
    Flavor 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program that we’ll write to solve this problem is going to do exactly what
    you just did: picking pieces randomly, trying to find one whose flavor makes each
    friend happy.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the two friends are happy with a given Yōkan slab. This means that
    there’s a single flavor that shows up for 2/3 of the pieces, or two different
    flavors that each show up for 1/3 of the pieces. Regardless, we have a 2/3 chance
    of making the first friend happy by just choosing a piece at random. If we succeed,
    then we’re done with the first friend and we move to the second friend. If we
    fail, well, we’ll just try again, and we’ll have a new 2/3 chance of success.
    If we fail that second time, we’ll try a third time, and a fourth time, until
    we succeed.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll figure out how many attempts we need later. For now, though, I can promise
    that it won’t be very many. The intuition for this can come from a coin-tossing
    experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you were playing a game with a fair coin. If you toss the coin
    and it comes up heads, you win. If you toss the coin and it comes up tails, you
    have to try again. Think of the coin coming up heads as making the friend happy,
    and the coin coming up tails as not making the friend happy and having to try
    again. How many times do you expect to have to toss the coin before it comes up
    heads? Not many, right? If there’s a flavor in the slab that makes a friend happy,
    we’ll toss only so many tails in a row before we find a heads.
  prefs: []
  type: TYPE_NORMAL
- en: We were in the middle of working through a test case before all of that randomizing
    and coin-tossing talk, so let’s finish that before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second query starts at Piece 8 and ends at Piece 11\. The corresponding
    slab is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg378-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the two friends are not happy with this one. Each friend needs
    to find at least 4/3 = ![Image](../images/page_378_1.jpg) pieces of the same flavor;
    as the available number of pieces of each flavor is an integer, what we really
    need is at least 2 pieces of the same flavor. We can do this for the first friend
    with Flavor 2, but we’re stuck for the second friend. We need to output `NO` here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third query starts at Piece 5 and ends at Piece 6\. That’s this part of
    the Yōkan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg378-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each friend needs just one piece of a given flavor. We can therefore use Flavor
    1 to make both friends happy: we can give one piece to the first friend and the
    other to the second friend! The correct output is therefore `YES`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Generating Random Numbers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll need a way to generate random numbers in order to randomly pick Yōkan
    pieces. We’ll use C’s `rand` function to do this.
  prefs: []
  type: TYPE_NORMAL
- en: If we call `rand` with an integer `x`, we’re asking for `rand` to give us one
    of `x` possibilities. Specifically, we’ll get back a random integer in the range
    `0` to `x - 1`. For example, if we call `rand(4)`, we’ll get back a `0`, `1`,
    `2`, or `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we use `rand` to pick a random piece of a slab? Let’s use the term
    *width* to refer to the number of pieces in a slab. For example, the slab from
    Piece 8 to Piece 11 has a width of 4\. In this case, we’d need `rand` to give
    us back `8`, `9`, `10`, or `11`. We can start by calling `rand(4)`, because we
    need `rand` to give us one of four possibilities. That would give us a `0`, `1`,
    `2`, or `3`. This is a good start, but those numbers are not in the right range.
    To fix that, we can just add 8 to move that value into the 8–11 range that we
    need.
  prefs: []
  type: TYPE_NORMAL
- en: In code, generating a random number for a given width `width` and starting point
    `left` can be done as in [Listing 10-1](ch10.xhtml#ch010ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: Randomly choosing a piece*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code carries out the plan that we just outlined: it generates a random
    number from `0` to `width - 1`, then adds the starting point `left` to it ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Determining Number of Pieces*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that we’re working on a particular query. We’re going to choose a random
    piece in that query’s slab. Does the flavor of that piece make one or both of
    the friends happy? To answer that, we’ll need to be able to quickly determine
    how many times that flavor shows up in the slab.
  prefs: []
  type: TYPE_NORMAL
- en: It will therefore be convenient for us to have a sorted array for each flavor
    that gives us the pieces of that flavor. I’ll call such an array a *flavor array*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the Yōkan from our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg379-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The array for Flavor 1 would be `[1, 5, 6, 9, 13, 14]`; the array for Flavor
    2 would be `[4, 7, 10, 11]`; and so on. As promised, each of these arrays is sorted:
    the piece numbers are in order from smallest to largest. We’ll see how to generate
    these flavor arrays later; for now let’s just assume they exist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use such an array to determine the number of pieces of a given flavor
    that lie within a slab. For example, we could use the array `[1, 5, 6, 9, 13,
    14]` to conclude that there are three pieces of Flavor 1 in the 3-11 slab: the
    pieces 5, 6, and 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take stock. We have the query that we want to solve. We have a random
    flavor that we care about checking. We have the flavor array: a sorted array of
    piece numbers of that flavor. And we need to determine how many of those pieces
    are in the range of the query.'
  prefs: []
  type: TYPE_NORMAL
- en: We could do this using a linear search through the flavor array. But that would
    be too slow—a linear amount of work per query.
  prefs: []
  type: TYPE_NORMAL
- en: If you think back to [Chapter 7](ch07.xhtml), you might wonder whether we can
    call on a binary search here. We can indeed, because the array is sorted! Well,
    actually, we’ll need to call binary search twice rather than once, but that won’t
    change the fact that we’ll be able to find what we need in logarithmic time.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to write a binary search function that takes a flavor array `pieces`
    and an integer `at_least` and returns the index of the leftmost value in the array
    that’s greater than or equal to `at_least`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do, we should make sure that the specification of that function actually
    does what we need. To that end, let’s use it to figure out how many pieces of
    Flavor 1 are in the 3-11 slab.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out where the pieces of Flavor 1 begin in that slab, we can call our
    function with the array `[1, 5, 6, 9, 13, 14]` and an `at_least` value of `3`.
    We’ll get a result of `1`. This tells us that the piece at index 1 is the first
    piece of this flavor whose number is at least 3\. That piece is Piece 5, which
    is indeed the first piece that we’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Where do the pieces of Flavor 1 end in that slab? We can figure that out, too!
    Just call our function with the same array, but this time an `at_least` value
    of `12`. Why 12? Because that’s the first piece *not* in the slab. If we make
    this call, we’ll get a result of `4`. This refers to the piece at index 4, which
    is Piece 13\. That’s the first piece of this flavor that’s not in the 3-11 slab.
    In general, to figure out where a flavor ends, we’ll call our binary search function
    with an `at_least` value that’s 1 larger than the right end of the slab.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know where the relevant pieces start (index 1) and where the relevant
    pieces end (just to the left of index 4). If we subtract 1 from 4, we get an answer
    of 3, which is exactly the number of pieces of Flavor 1 in the 3-11 slab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code for our binary search function. (Soon, we’ll see the function
    that calls this function twice.) As you learned in “Searching for a Solution”
    on [page 250](ch07.xhtml#sec107), the right way to write a binary search function
    is to first figure out the invariant. Our invariant will have two parts: that
    all values at indices less than `low` are `< at_least`, and that all values at
    indices `high` or greater are `>= at_least`. See [Listing 10-2](ch10.xhtml#ch010ex02)
    for the code. In addition to the aforementioned `pieces` and `at_least` parameters,
    we have a parameter `num_pieces` that gives the number of pieces in the `pieces`
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: Searching for the first satisfying value*'
  prefs: []
  type: TYPE_NORMAL
- en: We need to make both parts of the invariant true above the loop. For the first
    part, notice that the invariant isn’t making any claim about the value at index
    `low`; it makes a claim only about the values to the left of index `low`. For
    that reason, we can set `low` to `0` above the loop ❶; there’s nothing to the
    left of `low` now, so this part of the invariant is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second part, the invariant claims something about all of the values
    at indices `high` or greater. Since we don’t know anything about any value in
    the array, we need to make this part of the invariant claim nothing. We can do
    this by setting `high` to just beyond the right end of the array ➋: now there
    are no valid indices between `high` and the end of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the `while` loop maintains the invariant. I encourage you to
    check this for yourself if you like, but you’ve had a lot of binary search practice
    already so I don’t blame you if you’d rather not!
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop condition ➌ ensures that `low` and `high` are equal when the
    loop terminates. The invariant tells us that all values to the left of `low` are
    too small and that `low` is the first index of the value that’s `>= at_least`.
    This is why we return `low` when the function terminates ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as promised, we’re going to make two calls of that function to figure
    out how many pieces of a given flavor are within the range of a given slab. See
    [Listing 10-3](ch10.xhtml#ch010ex03) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3: Determining number of pieces of a given flavor that are in range*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `pieces` parameter is the flavor array, and the `left` and `right`
    parameters indicate the leftmost and rightmost pieces of the slab. The code first
    finds the index in the slab where the flavor starts ❶. Then it finds the index
    immediately to the right of where the flavor ends in the slab ➋. Finally, it subtracts
    the first of these indices from the second to determine the number of pieces of
    the flavor in the slab ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '*Guessing Flavors*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, we know what to do once we’ve guessed a flavor: use binary search
    to check whether the guessed flavor makes one or both friends happy. Now we need
    to work on the code that makes the guesses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our overall strategy can be broken down into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**   Figure out the number of pieces that we need to make one friend
    happy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**   Try to make the first friend happy. Start by guessing a piece.
    If the flavor of that piece makes the friend happy, then we are done; otherwise,
    guess again. Keep guessing until we succeed or until we run out of guesses. It’s
    possible for us to find a flavor that’s so prevalent that it makes not just the
    first friend happy, but *both* friends happy. If that happens, we pump out a `YES`
    and stop right there, without doing Step 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**   Try to make the second friend happy using the same strategy that
    we used for the first friend. If we happen to guess the flavor that made the first
    friend happy, then we need to ignore it and move on to our next attempt because
    that flavor isn’t prevalent enough to make both friends happy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write the function for the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what each parameter is for:'
  prefs: []
  type: TYPE_NORMAL
- en: yokan   The array of Yōkan flavors; `yokan[1]` is the flavor of the first piece,
    `yokan[2]` is the flavor of the second piece, and so on. (We start at index 1
    rather than 0 because the pieces are numbered from 1 in this problem.) We need
    this array so that we can choose a random piece.
  prefs: []
  type: TYPE_NORMAL
- en: pieces_for_flavor   The array of flavor arrays. Each flavor array is sorted
    from smallest piece number to largest piece number. For example, `pieces_for_flavor[1]`
    might be the array `[1, 5, 6, 9, 13, 14]`, telling us all of the pieces that are
    of Flavor 1\. We need these arrays so that we can binary search them.
  prefs: []
  type: TYPE_NORMAL
- en: num_of_flavor   An array giving the number of pieces of each flavor; `num_of_flavor[1]`
    is the number of pieces of Flavor 1, `num_of_flavor[2]` is the number of pieces
    of Flavor 2, and so on. That is, this array tells us how many elements are in
    each of the flavor arrays.
  prefs: []
  type: TYPE_NORMAL
- en: left   The beginning index of the current query.
  prefs: []
  type: TYPE_NORMAL
- en: right   The ending index of the current query.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this function is in [Listing 10-4](ch10.xhtml#ch010ex04). Look
    out for the three steps—figure out the happy threshold, make the first friend
    happy, make the second friend happy—as you read through the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-4: Solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: For Step 1, we determine the number of pieces that will make a friend happy
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: For Step 2, we start guessing flavors for the first friend ➋. The `for` loop
    uses a `NUM_ATTEMPTS` constant that we haven’t defined yet. We’ll decide on this
    number after we finish walking through this function. In the `for` loop, we choose
    a random piece from the current slab ➌, then call our `num_in_range` helper function
    to get the number of pieces in the slab that have the same flavor as that random
    piece ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did our random flavor make one or both of the friends happy? We first check
    whether the flavor was so prevalent that it makes both friends happy. Specifically,
    if the flavor shows up 2/3 of the time (that is, twice the threshold value), it
    can be used to make both friends happy ➎. In this case, we’re done: we just output
    `YES` and return. If the flavor doesn’t make both friends happy, it might still
    be good enough to make the first friend happy, so we check for that next ➏. We
    also record the flavor that we found for the first friend ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: If in all our guessing we weren’t able to find a flavor for the first friend,
    then we output `NO` and stop.
  prefs: []
  type: TYPE_NORMAL
- en: If we were able to find a flavor for the first friend, then we proceed to Step
    3 ❽, where we try to find a flavor for the second friend. The logic is quite similar
    to what we did for the first friend. The only addition is to ensure that we don’t
    inadvertently use the flavor that we already used for the first friend ❾.
  prefs: []
  type: TYPE_NORMAL
- en: If we get to the bottom of the function, it means that we weren’t able to find
    a flavor for the second friend. We output `NO` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '*How Many Attempts Do We Need?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s finally answer the question of how many attempts we need to ensure a ridiculously
    high probability of success.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that each query asks about a slab of the Yōkan where exactly one
    third of the pieces are of some flavor *x*, exactly one third are of some other
    flavor *y*, and the rest of the pieces are distributed among a bunch of other
    flavors. That will be the hardest type of query of all for us. We may get lucky
    and run into a query where one flavor shows up 50 percent or 70 percent or 85
    percent of the time, and for those we’ll have an easier time with our guessing.
    But we’re focusing on the hardest type of query because if we can nail that one,
    then we know that we can nail any others.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you haven’t worked with probability before. A *probability* is
    just a value in the range 0 to 1\. If something has a probability of 0 then it
    never occurs; if something has a probability of 1 then it occurs every time. You
    can multiply a probability value by 100 to turn it into a percentage. For example,
    when tossing a coin there is a 0.5 probability that it comes up heads; multiplied
    by 100, we see it equivalently has a 0.5 × 100 = 50 percent chance of coming up
    heads. We need a couple of other rules of probability as well, but I’ll explain
    those as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s just pick a number of guesses out of nowhere and see how well we do.
    How about 10? We’ll first figure out the probability that we make the first friend
    happy. On our first guess, we have a 2/3 probability of success. That’s because
    2/3 of the pieces in the slab are of one of the two flavors that each show up
    1/3 of the time. What’s our probability of failure? There are only two outcomes
    here: success and failure. They have to add up to 1, because there’s a 100 percent
    chance that one of these two outcomes happens. So we can find the probability
    of failure by subtracting the probability of success from 1\. That gives us a
    1 – 2/3 = 1/3 probability of failure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the probability of failure on all 10 guesses? For that to happen, we
    need to have failed on each guess independently. There’s a 1/3 probability that
    we fail on the first guess, a 1/3 probability that we fail on the second guess,
    a 1/3 probability that we fail on the third guess, and so on. There’s a rule that
    we can use here to figure out the probability that we fail on all of these 10
    independent guesses: just multiply all of the probabilities together. We see that
    the probability of failing on all 10 guesses is (1/3)^(10), which is about 0.000017.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are able to calculate our probability of success for this friend: 1
    – 0.000017 = 0.999983.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a better-than-99.99 percent probability of success. We’re doing great!
  prefs: []
  type: TYPE_NORMAL
- en: What’s the probability that we make the second friend happy given that we made
    the first friend happy? For this one, the probability of success on each attempt
    is 1/3, not 2/3, because the pieces of the first friend’s flavor are gone. If
    you run through the calculation starting with 1/3 rather than 2/3, you should
    find a probability of success for the second friend of about 0.982658\. That’s
    over 98.2 percent! We’re still looking good.
  prefs: []
  type: TYPE_NORMAL
- en: It’s nice that we now have both the probability of success for the first friend
    and the probability of success for the second friend given success on the first
    friend. But what we care about more is the probability of success for both friends.
    To find that, we can multiply our two success probabilities together. Doing so,
    we find that the overall probability of making both friends happy is 0.999983
    × 0.982658 = 0.982641.
  prefs: []
  type: TYPE_NORMAL
- en: This probability is more than 98.2 percent. Pretty good, right? Unfortunately,
    no. If we had to process one query, then this probability would be just fine.
    But we may need to process a massive 200,000 queries. And we need to get every
    single one of them right. If we get even one wrong, then we fail the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you’re throwing a ball into a basket and you have a 98.2 percent probability
    of success on each throw. You throw one ball. That one’s probably going in. Now
    imagine that you throw 100 balls. You’re probably going to botch at least a couple
    of those throws. And if you threw 200,000 balls? Your probability of getting every
    single one into the basket is near 0.
  prefs: []
  type: TYPE_NORMAL
- en: While 10 attempts was a good try, it isn’t enough. We need more. Through some
    trial and error, I’ve settled on using 60 attempts for each friend. If you run
    through the calculations using 60 guesses instead of 10, you should find a success
    probability for each query of about 0.99999999997.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a lot of 9s! But we need them all because otherwise we’d take a massive
    probability hit when going from 1 query to 200,000\. To find our probability of
    success for 200,000 queries, we can raise our per-query probability of success
    to the power of 200,000: 0.99999999997^(200,000) = 0.999994.'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we’ve lost a few 9s. Still, this is a staggeringly high probability,
    and this time it is for the probability that we get every single query right,
    not just one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re finally ready to set our `NUM_ATTEMPTS` constant. Let’s use `60`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Filling the Flavor Arrays*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re almost ready for the `main` function; we just need one more little helper
    function first.
  prefs: []
  type: TYPE_NORMAL
- en: That helper function will take `yokan` (the Yōkan array) and `num_pieces` (the
    number of pieces in the Yōkan) and produce the `pieces_for_flavor` flavor arrays
    that we used in the `solve` function. See [Listing 10-5](ch10.xhtml#ch010ex05)
    for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-5: Filling in the flavor arrays*'
  prefs: []
  type: TYPE_NORMAL
- en: The function assumes that each array in `pieces_for_flavor` already has memory
    assigned to it; that’s a responsibility of the `main` function that’s coming up
    next.
  prefs: []
  type: TYPE_NORMAL
- en: We use a local `cur_of_flavor` array ❶ to track the number of pieces we’ve found
    so far of each flavor. Inside the `for` loop, we use this array to determine the
    index in which to store the current piece number ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve made it to the `main` function! Check it out in [Listing 10-6](ch10.xhtml#ch010ex06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-6: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use C’s `rand` function, we need to use the `srand` function to
    initialize the random number generator with a seed. The seed determines the sequence
    of random numbers that are generated. We don’t want to use the same seed every
    time, otherwise we’ll generate the same sequence of numbers each time. What works
    well is to use the current time as the seed so that the random numbers change
    each time we run the program. We do that using C’s `time` function ❶. To use that
    function, you’ll need to add `#include <time.h>` at the top of your program.
  prefs: []
  type: TYPE_NORMAL
- en: There are two important `for` loops here. The first one ➋ fills in the `yokan`
    array and also uses the `num_of_flavor` array to keep track of the number of pieces
    of each flavor. Why do we need to know the number of pieces of each flavor? It’s
    because, without knowing that, we wouldn’t know how big to make each flavor array.
    The second `for` loop ➌ is responsible for allocating memory for the flavor arrays.
    It uses `num_of_flavor` to determine exactly how big each flavor array should
    be ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Following these `for` loops, we call our helper function to fill in the flavor
    arrays whose memory we just allocated ➎.
  prefs: []
  type: TYPE_NORMAL
- en: And then we’re off to the queries! For each one, we call our `solve` function
    ➏ to print `YES` or `NO` as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you submit our code to the judge, you should find that it passes all test
    cases within the time limit. If your code is correct and you somehow fail a test
    case, take a screenshot: you’ll probably never see that again.'
  prefs: []
  type: TYPE_NORMAL
- en: Randomization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main types of randomized algorithms. We just learned about one
    of them. Let’s expand on that one here and preview the other.
  prefs: []
  type: TYPE_NORMAL
- en: '*Monte Carlo Algorithms*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type of algorithm that we used to solve Yōkan, where there’s a chance that
    we get the answer wrong, is called a *Monte Carlo Algorithm*. The key question
    when using such an algorithm is: How many attempts should we use? There’s a tradeoff
    between the number of attempts and the probability of success: as we crank up
    the number of attempts, we increase the probability of success but slow down the
    algorithm. We generally want to find a sweet spot where the probability of success
    is high enough but our algorithm is still fast. Of course, what counts as a “high
    enough” probability of success depends on what we’re using the algorithm for.
    Solving a programming competition problem? Ninety-nine percent probability of
    success is fine. (If the algorithm fails, who cares: just run it again.) For algorithms
    that impact the health and safety of people, though, 99 percent is not okay.'
  prefs: []
  type: TYPE_NORMAL
- en: In our solution to Yōkan, if we answer `YES`, then we’re guaranteed to be correct.
    We only answer `YES` when we’re staring at the very flavors that show why the
    friends are happy with the slab. By contrast, if we answer `NO`, then we might
    be wrong. It might be the case that the friends aren’t happy with the slab—but
    it could also be that we just got unlucky and kept picking bad flavors. Because
    only one of the two types of answers can be wrong, we say that our algorithm has
    *one-sided errors*. There are Monte Carlo algorithms that can be wrong in both
    the “yes” and “no” cases; those are said to have *two-sided errors*.
  prefs: []
  type: TYPE_NORMAL
- en: A Monte Carlo algorithm helped us solve Yōkan because the probability of randomly
    finding a useful flavor is so high. It might not seem that a 1/3 or 2/3 probability
    of success is that great, and indeed an algorithm that worked only one-third or
    two-thirds of the time wouldn’t cut it. But remember that these probabilities
    are only our starting point. By the time we’re done with our repeated attempts,
    we’ll have converted that wonderful per-attempt probability to a wonderful per-answer
    probability.
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo algorithms are useful for other problems as well. Consider a graph
    with *n* nodes and imagine dividing the nodes into two groups. There are about
    2*^n* ways to make this division, because for each of the *n* nodes we have two
    options for where to put it. Such a division of nodes into two groups is called
    a *cut*. The *minimum cut problem* asks which of these 2*^n* divisions has the
    fewest edges that cross from one group to the other. Now, if we just randomly
    chose a cut, we’d have a per-attempt probability of success of 1/2*^n*, which
    is terrible and not a promising start to a Monte Carlo algorithm. There *is* a
    Monte Carlo algorithm for this problem, though, and it hinges on the surprising
    fact that the per-attempt probability of success can be driven up to 1/*n*². Relative
    to 1/2*^n*, a probability of success of 1/*n*² is high indeed.
  prefs: []
  type: TYPE_NORMAL
- en: If you can find a way to come up with a “surprisingly high” per-attempt probability
    of success, then you’re well on your way to developing a useful Monte Carlo algorithm.
    Just crank up the number of attempts until you get the overall probability of
    success that you want.
  prefs: []
  type: TYPE_NORMAL
- en: '*Las Vegas Algorithms*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A Monte Carlo algorithm is always fast and almost always correct. A *Las Vegas
    Algorithm*, by contrast, is always correct and almost always fast. (These algorithms
    were given casino-related names to evoke the idea of gambling: with a Monte Carlo
    algorithm we’re gambling with correctness, and with a Las Vegas algorithm we’re
    gambling with speed.)'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we had an algorithm that was quite fast for the vast majority of test
    cases but quite slow for the few remaining test cases. We might be okay to deploy
    this algorithm; we just have to hope that the Achilles’ heel test cases don’t
    happen very often.
  prefs: []
  type: TYPE_NORMAL
- en: But we can do better than that, and one way is through the use of a Las Vegas
    algorithm. In such an algorithm, we randomize the decisions that the algorithm
    makes as it runs. Because the algorithm has no fixed sequence of steps, no one
    can craft a test case that’ll reliably slow it down because no one knows what
    decisions the algorithm will make on that test case!
  prefs: []
  type: TYPE_NORMAL
- en: Why can Las Vegas algorithms be effective? I like Ethan Epperly’s article “Why
    Randomized Algorithms?” (see *[https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/](https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/)*).
    Suppose you were playing many rounds of Rock Paper Scissors against your friend.
    One approach would be to use a fixed pattern, like rock, paper, scissors, rock,
    paper, scissors, rock, paper . . . This might work for a little while—but eventually
    your friend will figure out what you’re doing, and then you’ll never win a round
    again. They’ll just keep picking the option that beats you. A better approach
    is to randomly decide what to do on each round. If you do that, you’re using a
    Las Vegas algorithm. Your friend will have no clue what’s coming next! In our
    code for such an algorithm, we’ll randomize the choices that we make so that no
    fixed test case can force us into poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Way back in [Chapter 1](ch01.xhtml), we solved two problems using hash tables.
    In each one, we chose one specific hash function and just went for it. A malicious
    actor could bring those solutions to a crawl by intentionally causing a huge number
    of hash collisions. It’s possible to address that through a Las Vegas algorithm:
    rather than committing to a single hash function for all of time, sitting there
    waiting for someone to figure out what we’re doing, we let our program randomly
    choose which hash function to use each time it runs. Doing so is called *random
    hashing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Random hashing is a frequently used Las Vegas algorithm. But there’s one Las
    Vegas algorithm used even more frequently than that. We’re going to see that one
    in Problem 2\. First, let’s talk about whether we really do need randomization
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Deterministic vs. Randomized Algorithms*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *deterministic algorithm* is an algorithm that doesn’t use randomness. Every
    algorithm we looked at in the first nine chapters of this book is a deterministic
    algorithm, and wow did we get a lot of mileage from those. Why not just forget
    about randomized algorithms and stick with deterministic ones, then? Why play
    around with guessing stuff and getting a 99.9999 percent probability of success
    when we can just have 100 percent success with a deterministic algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that a fast randomized algorithm can be easier to develop than
    a fast deterministic algorithm. If you’re interested, you might try solving Yōkan
    without using randomization. It’s certainly possible but requires additional ideas
    not needed in the randomized algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: There are problems where the efficiency gulf between the currently best randomized
    algorithm and the currently best deterministic algorithm is huge. For example,
    to determine whether a number is prime, there’s a randomized algorithm that runs
    in *O*(*n*²) time, but the best we’ve been able to do in terms of deterministic
    algorithms is *O*(*n*⁶).
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, it’s difficult to find a way to quickly solve our next problem with
    a deterministic algorithm. Good thing we don’t have to. Let’s do some more randomization!
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Caps and Bottles'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is DMOJ problem `cco09p4`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have *n* caps and *n* bottles. Each cap and bottle has a unique size, and
    there is exactly one cap that perfectly fits each bottle.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to match the caps to their corresponding bottles. (I’ve seen this
    problem alternately phrased as matching nuts and bolts, keys and locks, hats and
    people’s heads, you name it. Feel free to use one of these if it works as a better
    visual for you.)
  prefs: []
  type: TYPE_NORMAL
- en: The caps and bottles have very similar sizes, so we cannot make comparisons
    between two caps or between two bottles. The only thing we can do is try to put
    a cap on a bottle to learn whether the cap is too small, the right size, or too
    big for the bottle.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, we interact with the judge by making queries and progressively
    reporting our answer until we are done. (It’s kind of like how we interacted with
    the judge when solving Cave Doors in [Chapter 7](ch07.xhtml), but here we communicate
    with the judge by using input and output rather than by calling functions.)
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because input and output are interleaved in this problem, we’ll look at them
    together.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we read the integer *n*, which tells us the number of caps and bottles
    that we must match. *n* is between 1 and 10,000\. The caps are numbered from 1
    to *n*, as are the bottles.
  prefs: []
  type: TYPE_NORMAL
- en: After reading *n*, we can interact with the judge in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Query**   We can make a query by outputting `0 cap_num bottle_num`. This
    asks the judge to tell us about the relationship between the cap numbered `cap_num`
    and the bottle numbered `bottle_num`. We need to read from the input to get the
    answer to our query. We’ll get a –1 if the cap is too small for the bottle, a
    0 if it matches the bottle, or a 1 if it’s too big for the bottle.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Report**   We can tell the judge part of our answer by outputting `1 cap_num
    bottle_num`, which means that we are matching the cap numbered `cap_num` with
    the bottle numbered `bottle_num`. The judge doesn’t produce anything for us to
    read in response.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to eventually make *n* reports to the judge in order to match each of
    the *n* caps with some distinct bottle. We can mix and match queries and reports
    as we prefer; that is, there’s no requirement to make all queries before all reports
    or anything like that.
  prefs: []
  type: TYPE_NORMAL
- en: We are allowed to make at most 500,000 queries.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving a Subtask*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For most problems in this book, we read from standard input, do what the problem
    asks, and output the answer on standard output. Oftentimes, such as for each problem
    in the previous chapter, what we read from standard input are operations that
    tell us what to do next. The interaction for this Caps and Bottles problem is
    a little different. Rather than being asked to respond to queries, we are the
    ones making the queries to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: The last time we had a nonstandard interaction with the judge was when we solved
    Cave Doors in [Chapter 7](ch07.xhtml). There, we first solved a small subtask,
    rather than the whole problem, to give us confidence that we were interacting
    correctly. Let’s start that way here.
  prefs: []
  type: TYPE_NORMAL
- en: The first subtask for this problem guarantees that *n* will be at most 700\.
    The first algorithm that we come up with might make a lot of queries; the hope
    is that with only 700 caps and bottles we’ll be able to pass at least those test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: We need to figure out which bottle goes with each cap. Well, why not go through
    the caps one by one, and just ask about each bottle for each cap? If we do that,
    we get the code in [Listing 10-7](ch10.xhtml#ch010ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-7: Solving subtask 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we’ve got the interaction right. We start by reading the value
    of `n` ❶, which tells us how many caps and bottles we’re dealing with. Then we
    have a double `for` loop that considers matching each cap with each bottle. For
    each such cap-bottle pair, we query the judge ➋. We know that the judge will then
    produce a response, so we read that next ➌. If we’ve found a match, we tell the
    judge about it ➍.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit of a mind-bend to test this program locally, but let’s do it anyway.
    We need to play the role of the judge, responding consistently to the queries
    that the program makes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work through a test case with three caps and bottles. To “play judge,”
    we need to settle on some sizes for the caps and bottles so that we can respond
    consistently to the queries. The program will never know what these sizes are,
    but as the judge we need them so that we know whether a cap is too small or too
    large. Let’s agree that the cap sizes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg392-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and that the bottle sizes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg392-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the program handles this test case correctly, it will match Cap 1 with Bottle
    2, Cap 2 with Bottle 1, and Cap 3 with Bottle 3.
  prefs: []
  type: TYPE_NORMAL
- en: Run our program. Type `3` from the keyboard to indicate that `n` is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Now the program starts making queries. You’ll see those show up as part of the
    program’s output. The first one is `0 1 1`, which is asking us for the relationship
    between Cap 1 and Bottle 1\. Cap 1 (size 23) is smaller than Bottle 1 (size 85),
    so we need to type `-1` here. Go ahead—and once you do, we’ll be asked another
    query.
  prefs: []
  type: TYPE_NORMAL
- en: The next query we get is `0 1 2`, which asks us about Cap 1 and Bottle 2\. This
    cap and bottle match, so type `0`. The program correctly reports that Cap 1 and
    Bottle 2 are matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our program has figured out how to match Cap 1, it should move on
    to Cap 2\. That’s exactly what it does, as we can see from the next query: `0
    2 1`. Cap 2 and Bottle 1 match, so we need to type `0` in response. The program
    now correctly reports a match between Cap 2 and Bottle 1.'
  prefs: []
  type: TYPE_NORMAL
- en: All the program has to figure out now is what to do with Cap 3\. It asks the
    query `0 3 1`, to which we must type `-1` because Cap 3 is smaller than Bottle
    1\. Then it asks `0 3 2`, and again we type `-1`. Finally, we get the query `0
    3 3`; as Cap 3 and Bottle 3 match, we type `0`. When we do so, the program should
    correctly report that Cap 3 is matched with Bottle 3 . . . and we’re done! The
    program has successfully matched the caps and bottles.
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge, you should pass a few test cases.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we don’t pass more is because of the requirement that we make at
    most 500,000 queries. We can tell from our nested `for` loops that we have an
    *O*(*n*²) algorithm here. With 10,000 caps and bottles, we might make up to 10,
    000² = 100,000,000 queries. That’s way too many! We’ll need new ideas to complete
    the remaining subtasks.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we stay with our idea of choosing a cap and then figuring out which bottle
    matches it, we need to make better use of the information that the judge gives
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Piles of Caps and Bottles
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the algorithm that we used to solve the subtask, we ask the judge about the
    relationship between Cap 1 and Bottle 1, Cap 1 and Bottle 2, Cap 1 and Bottle
    3, and so on, until we find the bottle that matches Cap 1\. Maybe we finally find
    the match with bottle 5,000\. That was a lot of work! For the cost of 5,000 queries,
    we match one cap and one bottle, and that’s all we get. We’re back to square one
    for the next cap.
  prefs: []
  type: TYPE_NORMAL
- en: We’re throwing away a lot of information on our way to matching that first cap,
    though, and that’s information we can use to make it easier for us to match other
    caps later. In particular, so far we’re not doing anything with the “too small”
    and “too big” information that the judge gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were doing this by hand, how could you use this information from the
    judge? One thing you might do is form two piles of bottles: one of small bottles
    and one of big bottles. suppose we find that Cap 1 is too small for Bottle 1\.
    Throw that bottle into the big pile. Then maybe we find that Cap 1 is too big
    for Bottle 2\. That bottle goes into the small pile. Cap 1 is too big for Bottle
    3? That bottle goes into the small pile, as well. Do this for every bottle.'
  prefs: []
  type: TYPE_NORMAL
- en: Now what we have are two piles of bottles. Maybe these are subproblems? The
    hope is that we could solve each subproblem and thereby solve the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: This may feel like the setup to a dynamic-programming solution. But it’s not,
    because the two subproblems are not overlapping. Solving one of them doesn’t help
    us at all with the other one. Recursion, then? Can we use that?
  prefs: []
  type: TYPE_NORMAL
- en: 'For recursion to work, we need each subproblem to be a smaller version of the
    original problem. Our original problem had a bunch of caps and bottles. But, so
    far, our subproblems have only bottles. Where are the caps to go with those bottles?
    We need to find a way to split the caps into small caps and large caps, too. Once
    we do that, we’ll truly have our two subproblems: one for the small caps and bottles
    and one for the big caps and bottles.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are the overall steps that we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**   Choose a cap for our subproblem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**   Go through the bottles. If the cap is smaller than the bottle,
    put the bottle in the pile of big bottles; if the cap is bigger than the bottle,
    put the bottle in the pile of small bottles. At some point during this step, we’re
    going to find the bottle that matches the cap. Call this the *matching bottle*.
    Report the match between the cap and the matching bottle.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of Step 2, we’ll have the two piles of bottles that we need. Now
    for the caps . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**   Go through the caps. If the current cap is smaller than the matching
    bottle, put the cap in the pile of small caps; if the current cap is bigger than
    the matching bottle, put the cap in the pile of big caps. At the end of this step,
    we’ll have the two piles of caps that we need.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**   Recursively solve the subproblem on the small caps and small bottles.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**   Recursively solve the subproblem on the big caps and big bottles.'
  prefs: []
  type: TYPE_NORMAL
- en: Like binary search, this is an example of a divide and conquer algorithm. We’re
    dividing the caps and bottles into smaller, independent subproblems and then conquering
    each of those subproblems recursively.
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There’s a bit of setup we need to do before we can implement our algorithm;
    let’s get that out of the way first. See [Listing 10-8](ch10.xhtml#ch010ex08)
    for our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-8: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important arrays here: `cap_nums` and `bottle_nums` ❶. We will
    initialize these arrays so that they contain all cap numbers ➋ and all bottle
    numbers ➌, respectively. This is our starting point for the caps and bottles that
    we’re working with. In the code that we’ll see next, we’ll be making recursive
    calls on smaller subsets of those caps and bottles.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Our Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s turn our five-step algorithm into code. See [Listing 10-9](ch10.xhtml#ch010ex09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-9: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to our code that implements our five steps, we have some `malloc` calls.
    We need those so that we have memory for the piles of caps and bottles that we’ll
    form.
  prefs: []
  type: TYPE_NORMAL
- en: For Step 1, we must choose a cap. We can make that easy if we just choose the
    first cap. Yeah, let’s just do that ❶ and move on. Nothing to see here.
  prefs: []
  type: TYPE_NORMAL
- en: For Step 2, we use a `for` loop to go through all of the bottles ➋. For each
    cap, there are three possibilities for the if statement inside this loop. In the
    first, we find a match ➌, so we tell the judge about the match and remember the
    matching bottle for later. In the second, the cap is too small for the bottle,
    so we throw the bottle into the pile of big bottles. In the third, the cap is
    too big for the bottle, so we throw the bottle into the pile of small bottles.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is similar to Step 2, but this time we go through all of the caps ➍ rather
    than all of the bottles. If the cap is too small for the bottle, we throw the
    cap into the pile of small caps. If the cap is too big for the bottle, we throw
    the cap into the pile of big caps. Be careful not to mix these up! It’s easy to
    mess up a `-1` or a `1` and throw caps or bottles in the wrong piles.
  prefs: []
  type: TYPE_NORMAL
- en: For Step 4, we solve the “small caps and small bottles” subproblem with a recursive
    call ➎.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, for Step 5, we solve the “big caps and big bottles” subproblem
    through another recursive call ➏.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Get the small stuff in one subproblem, get the big stuff in another
    subproblem, and solve both subproblems recursively. Pretty slick, right? . . .
    Right?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately it isn’t quite slick enough. If you submit our code to the judge,
    you will find that it times out before passing all test cases.
  prefs: []
  type: TYPE_NORMAL
- en: We are very close to nailing this problem, though. All we need to add is randomization.
    Why is our current solution not quite there? And how will randomization fix it?
    Those answers are next.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Adding Randomization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we see how to add randomization, let’s understand exactly the kind of
    test case that defeats Solution 1.
  prefs: []
  type: TYPE_NORMAL
- en: Why Solution 1 Is Slow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Each call of our `solve` function operates on some caps and some bottles. Our
    choice of cap splits the caps and bottles into two groups: the group with the
    small caps and bottles and the group with the big caps and bottles. No matter
    which cap we choose, we get this correct behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: That said, the cap we choose does have a major impact on the number of queries
    that we’ll need to solve the problem. The algorithm that we used to solve the
    subtask ([Listing 10-7](ch10.xhtml#ch010ex07)) was an *O*(*n*²) algorithm, and
    it was too slow. So to offer an explanation for why Solution 1 is too slow, what
    we can do is demonstrate that it, too, has test cases on which it takes *O*(*n*²)
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The test case we’ll use may intuitively feel like it should be an easy one.
    But that intuition is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always for this problem, we’ll have *n* caps and *n* bottles. The sizes
    of the caps will increase from Cap 1 to Cap *n*. For example, we can say that
    Cap 1 has size 1, Cap 2 has size 2, Cap 3 has size 3, and so on. Let’s do similarly
    for the bottles: Bottle 1 has size 1, Bottle 2 has size 2, Bottle 3 has size 3,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, what will our Solution 1 algorithm do? On the first call of `solve`, it
    will choose Cap 1 on which to split the caps and bottles. It’ll loop through the
    caps, which costs *n* queries, and then it’ll loop through the bottles, which
    costs another *n* queries. So that’s 2*n* queries so far. And what of our subproblems?
    Do they have similar sizes or are they very lopsided?
  prefs: []
  type: TYPE_NORMAL
- en: They are lopsided! There are no caps or bottles that are smaller than the chosen
    cap. So the “smaller caps and bottles” subproblem is empty. The “bigger caps and
    bottles” subproblem, then, has everything—all remaining *n* – 1 caps and bottles.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens on that subproblem with *n* – 1 caps and bottles? Again, we’re
    going to pick the first cap, which is Cap 2 this time. We’ll make *n* – 1 queries
    as we make our way through the first `for` loop and then another *n* – 1 queries
    as we make our way through the second loop. That’s 2(*n* – 1) queries for this
    subproblem. And, again, the two subproblems stemming from this one are as lopsided
    as can be: an empty subproblem and a subproblem with *n* – 2 caps and bottles.'
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is very similar to the one on [page 307](ch08.xhtml#sec129)
    that clobbered us when we were solving Building Treaps. In each case, we were
    hoping for a nice, even split of our problem into two subproblems. When we don’t
    get that, we end up doing a quadratic amount of work. Here, we’ll make 2*n* queries,
    then 2(*n* – 1) queries, then 2(*n* – 2) queries, and so on. The total number
    of queries we’ll make is 2(1 + 2 + 3 + . . . + *n*), which is *O*(*n*²).
  prefs: []
  type: TYPE_NORMAL
- en: Darn! All of that fancy splitting and recursing, and yet we’re still stuck at
    *O*(*n*²).
  prefs: []
  type: TYPE_NORMAL
- en: What We Will Randomize
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In Solution 1, we chose the first cap and split our problem around it. That
    first cap determines what counts as “small” and “big.” As we just saw, if that
    cap does a poor job of splitting, then our algorithm can be quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder whether we can avoid that poor behavior by making a “smarter”
    choice of cap. Maybe we should have chosen the rightmost cap? Unfortunately not:
    the test case from the prior subsection would wreck that, too. Maybe we should
    have chosen the cap in the middle? Sure, but then someone could craft a test case
    where the middle caps are always the smallest caps. Then we’d be back to quadratic
    land again.'
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do here is to choose our caps randomly! Each time we need
    a cap, we’ll call `rand` to get it. If we do that, no test case can reliably cause
    poor performance because on each run we’ll make different choices for how the
    algorithm executes. This converts our deterministic algorithm into a Las Vegas
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this use of randomization with the kind of randomization that we used
    when solving Yōkan. In Yōkan, the randomization determined whether we got the
    right answer. In Caps and Bottles, we always get the right answer; the randomization
    determines how fast we get it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Randomization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need just two changes to Solution 1\. First, we need to add the call of `srand`
    to the `main` function in [Listing 10-8](ch10.xhtml#ch010ex08), just as we did
    when solving Yōkan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we need to choose a random cap in [Listing 10-9](ch10.xhtml#ch010ex09).
    Rather than choosing the first cap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'we choose a random one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you make those two changes and submit the updated code to the judge, you
    should find that it passes all test cases. Randomization has done it again!
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, in solving this problem we’ve also managed to secretly learn
    one of the most famous algorithms in computer science. Let’s go there next.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key idea in our solution to Caps and Bottles is to choose a cap and then
    use that cap to split the problem into two subproblems: one subproblem with the
    small stuff and the other with the big stuff. This idea most famously powers a
    sorting algorithm called *Quicksort*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementing Quicksort*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quicksort is one of many algorithms that can be used to sort an array; in practice,
    it’s one of the . . . quickest. In Caps and Bottles, the item that’s used to split
    the problem is a cap; in Quicksort, the value that’s used to split the array is
    called the *pivot*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for Quicksort is similar to the code we used to solve Caps and Bottles.
    Check it out in [Listing 10-10](ch10.xhtml#ch010ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-10: Quicksort*'
  prefs: []
  type: TYPE_NORMAL
- en: We choose a random pivot index ❶ and move the pivot to the left end of the array
    ➋. We want the pivot out of the way like that so that we don’t lose track of it—we’ll
    need to put it in the correct place later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we go through all of the other values in the array ➌, adding each to `big_values`
    or `small_values` as appropriate. Once that’s done, we make our two recursive
    calls to sort the small values and sort the big values.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do next is paste everything together: first the small values,
    then the pivot, then the big values. We copy the small values to the beginning
    of the `values` array ➍, then copy the pivot ➎, then copy the big values ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see why our solution to Caps and Bottles is so fast. While we’ll
    couch our discussion in terms of Caps and Bottles, what we learn about its runtime
    directly applies to the runtime of Quicksort as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Worst-Case and Expected Runtime*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our solution to Caps and Bottles is a Las Vegas algorithm. The runtime depends
    on how well each of our randomly chosen caps splits the problem into the two subproblems.
    If we choose terrible cap after terrible cap, we get *O*(*n*²) runtime. But that’s
    the worst-case behavior; the whole reason we introduced randomization was to make
    it extremely unlikely that this would actually happen. Rather than focusing on
    the worst-case runtime of such an algorithm, then, algorithm designers tend to
    focus on the *expected runtime*, which tells us what we can expect to happen in
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we expect in practice for our randomized solution to Caps and Bottles?
    We already know what happens if we’re shockingly unlucky: we get *O*(*n*²) performance.
    What happens if we’re shockingly lucky, picking caps that perfectly split each
    problem in half?'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we’ll choose our cap and make our 2*n* queries, as we always do. If
    that cap perfectly splits the problem in half, then we’ll need to work on two
    subproblems each with *n*/2 caps and bottles. Each of those two subproblems will
    generate 2*n*/2 = *n* queries of their own before they in turn recurse. So those
    two subproblems with *n*/2 caps and bottles will generate 2*n* queries, just like
    our original problem did.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if each subproblem with *n*/2 caps and bottles is split perfectly, then
    we get four problems of size *n*/4\. Each of those four will generate 2*n*/4 =
    *n*/2 queries before they recurse, for a total of 2*n* queries.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we make 2*n* queries for our original problem of size *n*, 2*n*
    queries in total for our subproblems of size *n*/2, 2*n* queries in total for
    our subproblems of size *n*/4, and so on. We can only do this about log *n* times
    before we reach base case subproblems. So, we do 2*n* queries a total of log *n*
    times, for a total of *O*(*n* log *n*) queries.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to see this *O*(*n* log *n*) bound is through a *recursion tree*.
    Such a tree characterizes how much work is done in each call of a recursive function.
    When we have perfect splits all the way down, our recursion tree looks like the
    one in [Figure 10-1](ch10.xhtml#ch010fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: A recursion tree with perfect splits*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each node splits into two nodes below, representing the fact that
    each problem splits into two. The quantity in each node indicates the number of
    queries that are directly made to solve that subproblem. The 2*n* at the top,
    for example, means that the initial call makes 2*n* queries. It’s not saying that
    the total number of queries made in the entire algorithm is 2*n*, only that the
    initial call makes 2*n* queries of its own prior to recursing. Notice that each
    level in this tree—the node at the top, the two nodes below that, and the four
    nodes below those—make a total of 2*n* queries. If we drew the entire tree, it
    would have about log *n* levels in it. In all, then, we have *O*(*n* log *n*)
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Now, *O*(*n* log *n*) is a wonderful thing, but all I’ve argued so far is that
    this is what happens when the algorithm gets super lucky with perfect splits.
    The algorithm is generally not going to get this lucky, though, just as it’s generally
    not going to get super unlucky with horrible cap choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the expected runtime is very close to what is predicted by
    the super lucky case rather than the super unlucky case. For example, let’s imagine
    that each time we choose a cap, one subproblem will end up with 90 percent of
    the caps and bottles and the other subproblem will end up with the remaining 10
    percent of the caps and bottles. You might consider that pretty unlucky. But even
    in this case, our algorithm is *O*(*n* log *n*)! Our biggest subproblem would
    go from size *n*, to size *n*/(10/9), to size *n*/(10/9)², and so on. That is,
    rather than dividing by 2 each time, we’re dividing by 10/9\. How many times do
    we need to do this to get down to a base case? It’s still logarithmic! The base
    of the log changes—it goes from log[2] to log[10/9]—but it’s still log. Yes: even
    if we get *this* unlucky, we’re still not going to hit *O*(*n*²).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I teach randomization in my algorithms classes, I often have at least a
    few flummoxed students. “Really, Dan? Picking random numbers? This feels like
    the kind of thing I would have tried *before* learning about real algorithms.”
    But as I hoped I’ve demonstrated in this chapter, randomization is no rookie move.
    Compared to deterministic algorithms, randomized algorithms can be faster and
    easier to design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.xhtml), I gave this advice: if you see an opportunity to
    use binary search to solve a problem, just do it. Who cares if there’s a slightly
    more efficient solution that doesn’t use binary search. I offer similar advice
    here: if you see an opportunity to use randomization, and you can tolerate the
    randomness in correctness or runtime, just do it. Who cares if there’s a deterministic
    algorithm: even if you can come up with one (which may not be easy!), it’ll probably
    be slower in practice anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yōkan is originally from the 2015 Don Mills Programming Gala programming competition,
    Gold Division. Caps and Bottles is originally from the 2009 Canadian Computing
    Olympiad.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a way to cut down the amount of memory needed by our solution to Caps
    and Bottles. It’s a neat trick that applies to implementations of Quicksort as
    well. Check it out in “Caps and Bottles: In-Place Sorting” in [Appendix B](app02.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a deep dive into sorting algorithms, I recommend *Compared to What?: An
    Introduction to the Analysis of Algorithms* by Gregory J.E. Rawlins (1991). It’s
    an oldie but a goodie. There are many sorting algorithms: some of them are slow,
    some of them are fast; some of them merge sorted pieces, some of them split and
    sort the pieces. The book compares and contrasts many sorting algorithms. This
    is also the book that originally introduced me to the Caps and Bottles problem.'
  prefs: []
  type: TYPE_NORMAL
