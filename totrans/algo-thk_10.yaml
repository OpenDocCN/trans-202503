- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: RANDOMIZATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机化**'
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: Think back to when we learned about binary search in [Chapter 7](ch07.xhtml).
    Rather than answering the question, “What is the optimal solution?” we instead
    asked, “Is this specific value the optimal solution?” While we were solving the
    Feeding Ants problem, you may have thought that my picking values out of thin
    air was outlandish, wondering how that was going to work at all. But it works
    great, as we now know.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第7章](ch07.xhtml)学习的二分查找。当时我们不是在回答“最优解是什么？”的问题，而是在问“这个特定的值是不是最优解？”在解决喂蚂蚁问题时，你可能会觉得我随意挑选值的做法很荒唐，想知道那到底怎么可能有效。但事实证明，这种做法非常有效，现在我们知道了。
- en: You want something that’s even more outlandish than binary search? How about
    just straight-up guessing a completely random solution. How could that possibly
    work? What is it about specific problems that makes this random guessing a viable
    strategy? And could random guessing still help us solve a problem even if we already
    have a solution? The surprising conclusions await.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要比二分查找更荒唐的东西吗？那就直接猜一个完全随机的解法吧。那怎么可能行得通呢？究竟是什么使得在特定问题下，随机猜测能成为一种可行的策略？即使我们已经有了解法，随机猜测还能帮我们解决问题吗？令人惊讶的结论在等着我们。
- en: '**Problem 1: Yōkan**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**问题1：羊羹**'
- en: Yōkan is a Japanese candy. It’s sweet. It has kind of a jelly or gummy texture.
    Buy a nice big block and cut it into little pieces and pair it with some fruit
    and chill it for a nice refreshing . . . oh, sorry. Back to algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 羊羹是一种日本糖果，味道甜美，质地类似果冻或橡皮糖。买一块大块的羊羹，切成小块，搭配一些水果，冷藏一下，享受一份清爽的……哦，抱歉，我们还是回到算法吧。
- en: This is DMOJ problem `dmpg15g6`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`dmpg15g6`。
- en: '*The Problem*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: Two friends have found a Yōkan consisting of *n* pieces. The pieces are numbered
    1, 2, . . . , *n*. Each piece of the Yōkan has a specific flavor, and each friend
    will eat only those pieces that are the same flavor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两个朋友找到了一个包含*n*块的羊羹。这些块按顺序编号为1, 2, ... , *n*。每一块羊羹有一个特定的味道，每个朋友只会吃那些味道相同的部分。
- en: A slab of Yōkan consists of all of the pieces from Piece *l* to Piece *r*. A
    friend is *happy* with a slab if they can find at least one-third of that slab’s
    pieces that have the same flavor. For example, if a slab has 9 pieces, then a
    friend would need to find 9/3 = 3 pieces of the same flavor. For both friends
    to be happy with the slab, they would each need to find their own one-third of
    pieces that have the same flavor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一块羊羹由从第*l*块到第*r*块的所有部分组成。如果一个朋友能找到至少三分之一的羊羹部分有相同的味道，那么他们会对这块羊羹感到*高兴*。例如，如果一块羊羹有9块，那么朋友需要找到9/3
    = 3块味道相同的部分。为了让两个朋友都对这块羊羹感到高兴，他们需要各自找到三分之一的味道相同的部分。
- en: The friends will query about various slabs; for each, we need to determine whether
    both of them would be happy with that slab.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 朋友们将查询不同的羊羹部分；对于每个部分，我们需要确定他们两个是否都会对这块羊羹感到高兴。
- en: Input
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing *n*, the number of pieces in the Yōkan, and *m*, the number
    of possible piece flavors. *n* and *m* are between 1 and 200,000.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*，即羊羹的块数，和*m*，即可能的味道数。*n*和*m*的范围在1到200,000之间。
- en: A line containing *n* integers giving the flavors of the Yōkan pieces from Piece
    1 to Piece *n*. Each integer is a flavor between 1 and *m*.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*n*个整数，表示从第1块到第*n*块的羊羹部分的味道。每个整数表示一种味道，范围在1到*m*之间。
- en: A line containing *q*, the number of queries that the friends have. *q* is between
    1 and 200,000.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含*q*，即朋友们的查询数。*q*的范围在1到200,000之间。
- en: '*q* lines, one for each query. Each such line contains the integers *l* and
    *r*, indicating the slab from Piece *l* to Piece *r*.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*行，每行对应一个查询。每一行包含两个整数*l*和*r*，表示从第*l*块到第*r*块的羊羹部分。'
- en: Output
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'The output for each query is on its own line. For each query:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查询的输出单独一行。对于每个查询：
- en: If both friends are happy with this slab, output `YES`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个朋友都对这块羊羹感到高兴，输出`YES`。
- en: Otherwise, output `NO`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，输出`NO`。
- en: The time limit for solving the test case is 1.4 seconds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为1.4秒。
- en: '*Randomly Choosing a Piece*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*随机选择一块*'
- en: 'Let’s start with a test case:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个测试用例开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Yōkan here has 14 pieces. It looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的羊羹有14块，长得像这样：
- en: '![Image](../images/pg377-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg377-01.jpg)'
- en: 'There are three queries to process. The first query starts at Piece 3 and ends
    at Piece 11\. We’re therefore interested in this slab of the Yōkan:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理三个查询。第一个查询从第3块开始，到第11块结束。因此，我们关心的是这块羊羹：
- en: '![Image](../images/pg377-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg377-02.jpg)'
- en: This slab has 9 pieces, so we want to determine whether each friend can find
    9/3 = 3 pieces of the same flavor. And they can! The first friend could eat 3
    pieces of Flavor 1\. The second friend could eat 3 pieces of Flavor 2\. (There
    are 4 pieces of Flavor 2 there, but that fourth one is overkill for what we need.)
    For this query, we would therefore output `YES`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这块羊羹有 9 块，因此我们要确定每个朋友是否能找到 9/3 = 3 块相同口味的部分。而他们是可以的！第一个朋友可以吃 3 块口味 1，第二个朋友可以吃
    3 块口味 2。（这里有 4 块口味 2，但第四块对于我们来说多余了。）因此，针对这个问题，我们的输出应该是 `YES`。
- en: Think about how we might write code to determine whether the friends are happy
    with this slab. In general, it would be too slow to do this by checking each piece
    in the slab one by one; after all, a slab can have up to 200,000 pieces in it.
    This is a familiar roadblock for us by this point in the book; the usual thing
    to do would be to use some fancy data structure to make the queries fast.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们如何编写代码来判断朋友们是否满意这块羊羹。一般来说，通过逐一检查羊羹中的每一块来做这个判断会太慢了；毕竟，一块羊羹可能有多达 20 万块部分。到目前为止，这个问题我们已经很熟悉了；通常做法是使用一些巧妙的数据结构来加速查询。
- en: But we’re going to do something far less usual here. I’d like you to look at
    that Yōkan slab again and randomly pick one of its pieces. Pieces of Flavor 1
    and pieces of Flavor 2 are prevalent here, so you may have ended up picking a
    piece of one of those two flavors. If you did, then you just found a way to satisfy
    the first friend. If not, please randomly pick another piece of that Yōkan slab.
    You may have gotten Flavor 1 or Flavor 2 that time. Still no? Then try a third
    time. If you’re choosing randomly, you’re bound to pick Flavor 1 or Flavor 2 within
    a small number of tries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们这里要做一些不太寻常的事情。我希望你再次看那块羊羹，并随机挑选其中的一块。羊羹中有口味 1 和口味 2 的部分，所以你可能会挑到其中一个口味。如果是的话，那你就找到了满足第一个朋友的方法。如果没有，请再随机挑选一块羊羹。你可能会得到口味
    1 或口味 2。还是没有？那就再试第三次。如果你是随机挑选的话，你很快就会在少数几次尝试中挑到口味 1 或口味 2。
- en: 'Let’s say that you’ve found Flavor 1 for the first friend. Now, do it again,
    this time for the second friend. It’ll be a little more difficult this time: the
    three Flavor 1 pieces are gone, so you’ll have to land on Flavor 2\. Still, try
    picking a random piece a few times, and I’m sure you’ll eventually pick one of
    Flavor 2.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经为第一个朋友找到了口味 1。现在，再做一次，这次为第二个朋友。这个过程会稍微困难一些：因为三个口味 1 的部分已经没有了，所以你必须选择口味
    2。不过，还是试着随机挑选几次，我相信你最终会挑到口味 2 的一块。
- en: 'The program that we’ll write to solve this problem is going to do exactly what
    you just did: picking pieces randomly, trying to find one whose flavor makes each
    friend happy.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要写的程序将做的事情与你刚才做的完全一样：随机挑选部分，试图找到一种口味让每个朋友都感到满意。
- en: Suppose that the two friends are happy with a given Yōkan slab. This means that
    there’s a single flavor that shows up for 2/3 of the pieces, or two different
    flavors that each show up for 1/3 of the pieces. Regardless, we have a 2/3 chance
    of making the first friend happy by just choosing a piece at random. If we succeed,
    then we’re done with the first friend and we move to the second friend. If we
    fail, well, we’ll just try again, and we’ll have a new 2/3 chance of success.
    If we fail that second time, we’ll try a third time, and a fourth time, until
    we succeed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这两位朋友都对这块羊羹感到满意。这意味着羊羹中有一个口味在 2/3 的部分出现，或者有两个不同的口味各自出现在 1/3 的部分。不管怎样，我们都有
    2/3 的机会通过随机选择一块来让第一个朋友满意。如果成功了，那我们就完成了第一个朋友的任务，接着转向第二个朋友。如果失败了，我们就再试一次，这时我们有新的
    2/3 的成功机会。如果第二次也失败了，我们就再试第三次、第四次，直到成功为止。
- en: We’ll figure out how many attempts we need later. For now, though, I can promise
    that it won’t be very many. The intuition for this can come from a coin-tossing
    experiment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会弄清楚需要多少次尝试。不过，现在我可以保证，次数不会太多。这个直觉可以通过掷硬币实验来理解。
- en: Imagine that you were playing a game with a fair coin. If you toss the coin
    and it comes up heads, you win. If you toss the coin and it comes up tails, you
    have to try again. Think of the coin coming up heads as making the friend happy,
    and the coin coming up tails as not making the friend happy and having to try
    again. How many times do you expect to have to toss the coin before it comes up
    heads? Not many, right? If there’s a flavor in the slab that makes a friend happy,
    we’ll toss only so many tails in a row before we find a heads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在和一个公平的硬币玩游戏。如果你抛硬币，结果是正面朝上，你就赢了。如果是反面朝上，你就得再试一次。可以将硬币正面朝上视为让朋友开心，而反面朝上则意味着朋友不开心，并且你需要再试一次。你预计需要抛硬币多少次才能出现正面？不多吧？如果羊羹中有一种口味让朋友开心，我们就只会抛少量的反面，然后就能找到正面。
- en: We were in the middle of working through a test case before all of that randomizing
    and coin-tossing talk, so let’s finish that before continuing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始进行所有随机化和抛硬币的讨论之前，我们正在处理中一个测试用例，所以让我们先完成这个部分，再继续往下讲。
- en: 'The second query starts at Piece 8 and ends at Piece 11\. The corresponding
    slab is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询从第8块开始，到第11块结束。对应的羊羹块是：
- en: '![Image](../images/pg378-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg378-01.jpg)'
- en: Unfortunately, the two friends are not happy with this one. Each friend needs
    to find at least 4/3 = ![Image](../images/page_378_1.jpg) pieces of the same flavor;
    as the available number of pieces of each flavor is an integer, what we really
    need is at least 2 pieces of the same flavor. We can do this for the first friend
    with Flavor 2, but we’re stuck for the second friend. We need to output `NO` here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这两个朋友对这个结果不满意。每个朋友至少需要找到4/3 = ![Image](../images/page_378_1.jpg)块相同口味的糖果；由于每个口味的糖果块数是整数，实际上我们需要的是至少2块相同口味的糖果。我们可以用口味2满足第一个朋友的需求，但第二个朋友就没法满足了。我们需要在这里输出`NO`。
- en: 'The third query starts at Piece 5 and ends at Piece 6\. That’s this part of
    the Yōkan:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个查询从第5块开始，到第6块结束。这是羊羹的这一部分：
- en: '![Image](../images/pg378-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg378-02.jpg)'
- en: 'Each friend needs just one piece of a given flavor. We can therefore use Flavor
    1 to make both friends happy: we can give one piece to the first friend and the
    other to the second friend! The correct output is therefore `YES`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个朋友只需要一块指定口味的糖果。所以我们可以使用口味1让两个朋友都开心：我们可以把一块给第一个朋友，把另一块给第二个朋友！因此，正确的输出是`YES`。
- en: '*Generating Random Numbers*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*生成随机数*'
- en: We’ll need a way to generate random numbers in order to randomly pick Yōkan
    pieces. We’ll use C’s `rand` function to do this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来生成随机数，以便随机选择羊羹的块。我们将使用C语言的`rand`函数来完成这一任务。
- en: If we call `rand` with an integer `x`, we’re asking for `rand` to give us one
    of `x` possibilities. Specifically, we’ll get back a random integer in the range
    `0` to `x - 1`. For example, if we call `rand(4)`, we’ll get back a `0`, `1`,
    `2`, or `3`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`rand`并传入整数`x`，我们要求`rand`给我们`x`种可能性中的一个。具体来说，我们会得到一个在`0`到`x - 1`范围内的随机整数。例如，如果我们调用`rand(4)`，我们会得到`0`、`1`、`2`或`3`。
- en: Now, how can we use `rand` to pick a random piece of a slab? Let’s use the term
    *width* to refer to the number of pieces in a slab. For example, the slab from
    Piece 8 to Piece 11 has a width of 4\. In this case, we’d need `rand` to give
    us back `8`, `9`, `10`, or `11`. We can start by calling `rand(4)`, because we
    need `rand` to give us one of four possibilities. That would give us a `0`, `1`,
    `2`, or `3`. This is a good start, but those numbers are not in the right range.
    To fix that, we can just add 8 to move that value into the 8–11 range that we
    need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用`rand`来随机选择羊羹块呢？我们可以使用“宽度”一词来表示羊羹块的数量。例如，从第8块到第11块的宽度是4。在这种情况下，我们需要`rand`返回`8`、`9`、`10`或`11`。我们可以先调用`rand(4)`，因为我们需要`rand`从四个可能的值中选择一个。这会返回`0`、`1`、`2`或`3`。这是一个不错的开始，但这些数字不在正确的范围内。为了解决这个问题，我们只需加上8，将这个值调整到我们需要的8–11范围内。
- en: In code, generating a random number for a given width `width` and starting point
    `left` can be done as in [Listing 10-1](ch10.xhtml#ch010ex01).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，生成给定宽度`width`和起始点`left`的随机数可以参考[列表 10-1](ch10.xhtml#ch010ex01)来实现。
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Randomly choosing a piece*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1：随机选择一块*'
- en: 'The code carries out the plan that we just outlined: it generates a random
    number from `0` to `width - 1`, then adds the starting point `left` to it ❶.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行了我们刚刚概述的计划：它生成了一个从`0`到`width - 1`之间的随机数，然后加上起始点`left` ❶。
- en: '*Determining Number of Pieces*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*确定块数*'
- en: Suppose that we’re working on a particular query. We’re going to choose a random
    piece in that query’s slab. Does the flavor of that piece make one or both of
    the friends happy? To answer that, we’ll need to be able to quickly determine
    how many times that flavor shows up in the slab.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理一个特定的查询。我们将选择该查询块中的一个随机片段。这个片段的味道是否让其中一个或两个朋友开心？为了回答这个问题，我们需要能够快速确定该味道在块中出现的次数。
- en: It will therefore be convenient for us to have a sorted array for each flavor
    that gives us the pieces of that flavor. I’ll call such an array a *flavor array*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们来说，拥有一个每个味道的排序数组将非常方便，它可以为我们提供该味道的片段。我称这种数组为*味道数组*。
- en: 'Let’s go back to the Yōkan from our test case:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到测试用例中的羊羹：
- en: '![Image](../images/pg379-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg379-01.jpg)'
- en: 'The array for Flavor 1 would be `[1, 5, 6, 9, 13, 14]`; the array for Flavor
    2 would be `[4, 7, 10, 11]`; and so on. As promised, each of these arrays is sorted:
    the piece numbers are in order from smallest to largest. We’ll see how to generate
    these flavor arrays later; for now let’s just assume they exist.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 味道1的数组是`[1, 5, 6, 9, 13, 14]`；味道2的数组是`[4, 7, 10, 11]`；依此类推。如同承诺的那样，这些数组已经排序：片段编号按从小到大的顺序排列。稍后我们会看到如何生成这些味道数组；现在我们暂且假设它们已经存在。
- en: 'We can use such an array to determine the number of pieces of a given flavor
    that lie within a slab. For example, we could use the array `[1, 5, 6, 9, 13,
    14]` to conclude that there are three pieces of Flavor 1 in the 3-11 slab: the
    pieces 5, 6, and 9.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的数组来确定给定味道在某个块中的片段数量。例如，我们可以使用数组`[1, 5, 6, 9, 13, 14]`得出结论：在3-11块中有三个味道1的片段：片段5、片段6和片段9。
- en: 'Let’s take stock. We have the query that we want to solve. We have a random
    flavor that we care about checking. We have the flavor array: a sorted array of
    piece numbers of that flavor. And we need to determine how many of those pieces
    are in the range of the query.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们盘点一下。我们有了要解决的查询。我们有一个随机的味道，需要检查它。我们有了味道数组：一个排序的该味道的片段编号数组。我们需要确定这些片段中有多少个在查询范围内。
- en: We could do this using a linear search through the flavor array. But that would
    be too slow—a linear amount of work per query.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过线性查找味道数组来做到这一点。但那会太慢——每次查询都需要线性时间。
- en: If you think back to [Chapter 7](ch07.xhtml), you might wonder whether we can
    call on a binary search here. We can indeed, because the array is sorted! Well,
    actually, we’ll need to call binary search twice rather than once, but that won’t
    change the fact that we’ll be able to find what we need in logarithmic time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想一下[第7章](ch07.xhtml)，你可能会想知道是否可以在这里使用二分查找。的确可以，因为数组是排序的！实际上，我们需要调用二分查找两次，而不是一次，但这不会改变我们能够在对数时间内找到所需内容的事实。
- en: We’re going to write a binary search function that takes a flavor array `pieces`
    and an integer `at_least` and returns the index of the leftmost value in the array
    that’s greater than or equal to `at_least`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个二分查找函数，传入一个味道数组`pieces`和一个整数`at_least`，返回数组中第一个大于或等于`at_least`的值的索引。
- en: Before we do, we should make sure that the specification of that function actually
    does what we need. To that end, let’s use it to figure out how many pieces of
    Flavor 1 are in the 3-11 slab.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该确保这个函数的规范确实能满足我们的需求。为此，让我们用它来找出3-11块中味道1的片段数量。
- en: To figure out where the pieces of Flavor 1 begin in that slab, we can call our
    function with the array `[1, 5, 6, 9, 13, 14]` and an `at_least` value of `3`.
    We’ll get a result of `1`. This tells us that the piece at index 1 is the first
    piece of this flavor whose number is at least 3\. That piece is Piece 5, which
    is indeed the first piece that we’re looking for.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出味道1在该块中的片段起始位置，我们可以调用我们的函数，传入数组`[1, 5, 6, 9, 13, 14]`和`at_least`值为`3`。我们将得到结果`1`。这告诉我们，索引为1的片段是这个味道中编号至少为3的第一个片段。这个片段是片段5，它确实是我们要找的第一个片段。
- en: Where do the pieces of Flavor 1 end in that slab? We can figure that out, too!
    Just call our function with the same array, but this time an `at_least` value
    of `12`. Why 12? Because that’s the first piece *not* in the slab. If we make
    this call, we’ll get a result of `4`. This refers to the piece at index 4, which
    is Piece 13\. That’s the first piece of this flavor that’s not in the 3-11 slab.
    In general, to figure out where a flavor ends, we’ll call our binary search function
    with an `at_least` value that’s 1 larger than the right end of the slab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Flavor 1的片段在该区间结束在哪里？我们也可以算出来！只需用相同的数组调用我们的函数，不过这次设置`at_least`值为`12`。为什么是12？因为那是第一个**不**在该区间内的片段。如果我们这样调用，就会得到`4`的结果。这指的是索引4处的片段，即片段13。这是这个味道在3-11区间外的第一个片段。一般来说，要弄清楚某个味道的结束位置，我们可以调用二分查找函数，传入比区间右端大1的`at_least`值。
- en: Now we know where the relevant pieces start (index 1) and where the relevant
    pieces end (just to the left of index 4). If we subtract 1 from 4, we get an answer
    of 3, which is exactly the number of pieces of Flavor 1 in the 3-11 slab.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道相关片段的起始位置（索引1）和结束位置（就在索引4的左边）。如果从4中减去1，我们得到3，这正是3-11区间中Flavor 1的片段数量。
- en: 'Let’s write the code for our binary search function. (Soon, we’ll see the function
    that calls this function twice.) As you learned in “Searching for a Solution”
    on [page 250](ch07.xhtml#sec107), the right way to write a binary search function
    is to first figure out the invariant. Our invariant will have two parts: that
    all values at indices less than `low` are `< at_least`, and that all values at
    indices `high` or greater are `>= at_least`. See [Listing 10-2](ch10.xhtml#ch010ex02)
    for the code. In addition to the aforementioned `pieces` and `at_least` parameters,
    we have a parameter `num_pieces` that gives the number of pieces in the `pieces`
    array.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写二分查找函数的代码。（稍后，我们将看到调用此函数两次的函数。）正如你在《寻找解决方案》中所学到的，在[第250页](ch07.xhtml#sec107)，编写二分查找函数的正确方法是先找出不变式。我们的不变式将包含两部分：所有`low`索引之前的值都小于`<
    at_least`，以及所有`high`或更大的索引上的值都大于等于`>= at_least`。参见[示例10-2](ch10.xhtml#ch010ex02)中的代码。除了前述的`pieces`和`at_least`参数外，我们还有一个参数`num_pieces`，它给出了`pieces`数组中片段的数量。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: Searching for the first satisfying value*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-2：查找第一个满足条件的值*'
- en: We need to make both parts of the invariant true above the loop. For the first
    part, notice that the invariant isn’t making any claim about the value at index
    `low`; it makes a claim only about the values to the left of index `low`. For
    that reason, we can set `low` to `0` above the loop ❶; there’s nothing to the
    left of `low` now, so this part of the invariant is satisfied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在循环之前使不变式的两部分都成立。对于第一部分，注意不变式并没有对`low`索引上的值做任何声明；它仅对`low`左边的值做出声明。因此，我们可以在循环之前将`low`设置为`0`
    ❶；现在`low`左边没有任何值，所以这一部分的不变式得到了满足。
- en: 'For the second part, the invariant claims something about all of the values
    at indices `high` or greater. Since we don’t know anything about any value in
    the array, we need to make this part of the invariant claim nothing. We can do
    this by setting `high` to just beyond the right end of the array ➋: now there
    are no valid indices between `high` and the end of the array.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，不变式对`high`或更大的索引上的所有值进行了声明。由于我们对数组中的任何值都不了解，我们需要让这一部分的不变式声明为空。我们可以通过将`high`设置为数组右端之外的位置来实现
    ➋：这样`high`和数组末尾之间就没有有效索引了。
- en: The code inside the `while` loop maintains the invariant. I encourage you to
    check this for yourself if you like, but you’ve had a lot of binary search practice
    already so I don’t blame you if you’d rather not!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环中的代码保持着不变式。我鼓励你如果愿意，可以自己检查这一点，但你已经有了很多二分查找的练习，所以如果你不想检查，我也不怪你！'
- en: The `while` loop condition ➌ ensures that `low` and `high` are equal when the
    loop terminates. The invariant tells us that all values to the left of `low` are
    too small and that `low` is the first index of the value that’s `>= at_least`.
    This is why we return `low` when the function terminates ➍.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环条件 ➌ 确保当循环终止时，`low`和`high`相等。不变式告诉我们，所有在`low`左边的值都太小，并且`low`是第一个`>=
    at_least`的值的索引。这就是为什么当函数终止时我们返回`low`的原因 ➍。'
- en: Next, as promised, we’re going to make two calls of that function to figure
    out how many pieces of a given flavor are within the range of a given slab. See
    [Listing 10-3](ch10.xhtml#ch010ex03) for the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如之前承诺的，我们将调用该函数两次，以确定某种味道的片段在给定区间内的数量。参见[示例10-3](ch10.xhtml#ch010ex03)中的代码。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Determining number of pieces of a given flavor that are in range*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-3：确定给定口味的块数在范围内的情况*'
- en: Here, the `pieces` parameter is the flavor array, and the `left` and `right`
    parameters indicate the leftmost and rightmost pieces of the slab. The code first
    finds the index in the slab where the flavor starts ❶. Then it finds the index
    immediately to the right of where the flavor ends in the slab ➋. Finally, it subtracts
    the first of these indices from the second to determine the number of pieces of
    the flavor in the slab ➌.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`pieces`参数是口味数组，`left`和`right`参数表示该块的最左和最右边的块。代码首先找到块中口味开始的位置的索引❶。然后找到口味结束位置的右边的索引➋。最后，它从第二个索引中减去第一个索引来确定该块中该口味的块数➌。
- en: '*Guessing Flavors*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*猜测口味*'
- en: 'At this point, we know what to do once we’ve guessed a flavor: use binary search
    to check whether the guessed flavor makes one or both friends happy. Now we need
    to work on the code that makes the guesses.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们已经知道该怎么做：一旦我们猜到一个口味，就用二分查找来检查猜测的口味是否让一位或两位朋友感到高兴。现在我们需要处理生成这些猜测的代码。
- en: 'Our overall strategy can be broken down into three steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整体策略可以分为三个步骤：
- en: '**Step 1**   Figure out the number of pieces that we need to make one friend
    happy.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**   计算出让一位朋友高兴所需要的块数。'
- en: '**Step 2**   Try to make the first friend happy. Start by guessing a piece.
    If the flavor of that piece makes the friend happy, then we are done; otherwise,
    guess again. Keep guessing until we succeed or until we run out of guesses. It’s
    possible for us to find a flavor that’s so prevalent that it makes not just the
    first friend happy, but *both* friends happy. If that happens, we pump out a `YES`
    and stop right there, without doing Step 3.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**   尝试让第一位朋友高兴。首先猜测一块。如果该块的口味让朋友高兴，那么我们完成了；否则，再猜一次。一直猜直到成功或者猜测用完为止。我们有可能找到一个口味，它如此常见，不仅让第一位朋友高兴，还能让*两位*朋友都高兴。如果发生这种情况，我们就输出`YES`并停止，而不执行步骤3。'
- en: '**Step 3**   Try to make the second friend happy using the same strategy that
    we used for the first friend. If we happen to guess the flavor that made the first
    friend happy, then we need to ignore it and move on to our next attempt because
    that flavor isn’t prevalent enough to make both friends happy.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**   尝试使用我们为第一位朋友使用的相同策略来让第二位朋友高兴。如果我们恰好猜到了让第一位朋友高兴的口味，那么我们需要忽略它并继续下一次尝试，因为这个口味并不常见到足以让两位朋友都高兴。'
- en: 'We’ll write the function for the following signature:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为以下签名编写函数：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s what each parameter is for:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个参数的用途：
- en: yokan   The array of Yōkan flavors; `yokan[1]` is the flavor of the first piece,
    `yokan[2]` is the flavor of the second piece, and so on. (We start at index 1
    rather than 0 because the pieces are numbered from 1 in this problem.) We need
    this array so that we can choose a random piece.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: yokan   Yōkan口味的数组；`yokan[1]`是第一块的口味，`yokan[2]`是第二块的口味，依此类推。（我们从索引1开始而不是0，因为在这个问题中，块的编号从1开始。）我们需要这个数组，以便可以选择一个随机的块。
- en: pieces_for_flavor   The array of flavor arrays. Each flavor array is sorted
    from smallest piece number to largest piece number. For example, `pieces_for_flavor[1]`
    might be the array `[1, 5, 6, 9, 13, 14]`, telling us all of the pieces that are
    of Flavor 1\. We need these arrays so that we can binary search them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pieces_for_flavor   口味数组的数组。每个口味数组都按从小到大的块编号排序。例如，`pieces_for_flavor[1]`可能是数组`[1,
    5, 6, 9, 13, 14]`，表示所有的口味1的块。我们需要这些数组，以便能够进行二分查找。
- en: num_of_flavor   An array giving the number of pieces of each flavor; `num_of_flavor[1]`
    is the number of pieces of Flavor 1, `num_of_flavor[2]` is the number of pieces
    of Flavor 2, and so on. That is, this array tells us how many elements are in
    each of the flavor arrays.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: num_of_flavor   给出每个口味块数的数组；`num_of_flavor[1]`是口味1的块数，`num_of_flavor[2]`是口味2的块数，依此类推。也就是说，这个数组告诉我们每个口味数组中有多少元素。
- en: left   The beginning index of the current query.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: left   当前查询的起始索引。
- en: right   The ending index of the current query.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: right   当前查询的结束索引。
- en: The code for this function is in [Listing 10-4](ch10.xhtml#ch010ex04). Look
    out for the three steps—figure out the happy threshold, make the first friend
    happy, make the second friend happy—as you read through the code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码在[列表10-4](ch10.xhtml#ch010ex04)中。阅读代码时要注意三个步骤——找出使朋友高兴的临界值，首先让第一位朋友高兴，然后让第二位朋友高兴。
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-4: Solving the problem*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-4：解决问题*'
- en: For Step 1, we determine the number of pieces that will make a friend happy
    ❶.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 1 步，我们确定使朋友开心的块的数量 ❶。
- en: For Step 2, we start guessing flavors for the first friend ➋. The `for` loop
    uses a `NUM_ATTEMPTS` constant that we haven’t defined yet. We’ll decide on this
    number after we finish walking through this function. In the `for` loop, we choose
    a random piece from the current slab ➌, then call our `num_in_range` helper function
    to get the number of pieces in the slab that have the same flavor as that random
    piece ➍.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 2 步，我们开始为第一个朋友猜测口味 ➋。`for` 循环使用了一个尚未定义的 `NUM_ATTEMPTS` 常量。我们将在完成这个函数的讲解后再决定这个数字。在
    `for` 循环中，我们从当前的 Yōkan 块中选择一个随机块 ➌，然后调用我们的 `num_in_range` 辅助函数，获取该块中与随机块相同口味的块的数量
    ➍。
- en: 'Did our random flavor make one or both of the friends happy? We first check
    whether the flavor was so prevalent that it makes both friends happy. Specifically,
    if the flavor shows up 2/3 of the time (that is, twice the threshold value), it
    can be used to make both friends happy ➎. In this case, we’re done: we just output
    `YES` and return. If the flavor doesn’t make both friends happy, it might still
    be good enough to make the first friend happy, so we check for that next ➏. We
    also record the flavor that we found for the first friend ❼.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的随机口味是否让一个或两个朋友开心？首先，我们检查该口味是否如此普遍，以至于能让两个朋友都开心。具体来说，如果该口味出现的频率为 2/3（也就是两倍的阈值），那么它可以用来让两个朋友都开心
    ➎。这样的话，我们就完成了：我们直接输出`YES`并返回。如果这个口味没有让两个朋友都开心，它可能仍然足够让第一个朋友开心，所以我们接下来检查这一点 ➏。我们还记录下为第一个朋友找到的口味
    ❼。
- en: If in all our guessing we weren’t able to find a flavor for the first friend,
    then we output `NO` and stop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在所有的猜测中，我们未能为第一个朋友找到口味，那么我们输出`NO`并停止。
- en: If we were able to find a flavor for the first friend, then we proceed to Step
    3 ❽, where we try to find a flavor for the second friend. The logic is quite similar
    to what we did for the first friend. The only addition is to ensure that we don’t
    inadvertently use the flavor that we already used for the first friend ❾.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为第一个朋友找到了口味，那么我们继续进行第 3 步 ❽，尝试为第二个朋友找到口味。这个逻辑和我们为第一个朋友所做的非常相似。唯一的不同是要确保我们不会不小心使用已经为第一个朋友使用过的口味
    ❾。
- en: If we get to the bottom of the function, it means that we weren’t able to find
    a flavor for the second friend. We output `NO` in this case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达函数的底部，意味着我们未能为第二个朋友找到口味。在这种情况下，我们输出`NO`。
- en: '*How Many Attempts Do We Need?*'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*我们需要多少次尝试？*'
- en: Let’s finally answer the question of how many attempts we need to ensure a ridiculously
    high probability of success.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回答需要多少次尝试才能确保极高的成功概率。
- en: We’ll assume that each query asks about a slab of the Yōkan where exactly one
    third of the pieces are of some flavor *x*, exactly one third are of some other
    flavor *y*, and the rest of the pieces are distributed among a bunch of other
    flavors. That will be the hardest type of query of all for us. We may get lucky
    and run into a query where one flavor shows up 50 percent or 70 percent or 85
    percent of the time, and for those we’ll have an easier time with our guessing.
    But we’re focusing on the hardest type of query because if we can nail that one,
    then we know that we can nail any others.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个查询询问的是一个 Yōkan 的块，其中恰好三分之一的块是某种口味 *x*，另三分之一是另一种口味 *y*，其余的块则分布在其他各种口味之间。这将是我们面临的最难的查询类型。我们可能会碰巧遇到一个查询，其中某种口味出现了
    50%、70% 或 85% 的时间，对于这些情况，我们的猜测会更容易一些。但我们专注于最难的查询类型，因为如果我们能解决这个，那么我们就知道其他的查询也能解决。
- en: Don’t worry if you haven’t worked with probability before. A *probability* is
    just a value in the range 0 to 1\. If something has a probability of 0 then it
    never occurs; if something has a probability of 1 then it occurs every time. You
    can multiply a probability value by 100 to turn it into a percentage. For example,
    when tossing a coin there is a 0.5 probability that it comes up heads; multiplied
    by 100, we see it equivalently has a 0.5 × 100 = 50 percent chance of coming up
    heads. We need a couple of other rules of probability as well, but I’ll explain
    those as we go along.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心如果你以前没有做过概率相关的工作。*概率*只是一个在 0 到 1 之间的值。如果某件事的概率是 0，那么它永远不会发生；如果某件事的概率是 1，那么它每次都会发生。你可以将概率值乘以
    100 来转换成百分比。例如，当抛硬币时，正面朝上的概率是 0.5；乘以 100，我们就可以看到它有 0.5 × 100 = 50% 的机会正面朝上。我们还需要一些其他的概率规则，但我会在之后解释这些。
- en: 'Let’s just pick a number of guesses out of nowhere and see how well we do.
    How about 10? We’ll first figure out the probability that we make the first friend
    happy. On our first guess, we have a 2/3 probability of success. That’s because
    2/3 of the pieces in the slab are of one of the two flavors that each show up
    1/3 of the time. What’s our probability of failure? There are only two outcomes
    here: success and failure. They have to add up to 1, because there’s a 100 percent
    chance that one of these two outcomes happens. So we can find the probability
    of failure by subtracting the probability of success from 1\. That gives us a
    1 – 2/3 = 1/3 probability of failure.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随便挑一个猜测次数，看看我们能做得如何。比如10次？我们先算出让第一个朋友高兴的概率。在第一次猜测时，我们有2/3的成功概率。这是因为在这块石板中，有2/3的碎片属于两种每种出现1/3的口味之一。那么失败的概率是多少呢？这里只有两种结果：成功和失败。它们的概率加起来必须等于1，因为这两种结果中总有一个会发生。所以我们可以通过从1中减去成功的概率来找出失败的概率。这样算出失败的概率是1
    – 2/3 = 1/3。
- en: 'What’s the probability of failure on all 10 guesses? For that to happen, we
    need to have failed on each guess independently. There’s a 1/3 probability that
    we fail on the first guess, a 1/3 probability that we fail on the second guess,
    a 1/3 probability that we fail on the third guess, and so on. There’s a rule that
    we can use here to figure out the probability that we fail on all of these 10
    independent guesses: just multiply all of the probabilities together. We see that
    the probability of failing on all 10 guesses is (1/3)^(10), which is about 0.000017.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有10次猜测都失败的概率是多少？为了发生这种情况，我们需要在每次猜测时都独立失败。第一次猜测失败的概率是1/3，第二次猜测失败的概率是1/3，第三次猜测失败的概率是1/3，以此类推。我们可以用一个规则来计算所有这些10次独立猜测都失败的概率：将所有概率相乘。我们看到，所有10次猜测都失败的概率是(1/3)^(10)，约等于0.000017。
- en: 'Now we are able to calculate our probability of success for this friend: 1
    – 0.000017 = 0.999983.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够计算这个朋友的成功概率了：1 – 0.000017 = 0.999983。
- en: This is a better-than-99.99 percent probability of success. We’re doing great!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着成功的概率超过99.99%。我们做得很好！
- en: What’s the probability that we make the second friend happy given that we made
    the first friend happy? For this one, the probability of success on each attempt
    is 1/3, not 2/3, because the pieces of the first friend’s flavor are gone. If
    you run through the calculation starting with 1/3 rather than 2/3, you should
    find a probability of success for the second friend of about 0.982658\. That’s
    over 98.2 percent! We’re still looking good.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个朋友成功的前提下，让第二个朋友高兴的概率是多少？对于这个问题，每次尝试的成功概率是1/3，而不是2/3，因为第一个朋友的口味已经没有了。如果你从1/3开始计算，你会得到第二个朋友的成功概率大约是0.982658。这个概率超过98.2%！我们依然很有希望。
- en: It’s nice that we now have both the probability of success for the first friend
    and the probability of success for the second friend given success on the first
    friend. But what we care about more is the probability of success for both friends.
    To find that, we can multiply our two success probabilities together. Doing so,
    we find that the overall probability of making both friends happy is 0.999983
    × 0.982658 = 0.982641.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了第一个朋友的成功概率和在第一个朋友成功的前提下，第二个朋友的成功概率。但我们更关心的是两个朋友都成功的概率。为了计算这个，我们可以将两个成功的概率相乘。这样算下来，我们发现让两个朋友都高兴的总体概率是0.999983
    × 0.982658 = 0.982641。
- en: This probability is more than 98.2 percent. Pretty good, right? Unfortunately,
    no. If we had to process one query, then this probability would be just fine.
    But we may need to process a massive 200,000 queries. And we need to get every
    single one of them right. If we get even one wrong, then we fail the test case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概率超过98.2%。相当不错，对吧？不幸的是，不是这样的。如果我们只处理一个查询，这个概率就没问题了。但我们可能需要处理多达200,000个查询。并且每个查询都必须完全正确。如果我们有哪怕一个错了，我们就会失败。
- en: Suppose you’re throwing a ball into a basket and you have a 98.2 percent probability
    of success on each throw. You throw one ball. That one’s probably going in. Now
    imagine that you throw 100 balls. You’re probably going to botch at least a couple
    of those throws. And if you threw 200,000 balls? Your probability of getting every
    single one into the basket is near 0.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你把一个球投进篮筐，每次投掷的成功概率是98.2%。你投一个球。这个球很可能会进。现在假设你投100个球。你可能会搞砸其中几个。如果你投200,000个球呢？你把每个球都投进篮筐的概率接近于0。
- en: While 10 attempts was a good try, it isn’t enough. We need more. Through some
    trial and error, I’ve settled on using 60 attempts for each friend. If you run
    through the calculations using 60 guesses instead of 10, you should find a success
    probability for each query of about 0.99999999997.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 10 次尝试已经是一次不错的尝试，但仍然不够。我们需要更多。通过一些反复试探，我最终决定每个朋友使用 60 次尝试。如果你使用 60 次猜测而不是
    10 次进行计算，你应该能找到每个查询的成功概率大约是 0.99999999997。
- en: 'That’s a lot of 9s! But we need them all because otherwise we’d take a massive
    probability hit when going from 1 query to 200,000\. To find our probability of
    success for 200,000 queries, we can raise our per-query probability of success
    to the power of 200,000: 0.99999999997^(200,000) = 0.999994.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是好多 9！但是我们需要这些，因为否则从 1 个查询增加到 200,000 个查询时，我们的概率将大幅下降。为了找到 200,000 个查询的成功概率，我们可以将每个查询的成功概率的
    200,000 次方：0.99999999997^(200,000) = 0.999994。
- en: It looks like we’ve lost a few 9s. Still, this is a staggeringly high probability,
    and this time it is for the probability that we get every single query right,
    not just one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们丢失了一些 9。尽管如此，这仍然是一个极高的概率，这次是针对每个查询都正确的概率，而不仅仅是一个。
- en: 'We’re finally ready to set our `NUM_ATTEMPTS` constant. Let’s use `60`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好设置我们的 `NUM_ATTEMPTS` 常量了。我们来使用 `60`：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Filling the Flavor Arrays*'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*填充风味数组*'
- en: We’re almost ready for the `main` function; we just need one more little helper
    function first.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几乎准备好 `main` 函数了；只是还需要一个小的辅助函数。
- en: That helper function will take `yokan` (the Yōkan array) and `num_pieces` (the
    number of pieces in the Yōkan) and produce the `pieces_for_flavor` flavor arrays
    that we used in the `solve` function. See [Listing 10-5](ch10.xhtml#ch010ex05)
    for the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数将接收 `yokan`（Yōkan 数组）和 `num_pieces`（Yōkan 中的片数），并生成我们在 `solve` 函数中使用的
    `pieces_for_flavor` 风味数组。有关代码，请参见 [清单 10-5](ch10.xhtml#ch010ex05)。
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-5: Filling in the flavor arrays*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：填充风味数组*'
- en: The function assumes that each array in `pieces_for_flavor` already has memory
    assigned to it; that’s a responsibility of the `main` function that’s coming up
    next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数假设 `pieces_for_flavor` 中的每个数组已经分配了内存；这是接下来要编写的 `main` 函数的责任。
- en: We use a local `cur_of_flavor` array ❶ to track the number of pieces we’ve found
    so far of each flavor. Inside the `for` loop, we use this array to determine the
    index in which to store the current piece number ➋.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个本地的 `cur_of_flavor` 数组 ❶ 来跟踪每个风味已经找到的片数。在 `for` 循环内，我们使用这个数组来确定存储当前片数的索引
    ➋。
- en: '*The main Function*'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*主函数*'
- en: We’ve made it to the `main` function! Check it out in [Listing 10-6](ch10.xhtml#ch010ex06).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了 `main` 函数！请查看 [清单 10-6](ch10.xhtml#ch010ex06)。
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-6: The* main *function*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：* 主函数 *'
- en: Before we can use C’s `rand` function, we need to use the `srand` function to
    initialize the random number generator with a seed. The seed determines the sequence
    of random numbers that are generated. We don’t want to use the same seed every
    time, otherwise we’ll generate the same sequence of numbers each time. What works
    well is to use the current time as the seed so that the random numbers change
    each time we run the program. We do that using C’s `time` function ❶. To use that
    function, you’ll need to add `#include <time.h>` at the top of your program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用 C 的 `rand` 函数之前，我们需要使用 `srand` 函数通过一个种子来初始化随机数生成器。种子决定了生成的随机数序列。我们不想每次使用相同的种子，否则每次生成的数列都会一样。一个有效的方法是使用当前时间作为种子，这样每次运行程序时随机数都会不同。我们可以通过
    C 的 `time` 函数来实现这一点 ❶。要使用该函数，您需要在程序顶部添加 `#include <time.h>`。
- en: There are two important `for` loops here. The first one ➋ fills in the `yokan`
    array and also uses the `num_of_flavor` array to keep track of the number of pieces
    of each flavor. Why do we need to know the number of pieces of each flavor? It’s
    because, without knowing that, we wouldn’t know how big to make each flavor array.
    The second `for` loop ➌ is responsible for allocating memory for the flavor arrays.
    It uses `num_of_flavor` to determine exactly how big each flavor array should
    be ➍.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的 `for` 循环。第一个 ➋ 填充 `yokan` 数组，并使用 `num_of_flavor` 数组来跟踪每种风味的片数。为什么我们需要知道每种风味的片数？因为如果不知道这一点，我们就不知道应该为每个风味数组分配多大的内存。第二个
    `for` 循环 ➌ 负责为风味数组分配内存。它使用 `num_of_flavor` 来确定每个风味数组的确切大小 ➍。
- en: Following these `for` loops, we call our helper function to fill in the flavor
    arrays whose memory we just allocated ➎.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些 `for` 循环之后，我们调用我们的辅助函数来填充我们刚刚分配内存的风味数组 ➎。
- en: And then we’re off to the queries! For each one, we call our `solve` function
    ➏ to print `YES` or `NO` as needed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始处理查询！对于每个查询，我们调用我们的`solve`函数 ➏，根据需要打印`YES`或`NO`。
- en: 'If you submit our code to the judge, you should find that it passes all test
    cases within the time limit. If your code is correct and you somehow fail a test
    case, take a screenshot: you’ll probably never see that again.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们的代码提交给评测系统，你应该会发现它在时间限制内通过了所有测试用例。如果你的代码是正确的，但你还是没通过某个测试用例，截图保存：你可能再也不会见到这种情况了。
- en: Randomization
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机化
- en: There are two main types of randomized algorithms. We just learned about one
    of them. Let’s expand on that one here and preview the other.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化算法有两种主要类型。我们刚刚了解了一种。让我们在这里扩展一下这一种，并预览另一种。
- en: '*Monte Carlo Algorithms*'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*蒙特卡罗算法*'
- en: 'The type of algorithm that we used to solve Yōkan, where there’s a chance that
    we get the answer wrong, is called a *Monte Carlo Algorithm*. The key question
    when using such an algorithm is: How many attempts should we use? There’s a tradeoff
    between the number of attempts and the probability of success: as we crank up
    the number of attempts, we increase the probability of success but slow down the
    algorithm. We generally want to find a sweet spot where the probability of success
    is high enough but our algorithm is still fast. Of course, what counts as a “high
    enough” probability of success depends on what we’re using the algorithm for.
    Solving a programming competition problem? Ninety-nine percent probability of
    success is fine. (If the algorithm fails, who cares: just run it again.) For algorithms
    that impact the health and safety of people, though, 99 percent is not okay.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来解决 Yōkan 问题的算法，其中有可能得到错误答案的算法叫做*蒙特卡罗算法*。使用这种算法时，关键问题是：我们应该尝试多少次？尝试次数和成功概率之间存在权衡：随着我们增加尝试次数，我们提高了成功的概率，但也让算法变慢。我们通常想找到一个平衡点，在这个平衡点上，成功概率足够高，同时算法仍然足够快。当然，什么是“足够高”的成功概率取决于我们使用该算法的目的。如果是解决编程竞赛问题？99%的成功概率就足够了。（如果算法失败，没关系：再跑一次就行了。）但是对于那些影响到人们健康与安全的算法来说，99%就不行。
- en: In our solution to Yōkan, if we answer `YES`, then we’re guaranteed to be correct.
    We only answer `YES` when we’re staring at the very flavors that show why the
    friends are happy with the slab. By contrast, if we answer `NO`, then we might
    be wrong. It might be the case that the friends aren’t happy with the slab—but
    it could also be that we just got unlucky and kept picking bad flavors. Because
    only one of the two types of answers can be wrong, we say that our algorithm has
    *one-sided errors*. There are Monte Carlo algorithms that can be wrong in both
    the “yes” and “no” cases; those are said to have *two-sided errors*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解决 Yōkan 问题的方案中，如果我们回答`YES`，那么我们可以确保是正确的。我们只有在面对能够解释为什么朋友们对这块糕点满意的确切口味时才会回答`YES`。相反，如果我们回答`NO`，那么我们可能是错误的。也许朋友们并不喜欢这块糕点——但也有可能是我们运气不好，一直挑到不好的口味。因为这两种回答中只有一种能是错的，所以我们说我们的算法具有*单边错误*。有些蒙特卡罗算法在“YES”和“NO”两种情况下都有可能出错；这些算法被称为*双边错误*。
- en: A Monte Carlo algorithm helped us solve Yōkan because the probability of randomly
    finding a useful flavor is so high. It might not seem that a 1/3 or 2/3 probability
    of success is that great, and indeed an algorithm that worked only one-third or
    two-thirds of the time wouldn’t cut it. But remember that these probabilities
    are only our starting point. By the time we’re done with our repeated attempts,
    we’ll have converted that wonderful per-attempt probability to a wonderful per-answer
    probability.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个蒙特卡罗算法帮助我们解决了 Yōkan 问题，因为随机找到一个有用口味的概率非常高。或许你会觉得1/3或2/3的成功概率并不那么出色，确实，只有三分之一或三分之二时间成功的算法是不可接受的。但是记住，这些概率只是我们的起点。在多次尝试之后，我们将把这种每次尝试的高概率转化为每次回答的高概率。
- en: Monte Carlo algorithms are useful for other problems as well. Consider a graph
    with *n* nodes and imagine dividing the nodes into two groups. There are about
    2*^n* ways to make this division, because for each of the *n* nodes we have two
    options for where to put it. Such a division of nodes into two groups is called
    a *cut*. The *minimum cut problem* asks which of these 2*^n* divisions has the
    fewest edges that cross from one group to the other. Now, if we just randomly
    chose a cut, we’d have a per-attempt probability of success of 1/2*^n*, which
    is terrible and not a promising start to a Monte Carlo algorithm. There *is* a
    Monte Carlo algorithm for this problem, though, and it hinges on the surprising
    fact that the per-attempt probability of success can be driven up to 1/*n*². Relative
    to 1/2*^n*, a probability of success of 1/*n*² is high indeed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛算法在其他问题中也很有用。考虑一个包含 *n* 个节点的图，假设我们将这些节点分成两个组。将这些节点分组的方式大约有 2*^n* 种，因为每个节点都有两个选择可以放在哪个组中。这种将节点分为两组的方式被称为*割*。*最小割问题*询问，在这
    2*^n* 种分法中，哪一种割的边数最少。现在，如果我们只是随机选择一个割，那么每次尝试成功的概率将是 1/2*^n*，这非常糟糕，根本无法作为蒙特卡洛算法的一个好开端。不过，确实存在一个蒙特卡洛算法解决这个问题，并且它依赖于一个惊人的事实：每次尝试的成功概率可以提升到
    1/*n*²。与 1/2*^n* 相比，成功的概率 1/*n*² 确实非常高。
- en: If you can find a way to come up with a “surprisingly high” per-attempt probability
    of success, then you’re well on your way to developing a useful Monte Carlo algorithm.
    Just crank up the number of attempts until you get the overall probability of
    success that you want.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能找到一种方法，使得每次尝试的成功概率“异常高”，那么你已经在开发一个有用的蒙特卡洛算法的路上了。只需要增加尝试的次数，直到达到你想要的整体成功概率。
- en: '*Las Vegas Algorithms*'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*拉斯维加斯算法*'
- en: 'A Monte Carlo algorithm is always fast and almost always correct. A *Las Vegas
    Algorithm*, by contrast, is always correct and almost always fast. (These algorithms
    were given casino-related names to evoke the idea of gambling: with a Monte Carlo
    algorithm we’re gambling with correctness, and with a Las Vegas algorithm we’re
    gambling with speed.)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛算法通常是快速且几乎总是正确的。相比之下，*拉斯维加斯算法*总是正确的，且几乎总是快速的。（这些算法被赋予与赌场相关的名字，旨在唤起赌博的概念：使用蒙特卡洛算法，我们是在与正确性赌博，而使用拉斯维加斯算法，则是在与速度赌博。）
- en: Suppose we had an algorithm that was quite fast for the vast majority of test
    cases but quite slow for the few remaining test cases. We might be okay to deploy
    this algorithm; we just have to hope that the Achilles’ heel test cases don’t
    happen very often.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个对于绝大多数测试用例非常快速，但对于少数剩余的测试用例非常慢的算法。我们可能仍然可以部署这个算法；我们只需要希望那些致命的测试用例不会经常出现。
- en: But we can do better than that, and one way is through the use of a Las Vegas
    algorithm. In such an algorithm, we randomize the decisions that the algorithm
    makes as it runs. Because the algorithm has no fixed sequence of steps, no one
    can craft a test case that’ll reliably slow it down because no one knows what
    decisions the algorithm will make on that test case!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更好，一种方法是通过使用拉斯维加斯算法。在这种算法中，我们会随机化算法运行时做出的决策。因为算法没有固定的步骤序列，所以没有人能设计出一个能可靠地拖慢它的测试用例，因为没有人知道算法在该测试用例上会做出什么决策！
- en: Why can Las Vegas algorithms be effective? I like Ethan Epperly’s article “Why
    Randomized Algorithms?” (see *[https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/](https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/)*).
    Suppose you were playing many rounds of Rock Paper Scissors against your friend.
    One approach would be to use a fixed pattern, like rock, paper, scissors, rock,
    paper, scissors, rock, paper . . . This might work for a little while—but eventually
    your friend will figure out what you’re doing, and then you’ll never win a round
    again. They’ll just keep picking the option that beats you. A better approach
    is to randomly decide what to do on each round. If you do that, you’re using a
    Las Vegas algorithm. Your friend will have no clue what’s coming next! In our
    code for such an algorithm, we’ll randomize the choices that we make so that no
    fixed test case can force us into poor performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么拉斯维加斯算法能够有效？我喜欢Ethan Epperly的文章《为什么使用随机化算法？》（参见 *[https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/](https://www.ethanepperly.com/index.php/2021/08/11/why-randomized-algorithms/)*）。假设你和朋友进行多轮石头剪子布游戏。一种方法是使用固定模式，例如石头、剪子、布、石头、剪子、布、石头、剪子……这种方法可能能行得通一段时间——但最终你的朋友会搞明白你在做什么，然后你就永远赢不了一局了。他们会一直选择能战胜你的选项。一种更好的方法是随机决定每一轮该做什么。如果你这么做，你就在使用拉斯维加斯算法。你的朋友根本不知道接下来会发生什么！在我们编写的这种算法代码中，我们会随机化我们的选择，以确保没有固定的测试用例能够迫使我们表现不佳。
- en: 'Way back in [Chapter 1](ch01.xhtml), we solved two problems using hash tables.
    In each one, we chose one specific hash function and just went for it. A malicious
    actor could bring those solutions to a crawl by intentionally causing a huge number
    of hash collisions. It’s possible to address that through a Las Vegas algorithm:
    rather than committing to a single hash function for all of time, sitting there
    waiting for someone to figure out what we’re doing, we let our program randomly
    choose which hash function to use each time it runs. Doing so is called *random
    hashing*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在[第一章](ch01.xhtml)中，我们使用哈希表解决了两个问题。在每个问题中，我们都选择了一个特定的哈希函数，并且直接使用它。一个恶意行为者可以通过故意引发大量哈希碰撞，使这些解决方案变得极其缓慢。我们可以通过拉斯维加斯算法来解决这个问题：我们不再一成不变地使用一个哈希函数，而是让程序每次运行时随机选择使用哪一个哈希函数。这样做就叫做*随机哈希*。
- en: Random hashing is a frequently used Las Vegas algorithm. But there’s one Las
    Vegas algorithm used even more frequently than that. We’re going to see that one
    in Problem 2\. First, let’s talk about whether we really do need randomization
    in the first place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随机哈希是一个常用的拉斯维加斯算法。但是，还有一个比这个更常用的拉斯维加斯算法。我们将在问题2中看到它。首先，让我们讨论一下我们是否真的需要随机化。
- en: '*Deterministic vs. Randomized Algorithms*'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*确定性算法与随机化算法*'
- en: A *deterministic algorithm* is an algorithm that doesn’t use randomness. Every
    algorithm we looked at in the first nine chapters of this book is a deterministic
    algorithm, and wow did we get a lot of mileage from those. Why not just forget
    about randomized algorithms and stick with deterministic ones, then? Why play
    around with guessing stuff and getting a 99.9999 percent probability of success
    when we can just have 100 percent success with a deterministic algorithm?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定性算法*是一种不使用随机性的算法。我们在本书前九章中讨论的所有算法都是确定性算法，哇，我们从这些算法中获得了大量的收益。那么，为什么不直接忘记随机化算法，坚持使用确定性算法呢？为什么要玩猜测游戏，虽然随机化算法的成功概率达到99.9999%，但我们可以通过确定性算法实现100%的成功呢？'
- en: The reason is that a fast randomized algorithm can be easier to develop than
    a fast deterministic algorithm. If you’re interested, you might try solving Yōkan
    without using randomization. It’s certainly possible but requires additional ideas
    not needed in the randomized algorithm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，开发一个快速的随机化算法比开发一个快速的确定性算法要容易。如果你感兴趣，可以尝试不使用随机化来解决Yōkan问题。虽然这是可能的，但需要一些在随机化算法中不需要的额外想法。
- en: There are problems where the efficiency gulf between the currently best randomized
    algorithm and the currently best deterministic algorithm is huge. For example,
    to determine whether a number is prime, there’s a randomized algorithm that runs
    in *O*(*n*²) time, but the best we’ve been able to do in terms of deterministic
    algorithms is *O*(*n*⁶).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题中，当前最好的随机化算法和最好的确定性算法之间的效率差距非常大。例如，判断一个数是否为质数的随机化算法的时间复杂度是 *O*(*n*²)，但我们在确定性算法方面所能做到的最好的是
    *O*(*n*⁶)。
- en: Likewise, it’s difficult to find a way to quickly solve our next problem with
    a deterministic algorithm. Good thing we don’t have to. Let’s do some more randomization!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用确定性算法快速解决下一个问题是比较困难的。幸运的是，我们不需要这样做。我们来做一些随机化！
- en: 'Problem 2: Caps and Bottles'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 2：瓶盖和瓶子
- en: This is DMOJ problem `cco09p4`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `cco09p4`。
- en: '*The Problem*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: We have *n* caps and *n* bottles. Each cap and bottle has a unique size, and
    there is exactly one cap that perfectly fits each bottle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 *n* 个瓶盖和 *n* 个瓶子。每个瓶盖和瓶子都有唯一的尺寸，并且每个瓶子都有一个完美匹配的瓶盖。
- en: Our goal is to match the caps to their corresponding bottles. (I’ve seen this
    problem alternately phrased as matching nuts and bolts, keys and locks, hats and
    people’s heads, you name it. Feel free to use one of these if it works as a better
    visual for you.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将瓶盖与对应的瓶子匹配起来。（我见过这个问题被换一种说法：匹配螺母和螺栓、钥匙和锁、帽子和人的头等。你可以根据自己的需求使用其中一个，更容易理解的话就选择它。）
- en: The caps and bottles have very similar sizes, so we cannot make comparisons
    between two caps or between two bottles. The only thing we can do is try to put
    a cap on a bottle to learn whether the cap is too small, the right size, or too
    big for the bottle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些瓶盖和瓶子具有非常相似的尺寸，因此我们不能直接比较两个瓶盖或两个瓶子。我们唯一能做的就是尝试将一个瓶盖放到一个瓶子上，从而了解瓶盖是太小、正合适还是太大。
- en: To solve the problem, we interact with the judge by making queries and progressively
    reporting our answer until we are done. (It’s kind of like how we interacted with
    the judge when solving Cave Doors in [Chapter 7](ch07.xhtml), but here we communicate
    with the judge by using input and output rather than by calling functions.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们通过查询与逐步报告我们的答案与评审互动，直到问题解决。（这有点像我们在解决 [第 7 章](ch07.xhtml) 中的洞门问题时与评审的互动方式，但这里我们是通过输入输出与评审通信，而不是通过调用函数。）
- en: Input and Output
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入与输出
- en: Because input and output are interleaved in this problem, we’ll look at them
    together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入与输出在这个问题中是交替进行的，因此我们将它们一起考虑。
- en: To start, we read the integer *n*, which tells us the number of caps and bottles
    that we must match. *n* is between 1 and 10,000\. The caps are numbered from 1
    to *n*, as are the bottles.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，我们读取整数 *n*，它告诉我们必须匹配的瓶盖和瓶子的数量。*n* 在 1 到 10,000 之间。瓶盖从 1 到 *n* 编号，瓶子也是如此。
- en: After reading *n*, we can interact with the judge in two ways.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取了 *n* 之后，我们可以通过两种方式与评审进行互动。
- en: '**Query**   We can make a query by outputting `0 cap_num bottle_num`. This
    asks the judge to tell us about the relationship between the cap numbered `cap_num`
    and the bottle numbered `bottle_num`. We need to read from the input to get the
    answer to our query. We’ll get a –1 if the cap is too small for the bottle, a
    0 if it matches the bottle, or a 1 if it’s too big for the bottle.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**  我们可以通过输出 `0 cap_num bottle_num` 来进行查询。这个查询请求评审告诉我们编号为 `cap_num` 的瓶盖与编号为
    `bottle_num` 的瓶子之间的关系。我们需要从输入中读取数据来获得查询的答案。如果瓶盖对于瓶子来说太小，答案是 -1；如果瓶盖和瓶子匹配，答案是 0；如果瓶盖对于瓶子来说太大，答案是
    1。'
- en: '**Report**   We can tell the judge part of our answer by outputting `1 cap_num
    bottle_num`, which means that we are matching the cap numbered `cap_num` with
    the bottle numbered `bottle_num`. The judge doesn’t produce anything for us to
    read in response.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告**  我们可以通过输出 `1 cap_num bottle_num` 向评审报告部分答案，这表示我们将编号为 `cap_num` 的瓶盖与编号为
    `bottle_num` 的瓶子匹配。评审不会返回任何东西让我们读取。'
- en: We need to eventually make *n* reports to the judge in order to match each of
    the *n* caps with some distinct bottle. We can mix and match queries and reports
    as we prefer; that is, there’s no requirement to make all queries before all reports
    or anything like that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要向评审做 *n* 次报告，以便将每个 *n* 个瓶盖与一些不同的瓶子匹配。我们可以随意混合和匹配查询与报告，也就是说，并没有要求所有查询必须在所有报告之前完成，或类似的限制。
- en: We are allowed to make at most 500,000 queries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最多可以进行 500,000 次查询。
- en: '*Solving a Subtask*'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决子任务*'
- en: For most problems in this book, we read from standard input, do what the problem
    asks, and output the answer on standard output. Oftentimes, such as for each problem
    in the previous chapter, what we read from standard input are operations that
    tell us what to do next. The interaction for this Caps and Bottles problem is
    a little different. Rather than being asked to respond to queries, we are the
    ones making the queries to the judge.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的大多数问题，我们从标准输入读取，按照问题的要求操作，然后在标准输出上输出答案。通常情况下，例如上一章中的每个问题，我们从标准输入读取的是指示我们下一步要做什么的操作。而这个瓶盖和瓶子问题的交互方式稍有不同。我们不是响应评审的查询，而是我们向评审提出查询。
- en: The last time we had a nonstandard interaction with the judge was when we solved
    Cave Doors in [Chapter 7](ch07.xhtml). There, we first solved a small subtask,
    rather than the whole problem, to give us confidence that we were interacting
    correctly. Let’s start that way here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一次与裁判进行非标准交互是在[第7章](ch07.xhtml)解决洞门问题时。在那里，我们先解决了一个小的子任务，而不是整个问题，以确保我们正确地进行交互。我们也可以这样开始这里的任务。
- en: The first subtask for this problem guarantees that *n* will be at most 700\.
    The first algorithm that we come up with might make a lot of queries; the hope
    is that with only 700 caps and bottles we’ll be able to pass at least those test
    cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的第一个子任务保证*n*最多为700。我们想到的第一个算法可能会发出很多查询；希望通过700个帽子和瓶子，我们至少能通过这些测试用例。
- en: We need to figure out which bottle goes with each cap. Well, why not go through
    the caps one by one, and just ask about each bottle for each cap? If we do that,
    we get the code in [Listing 10-7](ch10.xhtml#ch010ex07).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要弄清楚哪个瓶子与每个帽子匹配。那么，为什么不一个一个地遍历这些帽子，然后分别询问每个帽子对应哪个瓶子呢？如果我们这样做，就会得到[列表10-7](ch10.xhtml#ch010ex07)中的代码。
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-7: Solving subtask 1*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7：解决子任务1*'
- en: Let’s make sure we’ve got the interaction right. We start by reading the value
    of `n` ❶, which tells us how many caps and bottles we’re dealing with. Then we
    have a double `for` loop that considers matching each cap with each bottle. For
    each such cap-bottle pair, we query the judge ➋. We know that the judge will then
    produce a response, so we read that next ➌. If we’ve found a match, we tell the
    judge about it ➍.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保交互是正确的。我们从读取`n`的值开始❶，这告诉我们有多少个帽子和瓶子。然后，我们有一个双重`for`循环，考虑将每个帽子与每个瓶子进行匹配。对于每个帽子-瓶子组合，我们会查询裁判
    ➋。我们知道裁判会给出回应，所以我们接下来读取这个回应 ➌。如果我们找到了匹配，我们会告诉裁判 ➍。
- en: It’s a bit of a mind-bend to test this program locally, but let’s do it anyway.
    We need to play the role of the judge, responding consistently to the queries
    that the program makes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地测试这个程序有点费脑筋，但我们还是来试试吧。我们需要扮演裁判的角色，一致地回答程序提出的查询。
- en: 'We’ll work through a test case with three caps and bottles. To “play judge,”
    we need to settle on some sizes for the caps and bottles so that we can respond
    consistently to the queries. The program will never know what these sizes are,
    but as the judge we need them so that we know whether a cap is too small or too
    large. Let’s agree that the cap sizes are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个包含三个帽子和瓶子的测试用例来进行处理。为了“扮演裁判”，我们需要为帽子和瓶子确定一些尺寸，以便我们能够一致地回答查询。程序永远不会知道这些尺寸，但作为裁判，我们需要它们，这样我们才能知道一个帽子是否太小或太大。让我们约定帽子的尺寸如下：
- en: '![Image](../images/pg392-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg392-01.jpg)'
- en: 'and that the bottle sizes are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 并且瓶子的尺寸如下：
- en: '![Image](../images/pg392-02.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg392-02.jpg)'
- en: If the program handles this test case correctly, it will match Cap 1 with Bottle
    2, Cap 2 with Bottle 1, and Cap 3 with Bottle 3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序正确处理这个测试用例，它将把Cap 1与Bottle 2匹配，把Cap 2与Bottle 1匹配，把Cap 3与Bottle 3匹配。
- en: Run our program. Type `3` from the keyboard to indicate that `n` is `3`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的程序。从键盘上输入`3`，表示`n`的值是`3`。
- en: Now the program starts making queries. You’ll see those show up as part of the
    program’s output. The first one is `0 1 1`, which is asking us for the relationship
    between Cap 1 and Bottle 1\. Cap 1 (size 23) is smaller than Bottle 1 (size 85),
    so we need to type `-1` here. Go ahead—and once you do, we’ll be asked another
    query.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序开始发出查询。你会看到它们出现在程序的输出部分。第一个查询是`0 1 1`，它在询问我们关于Cap 1和Bottle 1之间的关系。Cap 1（大小23）比Bottle
    1（大小85）小，所以我们在这里需要输入`-1`。继续输入——一旦你完成，我们将收到另一个查询。
- en: The next query we get is `0 1 2`, which asks us about Cap 1 and Bottle 2\. This
    cap and bottle match, so type `0`. The program correctly reports that Cap 1 and
    Bottle 2 are matched.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的下一个查询是`0 1 2`，它在询问我们关于Cap 1和Bottle 2的情况。这个帽子和瓶子是匹配的，所以输入`0`。程序正确报告Cap 1与Bottle
    2匹配。
- en: 'Now that our program has figured out how to match Cap 1, it should move on
    to Cap 2\. That’s exactly what it does, as we can see from the next query: `0
    2 1`. Cap 2 and Bottle 1 match, so we need to type `0` in response. The program
    now correctly reports a match between Cap 2 and Bottle 1.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的程序已经弄清楚如何匹配Cap 1，它应该继续处理Cap 2。正如我们从下一个查询中看到的那样，它确实做到了：`0 2 1`。Cap 2和Bottle
    1匹配，所以我们需要输入`0`作为回应。程序现在正确报告Cap 2与Bottle 1匹配。
- en: All the program has to figure out now is what to do with Cap 3\. It asks the
    query `0 3 1`, to which we must type `-1` because Cap 3 is smaller than Bottle
    1\. Then it asks `0 3 2`, and again we type `-1`. Finally, we get the query `0
    3 3`; as Cap 3 and Bottle 3 match, we type `0`. When we do so, the program should
    correctly report that Cap 3 is matched with Bottle 3 . . . and we’re done! The
    program has successfully matched the caps and bottles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序要做的就是处理瓶盖3。它询问查询`0 3 1`，我们必须输入`-1`，因为瓶盖3比瓶子1小。然后它询问`0 3 2`，我们再次输入`-1`。最后，我们得到查询`0
    3 3`；由于瓶盖3与瓶子3匹配，我们输入`0`。当我们这么做时，程序应该正确报告瓶盖3与瓶子3匹配……然后我们完成了！程序成功地匹配了瓶盖和瓶子。
- en: If you submit our code to the judge, you should pass a few test cases.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们的代码提交给评审，应该能够通过一些测试用例。
- en: The reason we don’t pass more is because of the requirement that we make at
    most 500,000 queries. We can tell from our nested `for` loops that we have an
    *O*(*n*²) algorithm here. With 10,000 caps and bottles, we might make up to 10,
    000² = 100,000,000 queries. That’s way too many! We’ll need new ideas to complete
    the remaining subtasks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有通过更多测试的原因在于要求我们最多进行500,000次查询。从我们嵌套的`for`循环可以看出，我们的算法是*O*(*n*²)。如果有10,000个瓶盖和瓶子，我们最多可能进行10,000²
    = 100,000,000次查询。这太多了！我们需要新的思路来完成剩下的子任务。
- en: '*Solution 1: Recursion*'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法1：递归*'
- en: If we stay with our idea of choosing a cap and then figuring out which bottle
    matches it, we need to make better use of the information that the judge gives
    us.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们坚持选择一个瓶盖，然后找出哪个瓶子匹配它，我们需要更好地利用评审给我们的信息。
- en: Piles of Caps and Bottles
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 瓶盖和瓶子的堆叠
- en: In the algorithm that we used to solve the subtask, we ask the judge about the
    relationship between Cap 1 and Bottle 1, Cap 1 and Bottle 2, Cap 1 and Bottle
    3, and so on, until we find the bottle that matches Cap 1\. Maybe we finally find
    the match with bottle 5,000\. That was a lot of work! For the cost of 5,000 queries,
    we match one cap and one bottle, and that’s all we get. We’re back to square one
    for the next cap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用来解决子任务的算法中，我们询问评审瓶盖1与瓶子1、瓶盖1与瓶子2、瓶盖1与瓶子3之间的关系，依此类推，直到找到与瓶盖1匹配的瓶子。也许我们最后在瓶子5000上找到了匹配。这花了很多功夫！花费5000次查询，我们才匹配了一个瓶盖和一个瓶子，仅此而已。对于下一个瓶盖，我们又得从头开始。
- en: We’re throwing away a lot of information on our way to matching that first cap,
    though, and that’s information we can use to make it easier for us to match other
    caps later. In particular, so far we’re not doing anything with the “too small”
    and “too big” information that the judge gives us.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在匹配第一个瓶盖的过程中，我们丢失了很多信息，而这些信息可以帮助我们稍后更容易地匹配其他瓶盖。特别是，到目前为止，我们没有处理评审给出的“太小”和“太大”的信息。
- en: 'If you were doing this by hand, how could you use this information from the
    judge? One thing you might do is form two piles of bottles: one of small bottles
    and one of big bottles. suppose we find that Cap 1 is too small for Bottle 1\.
    Throw that bottle into the big pile. Then maybe we find that Cap 1 is too big
    for Bottle 2\. That bottle goes into the small pile. Cap 1 is too big for Bottle
    3? That bottle goes into the small pile, as well. Do this for every bottle.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是手动操作的，如何使用评审提供的信息呢？你可以做的一件事是将瓶子分为两堆：一堆是小瓶子，另一堆是大瓶子。假设我们发现瓶盖1对瓶子1来说太小了。把那个瓶子丢进大堆里。然后，也许我们发现瓶盖1对瓶子2来说太大了。那瓶子就进入小堆。瓶盖1对瓶子3来说太大吗？那个瓶子也进小堆。对每个瓶子都这么做。
- en: Now what we have are two piles of bottles. Maybe these are subproblems? The
    hope is that we could solve each subproblem and thereby solve the original problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两堆瓶子。也许这些是子问题？希望我们能够解决每个子问题，从而解决原始问题。
- en: This may feel like the setup to a dynamic-programming solution. But it’s not,
    because the two subproblems are not overlapping. Solving one of them doesn’t help
    us at all with the other one. Recursion, then? Can we use that?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像是动态规划解法的开端，但实际上不是，因为这两个子问题并没有重叠。解决一个子问题对另一个子问题没有任何帮助。那么，递归呢？我们可以使用它吗？
- en: 'For recursion to work, we need each subproblem to be a smaller version of the
    original problem. Our original problem had a bunch of caps and bottles. But, so
    far, our subproblems have only bottles. Where are the caps to go with those bottles?
    We need to find a way to split the caps into small caps and large caps, too. Once
    we do that, we’ll truly have our two subproblems: one for the small caps and bottles
    and one for the big caps and bottles.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使递归工作，我们需要确保每个子问题都是原始问题的一个更小的版本。我们原始的问题有一堆瓶盖和瓶子。但是，到目前为止，我们的子问题只有瓶子。那么，这些瓶子应该配什么瓶盖呢？我们需要找到一种方法，将瓶盖分为小瓶盖和大瓶盖。一旦我们做到这一点，我们就会真正拥有两个子问题：一个是针对小瓶盖和瓶子的，另一个是针对大瓶盖和瓶子的。
- en: Here are the overall steps that we’ll use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将使用的总体步骤。
- en: '**Step 1**   Choose a cap for our subproblem.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**   选择一个瓶盖作为我们的子问题。'
- en: '**Step 2**   Go through the bottles. If the cap is smaller than the bottle,
    put the bottle in the pile of big bottles; if the cap is bigger than the bottle,
    put the bottle in the pile of small bottles. At some point during this step, we’re
    going to find the bottle that matches the cap. Call this the *matching bottle*.
    Report the match between the cap and the matching bottle.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**   遍历瓶子。如果瓶盖小于瓶子，将瓶子放入大瓶子的堆中；如果瓶盖大于瓶子，将瓶子放入小瓶子的堆中。在此步骤的某个时刻，我们会找到与瓶盖匹配的瓶子。把这个瓶子叫做*匹配瓶子*。报告瓶盖和匹配瓶子之间的配对。'
- en: At the end of Step 2, we’ll have the two piles of bottles that we need. Now
    for the caps . . .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 结束时，我们将得到我们需要的两堆瓶子。现在，瓶盖的处理...
- en: '**Step 3**   Go through the caps. If the current cap is smaller than the matching
    bottle, put the cap in the pile of small caps; if the current cap is bigger than
    the matching bottle, put the cap in the pile of big caps. At the end of this step,
    we’ll have the two piles of caps that we need.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**   遍历瓶盖。如果当前瓶盖小于匹配瓶子，将瓶盖放入小瓶盖的堆中；如果当前瓶盖大于匹配瓶子，将瓶盖放入大瓶盖的堆中。在此步骤结束时，我们将拥有我们需要的两堆瓶盖。'
- en: '**Step 4**   Recursively solve the subproblem on the small caps and small bottles.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4**   递归地解决小瓶盖和小瓶子的子问题。'
- en: '**Step 5**   Recursively solve the subproblem on the big caps and big bottles.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5**   递归地解决大瓶盖和大瓶子的子问题。'
- en: Like binary search, this is an example of a divide and conquer algorithm. We’re
    dividing the caps and bottles into smaller, independent subproblems and then conquering
    each of those subproblems recursively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 像二分查找一样，这是一个分治算法的例子。我们将瓶盖和瓶子分解成更小的独立子问题，然后递归地解决每个子问题。
- en: The main Function
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: There’s a bit of setup we need to do before we can implement our algorithm;
    let’s get that out of the way first. See [Listing 10-8](ch10.xhtml#ch010ex08)
    for our `main` function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现算法之前，有一些设置工作需要完成；我们先把这些处理掉。请参见[清单 10-8](ch10.xhtml#ch010ex08)中的`main`函数。
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-8: The* main *function*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：* 主 *函数*'
- en: 'There are two important arrays here: `cap_nums` and `bottle_nums` ❶. We will
    initialize these arrays so that they contain all cap numbers ➋ and all bottle
    numbers ➌, respectively. This is our starting point for the caps and bottles that
    we’re working with. In the code that we’ll see next, we’ll be making recursive
    calls on smaller subsets of those caps and bottles.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的数组：`cap_nums`和`bottle_nums` ❶。我们将初始化这些数组，使它们分别包含所有瓶盖的编号 ➋ 和所有瓶子的编号 ➌。这将是我们处理的瓶盖和瓶子的起点。在接下来的代码中，我们将对这些瓶盖和瓶子的更小子集进行递归调用。
- en: Implementing Our Algorithm
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现我们的算法
- en: Now let’s turn our five-step algorithm into code. See [Listing 10-9](ch10.xhtml#ch010ex09).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这五步算法转化为代码。请参见[清单 10-9](ch10.xhtml#ch010ex09)。
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-9: Solution 1*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：解决方案 1*'
- en: Prior to our code that implements our five steps, we have some `malloc` calls.
    We need those so that we have memory for the piles of caps and bottles that we’ll
    form.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们五步算法的代码之前，我们有一些`malloc`调用。我们需要这些调用，以便为我们将要创建的瓶盖和瓶子的堆分配内存。
- en: For Step 1, we must choose a cap. We can make that easy if we just choose the
    first cap. Yeah, let’s just do that ❶ and move on. Nothing to see here.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于步骤 1，我们必须选择一个瓶盖。如果我们直接选择第一个瓶盖，这会让问题变得简单。是的，就这么做❶，然后继续。没什么好看。
- en: For Step 2, we use a `for` loop to go through all of the bottles ➋. For each
    cap, there are three possibilities for the if statement inside this loop. In the
    first, we find a match ➌, so we tell the judge about the match and remember the
    matching bottle for later. In the second, the cap is too small for the bottle,
    so we throw the bottle into the pile of big bottles. In the third, the cap is
    too big for the bottle, so we throw the bottle into the pile of small bottles.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于步骤2，我们使用 `for` 循环遍历所有瓶子 ➋。对于每个瓶盖，在这个循环中的 `if` 语句里有三种可能性。第一种情况下，我们找到匹配 ➌，然后告诉评测系统这个匹配并记住匹配的瓶子以便后续使用。第二种情况下，瓶盖太小，无法匹配瓶子，我们就把瓶子放进大瓶子堆里。第三种情况下，瓶盖太大，无法匹配瓶子，我们就把瓶子放进小瓶子堆里。
- en: Step 3 is similar to Step 2, but this time we go through all of the caps ➍ rather
    than all of the bottles. If the cap is too small for the bottle, we throw the
    cap into the pile of small caps. If the cap is too big for the bottle, we throw
    the cap into the pile of big caps. Be careful not to mix these up! It’s easy to
    mess up a `-1` or a `1` and throw caps or bottles in the wrong piles.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3与步骤2类似，但这次我们遍历所有瓶盖 ➍ 而不是所有瓶子。如果瓶盖太小，无法匹配瓶子，我们就把瓶盖扔进小瓶盖堆里。如果瓶盖太大，无法匹配瓶子，我们就把瓶盖扔进大瓶盖堆里。一定要小心不要弄错！很容易搞错一个
    `-1` 或 `1`，把瓶盖或瓶子放进错误的堆里。
- en: For Step 4, we solve the “small caps and small bottles” subproblem with a recursive
    call ➎.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于步骤4，我们通过递归调用 ➎ 解决“小瓶盖和小瓶子”的子问题。
- en: And finally, for Step 5, we solve the “big caps and big bottles” subproblem
    through another recursive call ➏.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于步骤5，我们通过另一个递归调用 ➏ 解决“大瓶盖和大瓶子”的子问题。
- en: And that’s it! Get the small stuff in one subproblem, get the big stuff in another
    subproblem, and solve both subproblems recursively. Pretty slick, right? . . .
    Right?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！将小的部分放入一个子问题，将大的部分放入另一个子问题，并递归地解决这两个子问题。很巧妙，对吧？……对吧？
- en: Unfortunately it isn’t quite slick enough. If you submit our code to the judge,
    you will find that it times out before passing all test cases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它还不够巧妙。如果你将我们的代码提交给评测系统，你会发现它在通过所有测试用例之前就超时了。
- en: We are very close to nailing this problem, though. All we need to add is randomization.
    Why is our current solution not quite there? And how will randomization fix it?
    Those answers are next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们离解决这个问题已经很近了。我们需要做的就是添加随机化。为什么我们当前的解决方案还不够好？随机化又是如何解决这个问题的呢？这些问题的答案会在接下来的部分讲解。
- en: '*Solution 2: Adding Randomization*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案2：添加随机化*'
- en: Before we see how to add randomization, let’s understand exactly the kind of
    test case that defeats Solution 1.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到如何添加随机化之前，让我们先准确了解一下是什么样的测试用例会击败解决方案1。
- en: Why Solution 1 Is Slow
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么解决方案1会很慢
- en: 'Each call of our `solve` function operates on some caps and some bottles. Our
    choice of cap splits the caps and bottles into two groups: the group with the
    small caps and bottles and the group with the big caps and bottles. No matter
    which cap we choose, we get this correct behavior.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `solve` 函数的每次调用都会操作一些瓶盖和一些瓶子。我们选择的瓶盖将瓶盖和瓶子分成两组：一组是小瓶盖和小瓶子，另一组是大瓶盖和大瓶子。无论我们选择哪个瓶盖，都能得到正确的行为。
- en: That said, the cap we choose does have a major impact on the number of queries
    that we’ll need to solve the problem. The algorithm that we used to solve the
    subtask ([Listing 10-7](ch10.xhtml#ch010ex07)) was an *O*(*n*²) algorithm, and
    it was too slow. So to offer an explanation for why Solution 1 is too slow, what
    we can do is demonstrate that it, too, has test cases on which it takes *O*(*n*²)
    time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们选择的瓶盖确实会对解决问题所需的查询次数产生重大影响。我们用来解决子任务的算法（[第10-7列表](ch10.xhtml#ch010ex07)）是一个
    *O*(*n*²) 算法，它的速度太慢了。因此，为了说明解决方案1为何太慢，我们可以通过展示它也有一些测试用例，处理这些用例时需要 *O*(*n*²) 的时间。
- en: The test case we’ll use may intuitively feel like it should be an easy one.
    But that intuition is wrong.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的测试用例直觉上可能觉得它应该是一个简单的测试用例。但这种直觉是错误的。
- en: 'As always for this problem, we’ll have *n* caps and *n* bottles. The sizes
    of the caps will increase from Cap 1 to Cap *n*. For example, we can say that
    Cap 1 has size 1, Cap 2 has size 2, Cap 3 has size 3, and so on. Let’s do similarly
    for the bottles: Bottle 1 has size 1, Bottle 2 has size 2, Bottle 3 has size 3,
    and so on.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，对于这个问题，我们有 *n* 个瓶盖和 *n* 个瓶子。瓶盖的大小从瓶盖1到瓶盖 *n* 依次增大。例如，我们可以说瓶盖1的大小是1，瓶盖2的大小是2，瓶盖3的大小是3，依此类推。对于瓶子也是一样：瓶子1的大小是1，瓶子2的大小是2，瓶子3的大小是3，依此类推。
- en: Now, what will our Solution 1 algorithm do? On the first call of `solve`, it
    will choose Cap 1 on which to split the caps and bottles. It’ll loop through the
    caps, which costs *n* queries, and then it’ll loop through the bottles, which
    costs another *n* queries. So that’s 2*n* queries so far. And what of our subproblems?
    Do they have similar sizes or are they very lopsided?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的方案 1 算法会做什么呢？在第一次调用`solve`时，它会选择第一个分界点来拆分分界点和瓶子。它会遍历这些分界点，这需要 *n* 次查询，然后遍历瓶子，这又需要
    *n* 次查询。所以到目前为止是 2*n* 次查询。那么，我们的子问题呢？它们的大小是否相似，还是非常不均衡？
- en: They are lopsided! There are no caps or bottles that are smaller than the chosen
    cap. So the “smaller caps and bottles” subproblem is empty. The “bigger caps and
    bottles” subproblem, then, has everything—all remaining *n* – 1 caps and bottles.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是极度不均衡的！没有任何分界点或瓶子比所选的分界点小。所以，“较小的分界点和瓶子”子问题是空的。那么，“较大的分界点和瓶子”子问题就包含了所有剩余的
    *n* – 1 个分界点和瓶子。
- en: 'What happens on that subproblem with *n* – 1 caps and bottles? Again, we’re
    going to pick the first cap, which is Cap 2 this time. We’ll make *n* – 1 queries
    as we make our way through the first `for` loop and then another *n* – 1 queries
    as we make our way through the second loop. That’s 2(*n* – 1) queries for this
    subproblem. And, again, the two subproblems stemming from this one are as lopsided
    as can be: an empty subproblem and a subproblem with *n* – 2 caps and bottles.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，带有 *n* – 1 个分界点和瓶子的子问题会发生什么呢？同样，我们会选择第一个分界点，这次是分界点 2。我们将通过第一个`for`循环进行 *n*
    – 1 次查询，然后通过第二个循环再进行 *n* – 1 次查询。这对于这个子问题来说是 2(*n* – 1) 次查询。而且，源自这个子问题的两个子问题是极度不均衡的：一个空子问题和一个包含
    *n* – 2 个分界点和瓶子的子问题。
- en: The situation here is very similar to the one on [page 307](ch08.xhtml#sec129)
    that clobbered us when we were solving Building Treaps. In each case, we were
    hoping for a nice, even split of our problem into two subproblems. When we don’t
    get that, we end up doing a quadratic amount of work. Here, we’ll make 2*n* queries,
    then 2(*n* – 1) queries, then 2(*n* – 2) queries, and so on. The total number
    of queries we’ll make is 2(1 + 2 + 3 + . . . + *n*), which is *O*(*n*²).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的情况非常类似于我们在解决构建 Treaps 时遇到的[第 307 页](ch08.xhtml#sec129)的情况。在每种情况下，我们都希望能将问题均匀地拆分成两个子问题。但如果没有得到这样的拆分，我们最终做的工作量是二次的。在这里，我们将执行
    2*n* 次查询，然后是 2(*n* – 1) 次查询，再然后是 2(*n* – 2) 次查询，以此类推。我们将进行的查询总数是 2(1 + 2 + 3 +
    . . . + *n*)，这就是 *O*(*n*²)。
- en: Darn! All of that fancy splitting and recursing, and yet we’re still stuck at
    *O*(*n*²).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 真糟糕！所有这些复杂的拆分和递归，结果我们还是被困在 *O*(*n*²)。
- en: What We Will Randomize
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们将随机化的内容
- en: In Solution 1, we chose the first cap and split our problem around it. That
    first cap determines what counts as “small” and “big.” As we just saw, if that
    cap does a poor job of splitting, then our algorithm can be quadratic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在方案 1 中，我们选择了第一个分界点并围绕它拆分了问题。这个第一个分界点决定了什么是“较小”的，什么是“较大”的。正如我们刚才看到的，如果这个分界点的拆分效果不佳，那么我们的算法可能会变成二次时间复杂度。
- en: 'You might wonder whether we can avoid that poor behavior by making a “smarter”
    choice of cap. Maybe we should have chosen the rightmost cap? Unfortunately not:
    the test case from the prior subsection would wreck that, too. Maybe we should
    have chosen the cap in the middle? Sure, but then someone could craft a test case
    where the middle caps are always the smallest caps. Then we’d be back to quadratic
    land again.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，是否可以通过做出一个“更聪明”的分界点选择来避免这种不好的表现。也许我们应该选择最右边的分界点？不幸的是，前一小节中的测试用例也会破坏这一选择。也许我们应该选择中间的分界点？当然可以，但那时就可能有人设计出一种测试用例，其中中间的分界点总是最小的分界点。那样我们又会回到二次时间复杂度的情况了。
- en: The best thing to do here is to choose our caps randomly! Each time we need
    a cap, we’ll call `rand` to get it. If we do that, no test case can reliably cause
    poor performance because on each run we’ll make different choices for how the
    algorithm executes. This converts our deterministic algorithm into a Las Vegas
    algorithm.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最好的做法是随机选择我们的分界点！每次需要一个分界点时，我们都调用`rand`来获取它。如果我们这样做，没有任何测试用例能可靠地导致性能差，因为在每次运行时，我们会做出不同的选择，影响算法的执行方式。这将我们的确定性算法转化为拉斯维加斯算法。
- en: Contrast this use of randomization with the kind of randomization that we used
    when solving Yōkan. In Yōkan, the randomization determined whether we got the
    right answer. In Caps and Bottles, we always get the right answer; the randomization
    determines how fast we get it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种随机化与我们在解决Yōkan时使用的随机化进行对比。在Yōkan中，随机化决定了我们是否得到了正确答案。而在“分界点与瓶子”问题中，我们总是能得到正确答案；随机化决定了我们得到答案的速度。
- en: Adding the Randomization
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加随机化
- en: We need just two changes to Solution 1\. First, we need to add the call of `srand`
    to the `main` function in [Listing 10-8](ch10.xhtml#ch010ex08), just as we did
    when solving Yōkan.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要对解法 1 做两个修改。首先，我们需要像在解决“羊羹”问题时那样，在[列表 10-8](ch10.xhtml#ch010ex08)中的`main`函数中添加`srand`的调用。
- en: 'Second, we need to choose a random cap in [Listing 10-9](ch10.xhtml#ch010ex09).
    Rather than choosing the first cap:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我们需要在[列表 10-9](ch10.xhtml#ch010ex09)中选择一个随机的枢纽。与其选择第一个枢纽：
- en: '[PRE12]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'we choose a random one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个随机的：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you make those two changes and submit the updated code to the judge, you
    should find that it passes all test cases. Randomization has done it again!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了这两个修改，并将更新后的代码提交给评测系统，你应该会发现它通过了所有的测试用例。随机化再次起作用了！
- en: Believe it or not, in solving this problem we’ve also managed to secretly learn
    one of the most famous algorithms in computer science. Let’s go there next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，在解决这个问题的过程中，我们也偷偷学会了计算机科学中最著名的算法之一。接下来我们来看一下。
- en: Quicksort
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速排序
- en: 'The key idea in our solution to Caps and Bottles is to choose a cap and then
    use that cap to split the problem into two subproblems: one subproblem with the
    small stuff and the other with the big stuff. This idea most famously powers a
    sorting algorithm called *Quicksort*.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决盖子和瓶子问题的关键思想是选择一个盖子，然后使用该盖子将问题拆分为两个子问题：一个子问题处理小的部分，另一个处理大的部分。这个思想最著名的应用是一个叫做*快速排序*的排序算法。
- en: '*Implementing Quicksort*'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实现快速排序*'
- en: Quicksort is one of many algorithms that can be used to sort an array; in practice,
    it’s one of the . . . quickest. In Caps and Bottles, the item that’s used to split
    the problem is a cap; in Quicksort, the value that’s used to split the array is
    called the *pivot*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是众多可以用来排序数组的算法之一；在实践中，它是其中之一……最快的。在“盖子和瓶子”问题中，用来拆分问题的项是一个盖子；在快速排序中，用来拆分数组的值被称为*枢纽*。
- en: The code for Quicksort is similar to the code we used to solve Caps and Bottles.
    Check it out in [Listing 10-10](ch10.xhtml#ch010ex010).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的代码与我们用来解决盖子和瓶子问题的代码类似。请查看[列表 10-10](ch10.xhtml#ch010ex010)中的代码。
- en: '[PRE14]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-10: Quicksort*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-10：快速排序*'
- en: We choose a random pivot index ❶ and move the pivot to the left end of the array
    ➋. We want the pivot out of the way like that so that we don’t lose track of it—we’ll
    need to put it in the correct place later.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个随机的枢纽索引 ❶，并将枢纽移动到数组的左端 ➋。我们要把枢纽移开，这样就不会丢失它——我们稍后需要将它放到正确的位置。
- en: Next, we go through all of the other values in the array ➌, adding each to `big_values`
    or `small_values` as appropriate. Once that’s done, we make our two recursive
    calls to sort the small values and sort the big values.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历数组中的所有其他值 ➌，根据需要将它们添加到`big_values`或`small_values`中。一旦完成，我们将做出两个递归调用，分别对小值和大值进行排序。
- en: 'What we want to do next is paste everything together: first the small values,
    then the pivot, then the big values. We copy the small values to the beginning
    of the `values` array ➍, then copy the pivot ➎, then copy the big values ➏.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是将所有内容拼接在一起：首先是小值，然后是枢纽，最后是大值。我们将小值复制到`values`数组的开头 ➍，然后复制枢纽 ➎，最后复制大值
    ➏。
- en: Next, we’ll see why our solution to Caps and Bottles is so fast. While we’ll
    couch our discussion in terms of Caps and Bottles, what we learn about its runtime
    directly applies to the runtime of Quicksort as well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到为什么我们解决盖子和瓶子问题的解法如此快速。虽然我们会用盖子和瓶子的问题来讨论，但我们学到的关于运行时间的知识也直接适用于快速排序的运行时间。
- en: '*Worst-Case and Expected Runtime*'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*最坏情况和预期运行时间*'
- en: Our solution to Caps and Bottles is a Las Vegas algorithm. The runtime depends
    on how well each of our randomly chosen caps splits the problem into the two subproblems.
    If we choose terrible cap after terrible cap, we get *O*(*n*²) runtime. But that’s
    the worst-case behavior; the whole reason we introduced randomization was to make
    it extremely unlikely that this would actually happen. Rather than focusing on
    the worst-case runtime of such an algorithm, then, algorithm designers tend to
    focus on the *expected runtime*, which tells us what we can expect to happen in
    practice.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的盖子和瓶子问题的解法是一种拉斯维加斯算法。运行时间取决于我们随机选择的每个盖子将问题拆分为两个子问题的效果。如果我们每次都选到糟糕的盖子，运行时间将是*O*(*n*²)。但那是最坏情况的表现；我们引入随机化的原因就是为了让这种情况极不可能发生。因此，算法设计者通常不关注这种算法的最坏情况运行时间，而是更关注*预期运行时间*，即告诉我们在实际情况中可能发生的情况。
- en: 'What can we expect in practice for our randomized solution to Caps and Bottles?
    We already know what happens if we’re shockingly unlucky: we get *O*(*n*²) performance.
    What happens if we’re shockingly lucky, picking caps that perfectly split each
    problem in half?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们对于瓶盖和瓶子的随机化解决方案，实践中会期望什么样的表现呢？我们已经知道如果运气极差会发生什么：我们会得到 *O*(*n*²) 的性能。如果我们运气极好，恰好选择能够完美划分每个问题一半的瓶盖，会发生什么呢？
- en: To begin, we’ll choose our cap and make our 2*n* queries, as we always do. If
    that cap perfectly splits the problem in half, then we’ll need to work on two
    subproblems each with *n*/2 caps and bottles. Each of those two subproblems will
    generate 2*n*/2 = *n* queries of their own before they in turn recurse. So those
    two subproblems with *n*/2 caps and bottles will generate 2*n* queries, just like
    our original problem did.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择瓶盖并进行 2*n* 次查询，就像我们一直做的那样。如果这个瓶盖完美地将问题一分为二，那么我们将需要处理两个子问题，每个子问题包含 *n*/2
    个瓶盖和瓶子。这两个子问题中的每一个在递归之前将会各自生成 2*n*/2 = *n* 次查询。因此，这两个包含 *n*/2 个瓶盖和瓶子的子问题将会生成 2*n*
    次查询，就像我们原始问题一样。
- en: Now, if each subproblem with *n*/2 caps and bottles is split perfectly, then
    we get four problems of size *n*/4\. Each of those four will generate 2*n*/4 =
    *n*/2 queries before they recurse, for a total of 2*n* queries.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果每个包含 *n*/2 个瓶盖和瓶子的子问题被完美地划分，那么我们会得到四个大小为 *n*/4 的问题。每个问题在递归之前会生成 2*n*/4
    = *n*/2 次查询，总共会有 2*n* 次查询。
- en: To summarize, we make 2*n* queries for our original problem of size *n*, 2*n*
    queries in total for our subproblems of size *n*/2, 2*n* queries in total for
    our subproblems of size *n*/4, and so on. We can only do this about log *n* times
    before we reach base case subproblems. So, we do 2*n* queries a total of log *n*
    times, for a total of *O*(*n* log *n*) queries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们为原始大小为 *n* 的问题进行了 2*n* 次查询，为大小为 *n*/2 的子问题总共进行了 2*n* 次查询，为大小为 *n*/4 的子问题总共进行了
    2*n* 次查询，以此类推。我们最多只能进行 log *n* 次这样的操作，直到到达基本情况的子问题。所以，我们总共进行了 2*n* 次查询，共进行 log
    *n* 次，因此总共进行了 *O*(*n* log *n*) 次查询。
- en: Another way to see this *O*(*n* log *n*) bound is through a *recursion tree*.
    Such a tree characterizes how much work is done in each call of a recursive function.
    When we have perfect splits all the way down, our recursion tree looks like the
    one in [Figure 10-1](ch10.xhtml#ch010fig01).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种理解 *O*(*n* log *n*) 上界的方法是通过 *递归树*。这样的树能够描述每次递归调用中所做的工作量。当我们一直得到完美的划分时，我们的递归树就像
    [图 10-1](ch10.xhtml#ch010fig01) 中的那样。
- en: '![image](../images/ch10fig01.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig01.jpg)'
- en: '*Figure 10-1: A recursion tree with perfect splits*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：一个具有完美划分的递归树*'
- en: Notice that each node splits into two nodes below, representing the fact that
    each problem splits into two. The quantity in each node indicates the number of
    queries that are directly made to solve that subproblem. The 2*n* at the top,
    for example, means that the initial call makes 2*n* queries. It’s not saying that
    the total number of queries made in the entire algorithm is 2*n*, only that the
    initial call makes 2*n* queries of its own prior to recursing. Notice that each
    level in this tree—the node at the top, the two nodes below that, and the four
    nodes below those—make a total of 2*n* queries. If we drew the entire tree, it
    would have about log *n* levels in it. In all, then, we have *O*(*n* log *n*)
    queries.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个节点都分裂成两个下方的节点，表示每个问题都被分成了两部分。每个节点中的数量表示为了解决该子问题而直接进行的查询次数。例如，顶部的 2*n*
    表示初始调用会生成 2*n* 次查询。它并不是在说整个算法中总共会有 2*n* 次查询，而是说初始调用会进行 2*n* 次查询，然后才会递归。请注意，这棵树中的每一层——顶部的节点、下方的两个节点，以及下方的四个节点——总共会生成
    2*n* 次查询。如果我们画出整棵树，它大约会有 log *n* 层。因此，总的来说，我们有 *O*(*n* log *n*) 次查询。
- en: Now, *O*(*n* log *n*) is a wonderful thing, but all I’ve argued so far is that
    this is what happens when the algorithm gets super lucky with perfect splits.
    The algorithm is generally not going to get this lucky, though, just as it’s generally
    not going to get super unlucky with horrible cap choices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*O*(*n* log *n*) 是一件很棒的事，但到目前为止，我所讨论的只是当算法遇到完美划分时会发生的情况。然而，算法通常不会如此幸运，就像它通常也不会遇到极度不幸的糟糕瓶盖选择一样。
- en: 'It turns out that the expected runtime is very close to what is predicted by
    the super lucky case rather than the super unlucky case. For example, let’s imagine
    that each time we choose a cap, one subproblem will end up with 90 percent of
    the caps and bottles and the other subproblem will end up with the remaining 10
    percent of the caps and bottles. You might consider that pretty unlucky. But even
    in this case, our algorithm is *O*(*n* log *n*)! Our biggest subproblem would
    go from size *n*, to size *n*/(10/9), to size *n*/(10/9)², and so on. That is,
    rather than dividing by 2 each time, we’re dividing by 10/9\. How many times do
    we need to do this to get down to a base case? It’s still logarithmic! The base
    of the log changes—it goes from log[2] to log[10/9]—but it’s still log. Yes: even
    if we get *this* unlucky, we’re still not going to hit *O*(*n*²).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，预期的运行时间非常接近于由超级幸运情况预测的运行时间，而不是超级不幸情况。例如，让我们想象每次选择一个帽子时，一个子问题将以90%的帽子和瓶子结束，而另一个子问题将以剩余的10%的帽子和瓶子结束。你可能会认为这相当不幸。但即使在这种情况下，我们的算法仍然是*O*(*n*
    log *n*)！我们最大的子问题将从大小*n*，变成大小*n*/(10/9)，然后变成大小*n*/(10/9)²，依此类推。也就是说，我们不是每次都除以2，而是每次都除以10/9。我们需要多少次这样做才能达到基本情况？它仍然是对数的！对数的底数变化了——从log[2]变为log[10/9]——但仍然是对数。没错：即使我们变得这么不幸，我们仍然不会达到*O*(*n*²)。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: When I teach randomization in my algorithms classes, I often have at least a
    few flummoxed students. “Really, Dan? Picking random numbers? This feels like
    the kind of thing I would have tried *before* learning about real algorithms.”
    But as I hoped I’ve demonstrated in this chapter, randomization is no rookie move.
    Compared to deterministic algorithms, randomized algorithms can be faster and
    easier to design.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在算法课上教授随机化时，我经常会有一些困惑的学生。“真的，丹？选择随机数？这感觉像是我在学习真正算法之前会尝试的事情。”但正如我在本章中所展示的，随机化并不是新手动作。与确定性算法相比，随机化算法可以更快速，更容易设计。
- en: 'In [Chapter 7](ch07.xhtml), I gave this advice: if you see an opportunity to
    use binary search to solve a problem, just do it. Who cares if there’s a slightly
    more efficient solution that doesn’t use binary search. I offer similar advice
    here: if you see an opportunity to use randomization, and you can tolerate the
    randomness in correctness or runtime, just do it. Who cares if there’s a deterministic
    algorithm: even if you can come up with one (which may not be easy!), it’ll probably
    be slower in practice anyway.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml)中，我给出了这样的建议：如果你看到可以用二分查找解决问题的机会，就去做吧。谁在乎是否有一个稍微更高效的解决方案不使用二分查找呢？我在这里也提供类似的建议：如果你看到可以利用随机化的机会，并且你可以容忍随机性对正确性或运行时间的影响，那就去做吧。谁在乎是否存在一个确定性算法：即使你可以想出一个（这可能不容易！），实际上它可能在实践中也会更慢。
- en: Notes
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Yōkan is originally from the 2015 Don Mills Programming Gala programming competition,
    Gold Division. Caps and Bottles is originally from the 2009 Canadian Computing
    Olympiad.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Yōkan最初来自2015年Don Mills编程盛典编程竞赛，金牌部分。Caps and Bottles最初来自2009年加拿大计算奥林匹克竞赛。
- en: 'There’s a way to cut down the amount of memory needed by our solution to Caps
    and Bottles. It’s a neat trick that applies to implementations of Quicksort as
    well. Check it out in “Caps and Bottles: In-Place Sorting” in [Appendix B](app02.xhtml).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '有一种方法可以减少我们解决Caps and Bottles问题所需的内存量。这是一个适用于快速排序实现的巧妙技巧。在[附录B](app02.xhtml)的“Caps
    and Bottles: In-Place Sorting”中查看它。'
- en: 'For a deep dive into sorting algorithms, I recommend *Compared to What?: An
    Introduction to the Analysis of Algorithms* by Gregory J.E. Rawlins (1991). It’s
    an oldie but a goodie. There are many sorting algorithms: some of them are slow,
    some of them are fast; some of them merge sorted pieces, some of them split and
    sort the pieces. The book compares and contrasts many sorting algorithms. This
    is also the book that originally introduced me to the Caps and Bottles problem.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于深入了解排序算法，我推荐Gregory J.E. Rawlins（1991年）的*Compared to What?：An Introduction
    to the Analysis of Algorithms*。这是一本老书但是经典之作。有许多排序算法：有些慢，有些快；有些合并排序后的片段，有些分割并排序片段。该书比较和对比了许多排序算法。这也是最初让我了解Caps
    and Bottles问题的书籍。
