- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**DESKTOP ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**桌面架构**'
- en: '![Image](../images/f0301-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0301-01.jpg)'
- en: “A computer on every desk” was Bill Gates’s ambition during the 32-bit era of
    the 1990s, and while the current trend is toward the Internet of Things and the
    cloud, a personal computer (PC) can still be found on many desks and laps today.
    The PC isn’t a single computer design; rather, it’s a set of loose conventions
    for combining many different components from different manufacturers into computers,
    based around the x86 family of CPUs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “每个桌面上都有一台计算机”是比尔·盖茨在1990年代32位时代的愿景，尽管当前的趋势是物联网和云计算，但个人计算机（PC）今天仍然能在许多桌面和膝上看到。PC并不是单一的计算机设计；它是通过将来自不同制造商的许多不同组件结合在一起，围绕x86系列CPU构建的一套松散的约定。
- en: Thanks to a business-led focus on backward compatibility, modern PCs retain
    many features from earlier stages of their evolution, so in this chapter we’ll
    study how these conventions came into being and how they’ve affected x86 architecture
    and PC computer design. We’ll examine x86’s CISC philosophy and its Silicon Valley
    history and instruction set, then look at some computer design elements used to
    build modern PCs around it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于商业驱动的向后兼容性，现代PC保留了许多早期阶段的特性，因此在本章中，我们将研究这些约定是如何形成的，以及它们如何影响x86架构和PC计算机设计。我们将考察x86的CISC哲学及其硅谷历史和指令集，然后看一下用于围绕它构建现代PC的一些计算机设计元素。
- en: CISC Design Philosophy
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CISC设计哲学
- en: Most desktop computers use CPUs from the x86 family, which are usually described
    as CISC architectures. We’ve seen CISC architectures a few times, but let’s take
    a closer look at some of the CISC principles that appear in x86.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数桌面计算机使用来自x86系列的CPU，这些CPU通常被描述为CISC架构。我们已经见过几次CISC架构，但让我们更详细地看看出现在x86中的一些CISC原则。
- en: In a CISC architecture, you try to do as many big and clever things as you can
    on a large, complex chip with lots of silicon. You design many different small
    machines that all do different specialized things; you also provide dedicated
    instructions for each of them. As you can imagine, this is very hard to design,
    and you end up having to pay your architects a lot of money—especially when all
    the new complex features need to be made to play nicely with other innovations,
    such as pipelining and out-of-order execution (OOOE). Using lots of silicon typically
    consumes lots of power, so CISC processors often have to be plugged into the wall,
    with heavy power transformers and large cooling systems such as fans. These requirements
    are easier to meet in a desktop setting than in embedded and smart-type environments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在CISC架构中，你试图在一个大而复杂的芯片上做尽可能多的、巧妙的事情，芯片包含大量的硅。你设计许多不同的小型机器，每个机器都执行不同的专门功能；你还为每个机器提供专门的指令。正如你可以想象的那样，这非常难以设计，最终你不得不支付给你的架构师大量的钱——特别是当所有新的复杂功能需要与其他创新（如流水线和乱序执行（OOOE））良好协作时。使用大量硅通常会消耗大量功率，因此CISC处理器通常需要插入电源插座，配备强大的电源变压器和大型冷却系统，如风扇。这些要求在桌面环境中比在嵌入式和智能设备环境中更容易满足。
- en: 'A classic aspect of CISC philosophy is having lots of instructions that combine
    memory access with arithmetic logic unit (ALU) instructions, such as “multiply
    the contents of a first address by the contents of a second address and store
    the result in a third address,” where the addresses are in RAM. This is, in fact,
    a compound instruction involving many steps: we need to load both addresses, multiply
    their values, put the resulting value in a register, and store it in memory again.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CISC哲学的一个经典特征是有大量指令将内存访问与算术逻辑单元（ALU）指令结合，例如“将第一个地址的内容与第二个地址的内容相乘，并将结果存储在第三个地址”，其中地址位于RAM中。实际上，这是一个涉及多个步骤的复合指令：我们需要加载这两个地址，乘以它们的值，将结果存入寄存器，然后再次将其存储到内存中。
- en: CISC also emphasizes implementing new instructions in hardware essentially saying,
    “Throw more silicon at the problem.” For example, if users demand lots of video
    codec streaming, you can create special instructions that perform the specific
    mathematical operations used in video codecs, and build lots of new simple machines
    in digital logic to implement each of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CISC还强调在硬件中实现新指令，基本上是在说：“更多的硅解决问题。”例如，如果用户需求大量的视频编解码流媒体，你可以创建专门的指令来执行视频编解码中使用的特定数学运算，并在数字逻辑中构建许多新的简单机器来实现它们。
- en: 'A “decode my video” instruction is going to take more than one clock cycle,
    and accommodating different instructions that take differing amounts of time is
    a major challenge that arises in CISC architectures. In particular, pipelining
    and OOOE are harder to get right when instructions have different durations. This
    problem can be fixed by throwing even more silicon at it: you can create even
    more complex digital logic in the control unit (CU) to identify these durations
    and schedule around them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“解码我的视频”指令将需要超过一个时钟周期，并且处理不同指令所需的时间差异是CISC架构中面临的主要挑战。特别是，当指令的执行时间不同的时候，流水线和乱序执行（OOOE）就更难正确实现。这个问题可以通过增加更多硅片来解决：你可以在控制单元（CU）中创建更复杂的数字逻辑来识别这些时间差异，并根据它们进行调度。
- en: One supposed advantage of CISC architectures is that the compiler has to do
    very little work to translate common high-level language statements into assembly;
    this is because the instruction set architecture (ISA) has dedicated instructions
    for commands such as “decode my video,” which then have a simple one-to-one translation.
    But these instructions make life harder for compiler writers, who now need to
    wade through a five-volume set of instructions for *every* backend CPU they target;
    they’re also now expected to make some attempt to optimize their compiler for
    each particular ISA. It would be much easier for compiler writers to just use
    one volume of instructions and ignore all the advanced ones. In practice, this
    means that CISC architectures are more likely to come with compilers written by
    the same people who built the CPU, because no one else wants to work to optimize
    for one particular CPU. These compilers tend to be proprietary and to run faster
    than the open source versions due to the complexity involved; only those who built
    the system fully understand all the features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CISC架构的一个假定优势是，编译器几乎不需要做任何工作就可以将常见的高级语言语句翻译成汇编语言；这是因为指令集架构（ISA）为诸如“解码我的视频”这样的命令提供了专门的指令，这些指令通常有一个简单的一对一的翻译。但是这些指令让编译器编写者的工作变得更加困难，他们现在需要为*每个*目标后端CPU通读五卷指令集；他们现在还需要尝试针对每个特定的ISA来优化编译器。对于编译器开发者来说，使用一本指令集并忽略所有高级指令会更容易。实际上，这意味着CISC架构更有可能配备由同样开发CPU的团队编写的编译器，因为没有其他人愿意为某个特定CPU进行优化。这些编译器通常是专有的，并且由于涉及的复杂性，比开源版本运行得更快；只有那些构建系统的人才完全理解所有的特性。
- en: 'Another upside is that assembly programs can be short, as every instruction
    does a lot of work. In the 1980s, this was important: RAM was limited, so shorter
    programs freed up more RAM for data. It’s not so important today.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是汇编程序可以很短，因为每条指令做了很多工作。在1980年代，这一点很重要：RAM受限，因此较短的程序释放了更多的RAM用于数据。今天，这点已经不那么重要了。
- en: CISC was invented by an Englishman, Maurice Wilkes, seen previously in [Figure
    1-19](ch01.xhtml#ch01fig19), but was commercialized by Americans. Stereotypical
    CISC architects and users are business-driven, and CISC is dominant in real-world
    desktop computing. You’re probably using a CISC architecture on your desktop today.
    If a CISC client asks for a new instruction to speed up their particular multimedia
    application, then the CISC business will often design and add it for them—for
    a cost. New features are often bolted on in this way, without necessarily being
    designed to beautifully fit together with what was there before. The older features
    will usually be retained, however, in order to avoid breaking other customers’
    existing systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CISC是由一位英国人莫里斯·威尔克斯（Maurice Wilkes）发明的，如前所示在[图1-19](ch01.xhtml#ch01fig19)，但它是在美国得到商业化的。典型的CISC架构师和用户是以商业驱动为主的，CISC在现实世界的桌面计算中占据主导地位。你今天可能就在使用CISC架构的桌面计算机。如果一个CISC客户要求添加一个新的指令来加速他们特定的多媒体应用程序，那么CISC公司通常会为他们设计并添加这个指令——当然是有成本的。这些新特性通常是以这种方式附加上的，并不一定设计得与之前的系统完美契合。然而，为了避免破坏其他客户的现有系统，旧特性通常会被保留。
- en: Microprogramming
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微程序设计
- en: Building new CPUs in hardware is hard and expensive. A chip mask set costs around
    $5 million to make, and if you get it wrong anywhere, new masks will be needed.
    This problem is acute for CISC due to its complex designs. *Microprogramming*
    is a solution to this problem in which the architecture consists of many simple
    machines that can be connected and disconnected through basic switches. Instructions
    are then defined as sequences of connections and disconnections. For example,
    to add two registers, you first connect one of them to an ALU input, then connect
    the other register to the other ALU input. Then you connect the ALU to a signal
    asking it to add, and finally you connect the result in the ALU output to a register.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中构建新 CPU 既困难又昂贵。制作一个芯片掩膜集的成本大约为 500 万美元，如果某个地方出现错误，就需要新的掩膜。由于 CISC 设计复杂，这个问题尤为严重。*微程序设计*是解决这个问题的一种方法，它使得架构由许多简单的机器组成，这些机器可以通过基本的开关连接和断开。指令则被定义为连接和断开序列。例如，要将两个寄存器相加，你首先将其中一个寄存器连接到
    ALU 输入，然后将另一个寄存器连接到另一个 ALU 输入。接着，你将 ALU 连接到一个信号，指示它进行加法运算，最后将 ALU 输出的结果连接到一个寄存器。
- en: This idea is reminiscent of the rotating barrel CU in Babbage’s Analytical Engine.
    The barrel has pins that are placed to trigger sequences of the simple machines.
    If the pins are moved around, different instructions and architectures can be
    easily created. Modern electronic microprogramming—and hence CISC—is credited
    to Wilkes, who studied and taught the history of computing and was very open about
    having picked up the idea from Babbage’s mechanical barrel. This is a paradigmatic
    example of how studying the arc of history can enable major, Turing Award–winning
    advances in modern architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法让人想起了巴贝奇的分析机中的旋转桶控制单元（CU）。桶中有触发器，通过它们可以触发一系列简单机器的工作。如果触发器位置发生变化，就可以轻松创建不同的指令和架构。现代电子微程序设计——因此也包括
    CISC——被归功于威尔克斯（Wilkes），他研究并教授计算历史，并且非常坦率地承认从巴贝奇的机械桶中获得了这个想法。这是一个典型的例子，说明了研究历史的轨迹如何促成现代架构中的重大、图灵奖获奖的进展。
- en: The electronic version of Babbage’s barrel pins is usually firmware, known as
    *microcode*, inside the CPU, containing a list of connections to make and break
    in sequence for each instruction. (This isn’t ROM in the CPU’s address space,
    it’s a non-addressable, separate region inside the CPU itself.) As firmware, it
    can be electronically reprogrammed at any time. This massively reduces the cost
    of fixing hardware bugs in the CPU, as they can be corrected with a firmware update
    rather than having to return and remanufacture the chip itself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 巴贝奇桶中触发器的电子版本通常是固件，称为*微代码*，它存在于 CPU 内部，包含每条指令中要顺序连接和断开的连接列表。（这不是 CPU 地址空间中的
    ROM，而是 CPU 内部一个不可寻址的独立区域。）作为固件，它可以随时进行电子重编程。这大大减少了修复 CPU 硬件故障的成本，因为可以通过固件更新来修正问题，而不必返回并重新制造芯片。
- en: Microprograms aren’t machine code programs; they exist at a lower level, defining
    the machine that the machine code runs on. The actions of microprograms can be
    notated using register transfer language (RTL), as in [Chapter 7](ch07.xhtml).
    Modern CISC chips may have many thousands of complex instructions all defined
    in microcode. You can re-microprogram your CPU to implement a completely different
    instruction set if you like, such as turning an x86 into a retro 6502! There’s
    now so much reconfigurability that microprograms can behave almost like FPGAs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微程序不是机器代码程序；它们存在于更低的层次，定义了机器代码运行的机器。微程序的动作可以使用寄存器传输语言（RTL）进行标注，如在[第 7 章](ch07.xhtml)中所示。现代
    CISC 芯片可能有成千上万条复杂的指令，这些指令都通过微代码来定义。如果你愿意，你可以重新编写你的 CPU 微程序，实施完全不同的指令集，比如将 x86
    转换为复古的 6502！现在的可重配置性已经非常强大，微程序几乎可以像 FPGA 一样运行。
- en: Now that we’ve seen some of the design concepts, let’s turn to the history of
    x86\. Doing so will help you make sense of features still present in modern x86s
    that have accumulated through this history.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些设计概念，让我们来看看 x86 的历史。了解这些历史将帮助你理解现代 x86 处理器中仍然存在的、通过这段历史积累的特性。
- en: x86 History
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86 历史
- en: 'The x86 architecture has been the most commercially successful and resilient
    CPU architecture to date, reaching its 45th anniversary in 2023\. x86 is a family
    of CISC architectures whose designs and names derive from the model numbers of
    the first few generations of Intel processors: 8086, 80286, 80386, and 80486\.
    x86 has persisted across three generations of word lengths: 16-, 32-, and 64-bit
    architectures. As a commercial product, it has strongly emphasized rigorous backward
    compatibility with all previous generations, at the cost of adding complexity
    to the design, including digital logic to ensure historical bugs are kept in order
    to allow old games that exploit them as features to continue to run. You can still
    take your executable machine code from the 1970s and run it on a modern x86 and
    it will “just work.” (This is a similar approach to software design in commercial
    operating systems, which similarly grow to huge, bloated sizes to maintain compatibility
    for customers at the expense of performance and beauty.) As a result of continually
    adding new CISC instructions and keeping all the old ones, the latest version
    of x86—the *amd64* ISA—now includes over 3,000 instructions, documented in a five-volume
    set of reference books.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构是迄今为止最具商业成功和韧性的CPU架构，2023年迎来了它的第45个周年纪念。x86是一系列CISC架构，其设计和名称来源于英特尔处理器前几代的型号：8086、80286、80386和80486。x86跨越了三代字长：16位、32位和64位架构。作为一个商业产品，它特别强调与所有前代架构的严格向后兼容性，尽管这增加了设计的复杂性，包括数字逻辑，以确保历史遗留的bug得以保留，从而使得那些利用这些bug作为特性的旧游戏仍能继续运行。你仍然可以将1970年代的可执行机器代码拿到现代x86上运行，它会“顺利运行”。（这与商业操作系统中的软件设计方法类似，后者也同样膨胀到巨大的规模，以维护客户兼容性，代价是性能和美观的牺牲。）由于不断添加新的CISC指令并保留所有旧指令，最新版本的x86——*amd64*指令集架构——如今包含超过3000条指令，这些指令被记录在五卷的参考书中。
- en: '*Prehistory*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*史前时期*'
- en: The history of x86 design is one of Silicon Valley architecture and politics,
    and specifically of the companies Intel and AMD. Both companies make processors
    using the same proprietary instruction set, and they’re constantly locked in legal
    battles with each other, which have now spanned decades.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: x86设计的历史是硅谷架构和政治的历史，特别是英特尔和AMD两家公司之间的历史。这两家公司使用相同的专有指令集制造处理器，而且它们之间不断进行法律斗争，这些争斗已经持续了几十年。
- en: William Shockley, John Bardeen, and Walter Brattain were awarded the Nobel Prize
    in Physics in 1956 for their invention of the transistor at Bell Labs, New Jersey.
    Shockley’s family was from Palo Alto, California, though he was born in London.
    After winning a Nobel Prize, you can live and work wherever you like, so Shockley
    decided to relocate from New Jersey to Mountain View, California, because he wanted
    to be near his mother in Palo Alto. He set up Shockley Semiconductor there to
    continue his transistor research and commercialization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 威廉·肖克利、约翰·巴丁和沃尔特·布拉廷因发明晶体管而获得了1956年诺贝尔物理学奖，发明地是在新泽西州的贝尔实验室。肖克利的家族来自加利福尼亚州的帕洛阿尔托，尽管他出生在伦敦。获奖之后，你可以在任何地方生活和工作，因此肖克利决定从新泽西迁往加利福尼亚州的山景城，因为他希望能靠近位于帕洛阿尔托的母亲。他在这里成立了肖克利半导体公司，继续进行晶体管的研究和商业化。
- en: By 1957, Shockley had become a difficult person to work with due to a mixture
    of Nobel laureate hubris and obsession with topics considered fringe by his staff.
    A group of employees, the so-called “traitorous eight”—including Gordon Moore
    and Robert Noyce—walked out on Shockley to set a rival firm, Fairchild Semiconductor.
    This was considered almost blasphemous by the commercial culture of the time,
    in which it was assumed people would join a big company and be loyal company servants
    for their whole careers. It has since become the blueprint for Silicon Valley’s
    startup culture, in which it’s assumed employees will and should leave big companies
    to start their own.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到了1957年，由于诺贝尔奖得主的傲慢与对一些被员工认为是边缘话题的痴迷的混合，Shockley已经成为一个很难合作的人。一群员工，所谓的“背叛的八人组”——包括戈登·摩尔和罗伯特·诺伊斯——离开了Shockley，成立了竞争公司费尔柴尔德半导体。这在当时的商业文化中几乎被视为亵渎，因为人们普遍认为，员工会加入大公司，并忠诚地为公司服务整个职业生涯。此后，这种做法成为了硅谷创业文化的蓝图，认为员工会并且应该离开大公司，自己创办公司。
- en: Fairchild created the first commercial version of the integrated circuit (chip).
    Demand for computing at this time was almost entirely from the American military,
    which used taxpayer money to subsidize research and buy the products of chipmakers
    to power missiles and planes for the Cold War. These government funds fed the
    silicon industry, accelerating the growth of Fairchild and also many rival upstarts
    as Fairchild staff copied the Fairchild model and left to start their own competing
    chip companies, giving rise to modern Silicon Valley.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 飞兆半导体公司（Fairchild）创造了集成电路（芯片）的第一个商业版本。此时，对计算的需求几乎完全来自美国军方，军方利用纳税人的资金资助研究，并购买芯片制造商的产品，为冷战中的导弹和飞机提供动力。这些政府资金推动了硅行业的发展，加速了飞兆半导体的成长，并促使许多竞争对手的崛起，因为飞兆的员工复制了飞兆的模式，离开公司创办了自己的竞争性芯片公司，最终催生了现代硅谷。
- en: In 1968, Fairchild politics led Gordon Moore and Robert Noyce to quit again—this
    time leaving Fairchild to set up Intel (short for Integrated Electronics). AMD
    (Advanced Micro Devices) was founded the following year by Jerry Sanders. AMD’s
    early goal was to copy Intel’s products and produce them more cheaply as a second
    source. Before the x86 series proper, Intel produced the 4-bit 4004 in 1971\.
    AMD cloned it shortly afterward in 1975 as the Am9080\. Intel preempted this in
    1974 with an 8-bit version, the 8080 (3 MHz), which was then also copied by AMD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年，飞兆半导体的内部政治导致戈登·摩尔和罗伯特·诺伊斯再次辞职——这次他们离开飞兆成立了英特尔（Integrated Electronics的缩写）。AMD（Advanced
    Micro Devices）于次年由杰里·桑德斯创立。AMD早期的目标是复制英特尔的产品，并作为第二来源以更低的成本生产这些产品。在x86系列正式推出之前，英特尔于1971年生产了4位的4004芯片，随后AMD于1975年将其克隆为Am9080。英特尔在1974年通过推出8位版本的8080（3
    MHz）抢先一步，随后AMD也复制了这一款。
- en: '*16-Bit Classical Era*'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*16位经典时代*'
- en: The first member of the x86 family proper—defined by modern backward compatibility—was
    Intel’s 16-bit, 5 MHz 8086 chip, made in 1978\. This was a CISC chip that used
    microprogramming. x86 is named after its last two digits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: x86家族的第一个成员——由现代向后兼容性定义——是英特尔于1978年推出的16位、5 MHz的8086芯片。这是一款采用微程序设计的CISC芯片。x86的名称来源于其最后两位数字。
- en: Competition between Intel and AMD became formalized in 1982 by a three-way contract
    between Intel, AMD, and IBM, whose business at the time was building computers.
    IBM wanted to buy CPUs for its computers but didn’t want to be locked into using
    a proprietary design from a single company, because such a company could then
    hold IBM to ransom via the lock-in and increase its prices. As a huge company,
    IBM had enough buying power to play suppliers against one another to get what
    it really wanted, which was for more than one company to compete to produce the
    same chips as generic commodities; this would push down the prices and enable
    IBM to get them cheap in perpetuity. IBM said to Intel, “We want to buy your chips,
    but we’ll buy them only if you sign this contract saying you’ll let AMD copy them.
    If you don’t sign, then we won’t buy from either of you.” The three companies
    agreed and thus created the famous Intel-AMD cross-license for both chipmakers
    to design and sell chips implementing the same x86 ISA.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔与AMD之间的竞争在1982年通过英特尔、AMD和IBM之间的三方合同正式化，当时IBM的业务是制造计算机。IBM希望购买用于其计算机的CPU，但不想被单一公司设计的专有技术锁定，因为这样一来，该公司可能通过锁定政策勒索IBM并提高价格。作为一个巨大的公司，IBM拥有足够的购买力来通过与供应商的博弈获取其真正想要的东西——让多家公司竞争生产相同的芯片作为通用商品；这将压低价格并使IBM能够长期以低价获得这些芯片。IBM对英特尔说：“我们想买你们的芯片，但只有在你签署这份合同，允许AMD复制它们的情况下我们才会购买。如果你不签署，我们就不从你们任何一方购买。”三家公司达成一致，最终创立了著名的英特尔-AMD交叉许可协议，允许两家公司设计和销售实现相同x86指令集架构（ISA）的芯片。
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a general lesson about computer economics: after a sale, the seller
    of a hardware or software platform can wield extreme power over the buyer via
    lock-in. Platform sellers should thus try to initially give away their platforms
    for free or at large discounts, to get users locked into them, before ramping
    up their sales terms once they have the buyer over a barrel. But before the buyer
    selects a platform, it’s the buyer who holds all the power and calls the shots.
    Thus, buyers should negotiate hard to formalize a contract that mitigates the
    seller’s power over them later. Once you hand over the money, you have no power
    except what was agreed in that contract.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是计算机经济学的一般教训：在销售之后，硬件或软件平台的卖方可以通过锁定效应对买方施加极大的控制力。因此，平台的卖方应在初期尽可能免费或大幅折扣地提供其平台，以便让用户锁定在平台上，然后再提高销售条件，一旦他们掌控了买方。但在买方选择平台之前，买方才是拥有所有权力并决定一切的人。因此，买方应当积极谈判，以形成一份合同，从而在以后减轻卖方对他们的控制力。一旦你付了钱，除了合同中约定的内容，你将不再拥有任何权力。*'
- en: The IBM deal propelled both chipmakers into the business computing market, enabling
    them to scale rapidly. After the deal, Intel updated the 8086 with its 80186 (1982;
    6 MHz), followed soon after by the 80286 (1982; 8 MHz), which added protected
    mode for OS support for the first time. AMD then quickly cloned the 80286 as its
    Am286 (1982; 8 MHz). These 16-bit devices were appearing in the early 1980s as
    high-end business machines, at the same time that the 8-bit golden age was arriving
    in homes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IBM的交易将两大芯片制造商推向了商务计算市场，使他们能够快速扩张。交易之后，英特尔用80186（1982年；6 MHz）更新了8086，随后推出了80286（1982年；8
    MHz），首次增加了操作系统支持的保护模式。AMD随后快速复制了80286，推出了Am286（1982年；8 MHz）。这些16位设备出现在1980年代初期，作为高端商务机器，与此同时，8位的黄金时代也在家庭中到来。
- en: '*32-Bit Clone Wars Era*'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*32位克隆战争时代*'
- en: The 32-bit era began with Intel’s 386 (1985; 16 MHz), which introduced the 32-bit
    instruction set x86 IA-32\. Throughout this era, we saw continual antagonism and
    legal action between the two big chipmakers; this was made more entertaining by
    the entry of additional competitors Cyrix and Via, who also made x86 clones. [Table
    13-1](ch13.xhtml#ch13tab1) summarizes these developments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 32位时代始于英特尔的386（1985年；16 MHz），它引入了32位指令集x86 IA-32。 在这一时代，两个主要芯片制造商之间的竞争和法律诉讼不断，这一过程在赛瑞克斯和威雅等额外竞争者加入后变得更具娱乐性，这些公司也生产x86兼容芯片。[表13-1](ch13.xhtml#ch13tab1)总结了这些发展。
- en: '**Table 13-1:** 32-Bit Era x86 Developments'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-1：** 32位时代x86发展'
- en: '| **Year** | **Maker** | **Architecture** | **Features** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **年份** | **制造商** | **架构** | **特性** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1985 | Intel | 386 | 16 MHz |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 1985 | 英特尔 | 386 | 16 MHz |'
- en: '| 1989 | Intel | 486 | 50 MHz, pipelined, FPU |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1989 | 英特尔 | 486 | 50 MHz, 流水线设计, FPU |'
- en: '| 1991 | AMD | Am386 | Clone of 386 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1991 | AMD | Am386 | 386的克隆 |'
- en: '| 1993 | Intel | Pentium | 75 MHz, superscalar |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 1993 | 英特尔 | Pentium | 75 MHz, 超标量 |'
- en: '| 1993 | AMD | Am486 | Clone of 486 (last clone) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1993 | AMD | Am486 | 486的克隆（最后一个克隆） |'
- en: '| 1995 | Intel | P5 | 150 MHz, MMX SIMD “Pentium MMX” |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 英特尔 | P5 | 150 MHz, MMX SIMD “Pentium MMX” |'
- en: '| 1995 | Intel | P6 (i686) | 200 MHz, SSE SIMD, OOOE, “Pentium Pro” |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 英特尔 | P6 (i686) | 200 MHz, SSE SIMD, OOOE, “Pentium Pro” |'
- en: '| 1996 | AMD | K5 | 133 MHz, Pentium-like |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1996 | AMD | K5 | 133 MHz, 类似Pentium |'
- en: '| 1995 | Cyrix | Cx5x86 | 140 MHz, Pentium-like |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 赛瑞克斯 | Cx5x86 | 140 MHz, 类似Pentium |'
- en: '| 1996 | Cyrix | 6x86 | 140 MHz, Pentium-like |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1996 |赛瑞克斯 | 6x86 | 140 MHz, 类似Pentium |'
- en: '| 1997 | AMD | K6 | 300 MHz, 3D-NOW, rival SIMD |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1997 | AMD | K6 | 300 MHz, 3D-NOW, 对抗SIMD |'
- en: '| 2001 | VIA | C3 | 500 MHz, Pentium-like |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 2001 | VIA | C3 | 500 MHz, 类似Pentium |'
- en: '| 2001 | AMD | Athlon | 2 GHz |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2001 | AMD | Athlon | 2 GHz |'
- en: Intel was usually the technical leader, creating new technologies such as pipelined
    designs and extension instructions, with the others copying a year or two later
    to bring the price down. At every step, clock speeds reliably got faster, following
    Moore’s law for clock speed. This was the “bland 1990s,” where customers assumed
    they would need to buy a new beige desktop computer every 18 months to keep up
    with doubling clock speeds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔通常是技术领导者，创造了诸如流水线设计和扩展指令等新技术，其他公司在一到两年后跟进以降低价格。在每个阶段，时钟速度都稳定地变得更快，遵循摩尔定律。这就是“乏味的1990年代”，当时客户认为他们需要每18个月购买一台新的米色台式电脑，以跟上时钟速度的翻倍。
- en: After the 486, Intel got sick of competitors copying the untrademarkable 86
    name, so they switched to the trademarkable brand name “Pentium.” This was the
    dominant chip for some time, but then AMD took the lead by becoming the first
    to reach 1 GHz speed with its Athlon in 2001.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在486处理器之后，英特尔厌倦了竞争对手复制无法注册商标的86名称，因此他们改用了可注册商标的品牌名称“奔腾”。这一芯片在一段时间内占据主导地位，但后来AMD通过其Athlon处理器在2001年率先达到了1
    GHz的速度，取得了领先。
- en: '*64-Bit Branding Era*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*64位品牌化时代*'
- en: 'The 64-bit era of x86 arrived in 2000 when AMD formally defined the amd64 ISA,
    which was adopted by most CISC processors following it. This was a coup: the x86
    ISA family had previously always been defined by Intel, with others pegging their
    own products to them.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: x86的64位时代在2000年到来，当时AMD正式定义了amd64 ISA，随后大多数CISC处理器都采用了这一架构。这是一场革命：x86 ISA家族之前一直由英特尔定义，其他厂商只能将自己的产品与其挂钩。
- en: Intel attempted to define its own failed 64-bit competitor ISA, called IA-64,
    but this was released after amd64 and never caught on; today, everyone uses amd64\.
    Intel, however, refuses to acknowledge the name amd64, instead referring to the
    same ISA as x86_64\. Confusingly, you’ll see both names used to describe executable
    software downloads for this ISA, such as in the names of Linux distribution packages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔曾试图定义自己失败的64位竞争对手指令集架构（ISA），名为IA-64，但该架构在amd64发布之后才面世，并未获得广泛认可；如今，大家都使用amd64。然而，英特尔拒绝承认amd64这一名称，而是称其为x86_64。令人困惑的是，你会看到这两个名称都被用来描述该ISA的软件执行文件下载，比如在Linux发行版的软件包名称中。
- en: The 64-bit era is characterized by a separation of marketing terms from the
    underlying technologies, with the same marketing brand often used to label completely
    different architectures. Unlike the previous 32-bit Pentium, the branding is no
    longer attached to specific designs. You’re probably used to seeing 64-bit products
    with brands like Pentium, Celeron, and Xeon. You may also see the numbers 3, 5,
    7, and 9 in brand names, as in Core i3, Core i5, and so on. For Intel, these numbers
    don’t mean anything other than suggesting an ordering of which products are better;
    AMD uses the same numbers to suggest which products are similar to Intel’s.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 64位时代的特点是市场营销术语与基础技术的分离，同一市场品牌常常用来标示完全不同的架构。与之前的32位奔腾处理器不同，品牌名称不再与特定的设计相联系。你可能已经习惯看到像奔腾、赛扬和至强这样的64位产品品牌。你也可能会在品牌名称中看到数字3、5、7和9，如Core
    i3、Core i5等。对于英特尔来说，这些数字除了暗示哪些产品更好之外，并没有其他意义；而AMD则用相同的数字来暗示哪些产品与英特尔的产品类似。
- en: '[Table 13-2](ch13.xhtml#ch13tab2) shows examples of Intel and AMD releases
    and some of their notable features during the 64-bit era.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格13-2](ch13.xhtml#ch13tab2)展示了英特尔和AMD发布的一些例子及其在64位时代的显著特点。'
- en: Pipelines have varied between around 14 and 20 stages during this period, and
    OOOE has been used throughout. AMD Piledriver was the first to introduce neural
    network–based branch prediction hardware.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一时期，管道阶段数通常在14到20之间，并且始终使用了超标量执行（OOOE）。AMD的Piledriver架构首次引入了基于神经网络的分支预测硬件。
- en: Clock speeds hit 3.5 GHz around the start of the 64-bit era and have been stuck
    there ever since, due to the end of Moore’s law for clock speed. However, Moore’s
    law for transistor size continued to hold, and it became common to define machines
    by their transistor scale, in nanometers (nm) per transistor, rather than their
    clock speed, to show the continued progress. Between 2006 and 2016, Intel used
    a “tick-tock” cycle, in which their new products alternated between new digital
    logic designs (tock) and the use of new transistor technologies to make the same
    design smaller and faster (tick). *Boosts* are a feature first added in Nehalem,
    which *temporarily* increase the clock speed beyond the usual 3.5 GHz heat limit
    for short periods of time at the bottlenecks of intensive computations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟频率在64位时代初期达到了3.5 GHz，并且自此停滞不前，这是由于摩尔定律对时钟频率的限制。然而，摩尔定律在晶体管大小上的影响仍然存在，并且通常通过晶体管的尺度（单位：纳米）来定义机器，而不是通过时钟频率，以展示技术的持续进步。在2006年到2016年期间，英特尔采用了“tick-tock”周期，在此周期中，他们的新产品交替采用新的数字逻辑设计（tock）和采用新的晶体管技术使相同设计更小更快（tick）。*Boost*是Nehalem架构首次引入的功能，它能在高负载计算的瓶颈处*暂时*提升时钟频率，超越通常的3.5
    GHz热限制，持续短时间。
- en: '**Table 13-2:** 64-Bit Era x86 Developments'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格13-2：** 64位时代x86发展历程'
- en: '| **Year** | **Maker** | **Architecture** | **Transistor size (nm)** | **Branding**
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **年份** | **制造商** | **架构** | **晶体管大小（nm）** | **品牌** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 2003 | AMD | Hammer (K8) | 130 | Opteron |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 2003 | AMD | Hammer (K8) | 130 | Opteron |'
- en: '| 2005 | AMD | Hammer (K8) | 90 | Athlon 64 X2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| 2006 | Intel | Core | 65 | Celeron/Pentium/Xeon |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| 2007 | AMD | 10h (K10) | 65 | Opteron |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| 2008 | Intel | Nehalem | 45 | Pentium, Xeon, Core (1st generation) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| 2011 | Intel | Sandy Bridge | 32 | 2nd-generation Core i3/i5/i9; Xeon |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| 2012 | AMD | Piledriver | 32 | Opteron |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| 2013 | Intel | Haswell | 22 | 4th-generation Core i3/5/7; Celeron/Pentium/Xeon
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| 2015 | Intel | Skylake | 14 | 6th-generation Core i3/5/7; Celeron/Pentium/Xeon;
    CoreM |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| 2017 | Intel | Coffee Lake | 14 | 8th-generation Core i3/5/7; Celeron/Pentium
    Gold/Xeon |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| 2017 | AMD | Zen | 14 | Ryzen 3/5/7 1000 series |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| 2018 | AMD | Zen+ | 12 | Ryzen 3/5/7 2000 series |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| 2019 | AMD | Zen2 | 7 | Ryzen 3/5/7 3000 series |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| 2020 | AMD | Zen3 | 7 | Ryzen 5/7/9 5000 series |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| 2021 | Intel | Cypress Cove | 14 | 11th-generation Core i5/7/9; Xeon |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| 2021 | Intel | Golden Cove | 7 | 12th-generation Core i5/7/9; Xeon |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| 2022 | AMD | Zen4 | 5 | Ryzen 5/7/9 7000 series |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: Now that we’ve seen how x86 evolved, let’s look at its instruction set and learn
    how to program it. This will be a messier experience than for the other architectures
    we’ve studied, but hopefully, by understanding the history, you can at least understand
    why things ended up this way.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Programming x86
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: x86 is big and ugly; its code is usually generated by compilers rather than
    written by hand. Still, it’s worth your time to study it if you want to better
    understand what your compiler and computer are doing, or if you want to write
    compilers or other system software such as operating systems and bootloaders.
    Because x86 is such a widely used architecture, understanding it is also useful
    in security applications, such as cracking and defending code, including cheat
    and anti-cheat systems for games.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'As a CISC architecture, x86 often has many variations of each instruction,
    taking different types of operand, such as constants, registers, and memory locations.
    Groups of instructions have been added at different points in the architecture’s
    history, and they don’t always use the same conventions: for example, integer
    addition, integer multiplication, and floating-point operations all present very
    different interfaces to the programmer. You wouldn’t design a new CPU from scratch
    using such different interfaces; this mess is simply how the architecture has
    grown over time.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: This won’t be an exhaustive tour of x86 features. Rather, we’ll look at a couple
    of examples to give a flavor of how CISC extensions are created and how they operate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*Registers*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of the way x86 has evolved over time and its requirement for backward
    compatibility, its register set has grown into a particular form. There are two
    general types of register; let’s look at each.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**General-Purpose Registers**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are eight general-purpose user registers in x86 architecture. Their names
    reflect their traditional uses. [Table 13-3](ch13.xhtml#ch13tab3) shows them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-3:** x86 General-Purpose Registers'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-3:** x86 通用寄存器'
- en: '| **Register** | **Meaning** | **Use** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **含义** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AX | Accumulator register | Arithmetic operations |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| AX | 累加寄存器 | 算术运算 |'
- en: '| BX | Base register | A pointer to data |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| BX | 基址寄存器 | 指向数据的指针 |'
- en: '| CX | Counter register | Shift, rotate, and loop instructions |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| CX | 计数寄存器 | 移位、旋转和循环指令 |'
- en: '| DX | Data register | Arithmetic and I/O operations |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| DX | 数据寄存器 | 算术运算和 I/O 操作 |'
- en: '| SP | Stack pointer register | A pointer to the top of the stack |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| SP | 栈指针寄存器 | 指向栈顶的指针 |'
- en: '| BP | Stack base pointer register | A pointer to the base of the stack |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| BP | 栈基指针寄存器 | 指向栈底的指针 |'
- en: '| SI | Source index register | A pointer to a source for data copies |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| SI | 源索引寄存器 | 指向数据复制的源 |'
- en: '| DI | Destination index register | A pointer to a destination for data copies
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| DI | 目标索引寄存器 | 指向数据复制的目标 |'
- en: In the original 16-bit 8086, the general-purpose registers all had 16 bits.
    To retain partial backward compatibility with the previous 8-bit 8080, the first
    four—AX, BX, CX, and DX—can also be split into two 8-bit registers, named with
    H and L for high and low bytes, which can be accessed independently.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 16 位 8086 中，通用寄存器都具有 16 位。为了与之前的 8 位 8080 保持部分向后兼容，前四个寄存器—AX、BX、CX 和 DX—也可以拆分成两个
    8 位寄存器，分别命名为 H 和 L，代表高字节和低字节，可以独立访问。
- en: 'IA-32 extended the eight registers to have 32-bits. They can still be accessed
    as 16- or 8-bit registers as before, to maintain compatibility. To access them
    in their full 32-bit mode, we add the prefix E (for *extended*) to their names:
    EAX, EBX, ECX, and so on.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: IA-32 将这八个寄存器扩展为 32 位。为了保持兼容性，它们仍然可以像以前一样以 16 位或 8 位寄存器的形式访问。要以完整的 32 位模式访问它们，我们在它们的名字前加上前缀
    E（表示*扩展*）：EAX、EBX、ECX 等。
- en: 'amd64 extended the eight registers again, to 64 bits. As before, the 32-, 16-,
    and 8-bit versions are left intact for compatibility. To access them in 64-bit
    mode, we add the prefix R to their names: RAX, RBX, RCX, and so on. amd64 also
    added eight more 64-bit general-purpose registers, named R8 through R15.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: amd64 再次扩展了这八个寄存器，至 64 位。与之前一样，32 位、16 位和 8 位版本保持不变以保持兼容性。要以 64 位模式访问它们，我们在它们的名字前加上前缀
    R：RAX、RBX、RCX 等。amd64 还增加了八个额外的 64 位通用寄存器，命名为 R8 到 R15。
- en: As x86 is defined as the family based on the 16-bit system, and has to retain
    backward compatibility, a *word* in x86 speak still means 16 bits of data, rather
    than the full size of the modern registers. *Doubleword* or *dword* means 32 bits,
    and *quadword* or *qword* means 64 bits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 被定义为基于 16 位系统的架构，并且需要保持向后兼容，因此在 x86 中，*字* 仍然表示 16 位数据，而不是现代寄存器的完整大小。*双字*
    或 *dword* 表示 32 位，*四字* 或 *qword* 表示 64 位。
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) summarizes the evolution of the general-purpose
    x86 registers.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch13fig1) 总结了通用 x86 寄存器的发展历程。'
- en: '![Image](../images/f0310-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0310-01.jpg)'
- en: '*Figure 13-1: The x86 registers. Register names are shown to the left of each
    register, apart from 8-bit register names, which are shown in the center of the
    register.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：x86 寄存器。寄存器名称显示在每个寄存器的左侧，8 位寄存器名称显示在寄存器的中央。*'
- en: For compatibility with these different word sizes, memory addressing is always
    done *per byte*, even on a modern amd64\. This is in contrast to addressing, say,
    non-overlapping 64-bit *words* of memory. Words are stored in memory as little-endian
    bytes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容不同的字长，内存寻址始终是*按字节*进行的，即使在现代的 amd64 上也是如此。这与寻址 64 位 *字*（不重叠）的内存有所不同。字以小端字节的方式存储在内存中。
- en: '**Internal Registers**'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内部寄存器**'
- en: The program counter is called the *instruction pointer* in x86 speak, identified
    as IP, EIP, or RIP when used in its 16-, 32-, or 64-bit form, respectively.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计数器在 x86 中称为 *指令指针*，在使用其 16 位、32 位或 64 位形式时，分别标识为 IP、EIP 或 RIP。
- en: The status register is called FLAGS, EFLAGS, or RFLAGS, again when used in 16-,
    32-, or 64-bit form. Its structure is shown in [Figure 13-2](ch13.xhtml#ch13fig2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 状态寄存器称为 FLAGS、EFLAGS 或 RFLAGS，取决于其使用的 16 位、32 位或 64 位形式。其结构见 [图 13-2](ch13.xhtml#ch13fig2)。
- en: '![Image](../images/f0310-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0310-02.jpg)'
- en: '*Figure 13-2: The x86 status register (compare with [Figure 11-6](ch11.xhtml#ch11fig6))*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：x86 状态寄存器（与 [图 11-6](ch11.xhtml#ch11fig6) 比较）*'
- en: This is very like the 6502’s status register, with similar mnemonics. As with
    the 6502, these flags are set with comparison instructions, then consulted with
    separate branch instructions. There are also instructions to clear flags. Two
    important flags, as in other architectures, are the zero flag (ZF) and sign flag
    (SF).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '*Netwide Assembler Syntax*'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of its long history, x86 has acquired several different assembly languages
    with different syntaxes, which all assemble into the same machine code. Here we’ll
    use the *Netwide Assembler (NASM)* style, which is the least worst of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: x86 instructions usually have two operands. In NASM syntax, the first is usually
    the destination and sometimes also an input that gets updated to store the result,
    like an accumulator; the second operand is an input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most assemblers, NASM enables us to label lines of a program with text
    labels by inserting the label as text, followed by a colon, like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a label is inserted on line 5, we can jump to or load from line 5 by using
    its label name rather than the number 5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Movement**'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To copy constants or register contents between registers and RAM, you can use
    the same `mov` (move) instruction. This generalizes all of loading, storing, and
    moving. Several different addressing modes are provided.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '*Immediate addressing* places constants into registers. For example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Register addressing* copies data from one register to another inside the CPU,
    such as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Direct addressing* loads from and stores to memory through a specified address.
    Labels can be used in place of numerical addresses, in which context they’re known
    as *variables*. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Register indirect addressing* is notated using square brackets, such as:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In these two instructions, RDI is assumed to contain an address that in turn
    is used to load or store the value from RAX.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Creation**'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Data locations in RAM can be given names, and can be initialized or uninitialized.
    To initialize a location with a value and create a name for it, we use commands
    beginning with `d`, for *define*. For example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To name an uninitialized location, we use commands beginning with `r`, for
    *reserve*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that these aren’t x86 instructions, but rather just labeled regions of
    data, with the directives telling NASM to treat them as such.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To create arrays, we simply allocate a set of consecutive addresses. For example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'NASM also provides macro directives, which enable you to define numeric `(equ)`
    and string `(%define)` constants:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: NASM substitutes for these constants’ values before doing the assembly. These
    macro directives aren’t part of the x86 instructions set, but NASM provides them
    for convenience.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic and Logic**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As x86 instructions are usually designed to take two arguments, most arithmetic
    is done accumulator-style. There isn’t a single accumulator register, but any
    register can act like one. For example, here we place the value 1 into RBX and
    add 2 into it, so it ends up storing the result, 3:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a CISC architecture, variations of arithmetic instructions usually exist
    that combine loading data from memory with the arithmetic. For example, here’s
    how to add two numbers from addresses 1000h and 2000h and put the result in RBX:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that x86 *doesn’t* include the most extreme CISC style of addition, such
    as `[3000h] := [1000h]+[2000h]`, which combines two loads, one addition, and one
    store in a single instruction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtraction works similarly to addition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Incrementing and decrementing 8-, 16-, or 32-bit operands can be done using
    the `inc` and `dec` instructions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To multiply or divide integer operands, x86 provides `mul` and `div` instructions.
    Unlike addition and subtraction, these always use the A register as the accumulator
    (hence its name) and act on it with the operand given to the instruction. For
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the last of the above examples, the prefix `i` is added to the `div` instruction
    to indicate that signed integers are used. The `cwd` instruction converts a word
    to a double by allowing the DX register to be used as an extension of AX in order
    to accommodate the sign information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitwise logic instructions include `and, or, not`, and `xor`. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with addition, the first operand acts as an accumulator so gets overwritten
    with the result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow Control**'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NASM provides two types of labels, symbolic and numeric, that can both be used
    for jumps and branches. Symbolic labels consist of an identifier followed by a
    colon (:). They must be defined only once, as they have global scope. If the label
    identifier begins with a period (.), it’s considered local and can be used only
    in the current file. Here’s an infinite loop using a symbolic label and a jump:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Numeric labels consist of a single digit in the range 0 to 9 followed by a
    colon. Numeric labels are considered local. They also have limited scope so can
    be redefined repeatedly. When a numeric label is used as a reference (as an instruction
    operand, for example), the suffixes `b` (for backward) or `f` (for forward) should
    be added to the numeric label. For numeric label `1`, the reference `1b` refers
    to the nearest label `1` defined before the reference, and the reference `1f`
    refers to the nearest label `1` defined after the reference. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conditional jumps are performed using pairs of instructions. First, we use the
    `cmp` instruction to compare two values. It takes two operands to compare and
    raises appropriate flags in the status register. Next, a conditional jump instruction
    consults the status register to determine whether or not to make the jump. Some
    of the available conditional jump types are listed in [Table 13-4](ch13.xhtml#ch13tab4).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-4:** x86 Conditional Jump Instructions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Condition** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `je` | Jump if `cmp` is equal |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `jne` | Jump if `cmp` is not equal |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `jg` | Signed > (greater) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `jge` | Signed >= |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `jl` | Signed < (less than) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `jle` | Signed <= |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `ja` | Unsigned > (above) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `jae` | Unsigned >= |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `jb` | Unsigned < (below) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `jbe` | Unsigned <= |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `jc` | Jump if carry (used for unsigned overflow or multi-precision add)
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `jo` | Jump if there was signed overflow |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: 'To illustrate, this program uses the `cmp` and `je` instructions to make a
    jump if the compared values are equal:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Subroutines are called and returned from as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `call` instruction jumps to the subroutine with the given label, and `ret`
    returns from the subroutine to the calling location.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**The Stack**'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Subroutine calls and returns are implemented internally using a stack. If you’re
    just writing simple calls and returns, as in the example we just looked at, you
    don’t need to see or think about the stack yourself. However, x86 also allows
    you to access the stack directly to pass arguments or for other purposes. Specifically,
    registers SS and ESP (or SP) are provided and used for implementing the stack.
    The stack is limited to storing only words and doublewords. Here’s how it works:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the contents of registers AX and BX are pushed to the stack, meaning these
    registers can then be overwritten and used for other purposes, before being restored
    by the pop instructions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**X86 CALLING CONVENTIONS**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The x86 architecture has been used with many different calling conventions during
    its history. Due to the small number of architectural registers, and a historical
    focus on simplicity and small code size, many x86 calling conventions pass arguments
    on the stack. The return value (or a pointer to it) is returned in a register.
    Some conventions use registers for the first few parameters, which may improve
    performance, especially for short and simple *leaf routines* that are very frequently
    invoked (these are routines that don’t call other routines).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: For amd64, there are two current conventions in widespread use, one suggested
    by System V UNIX designers and the other by Microsoft. They agree that the caller
    rather than callee should clean up the stack. They both require the first few
    arguments to be passed in registers, with the later arguments on the stack, right
    to left, though they disagree on how many and which registers to use. They disagree
    on which registers are *temporary*—that is, which can be overwritten by the callee
    during a function call. This is in contrast to those that are *safe*, guaranteed
    to not be changed by function calls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**BIOS I/O**'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can call BIOS routines from ROM to communicate with the screen and keyboard,
    as on a retro computer. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This sets a screen mode, prints an ASCII character to a location on the screen,
    reads an ASCII character from the keyboard, and sets a pixel color. These are
    all the basic ingredients you need to make 8 bit–style video games. The `int`
    instructions here generate interrupt requests, which pass control to the BIOS,
    and their operands tell the BIOS which of its subroutines is to be run. These
    subroutines each assume that their arguments have been placed into particular
    registers such as AH and AL before the interrupt is made.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating Point**'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The x86 floating-point architecture derives from the 8086’s old coprocessor,
    the 8087\. This was a separate, optional chip for accelerating numerical computation.
    Since the 486, the FPU moved into the main x86 architecture, where it has become
    known as the *x87 extension*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The x87 extension adds dedicated floating-point registers called ST0 to ST7,
    which are used as a stack (hence the prefix *ST*); the stack has a maximum of
    eight elements, with ST0 being the top. New floating-point instructions start
    with the letter `F` and move data to and from this stack; they instruct the FPU
    to perform arithmetic using the top items of the stack.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'You can push floats to the x87 stack, call arithmetic on them, and pop the
    result back, such as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, when you give an ASCII representation of a float to NASM for any of the
    word lengths used, NASM knows to convert it to IEEE binary representation for
    you.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*Segmentation*'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: x86 programs can be written as collections of *segments*, which are separate
    chunks of a program that can be stored in different locations in memory. For example,
    if you wish to keep your instructions apart from your data (as in a Harvard architecture),
    you can do this by using a separate code segment and data segment. A stack segment
    can also be used to keep the hardware stack data separate from both. Segments
    all live in the same global address space, but by storing the start address of
    each segment in a dedicated register, addresses within them can afterward be referred
    to by just their offset from the segment start. This system was intended as a
    way for 16-bit CPUs to work with more than 64 k[2]B of RAM. It still exists but
    isn’t used much in modern 64-bit x86, because the 64-bit address space is so large
    anyway. Six *segment registers*, called CS, SS, DS, ES, FS, and GS, are specified
    to hold the segment start addresses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the segment system, the NASM directive `section` specifies code
    and data segments. In some settings, some assemblers will still look for sections
    and assume that `section .text` is read-only and that `section .data` is read-write,
    even though the concepts are no longer used at the amd64 hardware level. A *segmentation
    fault* will occur if you try to access a segment that the assembler doesn’t want
    you to access.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*Backward-Compatible Modes*'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Part of the x86 standard is that all CPUs have to be backward-compatible with
    the original 16-bit 8086\. This means that when they first power on, they have
    to start in 16-bit mode and behave exactly like an 8086.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: From there, 32-bit x86s have instructions that switch them into 32-bit mode,
    and 64-bit x86s have further instructions to switch from 32-bit to 64-bit mode.
    To boot an amd64, you therefore progressively switch up into 32- and then 64-bit
    mode, replaying the history of its architecture in a fraction of a second.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the x86 architecture, let’s zoom out to
    consider the PC computer design that uses it as the CPU component.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: PC Computer Design
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The desktop PC is a different concept from the other computers we’ve studied:
    rather than specifying one particular computer design, it’s a loose collection
    of formal and informal standards. The first PCs were designed and defined as such
    by IBM, beginning in 1981 with the IBM 5150, seen in [Figure 11-1](ch11.xhtml#ch11fig1);
    they were then copied by other manufacturers using similar compatible components.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In the 1990s, any computer with an x86 CPU capable of running a Microsoft DOS
    or Windows operating system was generally considered to be a PC. Microsoft chose
    what computer design features to support in this software, so it effectively set
    the standard definition. Other operating systems could also run on many of these
    machines while making different support choices. Often there are multiple competing
    standards for computer design features, and it becomes a political as well as
    technical question which ones get taken up by the PC community.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Programming and using PCs thus feels different than more standardized platforms.
    For example, games created for a particular machine, such as a Commodore 64, can
    assume a precise hardware feature set and will run exactly the same on any Commodore
    64\. This enables the game designer to work as an artist, making the game look
    and feel exactly as they intend. But a game made for PCs will run differently
    on different PCs with different features, requiring game designers to create what
    is really a whole set of similar games, some of which they’ll never see themselves
    and can only guess at how to implement. Similarly, game players may have to get
    more involved in configuring their hardware and software to customize which version
    of the game they want to play.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll look at some specific examples of buses, I/O modules, and devices
    used in today’s desktop PCs. These can often form the bottlenecks in modern PCS—there’s
    little use in having a highly optimized CPU if it has to spend its time waiting
    on other parts of the system. When you buy a computer, don’t just look at CPU
    speed—think about these supporting structures, too.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*The Bus Hierarchy*'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like CPUs, buses are continually being improved and replaced, so the PC architecture
    has used various standard bus hierarchies over time. Buses can be found in a desktop
    PC at several layers; each layer has different uses and different bandwidths,
    and is optimized for different purposes. [Table 13-5](ch13.xhtml#ch13tab5) shows
    some recent standards with their speeds and typical uses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-5:** PC Bus Speeds and Uses'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '| **Standard** | **Bandwidth (GBps)** | **Uses** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| Gigabit Ethernet | 1 | Network |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| USB3 | 5 | Peripherals |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| SATA3 | 6 | Secondary storage |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| NVMe | 32 | Secondary storage |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| PCI express 5.0 x16 | 63 | Graphics cards |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: You can see that communication with the outside world via Ethernet is at the
    slower end, local peripherals and secondary storage are in the middle, and graphics
    cards have had a lot of work done to make them communicate quickly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The classic PC hierarchy used two structures called Northbridge and Southbridge—known
    together as the *chipset*—as the main skeleton of the bus hierarchy. This is shown
    in [Figure 13-3](ch13.xhtml#ch13fig3).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0320-01.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: The Northbridge-Southbridge bus architecture*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*Northbridge* connects directly to the CPU’s FSB (front-side bus) and links
    it to RAM and to fast I/O modules using the same address space via PCIe bus. It
    also connects to Southbridge. Northbridge is fast and powerful. It was traditionally
    constructed on a separate chip from the CPU that also hosted some memory cache
    levels. More recently, Northbridge has moved onto CPU silicon in many systems.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '*Southbridge* bridges a second time, from Northbridge to slower I/O bus hierarchies.
    It’s still usually located in its own dedicated silicon chip (which is sometimes
    also called “the chipset” even when Northbridge is located on the CPU chip). Southbridge
    contains many different standard I/O modules, all printed on the same silicon.
    Here you’ll see structures such as USB controllers, hard disk controllers, and
    the older PCI (not PCIe) bus.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2](fm03.xhtml#fig2) in the introduction shows the physical layout of
    this design on a 2010s PC mainboard. In the figure, both Northbridge and Southbridge
    are covered by large heatsinks, showing that they’re major consumers of power
    and producers of heat, just like the CPU. Compared to retro computers, there are
    few other chips remaining on the mainboard, because most of their functionality
    has migrated to either Southbridge, Northbridge, or the CPU. The rest of the mainboard
    is taken up mostly by physical connectors and analog components used in power
    management.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: With Northbridge now migrated onto the same silicon as the CPU in many cases,
    it’s become harder to identify it on more modern mainboards.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Standardized I/O**'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A current desktop PC trend is toward standardized I/O. In the bad old days,
    every device would have its own I/O module, a physical component sitting on the
    bus. That meant that each device had its own IRQ (interrupt request) line into
    the processor. You would need a specific I/O-level driver to look after that module,
    which could be painful to configure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Bus hierarchies such as USB have now largely solved this problem for PCs. These
    use a single I/O module, such as a USB controller, which has to be configured
    only once and uses only a single IRQ. All the devices then connect to this controller
    using a lower-level bus with its own protocol, which can include communications
    that inform the controller what the device is. They can easily share the single
    IRQ allocated to the controller.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast Serial Buses**'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the golden age, a bus meant a whole load of parallel wires, often in the
    form of a ribbon cable, as in the left of [Figure 13-4](ch13.xhtml#ch13fig4).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0321-01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A 1980s parallel bus ribbon cable with lots of wires (left) versus
    a fast serial 2020s connector with fewer wires*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: It’s rare to see ribbon cables nowadays, as most buses are serial, having just
    one wire for communication plus a few control and power wires, as on the right
    of [Figure 13-4](ch13.xhtml#ch13fig4). For example, SATA, SSA-SCSI, USB, and CAN
    are all serial buses.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This change was prompted by technical problems with parallel buses that arrived
    once speeds exceeded around 1Gbps. Small differences in delays on out-of-box parallel
    wires can put signals on different wires out of sync, and resynchronizing their
    data is very hard. Serial buses, on the other hand, can be made faster and faster
    as there’s no need to sync multiple wires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration Up the Hierarchy**'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I/O modules get faster they want to move up the bus hierarchy to be closer
    to the CPU. Devices that used to hang off standardized buses, such as USB, want
    to connect directly to Southbridge; devices that used to hang off Southbridge
    want to get promoted to Northbridge; and devices that used to hang off Northbridge
    want to get promoted up into system-on-chip (SoC) silicon. At the same time, Northbridge,
    Southbridge, and standardized buses all want to increase their own speeds, meaning
    a device wanting to move from Southbridge to Northbridge, for example, might get
    overtaken by a new, faster Southbridge that makes its migration unnecessary. Since
    Moore’s law stopped the central CPU clock from getting faster, there’s been a
    big push to move innovation to all of these levels, which perhaps is making it
    a little more glamorous for the non-CPU architects who work on them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Migration up the bus hierarchy and onto silicon makes the economics and legal
    structures of computer design harder to understand. In 8-bit times, different
    companies could make separate physical chips, such as CPU and I/O modules. Computer
    manufacturers would buy these chips, then design and build PCBs to integrate them.
    Nowadays, as more of these structures need to be fabricated together on the same
    piece of silicon, the CPU and I/O module companies need to share their designs
    with the computer manufacturer, using software files similar to LogiSim designs.
    The manufacturer then adds designs to these files to link them together, then
    sends them to a fabrication company. The units of digital logic design provided
    by each company are known as *IP (intellectual property) cores* and need to be
    closely guarded by lawyers and patent agents rather than just bought and sold
    as physical chips in plastic packages.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*Common Buses*'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the space on mainboards is now taken up by connectors rather than chips,
    as you saw in [Figure 2](fm03.xhtml#fig2) of the introduction. The connectors
    seen in that figure are typical of other parts of the bus hierarchy. We’ll examine
    some of the main ones next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripheral Component Interconnect Express Bus**'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PCIe (not to be confused with the older PCI) stands for Peripheral Component
    Interconnect Express and is a general-purpose bus for connecting graphics and
    other cards. PCIe comes in several flavors, as shown in [Figure 13-5](ch13.xhtml#ch13fig5);
    the connectors have physically different widths because they have different numbers
    of lanes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0322-01.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-5: Some PCIe bus connectors*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: You can get various powers of 2 between 1 and 32 lanes, depending on how much
    data you want to transfer. PCIe also comes in different generations, with speeds
    going from 250MBps to 2GBps per lane.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Like many modern “buses,” PCIe began as an actual bus—in which many nodes share
    the same set of wires, each with its own address—but has evolved into a mesh network,
    with nodes now performing some routing to avoid congestion on the bus.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**SCSI and SATA Buses**'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SCSI and SATA are competing buses for mass storage devices (for example, hard
    disks). The Small Computer System Interface (SCSI, pronounced “scuzzy”) is a very
    ancient, classic, well-tested, reliable, and expensive standard, dating from the
    1980s. It pioneered moving compute work for I/O control from CPU into digital
    logic in the I/O module, freeing up the CPU to work on other tasks more quickly.
    It’s used today in servers. SCSI has been through many versions; the latest update
    is Serial Storage Architecture (SSA), a serial bus version.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Serial Advanced Technology Attachment (SATA) is cheaper and simpler than SCSI.
    For these reasons, it’s used in most consumer systems rather than SCSI.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Serial Bus**'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Universal Serial “Bus” (USB)* is the one you’re probably most familiar
    with. However, USB isn’t a bus at all—it’s not even a mesh network. It’s actually
    a point-to-point connector, intended to upgrade the older serial port.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Before USB was invented, whenever you got a new piece of hardware you would
    spend a day trying to get the device driver working and configuring the IRQ lines.
    USB now makes all of this instant so you can “plug and play” many devices. USB
    is designed so that devices can be connected and disconnected while the computer
    is turned on, and part of its standard defines a generic method for devices to
    state their type and model over the basic USB protocol itself rather than requiring
    a device driver. This enables computer software to automatically see what’s been
    plugged in, and in many cases to download and run the appropriate drivers for
    it without intervention.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: USB also defines standards for requesting and sending power down the wires.
    A USB cable has four wires, two for sending a serial signal and two for power.
    There are 5 V and a ground in there, so, for example, you can use the same USB
    cable to charge your mobile phone and exchange data with it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: All of this is done through a centralized USB controller, which is a single
    I/O module, so you don’t have to worry about IRQs anymore. The USB controller
    itself has an IRQ, but then everything else is hanging off a USB network. There
    have been different versions of USB, including USB 1 running at 12Mbps and USB
    3 running at 5Gbps.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike some point-to-point networks, USB connections have a manager end and
    a worker end, with the manager in charge of the communications protocol. If you
    plug a USB memory stick into your computer, your computer is the manager. As the
    worker, your USB stick can’t take over and start sending its own requests to copy
    data from your computer. This is why USB wires have different endings: one end
    plugs into the manager that controls it and the other end goes into the worker,
    and you can’t connect them the other way around.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '*On-the-go (OTG)* is part of the USB protocol that allows a worker device to
    act as a manager via a physical adapter. Sometimes you do want to connect them
    the wrong way around. For example, when you connect your smartphone to your computer,
    you usually want it to be the worker, like a USB stick, with your computer as
    the manager. But other times you want the phone to be the manager, such as when
    connecting a memory stick or sound card to it.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethernet**'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Ethernet*, in its oldest and simplest form, is a true bus, with multiple PCs
    in a local area network all writing and reading on public wires. Each message
    is packaged as a “frame,” containing the address (Media Access Control, or MAC,
    address) of the recipient. Senders must take care to avoid collisions—that is,
    people talking at the same time—by watching the bus and waiting for a suitable
    time to transmit. Everyone can see everything on the bus, so it’s easy to “sniff”
    the bus and spy on other users.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Modern networks build non-bus features on top of the basic Ethernet bus structure.
    For example, rather than connecting all computers in a building to a single shared
    Ethernet bus, it’s now common for each to connect only to a central *switch* using
    a dedicated Ethernet cable. The switch receives all messages that are sent, but
    rather than forwarding them, bus-style, to all machines on the network, it forwards
    them only to the intended destination.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard Devices*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your desktop PC wouldn’t be complete without some other standard devices. To
    complete our study of PCs, let’s take a quick look at how these have evolved.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**Flat-Screen Displays**'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern flat-screen displays are used in mobile phone screens and large-screen
    TVs and monitors. They’re made from transistors and capacitors, laid down like
    chips by photolithography masks and gas processes. Many rare elements are used
    to produce the specific red, green, and blue light-emitting pixels, including
    yttrium, lanthanum, terbium, praseodymium, europium, dysprosium, and gadolinium.
    Some of these are so rare that they can be mined only in one or two places. Many
    specific combinations of electronics and elements have been used as display “technologies,”
    including TFT. The latest at the time of writing is organic LED (OLED).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphics Cards**'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the 1980s, graphics was simple. An area of memory was allocated to represent
    the array of pixels on the screen. User programs would write to it like any other
    part of memory. Then a graphics chip would read from it and turn the data into
    CRT scanning commands to send to the monitor. Now things are more complicated,
    as programmers expect graphics hardware to provide commands for complex rendering
    of 2D and 3D shapes without taking up CPU time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: To respond to this demand, the modern graphics processing unit (GPU) evolved
    from 1980s visual display units (VDUs). Rather than taking commands to light up
    pixels, GPUs typically take commands to render 3D triangles with sprite-like textures,
    and to shade them using complex lighting models.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been playing video games over the last couple of decades, you’ll have
    seen the visual abilities of GPUs evolve with Moore’s law, doubling in quality
    and getting closer to photorealistic, real-time rendering.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The GPU traditionally sits on one of the buses of the mainboard, such as PCI,
    AGP, or PCIe. GPUs have been the one part of computer architecture that’s been
    getting physically bigger rather than shrinking over the years, starting off as
    a small chip and now most likely a full card ([Figure 13-6](ch13.xhtml#ch13fig6)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0325-01.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-6: A 2022 Nvidia RTX 3080 GPU*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: There has, however, also been a recent trend to shrink GPUs back to put on a
    single chip on the mainboard, or onto the same silicon as the CPU. This is particularly
    the case in machines where the GPU isn’t the main focus, such as generic business
    PCs where the graphics requirements don’t extend much beyond displaying the desktop.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Graphics cards sit on the system bus as I/O modules. Importantly, they can use
    direct memory access (DMA). For example, an image can be placed in regular RAM,
    then a single command can be given to the GPU to load it from main RAM into the
    GPU. This DMA action doesn’t go through the CPU, so from the CPU’s point of view
    it’s almost instant. (It will, however, slow down if the bus is needed for other
    things, such as additional DMAs from a webcam into the main RAM.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Early GPUs were designed to accelerate rendering of the popular OpenGL 3D graphics
    API by implementing its commands directly in hardware, beginning with a memory-mapped
    area and a chip that read that area and figured out how to display that memory
    block on the screen. In the 2000s, in addition to or instead of memory-mapped
    graphics, optional plug-in graphics cards sat on the system bus as I/O modules
    and drew graphics in response to compiled and assembled commands of graphics languages
    such as OpenGL or DirectX, sent to them via the system bus. Graphics cards were
    labeled and sold as implementing one or more of these language interfaces.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: A 3D graphics language usually assumes that 3D objects are composed of many
    small triangles. Triangles are chosen because their three points always lie in
    a plane, making the math easier. Their implementations, in hardware and/or software,
    usually split into two main parts, known as *shaders*. First, vertex calculations
    convert the 3D coordinates of each vertex into 2D pixel coordinates. Second, pixel
    calculations compute the color (shade) of each display pixel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The latter can be done in many different ways according to different mathematical
    models of how surfaces and lights interact. Most shaders allow triangles to be
    translucent (partly transparent), modeled via an alpha channel in their RGBA color,
    as discussed on [page 68](ch02.xhtml#page_68). Some shaders allow normal (orthogonal)
    vectors to be described for each triangle as a hint that they’re part of smooth,
    continuous surfaces.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-7](ch13.xhtml#ch13fig7) shows the results of three traditional shaders
    built into early OpenGL implementations, rendering the same triangle mesh approximation
    to a sphere.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0326-01.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-7: Traditional OpenGL shaders: flat (left), Gouraud (center), and
    Phong (right)*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Graphics users demanded more flexibility in shaders. New shading models are
    often proposed in graphics research, and users wanted them to be quickly available
    in their own systems. The graphics languages rapidly gained many extension commands
    in their later versions, to enable particular additional shaders, and graphics
    card architects struggled to keep up with designing new hardware to implement
    them and make them compatible with one another. These architects instead began
    to open up new and simpler shader languages (such as GLSL) to enable these and
    other arbitrary shaders to be implemented in user programs, and executed on the
    graphics card—now known as a GPU—via their own ISAs. This allowed programmers—especially
    game designers and movie studios—to create their own custom shaders to give their
    creations a more individual feel, as in the examples in [Figure 13-8](ch13.xhtml#ch13fig8).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0326-02.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-8: Custom shaders: water effects from* 0 A.D. *(left), “toon” shading
    (center), and retro CRT emulation (right)*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Today’s graphics systems have continued this architectural trend, with GPUs
    now functioning as highly general parallel processors of their own instruction
    sets, and the graphics-specific shaders moved into software. Former hardware interfaces
    including OpenGL and DirectX are now implemented in software, written in the GPU’s
    own assembly and machine code. Such code can now also be generated directly by
    other graphics tools, such as Wayland compositors and the Vulkan SPIR-V language.
    The resulting GPU machine code is sent over the bus to the graphics card, where
    it runs on the GPU. We’ll study this code in more detail in [Chapter 15](ch15.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**Sound Cards**'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike retro sound chips, such as the SID, modern sound cards don’t generate
    signals at all. Instead, they manage the flow of quantized, digital sound wave
    signals. As a result, computers have lost their characteristic sound effects and
    musical culture: modern game music can consist of ordinary recordings of orchestras
    or rock bands rather than any particular “computer music.” Like graphics cards,
    sound cards are always now under OS control, so user programmers are unlikely
    to see much of their architecture.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: A modern sound card is really just a group of digital-to-analog converters (DACs),
    and indeed it’s possible to make your own from any DAC, such as the one found
    on a Labjack, a software-defined radio, or an Arduino Due. Typically, professional
    sound cards are optimized for low latency, sound quality, and many channels, while
    consumer cards are optimized for lower cost. Human hearing has a maximum frequency
    of around 20 kHz, which requires a 40 kHz sampling rate to be represented accurately.
    It’s common to use 48 kHz to allow some wiggle room and because it’s almost a
    power of 2\. Professional systems may use higher rates to reduce the buildup of
    audible errors from repeated processing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Sound card hardware typically consists of a ring buffer for each channel, as
    well as DAC hardware, which reads or writes to and from it. A ring buffer maintains
    a pointer to the next location to write, and wraps the storage around the ring
    so space doesn’t run out. The buffer size provides a trade-off between latency
    and dropouts. A small buffer means low latency but risks dropouts. We can also
    choose the bit depth of the audio.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Sound cards, like graphics cards, connect to the system bus. They’re less bandwidth-hungry
    than video, so they’re usually found on a bus hanging off of Southbridge, such
    as PCI for internal cards or USB or Firewire for external cards.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Sound card I/O protocols vary by manufacturer, and like GPUs, their details
    may be proprietary and known only to the driver writers inside the company, who
    then make a software API available. As with GPUs, the hardware or software interfaces
    are then reverse engineered by open source driver writers, who wrap them in generic
    software APIs such as *ALSA*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyboards and Mice**'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern keyboards are nothing like the memory-mapped keyboards of the 1980s.
    They now contain small, embedded computers (see [Figure 13-9](ch13.xhtml#ch13fig9)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0328-01.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-9: The key pressure sensors and embedded system inside a modern
    keyboard*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard’s embedded computer is actually doing a lot of work, similar to
    a typical Arduino application. It takes the matrix of key presses, converts them
    to a keycode data representation scheme, and transmits them over a virtual serial
    port wrapped in USB protocol.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Something similar has happened with mice. A modern optical mouse performs some
    extremely complicated real-time machine vision processing known as *optic flow*
    on a dedicated internal embedded system. If you try to implement optic flow in
    software, you’ll find it’s hard to do fast. It’s still a research area, with recent
    implementations in software libraries such as OpenCV. In a mouse, however, it’s
    implemented directly as low-level digital electronics, as in [Figure 13-10](ch13.xhtml#ch13fig10).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0328-02.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-10: The inside of an optical mouse*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This digital logic is just about simple enough for you to still be able to see
    the connections. You can see from the overall, fairly homogeneous structure that
    it’s processing a region of 2D space—the image underneath the mouse. It tracks
    how light and dark areas of this image are moving around and from that infers
    the movement of the mouse.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: There’s also usually a USB controller attached to the device. This is actually
    a complex embedded system—possibly a computer in its own right—and the fact that
    it’s now available for a few dollars in every mouse is very impressive.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**THE PC BOOT PROCESS**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The term *booting* comes from the paradoxical expression “pulling yourself up
    by your bootstraps.” It means starting with nothing and getting into a complex
    computer system by having small programs execute that load slightly larger and
    more powerful programs, in a sequence. On both retro systems and modern PCs, this
    begins by the CPU fetching an instruction from a hardwired ROM address.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Unlike retro computers, modern PCs aren’t made from standard components; instead,
    they are assembled from many different optional components, such as RAM modules
    of various types, caches, and I/O extension cards. It’s not initially obvious
    where all these things are, how they should be initialized, or how they should
    be mounted in the address space. To address this, the modern PC boot process is
    split into two parts.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: First, a *bootloader* such as *coreboot* is burned into ROM firmware, at the
    address of the CPU’s initial program counter. For x86, this is ffff,fff0[16].
    This is a 16-bit address, because x86 processors always power on in “legacy mode”
    (Intel calls it “real mode”), which makes them behave like 1980s 16-bit chips
    for backward compatibility. In this mode, only 1 M[2]B of combined ROM and RAM
    memory is addressable, and the initial program counter address is near the top
    of it. The bootloader runs from here and is responsible for inspecting, initializing,
    and assigning addresses to the available hardware. The boot-loader doesn’t display
    anything onscreen because there aren’t yet any routines available for doing I/O.
    Because it’s invisible, it can be hard to understand all the hard work the bootloader
    is doing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Second, after this initialization, the bootloader performs a jump to code in
    the BIOS. The BIOS, as in a retro computer, contains subroutines for basic I/O
    such as ASCII character display, keyboard reading, and hard disk access. At this
    stage, your PC can look and feel much like a retro computer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the BIOS code jumped to from the bootloader will print a few strings
    on the screen, such as the name and logo of the BIOS. A PC BIOS ROM and an example
    of BIOS display I/O capabilities are shown here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0330-01.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: A BIOS will usually first offer the user the chance to “go into the BIOS” by
    pressing a key, which will call graphical routines for setting configuration options.
    One of these options is usually to give the name of a storage device whose first
    data contains the next program to be loaded and jumped to, usually at address
    7c00[16]. What this program does is up to you—a common first move is to switch
    the x86 up into 32-, then 64-bit modes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: There was a time when different x86 BIOS manufacturers all made different and
    incompatible libraries of routines, but they’ve now converged on two standards.
    One, PCBIOS, was defined by IBM (who just call it “BIOS”) in early x86 PCs. It
    was cloned by other manufacturers and is still used by many x86 machines today.
    SeaBIOS is an open source implementation. The other standard, UEFI, is more recent.
    It assumes more advanced graphics and I/O are available, so its library of routines
    includes higher resolution and more colorful graphics, and access to additional
    devices such as USB. TianoCore is an open source implementation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No one would design a modern desktop PC to have its current form if they were
    able to start from scratch. Like many successful commercial, real-world systems,
    the PC has evolved over time as new features have been requested and bolted on,
    while existing customers demand backward compatibility. As a result, both the
    x86 architecture and PC computer design have accumulated layers of legacy features.
    The CISC philosophy is a good fit for this environment. It’s common for multiple
    competing standards to be supported within single designs, even including multiple
    choices for x86 assemblers including but not limited to NASM. Recent x86 has extended
    beyond the features seen in this chapter by adding parallelization, which we’ll
    examine in [Chapter 15](ch15.xhtml). But before this, we’ll take a breather by
    looking at developments in the cleaner, more beautiful world of RISC in the next
    chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Creating a Bootable ISO Image**'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here you’ll create a simple 16-bit “Hello, world!” program, assemble it with
    NASM into executable machine code, then store this machine code in an ISO file,
    an image of the contents of a physical secondary storage device that you can use
    to boot a real PC or a virtual machine.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following *hello16bit.asm* file:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following commands:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**NOTE**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re using Microsoft Windows, these commands can be run by installing
    and using the Windows Subsystem for Linux. If you don’t already have NASM, install
    it from* [https://nasm.us](https://nasm.us). *You may also need to install mkisofs
    for your system.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: If everything worked, you’ll now have a *cd.iso* file for booting a physical
    or virtual x86 machine. This will allow you to run on “bare metal” x86, without
    an operating system getting in the way.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll discuss how to boot into your ISO file in the next exercises. When you
    do, you should see something like [Figure 13-11](ch13.xhtml#ch13fig11) on the
    screen.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0332-01.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-11: The result of booting into a bare metal test program*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, let’s look at what *hello16bit.asm* actually does.
    In addition to actual x86 instruction mnemonics, a NASM program usually also includes
    some directives, which are lines that aren’t assembled themselves but instead
    tell NASM to change its behaviors in various ways. The `section` directive tells
    NASM to change which segment of the output file to write the next assembled instructions
    to. In some file formats, the number and names of sections are fixed; in others,
    the user may make up as many as they wish. The Unix object and bin formats all
    support the standardized section names `.text` (contains executable instructions),
    `.data` (contains initialized variables), and `.bss` (contains uninitialized variables).
    The ASCII string includes special ASCII codes 13, 10, and 0 after the human readable
    letters. What are these? (Hint: See [Chapter 2](ch02.xhtml).)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '**Booting on a Virtual x86**'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ISO can be booted on a virtual machine as if it were a physical disk. Follow
    these steps to try it out using the VirtualBox virtual machine. (Open source Linux
    users may prefer to use virt-manager at *[https://virt-manager.org](https://virt-manager.org)*.)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Visit *[https://www.virtualbox.org](https://www.virtualbox.org)* for instructions
    on how to install VirtualBox on your system.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, create a new virtual machine by clicking the **New** icon; use
    the default settings.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start your virtual machine and “insert” your bootable virtual CD by selecting
    your *cd.iso* file when asked.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Booting on a Physical x86**'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ISO can also be booted on a physical x86 machine if you first “burn” it
    onto a physical USB stick. Here’s how:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Use a program such as Etcher (*[https://www.balena.io](https://www.balena.io)*)
    for your current operating system to burn the ISO to a USB stick.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have a bootable USB stick, you need to tell your PC to boot from it.
    Your PC is probably currently configured to boot from a hard disk, but it will
    have some method—which varies by manufacturer—to change to booting from USB as
    part of its BIOS configuration tools. Editing these settings is called “going
    into the BIOS.” On most machines it’s done by holding down a particular key for
    a few seconds as you turn on the machine. This is often ESC, DEL, F1, F2, F8,
    F10, or F11, depending on the manufacturer (if it doesn’t say which, try running
    a finger over the whole top row of the keyboard to hit them all). You’ll usually
    see some low-resolution BIOS menus: if you hunt around, there will be some way
    to specify the boot order and bring USB to the top of it. Some machines may have
    additional security features that need to be disabled before you can boot from
    a new device.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Booting to and Programming in 64-Bit Mode**'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Switching a modern x86 into 32- and 64-bit modes isn’t trivial. Due to historical
    baggage, it requires a couple of screens of instructions and data. How these work
    is fairly obscure, but luckily it’s a standard process that can now be done using
    the boilerplate code shown here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you save this, assemble it, and put it into an ISO as for the 16-bit version,
    it will boot your real or virtual x86 into 64-bit mode and print another “Hello,
    world!” message. You can then use the “Hello, world!” program as a starting point,
    modifying it into your own bootable programs for the following tasks:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Write a subroutine that reads integers and converts them into ASCII strings.
    Extend it to floating point. Use it to print out some numbers along with “Hello,
    world!”
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try porting previous programs from the Analytical Engine and Manchester Baby
    to run on x86\. What’s gotten easier or harder to do in modern x86 compared to
    those systems?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the BIOS routine to light up pixels on the screen several times to draw
    a simple shape.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Challenging**'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a simple game such as *Space Invaders* using the above BIOS calls, on
    bare metal x86.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the official NASM manual, see “NASM: The Netwide Assembler,” *[https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html](https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html)*.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an overview of x86 history, see P. Lilly, “A Brief History of CPUs: 31
    Awesome Years of x86,” *Maximum PC*, April 2009, *[https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86](https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86)*.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the full five-volume amd64 reference set, see AMD Technology, *AMD64 Architecture
    Programmer’s Manual Volumes 1–5* (Santa Clara: AMD Technology, 2023), *[https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5](https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5)*.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on 3D graphics programming, see Graham Sellars, *Vulkan Programming
    Guide* (Boston: Addison-Wesley, 2017).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details of how the x86 boot assembly code works, see Gregor Brunmar, “The
    World of Protected Mode” (*[http://www.osdever.net/tutorials/view/the-world-of-protected-mode](http://www.osdever.net/tutorials/view/the-world-of-protected-mode)*),
    the lame_bootloader GitHub repository (*[https://github.com/sedflix/lame_bootloader](https://github.com/sedflix/lame_bootloader)*),
    and “Setting Up Long Mode” (*[https://wiki.osdev.org/Setting_Up_Long_Mode](https://wiki.osdev.org/Setting_Up_Long_Mode)*).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
