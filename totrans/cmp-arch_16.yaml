- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**DESKTOP ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**桌面架构**'
- en: '![Image](../images/f0301-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0301-01.jpg)'
- en: “A computer on every desk” was Bill Gates’s ambition during the 32-bit era of
    the 1990s, and while the current trend is toward the Internet of Things and the
    cloud, a personal computer (PC) can still be found on many desks and laps today.
    The PC isn’t a single computer design; rather, it’s a set of loose conventions
    for combining many different components from different manufacturers into computers,
    based around the x86 family of CPUs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “每个桌面上都有一台计算机”是比尔·盖茨在1990年代32位时代的愿景，尽管当前的趋势是物联网和云计算，但个人计算机（PC）今天仍然能在许多桌面和膝上看到。PC并不是单一的计算机设计；它是通过将来自不同制造商的许多不同组件结合在一起，围绕x86系列CPU构建的一套松散的约定。
- en: Thanks to a business-led focus on backward compatibility, modern PCs retain
    many features from earlier stages of their evolution, so in this chapter we’ll
    study how these conventions came into being and how they’ve affected x86 architecture
    and PC computer design. We’ll examine x86’s CISC philosophy and its Silicon Valley
    history and instruction set, then look at some computer design elements used to
    build modern PCs around it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于商业驱动的向后兼容性，现代PC保留了许多早期阶段的特性，因此在本章中，我们将研究这些约定是如何形成的，以及它们如何影响x86架构和PC计算机设计。我们将考察x86的CISC哲学及其硅谷历史和指令集，然后看一下用于围绕它构建现代PC的一些计算机设计元素。
- en: CISC Design Philosophy
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CISC设计哲学
- en: Most desktop computers use CPUs from the x86 family, which are usually described
    as CISC architectures. We’ve seen CISC architectures a few times, but let’s take
    a closer look at some of the CISC principles that appear in x86.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数桌面计算机使用来自x86系列的CPU，这些CPU通常被描述为CISC架构。我们已经见过几次CISC架构，但让我们更详细地看看出现在x86中的一些CISC原则。
- en: In a CISC architecture, you try to do as many big and clever things as you can
    on a large, complex chip with lots of silicon. You design many different small
    machines that all do different specialized things; you also provide dedicated
    instructions for each of them. As you can imagine, this is very hard to design,
    and you end up having to pay your architects a lot of money—especially when all
    the new complex features need to be made to play nicely with other innovations,
    such as pipelining and out-of-order execution (OOOE). Using lots of silicon typically
    consumes lots of power, so CISC processors often have to be plugged into the wall,
    with heavy power transformers and large cooling systems such as fans. These requirements
    are easier to meet in a desktop setting than in embedded and smart-type environments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在CISC架构中，你试图在一个大而复杂的芯片上做尽可能多的、巧妙的事情，芯片包含大量的硅。你设计许多不同的小型机器，每个机器都执行不同的专门功能；你还为每个机器提供专门的指令。正如你可以想象的那样，这非常难以设计，最终你不得不支付给你的架构师大量的钱——特别是当所有新的复杂功能需要与其他创新（如流水线和乱序执行（OOOE））良好协作时。使用大量硅通常会消耗大量功率，因此CISC处理器通常需要插入电源插座，配备强大的电源变压器和大型冷却系统，如风扇。这些要求在桌面环境中比在嵌入式和智能设备环境中更容易满足。
- en: 'A classic aspect of CISC philosophy is having lots of instructions that combine
    memory access with arithmetic logic unit (ALU) instructions, such as “multiply
    the contents of a first address by the contents of a second address and store
    the result in a third address,” where the addresses are in RAM. This is, in fact,
    a compound instruction involving many steps: we need to load both addresses, multiply
    their values, put the resulting value in a register, and store it in memory again.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CISC哲学的一个经典特征是有大量指令将内存访问与算术逻辑单元（ALU）指令结合，例如“将第一个地址的内容与第二个地址的内容相乘，并将结果存储在第三个地址”，其中地址位于RAM中。实际上，这是一个涉及多个步骤的复合指令：我们需要加载这两个地址，乘以它们的值，将结果存入寄存器，然后再次将其存储到内存中。
- en: CISC also emphasizes implementing new instructions in hardware essentially saying,
    “Throw more silicon at the problem.” For example, if users demand lots of video
    codec streaming, you can create special instructions that perform the specific
    mathematical operations used in video codecs, and build lots of new simple machines
    in digital logic to implement each of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CISC还强调在硬件中实现新指令，基本上是在说：“更多的硅解决问题。”例如，如果用户需求大量的视频编解码流媒体，你可以创建专门的指令来执行视频编解码中使用的特定数学运算，并在数字逻辑中构建许多新的简单机器来实现它们。
- en: 'A “decode my video” instruction is going to take more than one clock cycle,
    and accommodating different instructions that take differing amounts of time is
    a major challenge that arises in CISC architectures. In particular, pipelining
    and OOOE are harder to get right when instructions have different durations. This
    problem can be fixed by throwing even more silicon at it: you can create even
    more complex digital logic in the control unit (CU) to identify these durations
    and schedule around them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“解码我的视频”指令将需要超过一个时钟周期，并且处理不同指令所需的时间差异是CISC架构中面临的主要挑战。特别是，当指令的执行时间不同的时候，流水线和乱序执行（OOOE）就更难正确实现。这个问题可以通过增加更多硅片来解决：你可以在控制单元（CU）中创建更复杂的数字逻辑来识别这些时间差异，并根据它们进行调度。
- en: One supposed advantage of CISC architectures is that the compiler has to do
    very little work to translate common high-level language statements into assembly;
    this is because the instruction set architecture (ISA) has dedicated instructions
    for commands such as “decode my video,” which then have a simple one-to-one translation.
    But these instructions make life harder for compiler writers, who now need to
    wade through a five-volume set of instructions for *every* backend CPU they target;
    they’re also now expected to make some attempt to optimize their compiler for
    each particular ISA. It would be much easier for compiler writers to just use
    one volume of instructions and ignore all the advanced ones. In practice, this
    means that CISC architectures are more likely to come with compilers written by
    the same people who built the CPU, because no one else wants to work to optimize
    for one particular CPU. These compilers tend to be proprietary and to run faster
    than the open source versions due to the complexity involved; only those who built
    the system fully understand all the features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CISC架构的一个假定优势是，编译器几乎不需要做任何工作就可以将常见的高级语言语句翻译成汇编语言；这是因为指令集架构（ISA）为诸如“解码我的视频”这样的命令提供了专门的指令，这些指令通常有一个简单的一对一的翻译。但是这些指令让编译器编写者的工作变得更加困难，他们现在需要为*每个*目标后端CPU通读五卷指令集；他们现在还需要尝试针对每个特定的ISA来优化编译器。对于编译器开发者来说，使用一本指令集并忽略所有高级指令会更容易。实际上，这意味着CISC架构更有可能配备由同样开发CPU的团队编写的编译器，因为没有其他人愿意为某个特定CPU进行优化。这些编译器通常是专有的，并且由于涉及的复杂性，比开源版本运行得更快；只有那些构建系统的人才完全理解所有的特性。
- en: 'Another upside is that assembly programs can be short, as every instruction
    does a lot of work. In the 1980s, this was important: RAM was limited, so shorter
    programs freed up more RAM for data. It’s not so important today.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是汇编程序可以很短，因为每条指令做了很多工作。在1980年代，这一点很重要：RAM受限，因此较短的程序释放了更多的RAM用于数据。今天，这点已经不那么重要了。
- en: CISC was invented by an Englishman, Maurice Wilkes, seen previously in [Figure
    1-19](ch01.xhtml#ch01fig19), but was commercialized by Americans. Stereotypical
    CISC architects and users are business-driven, and CISC is dominant in real-world
    desktop computing. You’re probably using a CISC architecture on your desktop today.
    If a CISC client asks for a new instruction to speed up their particular multimedia
    application, then the CISC business will often design and add it for them—for
    a cost. New features are often bolted on in this way, without necessarily being
    designed to beautifully fit together with what was there before. The older features
    will usually be retained, however, in order to avoid breaking other customers’
    existing systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CISC是由一位英国人莫里斯·威尔克斯（Maurice Wilkes）发明的，如前所示在[图1-19](ch01.xhtml#ch01fig19)，但它是在美国得到商业化的。典型的CISC架构师和用户是以商业驱动为主的，CISC在现实世界的桌面计算中占据主导地位。你今天可能就在使用CISC架构的桌面计算机。如果一个CISC客户要求添加一个新的指令来加速他们特定的多媒体应用程序，那么CISC公司通常会为他们设计并添加这个指令——当然是有成本的。这些新特性通常是以这种方式附加上的，并不一定设计得与之前的系统完美契合。然而，为了避免破坏其他客户的现有系统，旧特性通常会被保留。
- en: Microprogramming
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微程序设计
- en: Building new CPUs in hardware is hard and expensive. A chip mask set costs around
    $5 million to make, and if you get it wrong anywhere, new masks will be needed.
    This problem is acute for CISC due to its complex designs. *Microprogramming*
    is a solution to this problem in which the architecture consists of many simple
    machines that can be connected and disconnected through basic switches. Instructions
    are then defined as sequences of connections and disconnections. For example,
    to add two registers, you first connect one of them to an ALU input, then connect
    the other register to the other ALU input. Then you connect the ALU to a signal
    asking it to add, and finally you connect the result in the ALU output to a register.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中构建新 CPU 既困难又昂贵。制作一个芯片掩膜集的成本大约为 500 万美元，如果某个地方出现错误，就需要新的掩膜。由于 CISC 设计复杂，这个问题尤为严重。*微程序设计*是解决这个问题的一种方法，它使得架构由许多简单的机器组成，这些机器可以通过基本的开关连接和断开。指令则被定义为连接和断开序列。例如，要将两个寄存器相加，你首先将其中一个寄存器连接到
    ALU 输入，然后将另一个寄存器连接到另一个 ALU 输入。接着，你将 ALU 连接到一个信号，指示它进行加法运算，最后将 ALU 输出的结果连接到一个寄存器。
- en: This idea is reminiscent of the rotating barrel CU in Babbage’s Analytical Engine.
    The barrel has pins that are placed to trigger sequences of the simple machines.
    If the pins are moved around, different instructions and architectures can be
    easily created. Modern electronic microprogramming—and hence CISC—is credited
    to Wilkes, who studied and taught the history of computing and was very open about
    having picked up the idea from Babbage’s mechanical barrel. This is a paradigmatic
    example of how studying the arc of history can enable major, Turing Award–winning
    advances in modern architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法让人想起了巴贝奇的分析机中的旋转桶控制单元（CU）。桶中有触发器，通过它们可以触发一系列简单机器的工作。如果触发器位置发生变化，就可以轻松创建不同的指令和架构。现代电子微程序设计——因此也包括
    CISC——被归功于威尔克斯（Wilkes），他研究并教授计算历史，并且非常坦率地承认从巴贝奇的机械桶中获得了这个想法。这是一个典型的例子，说明了研究历史的轨迹如何促成现代架构中的重大、图灵奖获奖的进展。
- en: The electronic version of Babbage’s barrel pins is usually firmware, known as
    *microcode*, inside the CPU, containing a list of connections to make and break
    in sequence for each instruction. (This isn’t ROM in the CPU’s address space,
    it’s a non-addressable, separate region inside the CPU itself.) As firmware, it
    can be electronically reprogrammed at any time. This massively reduces the cost
    of fixing hardware bugs in the CPU, as they can be corrected with a firmware update
    rather than having to return and remanufacture the chip itself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 巴贝奇桶中触发器的电子版本通常是固件，称为*微代码*，它存在于 CPU 内部，包含每条指令中要顺序连接和断开的连接列表。（这不是 CPU 地址空间中的
    ROM，而是 CPU 内部一个不可寻址的独立区域。）作为固件，它可以随时进行电子重编程。这大大减少了修复 CPU 硬件故障的成本，因为可以通过固件更新来修正问题，而不必返回并重新制造芯片。
- en: Microprograms aren’t machine code programs; they exist at a lower level, defining
    the machine that the machine code runs on. The actions of microprograms can be
    notated using register transfer language (RTL), as in [Chapter 7](ch07.xhtml).
    Modern CISC chips may have many thousands of complex instructions all defined
    in microcode. You can re-microprogram your CPU to implement a completely different
    instruction set if you like, such as turning an x86 into a retro 6502! There’s
    now so much reconfigurability that microprograms can behave almost like FPGAs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微程序不是机器代码程序；它们存在于更低的层次，定义了机器代码运行的机器。微程序的动作可以使用寄存器传输语言（RTL）进行标注，如在[第 7 章](ch07.xhtml)中所示。现代
    CISC 芯片可能有成千上万条复杂的指令，这些指令都通过微代码来定义。如果你愿意，你可以重新编写你的 CPU 微程序，实施完全不同的指令集，比如将 x86
    转换为复古的 6502！现在的可重配置性已经非常强大，微程序几乎可以像 FPGA 一样运行。
- en: Now that we’ve seen some of the design concepts, let’s turn to the history of
    x86\. Doing so will help you make sense of features still present in modern x86s
    that have accumulated through this history.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些设计概念，让我们来看看 x86 的历史。了解这些历史将帮助你理解现代 x86 处理器中仍然存在的、通过这段历史积累的特性。
- en: x86 History
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86 历史
- en: 'The x86 architecture has been the most commercially successful and resilient
    CPU architecture to date, reaching its 45th anniversary in 2023\. x86 is a family
    of CISC architectures whose designs and names derive from the model numbers of
    the first few generations of Intel processors: 8086, 80286, 80386, and 80486\.
    x86 has persisted across three generations of word lengths: 16-, 32-, and 64-bit
    architectures. As a commercial product, it has strongly emphasized rigorous backward
    compatibility with all previous generations, at the cost of adding complexity
    to the design, including digital logic to ensure historical bugs are kept in order
    to allow old games that exploit them as features to continue to run. You can still
    take your executable machine code from the 1970s and run it on a modern x86 and
    it will “just work.” (This is a similar approach to software design in commercial
    operating systems, which similarly grow to huge, bloated sizes to maintain compatibility
    for customers at the expense of performance and beauty.) As a result of continually
    adding new CISC instructions and keeping all the old ones, the latest version
    of x86—the *amd64* ISA—now includes over 3,000 instructions, documented in a five-volume
    set of reference books.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构是迄今为止最具商业成功和韧性的CPU架构，2023年迎来了它的第45个周年纪念。x86是一系列CISC架构，其设计和名称来源于英特尔处理器前几代的型号：8086、80286、80386和80486。x86跨越了三代字长：16位、32位和64位架构。作为一个商业产品，它特别强调与所有前代架构的严格向后兼容性，尽管这增加了设计的复杂性，包括数字逻辑，以确保历史遗留的bug得以保留，从而使得那些利用这些bug作为特性的旧游戏仍能继续运行。你仍然可以将1970年代的可执行机器代码拿到现代x86上运行，它会“顺利运行”。（这与商业操作系统中的软件设计方法类似，后者也同样膨胀到巨大的规模，以维护客户兼容性，代价是性能和美观的牺牲。）由于不断添加新的CISC指令并保留所有旧指令，最新版本的x86——*amd64*指令集架构——如今包含超过3000条指令，这些指令被记录在五卷的参考书中。
- en: '*Prehistory*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*史前时期*'
- en: The history of x86 design is one of Silicon Valley architecture and politics,
    and specifically of the companies Intel and AMD. Both companies make processors
    using the same proprietary instruction set, and they’re constantly locked in legal
    battles with each other, which have now spanned decades.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: x86设计的历史是硅谷架构和政治的历史，特别是英特尔和AMD两家公司之间的历史。这两家公司使用相同的专有指令集制造处理器，而且它们之间不断进行法律斗争，这些争斗已经持续了几十年。
- en: William Shockley, John Bardeen, and Walter Brattain were awarded the Nobel Prize
    in Physics in 1956 for their invention of the transistor at Bell Labs, New Jersey.
    Shockley’s family was from Palo Alto, California, though he was born in London.
    After winning a Nobel Prize, you can live and work wherever you like, so Shockley
    decided to relocate from New Jersey to Mountain View, California, because he wanted
    to be near his mother in Palo Alto. He set up Shockley Semiconductor there to
    continue his transistor research and commercialization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 威廉·肖克利、约翰·巴丁和沃尔特·布拉廷因发明晶体管而获得了1956年诺贝尔物理学奖，发明地是在新泽西州的贝尔实验室。肖克利的家族来自加利福尼亚州的帕洛阿尔托，尽管他出生在伦敦。获奖之后，你可以在任何地方生活和工作，因此肖克利决定从新泽西迁往加利福尼亚州的山景城，因为他希望能靠近位于帕洛阿尔托的母亲。他在这里成立了肖克利半导体公司，继续进行晶体管的研究和商业化。
- en: By 1957, Shockley had become a difficult person to work with due to a mixture
    of Nobel laureate hubris and obsession with topics considered fringe by his staff.
    A group of employees, the so-called “traitorous eight”—including Gordon Moore
    and Robert Noyce—walked out on Shockley to set a rival firm, Fairchild Semiconductor.
    This was considered almost blasphemous by the commercial culture of the time,
    in which it was assumed people would join a big company and be loyal company servants
    for their whole careers. It has since become the blueprint for Silicon Valley’s
    startup culture, in which it’s assumed employees will and should leave big companies
    to start their own.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到了1957年，由于诺贝尔奖得主的傲慢与对一些被员工认为是边缘话题的痴迷的混合，Shockley已经成为一个很难合作的人。一群员工，所谓的“背叛的八人组”——包括戈登·摩尔和罗伯特·诺伊斯——离开了Shockley，成立了竞争公司费尔柴尔德半导体。这在当时的商业文化中几乎被视为亵渎，因为人们普遍认为，员工会加入大公司，并忠诚地为公司服务整个职业生涯。此后，这种做法成为了硅谷创业文化的蓝图，认为员工会并且应该离开大公司，自己创办公司。
- en: Fairchild created the first commercial version of the integrated circuit (chip).
    Demand for computing at this time was almost entirely from the American military,
    which used taxpayer money to subsidize research and buy the products of chipmakers
    to power missiles and planes for the Cold War. These government funds fed the
    silicon industry, accelerating the growth of Fairchild and also many rival upstarts
    as Fairchild staff copied the Fairchild model and left to start their own competing
    chip companies, giving rise to modern Silicon Valley.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 飞兆半导体公司（Fairchild）创造了集成电路（芯片）的第一个商业版本。此时，对计算的需求几乎完全来自美国军方，军方利用纳税人的资金资助研究，并购买芯片制造商的产品，为冷战中的导弹和飞机提供动力。这些政府资金推动了硅行业的发展，加速了飞兆半导体的成长，并促使许多竞争对手的崛起，因为飞兆的员工复制了飞兆的模式，离开公司创办了自己的竞争性芯片公司，最终催生了现代硅谷。
- en: In 1968, Fairchild politics led Gordon Moore and Robert Noyce to quit again—this
    time leaving Fairchild to set up Intel (short for Integrated Electronics). AMD
    (Advanced Micro Devices) was founded the following year by Jerry Sanders. AMD’s
    early goal was to copy Intel’s products and produce them more cheaply as a second
    source. Before the x86 series proper, Intel produced the 4-bit 4004 in 1971\.
    AMD cloned it shortly afterward in 1975 as the Am9080\. Intel preempted this in
    1974 with an 8-bit version, the 8080 (3 MHz), which was then also copied by AMD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年，飞兆半导体的内部政治导致戈登·摩尔和罗伯特·诺伊斯再次辞职——这次他们离开飞兆成立了英特尔（Integrated Electronics的缩写）。AMD（Advanced
    Micro Devices）于次年由杰里·桑德斯创立。AMD早期的目标是复制英特尔的产品，并作为第二来源以更低的成本生产这些产品。在x86系列正式推出之前，英特尔于1971年生产了4位的4004芯片，随后AMD于1975年将其克隆为Am9080。英特尔在1974年通过推出8位版本的8080（3
    MHz）抢先一步，随后AMD也复制了这一款。
- en: '*16-Bit Classical Era*'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*16位经典时代*'
- en: The first member of the x86 family proper—defined by modern backward compatibility—was
    Intel’s 16-bit, 5 MHz 8086 chip, made in 1978\. This was a CISC chip that used
    microprogramming. x86 is named after its last two digits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: x86家族的第一个成员——由现代向后兼容性定义——是英特尔于1978年推出的16位、5 MHz的8086芯片。这是一款采用微程序设计的CISC芯片。x86的名称来源于其最后两位数字。
- en: Competition between Intel and AMD became formalized in 1982 by a three-way contract
    between Intel, AMD, and IBM, whose business at the time was building computers.
    IBM wanted to buy CPUs for its computers but didn’t want to be locked into using
    a proprietary design from a single company, because such a company could then
    hold IBM to ransom via the lock-in and increase its prices. As a huge company,
    IBM had enough buying power to play suppliers against one another to get what
    it really wanted, which was for more than one company to compete to produce the
    same chips as generic commodities; this would push down the prices and enable
    IBM to get them cheap in perpetuity. IBM said to Intel, “We want to buy your chips,
    but we’ll buy them only if you sign this contract saying you’ll let AMD copy them.
    If you don’t sign, then we won’t buy from either of you.” The three companies
    agreed and thus created the famous Intel-AMD cross-license for both chipmakers
    to design and sell chips implementing the same x86 ISA.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔与AMD之间的竞争在1982年通过英特尔、AMD和IBM之间的三方合同正式化，当时IBM的业务是制造计算机。IBM希望购买用于其计算机的CPU，但不想被单一公司设计的专有技术锁定，因为这样一来，该公司可能通过锁定政策勒索IBM并提高价格。作为一个巨大的公司，IBM拥有足够的购买力来通过与供应商的博弈获取其真正想要的东西——让多家公司竞争生产相同的芯片作为通用商品；这将压低价格并使IBM能够长期以低价获得这些芯片。IBM对英特尔说：“我们想买你们的芯片，但只有在你签署这份合同，允许AMD复制它们的情况下我们才会购买。如果你不签署，我们就不从你们任何一方购买。”三家公司达成一致，最终创立了著名的英特尔-AMD交叉许可协议，允许两家公司设计和销售实现相同x86指令集架构（ISA）的芯片。
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a general lesson about computer economics: after a sale, the seller
    of a hardware or software platform can wield extreme power over the buyer via
    lock-in. Platform sellers should thus try to initially give away their platforms
    for free or at large discounts, to get users locked into them, before ramping
    up their sales terms once they have the buyer over a barrel. But before the buyer
    selects a platform, it’s the buyer who holds all the power and calls the shots.
    Thus, buyers should negotiate hard to formalize a contract that mitigates the
    seller’s power over them later. Once you hand over the money, you have no power
    except what was agreed in that contract.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是计算机经济学的一般教训：在销售之后，硬件或软件平台的卖方可以通过锁定效应对买方施加极大的控制力。因此，平台的卖方应在初期尽可能免费或大幅折扣地提供其平台，以便让用户锁定在平台上，然后再提高销售条件，一旦他们掌控了买方。但在买方选择平台之前，买方才是拥有所有权力并决定一切的人。因此，买方应当积极谈判，以形成一份合同，从而在以后减轻卖方对他们的控制力。一旦你付了钱，除了合同中约定的内容，你将不再拥有任何权力。*'
- en: The IBM deal propelled both chipmakers into the business computing market, enabling
    them to scale rapidly. After the deal, Intel updated the 8086 with its 80186 (1982;
    6 MHz), followed soon after by the 80286 (1982; 8 MHz), which added protected
    mode for OS support for the first time. AMD then quickly cloned the 80286 as its
    Am286 (1982; 8 MHz). These 16-bit devices were appearing in the early 1980s as
    high-end business machines, at the same time that the 8-bit golden age was arriving
    in homes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IBM的交易将两大芯片制造商推向了商务计算市场，使他们能够快速扩张。交易之后，英特尔用80186（1982年；6 MHz）更新了8086，随后推出了80286（1982年；8
    MHz），首次增加了操作系统支持的保护模式。AMD随后快速复制了80286，推出了Am286（1982年；8 MHz）。这些16位设备出现在1980年代初期，作为高端商务机器，与此同时，8位的黄金时代也在家庭中到来。
- en: '*32-Bit Clone Wars Era*'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*32位克隆战争时代*'
- en: The 32-bit era began with Intel’s 386 (1985; 16 MHz), which introduced the 32-bit
    instruction set x86 IA-32\. Throughout this era, we saw continual antagonism and
    legal action between the two big chipmakers; this was made more entertaining by
    the entry of additional competitors Cyrix and Via, who also made x86 clones. [Table
    13-1](ch13.xhtml#ch13tab1) summarizes these developments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 32位时代始于英特尔的386（1985年；16 MHz），它引入了32位指令集x86 IA-32。 在这一时代，两个主要芯片制造商之间的竞争和法律诉讼不断，这一过程在赛瑞克斯和威雅等额外竞争者加入后变得更具娱乐性，这些公司也生产x86兼容芯片。[表13-1](ch13.xhtml#ch13tab1)总结了这些发展。
- en: '**Table 13-1:** 32-Bit Era x86 Developments'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-1：** 32位时代x86发展'
- en: '| **Year** | **Maker** | **Architecture** | **Features** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **年份** | **制造商** | **架构** | **特性** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1985 | Intel | 386 | 16 MHz |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 1985 | 英特尔 | 386 | 16 MHz |'
- en: '| 1989 | Intel | 486 | 50 MHz, pipelined, FPU |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1989 | 英特尔 | 486 | 50 MHz, 流水线设计, FPU |'
- en: '| 1991 | AMD | Am386 | Clone of 386 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1991 | AMD | Am386 | 386的克隆 |'
- en: '| 1993 | Intel | Pentium | 75 MHz, superscalar |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 1993 | 英特尔 | Pentium | 75 MHz, 超标量 |'
- en: '| 1993 | AMD | Am486 | Clone of 486 (last clone) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1993 | AMD | Am486 | 486的克隆（最后一个克隆） |'
- en: '| 1995 | Intel | P5 | 150 MHz, MMX SIMD “Pentium MMX” |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 英特尔 | P5 | 150 MHz, MMX SIMD “Pentium MMX” |'
- en: '| 1995 | Intel | P6 (i686) | 200 MHz, SSE SIMD, OOOE, “Pentium Pro” |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 英特尔 | P6 (i686) | 200 MHz, SSE SIMD, OOOE, “Pentium Pro” |'
- en: '| 1996 | AMD | K5 | 133 MHz, Pentium-like |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1996 | AMD | K5 | 133 MHz, 类似Pentium |'
- en: '| 1995 | Cyrix | Cx5x86 | 140 MHz, Pentium-like |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1995 | 赛瑞克斯 | Cx5x86 | 140 MHz, 类似Pentium |'
- en: '| 1996 | Cyrix | 6x86 | 140 MHz, Pentium-like |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1996 |赛瑞克斯 | 6x86 | 140 MHz, 类似Pentium |'
- en: '| 1997 | AMD | K6 | 300 MHz, 3D-NOW, rival SIMD |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1997 | AMD | K6 | 300 MHz, 3D-NOW, 对抗SIMD |'
- en: '| 2001 | VIA | C3 | 500 MHz, Pentium-like |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 2001 | VIA | C3 | 500 MHz, 类似Pentium |'
- en: '| 2001 | AMD | Athlon | 2 GHz |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2001 | AMD | Athlon | 2 GHz |'
- en: Intel was usually the technical leader, creating new technologies such as pipelined
    designs and extension instructions, with the others copying a year or two later
    to bring the price down. At every step, clock speeds reliably got faster, following
    Moore’s law for clock speed. This was the “bland 1990s,” where customers assumed
    they would need to buy a new beige desktop computer every 18 months to keep up
    with doubling clock speeds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔通常是技术领导者，创造了诸如流水线设计和扩展指令等新技术，其他公司在一到两年后跟进以降低价格。在每个阶段，时钟速度都稳定地变得更快，遵循摩尔定律。这就是“乏味的1990年代”，当时客户认为他们需要每18个月购买一台新的米色台式电脑，以跟上时钟速度的翻倍。
- en: After the 486, Intel got sick of competitors copying the untrademarkable 86
    name, so they switched to the trademarkable brand name “Pentium.” This was the
    dominant chip for some time, but then AMD took the lead by becoming the first
    to reach 1 GHz speed with its Athlon in 2001.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在486处理器之后，英特尔厌倦了竞争对手复制无法注册商标的86名称，因此他们改用了可注册商标的品牌名称“奔腾”。这一芯片在一段时间内占据主导地位，但后来AMD通过其Athlon处理器在2001年率先达到了1
    GHz的速度，取得了领先。
- en: '*64-Bit Branding Era*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*64位品牌化时代*'
- en: 'The 64-bit era of x86 arrived in 2000 when AMD formally defined the amd64 ISA,
    which was adopted by most CISC processors following it. This was a coup: the x86
    ISA family had previously always been defined by Intel, with others pegging their
    own products to them.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: x86的64位时代在2000年到来，当时AMD正式定义了amd64 ISA，随后大多数CISC处理器都采用了这一架构。这是一场革命：x86 ISA家族之前一直由英特尔定义，其他厂商只能将自己的产品与其挂钩。
- en: Intel attempted to define its own failed 64-bit competitor ISA, called IA-64,
    but this was released after amd64 and never caught on; today, everyone uses amd64\.
    Intel, however, refuses to acknowledge the name amd64, instead referring to the
    same ISA as x86_64\. Confusingly, you’ll see both names used to describe executable
    software downloads for this ISA, such as in the names of Linux distribution packages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔曾试图定义自己失败的64位竞争对手指令集架构（ISA），名为IA-64，但该架构在amd64发布之后才面世，并未获得广泛认可；如今，大家都使用amd64。然而，英特尔拒绝承认amd64这一名称，而是称其为x86_64。令人困惑的是，你会看到这两个名称都被用来描述该ISA的软件执行文件下载，比如在Linux发行版的软件包名称中。
- en: The 64-bit era is characterized by a separation of marketing terms from the
    underlying technologies, with the same marketing brand often used to label completely
    different architectures. Unlike the previous 32-bit Pentium, the branding is no
    longer attached to specific designs. You’re probably used to seeing 64-bit products
    with brands like Pentium, Celeron, and Xeon. You may also see the numbers 3, 5,
    7, and 9 in brand names, as in Core i3, Core i5, and so on. For Intel, these numbers
    don’t mean anything other than suggesting an ordering of which products are better;
    AMD uses the same numbers to suggest which products are similar to Intel’s.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 64位时代的特点是市场营销术语与基础技术的分离，同一市场品牌常常用来标示完全不同的架构。与之前的32位奔腾处理器不同，品牌名称不再与特定的设计相联系。你可能已经习惯看到像奔腾、赛扬和至强这样的64位产品品牌。你也可能会在品牌名称中看到数字3、5、7和9，如Core
    i3、Core i5等。对于英特尔来说，这些数字除了暗示哪些产品更好之外，并没有其他意义；而AMD则用相同的数字来暗示哪些产品与英特尔的产品类似。
- en: '[Table 13-2](ch13.xhtml#ch13tab2) shows examples of Intel and AMD releases
    and some of their notable features during the 64-bit era.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格13-2](ch13.xhtml#ch13tab2)展示了英特尔和AMD发布的一些例子及其在64位时代的显著特点。'
- en: Pipelines have varied between around 14 and 20 stages during this period, and
    OOOE has been used throughout. AMD Piledriver was the first to introduce neural
    network–based branch prediction hardware.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一时期，管道阶段数通常在14到20之间，并且始终使用了超标量执行（OOOE）。AMD的Piledriver架构首次引入了基于神经网络的分支预测硬件。
- en: Clock speeds hit 3.5 GHz around the start of the 64-bit era and have been stuck
    there ever since, due to the end of Moore’s law for clock speed. However, Moore’s
    law for transistor size continued to hold, and it became common to define machines
    by their transistor scale, in nanometers (nm) per transistor, rather than their
    clock speed, to show the continued progress. Between 2006 and 2016, Intel used
    a “tick-tock” cycle, in which their new products alternated between new digital
    logic designs (tock) and the use of new transistor technologies to make the same
    design smaller and faster (tick). *Boosts* are a feature first added in Nehalem,
    which *temporarily* increase the clock speed beyond the usual 3.5 GHz heat limit
    for short periods of time at the bottlenecks of intensive computations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟频率在64位时代初期达到了3.5 GHz，并且自此停滞不前，这是由于摩尔定律对时钟频率的限制。然而，摩尔定律在晶体管大小上的影响仍然存在，并且通常通过晶体管的尺度（单位：纳米）来定义机器，而不是通过时钟频率，以展示技术的持续进步。在2006年到2016年期间，英特尔采用了“tick-tock”周期，在此周期中，他们的新产品交替采用新的数字逻辑设计（tock）和采用新的晶体管技术使相同设计更小更快（tick）。*Boost*是Nehalem架构首次引入的功能，它能在高负载计算的瓶颈处*暂时*提升时钟频率，超越通常的3.5
    GHz热限制，持续短时间。
- en: '**Table 13-2:** 64-Bit Era x86 Developments'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格13-2：** 64位时代x86发展历程'
- en: '| **Year** | **Maker** | **Architecture** | **Transistor size (nm)** | **Branding**
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **年份** | **制造商** | **架构** | **晶体管大小（nm）** | **品牌** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 2003 | AMD | Hammer (K8) | 130 | Opteron |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 2003 | AMD | Hammer (K8) | 130 | Opteron |'
- en: '| 2005 | AMD | Hammer (K8) | 90 | Athlon 64 X2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 2005 | AMD | Hammer (K8) | 90 | Athlon 64 X2 |'
- en: '| 2006 | Intel | Core | 65 | Celeron/Pentium/Xeon |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 2006 | Intel | Core | 65 | Celeron/Pentium/Xeon |'
- en: '| 2007 | AMD | 10h (K10) | 65 | Opteron |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 2007 | AMD | 10h (K10) | 65 | Opteron |'
- en: '| 2008 | Intel | Nehalem | 45 | Pentium, Xeon, Core (1st generation) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 2008 | Intel | Nehalem | 45 | Pentium, Xeon, Core（第一代） |'
- en: '| 2011 | Intel | Sandy Bridge | 32 | 2nd-generation Core i3/i5/i9; Xeon |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 2011 | Intel | Sandy Bridge | 32 | 第二代 Core i3/i5/i9；Xeon |'
- en: '| 2012 | AMD | Piledriver | 32 | Opteron |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 2012 | AMD | Piledriver | 32 | Opteron |'
- en: '| 2013 | Intel | Haswell | 22 | 4th-generation Core i3/5/7; Celeron/Pentium/Xeon
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2013 | Intel | Haswell | 22 | 第四代 Core i3/5/7；Celeron/Pentium/Xeon |'
- en: '| 2015 | Intel | Skylake | 14 | 6th-generation Core i3/5/7; Celeron/Pentium/Xeon;
    CoreM |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 2015 | Intel | Skylake | 14 | 第六代 Core i3/5/7；Celeron/Pentium/Xeon；CoreM
    |'
- en: '| 2017 | Intel | Coffee Lake | 14 | 8th-generation Core i3/5/7; Celeron/Pentium
    Gold/Xeon |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 2017 | Intel | Coffee Lake | 14 | 第八代 Core i3/5/7；Celeron/Pentium Gold/Xeon
    |'
- en: '| 2017 | AMD | Zen | 14 | Ryzen 3/5/7 1000 series |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2017 | AMD | Zen | 14 | Ryzen 3/5/7 1000 系列 |'
- en: '| 2018 | AMD | Zen+ | 12 | Ryzen 3/5/7 2000 series |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2018 | AMD | Zen+ | 12 | Ryzen 3/5/7 2000 系列 |'
- en: '| 2019 | AMD | Zen2 | 7 | Ryzen 3/5/7 3000 series |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 2019 | AMD | Zen2 | 7 | Ryzen 3/5/7 3000 系列 |'
- en: '| 2020 | AMD | Zen3 | 7 | Ryzen 5/7/9 5000 series |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 2020 | AMD | Zen3 | 7 | Ryzen 5/7/9 5000 系列 |'
- en: '| 2021 | Intel | Cypress Cove | 14 | 11th-generation Core i5/7/9; Xeon |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | Intel | Cypress Cove | 14 | 第十一代 Core i5/7/9；Xeon |'
- en: '| 2021 | Intel | Golden Cove | 7 | 12th-generation Core i5/7/9; Xeon |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2021 | Intel | Golden Cove | 7 | 第十二代 Core i5/7/9；Xeon |'
- en: '| 2022 | AMD | Zen4 | 5 | Ryzen 5/7/9 7000 series |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 2022 | AMD | Zen4 | 5 | Ryzen 5/7/9 7000 系列 |'
- en: Now that we’ve seen how x86 evolved, let’s look at its instruction set and learn
    how to program it. This will be a messier experience than for the other architectures
    we’ve studied, but hopefully, by understanding the history, you can at least understand
    why things ended up this way.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 x86 的演变过程，接下来让我们看看它的指令集，并学习如何编程。这将是一个比我们之前研究过的其他架构更为复杂的过程，但希望通过了解历史，你至少可以明白为什么事情会发展成现在这个样子。
- en: Programming x86
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程 x86
- en: x86 is big and ugly; its code is usually generated by compilers rather than
    written by hand. Still, it’s worth your time to study it if you want to better
    understand what your compiler and computer are doing, or if you want to write
    compilers or other system software such as operating systems and bootloaders.
    Because x86 is such a widely used architecture, understanding it is also useful
    in security applications, such as cracking and defending code, including cheat
    and anti-cheat systems for games.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: x86 架构庞大且复杂，它的代码通常是由编译器生成，而不是手工编写的。不过，如果你想更好地理解你的编译器和计算机是如何工作的，或者如果你想编写编译器或其他系统软件，比如操作系统和引导程序，那么学习
    x86 仍然值得花时间。因为 x86 是一种广泛使用的架构，理解它在安全应用中也很有用，例如破解和防护代码，包括游戏的作弊和反作弊系统。
- en: 'As a CISC architecture, x86 often has many variations of each instruction,
    taking different types of operand, such as constants, registers, and memory locations.
    Groups of instructions have been added at different points in the architecture’s
    history, and they don’t always use the same conventions: for example, integer
    addition, integer multiplication, and floating-point operations all present very
    different interfaces to the programmer. You wouldn’t design a new CPU from scratch
    using such different interfaces; this mess is simply how the architecture has
    grown over time.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种 CISC 架构，x86 通常会有多种不同的指令变体，它们接受不同类型的操作数，如常量、寄存器和内存位置。不同时间点添加了不同的指令组，这些指令组并不总是遵循相同的约定：例如，整数加法、整数乘法和浮点操作向程序员呈现的接口差异很大。你不会从零开始设计一个使用如此不同接口的
    CPU；这种混乱正是架构随着时间发展所带来的结果。
- en: This won’t be an exhaustive tour of x86 features. Rather, we’ll look at a couple
    of examples to give a flavor of how CISC extensions are created and how they operate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会是一次详尽的 x86 特性之旅。相反，我们将通过几个例子，展示 CISC 扩展是如何创建的，以及它们是如何运作的。
- en: '*Registers*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寄存器*'
- en: Because of the way x86 has evolved over time and its requirement for backward
    compatibility, its register set has grown into a particular form. There are two
    general types of register; let’s look at each.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 随着时间的演变以及其对向后兼容性的需求，它的寄存器集已经发展成一种特定的形式。寄存器大体上分为两类，我们来看看每一类。
- en: '**General-Purpose Registers**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通用寄存器**'
- en: There are eight general-purpose user registers in x86 architecture. Their names
    reflect their traditional uses. [Table 13-3](ch13.xhtml#ch13tab3) shows them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86 架构中有八个通用用户寄存器。它们的名称反映了它们的传统用途。[表 13-3](ch13.xhtml#ch13tab3) 显示了这些寄存器。
- en: '**Table 13-3:** x86 General-Purpose Registers'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-3:** x86 通用寄存器'
- en: '| **Register** | **Meaning** | **Use** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **含义** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AX | Accumulator register | Arithmetic operations |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| AX | 累加寄存器 | 算术运算 |'
- en: '| BX | Base register | A pointer to data |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| BX | 基址寄存器 | 指向数据的指针 |'
- en: '| CX | Counter register | Shift, rotate, and loop instructions |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| CX | 计数寄存器 | 移位、旋转和循环指令 |'
- en: '| DX | Data register | Arithmetic and I/O operations |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| DX | 数据寄存器 | 算术运算和 I/O 操作 |'
- en: '| SP | Stack pointer register | A pointer to the top of the stack |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| SP | 栈指针寄存器 | 指向栈顶的指针 |'
- en: '| BP | Stack base pointer register | A pointer to the base of the stack |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| BP | 栈基指针寄存器 | 指向栈底的指针 |'
- en: '| SI | Source index register | A pointer to a source for data copies |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| SI | 源索引寄存器 | 指向数据复制的源 |'
- en: '| DI | Destination index register | A pointer to a destination for data copies
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| DI | 目标索引寄存器 | 指向数据复制的目标 |'
- en: In the original 16-bit 8086, the general-purpose registers all had 16 bits.
    To retain partial backward compatibility with the previous 8-bit 8080, the first
    four—AX, BX, CX, and DX—can also be split into two 8-bit registers, named with
    H and L for high and low bytes, which can be accessed independently.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 16 位 8086 中，通用寄存器都具有 16 位。为了与之前的 8 位 8080 保持部分向后兼容，前四个寄存器—AX、BX、CX 和 DX—也可以拆分成两个
    8 位寄存器，分别命名为 H 和 L，代表高字节和低字节，可以独立访问。
- en: 'IA-32 extended the eight registers to have 32-bits. They can still be accessed
    as 16- or 8-bit registers as before, to maintain compatibility. To access them
    in their full 32-bit mode, we add the prefix E (for *extended*) to their names:
    EAX, EBX, ECX, and so on.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: IA-32 将这八个寄存器扩展为 32 位。为了保持兼容性，它们仍然可以像以前一样以 16 位或 8 位寄存器的形式访问。要以完整的 32 位模式访问它们，我们在它们的名字前加上前缀
    E（表示*扩展*）：EAX、EBX、ECX 等。
- en: 'amd64 extended the eight registers again, to 64 bits. As before, the 32-, 16-,
    and 8-bit versions are left intact for compatibility. To access them in 64-bit
    mode, we add the prefix R to their names: RAX, RBX, RCX, and so on. amd64 also
    added eight more 64-bit general-purpose registers, named R8 through R15.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: amd64 再次扩展了这八个寄存器，至 64 位。与之前一样，32 位、16 位和 8 位版本保持不变以保持兼容性。要以 64 位模式访问它们，我们在它们的名字前加上前缀
    R：RAX、RBX、RCX 等。amd64 还增加了八个额外的 64 位通用寄存器，命名为 R8 到 R15。
- en: As x86 is defined as the family based on the 16-bit system, and has to retain
    backward compatibility, a *word* in x86 speak still means 16 bits of data, rather
    than the full size of the modern registers. *Doubleword* or *dword* means 32 bits,
    and *quadword* or *qword* means 64 bits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 被定义为基于 16 位系统的架构，并且需要保持向后兼容，因此在 x86 中，*字* 仍然表示 16 位数据，而不是现代寄存器的完整大小。*双字*
    或 *dword* 表示 32 位，*四字* 或 *qword* 表示 64 位。
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) summarizes the evolution of the general-purpose
    x86 registers.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch13fig1) 总结了通用 x86 寄存器的发展历程。'
- en: '![Image](../images/f0310-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0310-01.jpg)'
- en: '*Figure 13-1: The x86 registers. Register names are shown to the left of each
    register, apart from 8-bit register names, which are shown in the center of the
    register.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：x86 寄存器。寄存器名称显示在每个寄存器的左侧，8 位寄存器名称显示在寄存器的中央。*'
- en: For compatibility with these different word sizes, memory addressing is always
    done *per byte*, even on a modern amd64\. This is in contrast to addressing, say,
    non-overlapping 64-bit *words* of memory. Words are stored in memory as little-endian
    bytes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容不同的字长，内存寻址始终是*按字节*进行的，即使在现代的 amd64 上也是如此。这与寻址 64 位 *字*（不重叠）的内存有所不同。字以小端字节的方式存储在内存中。
- en: '**Internal Registers**'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内部寄存器**'
- en: The program counter is called the *instruction pointer* in x86 speak, identified
    as IP, EIP, or RIP when used in its 16-, 32-, or 64-bit form, respectively.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计数器在 x86 中称为 *指令指针*，在使用其 16 位、32 位或 64 位形式时，分别标识为 IP、EIP 或 RIP。
- en: The status register is called FLAGS, EFLAGS, or RFLAGS, again when used in 16-,
    32-, or 64-bit form. Its structure is shown in [Figure 13-2](ch13.xhtml#ch13fig2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 状态寄存器称为 FLAGS、EFLAGS 或 RFLAGS，取决于其使用的 16 位、32 位或 64 位形式。其结构见 [图 13-2](ch13.xhtml#ch13fig2)。
- en: '![Image](../images/f0310-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0310-02.jpg)'
- en: '*Figure 13-2: The x86 status register (compare with [Figure 11-6](ch11.xhtml#ch11fig6))*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：x86 状态寄存器（与 [图 11-6](ch11.xhtml#ch11fig6) 比较）*'
- en: This is very like the 6502’s status register, with similar mnemonics. As with
    the 6502, these flags are set with comparison instructions, then consulted with
    separate branch instructions. There are also instructions to clear flags. Two
    important flags, as in other architectures, are the zero flag (ZF) and sign flag
    (SF).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 6502 的状态寄存器非常相似，且具有类似的助记符。与 6502 一样，这些标志通过比较指令设置，然后通过单独的分支指令进行查询。也有指令用来清除标志。两个重要的标志，像其他架构一样，是零标志（ZF）和符号标志（SF）。
- en: '*Netwide Assembler Syntax*'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Netwide Assembler 语法*'
- en: Because of its long history, x86 has acquired several different assembly languages
    with different syntaxes, which all assemble into the same machine code. Here we’ll
    use the *Netwide Assembler (NASM)* style, which is the least worst of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其悠久的历史，x86 形成了几种不同的汇编语言和语法，它们都能汇编成相同的机器代码。在这里，我们将使用 *Netwide Assembler (NASM)*
    风格，它是最不糟糕的一种。
- en: x86 instructions usually have two operands. In NASM syntax, the first is usually
    the destination and sometimes also an input that gets updated to store the result,
    like an accumulator; the second operand is an input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: x86 指令通常有两个操作数。在 NASM 语法中，第一个通常是目标操作数，有时也作为输入操作数来更新以存储结果，就像一个累加器；第二个操作数是输入操作数。
- en: 'Like most assemblers, NASM enables us to label lines of a program with text
    labels by inserting the label as text, followed by a colon, like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数汇编语言一样，NASM 允许我们通过插入文本标签并加上冒号来为程序的每一行标记文本标签，像这样：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a label is inserted on line 5, we can jump to or load from line 5 by using
    its label name rather than the number 5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在第 5 行插入一个标签，我们可以通过使用其标签名称而不是数字 5 来跳转到或从第 5 行加载数据。
- en: '**Data Movement**'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据移动**'
- en: To copy constants or register contents between registers and RAM, you can use
    the same `mov` (move) instruction. This generalizes all of loading, storing, and
    moving. Several different addressing modes are provided.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在寄存器和 RAM 之间复制常量或寄存器内容，可以使用相同的 `mov`（移动）指令。这将加载、存储和移动的操作统一化。提供了几种不同的寻址模式。
- en: '*Immediate addressing* places constants into registers. For example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*立即寻址*将常量放入寄存器。例如：'
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Register addressing* copies data from one register to another inside the CPU,
    such as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器寻址*将数据从一个寄存器复制到另一个寄存器内部，例如：'
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Direct addressing* loads from and stores to memory through a specified address.
    Labels can be used in place of numerical addresses, in which context they’re known
    as *variables*. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接寻址*通过指定的地址从内存加载或存储数据。可以使用标签代替数字地址，在这种情况下它们被称为 *变量*。例如：'
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Register indirect addressing* is notated using square brackets, such as:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器间接寻址*使用方括号表示，例如：'
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In these two instructions, RDI is assumed to contain an address that in turn
    is used to load or store the value from RAX.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条指令中，假设 RDI 包含一个地址，该地址被用来加载或存储来自 RAX 的值。
- en: '**Data Creation**'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据创建**'
- en: 'Data locations in RAM can be given names, and can be initialized or uninitialized.
    To initialize a location with a value and create a name for it, we use commands
    beginning with `d`, for *define*. For example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: RAM 中的数据位置可以被赋予名称，并且可以是初始化或未初始化的。为了用一个值初始化一个位置并为其创建一个名称，我们使用以 `d` 开头的命令，表示 *定义*。例如：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To name an uninitialized location, we use commands beginning with `r`, for
    *reserve*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了命名一个未初始化的位置，我们使用以 `r` 开头的命令，表示 *保留*：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that these aren’t x86 instructions, but rather just labeled regions of
    data, with the directives telling NASM to treat them as such.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些不是 x86 指令，而只是数据的标记区域，指令告诉 NASM 将它们视为数据区域。
- en: 'To create arrays, we simply allocate a set of consecutive addresses. For example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数组，我们只需分配一组连续的地址。例如：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'NASM also provides macro directives, which enable you to define numeric `(equ)`
    and string `(%define)` constants:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: NASM 还提供宏指令，允许你定义数值 `(equ)` 和字符串 `(%define)` 常量：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: NASM substitutes for these constants’ values before doing the assembly. These
    macro directives aren’t part of the x86 instructions set, but NASM provides them
    for convenience.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编之前，NASM 会替换这些常量的值。这些宏指令不是 x86 指令集的一部分，但 NASM 提供它们以方便使用。
- en: '**Arithmetic and Logic**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术和逻辑**'
- en: 'As x86 instructions are usually designed to take two arguments, most arithmetic
    is done accumulator-style. There isn’t a single accumulator register, but any
    register can act like one. For example, here we place the value 1 into RBX and
    add 2 into it, so it ends up storing the result, 3:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 指令通常设计为接受两个参数，因此大多数算术操作是以累加器风格进行的。虽然没有单一的累加器寄存器，但任何寄存器都可以充当累加器。例如，在这里我们将值
    1 放入 RBX 中，并将 2 加到其中，因此最终它存储了结果 3：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a CISC architecture, variations of arithmetic instructions usually exist
    that combine loading data from memory with the arithmetic. For example, here’s
    how to add two numbers from addresses 1000h and 2000h and put the result in RBX:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种 CISC 架构，算术指令通常有变种，将从内存加载数据与算术操作结合。例如，下面是如何将地址 1000h 和 2000h 中的两个数字相加，并将结果放入
    RBX 寄存器：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that x86 *doesn’t* include the most extreme CISC style of addition, such
    as `[3000h] := [1000h]+[2000h]`, which combines two loads, one addition, and one
    store in a single instruction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，x86 *不*包括最极端的 CISC 风格加法，例如 `[3000h] := [1000h]+[2000h]`，它将两个加载、一次加法和一次存储结合在一个指令中。
- en: 'Subtraction works similarly to addition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 减法的工作方式与加法相似：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Incrementing and decrementing 8-, 16-, or 32-bit operands can be done using
    the `inc` and `dec` instructions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `inc` 和 `dec` 指令对 8 位、16 位或 32 位操作数进行增量和减量：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To multiply or divide integer operands, x86 provides `mul` and `div` instructions.
    Unlike addition and subtraction, these always use the A register as the accumulator
    (hence its name) and act on it with the operand given to the instruction. For
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要对整数操作数进行乘法或除法，x86 提供了 `mul` 和 `div` 指令。与加法和减法不同，这些指令始终使用 A 寄存器作为累加器（因此得名），并作用于给定指令的操作数。例如：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the last of the above examples, the prefix `i` is added to the `div` instruction
    to indicate that signed integers are used. The `cwd` instruction converts a word
    to a double by allowing the DX register to be used as an extension of AX in order
    to accommodate the sign information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述最后一个示例中，`div` 指令前缀加上了 `i`，表示使用的是有符号整数。`cwd` 指令通过允许 DX 寄存器作为 AX 的扩展来转换字为双字，以容纳符号信息。
- en: 'Bitwise logic instructions include `and, or, not`, and `xor`. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 按位逻辑指令包括 `and`、`or`、`not` 和 `xor`。例如：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with addition, the first operand acts as an accumulator so gets overwritten
    with the result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法相同，第一个操作数充当累加器，因此会被结果覆盖。
- en: '**Flow Control**'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**流程控制**'
- en: 'NASM provides two types of labels, symbolic and numeric, that can both be used
    for jumps and branches. Symbolic labels consist of an identifier followed by a
    colon (:). They must be defined only once, as they have global scope. If the label
    identifier begins with a period (.), it’s considered local and can be used only
    in the current file. Here’s an infinite loop using a symbolic label and a jump:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: NASM 提供了两种类型的标签：符号标签和数字标签，两者都可以用于跳转和分支。符号标签由一个标识符后跟冒号（:）组成。它们必须仅定义一次，因为它们具有全局作用域。如果标签标识符以句点（.）开头，则被视为局部标签，仅在当前文件中使用。以下是使用符号标签和跳转的无限循环示例：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Numeric labels consist of a single digit in the range 0 to 9 followed by a
    colon. Numeric labels are considered local. They also have limited scope so can
    be redefined repeatedly. When a numeric label is used as a reference (as an instruction
    operand, for example), the suffixes `b` (for backward) or `f` (for forward) should
    be added to the numeric label. For numeric label `1`, the reference `1b` refers
    to the nearest label `1` defined before the reference, and the reference `1f`
    refers to the nearest label `1` defined after the reference. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数字标签由一个 0 到 9 范围内的单个数字后跟冒号组成。数字标签被视为局部标签。它们也有有限的作用域，因此可以反复重新定义。当数字标签用作引用（例如作为指令的操作数）时，应在数字标签后添加后缀
    `b`（向后）或 `f`（向前）。例如，对于数字标签 `1`，引用 `1b` 指的是定义在引用之前的最近标签 `1`，而引用 `1f` 指的是定义在引用之后的最近标签
    `1`。例如：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conditional jumps are performed using pairs of instructions. First, we use the
    `cmp` instruction to compare two values. It takes two operands to compare and
    raises appropriate flags in the status register. Next, a conditional jump instruction
    consults the status register to determine whether or not to make the jump. Some
    of the available conditional jump types are listed in [Table 13-4](ch13.xhtml#ch13tab4).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转是通过指令对来执行的。首先，我们使用 `cmp` 指令比较两个值。它需要两个操作数来比较，并在状态寄存器中设置适当的标志。接下来，条件跳转指令会检查状态寄存器，以决定是否执行跳转。某些可用的条件跳转类型列出了[表
    13-4](ch13.xhtml#ch13tab4)。
- en: '**Table 13-4:** x86 Conditional Jump Instructions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-4:** x86 条件跳转指令'
- en: '| **Instruction** | **Condition** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **条件** |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `je` | Jump if `cmp` is equal |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果 `cmp` 相等则跳转 |'
- en: '| `jne` | Jump if `cmp` is not equal |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果 `cmp` 不相等则跳转 |'
- en: '| `jg` | Signed > (greater) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `jg` | 有符号 >（大于）|'
- en: '| `jge` | Signed >= |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `jge` | 有符号 >= |'
- en: '| `jl` | Signed < (less than) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `jl` | 有符号 <（小于）|'
- en: '| `jle` | Signed <= |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `jle` | 有符号 <= |'
- en: '| `ja` | Unsigned > (above) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `ja` | 无符号 >（以上）|'
- en: '| `jae` | Unsigned >= |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `jae` | 无符号大于等于 |'
- en: '| `jb` | Unsigned < (below) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `jb` | 无符号小于（以下） |'
- en: '| `jbe` | Unsigned <= |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `jbe` | 无符号小于等于 |'
- en: '| `jc` | Jump if carry (used for unsigned overflow or multi-precision add)
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `jc` | 如果进位则跳转（用于无符号溢出或多精度加法） |'
- en: '| `jo` | Jump if there was signed overflow |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `jo` | 如果发生带符号溢出则跳转 |'
- en: 'To illustrate, this program uses the `cmp` and `je` instructions to make a
    jump if the compared values are equal:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，程序使用`cmp`和`je`指令在比较的值相等时进行跳转：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Subroutines are called and returned from as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序的调用和返回方式如下：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `call` instruction jumps to the subroutine with the given label, and `ret`
    returns from the subroutine to the calling location.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`指令跳转到带有指定标签的子程序，`ret`则从子程序返回到调用位置。'
- en: '**The Stack**'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**堆栈**'
- en: 'Subroutine calls and returns are implemented internally using a stack. If you’re
    just writing simple calls and returns, as in the example we just looked at, you
    don’t need to see or think about the stack yourself. However, x86 also allows
    you to access the stack directly to pass arguments or for other purposes. Specifically,
    registers SS and ESP (or SP) are provided and used for implementing the stack.
    The stack is limited to storing only words and doublewords. Here’s how it works:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序的调用和返回是通过堆栈内部实现的。如果你只是写简单的调用和返回，如我们刚才看到的例子，你不需要自己处理堆栈。然而，x86也允许你直接访问堆栈来传递参数或用于其他目的。具体来说，寄存器SS和ESP（或SP）被提供并用于实现堆栈。堆栈仅限于存储字和双字。其工作方式如下：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the contents of registers AX and BX are pushed to the stack, meaning these
    registers can then be overwritten and used for other purposes, before being restored
    by the pop instructions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，寄存器AX和BX的内容被推入堆栈，这意味着这些寄存器可以被覆盖并用于其他目的，之后再通过pop指令恢复。
- en: '**X86 CALLING CONVENTIONS**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**X86 调用约定**'
- en: The x86 architecture has been used with many different calling conventions during
    its history. Due to the small number of architectural registers, and a historical
    focus on simplicity and small code size, many x86 calling conventions pass arguments
    on the stack. The return value (or a pointer to it) is returned in a register.
    Some conventions use registers for the first few parameters, which may improve
    performance, especially for short and simple *leaf routines* that are very frequently
    invoked (these are routines that don’t call other routines).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构在其历史上曾使用过许多不同的调用约定。由于架构寄存器数量较少，并且历史上注重简化和小的代码体积，许多x86调用约定将参数通过堆栈传递。返回值（或指向它的指针）通过寄存器返回。一些约定使用寄存器传递前几个参数，这可能提升性能，尤其是对于那些非常频繁调用的短小简单的*叶子例程*（即不调用其他例程的例程）。
- en: For amd64, there are two current conventions in widespread use, one suggested
    by System V UNIX designers and the other by Microsoft. They agree that the caller
    rather than callee should clean up the stack. They both require the first few
    arguments to be passed in registers, with the later arguments on the stack, right
    to left, though they disagree on how many and which registers to use. They disagree
    on which registers are *temporary*—that is, which can be overwritten by the callee
    during a function call. This is in contrast to those that are *safe*, guaranteed
    to not be changed by function calls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于amd64，有两种目前广泛使用的调用约定，一种由System V UNIX设计者提出，另一种由微软提出。它们一致认为，堆栈清理应该由调用者而非被调用者负责。它们都要求将前几个参数通过寄存器传递，其余的参数则通过堆栈从右到左传递，尽管它们在使用哪些寄存器以及多少个寄存器上存在分歧。它们在哪些寄存器是*临时的*（即可以被被调用者在函数调用过程中覆盖）上存在分歧。这与那些被认为是*安全的*寄存器相对立，后者在函数调用过程中保证不会被更改。
- en: '**BIOS I/O**'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**BIOS 输入输出**'
- en: 'We can call BIOS routines from ROM to communicate with the screen and keyboard,
    as on a retro computer. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从ROM调用BIOS例程与屏幕和键盘进行通信，就像在复古计算机上一样。例如：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This sets a screen mode, prints an ASCII character to a location on the screen,
    reads an ASCII character from the keyboard, and sets a pixel color. These are
    all the basic ingredients you need to make 8 bit–style video games. The `int`
    instructions here generate interrupt requests, which pass control to the BIOS,
    and their operands tell the BIOS which of its subroutines is to be run. These
    subroutines each assume that their arguments have been placed into particular
    registers such as AH and AL before the interrupt is made.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个屏幕模式，将一个 ASCII 字符打印到屏幕的某个位置，从键盘读取一个 ASCII 字符，并设置像素颜色。这些都是制作 8 位风格视频游戏所需的基本要素。这里的
    `int` 指令生成中断请求，传递控制权给 BIOS，操作数告诉 BIOS 运行它的哪一个子程序。这些子程序假设在中断发生前，相关的参数已被放入特定的寄存器，如
    AH 和 AL。
- en: '**Floating Point**'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**浮点数**'
- en: The x86 floating-point architecture derives from the 8086’s old coprocessor,
    the 8087\. This was a separate, optional chip for accelerating numerical computation.
    Since the 486, the FPU moved into the main x86 architecture, where it has become
    known as the *x87 extension*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: x86 浮点架构源自 8086 的旧协处理器 8087。8087 是一个单独的可选芯片，用于加速数值计算。从 486 开始，FPU 被集成到主 x86
    架构中，并且被称为 *x87 扩展*。
- en: The x87 extension adds dedicated floating-point registers called ST0 to ST7,
    which are used as a stack (hence the prefix *ST*); the stack has a maximum of
    eight elements, with ST0 being the top. New floating-point instructions start
    with the letter `F` and move data to and from this stack; they instruct the FPU
    to perform arithmetic using the top items of the stack.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: x87 扩展增加了专用的浮点寄存器，称为 ST0 到 ST7，它们作为栈使用（因此前缀为 *ST*）；该栈最多可以有八个元素，ST0 是栈顶。新的浮点指令以字母
    `F` 开头，并将数据移动到栈中或从栈中移出；它们指示 FPU 使用栈顶的元素进行算术运算。
- en: 'You can push floats to the x87 stack, call arithmetic on them, and pop the
    result back, such as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将浮点数推送到 x87 栈中，对它们进行算术运算，然后将结果弹出，示例如下：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, when you give an ASCII representation of a float to NASM for any of the
    word lengths used, NASM knows to convert it to IEEE binary representation for
    you.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当你将一个浮点数的 ASCII 表示传递给 NASM 时，NASM 会知道将其转换为 IEEE 二进制表示。
- en: '*Segmentation*'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分段*'
- en: x86 programs can be written as collections of *segments*, which are separate
    chunks of a program that can be stored in different locations in memory. For example,
    if you wish to keep your instructions apart from your data (as in a Harvard architecture),
    you can do this by using a separate code segment and data segment. A stack segment
    can also be used to keep the hardware stack data separate from both. Segments
    all live in the same global address space, but by storing the start address of
    each segment in a dedicated register, addresses within them can afterward be referred
    to by just their offset from the segment start. This system was intended as a
    way for 16-bit CPUs to work with more than 64 k[2]B of RAM. It still exists but
    isn’t used much in modern 64-bit x86, because the 64-bit address space is so large
    anyway. Six *segment registers*, called CS, SS, DS, ES, FS, and GS, are specified
    to hold the segment start addresses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: x86 程序可以被写成多个 *段* 的集合，这些段是程序的独立部分，可以存储在内存的不同位置。例如，如果你希望将指令与数据分开存储（就像哈佛架构一样），你可以使用一个单独的代码段和数据段。还可以使用堆栈段，将硬件堆栈数据与其他数据分开存储。所有段都位于相同的全局地址空间中，但通过将每个段的起始地址存储在专用寄存器中，可以仅通过段的偏移量来引用其中的地址。该系统旨在使
    16 位 CPU 能够处理超过 64 KB 的内存。它仍然存在，但在现代 64 位 x86 中使用得不多，因为 64 位地址空间已经非常大。六个 *段寄存器*，即
    CS、SS、DS、ES、FS 和 GS，被指定用来保存段的起始地址。
- en: If you’re using the segment system, the NASM directive `section` specifies code
    and data segments. In some settings, some assemblers will still look for sections
    and assume that `section .text` is read-only and that `section .data` is read-write,
    even though the concepts are no longer used at the amd64 hardware level. A *segmentation
    fault* will occur if you try to access a segment that the assembler doesn’t want
    you to access.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用段系统，NASM 指令 `section` 用于指定代码段和数据段。在某些设置中，一些汇编器仍然会查找段并假设 `section .text`
    是只读的，而 `section .data` 是读写的，尽管这些概念在 amd64 硬件层面已经不再使用。如果你尝试访问汇编器不希望你访问的段，将会发生 *段错误*。
- en: '*Backward-Compatible Modes*'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*向后兼容模式*'
- en: Part of the x86 standard is that all CPUs have to be backward-compatible with
    the original 16-bit 8086\. This means that when they first power on, they have
    to start in 16-bit mode and behave exactly like an 8086.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: x86标准的一部分是所有CPU必须向后兼容最初的16位8086处理器。这意味着当它们首次启动时，必须以16位模式启动，并且行为必须完全像8086处理器。
- en: From there, 32-bit x86s have instructions that switch them into 32-bit mode,
    and 64-bit x86s have further instructions to switch from 32-bit to 64-bit mode.
    To boot an amd64, you therefore progressively switch up into 32- and then 64-bit
    mode, replaying the history of its architecture in a fraction of a second.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，32位x86处理器有指令可以将其切换到32位模式，而64位x86处理器则有进一步的指令可以将32位模式切换到64位模式。因此，要启动amd64处理器，你需要逐步切换到32位，然后是64位模式，在几分之一秒内重现其架构的历史。
- en: Now that we have an understanding of the x86 architecture, let’s zoom out to
    consider the PC computer design that uses it as the CPU component.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了x86架构，让我们放眼整个PC计算机设计，看看它如何将x86作为CPU组件。
- en: PC Computer Design
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PC计算机设计
- en: 'The desktop PC is a different concept from the other computers we’ve studied:
    rather than specifying one particular computer design, it’s a loose collection
    of formal and informal standards. The first PCs were designed and defined as such
    by IBM, beginning in 1981 with the IBM 5150, seen in [Figure 11-1](ch11.xhtml#ch11fig1);
    they were then copied by other manufacturers using similar compatible components.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 台式电脑与我们研究过的其他计算机概念不同：它并不是指定一种特定的计算机设计，而是一个松散的正式与非正式标准的集合。第一台PC由IBM于1981年设计并定义为此，最初的型号为IBM
    5150，如[图11-1](ch11.xhtml#ch11fig1)所示；随后，其他厂商也开始使用类似的兼容组件进行复制。
- en: In the 1990s, any computer with an x86 CPU capable of running a Microsoft DOS
    or Windows operating system was generally considered to be a PC. Microsoft chose
    what computer design features to support in this software, so it effectively set
    the standard definition. Other operating systems could also run on many of these
    machines while making different support choices. Often there are multiple competing
    standards for computer design features, and it becomes a political as well as
    technical question which ones get taken up by the PC community.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代，任何能够运行Microsoft DOS或Windows操作系统的x86 CPU计算机通常都被视为PC。微软选择了在其软件中支持哪些计算机设计特性，因此它实际上设定了标准定义。其他操作系统也可以在这些机器上运行，但会做出不同的支持选择。通常，计算机设计特性存在多个竞争标准，决定哪些标准被PC社区采纳，成为一个政治性和技术性的问题。
- en: Programming and using PCs thus feels different than more standardized platforms.
    For example, games created for a particular machine, such as a Commodore 64, can
    assume a precise hardware feature set and will run exactly the same on any Commodore
    64\. This enables the game designer to work as an artist, making the game look
    and feel exactly as they intend. But a game made for PCs will run differently
    on different PCs with different features, requiring game designers to create what
    is really a whole set of similar games, some of which they’ll never see themselves
    and can only guess at how to implement. Similarly, game players may have to get
    more involved in configuring their hardware and software to customize which version
    of the game they want to play.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编程和使用PC与更标准化的平台感觉不同。例如，为特定机器（如Commodore 64）创建的游戏可以假定精确的硬件特性，并且可以在任何Commodore
    64上完美运行。这使得游戏设计师能够像艺术家一样工作，使游戏的外观和感觉完全按照他们的意图呈现。但为PC设计的游戏会因为不同PC具有不同的特性而表现不同，这就要求游戏设计师实际上要创建一整套类似的游戏，其中有些他们自己永远不会见到，只能猜测如何实现。同样，玩家可能需要更深入地参与配置硬件和软件，以自定义他们想玩的游戏版本。
- en: Here we’ll look at some specific examples of buses, I/O modules, and devices
    used in today’s desktop PCs. These can often form the bottlenecks in modern PCS—there’s
    little use in having a highly optimized CPU if it has to spend its time waiting
    on other parts of the system. When you buy a computer, don’t just look at CPU
    speed—think about these supporting structures, too.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将具体介绍当前台式PC中使用的一些总线、I/O模块和设备。这些常常成为现代PC的瓶颈——如果CPU需要花费时间等待系统中的其他部件，那么拥有高度优化的CPU也没什么意义。在购买计算机时，不仅要关注CPU速度——也要考虑这些支持结构。
- en: '*The Bus Hierarchy*'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*总线层次结构*'
- en: Like CPUs, buses are continually being improved and replaced, so the PC architecture
    has used various standard bus hierarchies over time. Buses can be found in a desktop
    PC at several layers; each layer has different uses and different bandwidths,
    and is optimized for different purposes. [Table 13-5](ch13.xhtml#ch13tab5) shows
    some recent standards with their speeds and typical uses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CPU 类似，数据总线也在不断改进和替代，因此 PC 架构随着时间的推移使用了各种标准总线层次结构。总线可以在桌面 PC 中的多个层次找到；每一层有不同的用途和带宽，并且为不同的目的进行了优化。[表
    13-5](ch13.xhtml#ch13tab5)展示了一些近期标准的速度和典型用途。
- en: '**Table 13-5:** PC Bus Speeds and Uses'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-5：PC 总线速度和用途**'
- en: '| **Standard** | **Bandwidth (GBps)** | **Uses** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **标准** | **带宽（GBps）** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Gigabit Ethernet | 1 | Network |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 千兆以太网 | 1 | 网络 |'
- en: '| USB3 | 5 | Peripherals |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| USB3 | 5 | 外围设备 |'
- en: '| SATA3 | 6 | Secondary storage |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| SATA3 | 6 | 辅助存储 |'
- en: '| NVMe | 32 | Secondary storage |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| NVMe | 32 | 辅助存储 |'
- en: '| PCI express 5.0 x16 | 63 | Graphics cards |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| PCI Express 5.0 x16 | 63 | 显卡 |'
- en: You can see that communication with the outside world via Ethernet is at the
    slower end, local peripherals and secondary storage are in the middle, and graphics
    cards have had a lot of work done to make them communicate quickly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，通过以太网与外界通信是较慢的，地方外围设备和辅助存储位于中间，而显卡经过大量优化，使其能够快速通信。
- en: The classic PC hierarchy used two structures called Northbridge and Southbridge—known
    together as the *chipset*—as the main skeleton of the bus hierarchy. This is shown
    in [Figure 13-3](ch13.xhtml#ch13fig3).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 PC 架构使用了两个结构，称为北桥和南桥——合称为*芯片组*——作为总线层次结构的主要骨架。这在[图 13-3](ch13.xhtml#ch13fig3)中有所展示。
- en: '![Image](../images/f0320-01.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0320-01.jpg)'
- en: '*Figure 13-3: The Northbridge-Southbridge bus architecture*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：北桥-南桥总线架构*'
- en: '*Northbridge* connects directly to the CPU’s FSB (front-side bus) and links
    it to RAM and to fast I/O modules using the same address space via PCIe bus. It
    also connects to Southbridge. Northbridge is fast and powerful. It was traditionally
    constructed on a separate chip from the CPU that also hosted some memory cache
    levels. More recently, Northbridge has moved onto CPU silicon in many systems.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*北桥* 直接连接到 CPU 的 FSB（前端总线），并通过 PCIe 总线将其连接到 RAM 和快速的 I/O 模块，使用相同的地址空间。它还连接到南桥。北桥快速且强大。传统上，它是构建在与
    CPU 分开的芯片上，并且该芯片还承载了一些内存缓存层次。最近，北桥已经在许多系统中迁移到了 CPU 硅片上。'
- en: '*Southbridge* bridges a second time, from Northbridge to slower I/O bus hierarchies.
    It’s still usually located in its own dedicated silicon chip (which is sometimes
    also called “the chipset” even when Northbridge is located on the CPU chip). Southbridge
    contains many different standard I/O modules, all printed on the same silicon.
    Here you’ll see structures such as USB controllers, hard disk controllers, and
    the older PCI (not PCIe) bus.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*南桥* 第二次桥接，从北桥到较慢的 I/O 总线层次。它通常仍然位于自己的专用硅芯片上（即使北桥位于 CPU 芯片上时，它有时也被称为“芯片组”）。南桥包含许多不同的标准
    I/O 模块，所有这些模块都印刷在同一个硅片上。在这里，你会看到 USB 控制器、硬盘控制器和较老的 PCI（非 PCIe）总线等结构。'
- en: '[Figure 2](fm03.xhtml#fig2) in the introduction shows the physical layout of
    this design on a 2010s PC mainboard. In the figure, both Northbridge and Southbridge
    are covered by large heatsinks, showing that they’re major consumers of power
    and producers of heat, just like the CPU. Compared to retro computers, there are
    few other chips remaining on the mainboard, because most of their functionality
    has migrated to either Southbridge, Northbridge, or the CPU. The rest of the mainboard
    is taken up mostly by physical connectors and analog components used in power
    management.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍中的[图 2](fm03.xhtml#fig2)展示了这一设计在 2010 年代 PC 主板上的物理布局。在图中，北桥和南桥都被大型散热片覆盖，显示出它们是主要的功耗和热量源，就像
    CPU 一样。与复古计算机相比，主板上剩下的其他芯片很少，因为它们的大多数功能已经迁移到南桥、北桥或 CPU 上。主板的其余部分大多被用于电源管理中使用的物理连接器和模拟组件。
- en: With Northbridge now migrated onto the same silicon as the CPU in many cases,
    it’s become harder to identify it on more modern mainboards.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 随着北桥现在在许多情况下与 CPU 位于同一个硅片上，它在现代主板上变得更加难以识别。
- en: '**Standardized I/O**'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**标准化的输入输出（I/O）**'
- en: A current desktop PC trend is toward standardized I/O. In the bad old days,
    every device would have its own I/O module, a physical component sitting on the
    bus. That meant that each device had its own IRQ (interrupt request) line into
    the processor. You would need a specific I/O-level driver to look after that module,
    which could be painful to configure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当前桌面PC的趋势是朝着标准化I/O发展。在过去的坏时光里，每个设备都有自己的I/O模块，一个物理组件连接到总线上。这意味着每个设备都有自己的IRQ（中断请求）线路连接到处理器。你需要一个特定的I/O级别驱动程序来管理该模块，而这可能会让配置变得非常麻烦。
- en: Bus hierarchies such as USB have now largely solved this problem for PCs. These
    use a single I/O module, such as a USB controller, which has to be configured
    only once and uses only a single IRQ. All the devices then connect to this controller
    using a lower-level bus with its own protocol, which can include communications
    that inform the controller what the device is. They can easily share the single
    IRQ allocated to the controller.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: USB等总线层级结构现在在PC中大多解决了这个问题。这些总线使用一个单独的I/O模块，如USB控制器，该控制器只需配置一次并且只使用一个IRQ。所有设备随后通过一个低级总线与该控制器连接，并且该总线拥有自己的协议，可以包括向控制器传达设备类型的通信。它们可以轻松共享分配给控制器的单个IRQ。
- en: '**Fast Serial Buses**'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**快速串行总线**'
- en: In the golden age, a bus meant a whole load of parallel wires, often in the
    form of a ribbon cable, as in the left of [Figure 13-4](ch13.xhtml#ch13fig4).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在黄金时代，总线意味着一堆并行电缆，通常以带状电缆的形式出现，如[图13-4](ch13.xhtml#ch13fig4)左侧所示。
- en: '![Image](../images/f0321-01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0321-01.jpg)'
- en: '*Figure 13-4: A 1980s parallel bus ribbon cable with lots of wires (left) versus
    a fast serial 2020s connector with fewer wires*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：1980年代的并行总线带状电缆，电缆上有很多导线（左）与2020年代的快速串行连接器，电缆上有较少的导线（右）*'
- en: It’s rare to see ribbon cables nowadays, as most buses are serial, having just
    one wire for communication plus a few control and power wires, as on the right
    of [Figure 13-4](ch13.xhtml#ch13fig4). For example, SATA, SSA-SCSI, USB, and CAN
    are all serial buses.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如今很少见到带状电缆，因为大多数总线都是串行的，只使用一条通信线以及几条控制和电源线，如[图13-4](ch13.xhtml#ch13fig4)右侧所示。例如，SATA、SSA-SCSI、USB和CAN都是串行总线。
- en: This change was prompted by technical problems with parallel buses that arrived
    once speeds exceeded around 1Gbps. Small differences in delays on out-of-box parallel
    wires can put signals on different wires out of sync, and resynchronizing their
    data is very hard. Serial buses, on the other hand, can be made faster and faster
    as there’s no need to sync multiple wires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化是由于并行总线在速度超过约1Gbps后遇到的技术问题所引起的。并行电缆上的延迟微小差异可能导致不同的信号线不同步，而重新同步这些数据非常困难。另一方面，串行总线由于不需要同步多条电缆，因此可以越来越快。
- en: '**Migration Up the Hierarchy**'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向层级结构迁移**'
- en: As I/O modules get faster they want to move up the bus hierarchy to be closer
    to the CPU. Devices that used to hang off standardized buses, such as USB, want
    to connect directly to Southbridge; devices that used to hang off Southbridge
    want to get promoted to Northbridge; and devices that used to hang off Northbridge
    want to get promoted up into system-on-chip (SoC) silicon. At the same time, Northbridge,
    Southbridge, and standardized buses all want to increase their own speeds, meaning
    a device wanting to move from Southbridge to Northbridge, for example, might get
    overtaken by a new, faster Southbridge that makes its migration unnecessary. Since
    Moore’s law stopped the central CPU clock from getting faster, there’s been a
    big push to move innovation to all of these levels, which perhaps is making it
    a little more glamorous for the non-CPU architects who work on them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 随着I/O模块变得更快，它们希望向总线层级结构上移，更靠近CPU。曾经挂在标准化总线（如USB）上的设备希望直接连接到南桥；曾经挂在南桥上的设备希望升到北桥；曾经挂在北桥上的设备希望升到系统芯片（SoC）硅片上。同时，北桥、南桥和标准化总线都希望提高自己的速度，这意味着希望从南桥迁移到北桥的设备，可能会被一个新的、更快的南桥所超越，这使得其迁移变得不再必要。由于摩尔定律停止了中央CPU时钟的进一步加速，所有这些层级的创新推动变得更加重要，这或许使得非CPU架构师的工作变得更加光彩照人。
- en: Migration up the bus hierarchy and onto silicon makes the economics and legal
    structures of computer design harder to understand. In 8-bit times, different
    companies could make separate physical chips, such as CPU and I/O modules. Computer
    manufacturers would buy these chips, then design and build PCBs to integrate them.
    Nowadays, as more of these structures need to be fabricated together on the same
    piece of silicon, the CPU and I/O module companies need to share their designs
    with the computer manufacturer, using software files similar to LogiSim designs.
    The manufacturer then adds designs to these files to link them together, then
    sends them to a fabrication company. The units of digital logic design provided
    by each company are known as *IP (intellectual property) cores* and need to be
    closely guarded by lawyers and patent agents rather than just bought and sold
    as physical chips in plastic packages.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 向上迁移到总线层级并进入硅片使计算机设计的经济学和法律结构变得更难理解。在8位时代，不同的公司可以制作独立的物理芯片，例如CPU和I/O模块。计算机制造商购买这些芯片，然后设计和构建PCB以将它们集成在一起。如今，由于这些结构需要在同一块硅片上共同制造，CPU和I/O模块公司需要与计算机制造商共享他们的设计，使用类似于LogiSim设计的软件文件。制造商随后将设计添加到这些文件中，将它们链接在一起，然后将文件发送给制造公司。每家公司提供的数字逻辑设计单元被称为*IP（知识产权）核心*，这些设计需要由律师和专利代理人严密保护，而不是像物理芯片一样随意买卖。
- en: '*Common Buses*'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*常见总线*'
- en: Most of the space on mainboards is now taken up by connectors rather than chips,
    as you saw in [Figure 2](fm03.xhtml#fig2) of the introduction. The connectors
    seen in that figure are typical of other parts of the bus hierarchy. We’ll examine
    some of the main ones next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数主板上的空间都被连接器而非芯片占据，正如你在[图2](fm03.xhtml#fig2)的介绍中看到的那样。该图中看到的连接器是总线层级其他部分的典型代表。接下来，我们将详细检查其中的一些主要连接器。
- en: '**Peripheral Component Interconnect Express Bus**'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**外设组件互联快速通道总线**'
- en: PCIe (not to be confused with the older PCI) stands for Peripheral Component
    Interconnect Express and is a general-purpose bus for connecting graphics and
    other cards. PCIe comes in several flavors, as shown in [Figure 13-5](ch13.xhtml#ch13fig5);
    the connectors have physically different widths because they have different numbers
    of lanes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PCIe（不要与较旧的PCI混淆）代表外设组件互联快速通道（Peripheral Component Interconnect Express），是一种用于连接图形卡和其他卡的通用总线。PCIe有多种不同的类型，如[图13-5](ch13.xhtml#ch13fig5)所示；这些连接器有不同的物理宽度，因为它们具有不同数量的传输通道。
- en: '![Image](../images/f0322-01.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0322-01.jpg)'
- en: '*Figure 13-5: Some PCIe bus connectors*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-5：一些PCIe总线连接器*'
- en: You can get various powers of 2 between 1 and 32 lanes, depending on how much
    data you want to transfer. PCIe also comes in different generations, with speeds
    going from 250MBps to 2GBps per lane.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要传输的数据量，你可以获得从1到32条传输通道的不同2的幂次方数量。PCIe也有不同的代际版本，速度从每条通道250MBps到2GBps不等。
- en: Like many modern “buses,” PCIe began as an actual bus—in which many nodes share
    the same set of wires, each with its own address—but has evolved into a mesh network,
    with nodes now performing some routing to avoid congestion on the bus.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多现代“总线”一样，PCIe最初是一个实际的总线——多个节点共享相同的一组线路，每个节点都有自己的地址——但它已经发展成了一个网状网络，节点现在执行一些路由操作，以避免总线的拥塞。
- en: '**SCSI and SATA Buses**'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SCSI和SATA总线**'
- en: SCSI and SATA are competing buses for mass storage devices (for example, hard
    disks). The Small Computer System Interface (SCSI, pronounced “scuzzy”) is a very
    ancient, classic, well-tested, reliable, and expensive standard, dating from the
    1980s. It pioneered moving compute work for I/O control from CPU into digital
    logic in the I/O module, freeing up the CPU to work on other tasks more quickly.
    It’s used today in servers. SCSI has been through many versions; the latest update
    is Serial Storage Architecture (SSA), a serial bus version.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI和SATA是用于大容量存储设备（例如硬盘）的竞争性总线。小型计算机系统接口（SCSI，发音为“scuzzy”）是一个非常古老、经典、经过充分测试、可靠且昂贵的标准，起源于1980年代。它开创了将I/O控制的计算工作从CPU转移到I/O模块中的数字逻辑的做法，从而解放了CPU，使其能够更快速地处理其他任务。如今它仍在服务器中使用。SCSI经历了许多版本；最新的更新是串行存储架构（SSA），它是一个串行总线版本。
- en: Serial Advanced Technology Attachment (SATA) is cheaper and simpler than SCSI.
    For these reasons, it’s used in most consumer systems rather than SCSI.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 串行高级技术附件（SATA）比SCSI更便宜、更简单。正因为如此，它在大多数消费系统中取代了SCSI。
- en: '**Universal Serial Bus**'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**统一串行总线**'
- en: The *Universal Serial “Bus” (USB)* is the one you’re probably most familiar
    with. However, USB isn’t a bus at all—it’s not even a mesh network. It’s actually
    a point-to-point connector, intended to upgrade the older serial port.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用串行总线（USB）* 是你最熟悉的那种。然而，USB 实际上并不是总线——它甚至不是一个网状网络。它实际上是一个点对点连接器，旨在升级旧式的串行端口。'
- en: Before USB was invented, whenever you got a new piece of hardware you would
    spend a day trying to get the device driver working and configuring the IRQ lines.
    USB now makes all of this instant so you can “plug and play” many devices. USB
    is designed so that devices can be connected and disconnected while the computer
    is turned on, and part of its standard defines a generic method for devices to
    state their type and model over the basic USB protocol itself rather than requiring
    a device driver. This enables computer software to automatically see what’s been
    plugged in, and in many cases to download and run the appropriate drivers for
    it without intervention.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 USB 发明之前，每次获得一件新硬件时，你需要花一天时间去使设备驱动程序正常工作并配置 IRQ 线路。而现在，USB 使这一切变得瞬间完成，你可以“即插即用”许多设备。USB
    设计使得设备可以在计算机开机的情况下随时连接和断开，并且它的标准部分定义了一种通用的方法，允许设备通过基础的 USB 协议声明其类型和型号，而不需要设备驱动程序。这使得计算机软件能够自动识别已连接的设备，并在许多情况下自动下载并运行相应的驱动程序，而无需人工干预。
- en: USB also defines standards for requesting and sending power down the wires.
    A USB cable has four wires, two for sending a serial signal and two for power.
    There are 5 V and a ground in there, so, for example, you can use the same USB
    cable to charge your mobile phone and exchange data with it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: USB 还定义了请求和传输电力的标准。一个 USB 电缆有四条线路，其中两条用于传输串行信号，另外两条用于电力供应。电缆内有 5V 电压和接地线，因此你可以使用同一根
    USB 电缆为手机充电并与其交换数据。
- en: All of this is done through a centralized USB controller, which is a single
    I/O module, so you don’t have to worry about IRQs anymore. The USB controller
    itself has an IRQ, but then everything else is hanging off a USB network. There
    have been different versions of USB, including USB 1 running at 12Mbps and USB
    3 running at 5Gbps.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是通过一个集中式的 USB 控制器完成的，它是一个单一的 I/O 模块，因此你不再需要担心 IRQ 问题。USB 控制器本身有一个 IRQ，但之后其他一切都通过
    USB 网络连接。USB 有多个版本，包括 USB 1，传输速度为 12Mbps，以及 USB 3，传输速度为 5Gbps。
- en: 'Unlike some point-to-point networks, USB connections have a manager end and
    a worker end, with the manager in charge of the communications protocol. If you
    plug a USB memory stick into your computer, your computer is the manager. As the
    worker, your USB stick can’t take over and start sending its own requests to copy
    data from your computer. This is why USB wires have different endings: one end
    plugs into the manager that controls it and the other end goes into the worker,
    and you can’t connect them the other way around.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些点对点网络不同，USB 连接有一个管理端和一个从属端，管理端负责通信协议。如果你把 USB 存储棒插入计算机，那么计算机就是管理器。作为从属设备的
    USB 存储棒不能自行发起请求来复制计算机中的数据。这就是为什么 USB 电缆有不同接口的原因：一端插入管理端，控制它，另一端插入从属端，你不能将它们反过来连接。
- en: '*On-the-go (OTG)* is part of the USB protocol that allows a worker device to
    act as a manager via a physical adapter. Sometimes you do want to connect them
    the wrong way around. For example, when you connect your smartphone to your computer,
    you usually want it to be the worker, like a USB stick, with your computer as
    the manager. But other times you want the phone to be the manager, such as when
    connecting a memory stick or sound card to it.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*即插即用（OTG）* 是 USB 协议的一部分，允许从属设备通过物理适配器充当管理器。有时候你确实希望它们连接的方式相反。例如，当你将智能手机连接到计算机时，你通常希望手机作为从属设备，像一个
    USB 存储棒，而计算机作为管理器。但在其他情况下，你希望手机作为管理器，例如，当你将一个存储棒或声卡连接到手机时。'
- en: '**Ethernet**'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**以太网**'
- en: '*Ethernet*, in its oldest and simplest form, is a true bus, with multiple PCs
    in a local area network all writing and reading on public wires. Each message
    is packaged as a “frame,” containing the address (Media Access Control, or MAC,
    address) of the recipient. Senders must take care to avoid collisions—that is,
    people talking at the same time—by watching the bus and waiting for a suitable
    time to transmit. Everyone can see everything on the bus, so it’s easy to “sniff”
    the bus and spy on other users.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太网*，在其最古老和最简单的形式下，是一个真正的总线，局域网中的多个个人电脑都在公共电缆上进行读写。每条消息都被打包成一个“帧”，包含接收方的地址（媒体访问控制地址，或称MAC地址）。发送者必须小心避免碰撞——也就是，避免在同一时间有人同时发话——通过观察总线并等待合适的时机进行传输。每个人都可以看到总线上的所有内容，因此很容易“嗅探”总线并监视其他用户。'
- en: Modern networks build non-bus features on top of the basic Ethernet bus structure.
    For example, rather than connecting all computers in a building to a single shared
    Ethernet bus, it’s now common for each to connect only to a central *switch* using
    a dedicated Ethernet cable. The switch receives all messages that are sent, but
    rather than forwarding them, bus-style, to all machines on the network, it forwards
    them only to the intended destination.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络在基本的以太网总线结构之上构建了非总线特性。例如，现在不是将建筑物中的所有计算机连接到一个共享的以太网总线，而是每台计算机通常只通过专用以太网电缆连接到一个中心的*交换机*。交换机接收所有发送的消息，但与其将它们像总线那样转发给网络上的所有机器，不如仅将它们转发到预定的目的地。
- en: '*Standard Devices*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*标准设备*'
- en: Your desktop PC wouldn’t be complete without some other standard devices. To
    complete our study of PCs, let’s take a quick look at how these have evolved.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他一些标准设备，你的台式电脑将不完整。为了完成我们对个人电脑的研究，让我们快速了解这些设备是如何发展的。
- en: '**Flat-Screen Displays**'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**平面显示器**'
- en: Modern flat-screen displays are used in mobile phone screens and large-screen
    TVs and monitors. They’re made from transistors and capacitors, laid down like
    chips by photolithography masks and gas processes. Many rare elements are used
    to produce the specific red, green, and blue light-emitting pixels, including
    yttrium, lanthanum, terbium, praseodymium, europium, dysprosium, and gadolinium.
    Some of these are so rare that they can be mined only in one or two places. Many
    specific combinations of electronics and elements have been used as display “technologies,”
    including TFT. The latest at the time of writing is organic LED (OLED).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现代平面显示器被广泛应用于手机屏幕、电视和大型显示器。它们由晶体管和电容器组成，通过光刻掩膜和气体工艺像芯片一样被布局。许多稀有元素用于生产特定的红、绿、蓝发光像素，包括钇、镧、铽、铈、欧、镝和钆。其中一些元素如此稀有，只有在一两个地方可以开采。许多特定的电子元件和元素组合被用于显示“技术”，其中包括TFT。写作时，最新的技术是有机LED（OLED）。
- en: '**Graphics Cards**'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**显卡**'
- en: In the 1980s, graphics was simple. An area of memory was allocated to represent
    the array of pixels on the screen. User programs would write to it like any other
    part of memory. Then a graphics chip would read from it and turn the data into
    CRT scanning commands to send to the monitor. Now things are more complicated,
    as programmers expect graphics hardware to provide commands for complex rendering
    of 2D and 3D shapes without taking up CPU time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，图形非常简单。会分配一块内存区域来表示屏幕上的像素阵列。用户程序像访问其他内存区域一样写入其中。然后，图形芯片从中读取数据，将其转化为CRT扫描命令，并发送给显示器。现在情况更为复杂，因为程序员希望图形硬件提供复杂的2D和3D图形渲染命令，而不占用CPU时间。
- en: To respond to this demand, the modern graphics processing unit (GPU) evolved
    from 1980s visual display units (VDUs). Rather than taking commands to light up
    pixels, GPUs typically take commands to render 3D triangles with sprite-like textures,
    and to shade them using complex lighting models.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应这一需求，现代图形处理单元（GPU）由1980年代的视觉显示单元（VDU）演变而来。与其接受点亮像素的命令，GPU通常接受渲染3D三角形并为其添加类似精灵的纹理的命令，并使用复杂的光照模型为其着色。
- en: If you’ve been playing video games over the last couple of decades, you’ll have
    seen the visual abilities of GPUs evolve with Moore’s law, doubling in quality
    and getting closer to photorealistic, real-time rendering.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在过去几十年里玩过视频游戏，你一定看到了图形处理单元（GPU）的视觉能力随着摩尔定律的发展而不断演进，质量翻倍，越来越接近光学逼真、实时渲染的效果。
- en: The GPU traditionally sits on one of the buses of the mainboard, such as PCI,
    AGP, or PCIe. GPUs have been the one part of computer architecture that’s been
    getting physically bigger rather than shrinking over the years, starting off as
    a small chip and now most likely a full card ([Figure 13-6](ch13.xhtml#ch13fig6)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: GPU传统上位于主板的某个总线上，如PCI、AGP或PCIe。多年来，GPU一直是计算机架构中唯一一个在物理上不断变大的部件，它最初是一个小芯片，现在大多数可能是一个完整的卡片（[图
    13-6](ch13.xhtml#ch13fig6)）。
- en: '![Image](../images/f0325-01.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0325-01.jpg)'
- en: '*Figure 13-6: A 2022 Nvidia RTX 3080 GPU*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-6：2022年Nvidia RTX 3080 GPU*'
- en: There has, however, also been a recent trend to shrink GPUs back to put on a
    single chip on the mainboard, or onto the same silicon as the CPU. This is particularly
    the case in machines where the GPU isn’t the main focus, such as generic business
    PCs where the graphics requirements don’t extend much beyond displaying the desktop.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最近也有一个趋势是将GPU缩小回主板上的单一芯片，或者与CPU集成在同一块硅片上。这在一些机器中尤为常见，特别是那些GPU不是主要关注点的机器，如图形需求不超过显示桌面的通用商务PC。
- en: Graphics cards sit on the system bus as I/O modules. Importantly, they can use
    direct memory access (DMA). For example, an image can be placed in regular RAM,
    then a single command can be given to the GPU to load it from main RAM into the
    GPU. This DMA action doesn’t go through the CPU, so from the CPU’s point of view
    it’s almost instant. (It will, however, slow down if the bus is needed for other
    things, such as additional DMAs from a webcam into the main RAM.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 显卡位于系统总线上，作为I/O模块。重要的是，它们可以使用直接内存访问（DMA）。例如，图像可以被放置在常规RAM中，然后可以给GPU发出一个命令，将它从主内存加载到GPU中。这种DMA操作不经过CPU，因此从CPU的角度来看几乎是瞬时的。（然而，如果总线需要用于其他任务，如从网络摄像头向主内存传输额外的DMA数据时，速度会变慢。）
- en: Early GPUs were designed to accelerate rendering of the popular OpenGL 3D graphics
    API by implementing its commands directly in hardware, beginning with a memory-mapped
    area and a chip that read that area and figured out how to display that memory
    block on the screen. In the 2000s, in addition to or instead of memory-mapped
    graphics, optional plug-in graphics cards sat on the system bus as I/O modules
    and drew graphics in response to compiled and assembled commands of graphics languages
    such as OpenGL or DirectX, sent to them via the system bus. Graphics cards were
    labeled and sold as implementing one or more of these language interfaces.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的GPU旨在通过直接在硬件中实现OpenGL 3D图形API的命令来加速渲染，最初是从内存映射区域开始，然后使用一个芯片读取该区域并找出如何将该内存块显示在屏幕上。在2000年代，除了或代替内存映射图形外，选配的插件显卡作为I/O模块位于系统总线上，根据通过系统总线发送的OpenGL或DirectX等图形语言编译和组装的命令来绘制图形。显卡被标记并作为实现一个或多个这些语言接口的产品出售。
- en: A 3D graphics language usually assumes that 3D objects are composed of many
    small triangles. Triangles are chosen because their three points always lie in
    a plane, making the math easier. Their implementations, in hardware and/or software,
    usually split into two main parts, known as *shaders*. First, vertex calculations
    convert the 3D coordinates of each vertex into 2D pixel coordinates. Second, pixel
    calculations compute the color (shade) of each display pixel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 3D图形语言通常假设3D物体由许多小三角形构成。选择三角形是因为它的三个顶点总是位于一个平面上，从而简化了数学计算。它们的实现，无论是在硬件还是软件中，通常分为两个主要部分，称为*着色器*。首先，顶点计算将每个顶点的3D坐标转换为2D像素坐标。其次，像素计算计算每个显示像素的颜色（阴影）。
- en: The latter can be done in many different ways according to different mathematical
    models of how surfaces and lights interact. Most shaders allow triangles to be
    translucent (partly transparent), modeled via an alpha channel in their RGBA color,
    as discussed on [page 68](ch02.xhtml#page_68). Some shaders allow normal (orthogonal)
    vectors to be described for each triangle as a hint that they’re part of smooth,
    continuous surfaces.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可以通过多种不同的方式实现，具体取决于表面与光源交互的数学模型。大多数着色器允许三角形具有半透明（部分透明）效果，这通常通过它们的RGBA颜色中的alpha通道来建模，如[第68页](ch02.xhtml#page_68)所述。一些着色器允许为每个三角形描述法线（正交）向量，作为它们是平滑连续表面一部分的提示。
- en: '[Figure 13-7](ch13.xhtml#ch13fig7) shows the results of three traditional shaders
    built into early OpenGL implementations, rendering the same triangle mesh approximation
    to a sphere.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-7](ch13.xhtml#ch13fig7)展示了三种早期OpenGL实现中内置的传统着色器的结果，它们将相同的三角网格近似渲染成一个球体。'
- en: '![Image](../images/f0326-01.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0326-01.jpg)'
- en: '*Figure 13-7: Traditional OpenGL shaders: flat (left), Gouraud (center), and
    Phong (right)*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-7：传统的 OpenGL 着色器：平面着色（左）、Gouraud 着色（中）、和 Phong 着色（右）*'
- en: Graphics users demanded more flexibility in shaders. New shading models are
    often proposed in graphics research, and users wanted them to be quickly available
    in their own systems. The graphics languages rapidly gained many extension commands
    in their later versions, to enable particular additional shaders, and graphics
    card architects struggled to keep up with designing new hardware to implement
    them and make them compatible with one another. These architects instead began
    to open up new and simpler shader languages (such as GLSL) to enable these and
    other arbitrary shaders to be implemented in user programs, and executed on the
    graphics card—now known as a GPU—via their own ISAs. This allowed programmers—especially
    game designers and movie studios—to create their own custom shaders to give their
    creations a more individual feel, as in the examples in [Figure 13-8](ch13.xhtml#ch13fig8).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户要求着色器具有更多灵活性。新的着色模型经常在图形研究中提出，用户希望它们能快速应用到自己的系统中。图形语言在后续版本中迅速增加了许多扩展命令，以支持特定的附加着色器，并且图形卡架构师们努力跟上设计新的硬件来实现它们，并确保它们彼此兼容。这些架构师转而开始开放新的、更简单的着色器语言（如
    GLSL），以使这些以及其他任意着色器能够在用户程序中实现，并通过它们自己的 ISA 在图形卡——现在称为 GPU——上执行。这使得程序员——特别是游戏设计师和电影工作室——能够创建自定义着色器，赋予他们的创作更具个性化的风格，如[图
    13-8](ch13.xhtml#ch13fig8)中的示例所示。
- en: '![Image](../images/f0326-02.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0326-02.jpg)'
- en: '*Figure 13-8: Custom shaders: water effects from* 0 A.D. *(left), “toon” shading
    (center), and retro CRT emulation (right)*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8：自定义着色器：来自* 0 A.D. *的水面效果（左）、“卡通”着色（中）、以及复古 CRT 模拟（右）*'
- en: Today’s graphics systems have continued this architectural trend, with GPUs
    now functioning as highly general parallel processors of their own instruction
    sets, and the graphics-specific shaders moved into software. Former hardware interfaces
    including OpenGL and DirectX are now implemented in software, written in the GPU’s
    own assembly and machine code. Such code can now also be generated directly by
    other graphics tools, such as Wayland compositors and the Vulkan SPIR-V language.
    The resulting GPU machine code is sent over the bus to the graphics card, where
    it runs on the GPU. We’ll study this code in more detail in [Chapter 15](ch15.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的图形系统延续了这一架构趋势，GPU 现在作为自己的指令集的高度通用的并行处理器，并且图形专用的着色器已经转移到软件中。以前的硬件接口，包括 OpenGL
    和 DirectX，现在都以软件的形式实现，编写在 GPU 自身的汇编和机器代码中。这些代码现在也可以由其他图形工具直接生成，例如 Wayland 合成器和
    Vulkan SPIR-V 语言。生成的 GPU 机器代码通过总线发送到图形卡，在 GPU 上运行。我们将在[第 15 章](ch15.xhtml)中更详细地学习这些代码。
- en: '**Sound Cards**'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声卡**'
- en: 'Unlike retro sound chips, such as the SID, modern sound cards don’t generate
    signals at all. Instead, they manage the flow of quantized, digital sound wave
    signals. As a result, computers have lost their characteristic sound effects and
    musical culture: modern game music can consist of ordinary recordings of orchestras
    or rock bands rather than any particular “computer music.” Like graphics cards,
    sound cards are always now under OS control, so user programmers are unlikely
    to see much of their architecture.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不像复古的声音芯片，例如 SID，现代的声卡根本不生成信号。相反，它们管理量化的数字声音波形信号的流动。因此，计算机失去了它们特有的音效和音乐文化：现代游戏音乐可以仅仅是普通的交响乐团或摇滚乐队的录音，而不再是任何特定的“计算机音乐”。像图形卡一样，声卡现在总是由操作系统控制，所以用户程序员不太可能看到它们的架构。
- en: A modern sound card is really just a group of digital-to-analog converters (DACs),
    and indeed it’s possible to make your own from any DAC, such as the one found
    on a Labjack, a software-defined radio, or an Arduino Due. Typically, professional
    sound cards are optimized for low latency, sound quality, and many channels, while
    consumer cards are optimized for lower cost. Human hearing has a maximum frequency
    of around 20 kHz, which requires a 40 kHz sampling rate to be represented accurately.
    It’s common to use 48 kHz to allow some wiggle room and because it’s almost a
    power of 2\. Professional systems may use higher rates to reduce the buildup of
    audible errors from repeated processing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现代声卡实际上只是由一组数模转换器（DAC）组成，实际上你可以使用任何DAC来制作自己的声卡，比如在Labjack、软件定义无线电或Arduino Due上找到的那种。通常，专业声卡针对低延迟、音质和多个通道进行了优化，而消费级声卡则注重降低成本。人耳的最大听力频率约为20
    kHz，因此需要40 kHz的采样率才能准确表示。常见的做法是使用48 kHz，以留出一些余地，并且因为它几乎是2的幂次。专业系统可能会使用更高的采样率，以减少重复处理带来的可听错误的积累。
- en: Sound card hardware typically consists of a ring buffer for each channel, as
    well as DAC hardware, which reads or writes to and from it. A ring buffer maintains
    a pointer to the next location to write, and wraps the storage around the ring
    so space doesn’t run out. The buffer size provides a trade-off between latency
    and dropouts. A small buffer means low latency but risks dropouts. We can also
    choose the bit depth of the audio.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 声卡硬件通常由每个通道的环形缓冲区和DAC硬件组成，DAC硬件用来读取或写入缓冲区。环形缓冲区维护一个指向下一个写入位置的指针，并将存储空间环绕起来，以免空间耗尽。缓冲区的大小提供了延迟和丢失之间的权衡。较小的缓冲区意味着较低的延迟，但也有丢失的风险。我们还可以选择音频的位深度。
- en: Sound cards, like graphics cards, connect to the system bus. They’re less bandwidth-hungry
    than video, so they’re usually found on a bus hanging off of Southbridge, such
    as PCI for internal cards or USB or Firewire for external cards.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 声卡像显卡一样连接到系统总线。它们对带宽的需求比视频小，因此通常位于南桥挂接的总线上，例如PCI用于内部卡，或USB或Firewire用于外部卡。
- en: Sound card I/O protocols vary by manufacturer, and like GPUs, their details
    may be proprietary and known only to the driver writers inside the company, who
    then make a software API available. As with GPUs, the hardware or software interfaces
    are then reverse engineered by open source driver writers, who wrap them in generic
    software APIs such as *ALSA*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 声卡的输入输出协议因制造商而异，像GPU一样，它们的细节可能是专有的，只为公司内部的驱动程序编写者所知，然后他们提供软件API。与GPU一样，硬件或软件接口随后被开源驱动程序编写者反向工程化，并通过通用软件API（如*ALSA*）进行封装。
- en: '**Keyboards and Mice**'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**键盘和鼠标**'
- en: Modern keyboards are nothing like the memory-mapped keyboards of the 1980s.
    They now contain small, embedded computers (see [Figure 13-9](ch13.xhtml#ch13fig9)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现代键盘与1980年代的内存映射键盘完全不同。它们现在包含小型的嵌入式计算机（见[图13-9](ch13.xhtml#ch13fig9)）。
- en: '![Image](../images/f0328-01.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0328-01.jpg)'
- en: '*Figure 13-9: The key pressure sensors and embedded system inside a modern
    keyboard*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-9：现代键盘内部的按键压力传感器和嵌入式系统*'
- en: The keyboard’s embedded computer is actually doing a lot of work, similar to
    a typical Arduino application. It takes the matrix of key presses, converts them
    to a keycode data representation scheme, and transmits them over a virtual serial
    port wrapped in USB protocol.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘的嵌入式计算机实际上做了很多工作，类似于典型的Arduino应用。它读取按键矩阵，将其转换为按键码数据表示方案，并通过USB协议包装，传输到虚拟串口。
- en: Something similar has happened with mice. A modern optical mouse performs some
    extremely complicated real-time machine vision processing known as *optic flow*
    on a dedicated internal embedded system. If you try to implement optic flow in
    software, you’ll find it’s hard to do fast. It’s still a research area, with recent
    implementations in software libraries such as OpenCV. In a mouse, however, it’s
    implemented directly as low-level digital electronics, as in [Figure 13-10](ch13.xhtml#ch13fig10).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标也发生了类似的变化。现代光学鼠标在一个专用的内嵌系统中执行一些极其复杂的实时机器视觉处理，称为*光流*。如果你尝试在软件中实现光流，会发现很难做到快速。它仍然是一个研究领域，最近的实现出现在像OpenCV这样的软件库中。然而，在鼠标中，它是通过低级数字电子元件直接实现的，如[图13-10](ch13.xhtml#ch13fig10)所示。
- en: '![Image](../images/f0328-02.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0328-02.jpg)'
- en: '*Figure 13-10: The inside of an optical mouse*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：光学鼠标内部结构*'
- en: This digital logic is just about simple enough for you to still be able to see
    the connections. You can see from the overall, fairly homogeneous structure that
    it’s processing a region of 2D space—the image underneath the mouse. It tracks
    how light and dark areas of this image are moving around and from that infers
    the movement of the mouse.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数字逻辑足够简单，你仍然能够看到连接。你可以从整体、相对均匀的结构中看出，它正在处理一个二维空间的区域——鼠标下方的图像。它跟踪图像中的明暗区域如何移动，并据此推断鼠标的运动。
- en: There’s also usually a USB controller attached to the device. This is actually
    a complex embedded system—possibly a computer in its own right—and the fact that
    it’s now available for a few dollars in every mouse is very impressive.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常设备上还会附加一个 USB 控制器。实际上，这是一个复杂的嵌入式系统——可能是一个独立的计算机——而且它现在只需要几美元就能集成到每个鼠标中，着实令人印象深刻。
- en: '**THE PC BOOT PROCESS**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**PC 启动过程**'
- en: The term *booting* comes from the paradoxical expression “pulling yourself up
    by your bootstraps.” It means starting with nothing and getting into a complex
    computer system by having small programs execute that load slightly larger and
    more powerful programs, in a sequence. On both retro systems and modern PCs, this
    begins by the CPU fetching an instruction from a hardwired ROM address.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*启动*（booting）这一术语源自自相矛盾的表达“拉自己一把（pulling yourself up by your bootstraps）”。它意味着从无到有，通过执行小程序依次加载稍大一些、功能更强大的程序，从而进入一个复杂的计算机系统。在复古系统和现代
    PC 上，这一过程从 CPU 从硬件 ROM 地址获取指令开始。'
- en: Unlike retro computers, modern PCs aren’t made from standard components; instead,
    they are assembled from many different optional components, such as RAM modules
    of various types, caches, and I/O extension cards. It’s not initially obvious
    where all these things are, how they should be initialized, or how they should
    be mounted in the address space. To address this, the modern PC boot process is
    split into two parts.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与复古计算机不同，现代 PC 并非由标准组件构成，而是由许多不同的可选组件组装而成，例如各种类型的 RAM 模块、缓存和 I/O 扩展卡。最初并不明显这些组件的位置、它们应该如何初始化或如何在地址空间中安装。为了解决这个问题，现代
    PC 的启动过程分为两个部分。
- en: First, a *bootloader* such as *coreboot* is burned into ROM firmware, at the
    address of the CPU’s initial program counter. For x86, this is ffff,fff0[16].
    This is a 16-bit address, because x86 processors always power on in “legacy mode”
    (Intel calls it “real mode”), which makes them behave like 1980s 16-bit chips
    for backward compatibility. In this mode, only 1 M[2]B of combined ROM and RAM
    memory is addressable, and the initial program counter address is near the top
    of it. The bootloader runs from here and is responsible for inspecting, initializing,
    and assigning addresses to the available hardware. The boot-loader doesn’t display
    anything onscreen because there aren’t yet any routines available for doing I/O.
    Because it’s invisible, it can be hard to understand all the hard work the bootloader
    is doing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*启动加载程序*（*coreboot* 等）被烧录到 ROM 固件中，位于 CPU 初始程序计数器的地址。对于 x86，这个地址是 ffff,fff0[16]。这是一个
    16 位地址，因为 x86 处理器总是在“传统模式”（英特尔称之为“实模式”）下启动，这使得它们像 1980 年代的 16 位芯片一样工作，以实现向后兼容。在这种模式下，只有
    1 MB[2] 的 ROM 和 RAM 内存是可寻址的，而初始程序计数器地址接近内存的顶部。启动加载程序从这里运行，负责检查、初始化并分配可用硬件的地址。启动加载程序不会在屏幕上显示任何内容，因为此时还没有任何可用于输入输出的例程。由于它不可见，所以很难理解启动加载程序正在执行的所有复杂工作。
- en: Second, after this initialization, the bootloader performs a jump to code in
    the BIOS. The BIOS, as in a retro computer, contains subroutines for basic I/O
    such as ASCII character display, keyboard reading, and hard disk access. At this
    stage, your PC can look and feel much like a retro computer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在完成初始化后，启动程序会跳转到 BIOS 中的代码。BIOS，就像复古计算机一样，包含了基本输入输出的子例程，如 ASCII 字符显示、键盘读取和硬盘访问。在这个阶段，你的
    PC 看起来和感觉上都很像一台复古计算机。
- en: Usually, the BIOS code jumped to from the bootloader will print a few strings
    on the screen, such as the name and logo of the BIOS. A PC BIOS ROM and an example
    of BIOS display I/O capabilities are shown here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从启动加载程序跳转到 BIOS 代码时，BIOS 会在屏幕上打印一些字符串，如 BIOS 的名称和标志。这里展示了一个 PC BIOS ROM 和一个示例的
    BIOS 显示 I/O 能力。
- en: '![Image](../images/f0330-01.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0330-01.jpg)'
- en: A BIOS will usually first offer the user the chance to “go into the BIOS” by
    pressing a key, which will call graphical routines for setting configuration options.
    One of these options is usually to give the name of a storage device whose first
    data contains the next program to be loaded and jumped to, usually at address
    7c00[16]. What this program does is up to you—a common first move is to switch
    the x86 up into 32-, then 64-bit modes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 通常会首先让用户有机会通过按某个键进入“BIOS”，这时会调用图形例程来设置配置选项。通常，其中的一个选项是指定一个存储设备的名称，该设备的第一个数据包含接下来需要加载并跳转的程序，通常是在地址
    7c00[16]。这个程序做什么由你决定——一个常见的第一步是将 x86 切换到 32 位模式，然后是 64 位模式。
- en: There was a time when different x86 BIOS manufacturers all made different and
    incompatible libraries of routines, but they’ve now converged on two standards.
    One, PCBIOS, was defined by IBM (who just call it “BIOS”) in early x86 PCs. It
    was cloned by other manufacturers and is still used by many x86 machines today.
    SeaBIOS is an open source implementation. The other standard, UEFI, is more recent.
    It assumes more advanced graphics and I/O are available, so its library of routines
    includes higher resolution and more colorful graphics, and access to additional
    devices such as USB. TianoCore is an open source implementation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，不同的 x86 BIOS 制造商各自开发了不同且不兼容的例程库，但现在它们已趋于两种标准。其一，PCBIOS，是 IBM（他们称之为“BIOS”）在早期的
    x86 PC 中定义的。其他制造商进行了克隆，至今许多 x86 机器仍在使用。SeaBIOS 是一个开源实现。另一种标准，UEFI，则是更现代的标准。它假设提供了更先进的图形和输入输出功能，因此它的例程库包括了更高分辨率和更多彩的图形，并且能访问
    USB 等额外设备。TianoCore 是一个开源实现。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: No one would design a modern desktop PC to have its current form if they were
    able to start from scratch. Like many successful commercial, real-world systems,
    the PC has evolved over time as new features have been requested and bolted on,
    while existing customers demand backward compatibility. As a result, both the
    x86 architecture and PC computer design have accumulated layers of legacy features.
    The CISC philosophy is a good fit for this environment. It’s common for multiple
    competing standards to be supported within single designs, even including multiple
    choices for x86 assemblers including but not limited to NASM. Recent x86 has extended
    beyond the features seen in this chapter by adding parallelization, which we’ll
    examine in [Chapter 15](ch15.xhtml). But before this, we’ll take a breather by
    looking at developments in the cleaner, more beautiful world of RISC in the next
    chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够从零开始设计，没人会将现代桌面 PC 设计成现在的样子。就像许多成功的商业实际系统一样，PC 随着时间推移不断发展，新的功能被要求并附加上去，而现有用户又要求向后兼容。因此，x86
    架构和 PC 计算机设计积累了许多遗留功能。CISC（复杂指令集计算机）理念非常适合这种环境。在单一设计中，通常会支持多个竞争标准，甚至包括多个 x86 汇编器的选择，其中之一就是但不限于
    NASM。最近的 x86 进一步扩展了本章所介绍的功能，增加了并行化，我们将在[第15章](ch15.xhtml)中进行探讨。但在此之前，我们将稍作休息，下一章将探讨更加简洁、美丽的
    RISC 世界。
- en: Exercises
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Creating a Bootable ISO Image**'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建可引导的 ISO 镜像**'
- en: Here you’ll create a simple 16-bit “Hello, world!” program, assemble it with
    NASM into executable machine code, then store this machine code in an ISO file,
    an image of the contents of a physical secondary storage device that you can use
    to boot a real PC or a virtual machine.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将创建一个简单的 16 位“Hello, world!”程序，使用 NASM 将其汇编成可执行的机器代码，然后将这些机器代码存储到 ISO 文件中，这是物理二级存储设备内容的镜像，可以用来启动真实的
    PC 或虚拟机。
- en: 'Create the following *hello16bit.asm* file:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下的*hello16bit.asm*文件：
- en: '[PRE22]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following commands:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE23]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**NOTE**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using Microsoft Windows, these commands can be run by installing
    and using the Windows Subsystem for Linux. If you don’t already have NASM, install
    it from* [https://nasm.us](https://nasm.us). *You may also need to install mkisofs
    for your system.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用的是 Microsoft Windows，可以通过安装并使用 Windows Subsystem for Linux 来运行这些命令。如果你还没有安装
    NASM，可以从* [https://nasm.us](https://nasm.us) *下载安装。你可能还需要为系统安装 mkisofs。*'
- en: If everything worked, you’ll now have a *cd.iso* file for booting a physical
    or virtual x86 machine. This will allow you to run on “bare metal” x86, without
    an operating system getting in the way.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你现在应该拥有一个*cd.iso*文件，可以用来启动物理或虚拟的 x86 机器。这将允许你在没有操作系统干扰的情况下在“裸机”上运行 x86。
- en: We’ll discuss how to boot into your ISO file in the next exercises. When you
    do, you should see something like [Figure 13-11](ch13.xhtml#ch13fig11) on the
    screen.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中讨论如何从 ISO 文件启动。当你启动时，应该会在屏幕上看到类似[图 13-11](ch13.xhtml#ch13fig11)的内容。
- en: '![Image](../images/f0332-01.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0332-01.jpg)'
- en: '*Figure 13-11: The result of booting into a bare metal test program*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：启动裸机测试程序的结果*'
- en: 'Before going any further, let’s look at what *hello16bit.asm* actually does.
    In addition to actual x86 instruction mnemonics, a NASM program usually also includes
    some directives, which are lines that aren’t assembled themselves but instead
    tell NASM to change its behaviors in various ways. The `section` directive tells
    NASM to change which segment of the output file to write the next assembled instructions
    to. In some file formats, the number and names of sections are fixed; in others,
    the user may make up as many as they wish. The Unix object and bin formats all
    support the standardized section names `.text` (contains executable instructions),
    `.data` (contains initialized variables), and `.bss` (contains uninitialized variables).
    The ASCII string includes special ASCII codes 13, 10, and 0 after the human readable
    letters. What are these? (Hint: See [Chapter 2](ch02.xhtml).)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们来看一下*hello16bit.asm*究竟做了什么。除了实际的x86指令助记符外，NASM程序通常还包括一些指令，这些指令不是由NASM本身汇编的，而是告诉NASM以各种方式更改其行为。`section`指令告诉NASM改变输出文件的哪个段来写入接下来的汇编指令。在某些文件格式中，段的数量和名称是固定的；而在其他格式中，用户可以根据需要自定义段的数量。Unix对象文件和bin格式都支持标准化的段名称`.text`（包含可执行指令）、`.data`（包含初始化变量）和`.bss`（包含未初始化变量）。ASCII字符串在可读字符后包含特殊的ASCII代码13、10和0。它们是什么？（提示：参见[第2章](ch02.xhtml)。）
- en: '**Booting on a Virtual x86**'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在虚拟x86上启动**'
- en: The ISO can be booted on a virtual machine as if it were a physical disk. Follow
    these steps to try it out using the VirtualBox virtual machine. (Open source Linux
    users may prefer to use virt-manager at *[https://virt-manager.org](https://virt-manager.org)*.)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ISO文件可以像物理磁盘一样在虚拟机上启动。按照以下步骤，尝试在VirtualBox虚拟机上运行它。（开源Linux用户可能更喜欢使用* [https://virt-manager.org](https://virt-manager.org)
    *来代替。）
- en: Visit *[https://www.virtualbox.org](https://www.virtualbox.org)* for instructions
    on how to install VirtualBox on your system.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问* [https://www.virtualbox.org](https://www.virtualbox.org) *以获取如何在你的系统上安装VirtualBox的说明。
- en: Once installed, create a new virtual machine by clicking the **New** icon; use
    the default settings.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，点击**新建**图标创建一个新虚拟机；使用默认设置。
- en: Start your virtual machine and “insert” your bootable virtual CD by selecting
    your *cd.iso* file when asked.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的虚拟机，并在系统提示时通过选择你的*cd.iso*文件来“插入”可启动的虚拟光盘。
- en: '**Booting on a Physical x86**'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在物理x86上启动**'
- en: 'The ISO can also be booted on a physical x86 machine if you first “burn” it
    onto a physical USB stick. Here’s how:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先将ISO文件“烧录”到一个物理USB闪存盘上，它也可以在物理x86机器上启动。操作步骤如下：
- en: Use a program such as Etcher (*[https://www.balena.io](https://www.balena.io)*)
    for your current operating system to burn the ISO to a USB stick.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用诸如Etcher（* [https://www.balena.io](https://www.balena.io) *）等程序，将ISO文件烧录到USB闪存盘上，适用于你当前的操作系统。
- en: 'Once you have a bootable USB stick, you need to tell your PC to boot from it.
    Your PC is probably currently configured to boot from a hard disk, but it will
    have some method—which varies by manufacturer—to change to booting from USB as
    part of its BIOS configuration tools. Editing these settings is called “going
    into the BIOS.” On most machines it’s done by holding down a particular key for
    a few seconds as you turn on the machine. This is often ESC, DEL, F1, F2, F8,
    F10, or F11, depending on the manufacturer (if it doesn’t say which, try running
    a finger over the whole top row of the keyboard to hit them all). You’ll usually
    see some low-resolution BIOS menus: if you hunt around, there will be some way
    to specify the boot order and bring USB to the top of it. Some machines may have
    additional security features that need to be disabled before you can boot from
    a new device.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了可启动的USB闪存盘，你需要告诉你的PC从它启动。你的PC目前可能配置为从硬盘启动，但它会有某种方法——不同厂商可能会有所不同——通过其BIOS配置工具切换到从USB启动。编辑这些设置的过程称为“进入BIOS”。在大多数机器上，你可以在开机时按住某个特定的键几秒钟来进入BIOS。这通常是ESC、DEL、F1、F2、F8、F10或F11，具体取决于制造商（如果没有明确说明是哪一个，试着把手指在键盘的顶行上滑动，逐一按下）。你通常会看到一些低分辨率的BIOS菜单：如果你细心查找，会找到某种方法来指定启动顺序，并将USB置于顶部。有些机器可能会有额外的安全功能，需要在从新设备启动之前先禁用它们。
- en: '**Booting to and Programming in 64-Bit Mode**'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**以64位模式启动并进行编程**'
- en: 'Switching a modern x86 into 32- and 64-bit modes isn’t trivial. Due to historical
    baggage, it requires a couple of screens of instructions and data. How these work
    is fairly obscure, but luckily it’s a standard process that can now be done using
    the boilerplate code shown here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将现代x86切换到32位和64位模式并不简单。由于历史遗留问题，这需要几屏的指令和数据。它是如何工作的相当晦涩，但幸运的是，现在可以使用下面展示的模板代码来完成这一过程：
- en: '[PRE24]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you save this, assemble it, and put it into an ISO as for the 16-bit version,
    it will boot your real or virtual x86 into 64-bit mode and print another “Hello,
    world!” message. You can then use the “Hello, world!” program as a starting point,
    modifying it into your own bootable programs for the following tasks:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存这个文件、汇编它，并像16位版本一样放入ISO，它将启动你的真实或虚拟x86到64位模式，并打印另一个“Hello, world!”消息。然后，你可以使用这个“Hello,
    world!”程序作为起点，将其修改成自己的可启动程序，用于以下任务：
- en: Write a subroutine that reads integers and converts them into ASCII strings.
    Extend it to floating point. Use it to print out some numbers along with “Hello,
    world!”
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个子程序，读取整数并将其转换为ASCII字符串。扩展到浮点数。用它打印一些数字和“Hello, world!”消息。
- en: Try porting previous programs from the Analytical Engine and Manchester Baby
    to run on x86\. What’s gotten easier or harder to do in modern x86 compared to
    those systems?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将之前的程序从分析机和曼彻斯特宝宝移植到x86上运行。与这些系统相比，现代x86在做某些事情时变得更容易或更难了？
- en: Call the BIOS routine to light up pixels on the screen several times to draw
    a simple shape.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用BIOS例程多次点亮屏幕上的像素，绘制一个简单的图形。
- en: '**More Challenging**'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: Write a simple game such as *Space Invaders* using the above BIOS calls, on
    bare metal x86.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述BIOS调用，在裸机x86上编写一个简单的游戏，比如*太空入侵者*。
- en: Further Reading
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For the official NASM manual, see “NASM: The Netwide Assembler,” *[https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html](https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html)*.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '有关官方的NASM手册，请参阅《NASM: The Netwide Assembler》，* [https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html](https://www.nasm.us/xdoc/2.13.03/html/nasmdoc0.html)*。'
- en: 'For an overview of x86 history, see P. Lilly, “A Brief History of CPUs: 31
    Awesome Years of x86,” *Maximum PC*, April 2009, *[https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86](https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86)*.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关x86历史的概述，请参阅P. Lilly，《*CPU的简短历史：31个令人惊叹的x86年*》，*Maximum PC*，2009年4月，* [https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86](https://www.pcgamer.com/a-brief-history-of-cpus-31-awesome-years-of-x86)*。
- en: 'For the full five-volume amd64 reference set, see AMD Technology, *AMD64 Architecture
    Programmer’s Manual Volumes 1–5* (Santa Clara: AMD Technology, 2023), *[https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5](https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5)*.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关完整的五卷amd64参考集，请参阅AMD技术，《*AMD64架构程序员手册卷1-5*》（圣克拉拉：AMD技术，2023），* [https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5](https://www.amd.com/en/support/tech-docs/amd64-architecture-programmers-manual-volumes-1-5)*。
- en: 'For information on 3D graphics programming, see Graham Sellars, *Vulkan Programming
    Guide* (Boston: Addison-Wesley, 2017).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关3D图形编程的信息，请参阅Graham Sellars，《*Vulkan编程指南*》（波士顿：Addison-Wesley，2017）。
- en: For details of how the x86 boot assembly code works, see Gregor Brunmar, “The
    World of Protected Mode” (*[http://www.osdever.net/tutorials/view/the-world-of-protected-mode](http://www.osdever.net/tutorials/view/the-world-of-protected-mode)*),
    the lame_bootloader GitHub repository (*[https://github.com/sedflix/lame_bootloader](https://github.com/sedflix/lame_bootloader)*),
    and “Setting Up Long Mode” (*[https://wiki.osdev.org/Setting_Up_Long_Mode](https://wiki.osdev.org/Setting_Up_Long_Mode)*).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关x86启动汇编代码如何工作的详细信息，请参阅Gregor Brunmar，《*受保护模式的世界*》（* [http://www.osdever.net/tutorials/view/the-world-of-protected-mode](http://www.osdever.net/tutorials/view/the-world-of-protected-mode)*），lame_bootloader
    GitHub库（* [https://github.com/sedflix/lame_bootloader](https://github.com/sedflix/lame_bootloader)*），以及《设置长模式》（*
    [https://wiki.osdev.org/Setting_Up_Long_Mode](https://wiki.osdev.org/Setting_Up_Long_Mode)*）。
