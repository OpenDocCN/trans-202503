- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 CONSTANTS, VARIABLES, AND DATA TYPES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 常量、变量和数据类型
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '[Chapter 2](chapter2.xhtml) discussed the basic format for data in memory,
    and [Chapter 3](chapter3.xhtml) covered how a computer system physically organizes
    that data in memory. This chapter completes that discussion by connecting the
    concept of *data representation* to its actual physical representation. I’ll focus
    on three main topics: constants, variables, and data structures.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2 章](chapter2.xhtml)讨论了内存中数据的基本格式，和[第 3 章](chapter3.xhtml)介绍了计算机系统如何在物理上组织这些数据。这一章通过将*数据表示*的概念与其实际物理表示连接起来，完成了对这一主题的讨论。我将集中讨论三个主要话题：常量、变量和数据结构。'
- en: This chapter doesn’t assume you’ve taken a formal course in data structures,
    though such experience would be useful. You’ll learn to declare and use constants,
    scalar variables, integers, data types, pointers, arrays, structs, and unions.
    Work to master these subjects before going on to the next chapter. Declaring and
    accessing arrays, in particular, seem to present a multitude of problems to beginning
    assembly language programmers, but the rest of this text depends on your understanding
    of these data structures and their memory representation. Do not try to skim over
    this material with the expectation that you’ll pick it up as needed later; you’ll
    need to comprehensively understand it right away.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你没有接受过正式的数据结构课程，尽管这种经验会很有帮助。你将学习如何声明和使用常量、标量变量、整数、数据类型、指针、数组、结构体和联合体。在进入下一章之前，务必掌握这些主题。特别是，声明和访问数组对初学汇编语言的程序员来说，似乎存在许多问题，但本书的其余部分依赖于你对这些数据结构及其内存表示的理解。不要抱着稍后根据需要再补充的心态略过这些内容；你需要立刻全面理解它。
- en: '### 4.1 Gas Constant Declarations'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 4.1 气体常数声明'
- en: 'Probably the first place to start is with constant declarations that allow
    you to attach a name to a literal constant value. Gas provides four directives,
    collectively known as *equates*, that let you define constants in your assembly
    language programs. You’ve already seen the most common form, .equ:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的第一步是通过常量声明为文字常量值附加一个名称。Gas 提供了四个指令，统称为*等式*，允许你在汇编语言程序中定义常量。你已经看到最常用的形式，即
    .equ：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you declare a symbolic constant in this manner, you may use the symbolic
    identifier anywhere the corresponding literal constant is legal. These constants
    are known as *manifest constants*—symbolic representations that allow you to substitute
    the literal value for the symbol anywhere in the program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你以这种方式声明了符号常量，就可以在程序中任何符号常量合法的地方使用这个符号标识符。这些常量被称为*显式常量*——符号表示，允许你在程序的任何地方将符号替换为文字常量的值。
- en: NOTE
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Technically, you could also use CPP macros to define constants in Gas. See
    [Chapter 13](chapter13.xhtml) for more details.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，你也可以使用 CPP 宏在 Gas 中定义常量。详情请见[第 13 章](chapter13.xhtml)。*'
- en: 'Contrast this with .rodata objects: an .rodata value is a constant value, because
    you cannot change it at runtime. However, a memory location is associated with
    an .rodata declaration, and the OS, not the Gas assembler, enforces the read-only
    attribute. Although the following instruction sequence will crash your program
    when it runs, writing it is perfectly legal:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与 .rodata 对象进行对比：.rodata 值是常量值，因为在运行时你不能更改它。然而，内存位置与 .rodata 声明相关联，操作系统而不是
    Gas 汇编器强制执行只读属性。虽然以下指令序列在程序运行时会崩溃，但编写它是完全合法的：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the other hand, it is no more legal to write the following, using the preceding
    declaration
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用前面声明的内容写以下内容也是不合法的：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'than it is to write this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此写法相比：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, both statements are equivalent: the compiler substitutes 15 for MaxIndex
    whenever it encounters this manifest constant.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个语句是等价的：编译器在遇到这个常量时，会将 15 替换为 MaxIndex。
- en: Constant declarations are great for defining magic numbers that could change
    during program modification. Examples include constants like nl (newline), maxLen,
    and NULL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明非常适合定义在程序修改过程中可能改变的魔法数字。例子包括像 nl（换行符）、maxLen 和 NULL 这样的常量。
- en: 'The GNU .set directive uses the following syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GNU .set 指令使用以下语法：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is semantically equivalent to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语义上等价于以下内容：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both the .set and = directives allow you to redefine a symbol previously defined
    with these directives.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .set 和 = 指令都允许你重新定义之前用这些指令定义的符号。
- en: 'For example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll see how to take advantage of this feature in [Chapter 13](chapter13.xhtml),
    which discusses macros and the Gas compile-time language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在[第13章](chapter13.xhtml)中看到如何利用这个功能，那里讨论了宏和Gas的编译时语言。
- en: Note that .equ also allows you to redefine symbols in your source file. These
    many synonyms for the same directive are Gas’s attempt to maintain compatibility
    with multiple assemblers and assembler versions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，.equ也允许你重新定义源文件中的符号。这些对同一指令的多个同义词是Gas为保持与多种汇编器及其版本的兼容性所做的尝试。
- en: 'The final equate directive Gas offers is .equiv:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Gas提供的最后一个等号指令是.equiv：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unlike the other three directives, .equiv will generate an error if the symbol
    is already defined. This is therefore likely the safest equate to use, unless
    you really need to redefine symbols in your program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他三个指令不同，.equiv会在符号已经定义的情况下产生错误。因此，除非你真的需要在程序中重新定义符号，否则这很可能是最安全的等号指令。
- en: Expressions appearing in these equates are limited to 64 bits. If you specify
    a value greater than 64 bits, the assembler will report an error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在这些等号中的表达式限制为64位。如果你指定一个超过64位的值，汇编器会报告错误。
- en: 4.2 The Location Counter Operator
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 位置计数器运算符
- en: 'One very special constant you’ll frequently use is the current location counter
    value. As noted in the previous chapter, Gas will substitute the value of the
    current section’s location counter in place of an individual period (.) appearing
    in a constant expression. You could in theory use this operator to embed a pointer
    to a variable within that variable itself:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个你将经常使用的非常特殊的常量是当前的定位计数器值。如前一章所述，Gas会在常量表达式中用当前段的定位计数器的值来替代单个句点（.）。理论上，你可以使用这个运算符将指向变量的指针嵌入到该变量本身中：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, this isn’t especially useful. It’s a better idea to use the location
    counter operator to compute offsets and lengths within a particular section. If
    you subtract a label in a section from the location counter, the difference is
    the (signed) distance from that point in the code to the specified label. This
    allows you to compute string lengths, function lengths, and other values that
    involve measuring the byte distance within a section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是特别有用。更好的做法是使用位置计数器运算符来计算特定段内的偏移量和长度。如果你从位置计数器中减去段内的一个标签，得到的差值就是从代码中的那个点到指定标签的（有符号）距离。这使你能够计算字符串长度、函数长度以及其他涉及在某一段内测量字节距离的值。
- en: 'Here’s an example that uses this technique to compute a string length:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这种技术计算字符串长度的例子：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This counts all the bytes Gas emits (including the zero-terminating byte) by
    the two string directives. You can use this technique to compute the length of
    any data object, not just the characters in a string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这会计算Gas发出的所有字节（包括字符串指令的零终止字节）。你可以使用这种技术来计算任何数据对象的长度，而不仅仅是字符串中的字符。
- en: Intuitively, there is a subtle difference between the location counter constant
    (.) and a literal constant such as 0. The constant 0 will always have the same
    value wherever it appears in the source file, whereas the location counter constant
    will have a different value through the source file. An HLL would associate a
    different type with these two types of constants. The next sections discuss types
    in assembly language, including relocatable types (the location counter is a relocatable
    type in assembly language).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，位置计数器常量（.）与像0这样的字面常量之间有一个微妙的区别。常量0无论在源文件中的哪个地方出现，其值始终相同，而位置计数器常量在源文件中会有不同的值。高级语言（HLL）会将这两种常量与不同的类型关联。接下来的章节将讨论汇编语言中的类型，包括可重定位类型（位置计数器就是汇编语言中的可重定位类型）。
- en: 4.3 Data Types and Gas
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 数据类型和Gas
- en: 'Like most traditional (that is, 1960s-era) assemblers, Gas is completely *typeless*.
    It relies on you, the programmer, to make sense of all the data types you use
    in your program, via your choice of instructions. In particular, Gas will be more
    than happy to accept any of the following statements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数传统的（即1960年代的）汇编器一样，Gas是完全*无类型的*。它依赖你——程序员——通过选择指令来理解你在程序中使用的所有数据类型。特别地，Gas非常乐意接受以下任何语句：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second instruction loads 64 bits from a 32-bit variable. However, Gas accepts
    this erroneous code and loads the 64 bits at the address you specify, which might
    include the 32 bits just beyond the wv declaration you’ve placed in your .text
    section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条指令从一个32位变量加载64位数据。然而，Gas接受了这个错误的代码，并且在你指定的地址加载了64位数据，这个地址可能包括你在.text段中放置的wv声明之后的32位数据。
- en: Accessing data by using the wrong data type can lead to subtle defects within
    your code. One advantage of (strongly typed) HLLs is that they can catch most
    program errors resulting from the misuse of data types. Assembly language, however,
    provides very little in the way of type checking. Type checking is *your* responsibility
    in assembly language. Section 4.4, “Pointer Data Types,” covers this issue next
    in great detail. Also see “Relocatable and Absolute Expressions” on [page 176](chapter4.xhtml#pg_176),
    which describes one of the few cases where Gas provides a small amount of type
    checking on your code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误的数据类型访问数据可能会导致代码中出现微妙的缺陷。强类型的高阶语言（HLL）有一个优势，即能够捕捉到大多数由于数据类型误用而导致的程序错误。然而，汇编语言几乎没有类型检查。类型检查是*你*在汇编语言中的责任。接下来的4.4节“指针数据类型”将详细讨论这个问题。另见[第176页](chapter4.xhtml#pg_176)中的“可重定位和绝对表达式”，它描述了Gas在代码中提供少量类型检查的少数几种情况。
- en: '### 4.4 Pointer Data Types'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '### 4.4 指针数据类型'
- en: 'If you had a bad experience when you first encountered pointers in an HLL,
    fear not: pointers are easier to deal with in assembly language. Any problems
    you had with pointers probably had more to do with the linked-list and tree data
    structures you were trying to implement with them. Pointers, on the other hand,
    have many uses in assembly language that have nothing to do with linked lists,
    trees, and other scary data structures. Indeed, simple data structures like arrays
    and structs often involve the use of pointers.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第一次接触高阶语言（HLL）中的指针时遇到过不好的经历，不必担心：在汇编语言中，指针更容易处理。你当时遇到的指针问题可能与使用它们时试图实现的链表和树形数据结构有关。另一方面，指针在汇编语言中有许多用途，这些用途与链表、树和其他复杂的数据结构无关。实际上，像数组和结构体这样简单的数据结构通常会使用指针。
- en: A *pointer* is a memory location whose value is the address of another memory
    location. Unfortunately, HLLs like C/C++ tend to hide the simplicity of pointers
    behind a wall of abstraction. This added complexity tends to frighten programmers
    because they don’t understand what’s going on behind the scenes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针*是一个内存位置，其值是另一个内存位置的地址。不幸的是，像C/C++这样的高阶语言（HLL）往往把指针的简单性隐藏在抽象的墙后。这种额外的复杂性往往会让程序员感到害怕，因为他们不明白幕后发生了什么。'
- en: 'To illuminate how pointers work, consider the following array declaration in
    Pascal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明指针是如何工作的，考虑一下Pascal中的以下数组声明：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if you don’t know Pascal, the concept here is simple. M is an array with
    1,024 integers in it, indexed from M[0] to M[1023]. Each one of these array elements
    can hold an integer value independent of the others. In other words, this array
    gives you 1,024 integer variables, each of which you refer to by number (the array
    index).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不懂Pascal，概念也很简单。M是一个包含1,024个整数的数组，索引从M[0]到M[1023]。每个数组元素都可以独立地保存一个整数值。换句话说，这个数组给你提供了1,024个整数变量，每个变量通过数字（数组索引）进行引用。
- en: 'It’s easy to see that the statement M[0]:=100; is storing the value 100 into
    the first element of the array M. The following two statements perform an identical
    operation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，语句M[0]:=100;将值100存储到数组M的第一个元素中。以下两个语句执行相同的操作：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Indeed, you can use any integer expression in the range 0 to 1,023 as an index
    into this array. The following statements still perform the same operation as
    our single assignment to index 0:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以使用任何在0到1,023范围内的整数表达式作为该数组的索引。以下语句仍然执行与我们对索引0的单次赋值相同的操作：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '“Okay, so what’s the point?” you’re probably thinking. “Anything that produces
    an integer in the range 0 to 1,023 is legal. So what?” Consider the following
    code that adds an interesting layer of indirection:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，那到底有什么意义？”你可能会想。“任何在0到1,023范围内生成整数的东西都是合法的。那又怎样？”考虑一下下面的代码，它添加了一个有趣的间接层：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With a little thought, you should see that these two instructions perform the
    exact same operation as the previous examples. The first statement stores 0 into
    array element M[1]. The second statement fetches the value of M[1], a legal array
    index, and uses that value (0) to control where it stores the value 100.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考，你应该明白这两条指令执行的操作与之前的示例完全相同。第一条语句将0存储到数组元素M[1]中。第二条语句获取M[1]的值，这是一个合法的数组索引，并利用该值（0）来控制它存储值100的位置。
- en: 'If you’re willing to accept this as reasonable, you’ll have no problems with
    pointers. If you were to change M to *memory* and imagine that this array represents
    system memory, then M[1] is a pointer: that is, a memory location whose value
    is the address (or index) of another memory location. Pointers are easy to declare
    and use in an assembly language program; you don’t even have to worry about array
    indices.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受这一点作为合理的，你将不会遇到指针的问题。如果你将 M 改为 *memory*，并假设这个数组表示系统内存，那么 M[1] 就是一个指针：即一个内存位置，其值是另一个内存位置的地址（或索引）。指针在汇编语言程序中很容易声明和使用；你甚至不需要担心数组索引。
- en: Okay, this section has used a Pascal array as an example of a pointer, which
    is fine, but how do you use pointers in an ARM assembly language program?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，本节已经使用 Pascal 数组作为指针的示例，这没问题，但如何在 ARM 汇编语言程序中使用指针呢？
- en: 4.4.1 Pointer Usage in Assembly Language
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 汇编语言中的指针使用
- en: 'An ARM64 pointer is a 64-bit value that may contain the address of another
    variable. For a dword variable p that contains 0x1000_0000, p “points” at memory
    location 0x1000_0000\. To access the dword that p points at, you could use code
    like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ARM64 指针是一个 64 位的值，它可以包含另一个变量的地址。对于一个包含 0x1000_0000 的双字（dword）变量 p，p “指向”内存位置
    0x1000_0000。要访问 p 所指向的双字，你可以使用类似以下的代码：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By loading the value of p into X0, this code loads the value 0x1000_0000 into
    X0 (assuming p contains 0x1000_0000). The second instruction loads the X1 register
    with the dword starting at the location whose offset appears in X0\. Because X0
    now contains 0x1000_0000, this will load X1 from locations 0x1000_0000 through
    0x1000_0007.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 p 的值加载到 X0 寄存器中，这段代码将值 0x1000_0000 加载到 X0（假设 p 的值为 0x1000_0000）。第二条指令将 X1
    寄存器加载为从 X0 中偏移位置开始的双字（dword）。因为 X0 现在包含 0x1000_0000，所以这将从 0x1000_0000 到 0x1000_0007
    的位置加载 X1。
- en: Why not just load X1 directly from location 0x1000_0000, like this?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接从地址 0x1000_0000 加载 X1 呢，像这样？
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The primary reason not to do so is that this ldr instruction always loads X1
    from location varAtAddress1000_0000. You cannot change the address from where
    it loads X1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不这样做的主要原因是，这条 ldr 指令总是从位置 varAtAddress1000_0000 加载 X1。你无法更改加载 X1 的地址。
- en: 'The former instructions, however, always load X1 from the location where p
    is pointing. This is easy to change under program control. Consider the following
    pseudocode instruction sequence:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的指令总是从 p 所指向的位置加载 X1。这在程序控制下很容易改变。考虑以下伪代码指令序列：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable p with the address of the variable i. The second
    path through the code loads p with the address of the variable j. Both execution
    paths converge on the last two ldr instructions that load X1 with i or j, depending
    on which execution path was taken. In many respects, this is like a parameter
    to a procedure in an HLL like Swift. Executing the same instructions accesses
    different variables depending on whose address (i or j) winds up in p.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的例子展示了程序中的两条执行路径。第一条路径将变量 p 加载为变量 i 的地址。第二条路径将 p 加载为变量 j 的地址。两条执行路径最终汇聚到最后两条
    ldr 指令，这些指令根据执行路径加载 i 或 j 到 X1。就很多方面来说，这就像是一个类似 Swift 之类高级语言中过程的参数。执行相同的指令会根据
    p 中的地址（i 或 j）访问不同的变量。
- en: 4.4.2 Pointer Declarations in Gas
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2 Gas 中的指针声明
- en: 'Because pointers are 64 bits long, you could use the .dword directive to allocate
    storage for your pointers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为指针是 64 位长的，你可以使用 .dword 指令为你的指针分配存储空间：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in Gas. You may specify addresses of static variables (.data,
    .rodata, and .bss objects) in the operand field of a .dword directive, so you
    can initialize only pointer variables with the addresses of static objects by
    using this technique.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了在 Gas 中初始化和声明指针变量是可能的。你可以在 .dword 指令的操作数字段中指定静态变量的地址（.data、.rodata 和
    .bss 对象），因此你可以通过使用此技术，仅用静态对象的地址来初始化指针变量。
- en: Remember that macOS does not allow you to take the address of a symbol in the
    .text section because of the limitation of PIE code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，macOS 不允许你获取 .text 部分符号的地址，因为 PIE 代码的限制。
- en: 4.4.3 Pointer Constants and Expressions
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3 指针常量和表达式
- en: 'Gas allows very simple constant expressions wherever a pointer constant is
    legal. Pointer constant expressions take one of the following forms:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 允许在指针常量合法的地方使用非常简单的常量表达式。指针常量表达式具有以下几种形式：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The PureConstantExpression term is a numeric constant expression that does
    not involve any pointer constants (an *absolute constant*, using Gas terminology).
    This type of expression produces a memory address that is the specified number
    of bytes before or after (- or +, respectively) the StaticVarName variable in
    memory. The first two forms shown here are semantically equivalent: both return
    a pointer constant whose address is the sum of the static variable and the constant
    expression.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PureConstantExpression术语是一个数值常量表达式，不涉及任何指针常量（使用Gas术语称为*绝对常量*）。这种类型的表达式生成一个内存地址，该地址位于StaticVarName变量前后指定字节数的位置（分别为-或+）。这里展示的前两种形式语义上是等效的：它们都返回一个指针常量，其地址是静态变量和常量表达式的和。
- en: Since you can create pointer constant expressions, it should come as no surprise
    that Gas lets you define manifest pointer constants by using equates. Listing
    4-1 demonstrates how to do this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可以创建指针常量表达式，Gas允许您通过使用等式定义显式指针常量，这也就不足为奇了。列表4-1演示了如何做到这一点。
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The equate pb = bb + 2 initializes the constant pb with the address of the
    third element ❶ (index 2) of the bb array. The pbVar: .dword pb declaration ❷
    creates a pointer variable (named pbVar) and initializes with the value of the
    pb constant. Because pb is the address of bb[2], this statement initializes pbVar
    with the address of bb[2]. The program stores the value held in pbVar into the
    pbValue variable ❸, then passes pbVar ❹ and pbValue ❺ to printf() to print their
    values.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '等式pb = bb + 2将常量pb初始化为bb数组中第三个元素❶（索引为2）的地址。声明pbVar: .dword pb ❷创建一个指针变量（命名为pbVar），并将pb常量的值初始化给它。因为pb是bb[2]的地址，所以这条语句将pbVar初始化为bb[2]的地址。程序将pbVar中存储的值存入pbValue变量❸，然后将pbVar❹和pbValue❺传递给printf()函数以打印它们的值。'
- en: 'Here’s the build command and sample output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建命令和示例输出：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The address that’s printed may vary on different machines and OSes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出来的地址在不同的机器和操作系统上可能会有所不同。
- en: 4.4.4 Pointer Variables and Dynamic Memory Allocation
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4 指针变量与动态内存分配
- en: Pointer variables are the perfect place to store the return result from the
    C stdlib malloc() function. This function returns the address of the storage it
    allocates in the X0 register; therefore, you can store the address directly into
    a pointer variable immediately after a call to malloc(). Listing 4-2 demonstrates
    calls to the C stdlib malloc() and free() functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 指针变量是存储C标准库malloc()函数返回结果的完美位置。该函数返回它分配的存储地址，通过X0寄存器返回；因此，您可以在调用malloc()之后直接将地址存入指针变量。列表4-2演示了调用C标准库malloc()和free()函数的过程。
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because malloc() ❶ and free() ❷ have only a single argument, you pass those
    arguments to them in the X0 register. For the call to malloc(), you pass an integer
    value specifying the amount of storage you want to allocate on the heap. For free(),
    you pass the pointer to the storage (previously allocated by malloc()) that you
    want to return back to the system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于malloc()❶和free()❷只有一个参数，您将这些参数通过X0寄存器传递给它们。对于malloc()的调用，您传递一个整数值，指定您希望在堆上分配的存储量。对于free()，您传递指向要返回给系统的存储（之前由malloc()分配）的指针。
- en: 'Here’s the build command and sample output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建命令和示例输出：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, the addresses you get will vary by OS and perhaps even by different
    runs of the program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如常所见，您获得的地址会因操作系统不同，甚至因程序运行不同而有所变化。
- en: 4.4.5 Common Pointer Problems
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.5 常见指针问题
- en: 'In most programming languages, programmers encounter five common problems.
    Some of these errors will cause your programs to immediately stop with a diagnostic
    message; other problems are subtler, yielding incorrect results or simply affecting
    the performance of your program without otherwise reporting an error. These five
    problems are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，程序员会遇到五种常见问题。其中一些错误会导致程序立即停止并显示诊断消息；而其他问题则更为隐蔽，可能会导致不正确的结果，或者仅仅影响程序的性能而没有报告错误。这五个问题如下：
- en: Using an uninitialized pointer (illegal memory access)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的指针（非法内存访问）
- en: Using a pointer that contains an illegal value (for example, NULL)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含非法值的指针（例如，NULL）
- en: Continuing to use malloc()’d storage after that storage has been freed
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储已被释放后继续使用通过malloc()分配的存储
- en: Failing to free() storage once the program is finished using it
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序使用完存储后未调用free()释放存储
- en: Accessing indirect data using the wrong data type
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误数据类型访问间接数据
- en: The following subsections describe each of these problems, their effects, and
    how to avoid them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子章节描述了这些问题的每个方面、其影响以及如何避免它们。
- en: 4.4.5.1 Illegal Memory Access Due to an Uninitialized Pointer
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.4.5.1 由于未初始化指针导致的非法内存访问
- en: Beginning programmers often don’t realize that declaring a pointer variable
    reserves storage only for the pointer itself; it does not reserve storage for
    the data that the pointer references. Therefore, you’ll run into problems if you
    attempt to dereference a pointer that does not contain the address of a valid
    memory location. Listing 4-3 demonstrates this problem (don’t try to compile and
    run this program; it will crash).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者往往没有意识到，声明一个指针变量只会为指针本身保留存储空间；它并不会为指针所引用的数据保留存储空间。因此，如果你尝试取消引用一个不包含有效内存地址的指针，就会遇到问题。列表4-3演示了这个问题（不要尝试编译和运行这个程序；它会崩溃）。
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although variables you declare in the .data section are, technically, initialized,
    static initialization still doesn’t initialize the pointer in this program ❶ with
    a valid address (but instead with a 0, which is NULL).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在.data段声明的变量从技术上来说是初始化过的，静态初始化仍然没有为程序中的指针❶提供一个有效的地址（而是用0，即NULL）。
- en: Of course, there is no such thing as a truly uninitialized variable on the ARM.
    There are variables that you’ve explicitly given an initial value, and there are
    variables that happen to inherit whatever bit pattern was in memory when storage
    for the variable was allocated. Much of the time, these garbage bit patterns don’t
    correspond to a valid memory address. Attempting to *dereference* such a pointer
    (that is, access the data in memory at which it points ❷) typically raises a *memory
    access violation* exception (segmentation fault).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在ARM架构上没有真正未初始化的变量。你可以显式地为某个变量赋予初始值，也可以有些变量继承了分配存储空间时内存中的任意位模式。很多时候，这些垃圾位模式并不对应有效的内存地址。试图*取消引用*这样的指针（即访问指针指向的内存中的数据❷）通常会引发*内存访问违规*异常（段错误）。
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse, since your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    overwrite the values of other important variables in memory. This defect can produce
    some difficult-to-locate problems in your program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时这些内存中的随机位恰好对应于一个你可以访问的有效内存位置。在这种情况下，CPU将访问指定的内存位置而不会终止程序。虽然对一个天真的程序员来说，这种情况看起来可能比停止程序更可取，但实际上这更糟糕，因为你的有缺陷的程序继续运行而没有提醒你出现问题。如果你通过一个未初始化的指针存储数据，你可能会覆盖内存中其他重要变量的值。这个缺陷可能会在你的程序中产生一些难以定位的问题。
- en: 4.4.5.2 Invalid Addresses
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.4.5.2 无效地址
- en: 'The second common problem is storing invalid address values into a pointer.
    The previous problem is actually a special case of this second problem (with garbage
    bits in memory supplying the invalid address, rather than you producing it via
    a miscalculation). The effects are the same: if you attempt to dereference a pointer
    containing an invalid address, you either will get a memory access violation exception
    or will access an unexpected memory location.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个常见的问题是将无效的地址值存入指针中。前一个问题实际上是第二个问题的一个特例（无效地址是由内存中的垃圾位提供的，而不是你通过错误计算产生的）。其后果是相同的：如果你尝试取消引用一个包含无效地址的指针，要么会发生内存访问违规异常，要么会访问一个意外的内存位置。
- en: '##### 4.4.5.3 The Dangling Pointer Problem'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 4.4.5.3 悬空指针问题'
- en: 'The third problem, continuing to use malloc()’d storage after that storage
    has been freed, is also known as the *dangling pointer problem*. To understand
    this problem, consider the following code fragment:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是在释放内存后继续使用通过malloc()分配的存储，这也被称为*悬空指针问题*。为了理解这个问题，考虑以下代码片段：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code allocates 256 bytes of storage and saves the address of that storage
    in the ptrVar variable. It then uses this block of 256 bytes for a while and frees
    the storage, returning it to the system for other uses.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码分配了256字节的存储空间，并将该存储的地址保存在ptrVar变量中。它随后使用这块256字节的存储一段时间，并释放该存储，将其返还给系统用于其他用途。
- en: Calling free() does not change the value of ptrVar in any way; ptrVar still
    points at the block of memory allocated by malloc() earlier. The value in ptrVar
    is a *dangling pointer*, or *wild pointer*—a pointer that is pointing at deallocated
    storage. In this example, free() does not change any data in the block allocated
    by malloc(), so upon return from free(), ptrVar still points at the data stored
    into the block by this code. However, the call to free() tells the system that
    the program no longer needs this 256-byte block of memory, so the system can use
    this region of memory for other purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调用free()不会以任何方式改变ptrVar的值；ptrVar仍然指向之前malloc()分配的内存块。ptrVar中的值是一个*悬空指针*，或者称为*野指针*——它指向一个已被释放的存储。在这个例子中，free()并没有改变malloc()分配的内存块中的任何数据，因此在从free()返回后，ptrVar仍然指向该块中由这段代码存储的数据。然而，调用free()会告诉系统程序不再需要这个256字节的内存块，因此系统可以将这块内存用于其他用途。
- en: The free() function cannot enforce the fact that you will never access this
    data again; you are simply promising that you won’t. Of course, the preceding
    code fragment breaks this promise; as you can see in the last three instructions,
    the program fetches the value in ptrVar and accesses the data it points at in
    memory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: free()函数无法强制保证你永远不会再访问这些数据；你只是承诺你不会这样做。当然，前面的代码段破坏了这个承诺；正如你在最后三条指令中看到的，程序取出了ptrVar中的值，并访问了它指向的内存数据。
- en: 'The biggest problem with dangling pointers is that you can often get away with
    using them. As long as the system doesn’t reuse the storage you’ve freed, a dangling
    pointer produces no ill effects. However, with each new call to malloc(), the
    system may decide to reuse the memory released by that previous call to free().
    When this happens, any attempt to dereference the dangling pointer may produce
    unintended consequences. The problems range from reading data that has been overwritten
    (by the new, legal use of the data storage), to overwriting the new data, to,
    in the worst case, overwriting system heap management pointers and likely crashing
    your program. The solution is clear: *never use a pointer value after you free
    the storage associated with that pointer.*  ##### 4.4.5.4 Memory Leaks'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 悬空指针最大的问题是，你通常可以不受影响地使用它们。只要系统没有重用你已释放的存储，悬空指针不会产生负面影响。然而，每次调用malloc()时，系统可能决定重用前一次调用free()释放的内存。当这种情况发生时，任何尝试解引用悬空指针的操作都可能产生意想不到的后果。问题可能从读取被覆盖的数据（由新的、合法的数据存储使用覆盖）开始，到覆盖新数据，再到最坏的情况，覆盖系统堆管理指针，最终导致程序崩溃。解决方案很明确：*在释放与指针相关的存储后，绝不再使用该指针的值*。#####
    4.4.5.4 内存泄漏
- en: 'Of all the pointer problems listed at the beginning of this section, failing
    to free allocated storage will probably have the least negative impact. The following
    code fragment demonstrates this problem:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开始时列出的所有指针问题中，未释放分配的存储可能会对程序产生最小的负面影响。以下代码片段演示了这个问题：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the program allocates 256 bytes of storage and references it
    by using the ptrVar variable. Later, the program allocates another block of bytes
    and overwrites the value in ptrVar with the address of this new block. The former
    value in ptrVar is lost. Because the program no longer has this address value,
    there is no way to call free() to return the storage for later use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序分配了256字节的存储，并通过ptrVar变量引用它。之后，程序分配了另一个字节块，并用这个新块的地址覆盖ptrVar中的值。原本在ptrVar中的值丢失了。由于程序不再拥有这个地址值，无法调用free()来释放存储，以供后续使用。
- en: As a result, these 256 bytes of memory are no longer available to your program.
    While this may seem like only a minor cost, imagine that this code is in a repeating
    loop. With each execution of the loop, the program loses another 256 bytes of
    memory, eventually exhausting the memory available on the heap. This problem is
    often called a *memory leak*, because it’s as though the memory bits are leaking
    out of your computer during program execution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，这256字节的内存不再可用于你的程序。虽然这看起来只是一个小成本，但假设这段代码处于一个重复循环中。每次执行循环时，程序都会失去另外256字节的内存，最终耗尽堆内存中可用的空间。这个问题通常被称为*内存泄漏*，因为它就像是内存中的位在程序执行过程中不断从计算机中“泄漏”出来。
- en: 'Memory leaks are far less damaging than dangling pointers. They create only
    two problems: the danger of running out of heap space (which ultimately may cause
    the program to abort, though this is rare) and performance problems due to virtual
    memory page swapping. Nevertheless, you should get in the habit of always freeing
    all storage after you have finished using it. When your program quits, the OS
    reclaims all storage, including the data lost via memory leaks. Therefore, memory
    lost via a leak is lost only to your program, not to the whole system.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏比悬挂指针危害小得多。它们只会带来两个问题：堆空间可能耗尽的危险（这最终可能导致程序中止，尽管这种情况很少发生）和由于虚拟内存页面交换导致的性能问题。尽管如此，你应该养成在使用完所有存储后始终释放它们的习惯。当程序退出时，操作系统会回收所有存储，包括由于内存泄漏丢失的数据。因此，通过内存泄漏丢失的内存仅对你的程序丢失，而不是整个系统。
- en: 4.4.5.5 Lack of Type-Safe Access
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.4.5.5 缺乏类型安全访问
- en: Because Gas cannot and does not enforce pointer type checking, you can load
    the address of a data structure into a register and access that data as though
    it were a completely different type (often resulting in logic errors in your program).
    For example, consider Listing 4-4.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Gas 无法也不执行指针类型检查，你可以将数据结构的地址加载到寄存器中，并将该数据当作完全不同的类型进行访问（这通常会导致程序中的逻辑错误）。例如，考虑清单
    4-4。
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are the commands to build and run the program in Listing 4-4:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建并运行清单 4-4 中程序的命令：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 4-4 reads data from the user as character values and then displays the
    data as double-word hexadecimal values. While assembly language lets you ignore
    data types at will and automatically coerce the data without any effort, this
    power is a double-edged sword. If you make a mistake and access indirect data
    by using the wrong data type, Gas and the ARM may not catch the mistake and your
    program may produce inaccurate results. Therefore, you need to ensure that you
    use data consistently with respect to data type when working with pointers and
    indirection in your programs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-4 从用户读取数据作为字符值，然后将数据以双字节十六进制值的形式显示。虽然汇编语言允许你随意忽略数据类型并自动将数据强制转换，而无需任何努力，但这种能力是一把双刃剑。如果你犯了错误，使用错误的数据类型访问间接数据，Gas
    和 ARM 可能不会捕捉到这个错误，导致程序产生不准确的结果。因此，在使用指针和间接访问数据时，你需要确保在数据类型上保持一致。
- en: 'This demonstration program has one fundamental flaw that could create a problem
    for you: when reading the last two characters of the input buffer, the program
    accesses data beyond the characters input by the user. If the user inputs 255
    characters (plus the zero-terminating byte that readLine() appends), this program
    will access data beyond the end of the buffer allocated by malloc(). In theory,
    this could cause the program to crash. This is yet another problem that can occur
    when accessing data by using the wrong type via pointers.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示程序有一个基本的缺陷，可能会给你带来问题：当读取输入缓冲区的最后两个字符时，程序访问了用户输入的字符之外的数据。如果用户输入 255 个字符（加上
    readLine() 添加的零终止字节），这个程序将访问 malloc() 分配的缓冲区末尾之外的数据。理论上，这可能导致程序崩溃。这又是一个在通过指针访问数据时使用错误类型可能发生的问题。
- en: Despite all the problems that pointers suffer from, they are essential for accessing
    common data structures such as arrays, structs, and strings. That’s why this chapter
    discussed pointers prior to these other *composite data types*. However, with
    the discussion of pointers out of the way, it’s time to look at those other data
    types.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管指针存在许多问题，它们在访问常见数据结构（如数组、结构体和字符串）时是必不可少的。因此，本章在介绍这些其他 *复合数据类型* 之前讨论了指针。然而，随着指针部分讨论完毕，现在是时候看看这些其他数据类型了。
- en: 4.5 Composite Data Types
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 复合数据类型
- en: '*Composite data types*, also known as *aggregate data types*, are those that
    are built up from other, generally scalar, data types. A string, for example,
    is a composite data type, since it’s built from a sequence of individual characters
    and other data. The following sections cover several of the more important composite
    data types: character strings, arrays, multidimensional arrays, structs, and unions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合数据类型*，也叫做 *聚合数据类型*，是由其他通常是标量类型的数据构建而成的。例如，字符串就是一种复合数据类型，因为它是由一系列单独的字符和其他数据构成的。以下各节将介绍几种重要的复合数据类型：字符字符串、数组、多维数组、结构体和联合体。'
- en: 4.6 Character Strings
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6 字符字符串
- en: After integer values, character strings are probably the most common data type
    that modern programs use. This section provides a couple definitions of character
    strings (the ubiquitous zero-terminated string, the more efficient length-prefixed
    string, and other combinations of the two) and discusses how to process those
    strings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数值之后，字符字符串可能是现代程序中使用的最常见数据类型。本节提供了几种字符字符串的定义（普遍使用的零终止字符串、效率更高的长度前缀字符串以及这两者的其他组合），并讨论了如何处理这些字符串。
- en: 'In general, a *character string* is a sequence of ASCII characters that possesses
    two main attributes: a length and character data. Different languages use different
    data structures to represent strings. For assembly language (at least, sans any
    library routines), you can choose to implement strings in whichever format you
    want—perhaps based on the format’s compatibility with an HLL or on a desire to
    produce faster string functions. All you need do is create a sequence of machine
    instructions to process the string data in whatever format the strings take.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*字符字符串*是一个由 ASCII 字符组成的序列，具有两个主要属性：长度和字符数据。不同的语言使用不同的数据结构来表示字符串。对于汇编语言（至少在没有库函数的情况下），你可以选择以任何格式实现字符串——可能基于格式与高级语言（HLL）的兼容性，或者希望提高字符串函数的执行速度。你所需要做的就是创建一系列机器指令，以处理字符串数据，不管字符串采用何种格式。
- en: It’s also possible for strings to hold Unicode characters. This section uses
    ASCII in all the examples (because Gas does a better job of supporting ASCII characters).
    The principles apply to Unicode as well, with an appropriate extension in the
    amount of storage you use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以包含 Unicode 字符。本节中的所有示例使用 ASCII（因为 Gas 更好地支持 ASCII 字符）。这些原理同样适用于 Unicode，只需要相应地扩展所使用的存储量。
- en: 4.6.1 Zero-Terminated Strings
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.1 零终止字符串
- en: 'Zero-terminated strings are the most common string representation in use today,
    since this is the native string format for C, C++, and other languages. A *zero-terminated
    string* consists of a sequence of zero or more ASCII characters ending with a
    0 byte. For example, in C/C++, the string "abc" requires 4 bytes: the three characters
    a, b, and c, followed by a byte containing 0.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串是当前使用最广泛的字符串表示形式，因为这是 C、C++ 和其他语言的本地字符串格式。*零终止字符串*由一个或多个 ASCII 字符组成，以一个
    0 字节结束。例如，在 C/C++ 中，字符串 "abc" 需要 4 个字节：三个字符 a、b 和 c，后跟一个包含 0 的字节。
- en: 'To create zero-terminated strings in Gas, simply use the .asciz directive.
    The easiest place to do this is in the .data section, using code like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Gas 中创建零终止字符串，只需使用 .asciz 指令。最简单的方法是将其放在 .data 部分，代码如下：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Whenever a character string appears in the .asciz directive, as it does here,
    Gas emits each character in the string to successive memory locations and terminates
    the whole string with a 0 byte.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每当字符字符串出现在 .asciz 指令中，如此处所示，Gas 会将字符串中的每个字符输出到连续的内存位置，并以一个 0 字节终止整个字符串。
- en: 'There are a couple of ways to accommodate a zero-terminated string that’s longer
    than a single source line. First, you can use .ascii directives for all but the
    last source code line in a long string. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度超过单行源代码的零终止字符串，有几种处理方法。首先，你可以对长字符串中的每一行源代码，除了最后一行，使用 .ascii 指令。例如：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The .asciz directive zero-terminates the entire string. However, if you prefer,
    you can always use a .byte directive to explicitly add the zero-terminating byte
    yourself:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: .asciz 指令会将整个字符串以零字节终止。但是，如果你愿意，你总是可以使用 .byte 指令显式地自己添加零终止字节：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use whichever scheme you like. Some people prefer the explicit .byte directive
    because it’s easy to add and remove strings from the list without having to worry
    about changing .ascii to .asciz (or vice versa).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的方案。一些人更倾向于使用显式的 .byte 指令，因为它容易添加或删除字符串，而不必担心将 .ascii 改为 .asciz（或反之亦然）。
- en: 'Zero-terminated strings have two principal attributes: they are simple to implement,
    and the strings can be any length. However, they also have a few drawbacks. First,
    zero-terminated strings cannot contain the NUL character (whose ASCII code is
    0). Generally, this isn’t a problem, but it does create havoc once in a while.
    Second, many operations on zero-terminated strings are somewhat inefficient. For
    example, to compute the length of a zero-terminated string, you must scan the
    entire string looking for that 0 byte (counting characters up to the 0). The following
    program fragment demonstrates how to compute the length of the preceding string:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串有两个主要特点：它们易于实现，并且字符串的长度可以是任意的。然而，它们也有一些缺点。首先，零终止字符串不能包含 NUL 字符（其 ASCII
    码为 0）。通常这不会是问题，但偶尔也会造成困扰。其次，许多零终止字符串的操作效率较低。例如，要计算零终止字符串的长度，你必须扫描整个字符串，寻找那个 0
    字节（计算字符直到 0 字节）。下面的程序片段展示了如何计算前面字符串的长度：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code saves the initial string address (in X2), then subtracts the final
    pointer (just beyond the 0 byte) from the initial address to compute the length.
    The extra sub (by 1) is present because we don’t normally include the zero-terminating
    byte in the string’s length.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码保存了初始字符串地址（在 X2 中），然后通过将最终指针（刚好在 0 字节之后）与初始地址相减来计算长度。额外的减 1 操作是因为我们通常不将零终止字节计入字符串的长度。
- en: As you can see, the time it takes to compute the length of the string is proportional
    to the length of the string; as the string gets longer, computing its length takes
    longer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，计算字符串长度所需的时间与字符串的长度成正比；随着字符串变长，计算其长度的时间也变得更长。
- en: 4.6.2 Length-Prefixed Strings
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.2 长度前缀字符串
- en: 'The length-prefixed string format overcomes some of the problems with zero-terminated
    strings. *Length-prefixed strings* are common in languages like Pascal; they generally
    consist of a length byte followed by zero or more character values. The first
    byte specifies the string length, and the following bytes (up to the specified
    length) are the character data. In a length-prefixed scheme, the string "abc"
    would consist of 4 bytes: 3 (the string length) followed by a, b, and c. You can
    create length-prefixed strings in Gas by using code like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串格式克服了零终止字符串的一些问题。*长度前缀字符串* 在像 Pascal 这样的语言中很常见；它们通常由一个长度字节和零个或多个字符值组成。第一个字节指定字符串的长度，接下来的字节（直到指定的长度）是字符数据。在长度前缀方案中，字符串
    "abc" 将由 4 个字节组成：3（字符串长度），后跟 a、b 和 c。你可以通过以下代码在 Gas 中创建长度前缀字符串：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    Gas automatically compute the string length for you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提前计算字符数并将其插入到字节语句中，像这里做的那样，可能看起来是一件非常麻烦的事。幸运的是，有方法可以让 Gas 自动为你计算字符串的长度。
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (for example, string length) are more efficient when using length-prefixed strings.
    However, length-prefixed strings have their own drawbacks; most important, they
    are limited to a maximum of 255 characters in length (assuming a 1-byte length
    prefix).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串解决了零终止字符串的两个主要问题。长度前缀字符串可以包含 NUL 字符，而在零终止字符串上进行的相对低效的操作（例如，字符串长度）在使用长度前缀字符串时更加高效。然而，长度前缀字符串也有其缺点；最重要的是，它们的最大长度限制为
    255 个字符（假设使用 1 字节长度前缀）。
- en: Of course, if you have a problem with a string-length limitation of 255 characters,
    you can always create a length-prefixed string by using any number of bytes for
    the length as you need. For example, the High-Level Assembler (HLA) uses a 4-byte
    length variant of length-prefixed strings, allowing strings up to 4GB long. (See
    section 4.11, “For More Information,” on [page 221](chapter4.xhtml#pg_221) for
    more on the HLA.) In assembly language, you can define string formats however
    you like.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你遇到 255 字符的字符串长度限制问题，可以通过使用所需字节数来创建长度前缀字符串。例如，高级汇编语言（HLA）使用 4 字节长度变体的长度前缀字符串，允许字符串的长度达到
    4GB。（有关 HLA 的更多信息，请参见第 4.11 节，[第 221 页](chapter4.xhtml#pg_221)。）在汇编语言中，你可以根据需要定义字符串格式。
- en: 'To create length-prefixed strings in your assembly language programs, you don’t
    want to manually count the characters in the string and emit that length in your
    code. It’s far better to have the assembler do this kind of grunt work for you
    by using the location counter operator (.), as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在汇编语言程序中创建长度前缀字符串，你不想手动计算字符串中的字符并在代码中输出该长度。最好让汇编器通过使用位置计数器操作符（.）为你完成这类繁重的工作，如下所示：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The lpsLen operand subtracts 1 in the address expression because
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: lpsLen 操作数在地址表达式中减去 1，因为
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: also includes the length prefix byte, which isn’t considered part of the string
    length.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还包括长度前缀字节，这不被视为字符串长度的一部分。
- en: Gas does not require you to define lpsLen before using it as the operand field
    in the .byte directive. Gas is smart enough to go back and fill in the value after
    it is defined in the equate statement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 不要求你在使用 .byte 指令中的操作数字段之前定义 lpsLen。Gas 足够聪明，可以在它在等式语句中定义之后回溯并填充该值。
- en: 4.6.3 String Descriptors
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.3 字符串描述符
- en: Another common string format is a string descriptor. A *string descriptor* is
    typically a small data structure (see section 4.8, “Structs,” on [page 212](chapter4.xhtml#pg_212))
    that contains several pieces of data describing a string.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的字符串格式是字符串描述符。*字符串描述符* 通常是一个小型数据结构（见第 4.8 节，“结构体”，在[第 212 页](chapter4.xhtml#pg_212)），包含描述字符串的多个数据项。
- en: At a bare minimum, a string descriptor will probably have a pointer to the actual
    string data and a field specifying the number of characters in the string (that
    is, the string length). Other possible fields might include the number of bytes
    currently occupied by the string, the maximum number of bytes the string could
    occupy, the string encoding (for example, ASCII, Latin-1, UTF-8, or UTF-16), and
    any other information the string data structure’s designer could dream up.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，字符串描述符可能会有指向实际字符串数据的指针和一个字段，指定字符串中的字符数（即字符串长度）。其他可能的字段包括当前字符串占用的字节数、字符串可能占用的最大字节数、字符串编码（例如，ASCII、Latin-1、UTF-8
    或 UTF-16），以及字符串数据结构设计者可能想到的其他信息。
- en: By far, the most common descriptor format incorporates a pointer to the string’s
    data and a size field specifying the number of bytes currently occupied by that
    string data. Note that this particular string descriptor is not the same thing
    as a length-prefixed string. In a length-prefixed string, the length immediately
    precedes the character data itself. In a descriptor, the length and a pointer
    are kept together, and this pair is (usually) separate from the character data
    itself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，最常见的描述符格式包含指向字符串数据的指针以及一个大小字段，指定当前由该字符串数据占用的字节数。请注意，这种特定的字符串描述符与长度前缀字符串不同。在长度前缀字符串中，长度紧接在字符数据之前。在描述符中，长度和指针一起存放，通常与字符数据本身是分开的。
- en: 4.6.4 Pointers to Strings
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.4 指向字符串的指针
- en: Often, an assembly language program won’t directly work with strings appearing
    in the .data (or .text, .rodata, or .bss) section. Instead, the program will work
    with pointers to strings (including strings whose storage the program has dynamically
    allocated with a call to a function like malloc()). Listing 4-4 provided a simple
    (though broken) example. In such applications, your assembly code will typically
    load a pointer to a string into a base register and then use a second (index)
    register to access individual characters in the string.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，汇编语言程序不会直接处理出现在 .data（或 .text、.rodata、.bss）部分的字符串。相反，程序会处理指向字符串的指针（包括程序通过调用
    malloc() 等函数动态分配存储的字符串）。清单 4-4 提供了一个简单（但有缺陷）的示例。在这种应用中，汇编代码通常会将指向字符串的指针加载到基址寄存器中，然后使用第二个（索引）寄存器访问字符串中的单个字符。
- en: 4.6.5 String Functions
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.5 字符串函数
- en: Unfortunately, few assemblers provide a set of string functions you can call
    from your assembly language programs. As an assembly language programmer, you’re
    expected to write these functions on your own. Fortunately, a couple of solutions
    are available if you don’t quite feel up to the task.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，少数汇编器提供你可以从汇编语言程序中调用的字符串函数。作为汇编语言程序员，你需要自己编写这些函数。幸运的是，如果你觉得自己没有足够的能力来完成这个任务，还是有一些解决方案可以使用的。
- en: The first set of string functions you can call, without having to write them
    yourself, are the C stdlib string functions from the *string.h* header file in
    C. Of course, you’ll have to use C strings (zero-terminated strings) in your code
    when calling C stdlib functions, but this generally isn’t a big problem. Listing
    4-5 provides examples of calls to various C string functions, further described
    in [Appendix E](appendix-E.xhtml).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用的第一组字符串函数，且无需自己编写，是 C 标准库中的字符串函数，这些函数位于 C 的 *string.h* 头文件中。当然，在调用 C 标准库函数时，你必须在代码中使用
    C 字符串（以零终止的字符串），但这通常不是一个大问题。列表 4-5 提供了调用各种 C 字符串函数的示例，详细描述请见 [附录 E](appendix-E.xhtml)。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the build command and sample output from Listing 4-5:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自列表 4-5 的构建命令和示例输出：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, you could make a good argument that if all your assembly code does
    is call a bunch of C stdlib functions, you should have written your application
    in C in the first place. Most of the benefits of writing code in assembly language
    happen only when you “think” in assembly language, not C.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以提出一个有力的论点，如果你的所有汇编代码只是调用一堆 C 标准库函数，那么你本应一开始就用 C 编写应用程序。编写汇编语言代码的主要好处仅在于你“用”汇编语言思考，而不是
    C。
- en: In particular, you can dramatically improve the performance of your string function
    calls if you stop using zero-terminated strings and switch to another string format
    (such as length-prefixed or descriptor-based strings that include a length component).
    [Chapter 14](chapter14.xhtml) presents some pure assembly string functions for
    those who want to avoid the inefficiencies of using zero-terminated strings with
    the C stdlib.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果你停止使用零终止字符串并改用另一种字符串格式（如长度前缀或基于描述符的字符串，其中包含长度组件），你可以显著提高字符串函数调用的性能。对于那些希望避免使用零终止字符串与
    C 标准库一起使用的低效性的读者，[第 14 章](chapter14.xhtml)介绍了一些纯汇编字符串函数。
- en: 4.7 Arrays
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7 数组
- en: Along with strings, arrays are probably the most commonly used composite data
    type. Yet most beginning programmers don’t understand their internal operation
    or their associated efficiency trade-offs. It’s surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，数组可能是最常用的复合数据类型。然而，大多数初学者并不了解它们的内部操作或相关的效率权衡。令人惊讶的是，很多初学者（甚至是高级程序员！）一旦学会如何在机器级别处理数组后，就会从完全不同的角度来看待数组。
- en: Abstractly, an *array* is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index
    (or other ordinal type such as Boolean or character). Different indices select
    unique elements of the array. This book assumes that the integer indices are contiguous,
    though this is by no means required. That is, if the number *x* is a valid index
    into the array and *y* is also a valid index, with *x* < *y*, then all *i* such
    that *x* < *i* < *y* are valid indices. Most HLLs use contiguous array indices,
    and they are the most efficient to use, hence their use here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的角度来看，*数组*是一种聚合数据类型，其成员（元素）类型相同。选择数组中的成员是通过整数索引（或其他顺序类型，如布尔值或字符）。不同的索引选择数组中的独特元素。本书假设整数索引是连续的，尽管这并非必须的。也就是说，如果数字
    *x* 是有效的数组索引，且 *y* 也是有效的索引，且 *x* < *y*，那么所有满足 *x* < *i* < *y* 的 *i* 都是有效的索引。大多数高级语言使用连续的数组索引，它们是最有效的，因此在此使用。
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, A[i] chooses the *i*th element
    from array A. There is no formal requirement that element i be anywhere near element
    i + 1 in memory; the definition of an array is satisfied as long as A[i] always
    refers to the same memory location and A[i + 1] always refers to its corresponding
    location (and the two are different).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将索引操作符应用于数组时，结果就是由该索引选择的特定数组元素。例如，A[i] 选择数组 A 中的第 *i* 个元素。在内存中，并没有正式要求元素
    i 和元素 i + 1 彼此接近；只要 A[i] 始终指向相同的内存位置，且 A[i + 1] 始终指向其对应位置（并且两者不同），那么数组的定义就满足要求。
- en: As noted, this book assumes that array elements occupy contiguous locations
    in memory. An array with five elements will appear in memory as shown in [Figure
    4-1](chapter4.xhtml#fig4-1).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本书假设数组元素占据内存中的连续位置。具有五个元素的数组将在内存中显示为 [图 4-1](chapter4.xhtml#fig4-1) 所示。
- en: '![](../images/Figure4-1.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.jpg)'
- en: 'Figure 4-1: An array layout in memory'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：内存中的数组布局
- en: The *base address* of an array is the address of that array’s first element
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Indices are not required to start at 0\. They may start with any number as long
    as they are contiguous. However, for the purposes of discussion, this book starts
    all indices at 0.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*基地址*是该数组第一个元素的地址，并且总是出现在最低的内存位置。第二个数组元素紧跟在第一个元素后面，第三个元素紧跟在第二个元素后面，以此类推。索引不一定要求从0开始。它们可以从任何数字开始，只要是连续的。然而，为了讨论的方便，本书将所有索引从0开始。
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组的元素，你需要一个函数将数组索引转换为被索引元素的地址。对于一维数组，这个函数非常简单：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, Initial_Index is the value of the first index in the array (which you
    can ignore if it’s 0), and the value Element_Size is the size, in bytes, of an
    individual array element (this may include padding bytes used to keep elements
    properly aligned).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Initial_Index 是数组中第一个索引的值（如果为 0，则可以忽略），Element_Size 是单个数组元素的大小，以字节为单位（这可能包括用于保持元素对齐的填充字节）。
- en: 4.7.1 Declaring Arrays in Gas Programs
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.7.1 在 Gas 程序中声明数组
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you’ve already
    seen. To allocate *n* elements in an array, you would use a declaration like the
    following in one of the variable declaration sections:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问数组元素之前，必须为该数组预留存储空间。幸运的是，数组声明基于你已经看到的声明。为了为数组分配 *n* 个元素，你可以在其中一个变量声明部分使用如下声明：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ArrayName is the name of the array variable, n is the number of array elements,
    element_size is the size (in bytes) of a single element, and initial_value is
    the initial value to assign to each array element. The element_size and initial
    _value arguments are optional, defaulting to 1 and 0, respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayName 是数组变量的名称，n 是数组元素的数量，element_size 是单个元素的大小（以字节为单位），initial_value 是要分配给每个数组元素的初始值。element_size
    和 initial_value 参数是可选的，默认为 1 和 0。
- en: 'For example, to declare an array of sixteen 32-bit words, you could use the
    following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要声明一个包含 16 个 32 位字的数组，可以使用以下代码：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This would set aside sixteen 4-byte words, each initialized with 0 (the default
    initial value).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为 16 个 4 字节的字保留空间，每个字的初始值为 0（默认初始值）。
- en: The value for element_size must not exceed 8; if it does, Gas will clip the
    value to 8\. For historical (Gas) reasons, you should limit the initial value
    to 32 bits; larger values are transformed in nonintuitive ways (and differently
    on macOS and Linux). As a general rule, I strongly recommend defaulting to 0 for
    each array element when using the .fill directive.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: element_size 的值不能超过 8；如果超过，Gas 会将值截断为 8。出于历史（Gas）原因，建议将初始值限制为 32 位；更大的值会以不直观的方式进行转换（并且在
    macOS 和 Linux 上有所不同）。作为一般规则，我强烈建议在使用 .fill 指令时，将每个数组元素的默认初始值设置为 0。
- en: NOTE
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you use the* .fill *directive in a* .bss *section, the initial value must
    be absent or set to 0.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在 .bss 部分使用 .fill 指令，则初始值必须为空或设置为 0。*'
- en: An alternative to the .fill directive is .space
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: .fill 指令的替代方法是 .space
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: where size is the number of bytes to allocate for the array and fill is an optional
    8-bit value that Gas will use to initialize each byte of the array. If the fill
    argument is absent, Gas uses a default value of 0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 size 是为数组分配的字节数，fill 是一个可选的 8 位值，Gas 将使用它初始化数组的每个字节。如果没有提供 fill 参数，Gas 会使用默认值
    0。
- en: 'To declare an array of a type other than bytes, you must compute the size argument
    as numberOfElements × elementSize. For example, to create a 16-element array of
    words, you could use the following declaration:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个非字节类型的数组，必须计算出大小参数，即 numberOfElements × elementSize。例如，要创建一个 16 元素的字数组，可以使用以下声明：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because the fill argument is not present, Gas will initialize this array with
    bytes containing 0s. I recommend putting parentheses around the element size in
    the expression to better document your intent; this differentiates the element
    size from the element count. As you’ll see in section 4.7.4, “Implementing Multidimensional
    Arrays,” on [page 203](chapter4.xhtml#pg_203), the element count could be an expression
    based on the size of each dimension.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于填充参数不存在，Gas 将使用包含 0 的字节初始化该数组。我建议在表达式中将元素大小放在括号中，以更好地记录你的意图；这可以将元素大小与元素计数区分开来。正如你在第
    4.7.4 节“实现多维数组”中所见，[第 203 页](chapter4.xhtml#pg_203)，元素计数可能是基于每个维度大小的表达式。
- en: 'To obtain the base address of these arrays, just use ArrayName or wordArray
    in an address expression. If you prefer to initialize an array with different
    values in each of the elements, you must manually supply those values in the directives
    .byte, .hword, .word, .dword, and so on. Here’s a 16-word array initialized with
    the values 0 to 15:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些数组的基地址，只需在地址表达式中使用 ArrayName 或 wordArray。如果你更倾向于为每个元素初始化不同的值，你必须在指令 .byte、.hword、.word、.dword
    等中手动提供这些值。以下是一个用值 0 到 15 初始化的 16 字元素数组：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you need to initialize a large array with different values, you’re best off
    either writing an external program (perhaps in an HLL like C/C++) or using Gas’s
    macro facilities to generate the array. I discuss this further in [Chapters 10](chapter10.xhtml)
    and [13](chapter13.xhtml).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要用不同的值初始化一个大数组，最好是编写一个外部程序（可能是用 C/C++ 等高级语言编写），或者使用 Gas 的宏功能来生成该数组。我在[第
    10 章](chapter10.xhtml)和[第 13 章](chapter13.xhtml)中进一步讨论了这个问题。
- en: '#### 4.7.2 Accessing Elements of a Single-Dimensional Array'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 4.7.2 访问一维数组的元素'
- en: 'To access an element of a zero-based array, use this formula:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个零基数组的元素，请使用以下公式：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the array is located within your .text section (an array of constants), or
    if you’re writing a Linux application and the array isn’t farther than ±1MB from
    your code that accesses the array, you can use the array’s name for the Base_Address
    entry. This is because Gas associates the address of the first element of an array
    with the name of that array.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组位于你的 .text 区段内（常量数组），或者你正在编写一个 Linux 应用程序且数组与访问该数组的代码的距离不超过±1MB，你可以使用数组的名称作为
    Base_Address 条目的值。这是因为 Gas 将数组第一个元素的地址与该数组的名称关联起来。
- en: 'Otherwise, you’ll need to load the base address of the array into a 64-bit
    register. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你需要将数组的基地址加载到 64 位寄存器中。例如：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The Element_Size entry is the number of bytes for each array element. If the
    object is an array of bytes, the Element_Size field is 1 (resulting in a very
    simple computation). If each element of the array is a half word (or other 2-byte
    type), then Element_Size is 2, and so on. To access an element of the wordArray
    array in the previous section, you’d use the following formula (the size is 4
    because each element is a word object):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Element_Size 条目表示每个数组元素的字节数。如果对象是字节数组，则 Element_Size 字段为 1（导致非常简单的计算）。如果数组的每个元素是半字（或其他
    2 字节类型），则 Element_Size 为 2，以此类推。要访问前面章节中的 wordArray 数组的元素，你可以使用以下公式（大小为 4，因为每个元素是一个字对象）：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The ARM code equivalent to the statement w0 = wordArray[index] is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于语句 w0 = wordArray[index] 的 ARM 代码如下：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This instruction sequence does not explicitly compute the sum of the base address
    plus the index times 4 (the size of a 32-bit integer element in wordArray). Instead,
    it relies on the scaled-indexed addressing mode (the uxtx #2 operand) to implicitly
    compute this sum. The instruction'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '该指令序列并未明确计算基地址加上索引乘以 4（即 wordArray 中 32 位整数元素的大小）。相反，它依赖于缩放索引寻址模式（uxtx #2 操作数）来隐式计算这个和。该指令'
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: loads W0 from location X2 + W1 * 4, which is the base address plus index * 4
    (because W1 contains index).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置 X2 + W1 * 4 加载 W0，这是基地址加上索引 * 4（因为 W1 包含索引）。
- en: To multiply by a constant other than 1, 2, 4, or 8 (the immediate shift constants
    possible with the scaled-indexed addressing mode), you’ll need to use the lsl
    instruction to multiply by the element size (if multiplying by a power of 2) or
    the mul instruction. You’ll see some examples in a bit.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要乘以 1、2、4 或 8 以外的常数（这是使用缩放索引寻址模式时可能的立即移位常数），你需要使用 lsl 指令来乘以元素大小（如果乘以 2 的幂），或者使用
    mul 指令。稍后会看到一些示例。
- en: The scaled-indexed addressing mode on the ARM is the natural addressing mode
    for accessing elements of a single-dimensional array. Make sure you remember to
    multiply the index by the size of an element; failure to do so will produce incorrect
    results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 上的缩放索引寻址模式是访问一维数组元素的自然寻址模式。确保记得将索引乘以元素的大小；如果不这么做，会导致不正确的结果。
- en: The examples in this section assume that the index variable is a 32-bit value,
    which is common for array indices. To use a smaller integer, you’d need to sign-
    or zero-extend it to 32 bits. To use a 64-bit integer, simply adjust the scaled-indexed
    addressing mode to use a 64-bit index register and use the shift-left scaling
    without zero or sign extension.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例假设索引变量是 32 位值，这是数组索引常见的类型。如果要使用较小的整数，您需要将其扩展为 32 位。如果要使用 64 位整数，只需调整缩放索引寻址模式以使用
    64 位索引寄存器，并使用左移缩放，而无需零扩展或符号扩展。
- en: 4.7.3 Sorting an Array of Values
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.7.3 排序一个值的数组
- en: When introducing arrays, books commonly introduce sorting the elements of an
    array. To acknowledge this historical precedent, this section takes a quick look
    at a simple sort in Gas. The program presented in this section uses a variant
    of the bubble sort, which is great for short lists of data and lists that are
    nearly sorted, but horrible for just about everything else. However, a bubble
    sort is easy to implement and understand, which is why this and other introductory
    texts continue to use it in examples.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍数组时，书籍通常会介绍数组元素的排序。为了承认这一历史先例，本节简要介绍了在 Gas 中的简单排序。此节中呈现的程序使用了冒泡排序的变体，它对于短列表数据和几乎已排序的列表非常有效，但对于其他几乎所有情况都表现不佳。然而，冒泡排序易于实现和理解，这也是为什么本书及其他入门书籍继续在示例中使用它的原因。
- en: Because of the relative complexity of Listing 4-6, I’ll insert comments throughout
    the source code rather than explaining it at the end. We begin by including *aoaa.inc*,
    as usual.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表 4-6 的相对复杂性，我将在源代码中插入注释，而不是在最后解释。我们首先像往常一样包含 *aoaa.inc*。
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Right away, let’s make some coding improvements as compared to many of the previous
    examples in this book. Those examples, such as Listing 4-1, used “magic” numbers,
    like 64 for the amount of stack space to allocate and 56 for the offset into the
    stack allocation where I preserve the LR register. I used these literal constants
    directly in the code to be as transparent as possible; however, good programming
    style demands the use of symbolic names in place of those magic numbers. The two
    equates below accomplish this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻开始进行一些编码改进，相较于本书中许多前面的示例。那些示例，如列表 4-1，使用了“魔法”数字，比如 64 表示分配的堆栈空间大小，56 表示我保留
    LR 寄存器的堆栈分配偏移量。我在代码中直接使用了这些字面常量，以便尽可能地透明；然而，良好的编程风格要求使用符号名称替代这些魔法数字。下面的两个等式就完成了这一点。
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The next couple of statements in the source file define offsets into the stack
    frame (allocated storage on the stack) where the program can preserve register
    values. In all the example programs so far, I’ve placed (global) variables in
    memory locations. That’s not the appropriate paradigm for RISC assembly language
    programming.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件中的接下来的几行语句定义了堆栈框架中的偏移量（分配的堆栈存储区域），程序可以在其中保存寄存器值。在迄今为止的所有示例程序中，我将（全局）变量放置在内存位置。这不是
    RISC 汇编语言编程的合适范式。
- en: 'The ARM ABI reserves registers X19 through X28 for use as nonvolatile (permanent)
    variable storage. *Nonvolatile* means you can call functions (like printf()) without
    worrying about those registers’ values being changed. The drawback to using nonvolatile
    registers is that you have to preserve their values upon entry into your code.
    The following two equates specify the offset into the stack allocation area for
    register preservation. This code will use registers X19 and X20 as loop control
    variables:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 保留寄存器 X19 到 X28 用作非易失性（永久）变量存储。*非易失性*意味着您可以调用函数（如 printf()），而无需担心这些寄存器的值会被更改。使用非易失性寄存器的缺点是，进入代码时必须保留它们的值。以下两个等式指定了用于寄存器保留的堆栈分配区的偏移量。此代码将使用寄存器
    X19 和 X20 作为循环控制变量：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The remaining equates define other constants used in this code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的等式定义了代码中使用的其他常量：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next come the usual read-only and writable data sections. In particular, the
    .data section contains the sortMe array, which will be the subject of the sorting
    operation. Also, this block of statements contains the getTitle function required
    by the *c.cpp* program:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是常规的只读和可写数据段。特别是，`.data` 段包含 `sortMe` 数组，它将成为排序操作的对象。此外，这段语句还包含 `getTitle`
    函数，该函数是 *c.cpp* 程序所需的：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we get to the bubble-sort function itself:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看冒泡排序函数本身：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The bubble-sort function could just use register names like X0, X1, W2, and
    X3 for all the local variables. However, the following #define statements let
    you use more meaningful names. X5, X6, and X7 are pure temporaries (no meaningful
    name is attached to them), so this code continues to use the ARM register names
    for these temporary or local objects. Technically, X0 through X7 are reserved
    for parameters. As the sort function has only two parameters (array and count),
    it uses X2 through X7 as local variables (which is fine, as these registers are
    volatile, according to the ARM ABI):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序函数可以直接使用寄存器名称，比如 X0、X1、W2 和 X3 来作为所有局部变量。然而，以下的 `#define` 语句允许你使用更具意义的名称。X5、X6
    和 X7 是纯粹的临时寄存器（没有附加任何有意义的名称），所以这段代码继续使用 ARM 寄存器名称来表示这些临时或局部对象。技术上讲，X0 到 X7 是为参数保留的。由于排序函数只有两个参数（数组和计数），它使用
    X2 到 X7 作为局部变量（这是可以的，因为根据 ARM ABI，这些寄存器是易失性的）：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The count parameter just defined contains the number of array elements (which
    will be 16 in the main program). Since it’s more convenient for this to be a byte
    count rather than a (word) element count, the following code multiplies count
    (X1) by 4, using a shift left by 2. Also, the loop executes count –1 times, so
    this code also preps count by subtracting 1 from it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚定义的 `count` 参数包含数组元素的数量（在主程序中将为 16）。因为使用字节计数比使用（字）元素计数更为方便，所以以下代码将 `count`（X1）乘以
    4，方法是将其左移 2 位。此外，循环执行 `count – 1` 次，所以这段代码也通过减去 1 来预处理 `count`：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The bubble sort works by making count – 1 passes through the array, where count
    is the number of elements. On each pass, it compares each adjacent pair of array
    elements; if the first element is greater than the second one, the program swaps
    them. At the end of each pass, one element winds up being moved to its final position.
    As an optimization, if no swaps occur, then all the elements are already in place,
    so the sort terminates:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序通过进行 `count - 1` 次遍历数组来工作，其中 `count` 是元素的数量。在每次遍历中，它比较每一对相邻的数组元素；如果第一个元素大于第二个元素，程序就会交换它们。在每次遍历的末尾，一个元素将被移动到它的最终位置。作为一种优化，如果没有发生交换，那么所有元素已经就位，排序将终止：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The main program begins by preserving the nonvolatile registers (LR, X19, and
    X20) that it uses:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序首先通过保存它使用的不可变寄存器（LR, X19 和 X20）来开始：
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, the main program calls the sort function to sort the array. As per the
    ARM ABI, this program passes the first argument (the address of the array) in
    X0 and the second argument (element count) in X1:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，主程序调用排序函数来对数组进行排序。根据 ARM ABI，程序将第一个参数（数组的地址）传递给 X0，第二个参数（元素计数）传递给 X1：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once sort has finished, the program executes a loop to display the 16 values
    in the array. This loop uses the nonvolatile registers X19 and X20 to hold the
    base address of the array and the loop index, so these values don’t have to be
    reloaded on each iteration of the loop. Because they are nonvolatile, we know
    that printf() won’t disturb their values:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦排序完成，程序执行一个循环来显示数组中的 16 个值。这个循环使用不可变寄存器 X19 和 X20 来保存数组的基地址和循环索引，因此这些值在每次循环迭代时不需要重新加载。因为它们是不可变的，我们知道
    `printf()` 不会干扰它们的值：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the output is complete, the main program must restore the nonvolatile
    registers before returning to the C++ program:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输出完成，主程序必须在返回 C++ 程序之前恢复这些不可变寄存器：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You could slightly optimize this program by using the stp and ldp instructions
    to preserve both X19 and X20\. To emphasize saving and restoring both registers
    as independent operations, I didn’t make that optimization here. However, you
    should get in the habit of optimizing your code in this manner in order to reap
    the benefits of using assembly language.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `stp` 和 `ldp` 指令来稍微优化这个程序，从而同时保存 X19 和 X20 寄存器。为了强调将保存和恢复两个寄存器作为独立操作，我在这里没有进行这个优化。然而，你应该养成以这种方式优化代码的习惯，以便能够享受到使用汇编语言的好处。
- en: 'Here’s the build command and output for Listing 4-6:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第 4-6 号清单的构建命令和输出：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, the
    bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (or, worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. [Chapter 5](chapter5.xhtml) provides
    an example of a more efficient sorting algorithm, quicksort, in ARM assembly language.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 像典型的冒泡排序算法一样，如果最内层的循环在没有交换任何数据的情况下完成，算法就会终止。如果数据已经是预排序的，冒泡排序是非常高效的，仅需对数据进行一次遍历。不幸的是，如果数据没有排序（或者，最糟糕的情况是，数据按反向顺序排序），那么这个算法非常低效。[第
    5 章](chapter5.xhtml)提供了一个更高效的排序算法——快速排序的 ARM 汇编语言示例。
- en: 4.7.4 Implementing Multidimensional Arrays
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.7.4 实现多维数组
- en: The ARM hardware can easily handle single-dimensional arrays. Unfortunately,
    however, accessing elements of *multidimensional arrays* takes some work and several
    instructions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 硬件可以轻松处理一维数组。然而，不幸的是，访问*多维数组*的元素需要一些工作并且需要多个指令。
- en: 'Before discussing how to declare or access multidimensional arrays, I’ll show
    you how to implement them in memory. First, how do you store a multidimensional
    object into a one-dimensional memory space? Consider for a moment a Pascal array
    of this form:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何声明或访问多维数组之前，我将向你展示如何在内存中实现它们。首先，如何将一个多维对象存储到一维内存空间中？请先考虑一下这个形式的 Pascal
    数组：
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This array contains 16 bytes organized as four rows of four characters. Somehow,
    you have to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-2](chapter4.xhtml#fig4-2) shows
    one way to do this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含 16 字节，组织成四行四列的字符。你必须以某种方式将这个数组中的 16 个字节与主存中的 16 个连续字节进行对应。[图 4-2](chapter4.xhtml#fig4-2)展示了实现这一目标的一种方法。
- en: '![](../images/Figure4-2.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.jpg)'
- en: 'Figure 4-2: Mapping a 4×4 array to sequential memory locations'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：将 4×4 数组映射到连续的内存位置
- en: 'The actual mapping is not important as long as two things occur: (1) each element
    maps to a unique memory location (no two entries in the array occupy the same
    memory locations), and (2) the mapping is consistent (a given element in the array
    always maps to the same memory location). Therefore, you need a function with
    two input parameters (row and column) that produces an offset into a linear array
    of 16 memory locations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的映射方式并不重要，只要满足两个条件：（1）每个元素都映射到一个唯一的内存位置（数组中的两个条目不能占用相同的内存位置），以及（2）映射是一致的（数组中的某个特定元素总是映射到相同的内存位置）。因此，你需要一个具有两个输入参数（行和列）的函数，它能够生成一个偏移量，指向一个包含
    16 个内存位置的线性数组。
- en: 'Any function that satisfies these constraints will work fine. Indeed, you could
    randomly choose a mapping, as long as it’s consistent. However, you really want
    a mapping that is efficient to compute at runtime and that works for any size
    array (not just 4×4 or even limited to two dimensions). While many possible functions
    fit this bill, two in particular are used by most programmers and HLLs: row-major
    ordering and column-major ordering.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 任何满足这些约束的函数都能正常工作。事实上，你可以随机选择一个映射，只要它是一致的。然而，你实际上需要一个在运行时高效计算的映射，并且能够适应任意大小的数组（不仅仅是
    4×4，甚至不限于二维数组）。虽然许多可能的函数都符合这个要求，但有两个特别常用，它们是大多数程序员和高级语言（HLL）使用的：行优先顺序和列优先顺序。
- en: 4.7.4.1 Row-Major Ordering
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.7.4.1 行优先顺序
- en: '*Row-major ordering* assigns successive elements, moving across the rows and
    then down the columns, to successive memory locations. [Figure 4-3](chapter4.xhtml#fig4-3)
    demonstrates this mapping.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*行优先顺序*将连续的元素按行依次排列，然后向下排列列，并将这些元素映射到连续的内存位置。[图 4-3](chapter4.xhtml#fig4-3)展示了这种映射方式。'
- en: '![](../images/Figure4-3.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-3.jpg)'
- en: 'Figure 4-3: Row-major ordering of array elements'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：数组元素的行优先顺序
- en: 'Row-major ordering is the method most HLLs employ. It is easy to implement
    and use in machine language: you start with the first row (row 0) and then concatenate
    the second row to its end. You then concatenate the third row to the end of the
    list, then the fourth row, and so on (see [Figure 4-4](chapter4.xhtml#fig4-4)).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 行优先顺序是大多数高级语言（HLL）使用的方法。它在机器语言中容易实现和使用：你从第一行（行 0）开始，然后将第二行连接到第一行的末尾。接着将第三行连接到列表的末尾，再将第四行连接上，依此类推（见[图
    4-4](chapter4.xhtml#fig4-4)）。
- en: '![](../images/Figure4-4.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-4.jpg)'
- en: 'Figure 4-4: Another view of row-major ordering for a 4×4 array'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：4×4 数组的行优先顺序的另一种视图
- en: 'The function that converts a list of index values into an offset is a slight
    modification of the formula for computing the address of an element of a single-dimensional
    array. The formula to compute the offset for a two-dimensional row-major ordered
    array is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引值列表转换为偏移量的函数是对计算单维数组元素地址公式的轻微修改。计算二维行主序数组偏移量的公式如下：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As usual, Base_Address is the address of the first element of the array (A[0][0]
    in this case), and Element_Size is the size of an individual element of the array,
    in bytes. colindex is the leftmost index, and rowindex is the rightmost index
    into the array. row_size is the number of elements in one row of the array (4,
    in this case, because each row has four elements). Assuming Element_Size is 1,
    this formula computes the following offsets from the base address:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，Base_Address 是数组第一个元素的地址（在这个例子中是 A[0][0]），Element_Size 是数组单个元素的大小，单位是字节。colindex
    是最左边的索引，rowindex 是数组中的最右边的索引。row_size 是数组中一行的元素数量（在此例中为 4，因为每行有四个元素）。假设 Element_Size
    为 1，这个公式计算出从基地址开始的以下偏移量：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个三维数组，计算内存偏移量的公式如下：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: col_size is the number of items in a column, and row_size is the number of items
    in a row.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: col_size 是列中项目的数量，row_size 是行中项目的数量。
- en: In C/C++, if you’ve declared the array as
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，如果你声明数组为
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: then row_size is equal to k and col_size is equal to j.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 row_size 等于 k，col_size 等于 j。
- en: For a four-dimensional array, declared in C/C++ as
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个四维数组，在 C/C++ 中声明为
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'the formula for computing the address of an array element is shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 计算数组元素地址的公式如下所示：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: depth_size is equal to j, col_size is equal to k, and row_size is equal to m.
    LeftIndex represents the value of the leftmost index.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: depth_size 等于 j，col_size 等于 k，row_size 等于 m。LeftIndex 表示最左边索引的值。
- en: By now you’re probably beginning to see a pattern. A generic formula will compute
    the offset into memory for an array with *any* number of dimensions; however,
    you’ll rarely use more than four.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经开始看到一个模式了。一个通用的公式可以计算 *任何* 维度数组的内存偏移量；然而，你很少会使用超过四维的数组。
- en: Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方便的思考行主序数组的方式是将其视为数组的数组。考虑以下单维 Pascal 数组定义：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: where sometype is the type sometype = array [0..3] of char; and A is a single-dimensional
    array. Its individual elements happen to be arrays, but you can safely ignore
    that for the time being.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 sometype 是类型 sometype = array [0..3] of char; 且 A 是一个单维数组。它的各个元素恰好是数组，但目前你可以暂时忽略这一点。
- en: 'Here is the formula to compute the address of an element in a single- dimensional
    array:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算单维数组中元素地址的公式：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this case, Element_Size happens to be 4 because each element of A is an array
    of four characters. Therefore, this formula computes the base address of each
    row in this 4×4 array of characters (see [Figure 4-5](chapter4.xhtml#fig4-5)).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Element_Size 恰好为 4，因为 A 中的每个元素是由四个字符组成的数组。因此，这个公式计算出这个 4×4 字符数组中每一行的基地址（见
    [图 4-5](chapter4.xhtml#fig4-5)）。
- en: '![](../images/Figure4-5.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-5.jpg)'
- en: 'Figure 4-5: Viewing a 4×4 array as an array of arrays'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：将一个 4×4 数组视为数组的数组
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn’t affect
    the computation, it’s probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦你计算出一行的基地址，你可以重新应用单维数组的公式来获得特定元素的地址。虽然这不会影响计算，但处理多个单维计算可能比处理复杂的多维数组计算要容易一些。
- en: 'Consider a Pascal array defined as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如下定义的 Pascal 数组：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can view this five-dimensional array as a single-dimensional array of arrays.
    The following Pascal code provides such a definition:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个五维数组看作是一个单维数组的数组。以下是一个 Pascal 代码提供的定义：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The size of OneD is 4 bytes. Because TwoD contains four OneD arrays, its size
    is 16 bytes. Likewise, ThreeD is four TwoDs, so it is 64 bytes long. Finally,
    FourD is four ThreeDs, so it is 256 bytes long. To compute the address of A[b,
    c, d, e, f], you could use the following steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: OneD 的大小是 4 字节。因为 TwoD 包含四个 OneD 数组，所以它的大小为 16 字节。同样，ThreeD 是四个 TwoD 数组，因此它的大小为
    64 字节。最后，FourD 是四个 ThreeD 数组，因此它的大小为 256 字节。要计算 A[b, c, d, e, f] 的地址，可以按照以下步骤进行：
- en: 1.  Compute the address of A[b] as Base + b × size. Here size is 256 bytes.
    Use this result as the new base address in the next computation.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 A[b] 的地址，公式为 Base + b × size。此处 size 为 256 字节。将此结果作为下一步计算的基地址。
- en: 2.  Compute the address of A[b, c] by the formula Base + c × size, where Base
    is the value obtained in the previous step and size is 64\. Use the result as
    the new base in the next computation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 A[b, c] 的地址，使用公式 Base + c × size，其中 Base 是前一步得到的值，size 为 64。将结果作为下一步计算的基地址。
- en: 3.  Compute the base address of A [b, c, d] by Base + d × size, where Base comes
    from the previous computation and size is 16\. Use the result as the new base
    in the next computation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 A[b, c, d] 的基地址，使用公式 Base + d × size，其中 Base 来自前一步的计算，size 为 16。将此结果作为下一步计算的基地址。
- en: 4.  Compute the address of A[b, c, d, e] with the formula Base + e × size, using
    Base from the previous step and a size of 4\. Use this value as the base for the
    next computation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 A[b, c, d, e] 的地址，使用公式 Base + e × size，其中 Base 来自前一步的计算，size 为 4。将此值作为下一步计算的基地址。
- en: 5.  Finally, compute the address of A[b, c, d, e, f] by using the formula Base
    + f × size, where Base comes from the previous computation and size is 1 (obviously,
    you can ignore this final multiplication). The result you obtain at this point
    is the address of the desired element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用公式 Base + f × size 计算 A[b, c, d, e, f] 的地址，其中 Base 来自前一步的计算，size 为 1（显然，你可以忽略这个最后的乘法）。此时得到的结果就是所需元素的地址。
- en: One of the main reasons you won’t find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It’s easy to enter something like A[b, c, d, e, f] into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会在汇编语言中找到更高维数组的主要原因之一是，汇编语言强调了这种访问方式的低效性。像 A[b, c, d, e, f] 这样的表达式在 Pascal
    程序中很容易出现，而你可能没有意识到编译器在做什么。汇编语言程序员不会这么随意——他们看得到使用高维数组时所面临的混乱。事实上，好的汇编语言程序员尽量避免使用二维数组，并且在使用此类数组时，如果确实必须使用，它们往往会采取一些技巧来访问数据。
- en: 4.7.4.2 Column-Major Ordering
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.7.4.2 列主序列
- en: '*Column-major ordering* is the other function HLLs frequently use to compute
    the address of an array element. FORTRAN and various dialects of BASIC (for example,
    older versions of Microsoft BASIC) use this method.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*列主序列*是高级语言常用来计算数组元素地址的另一种方法。FORTRAN 和各种 BASIC 方言（例如旧版本的 Microsoft BASIC）使用这种方法。'
- en: In row-major ordering, the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering, the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-6](chapter4.xhtml#fig4-6).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在行主序列中，最右边的索引随着你在连续的内存位置中移动而增加得最快；而在列主序列中，最左边的索引增加得最快。从图示上看，列主序列的数组组织如 [图 4-6](chapter4.xhtml#fig4-6)
    所示。
- en: '![](../images/Figure4-6.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-6.jpg)'
- en: 'Figure 4-6: Column-major ordering of array elements'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：数组元素的列主序列排列
- en: The formula for computing the address of an array element when using column-major
    ordering is similar to that for row-major ordering. You reverse the indices and
    sizes in the computation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列主序列时，计算数组元素地址的公式与行主序列类似。你只需要将计算中的索引和大小反转。
- en: 'For a two-dimensional column-major array:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维列主序列数组：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For a three-dimensional column-major array:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维列主序列数组：
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For a four-dimensional column-major array:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四维列主序列数组：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The formulas for higher-dimension arrays progress in a like fashion.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 更高维数组的计算公式按类似的方式进行。
- en: 4.7.4.3 Storage Allocation for Multidimensional Arrays
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.7.4.3 多维数组的存储分配
- en: 'If you have an *m*×*n* array, it will have *m* × *n* elements and require *m*
    × *n* × Element_Size bytes of storage. To allocate storage for an array, you must
    reserve this memory. As usual, you can accomplish this task in several ways. The
    most common way to declare a multidimensional array in Gas is to use the .space
    directive:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个*m*×*n*的数组，它将包含*m* × *n*个元素，并需要*m* × *n* × Element_Size字节的存储空间。要为数组分配存储空间，你必须预留这块内存。像往常一样，你可以通过多种方式完成这项任务。在Gas中，声明多维数组最常见的方法是使用.space指令：
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, size1 to sizen are the sizes of each of the dimensions of the array, and
    (Element_Size) is the size (in bytes) of a single element. I recommend putting
    parentheses around the Element_Size component of this expression to emphasize
    that it is not another dimension in the multidimensional array.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，size1 到 sizen 是数组各维度的大小，(Element_Size) 是单个元素的大小（以字节为单位）。我建议在这个表达式的 Element_Size
    部分加上括号，以强调它不是多维数组中的另一个维度。
- en: 'For example, here is a declaration for a 4×4 array of characters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个4×4字符数组的声明：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings (assuming the array holds 64-bit pointers to the strings):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例，展示如何声明一个三维字符串数组（假设该数组存储64位指针指向字符串）：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As with single-dimensional arrays, you may initialize every element of the
    array to a specific value by following the declaration with the values of the
    array constant. Array constants ignore dimension information; all that matters
    is that the number of elements in the array constant corresponds to the number
    of elements in the actual array. The following example shows the GameGrid declaration
    with an initializer:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维数组类似，你可以通过在声明后跟上数组常量的值来初始化数组的每个元素。数组常量忽略维度信息；唯一重要的是数组常量中的元素数量与实际数组中的元素数量相匹配。以下示例展示了带有初始化器的
    GameGrid 声明：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This example was laid out to enhance readability. Gas does not interpret the
    four separate lines as representing rows of data in the array; humans do, which
    is why it’s good to write the data in this manner. If you have a large array,
    an array with really large rows, or an array with many dimensions, there is little
    hope for winding up with something readable; in this case, comments that carefully
    explain everything come in handy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的布局旨在增强可读性。Gas 并不会将这四行分开的代码解释为数组中的数据行；人类会这样理解，这也是为什么以这种方式编写数据更好的原因。如果你有一个大型数组，或者数组的行非常大，或者数组有多个维度，那么几乎不可能得到可读的代码；在这种情况下，仔细解释每个细节的注释会非常有用。
- en: The use of a constant expression to compute the number of array elements rather
    than simply using the constant 16 (4 × 4) more clearly suggests that this code
    is initializing each element of a 4×4 element array than does the simple literal
    constant 16.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量表达式来计算数组元素的数量，而不是直接使用常量16（4 × 4），更清楚地表明这段代码是在初始化一个4×4元素的数组，而不仅仅是一个简单的字面常量16。
- en: 4.7.4.4 How to Access Elements of Multidimensional Arrays
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.7.4.4 如何访问多维数组的元素
- en: To access elements of a multidimensional array, you’ll need to be able to multiply
    two values; this is done using the mul (multiply) and madd (multiply and add)
    instructions.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问多维数组的元素，你需要能够进行两个值的乘法运算；这可以通过使用 mul（乘法）和 madd（乘法加法）指令来实现。
- en: The mul and madd instructions have the following syntax
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: mul 和 madd 指令具有以下语法：
- en: '[PRE82]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: where regd is the destination register (32 or 64 bits), regl and regr are source
    registers (left- and right-hand operands), and rega is a third source operand.
    These instructions perform the calculations described in the comments.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，regd 是目标寄存器（32位或64位），regl 和 regr 是源寄存器（左操作数和右操作数），而rega 是第三个源操作数。这些指令执行注释中描述的计算。
- en: These instructions do not have a form with an s suffix and therefore do not
    update the flags after their execution. An *n*-bit × *n*-bit multiplication can
    produce a 2 × *n* bit result; however, these instructions maintain only *n* bits
    in the destination register. Any overflow is lost. Sadly, these instructions do
    not allow immediate operands, though this would be useful.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令没有带有“s”后缀的形式，因此在执行后不会更新标志位。一个*n*位 × *n*位的乘法可以产生一个2 × *n*位的结果；然而，这些指令只在目标寄存器中保留*n*位，任何溢出都会丢失。遗憾的是，这些指令不允许使用立即数操作数，尽管这会很有用。
- en: The multiply instruction has several other variants that are used for other
    purposes. These are covered in [Chapter 6](chapter6.xhtml).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: multiply指令有几个其他变种，用于其他目的。这些内容在[第6章](chapter6.xhtml)中有详细介绍。
- en: 'Now that you’ve seen the formulas for computing the address of a multidimensional
    array element, it’s time to see how to access elements of those arrays with assembly
    language. The ldr, lsl, and mul/madd instructions make short work of the various
    equations that compute offsets into multidimensional arrays. First, consider a
    two-dimensional array:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过计算多维数组元素地址的公式，是时候看看如何使用汇编语言访问这些数组的元素了。ldr、lsl 和 mul/madd 指令可以轻松处理计算多维数组偏移量的各种方程。首先，考虑一个二维数组：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now consider a second example that uses a three-dimensional array:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个使用三维数组的第二个例子：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This code uses the madd instruction to multiply the value in W0 by 5 and add
    in the k index at the same time. Because the lsl instruction can multiply a register
    by only a power of 2, we must resort to a multiplication here. While there are
    ways to multiply the value in a register by a constant other than a power of 2,
    the madd instruction is more convenient, especially as it handles an addition
    operation at the same time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 madd 指令将 W0 中的值乘以 5，并同时加上 k 索引。因为 lsl 指令只能将寄存器的值乘以 2 的幂，所以我们必须在这里进行乘法运算。虽然也有方法可以将寄存器中的值乘以
    2 以外的常数，但 madd 指令更方便，特别是它还可以同时处理加法操作。
- en: 4.8 Structs
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8 结构体
- en: Another major composite data structure is the Pascal *record* or C/C++/C# *struct*.
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. However, this book uses the term
    *struct*, as C-based languages are more commonly used these days. (Records and
    structures also go by other names in other languages, but most people recognize
    at least one of these names.)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的复合数据结构是 Pascal 的 *record* 或 C/C++/C# 的 *struct*。Pascal 的术语可能更好，因为它避免了与更通用的术语
    *数据结构* 的混淆。然而，本书使用 *struct* 这个术语，因为基于 C 的语言现在更为常用。（在其他语言中，记录和结构也有其他名称，但大多数人至少能认出其中之一。）
- en: Whereas an array is homogeneous, with elements that are all the same type, the
    elements in a struct can have different types. Arrays let you select a particular
    element via an integer index. With structs, you must select an element, known
    as a *field,* by offset (from the beginning of the struct).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 而数组是同质的，所有元素都是相同类型，结构体中的元素可以具有不同类型。数组通过整数索引让你选择特定的元素。而在结构体中，你必须通过偏移量（相对于结构体的开始）选择一个元素，称为
    *字段*。
- en: 'The whole purpose of a struct is to let you encapsulate different, though logically
    related, data into a single package. The Pascal record declaration for a hypothetical
    student is a typical example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的主要目的是让你将不同但在逻辑上相关的数据封装到一个单独的包中。Pascal 记录声明一个假设的学生数据结构是一个典型的例子：
- en: '[PRE85]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name, the next
    2 bytes hold the Major code (assuming a 16-bit integer), the next 12 bytes hold
    the Social Security number, and so on. (Strings require an extra byte, in addition
    to all the characters in the string, to encode the length.) The John variable
    declaration allocates 89 bytes of storage laid out in memory, as shown in [Figure
    4-7](chapter4.xhtml#fig4-7) (assuming no padding or alignment of fields).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Pascal 编译器会将记录中的每个字段分配到连续的内存位置。这意味着 Pascal 会为名称保留前 65 字节，接下来的 2 字节存储 Major
    代码（假设为 16 位整数），接下来的 12 字节存储社会安全号码，依此类推。（字符串需要额外的一个字节，用于编码字符串的长度，除了所有字符外。）John
    变量声明会在内存中分配 89 字节存储空间，如 [图 4-7](chapter4.xhtml#fig4-7) 所示（假设没有对字段进行填充或对齐）。
- en: '![](../images/Figure4-7.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-7.jpg)'
- en: 'Figure 4-7: Student data structure in memory'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7：内存中的学生数据结构
- en: 'If the label John corresponds to the base address of this record, the sName
    field is at offset John + 0, the Major field is at offset John + 65, the SSN field
    is at offset John + 67, and so on. In assembly language, if X0 holds the base
    address of the John structure, you could access the Major field by using the following
    instruction:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签 John 对应于该记录的基地址，则 sName 字段位于偏移量 John + 0，Major 字段位于偏移量 John + 65，SSN 字段位于偏移量
    John + 67，以此类推。在汇编语言中，如果 X0 保存了 John 结构的基地址，可以通过以下指令访问 Major 字段：
- en: '[PRE86]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This loads W0 with the 16-bit value at the address specified by John + 65.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 W0 加载为位于 John + 65 地址的 16 位值。
- en: '#### 4.8.1 Dealing with Limited Gas Support for Structs'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 4.8.1 处理结构体的有限气体支持'
- en: Unfortunately, Gas provides only the smallest amount of support for structures
    via the .struct directive (see “Linux .struct Directive” on [page 217](chapter4.xhtml#pg_217)).
    Even more unfortunately, the macOS assembler doesn’t support .struct.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Gas仅通过`.struct`指令提供对结构的极少支持（请参阅“Linux .struct Directive” [第217页](chapter4.xhtml#pg_217)）。更不幸的是，macOS汇编器不支持`.struct`。
- en: 'To use structures under macOS and Linux together, you’ll need a way to specify
    the offsets to all the fields of a structure for use in the register indirect-plus-offset
    addressing mode (such as in the last example line of the previous section). In
    theory, you could manually use equates to define all the offsets:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux下使用结构，你需要一种方法来指定结构的所有字段的偏移量，以便在寄存器间接加偏移地址模式中使用（例如前一节最后一个示例行中）。理论上，你可以手动使用等式来定义所有的偏移量：
- en: '[PRE87]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: However, this is an absolutely horrible, error-prone, and difficult-to-maintain
    approach. The ideal method would be to supply a structure name (the type name)
    and a list of the field names and their types. From this, you’d aim to get offsets
    for all the fields, plus the size of the entire structure (which you can use with
    the .space directive to allocate storage for the structure).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法绝对是可怕的、容易出错的，而且难以维护。理想的方法是提供一个结构名称（类型名称）和字段名称及其类型的列表。从这些信息中，你可以得到所有字段的偏移量，以及整个结构的大小（你可以使用`.space`指令为结构分配存储空间）。
- en: The *aoaa.inc* include file contains several macro definitions that can help
    you declare and use structures in your assembly language source files. These macros
    aren’t amazingly robust, but when used carefully, they get the job done. [Table
    4-1](chapter4.xhtml#tab4-1) lists these macros and their arguments. Field names
    must be unique throughout the program, not just in the structure definition. Also
    note that the struct/ends macros do not support nesting.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc* 包含多个宏定义，可以帮助你在汇编语言源文件中声明和使用结构。这些宏并不是非常强大，但是在小心使用时，它们能完成任务。[表4-1](chapter4.xhtml#tab4-1)
    列出了这些宏及其参数。字段名称在整个程序中必须是唯一的，不仅仅在结构定义中。另外，请注意，struct/ends 宏不支持嵌套。'
- en: 'Table 4-1: The aoaa.inc Macros for Defining Structures'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：aoaa.inc 宏定义结构
- en: '| Macro | Argument(s) | Description |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| Macro | Argument(s) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| struct | name, offset | Begin a structure definition. The offset field is
    optional and can be either a (small) negative number or 0\. The default (and most
    commonly used) value is 0. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| struct | name, offset | 开始一个结构定义。offset字段是可选的，可以是一个（较小的）负数或0。默认（也是最常用的）值为0。
    |'
- en: '| ends | name | Ends a structure definition. The name argument must match the
    name supplied in the struct invocation. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| ends | name | 结束结构定义。name参数必须与struct调用中提供的名称匹配。 |'
- en: '| byte | name, elements | Create a field of type byte. name is the unique field
    name. elements is optional (default value is 1) and specifies the number of array
    elements. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| byte | name, elements | 创建一个byte类型的字段。name是唯一的字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| hword | name, elements | Create a field of type hword. name is the (unique)
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| hword | name, elements | 创建一个hword类型的字段。name是（唯一的）字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| word | name, elements | Create a field of type word. name is the unique field
    name. elements is optional (default value is 1) and specifies the number of array
    elements. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| word | name, elements | 创建一个word类型的字段。name是唯一的字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| dword | name, elements | Create a field of type dword. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| dword | name, elements | 创建一个dword类型的字段。name是唯一的字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| qword | name, elements | Create a field of type qword. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| qword | name, elements | 创建一个qword类型的字段。name是唯一的字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| single | name, elements | Create a field of type single. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| single | name, elements | 创建一个single类型的字段。name是唯一的字段名称。elements是可选的（默认值为1），指定数组元素的数量。
    |'
- en: '| double | name, elements | Create a field of type double. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| double | name, elements | 创建一个类型为 double 的字段。name 是唯一的字段名称。elements 是可选的（默认值为
    1），指定数组元素的数量。 |'
- en: For strings, you’d specify either a dword field (to hold a pointer to the field)
    or a byte field with a sufficient number of elements to hold all the characters
    in the string.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串，你可以指定一个 dword 字段（用于保存字段的指针），或者指定一个足够数量的字节字段来保存字符串中的所有字符。
- en: 'The student example from the previous section could be encoded as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的学生示例可以按如下方式编码：
- en: '[PRE88]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You would declare a variable of type student like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样声明一个类型为 student 的变量：
- en: '[PRE89]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The ends macro automatically generates a macro with the same name as the structure
    name, so you can use that like a directive to allocate sufficient space to hold
    an instance of the structure type.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ends 宏会自动生成一个与结构名称相同的宏，因此你可以像使用指令一样使用它，为结构类型的实例分配足够的空间。
- en: 'You could access fields of John as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式访问 John 的字段：
- en: '[PRE90]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This macro package has a couple of issues. First of all, the field names must
    be unique throughout the assembly language source file (unlike standard structures,
    where the field names are local to the structure itself). As a result, these structures
    tend to suffer from *namespace pollution*, which happens when you try to reuse
    some of the field names for other purposes. For example, sName will likely be
    used again elsewhere in the source file, since it’s a common identifier. A quick-and-dirty
    solution to this problem is to always prefix the field names with the structure
    name and a period. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏包有几个问题。首先，字段名称必须在整个汇编语言源文件中唯一（与标准结构不同，标准结构中的字段名称仅对结构本身有效）。因此，这些结构往往会受到*命名空间污染*的影响，这种情况发生在你尝试将一些字段名用于其他目的时。例如，sName
    很可能会在源文件的其他地方再次使用，因为它是一个常见的标识符。解决这个问题的快速且粗略的办法是始终在字段名前加上结构名称和一个句点。例如：
- en: '[PRE91]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This requires a bit more typing, but it resolves the namespace pollution issue
    most of the time.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要更多的输入，但大多数时候它能解决命名空间污染的问题。
- en: Consider the student John macro invocation/declaration given in this section.
    This macro expands into
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑本节中给出的学生 John 宏调用/声明。此宏扩展为
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: where student.size is an extra field that the struct macro generates, specifying
    the total size of the structure (in bytes).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 student.size 是 struct 宏生成的额外字段，指定结构的总大小（以字节为单位）。
- en: 'The struct macro accepts a second (optional) parameter: the *starting offset*
    for fields in the structure. By default, this is 0\. If you supply a negative
    number here, the directive/macro that struct generates works a little differently.
    Consider the following structure definition:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: struct 宏接受第二个（可选）参数：结构中字段的*起始偏移量*。默认情况下，这个值为 0。如果你在此处提供一个负数，struct 生成的指令/宏将有所不同。请考虑以下结构定义：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: HLA strings are actually a bit different from the structure provided here, but
    this does serve as a good example of negative starting offsets.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串实际上与此处提供的结构略有不同，但这确实是负起始偏移的一个很好的示例。
- en: 'The HLAstring macro that struct generates does the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: struct 生成的 HLAstring 宏执行以下操作：
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This expansion places the myString label after the first 4 bytes of the beginning
    of the structure. This is because the HLAstring.len field’s offset is –4, meaning
    that the length field starts 4 bytes before the base address of the structure
    (and the structure variable’s name is always associated with the base address).
    You’ll see some important uses for this feature in the next chapter.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展将 myString 标签放置在结构开始后的前 4 个字节处。这是因为 HLAstring.len 字段的偏移量为 -4，意味着长度字段从结构的基地址前
    4 个字节开始（结构变量的名称总是与基地址相关联）。你将在下一章看到这个特性的一些重要用途。
- en: The struct macro does not allow positive offsets (values greater than 0). It
    will generate an error at assembly time if you specify a positive value.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: struct 宏不允许正偏移量（大于 0 的值）。如果你指定正值，它将在汇编时生成错误。
- en: One issue with the struct macro is that it doesn’t provide a way to initialize
    the fields of the structure. To learn how to do that, keep reading.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: struct 宏的一个问题是它没有提供初始化结构字段的方法。要了解如何做到这一点，请继续阅读。
- en: 4.8.2 Initializing Structs
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.2 初始化结构
- en: 'The struct macro definitions do not provide any way to initialize the fields
    of a structure at compile time. You’ll have to either assign the values at runtime
    or manually build up the structure variable by using Gas directives. For example:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体宏定义在编译时无法初始化结构体的字段。你必须在运行时分配值，或者使用Gas指令手动构建结构体变量。例如：
- en: '[PRE95]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This initializes the fields of the structure to the corresponding values.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这将结构体的字段初始化为相应的值。
- en: 4.8.3 Creating Arrays of Structs
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.3 创建结构体数组
- en: 'A common pattern in program design is to create an array of structures. To
    do so, create a struct type and multiply its size by the number of array elements
    when declaring the array variable, as shown in the following example:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 程序设计中的常见模式是创建结构体数组。为此，首先创建一个结构体类型，并在声明数组变量时将其大小乘以数组元素的个数，如下例所示：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To access an element of this array, use the standard array-indexing techniques.
    Because class is a single-dimensional array, you’d compute the address of an element
    of this array by using the formula baseAddress + index × student.size. For example,
    to access an element of class, you’d use code like the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该数组的元素，可以使用标准的数组索引技术。由于类是一个一维数组，你可以通过以下公式计算该数组元素的地址：baseAddress + index ×
    student.size。例如，要访问类中的一个元素，你可以使用如下代码：
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You must sum in the offset to the field you want to access. Sadly, the scaled-indexed
    addressing mode doesn’t include an offset component as part of the addressing
    mode, but madd saves us an instruction by working in this addition as part of
    the multiplication.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在要访问的字段的偏移量中加上偏移量。不幸的是，缩放索引寻址模式在寻址模式中没有包括偏移量组件，但madd通过将这一加法作为乘法的一部分，为我们节省了一条指令。
- en: 'Naturally, you can create multidimensional arrays of structs as well, using
    the row-major or column-major order functions to compute the address of an element
    within such structs. The only real change is that the size of each element is
    the size of the struct object:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，你也可以创建结构体的多维数组，使用行主序或列主序函数来计算该结构体中元素的地址。唯一的变化是每个元素的大小是结构体对象的大小：
- en: '[PRE98]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This demonstrates how to access fields of an array of structs.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了如何访问结构体数组的字段。
- en: 4.8.4 Aligning Fields Within a Struct
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.4 对齐结构体中的字段
- en: 'To achieve maximum performance in your programs, or to ensure that Gas structures
    properly map to records or structures in an HLL, you will often need to be able
    to control the alignment of fields within a struct. For example, you might want
    to ensure that a double-word field’s offset is a multiple of 4\. You can use the
    salign macro to do this. The following creates a structure with aligned fields:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在程序中实现最佳性能，或者确保Gas结构体正确映射到高级语言中的记录或结构体，你通常需要能够控制结构体内字段的对齐方式。例如，你可能希望确保双字字段的偏移量是4的倍数。你可以使用salign宏来实现这一点。以下代码创建了一个字段对齐的结构体：
- en: '[PRE99]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As for the .align directive, the salign macro aligns the structure’s offset
    to 2*^n*, where *n* is the value specified as the salign argument. In this example,
    c’s offset is set to 4 (the macro rounds up the field offset from 1 to 4).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 至于.align指令，salign宏将结构体的偏移量对齐到2*^n*，其中*n*是salign参数中指定的值。在这个例子中，c的偏移量被设置为4（该宏将字段偏移从1向上调整为4）。
- en: 'Field alignment is up to you when you’re creating your own structure variables.
    However, if you’re linking with code written in an HLL that uses structures, you’ll
    need to determine field alignment for that particular language. Most modern HLLs
    use *natural alignment*: fields are aligned on a boundary that is the size of
    that field (or an element of that field). The structure itself is aligned at an
    address rounded to the size of the largest object in the structure. See section
    4.11, “For More Information,” on [page 221](chapter4.xhtml#pg_221) for appropriate
    links.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 字段对齐由你在创建结构体变量时决定。然而，如果你要与一个使用结构体的高级语言（HLL）中的代码进行链接，你需要确定该语言特定的字段对齐方式。大多数现代高级语言使用*自然对齐*：字段会对齐到与该字段大小（或该字段元素的大小）相同的边界。结构体本身会在地址上对齐到最大对象的大小。有关详细信息，请参阅第4.11节，“更多信息”，在[第221页](chapter4.xhtml#pg_221)上查看相关链接。
- en: 4.9 Unions
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9 共用体
- en: '*Unions* (in an HLL like C/C++) are similar to structures insofar as they create
    an aggregate data type containing several fields. Unlike structures, however,
    the fields of a union all occupy the same offset in the data structure.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*共用体*（如C/C++中的共用体）与结构体类似，它们创建一个包含多个字段的聚合数据类型。然而，与结构体不同的是，共用体的所有字段都占据数据结构中的相同偏移量。'
- en: 'Programmers typically use unions for one of two reasons: to conserve memory
    or to create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, consider the following struct type:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常使用联合体有两个原因：节省内存或创建别名。节省内存是该数据结构功能的预期用途。为了理解它是如何工作的，考虑以下结构体类型：
- en: '[PRE100]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If you declare a variable, say n, of type numericRec, you access the fields
    as n.i, n.u, and n.q. A struct assigns different offsets to each field, effectively
    allocating separate storage to each field. A union, on the other hand, assigns
    the same offset (typically 0) to each of these fields, allocating the same storage
    to each.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个类型为 numericRec 的变量，例如 n，你可以通过 n.i、n.u 和 n.q 访问各个字段。结构体会为每个字段分配不同的偏移量，有效地为每个字段分配独立的存储空间。而联合体则为这些字段分配相同的偏移量（通常为
    0），为每个字段分配相同的存储空间。
- en: For struct, then, numericRec.size is 16 because the struct contains two word
    fields and a double-word field. The size of the corresponding union, however,
    would be 8\. This is because all the fields of a union occupy the same memory
    locations, and the size of a union object is the size of the largest field of
    that object (see [Figure 4-8](chapter4.xhtml#fig4-8)).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体而言，numericRec.size 的大小是 16，因为结构体包含两个字字段和一个双字字段。然而，相应的联合体的大小将是 8。这是因为联合体的所有字段占用相同的内存位置，而联合体对象的大小是该对象最大字段的大小（见[图
    4-8](chapter4.xhtml#fig4-8)）。
- en: '![](../images/Figure4-8.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-8.jpg)'
- en: 'Figure 4-8: The layout of a union versus a structure variable'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8：联合体与结构体变量的布局
- en: 'Programs use unions for several purposes: preserving memory, overlaying data
    types, and creating *variant types* (dynamically typed values whose type can change
    during execution). Because you probably won’t use unions that often in an assembly
    language program, I’ve not bothered creating a union macro in the *aoaa.inc* include
    file. However, if you really need a union macro, you could take the information
    in [Chapter 13](chapter13.xhtml) and the source code to the struct macro in *aoaa.inc*
    and write your own.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用联合体有几个目的：节省内存、覆盖数据类型，以及创建*变体类型*（动态类型值，其类型可以在执行期间发生变化）。由于你可能不会在汇编语言程序中频繁使用联合体，因此我没有在*aoaa.inc*包含文件中创建联合体宏。然而，如果你真的需要联合体宏，你可以参考[第13章](chapter13.xhtml)的信息，以及*aoaa.inc*中结构体宏的源代码，自己编写一个。
- en: 4.10 Moving On
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10 继续前进
- en: This chapter concludes the machine organization component of this book, which
    dealt with the organization of memory, constants, data, and data types. It discussed
    memory variables and data types, arrays, row-major and column-major ordering,
    structs and unions, and strings, including zero-terminated, length-prefixed, and
    descriptor-based strings. It also covered issues you may encounter when using
    pointers, including uninitialized pointers, illegal pointer values, dangling pointers,
    memory leaks, and type-unsafe access.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书中关于计算机组织部分的内容，涉及了内存、常量、数据和数据类型的组织。讨论了内存变量和数据类型、数组、行主序和列主序、结构体和联合体，以及字符串，包括零终止、长度前缀和描述符字符串。还讨论了使用指针时可能遇到的问题，包括未初始化的指针、非法指针值、悬空指针、内存泄漏和类型不安全访问。
- en: Now it’s time to begin studying assembly language *programming* in earnest.
    The next section of the book will begin discussing procedures and functions ([Chapter
    5](chapter5.xhtml)), arithmetic ([Chapter 6](chapter6.xhtml)), low-level control
    structures ([Chapter 7](chapter7.xhtml)), and advanced arithmetic ([Chapter 8](chapter8.xhtml)).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始认真学习汇编语言*编程*了。本书的下一部分将开始讨论过程和函数（[第5章](chapter5.xhtml)）、算术运算（[第6章](chapter6.xhtml)）、低级控制结构（[第7章](chapter7.xhtml)）和高级算术运算（[第8章](chapter8.xhtml)）。
- en: 4.11 For More Information
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11 更多信息
- en: For additional information about data structure representation in memory, consider
    reading my book *Write Great Code*, Volume 1, 2nd edition (No Starch Press, 2020).
    For an in-depth discussion of data types, consult a textbook on data structures
    and algorithms such as *Introduction to Algorithms*, 3rd edition (MIT Press, 2009),
    by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于数据结构在内存中表示的更多信息，请阅读我的书《写出伟大的代码》第一卷，第2版（No Starch Press，2020年）。关于数据类型的深入讨论，请参考数据结构与算法的教科书，如《算法导论》第三版（MIT
    Press，2009年），作者为Thomas H. Cormen、Charles E. Leiserson、Ronald L. Rivest 和 Clifford
    Stein。
- en: You can find information about the GNU assembler (including the .struct directive)
    in the manual at *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在手册中找到有关GNU汇编器（包括.struct指令）的信息，链接为 *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*。
- en: As noted in [Chapter 3](chapter3.xhtml), you can find more information about
    ARM CPUs at the developer website at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*.
    To learn more about field alignment in particular, see *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dui0491<wbr>/i<wbr>/C<wbr>-and<wbr>-C<wbr>-<wbr>-<wbr>-Implementation<wbr>-Details<wbr>/Structures<wbr>-<wbr>-unions<wbr>-<wbr>-enumerations<wbr>-<wbr>-and<wbr>-bitfields<wbr>?lang<wbr>=en](https://developer.arm.com/documentation/dui0491/i/C-and-C---Implementation-Details/Structures--unions--enumerations--and-bitfields?lang=en)*.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[第3章](chapter3.xhtml)所述，你可以在开发者网站上找到更多关于ARM处理器的信息，网址为 *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*。如果你特别想了解字段对齐的更多内容，请参考
    *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dui0491<wbr>/i<wbr>/C<wbr>-and<wbr>-C<wbr>-<wbr>-<wbr>-Implementation<wbr>-Details<wbr>/Structures<wbr>-<wbr>-unions<wbr>-<wbr>-enumerations<wbr>-<wbr>-and<wbr>-bitfields<wbr>?lang<wbr>=en](https://developer.arm.com/documentation/dui0491/i/C-and-C---Implementation-Details/Structures--unions--enumerations--and-bitfields?lang=en)*。
- en: For more on dangling pointers, see *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Dangling<wbr>_pointer](https://en.wikipedia.org/wiki/Dangling_pointer)*.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于悬空指针的更多内容，请参见 *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Dangling<wbr>_pointer](https://en.wikipedia.org/wiki/Dangling_pointer)*。
- en: For more on the High-Level Assembler, see the online resources at my website,
    *[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/)*.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于高级汇编器的信息，可以查看我网站上的在线资源，链接为 *[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/)*。
