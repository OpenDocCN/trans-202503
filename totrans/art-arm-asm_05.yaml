- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 CONSTANTS, VARIABLES, AND DATA TYPES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Chapter 2](chapter2.xhtml) discussed the basic format for data in memory,
    and [Chapter 3](chapter3.xhtml) covered how a computer system physically organizes
    that data in memory. This chapter completes that discussion by connecting the
    concept of *data representation* to its actual physical representation. I’ll focus
    on three main topics: constants, variables, and data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter doesn’t assume you’ve taken a formal course in data structures,
    though such experience would be useful. You’ll learn to declare and use constants,
    scalar variables, integers, data types, pointers, arrays, structs, and unions.
    Work to master these subjects before going on to the next chapter. Declaring and
    accessing arrays, in particular, seem to present a multitude of problems to beginning
    assembly language programmers, but the rest of this text depends on your understanding
    of these data structures and their memory representation. Do not try to skim over
    this material with the expectation that you’ll pick it up as needed later; you’ll
    need to comprehensively understand it right away.
  prefs: []
  type: TYPE_NORMAL
- en: '### 4.1 Gas Constant Declarations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the first place to start is with constant declarations that allow
    you to attach a name to a literal constant value. Gas provides four directives,
    collectively known as *equates*, that let you define constants in your assembly
    language programs. You’ve already seen the most common form, .equ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you declare a symbolic constant in this manner, you may use the symbolic
    identifier anywhere the corresponding literal constant is legal. These constants
    are known as *manifest constants*—symbolic representations that allow you to substitute
    the literal value for the symbol anywhere in the program.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Technically, you could also use CPP macros to define constants in Gas. See
    [Chapter 13](chapter13.xhtml) for more details.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with .rodata objects: an .rodata value is a constant value, because
    you cannot change it at runtime. However, a memory location is associated with
    an .rodata declaration, and the OS, not the Gas assembler, enforces the read-only
    attribute. Although the following instruction sequence will crash your program
    when it runs, writing it is perfectly legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, it is no more legal to write the following, using the preceding
    declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'than it is to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, both statements are equivalent: the compiler substitutes 15 for MaxIndex
    whenever it encounters this manifest constant.'
  prefs: []
  type: TYPE_NORMAL
- en: Constant declarations are great for defining magic numbers that could change
    during program modification. Examples include constants like nl (newline), maxLen,
    and NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GNU .set directive uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is semantically equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both the .set and = directives allow you to redefine a symbol previously defined
    with these directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see how to take advantage of this feature in [Chapter 13](chapter13.xhtml),
    which discusses macros and the Gas compile-time language.
  prefs: []
  type: TYPE_NORMAL
- en: Note that .equ also allows you to redefine symbols in your source file. These
    many synonyms for the same directive are Gas’s attempt to maintain compatibility
    with multiple assemblers and assembler versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final equate directive Gas offers is .equiv:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the other three directives, .equiv will generate an error if the symbol
    is already defined. This is therefore likely the safest equate to use, unless
    you really need to redefine symbols in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions appearing in these equates are limited to 64 bits. If you specify
    a value greater than 64 bits, the assembler will report an error.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 The Location Counter Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One very special constant you’ll frequently use is the current location counter
    value. As noted in the previous chapter, Gas will substitute the value of the
    current section’s location counter in place of an individual period (.) appearing
    in a constant expression. You could in theory use this operator to embed a pointer
    to a variable within that variable itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, this isn’t especially useful. It’s a better idea to use the location
    counter operator to compute offsets and lengths within a particular section. If
    you subtract a label in a section from the location counter, the difference is
    the (signed) distance from that point in the code to the specified label. This
    allows you to compute string lengths, function lengths, and other values that
    involve measuring the byte distance within a section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses this technique to compute a string length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This counts all the bytes Gas emits (including the zero-terminating byte) by
    the two string directives. You can use this technique to compute the length of
    any data object, not just the characters in a string.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, there is a subtle difference between the location counter constant
    (.) and a literal constant such as 0. The constant 0 will always have the same
    value wherever it appears in the source file, whereas the location counter constant
    will have a different value through the source file. An HLL would associate a
    different type with these two types of constants. The next sections discuss types
    in assembly language, including relocatable types (the location counter is a relocatable
    type in assembly language).
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Data Types and Gas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like most traditional (that is, 1960s-era) assemblers, Gas is completely *typeless*.
    It relies on you, the programmer, to make sense of all the data types you use
    in your program, via your choice of instructions. In particular, Gas will be more
    than happy to accept any of the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second instruction loads 64 bits from a 32-bit variable. However, Gas accepts
    this erroneous code and loads the 64 bits at the address you specify, which might
    include the 32 bits just beyond the wv declaration you’ve placed in your .text
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing data by using the wrong data type can lead to subtle defects within
    your code. One advantage of (strongly typed) HLLs is that they can catch most
    program errors resulting from the misuse of data types. Assembly language, however,
    provides very little in the way of type checking. Type checking is *your* responsibility
    in assembly language. Section 4.4, “Pointer Data Types,” covers this issue next
    in great detail. Also see “Relocatable and Absolute Expressions” on [page 176](chapter4.xhtml#pg_176),
    which describes one of the few cases where Gas provides a small amount of type
    checking on your code.
  prefs: []
  type: TYPE_NORMAL
- en: '### 4.4 Pointer Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had a bad experience when you first encountered pointers in an HLL,
    fear not: pointers are easier to deal with in assembly language. Any problems
    you had with pointers probably had more to do with the linked-list and tree data
    structures you were trying to implement with them. Pointers, on the other hand,
    have many uses in assembly language that have nothing to do with linked lists,
    trees, and other scary data structures. Indeed, simple data structures like arrays
    and structs often involve the use of pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: A *pointer* is a memory location whose value is the address of another memory
    location. Unfortunately, HLLs like C/C++ tend to hide the simplicity of pointers
    behind a wall of abstraction. This added complexity tends to frighten programmers
    because they don’t understand what’s going on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illuminate how pointers work, consider the following array declaration in
    Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don’t know Pascal, the concept here is simple. M is an array with
    1,024 integers in it, indexed from M[0] to M[1023]. Each one of these array elements
    can hold an integer value independent of the others. In other words, this array
    gives you 1,024 integer variables, each of which you refer to by number (the array
    index).
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to see that the statement M[0]:=100; is storing the value 100 into
    the first element of the array M. The following two statements perform an identical
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, you can use any integer expression in the range 0 to 1,023 as an index
    into this array. The following statements still perform the same operation as
    our single assignment to index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '“Okay, so what’s the point?” you’re probably thinking. “Anything that produces
    an integer in the range 0 to 1,023 is legal. So what?” Consider the following
    code that adds an interesting layer of indirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With a little thought, you should see that these two instructions perform the
    exact same operation as the previous examples. The first statement stores 0 into
    array element M[1]. The second statement fetches the value of M[1], a legal array
    index, and uses that value (0) to control where it stores the value 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re willing to accept this as reasonable, you’ll have no problems with
    pointers. If you were to change M to *memory* and imagine that this array represents
    system memory, then M[1] is a pointer: that is, a memory location whose value
    is the address (or index) of another memory location. Pointers are easy to declare
    and use in an assembly language program; you don’t even have to worry about array
    indices.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this section has used a Pascal array as an example of a pointer, which
    is fine, but how do you use pointers in an ARM assembly language program?
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Pointer Usage in Assembly Language
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An ARM64 pointer is a 64-bit value that may contain the address of another
    variable. For a dword variable p that contains 0x1000_0000, p “points” at memory
    location 0x1000_0000\. To access the dword that p points at, you could use code
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By loading the value of p into X0, this code loads the value 0x1000_0000 into
    X0 (assuming p contains 0x1000_0000). The second instruction loads the X1 register
    with the dword starting at the location whose offset appears in X0\. Because X0
    now contains 0x1000_0000, this will load X1 from locations 0x1000_0000 through
    0x1000_0007.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just load X1 directly from location 0x1000_0000, like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The primary reason not to do so is that this ldr instruction always loads X1
    from location varAtAddress1000_0000. You cannot change the address from where
    it loads X1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The former instructions, however, always load X1 from the location where p
    is pointing. This is easy to change under program control. Consider the following
    pseudocode instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable p with the address of the variable i. The second
    path through the code loads p with the address of the variable j. Both execution
    paths converge on the last two ldr instructions that load X1 with i or j, depending
    on which execution path was taken. In many respects, this is like a parameter
    to a procedure in an HLL like Swift. Executing the same instructions accesses
    different variables depending on whose address (i or j) winds up in p.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Pointer Declarations in Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because pointers are 64 bits long, you could use the .dword directive to allocate
    storage for your pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in Gas. You may specify addresses of static variables (.data,
    .rodata, and .bss objects) in the operand field of a .dword directive, so you
    can initialize only pointer variables with the addresses of static objects by
    using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that macOS does not allow you to take the address of a symbol in the
    .text section because of the limitation of PIE code.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 Pointer Constants and Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas allows very simple constant expressions wherever a pointer constant is
    legal. Pointer constant expressions take one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The PureConstantExpression term is a numeric constant expression that does
    not involve any pointer constants (an *absolute constant*, using Gas terminology).
    This type of expression produces a memory address that is the specified number
    of bytes before or after (- or +, respectively) the StaticVarName variable in
    memory. The first two forms shown here are semantically equivalent: both return
    a pointer constant whose address is the sum of the static variable and the constant
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Since you can create pointer constant expressions, it should come as no surprise
    that Gas lets you define manifest pointer constants by using equates. Listing
    4-1 demonstrates how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The equate pb = bb + 2 initializes the constant pb with the address of the
    third element ❶ (index 2) of the bb array. The pbVar: .dword pb declaration ❷
    creates a pointer variable (named pbVar) and initializes with the value of the
    pb constant. Because pb is the address of bb[2], this statement initializes pbVar
    with the address of bb[2]. The program stores the value held in pbVar into the
    pbValue variable ❸, then passes pbVar ❹ and pbValue ❺ to printf() to print their
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The address that’s printed may vary on different machines and OSes.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.4 Pointer Variables and Dynamic Memory Allocation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pointer variables are the perfect place to store the return result from the
    C stdlib malloc() function. This function returns the address of the storage it
    allocates in the X0 register; therefore, you can store the address directly into
    a pointer variable immediately after a call to malloc(). Listing 4-2 demonstrates
    calls to the C stdlib malloc() and free() functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Because malloc() ❶ and free() ❷ have only a single argument, you pass those
    arguments to them in the X0 register. For the call to malloc(), you pass an integer
    value specifying the amount of storage you want to allocate on the heap. For free(),
    you pass the pointer to the storage (previously allocated by malloc()) that you
    want to return back to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the addresses you get will vary by OS and perhaps even by different
    runs of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5 Common Pointer Problems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In most programming languages, programmers encounter five common problems.
    Some of these errors will cause your programs to immediately stop with a diagnostic
    message; other problems are subtler, yielding incorrect results or simply affecting
    the performance of your program without otherwise reporting an error. These five
    problems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using an uninitialized pointer (illegal memory access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a pointer that contains an illegal value (for example, NULL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing to use malloc()’d storage after that storage has been freed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to free() storage once the program is finished using it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing indirect data using the wrong data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following subsections describe each of these problems, their effects, and
    how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5.1 Illegal Memory Access Due to an Uninitialized Pointer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Beginning programmers often don’t realize that declaring a pointer variable
    reserves storage only for the pointer itself; it does not reserve storage for
    the data that the pointer references. Therefore, you’ll run into problems if you
    attempt to dereference a pointer that does not contain the address of a valid
    memory location. Listing 4-3 demonstrates this problem (don’t try to compile and
    run this program; it will crash).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although variables you declare in the .data section are, technically, initialized,
    static initialization still doesn’t initialize the pointer in this program ❶ with
    a valid address (but instead with a 0, which is NULL).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is no such thing as a truly uninitialized variable on the ARM.
    There are variables that you’ve explicitly given an initial value, and there are
    variables that happen to inherit whatever bit pattern was in memory when storage
    for the variable was allocated. Much of the time, these garbage bit patterns don’t
    correspond to a valid memory address. Attempting to *dereference* such a pointer
    (that is, access the data in memory at which it points ❷) typically raises a *memory
    access violation* exception (segmentation fault).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse, since your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    overwrite the values of other important variables in memory. This defect can produce
    some difficult-to-locate problems in your program.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5.2 Invalid Addresses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second common problem is storing invalid address values into a pointer.
    The previous problem is actually a special case of this second problem (with garbage
    bits in memory supplying the invalid address, rather than you producing it via
    a miscalculation). The effects are the same: if you attempt to dereference a pointer
    containing an invalid address, you either will get a memory access violation exception
    or will access an unexpected memory location.'
  prefs: []
  type: TYPE_NORMAL
- en: '##### 4.4.5.3 The Dangling Pointer Problem'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third problem, continuing to use malloc()’d storage after that storage
    has been freed, is also known as the *dangling pointer problem*. To understand
    this problem, consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code allocates 256 bytes of storage and saves the address of that storage
    in the ptrVar variable. It then uses this block of 256 bytes for a while and frees
    the storage, returning it to the system for other uses.
  prefs: []
  type: TYPE_NORMAL
- en: Calling free() does not change the value of ptrVar in any way; ptrVar still
    points at the block of memory allocated by malloc() earlier. The value in ptrVar
    is a *dangling pointer*, or *wild pointer*—a pointer that is pointing at deallocated
    storage. In this example, free() does not change any data in the block allocated
    by malloc(), so upon return from free(), ptrVar still points at the data stored
    into the block by this code. However, the call to free() tells the system that
    the program no longer needs this 256-byte block of memory, so the system can use
    this region of memory for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The free() function cannot enforce the fact that you will never access this
    data again; you are simply promising that you won’t. Of course, the preceding
    code fragment breaks this promise; as you can see in the last three instructions,
    the program fetches the value in ptrVar and accesses the data it points at in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest problem with dangling pointers is that you can often get away with
    using them. As long as the system doesn’t reuse the storage you’ve freed, a dangling
    pointer produces no ill effects. However, with each new call to malloc(), the
    system may decide to reuse the memory released by that previous call to free().
    When this happens, any attempt to dereference the dangling pointer may produce
    unintended consequences. The problems range from reading data that has been overwritten
    (by the new, legal use of the data storage), to overwriting the new data, to,
    in the worst case, overwriting system heap management pointers and likely crashing
    your program. The solution is clear: *never use a pointer value after you free
    the storage associated with that pointer.*  ##### 4.4.5.4 Memory Leaks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the pointer problems listed at the beginning of this section, failing
    to free allocated storage will probably have the least negative impact. The following
    code fragment demonstrates this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the program allocates 256 bytes of storage and references it
    by using the ptrVar variable. Later, the program allocates another block of bytes
    and overwrites the value in ptrVar with the address of this new block. The former
    value in ptrVar is lost. Because the program no longer has this address value,
    there is no way to call free() to return the storage for later use.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, these 256 bytes of memory are no longer available to your program.
    While this may seem like only a minor cost, imagine that this code is in a repeating
    loop. With each execution of the loop, the program loses another 256 bytes of
    memory, eventually exhausting the memory available on the heap. This problem is
    often called a *memory leak*, because it’s as though the memory bits are leaking
    out of your computer during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory leaks are far less damaging than dangling pointers. They create only
    two problems: the danger of running out of heap space (which ultimately may cause
    the program to abort, though this is rare) and performance problems due to virtual
    memory page swapping. Nevertheless, you should get in the habit of always freeing
    all storage after you have finished using it. When your program quits, the OS
    reclaims all storage, including the data lost via memory leaks. Therefore, memory
    lost via a leak is lost only to your program, not to the whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5.5 Lack of Type-Safe Access
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because Gas cannot and does not enforce pointer type checking, you can load
    the address of a data structure into a register and access that data as though
    it were a completely different type (often resulting in logic errors in your program).
    For example, consider Listing 4-4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the commands to build and run the program in Listing 4-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Listing 4-4 reads data from the user as character values and then displays the
    data as double-word hexadecimal values. While assembly language lets you ignore
    data types at will and automatically coerce the data without any effort, this
    power is a double-edged sword. If you make a mistake and access indirect data
    by using the wrong data type, Gas and the ARM may not catch the mistake and your
    program may produce inaccurate results. Therefore, you need to ensure that you
    use data consistently with respect to data type when working with pointers and
    indirection in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This demonstration program has one fundamental flaw that could create a problem
    for you: when reading the last two characters of the input buffer, the program
    accesses data beyond the characters input by the user. If the user inputs 255
    characters (plus the zero-terminating byte that readLine() appends), this program
    will access data beyond the end of the buffer allocated by malloc(). In theory,
    this could cause the program to crash. This is yet another problem that can occur
    when accessing data by using the wrong type via pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite all the problems that pointers suffer from, they are essential for accessing
    common data structures such as arrays, structs, and strings. That’s why this chapter
    discussed pointers prior to these other *composite data types*. However, with
    the discussion of pointers out of the way, it’s time to look at those other data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Composite Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Composite data types*, also known as *aggregate data types*, are those that
    are built up from other, generally scalar, data types. A string, for example,
    is a composite data type, since it’s built from a sequence of individual characters
    and other data. The following sections cover several of the more important composite
    data types: character strings, arrays, multidimensional arrays, structs, and unions.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Character Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After integer values, character strings are probably the most common data type
    that modern programs use. This section provides a couple definitions of character
    strings (the ubiquitous zero-terminated string, the more efficient length-prefixed
    string, and other combinations of the two) and discusses how to process those
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a *character string* is a sequence of ASCII characters that possesses
    two main attributes: a length and character data. Different languages use different
    data structures to represent strings. For assembly language (at least, sans any
    library routines), you can choose to implement strings in whichever format you
    want—perhaps based on the format’s compatibility with an HLL or on a desire to
    produce faster string functions. All you need do is create a sequence of machine
    instructions to process the string data in whatever format the strings take.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible for strings to hold Unicode characters. This section uses
    ASCII in all the examples (because Gas does a better job of supporting ASCII characters).
    The principles apply to Unicode as well, with an appropriate extension in the
    amount of storage you use.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Zero-Terminated Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Zero-terminated strings are the most common string representation in use today,
    since this is the native string format for C, C++, and other languages. A *zero-terminated
    string* consists of a sequence of zero or more ASCII characters ending with a
    0 byte. For example, in C/C++, the string "abc" requires 4 bytes: the three characters
    a, b, and c, followed by a byte containing 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create zero-terminated strings in Gas, simply use the .asciz directive.
    The easiest place to do this is in the .data section, using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a character string appears in the .asciz directive, as it does here,
    Gas emits each character in the string to successive memory locations and terminates
    the whole string with a 0 byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to accommodate a zero-terminated string that’s longer
    than a single source line. First, you can use .ascii directives for all but the
    last source code line in a long string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The .asciz directive zero-terminates the entire string. However, if you prefer,
    you can always use a .byte directive to explicitly add the zero-terminating byte
    yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Use whichever scheme you like. Some people prefer the explicit .byte directive
    because it’s easy to add and remove strings from the list without having to worry
    about changing .ascii to .asciz (or vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero-terminated strings have two principal attributes: they are simple to implement,
    and the strings can be any length. However, they also have a few drawbacks. First,
    zero-terminated strings cannot contain the NUL character (whose ASCII code is
    0). Generally, this isn’t a problem, but it does create havoc once in a while.
    Second, many operations on zero-terminated strings are somewhat inefficient. For
    example, to compute the length of a zero-terminated string, you must scan the
    entire string looking for that 0 byte (counting characters up to the 0). The following
    program fragment demonstrates how to compute the length of the preceding string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code saves the initial string address (in X2), then subtracts the final
    pointer (just beyond the 0 byte) from the initial address to compute the length.
    The extra sub (by 1) is present because we don’t normally include the zero-terminating
    byte in the string’s length.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the time it takes to compute the length of the string is proportional
    to the length of the string; as the string gets longer, computing its length takes
    longer.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Length-Prefixed Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The length-prefixed string format overcomes some of the problems with zero-terminated
    strings. *Length-prefixed strings* are common in languages like Pascal; they generally
    consist of a length byte followed by zero or more character values. The first
    byte specifies the string length, and the following bytes (up to the specified
    length) are the character data. In a length-prefixed scheme, the string "abc"
    would consist of 4 bytes: 3 (the string length) followed by a, b, and c. You can
    create length-prefixed strings in Gas by using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    Gas automatically compute the string length for you.
  prefs: []
  type: TYPE_NORMAL
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (for example, string length) are more efficient when using length-prefixed strings.
    However, length-prefixed strings have their own drawbacks; most important, they
    are limited to a maximum of 255 characters in length (assuming a 1-byte length
    prefix).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you have a problem with a string-length limitation of 255 characters,
    you can always create a length-prefixed string by using any number of bytes for
    the length as you need. For example, the High-Level Assembler (HLA) uses a 4-byte
    length variant of length-prefixed strings, allowing strings up to 4GB long. (See
    section 4.11, “For More Information,” on [page 221](chapter4.xhtml#pg_221) for
    more on the HLA.) In assembly language, you can define string formats however
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create length-prefixed strings in your assembly language programs, you don’t
    want to manually count the characters in the string and emit that length in your
    code. It’s far better to have the assembler do this kind of grunt work for you
    by using the location counter operator (.), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The lpsLen operand subtracts 1 in the address expression because
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: also includes the length prefix byte, which isn’t considered part of the string
    length.
  prefs: []
  type: TYPE_NORMAL
- en: Gas does not require you to define lpsLen before using it as the operand field
    in the .byte directive. Gas is smart enough to go back and fill in the value after
    it is defined in the equate statement.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.3 String Descriptors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another common string format is a string descriptor. A *string descriptor* is
    typically a small data structure (see section 4.8, “Structs,” on [page 212](chapter4.xhtml#pg_212))
    that contains several pieces of data describing a string.
  prefs: []
  type: TYPE_NORMAL
- en: At a bare minimum, a string descriptor will probably have a pointer to the actual
    string data and a field specifying the number of characters in the string (that
    is, the string length). Other possible fields might include the number of bytes
    currently occupied by the string, the maximum number of bytes the string could
    occupy, the string encoding (for example, ASCII, Latin-1, UTF-8, or UTF-16), and
    any other information the string data structure’s designer could dream up.
  prefs: []
  type: TYPE_NORMAL
- en: By far, the most common descriptor format incorporates a pointer to the string’s
    data and a size field specifying the number of bytes currently occupied by that
    string data. Note that this particular string descriptor is not the same thing
    as a length-prefixed string. In a length-prefixed string, the length immediately
    precedes the character data itself. In a descriptor, the length and a pointer
    are kept together, and this pair is (usually) separate from the character data
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.4 Pointers to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, an assembly language program won’t directly work with strings appearing
    in the .data (or .text, .rodata, or .bss) section. Instead, the program will work
    with pointers to strings (including strings whose storage the program has dynamically
    allocated with a call to a function like malloc()). Listing 4-4 provided a simple
    (though broken) example. In such applications, your assembly code will typically
    load a pointer to a string into a base register and then use a second (index)
    register to access individual characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.5 String Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, few assemblers provide a set of string functions you can call
    from your assembly language programs. As an assembly language programmer, you’re
    expected to write these functions on your own. Fortunately, a couple of solutions
    are available if you don’t quite feel up to the task.
  prefs: []
  type: TYPE_NORMAL
- en: The first set of string functions you can call, without having to write them
    yourself, are the C stdlib string functions from the *string.h* header file in
    C. Of course, you’ll have to use C strings (zero-terminated strings) in your code
    when calling C stdlib functions, but this generally isn’t a big problem. Listing
    4-5 provides examples of calls to various C string functions, further described
    in [Appendix E](appendix-E.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output from Listing 4-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you could make a good argument that if all your assembly code does
    is call a bunch of C stdlib functions, you should have written your application
    in C in the first place. Most of the benefits of writing code in assembly language
    happen only when you “think” in assembly language, not C.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, you can dramatically improve the performance of your string function
    calls if you stop using zero-terminated strings and switch to another string format
    (such as length-prefixed or descriptor-based strings that include a length component).
    [Chapter 14](chapter14.xhtml) presents some pure assembly string functions for
    those who want to avoid the inefficiencies of using zero-terminated strings with
    the C stdlib.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Along with strings, arrays are probably the most commonly used composite data
    type. Yet most beginning programmers don’t understand their internal operation
    or their associated efficiency trade-offs. It’s surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractly, an *array* is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index
    (or other ordinal type such as Boolean or character). Different indices select
    unique elements of the array. This book assumes that the integer indices are contiguous,
    though this is by no means required. That is, if the number *x* is a valid index
    into the array and *y* is also a valid index, with *x* < *y*, then all *i* such
    that *x* < *i* < *y* are valid indices. Most HLLs use contiguous array indices,
    and they are the most efficient to use, hence their use here.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, A[i] chooses the *i*th element
    from array A. There is no formal requirement that element i be anywhere near element
    i + 1 in memory; the definition of an array is satisfied as long as A[i] always
    refers to the same memory location and A[i + 1] always refers to its corresponding
    location (and the two are different).
  prefs: []
  type: TYPE_NORMAL
- en: As noted, this book assumes that array elements occupy contiguous locations
    in memory. An array with five elements will appear in memory as shown in [Figure
    4-1](chapter4.xhtml#fig4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: An array layout in memory'
  prefs: []
  type: TYPE_NORMAL
- en: The *base address* of an array is the address of that array’s first element
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Indices are not required to start at 0\. They may start with any number as long
    as they are contiguous. However, for the purposes of discussion, this book starts
    all indices at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, Initial_Index is the value of the first index in the array (which you
    can ignore if it’s 0), and the value Element_Size is the size, in bytes, of an
    individual array element (this may include padding bytes used to keep elements
    properly aligned).
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.1 Declaring Arrays in Gas Programs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you’ve already
    seen. To allocate *n* elements in an array, you would use a declaration like the
    following in one of the variable declaration sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: ArrayName is the name of the array variable, n is the number of array elements,
    element_size is the size (in bytes) of a single element, and initial_value is
    the initial value to assign to each array element. The element_size and initial
    _value arguments are optional, defaulting to 1 and 0, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to declare an array of sixteen 32-bit words, you could use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This would set aside sixteen 4-byte words, each initialized with 0 (the default
    initial value).
  prefs: []
  type: TYPE_NORMAL
- en: The value for element_size must not exceed 8; if it does, Gas will clip the
    value to 8\. For historical (Gas) reasons, you should limit the initial value
    to 32 bits; larger values are transformed in nonintuitive ways (and differently
    on macOS and Linux). As a general rule, I strongly recommend defaulting to 0 for
    each array element when using the .fill directive.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you use the* .fill *directive in a* .bss *section, the initial value must
    be absent or set to 0.*'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the .fill directive is .space
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: where size is the number of bytes to allocate for the array and fill is an optional
    8-bit value that Gas will use to initialize each byte of the array. If the fill
    argument is absent, Gas uses a default value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an array of a type other than bytes, you must compute the size argument
    as numberOfElements × elementSize. For example, to create a 16-element array of
    words, you could use the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Because the fill argument is not present, Gas will initialize this array with
    bytes containing 0s. I recommend putting parentheses around the element size in
    the expression to better document your intent; this differentiates the element
    size from the element count. As you’ll see in section 4.7.4, “Implementing Multidimensional
    Arrays,” on [page 203](chapter4.xhtml#pg_203), the element count could be an expression
    based on the size of each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the base address of these arrays, just use ArrayName or wordArray
    in an address expression. If you prefer to initialize an array with different
    values in each of the elements, you must manually supply those values in the directives
    .byte, .hword, .word, .dword, and so on. Here’s a 16-word array initialized with
    the values 0 to 15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you need to initialize a large array with different values, you’re best off
    either writing an external program (perhaps in an HLL like C/C++) or using Gas’s
    macro facilities to generate the array. I discuss this further in [Chapters 10](chapter10.xhtml)
    and [13](chapter13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '#### 4.7.2 Accessing Elements of a Single-Dimensional Array'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element of a zero-based array, use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the array is located within your .text section (an array of constants), or
    if you’re writing a Linux application and the array isn’t farther than ±1MB from
    your code that accesses the array, you can use the array’s name for the Base_Address
    entry. This is because Gas associates the address of the first element of an array
    with the name of that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you’ll need to load the base address of the array into a 64-bit
    register. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The Element_Size entry is the number of bytes for each array element. If the
    object is an array of bytes, the Element_Size field is 1 (resulting in a very
    simple computation). If each element of the array is a half word (or other 2-byte
    type), then Element_Size is 2, and so on. To access an element of the wordArray
    array in the previous section, you’d use the following formula (the size is 4
    because each element is a word object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The ARM code equivalent to the statement w0 = wordArray[index] is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction sequence does not explicitly compute the sum of the base address
    plus the index times 4 (the size of a 32-bit integer element in wordArray). Instead,
    it relies on the scaled-indexed addressing mode (the uxtx #2 operand) to implicitly
    compute this sum. The instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: loads W0 from location X2 + W1 * 4, which is the base address plus index * 4
    (because W1 contains index).
  prefs: []
  type: TYPE_NORMAL
- en: To multiply by a constant other than 1, 2, 4, or 8 (the immediate shift constants
    possible with the scaled-indexed addressing mode), you’ll need to use the lsl
    instruction to multiply by the element size (if multiplying by a power of 2) or
    the mul instruction. You’ll see some examples in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The scaled-indexed addressing mode on the ARM is the natural addressing mode
    for accessing elements of a single-dimensional array. Make sure you remember to
    multiply the index by the size of an element; failure to do so will produce incorrect
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section assume that the index variable is a 32-bit value,
    which is common for array indices. To use a smaller integer, you’d need to sign-
    or zero-extend it to 32 bits. To use a 64-bit integer, simply adjust the scaled-indexed
    addressing mode to use a 64-bit index register and use the shift-left scaling
    without zero or sign extension.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.3 Sorting an Array of Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When introducing arrays, books commonly introduce sorting the elements of an
    array. To acknowledge this historical precedent, this section takes a quick look
    at a simple sort in Gas. The program presented in this section uses a variant
    of the bubble sort, which is great for short lists of data and lists that are
    nearly sorted, but horrible for just about everything else. However, a bubble
    sort is easy to implement and understand, which is why this and other introductory
    texts continue to use it in examples.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the relative complexity of Listing 4-6, I’ll insert comments throughout
    the source code rather than explaining it at the end. We begin by including *aoaa.inc*,
    as usual.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Right away, let’s make some coding improvements as compared to many of the previous
    examples in this book. Those examples, such as Listing 4-1, used “magic” numbers,
    like 64 for the amount of stack space to allocate and 56 for the offset into the
    stack allocation where I preserve the LR register. I used these literal constants
    directly in the code to be as transparent as possible; however, good programming
    style demands the use of symbolic names in place of those magic numbers. The two
    equates below accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The next couple of statements in the source file define offsets into the stack
    frame (allocated storage on the stack) where the program can preserve register
    values. In all the example programs so far, I’ve placed (global) variables in
    memory locations. That’s not the appropriate paradigm for RISC assembly language
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM ABI reserves registers X19 through X28 for use as nonvolatile (permanent)
    variable storage. *Nonvolatile* means you can call functions (like printf()) without
    worrying about those registers’ values being changed. The drawback to using nonvolatile
    registers is that you have to preserve their values upon entry into your code.
    The following two equates specify the offset into the stack allocation area for
    register preservation. This code will use registers X19 and X20 as loop control
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining equates define other constants used in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next come the usual read-only and writable data sections. In particular, the
    .data section contains the sortMe array, which will be the subject of the sorting
    operation. Also, this block of statements contains the getTitle function required
    by the *c.cpp* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get to the bubble-sort function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The bubble-sort function could just use register names like X0, X1, W2, and
    X3 for all the local variables. However, the following #define statements let
    you use more meaningful names. X5, X6, and X7 are pure temporaries (no meaningful
    name is attached to them), so this code continues to use the ARM register names
    for these temporary or local objects. Technically, X0 through X7 are reserved
    for parameters. As the sort function has only two parameters (array and count),
    it uses X2 through X7 as local variables (which is fine, as these registers are
    volatile, according to the ARM ABI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The count parameter just defined contains the number of array elements (which
    will be 16 in the main program). Since it’s more convenient for this to be a byte
    count rather than a (word) element count, the following code multiplies count
    (X1) by 4, using a shift left by 2. Also, the loop executes count –1 times, so
    this code also preps count by subtracting 1 from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The bubble sort works by making count – 1 passes through the array, where count
    is the number of elements. On each pass, it compares each adjacent pair of array
    elements; if the first element is greater than the second one, the program swaps
    them. At the end of each pass, one element winds up being moved to its final position.
    As an optimization, if no swaps occur, then all the elements are already in place,
    so the sort terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The main program begins by preserving the nonvolatile registers (LR, X19, and
    X20) that it uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the main program calls the sort function to sort the array. As per the
    ARM ABI, this program passes the first argument (the address of the array) in
    X0 and the second argument (element count) in X1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once sort has finished, the program executes a loop to display the 16 values
    in the array. This loop uses the nonvolatile registers X19 and X20 to hold the
    base address of the array and the loop index, so these values don’t have to be
    reloaded on each iteration of the loop. Because they are nonvolatile, we know
    that printf() won’t disturb their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the output is complete, the main program must restore the nonvolatile
    registers before returning to the C++ program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You could slightly optimize this program by using the stp and ldp instructions
    to preserve both X19 and X20\. To emphasize saving and restoring both registers
    as independent operations, I didn’t make that optimization here. However, you
    should get in the habit of optimizing your code in this manner in order to reap
    the benefits of using assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output for Listing 4-6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, the
    bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (or, worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. [Chapter 5](chapter5.xhtml) provides
    an example of a more efficient sorting algorithm, quicksort, in ARM assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4 Implementing Multidimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM hardware can easily handle single-dimensional arrays. Unfortunately,
    however, accessing elements of *multidimensional arrays* takes some work and several
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing how to declare or access multidimensional arrays, I’ll show
    you how to implement them in memory. First, how do you store a multidimensional
    object into a one-dimensional memory space? Consider for a moment a Pascal array
    of this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This array contains 16 bytes organized as four rows of four characters. Somehow,
    you have to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-2](chapter4.xhtml#fig4-2) shows
    one way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Mapping a 4×4 array to sequential memory locations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual mapping is not important as long as two things occur: (1) each element
    maps to a unique memory location (no two entries in the array occupy the same
    memory locations), and (2) the mapping is consistent (a given element in the array
    always maps to the same memory location). Therefore, you need a function with
    two input parameters (row and column) that produces an offset into a linear array
    of 16 memory locations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any function that satisfies these constraints will work fine. Indeed, you could
    randomly choose a mapping, as long as it’s consistent. However, you really want
    a mapping that is efficient to compute at runtime and that works for any size
    array (not just 4×4 or even limited to two dimensions). While many possible functions
    fit this bill, two in particular are used by most programmers and HLLs: row-major
    ordering and column-major ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4.1 Row-Major Ordering
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Row-major ordering* assigns successive elements, moving across the rows and
    then down the columns, to successive memory locations. [Figure 4-3](chapter4.xhtml#fig4-3)
    demonstrates this mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Row-major ordering of array elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Row-major ordering is the method most HLLs employ. It is easy to implement
    and use in machine language: you start with the first row (row 0) and then concatenate
    the second row to its end. You then concatenate the third row to the end of the
    list, then the fourth row, and so on (see [Figure 4-4](chapter4.xhtml#fig4-4)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: Another view of row-major ordering for a 4×4 array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that converts a list of index values into an offset is a slight
    modification of the formula for computing the address of an element of a single-dimensional
    array. The formula to compute the offset for a two-dimensional row-major ordered
    array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, Base_Address is the address of the first element of the array (A[0][0]
    in this case), and Element_Size is the size of an individual element of the array,
    in bytes. colindex is the leftmost index, and rowindex is the rightmost index
    into the array. row_size is the number of elements in one row of the array (4,
    in this case, because each row has four elements). Assuming Element_Size is 1,
    this formula computes the following offsets from the base address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: col_size is the number of items in a column, and row_size is the number of items
    in a row.
  prefs: []
  type: TYPE_NORMAL
- en: In C/C++, if you’ve declared the array as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: then row_size is equal to k and col_size is equal to j.
  prefs: []
  type: TYPE_NORMAL
- en: For a four-dimensional array, declared in C/C++ as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'the formula for computing the address of an array element is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: depth_size is equal to j, col_size is equal to k, and row_size is equal to m.
    LeftIndex represents the value of the leftmost index.
  prefs: []
  type: TYPE_NORMAL
- en: By now you’re probably beginning to see a pattern. A generic formula will compute
    the offset into memory for an array with *any* number of dimensions; however,
    you’ll rarely use more than four.
  prefs: []
  type: TYPE_NORMAL
- en: Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: where sometype is the type sometype = array [0..3] of char; and A is a single-dimensional
    array. Its individual elements happen to be arrays, but you can safely ignore
    that for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the formula to compute the address of an element in a single- dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Element_Size happens to be 4 because each element of A is an array
    of four characters. Therefore, this formula computes the base address of each
    row in this 4×4 array of characters (see [Figure 4-5](chapter4.xhtml#fig4-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Viewing a 4×4 array as an array of arrays'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn’t affect
    the computation, it’s probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Pascal array defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view this five-dimensional array as a single-dimensional array of arrays.
    The following Pascal code provides such a definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of OneD is 4 bytes. Because TwoD contains four OneD arrays, its size
    is 16 bytes. Likewise, ThreeD is four TwoDs, so it is 64 bytes long. Finally,
    FourD is four ThreeDs, so it is 256 bytes long. To compute the address of A[b,
    c, d, e, f], you could use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Compute the address of A[b] as Base + b × size. Here size is 256 bytes.
    Use this result as the new base address in the next computation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Compute the address of A[b, c] by the formula Base + c × size, where Base
    is the value obtained in the previous step and size is 64\. Use the result as
    the new base in the next computation.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compute the base address of A [b, c, d] by Base + d × size, where Base comes
    from the previous computation and size is 16\. Use the result as the new base
    in the next computation.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Compute the address of A[b, c, d, e] with the formula Base + e × size, using
    Base from the previous step and a size of 4\. Use this value as the base for the
    next computation.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Finally, compute the address of A[b, c, d, e, f] by using the formula Base
    + f × size, where Base comes from the previous computation and size is 1 (obviously,
    you can ignore this final multiplication). The result you obtain at this point
    is the address of the desired element.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons you won’t find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It’s easy to enter something like A[b, c, d, e, f] into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4.2 Column-Major Ordering
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Column-major ordering* is the other function HLLs frequently use to compute
    the address of an array element. FORTRAN and various dialects of BASIC (for example,
    older versions of Microsoft BASIC) use this method.'
  prefs: []
  type: TYPE_NORMAL
- en: In row-major ordering, the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering, the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-6](chapter4.xhtml#fig4-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Column-major ordering of array elements'
  prefs: []
  type: TYPE_NORMAL
- en: The formula for computing the address of an array element when using column-major
    ordering is similar to that for row-major ordering. You reverse the indices and
    sizes in the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a two-dimensional column-major array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'For a three-dimensional column-major array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For a four-dimensional column-major array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The formulas for higher-dimension arrays progress in a like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4.3 Storage Allocation for Multidimensional Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you have an *m*×*n* array, it will have *m* × *n* elements and require *m*
    × *n* × Element_Size bytes of storage. To allocate storage for an array, you must
    reserve this memory. As usual, you can accomplish this task in several ways. The
    most common way to declare a multidimensional array in Gas is to use the .space
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, size1 to sizen are the sizes of each of the dimensions of the array, and
    (Element_Size) is the size (in bytes) of a single element. I recommend putting
    parentheses around the Element_Size component of this expression to emphasize
    that it is not another dimension in the multidimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a declaration for a 4×4 array of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings (assuming the array holds 64-bit pointers to the strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'As with single-dimensional arrays, you may initialize every element of the
    array to a specific value by following the declaration with the values of the
    array constant. Array constants ignore dimension information; all that matters
    is that the number of elements in the array constant corresponds to the number
    of elements in the actual array. The following example shows the GameGrid declaration
    with an initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This example was laid out to enhance readability. Gas does not interpret the
    four separate lines as representing rows of data in the array; humans do, which
    is why it’s good to write the data in this manner. If you have a large array,
    an array with really large rows, or an array with many dimensions, there is little
    hope for winding up with something readable; in this case, comments that carefully
    explain everything come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a constant expression to compute the number of array elements rather
    than simply using the constant 16 (4 × 4) more clearly suggests that this code
    is initializing each element of a 4×4 element array than does the simple literal
    constant 16.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4.4 How to Access Elements of Multidimensional Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To access elements of a multidimensional array, you’ll need to be able to multiply
    two values; this is done using the mul (multiply) and madd (multiply and add)
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The mul and madd instructions have the following syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: where regd is the destination register (32 or 64 bits), regl and regr are source
    registers (left- and right-hand operands), and rega is a third source operand.
    These instructions perform the calculations described in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions do not have a form with an s suffix and therefore do not
    update the flags after their execution. An *n*-bit × *n*-bit multiplication can
    produce a 2 × *n* bit result; however, these instructions maintain only *n* bits
    in the destination register. Any overflow is lost. Sadly, these instructions do
    not allow immediate operands, though this would be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The multiply instruction has several other variants that are used for other
    purposes. These are covered in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen the formulas for computing the address of a multidimensional
    array element, it’s time to see how to access elements of those arrays with assembly
    language. The ldr, lsl, and mul/madd instructions make short work of the various
    equations that compute offsets into multidimensional arrays. First, consider a
    two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider a second example that uses a three-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the madd instruction to multiply the value in W0 by 5 and add
    in the k index at the same time. Because the lsl instruction can multiply a register
    by only a power of 2, we must resort to a multiplication here. While there are
    ways to multiply the value in a register by a constant other than a power of 2,
    the madd instruction is more convenient, especially as it handles an addition
    operation at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another major composite data structure is the Pascal *record* or C/C++/C# *struct*.
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. However, this book uses the term
    *struct*, as C-based languages are more commonly used these days. (Records and
    structures also go by other names in other languages, but most people recognize
    at least one of these names.)
  prefs: []
  type: TYPE_NORMAL
- en: Whereas an array is homogeneous, with elements that are all the same type, the
    elements in a struct can have different types. Arrays let you select a particular
    element via an integer index. With structs, you must select an element, known
    as a *field,* by offset (from the beginning of the struct).
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole purpose of a struct is to let you encapsulate different, though logically
    related, data into a single package. The Pascal record declaration for a hypothetical
    student is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name, the next
    2 bytes hold the Major code (assuming a 16-bit integer), the next 12 bytes hold
    the Social Security number, and so on. (Strings require an extra byte, in addition
    to all the characters in the string, to encode the length.) The John variable
    declaration allocates 89 bytes of storage laid out in memory, as shown in [Figure
    4-7](chapter4.xhtml#fig4-7) (assuming no padding or alignment of fields).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: Student data structure in memory'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the label John corresponds to the base address of this record, the sName
    field is at offset John + 0, the Major field is at offset John + 65, the SSN field
    is at offset John + 67, and so on. In assembly language, if X0 holds the base
    address of the John structure, you could access the Major field by using the following
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This loads W0 with the 16-bit value at the address specified by John + 65.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 4.8.1 Dealing with Limited Gas Support for Structs'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Gas provides only the smallest amount of support for structures
    via the .struct directive (see “Linux .struct Directive” on [page 217](chapter4.xhtml#pg_217)).
    Even more unfortunately, the macOS assembler doesn’t support .struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use structures under macOS and Linux together, you’ll need a way to specify
    the offsets to all the fields of a structure for use in the register indirect-plus-offset
    addressing mode (such as in the last example line of the previous section). In
    theory, you could manually use equates to define all the offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: However, this is an absolutely horrible, error-prone, and difficult-to-maintain
    approach. The ideal method would be to supply a structure name (the type name)
    and a list of the field names and their types. From this, you’d aim to get offsets
    for all the fields, plus the size of the entire structure (which you can use with
    the .space directive to allocate storage for the structure).
  prefs: []
  type: TYPE_NORMAL
- en: The *aoaa.inc* include file contains several macro definitions that can help
    you declare and use structures in your assembly language source files. These macros
    aren’t amazingly robust, but when used carefully, they get the job done. [Table
    4-1](chapter4.xhtml#tab4-1) lists these macros and their arguments. Field names
    must be unique throughout the program, not just in the structure definition. Also
    note that the struct/ends macros do not support nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: The aoaa.inc Macros for Defining Structures'
  prefs: []
  type: TYPE_NORMAL
- en: '| Macro | Argument(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| struct | name, offset | Begin a structure definition. The offset field is
    optional and can be either a (small) negative number or 0\. The default (and most
    commonly used) value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| ends | name | Ends a structure definition. The name argument must match the
    name supplied in the struct invocation. |'
  prefs: []
  type: TYPE_TB
- en: '| byte | name, elements | Create a field of type byte. name is the unique field
    name. elements is optional (default value is 1) and specifies the number of array
    elements. |'
  prefs: []
  type: TYPE_TB
- en: '| hword | name, elements | Create a field of type hword. name is the (unique)
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| word | name, elements | Create a field of type word. name is the unique field
    name. elements is optional (default value is 1) and specifies the number of array
    elements. |'
  prefs: []
  type: TYPE_TB
- en: '| dword | name, elements | Create a field of type dword. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| qword | name, elements | Create a field of type qword. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| single | name, elements | Create a field of type single. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| double | name, elements | Create a field of type double. name is the unique
    field name. elements is optional (default value is 1) and specifies the number
    of array elements. |'
  prefs: []
  type: TYPE_TB
- en: For strings, you’d specify either a dword field (to hold a pointer to the field)
    or a byte field with a sufficient number of elements to hold all the characters
    in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The student example from the previous section could be encoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You would declare a variable of type student like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The ends macro automatically generates a macro with the same name as the structure
    name, so you can use that like a directive to allocate sufficient space to hold
    an instance of the structure type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could access fields of John as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro package has a couple of issues. First of all, the field names must
    be unique throughout the assembly language source file (unlike standard structures,
    where the field names are local to the structure itself). As a result, these structures
    tend to suffer from *namespace pollution*, which happens when you try to reuse
    some of the field names for other purposes. For example, sName will likely be
    used again elsewhere in the source file, since it’s a common identifier. A quick-and-dirty
    solution to this problem is to always prefix the field names with the structure
    name and a period. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This requires a bit more typing, but it resolves the namespace pollution issue
    most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the student John macro invocation/declaration given in this section.
    This macro expands into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: where student.size is an extra field that the struct macro generates, specifying
    the total size of the structure (in bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The struct macro accepts a second (optional) parameter: the *starting offset*
    for fields in the structure. By default, this is 0\. If you supply a negative
    number here, the directive/macro that struct generates works a little differently.
    Consider the following structure definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: HLA strings are actually a bit different from the structure provided here, but
    this does serve as a good example of negative starting offsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLAstring macro that struct generates does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This expansion places the myString label after the first 4 bytes of the beginning
    of the structure. This is because the HLAstring.len field’s offset is –4, meaning
    that the length field starts 4 bytes before the base address of the structure
    (and the structure variable’s name is always associated with the base address).
    You’ll see some important uses for this feature in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The struct macro does not allow positive offsets (values greater than 0). It
    will generate an error at assembly time if you specify a positive value.
  prefs: []
  type: TYPE_NORMAL
- en: One issue with the struct macro is that it doesn’t provide a way to initialize
    the fields of the structure. To learn how to do that, keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.2 Initializing Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The struct macro definitions do not provide any way to initialize the fields
    of a structure at compile time. You’ll have to either assign the values at runtime
    or manually build up the structure variable by using Gas directives. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This initializes the fields of the structure to the corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.3 Creating Arrays of Structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A common pattern in program design is to create an array of structures. To
    do so, create a struct type and multiply its size by the number of array elements
    when declaring the array variable, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of this array, use the standard array-indexing techniques.
    Because class is a single-dimensional array, you’d compute the address of an element
    of this array by using the formula baseAddress + index × student.size. For example,
    to access an element of class, you’d use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You must sum in the offset to the field you want to access. Sadly, the scaled-indexed
    addressing mode doesn’t include an offset component as part of the addressing
    mode, but madd saves us an instruction by working in this addition as part of
    the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, you can create multidimensional arrays of structs as well, using
    the row-major or column-major order functions to compute the address of an element
    within such structs. The only real change is that the size of each element is
    the size of the struct object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates how to access fields of an array of structs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.4 Aligning Fields Within a Struct
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To achieve maximum performance in your programs, or to ensure that Gas structures
    properly map to records or structures in an HLL, you will often need to be able
    to control the alignment of fields within a struct. For example, you might want
    to ensure that a double-word field’s offset is a multiple of 4\. You can use the
    salign macro to do this. The following creates a structure with aligned fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As for the .align directive, the salign macro aligns the structure’s offset
    to 2*^n*, where *n* is the value specified as the salign argument. In this example,
    c’s offset is set to 4 (the macro rounds up the field offset from 1 to 4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Field alignment is up to you when you’re creating your own structure variables.
    However, if you’re linking with code written in an HLL that uses structures, you’ll
    need to determine field alignment for that particular language. Most modern HLLs
    use *natural alignment*: fields are aligned on a boundary that is the size of
    that field (or an element of that field). The structure itself is aligned at an
    address rounded to the size of the largest object in the structure. See section
    4.11, “For More Information,” on [page 221](chapter4.xhtml#pg_221) for appropriate
    links.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unions* (in an HLL like C/C++) are similar to structures insofar as they create
    an aggregate data type containing several fields. Unlike structures, however,
    the fields of a union all occupy the same offset in the data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers typically use unions for one of two reasons: to conserve memory
    or to create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, consider the following struct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: If you declare a variable, say n, of type numericRec, you access the fields
    as n.i, n.u, and n.q. A struct assigns different offsets to each field, effectively
    allocating separate storage to each field. A union, on the other hand, assigns
    the same offset (typically 0) to each of these fields, allocating the same storage
    to each.
  prefs: []
  type: TYPE_NORMAL
- en: For struct, then, numericRec.size is 16 because the struct contains two word
    fields and a double-word field. The size of the corresponding union, however,
    would be 8\. This is because all the fields of a union occupy the same memory
    locations, and the size of a union object is the size of the largest field of
    that object (see [Figure 4-8](chapter4.xhtml#fig4-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: The layout of a union versus a structure variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs use unions for several purposes: preserving memory, overlaying data
    types, and creating *variant types* (dynamically typed values whose type can change
    during execution). Because you probably won’t use unions that often in an assembly
    language program, I’ve not bothered creating a union macro in the *aoaa.inc* include
    file. However, if you really need a union macro, you could take the information
    in [Chapter 13](chapter13.xhtml) and the source code to the struct macro in *aoaa.inc*
    and write your own.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.10 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter concludes the machine organization component of this book, which
    dealt with the organization of memory, constants, data, and data types. It discussed
    memory variables and data types, arrays, row-major and column-major ordering,
    structs and unions, and strings, including zero-terminated, length-prefixed, and
    descriptor-based strings. It also covered issues you may encounter when using
    pointers, including uninitialized pointers, illegal pointer values, dangling pointers,
    memory leaks, and type-unsafe access.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to begin studying assembly language *programming* in earnest.
    The next section of the book will begin discussing procedures and functions ([Chapter
    5](chapter5.xhtml)), arithmetic ([Chapter 6](chapter6.xhtml)), low-level control
    structures ([Chapter 7](chapter7.xhtml)), and advanced arithmetic ([Chapter 8](chapter8.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For additional information about data structure representation in memory, consider
    reading my book *Write Great Code*, Volume 1, 2nd edition (No Starch Press, 2020).
    For an in-depth discussion of data types, consult a textbook on data structures
    and algorithms such as *Introduction to Algorithms*, 3rd edition (MIT Press, 2009),
    by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find information about the GNU assembler (including the .struct directive)
    in the manual at *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As noted in [Chapter 3](chapter3.xhtml), you can find more information about
    ARM CPUs at the developer website at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*.
    To learn more about field alignment in particular, see *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/dui0491<wbr>/i<wbr>/C<wbr>-and<wbr>-C<wbr>-<wbr>-<wbr>-Implementation<wbr>-Details<wbr>/Structures<wbr>-<wbr>-unions<wbr>-<wbr>-enumerations<wbr>-<wbr>-and<wbr>-bitfields<wbr>?lang<wbr>=en](https://developer.arm.com/documentation/dui0491/i/C-and-C---Implementation-Details/Structures--unions--enumerations--and-bitfields?lang=en)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on dangling pointers, see *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Dangling<wbr>_pointer](https://en.wikipedia.org/wiki/Dangling_pointer)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on the High-Level Assembler, see the online resources at my website,
    *[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
